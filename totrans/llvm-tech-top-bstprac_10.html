<html><head></head><body>
		<div id="_idContainer025">
			<h1 id="_idParaDest-104"><em class="italic"><a id="_idTextAnchor108"/>Chapter 8</em>: Working with Compiler Flags and Toolchains</h1>
			<p>In the previous chapter, we learned how to process Clang's AST – one of the most common formats for analyzing programs. In addition, we learned how to develop an AST plugin, which is an easy way to insert custom logic into the Clang compilation pipeline. This knowledge will help you augment your skillset for tasks such as source code linting or finding potential security vulnerabilities.</p>
			<p>In this chapter, we are ascending from specific subsystems and looking at the bigger picture – the compiler <strong class="bold">driver</strong> and <strong class="bold">toolchain</strong> that orchestrate, configure, and run individual LLVM and Clang components according to users' needs. More specifically, we will focus on how to add new compiler flags and how to create a custom toolchain. As we mentioned in <a href="B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Clang's Architecture</em>, compiler drivers and toolchains are often under-appreciated and have long been ignored. However, without these two important pieces of software, compilers will become extremely difficult to use. For example, users need to pass over <em class="italic">10</em> different compiler flags merely to build a simple <em class="italic">hello world</em> program, owing to the lack of flag translation. Users also need to run at least three different kinds of tools in order to create an executable to run, since there are no drivers or toolchains to help us invoke <em class="italic">assemblers</em> and <em class="italic">linkers</em>. In this chapter, you will learn how compiler drivers and toolchains work in Clang and how to customize them, which is extremely useful if you want to support Clang on a new operating system or architecture.</p>
			<p>In this section, we will cover the following topics:</p>
			<ul>
				<li>Understanding drivers and toolchains in Clang</li>
				<li>Adding custom driver flags</li>
				<li>Adding a custom toolchain</li>
			</ul>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor109"/>Technical requirements</h1>
			<p>In this chapter, we are still relying on the <strong class="source-inline">clang</strong> executable, so make sure you build it,  like this:</p>
			<p class="source-code">$ ninja clang</p>
			<p>Since we are working with a driver, as we mentioned in <a href="B14590_05_Final_JC_ePub.xhtml#_idTextAnchor067"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Clang's Architecture</em>, you can use the <strong class="source-inline">-###</strong> command-line option to print out the frontend flags that have been translated from the driver, like so:</p>
			<p class="source-code">$ clang++ <strong class="bold">-###</strong> -std=c++11 -Wall hello_world.cpp -o hello_world</p>
			<p class="source-code">"/path/to/clang" "-cc1" "-triple" "x86_64-apple-macosx11.0.0" "-Wdeprecated-objc-isa-usage" "-Werror=deprecated-objc-isa-usage" "-Werror=implicit-function-declaration" "-emit-obj" "-mrelax-all" "-disable-free" "-disable-llvm-verifier" … "-fno-strict-return" "-masm-verbose" "-munwind-tables" "-target-sdk-version=11.0" … "-resource-dir" "/Library/Developer/CommandLineTools/usr/lib/clang/12.0.0" "-isysroot" "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk" "-I/usr/local/include" "-stdlib=libc++" … "-Wall" "-Wno-reorder-init-list" "-Wno-implicit-int-float-conversion" "-Wno-c99-designator" … "-std=c++11" "-fdeprecated-macro" "-fdebug-compilation-dir" "/Users/Rem" "-ferror-limit" "19" "-fmessage-length" "87" "-stack-protector" "1" "-fstack-check" "-mdarwin-stkchk-strong-link" … "-fexceptions" … "-fdiagnostics-show-option" "-fcolor-diagnostics" "-o" "/path/to/temp/hello_world-dEadBeEf.o" "-x" "c++" "hello_world.cpp"…</p>
			<p>Using this flag will <em class="italic">not</em> run the rest of the compilation but merely execute the driver and toolchain. This makes it a good way to verify and debug specific flags and check they are correctly propagated from the driver to the frontend.</p>
			<p>Last but not least, in the last section of this chapter, <em class="italic">Adding a custom toolchain</em>, we will work on a project that can only run on Linux systems. Also, please install OpenSSL beforehand. It is usually available as a package in most Linux systems. For example, on Ubuntu, you can use the following command to install it:</p>
			<p class="source-code">$ sudo apt install <strong class="bold">openssl</strong></p>
			<p>We are only using the command-line utility, so there's no need to install any OpenSSL libraries that are normally used for development.</p>
			<p>The code that will be used in this chapter can be found here: <a href="https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter08">https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices-Clang-and-Middle-End-Libraries/tree/main/Chapter08</a>.</p>
			<p>In the first section of this chapter, we will provide a brief introduction to Clang's driver and toolchain infrastructure.</p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor110"/>Understanding drivers and toolchains in Clang</h1>
			<p>Before we<a id="_idIndexMarker331"/> talk about the compiler <a id="_idIndexMarker332"/>driver in Clang, it is necessary to highlight the <a id="_idIndexMarker333"/>fact that <em class="italic">compiling a piece of code</em> is never a <em class="italic">single</em> task (and not a simple one, either). In school, we were taught that a compiler consists of a <strong class="bold">lexer</strong>, a <strong class="bold">parser</strong>, sometimes came with an <strong class="bold">optimizer</strong>, and ended with an <strong class="bold">assembly code printer</strong>. While you still can see these stages in real-world compilers, they <a id="_idIndexMarker334"/>give you nothing but textual assembly code rather than an executable or library, as we would normally expect. Furthermore, this naïve compiler only provides limited flexibility – it can't be ported to any other operating systems or platforms.</p>
			<p>To make this toy compiler more realistic and usable, many other <em class="italic">plumber</em> tools need to be put together, along with the core compiler: an <strong class="bold">assembler</strong> to<a id="_idIndexMarker335"/> transform assembly code into (binary format) object file, a <strong class="bold">linker</strong> to <a id="_idIndexMarker336"/>put multiple object files into an executable or library, and many other routines to resolve platform-specific configurations, such as data<a id="_idIndexMarker337"/> width, default header file paths, or <strong class="bold">Application Binary Interfaces</strong> (<strong class="bold">ABIs</strong>). Only with help from these <em class="italic">plumbers</em> can we use a compiler by just typing a few words:</p>
			<p class="source-code">$ clang hello_world.c -o hello_world</p>
			<p>A <strong class="bold">compiler driver</strong> is <a id="_idIndexMarker338"/>software that organizes these <em class="italic">plumber</em> jobs. Despite having multiple different tasks to do during the compilation, we will only focus on two of the most important ones in this chapter – handling compiler flags and invoking the right tools on different platforms – which is what toolchains are designed for.</p>
			<p>The<a id="_idIndexMarker339"/> following <a id="_idIndexMarker340"/>diagram shows the interactions between the driver, the<a id="_idIndexMarker341"/> toolchains, and <a id="_idIndexMarker342"/>the rest of the compiler:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_8.1_B14590.jpg" alt="Figure 8.1 – Typical workflow of Clang's driver, toolchains, and the rest of the compiler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Typical workflow of Clang's driver, toolchains, and the rest of the compiler</p>
			<p>As shown in the preceding diagram, Clang's driver acts as <a id="_idIndexMarker343"/>a <em class="italic">dispatcher</em> and distributes flags and workloads to each of the compilation phases, namely the frontend/backend, the assembler, and the linker. To give you a more concrete idea of what the flags for each of these phases look like, recall the <strong class="source-inline">-###</strong> compiler option we introduced at the beginning of this chapter. The (massive amount of) content that's printed by that option is the flags for the frontend (<strong class="bold">4</strong> in the preceding screenshot). For example, among those frontend flags, <strong class="source-inline">-internal-isystem</strong> carries the information about the system header path, including the path where the C/C++ standard library header files are stored. It is obvious that Clang's frontend needs to know where the standard library headers are stored, but as per your past experiences of using <strong class="source-inline">clang</strong> (or <strong class="source-inline">gcc</strong>), you rarely <a id="_idIndexMarker344"/>need to tell them where those headers are <em class="italic">explicitly</em> – the driver will do that for you. The same logic applies to the linking phase as well. Linkers usually need <a id="_idIndexMarker345"/>more than just an object file to properly generate an executable or a library. For example, they need to know where the C/C++ standard library's library files (<strong class="source-inline">*.a</strong> or <strong class="source-inline">*.so</strong> on Unix/Linux systems) are. In that case, Clang's driver will provide that information to the linkers via linker flags.</p>
			<p>Flags and workloads – or <em class="italic">configurations</em>, in short – that<a id="_idIndexMarker346"/> are provided to individual compiler <a id="_idIndexMarker347"/>phases are <em class="italic">translated</em> from two sources: driver flags (<strong class="bold">2</strong> in the preceding diagram) and the selected toolchain (<strong class="bold">3</strong> in the preceding diagram). Driver flags are those provided by users via the command-line interface – that is, the <em class="italic">compiler flags</em>– such as <strong class="source-inline">-c</strong>, <strong class="source-inline">-Wall</strong>, and <strong class="source-inline">-std=c++11</strong>. In the next section, <em class="italic">Adding custom driver flags</em>, we will show you some examples of how Clang translates driver flags into frontend flags or even assembler/linker flags.</p>
			<p>On the other hand, a <strong class="bold">toolchain</strong> is <a id="_idIndexMarker348"/>an entity that describes how input code should be <a id="_idIndexMarker349"/>compiled on <strong class="bold">a specific platform</strong>. Different hardware architectures and <strong class="bold">operating systems</strong> (<strong class="bold">OS</strong>) – <em class="italic">platforms</em>, for short – have their own way to build, load, and run programs. Take macOS X and Linux, for example. Although they both have a <em class="italic">Unix-like</em> environment, when building a program, the system (standard) libraries for macOS X always reside in Apple's XCode IDE package, whereas Linux usually stores them in normal folders such as <strong class="source-inline">/usr/include</strong> and <strong class="source-inline">/usr/lib</strong>. Also, macOS X uses an executable format <a id="_idIndexMarker350"/>called <strong class="bold">Mach-O</strong>, which is different from Linux's ELF format. This greatly affects how compilers (Clang) build the code.</p>
			<p>For Clang to compile code for various platforms, it uses toolchains (which are effectively represented by the <strong class="source-inline">ToolChain</strong> C++ class internally) to encapsulate platform-specific information and configurations. In the early stage of compilation, Clang's driver selects a correct toolchain based on the system currently running (called <a id="_idIndexMarker351"/>the <strong class="bold">host</strong> system) or the users' preference – you can use the <strong class="source-inline">-target=</strong> driver flag to ask Clang to build a program for a specific platform that is different from the host system, which is effectively <a id="_idIndexMarker352"/>doing <strong class="bold">cross-compiling</strong>. Then, the driver will gather some platform-specific configurations from the selected toolchain before combining it with the aforementioned driver options and dispatching them to individual compiler phases via command-line flags. Note that different platforms usually use different assemblers and linkers. For example, macOS X can only use <strong class="source-inline">ld64</strong> and <strong class="source-inline">lld</strong> linkers for now, whereas Linux can use <strong class="source-inline">ld</strong> (BFD linker), <strong class="source-inline">ld.gold</strong>, and <strong class="source-inline">lld</strong> as linkers. Therefore, a toolchain should also specify what assembler and linker to use. In the last section of this chapter, <em class="italic">Adding a custom toolchain</em>, we will go through an example project to learn how Clang's toolchains work. Let's start our journey by learning how driver flags work in Clang.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor111"/>Adding custom driver flags</h1>
			<p>In the<a id="_idIndexMarker353"/> previous section, we explained the role of the driver and toolchains in Clang. In this section, we are going to learn how Clang's driver does this translation by adding a custom driver flag to Clang. Again, we will go through the overview for this example project first before demonstrating the detailed steps in a separate section.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor112"/>Project overview</h2>
			<p>The example<a id="_idIndexMarker354"/> project we will be using for this section is going to add a new driver flag so that when that flag is given by users, a header file will be <em class="italic">implicitly</em> included in the input code.</p>
			<p>To be more specific, here, we have a header file – <strong class="source-inline">simple_log.h</strong> – shown in the following code that defines some simple APIs to print log messages:</p>
			<p class="source-code">#ifndef SIMPLE_LOG_H</p>
			<p class="source-code">#define SIMPLE_LOG_H</p>
			<p class="source-code">#include &lt;iostream&gt;</p>
			<p class="source-code">#include &lt;string&gt;</p>
			<p class="source-code">#ifdef <strong class="bold">SLG_ENABLE_DEBUG</strong></p>
			<p class="source-code">inline void <strong class="bold">print_debug</strong>(const std::string &amp;M) {</p>
			<p class="source-code">  std::cout &lt;&lt; "[DEBUG] " &lt;&lt; M &lt;&lt; std::endl;</p>
			<p class="source-code">}</p>
			<p class="source-code">#endif</p>
			<p class="source-code">#ifdef <strong class="bold">SLG_ENABLE_ERROR</strong></p>
			<p class="source-code">inline void <strong class="bold">print_error</strong>(const std::string &amp;M) {</p>
			<p class="source-code">  std::cout &lt;&lt; "[ERROR] " &lt;&lt; M &lt;&lt; std::endl;</p>
			<p class="source-code">}</p>
			<p class="source-code">#endif</p>
			<p class="source-code">#ifdef <strong class="bold">SLG_ENABLE_INFO</strong></p>
			<p class="source-code">inline void <strong class="bold">print_info</strong>(const std::string &amp;M) {</p>
			<p class="source-code">  std::cout &lt;&lt; "[INFO] " &lt;&lt; M &lt;&lt; std::endl;</p>
			<p class="source-code">}</p>
			<p class="source-code">#endif</p>
			<p class="source-code">#endif</p>
			<p>The goal here is <a id="_idIndexMarker355"/>to use these APIs in our code <em class="italic">without</em> writing the <strong class="source-inline">#include "simple_log.h"</strong> line to import the header file. And this feature will only be enabled when we give a custom driver flag, <strong class="source-inline">-fuse-simple-log</strong>, to <strong class="source-inline">clang</strong>. For example, let's write the following code, <strong class="source-inline">test.cc</strong>:</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">  <strong class="bold">print_info</strong>("Hello world!!");</p>
			<p class="source-code">  return 0;</p>
			<p class="source-code">}</p>
			<p>Despite its lack of any <strong class="source-inline">#include</strong> directives, it can still be compiled (with the <strong class="source-inline">-fuse-simple-log</strong> flag) and run without any problems:</p>
			<p class="source-code">$ clang++ <strong class="bold">-fuse-simple-log</strong> test.cc -o test</p>
			<p class="source-code">$ ./test</p>
			<p class="source-code">[INFO] Hello world!!</p>
			<p class="source-code">$</p>
			<p>Moreover, we <a id="_idIndexMarker356"/>can use <strong class="source-inline">-fuse-&lt;log level&gt;-simple-log </strong>/<strong class="source-inline">-fno-use-&lt;log level&gt;-simple-log</strong> to include or exclude a function for a specific log level. For example, let's use the same preceding code snippets but add <strong class="source-inline">-fno-use-info-simple-log</strong> when we compile the code:</p>
			<p class="source-code">$ clang++ -fuse-simple-log <strong class="bold">-fno-use-info-simple-log</strong> test.cc -o test</p>
			<p class="source-code">test.cc:2:3: <strong class="bold">error</strong>: use of undeclared identifier 'print_info'</p>
			<p class="source-code">  print_info("Hello World!!");</p>
			<p class="source-code">  ^</p>
			<p class="source-code">1 error generated</p>
			<p class="source-code">$</p>
			<p>The switch for each log printing function is simply controlled by its surrounding <strong class="source-inline">#ifdef</strong> statements in <strong class="source-inline">simple_log.h</strong>. For example, <strong class="source-inline">print_info</strong> will only be included if <strong class="source-inline">SLG_ENABLE_INFO</strong> is defined. Later, in the <em class="italic">Translating custom driver flags</em> section, we will show you how these macro definitions are toggled by driver flags.</p>
			<p>Last but not least, you can specify a custom path to the <strong class="source-inline">simple_log.h</strong> file. By default, our feature will include <strong class="source-inline">simple_log.h</strong> in the current folder of the source code. You can change this by supplying <strong class="source-inline">-fsimple-log-path=&lt;file path&gt;</strong> or <strong class="source-inline">-fuse-simple-log=&lt;file path&gt;</strong>. For example, we want to use an alternative version of <strong class="source-inline">simple_log.h</strong> – <strong class="source-inline">advanced_log.h</strong>, which is stored in <strong class="source-inline">/home/user</strong> – which provides functions with the same interfaces but different implementations. Now, we can use the following commands:</p>
			<p class="source-code">$ clang++ <strong class="bold">-fuse-simple-log=/home/user/advanced_log.h</strong> test.cc -o test</p>
			<p class="source-code">[01/28/2021 20:51 PST][INFO] Hello World!!</p>
			<p class="source-code">$</p>
			<p>The following section will show you how to change the code in Clang's driver so that you can implement these features.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor113"/>Declaring custom driver flags</h2>
			<p>First, we will lead <a id="_idIndexMarker357"/>you through the steps to <em class="italic">declare</em> custom driver flags such as <strong class="source-inline">-fuse-simple-log</strong> and <strong class="source-inline">-fno-use-info-simple-log</strong>. Then, we are going to <em class="italic">wire</em> those flags to the real frontend functionalities.</p>
			<p>Clang uses <strong class="bold">TableGen</strong> syntax to declare all kinds of compiler flags – both driver flags and frontend flags.</p>
			<p class="callout-heading">TableGen</p>
			<p class="callout"><strong class="bold">TableGen</strong> is a <strong class="bold">Domain-Specific Language</strong> (<strong class="bold">DSL</strong>) that's used for declaring structural and <a id="_idIndexMarker358"/>relational data. To learn<a id="_idIndexMarker359"/> more, please check out <a href="B14590_04_Final_JC_ePub.xhtml#_idTextAnchor052"><em class="italic">Chapter 4</em></a>, <em class="italic">TableGen Development</em>.</p>
			<p>All these flag declarations are put in <strong class="source-inline">clang/include/clang/Driver/Options.td</strong>. Take the common <strong class="source-inline">-g</strong> flag, for example, which tells you that you want to generate source-level debug information. For example, it has a declaration like this:</p>
			<p class="source-code">def g_Flag : <strong class="bold">Flag&lt;["-"], "g"&gt;</strong>, Group&lt;g_Group&gt;,</p>
			<p class="source-code">  HelpText&lt;"Generate source-level debug information"&gt;;</p>
			<p>The TableGen record, <strong class="source-inline">g_Flag</strong>, is created from several TableGen classes: <strong class="source-inline">Flag</strong>, <strong class="source-inline">Group</strong>, and <strong class="source-inline">HelpText</strong>. Among them, we are most interested in <strong class="source-inline">Flag</strong>, whose template values (<strong class="source-inline">["-"]</strong> and <strong class="source-inline">"g"</strong>) describe the actual command-line flag format. Note that when we are declaring a <em class="italic">boolean</em> flag – the value of this flag is determined by its presence and no other values follow – as in this case, we inherit from the <strong class="source-inline">Flag</strong> class.</p>
			<p>In cases where we want to declare a flag that has values that follow an equal sign ("="), we inherit from the <strong class="source-inline">Joined</strong> class. For example, the TableGen declaration for <strong class="source-inline">-std=&lt;C++ standard name&gt;</strong> looks like this:</p>
			<p class="source-code">def std_EQ : <strong class="bold">Joined&lt;["-", "--"], "std="&gt;</strong>, Flags&lt;[CC1Option]&gt;, …;</p>
			<p>Usually, the record names (<strong class="source-inline">std_EQ</strong>, in this case) for these kinds of flags have <strong class="source-inline">_EQ</strong> as their suffices.</p>
			<p>Last but not least, the <strong class="source-inline">Flags</strong> (plural) class can be used to specify some properties. For example, <strong class="source-inline">CC1Options</strong> in the preceding snippet tells us that this flag can also be a frontend flag.</p>
			<p>Now that we've <a id="_idIndexMarker360"/>learned how driver flags are generally declared, it is time to create our own:</p>
			<ol>
				<li>First, we are going to deal with the <strong class="source-inline">-fuse-simple-log</strong> flag. Here is how we declare it:<p class="source-code">def fuse_simple_log : Flag&lt;["-"], "fuse-simple-log"&gt;,</p><p class="source-code">                  Group&lt;f_Group&gt;, Flags&lt;[NoXarchOption]&gt;;</p><p>This snippet basically has no differences from the examples we used previously, except for the <strong class="source-inline">Group</strong> class and <strong class="source-inline">NoXarchOption</strong>. The former specifies the <em class="italic">logical</em> group this flag belongs to – for example, <strong class="source-inline">f_Group</strong> is for flags starting with <strong class="source-inline">-f</strong>. The latter tells us that this flag can <em class="italic">only</em> be used in the driver. You cannot, for example, pass it to the frontend (but how do we pass flags directly to the frontend? We will answer this question shortly, at the end of this section).</p><p>Note that we only declare <strong class="source-inline">-fuse-simple-log</strong> here but not <strong class="source-inline">-fuse-simple-log=&lt;file path&gt;</strong> – that will be done in <em class="italic">another</em> flag that we will introduce shortly.</p></li>
				<li>Next, we are dealing with <strong class="source-inline">-fuse-&lt;log level&gt;-simple-log</strong> and <strong class="source-inline">-fno-use-&lt;log level&gt;-simple-log</strong>. In both GCC and Clang, it is pretty common to see pairwise flags such as <strong class="source-inline">-f&lt;flag name&gt;</strong>/<strong class="source-inline">-fno-&lt;flag name&gt;</strong> to enable or disable a certain feature. Therefore, Clang provides a handy TableGen utility – <strong class="source-inline">BooleanFFlag</strong> – to make creating pairwise flags easier. Please see the declarations for <strong class="source-inline">-fuse-error-simple-log</strong>/<strong class="source-inline">-fno-use-error-simple-log</strong> in the following code:<p class="source-code">defm use_error_simple_log : BooleanFFlag&lt;"use-error-simple-log"&gt;, Group&lt;f_Group&gt;, Flags&lt;[NoXarchOption]&gt;;</p><p><strong class="source-inline">BooleanFFlag</strong> is a <em class="italic">multiclass</em> (so make sure you use <strong class="source-inline">defm</strong> rather than <strong class="source-inline">def</strong> to create the TableGen record). Under the hood, it creates TableGen records for both <strong class="source-inline">-f&lt;flag name&gt;</strong> and <strong class="source-inline">-fno-&lt;flag name&gt;</strong> <em class="italic">at the same time</em>.</p><p>Now that we've<a id="_idIndexMarker361"/> learned how <strong class="source-inline">use_error_simple_log</strong> was created, we can use the same trick to create TableGen records for other log levels:</p><p class="source-code">defm use_debug_simple_log : BooleanFFlag&lt;"use-debug-simple-log"&gt;, Group&lt;f_Group&gt;, Flags&lt;[NoXarchOption]&gt;;</p><p class="source-code">defm use_info_simple_log : BooleanFFlag&lt;"use-info-simple-log"&gt;, Group&lt;f_Group&gt;, Flags&lt;[NoXarchOption]&gt;;</p></li>
				<li>Finally, we are declaring the <strong class="source-inline">-fuse-simple-log=&lt;file path&gt;</strong> and <strong class="source-inline">-fsimple-log-path=&lt;file path&gt;</strong> flags. In the previous steps, we were only dealing with boolean flags, but here, we are creating flags that have values that follow the equal sign, so we are using the <strong class="source-inline">Joined</strong> class we introduced earlier:<p class="source-code">def fsimple_log_path_EQ : Joined&lt;["-"], "fsimple-log-path="&gt;, Group&lt;f_Group&gt;, Flags&lt;[NoXarchOption]&gt;;</p><p class="source-code">def fuse_simple_log_EQ : Joined&lt;["-"], "fuse-simple-log="&gt;, Group&lt;f_Group&gt;, Flags&lt;[NoXarchOption]&gt;;</p><p>Again, flags with values will usually use <strong class="source-inline">_EQ</strong> in their TableGen record name suffix.</p></li>
			</ol>
			<p>That wraps up all the<a id="_idIndexMarker362"/> necessary steps for declaring our custom driver flags. During Clang's building process, these TableGen directives will be translated into C++ enums and other utilities that are used by the driver. For example, <strong class="source-inline">-fuse-simple-log=&lt;file path&gt;</strong> will be represented by an enum; that is, <strong class="source-inline">options::OPT_fuse_simple_log_EQ</strong>. The next section will show you how to query these flags from all the command-line flags given by users and, most importantly, how to translate our custom flags into their frontend counterparts.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor114"/>Translating custom driver flags</h2>
			<p>Recall that compiler<a id="_idIndexMarker363"/> drivers do a lot of things for users under the hood. For instance, they figure out the correct toolchain based on the compilation target and translate driver flags that have been designated by users, which is what we are going to do next. In our case here, we want to include the <strong class="source-inline">simple_log.h</strong> header file for users when our newly created <strong class="source-inline">-fuse-simple-log</strong> is given and define macro variables such as <strong class="source-inline">SLG_ENABLE_ERROR</strong> to include or exclude certain log printing functions, depending on the <strong class="source-inline">-fuse-&lt;log level&gt;-simple-log</strong>/<strong class="source-inline">-fno-use-&lt;log level&gt;-simple-log</strong> flags. More specifically, these tasks can be broken down into two parts:</p>
			<ul>
				<li>If <strong class="source-inline">-fuse-simple-log</strong> is given, we are translating it into a frontend flag:<p class="source-code"><strong class="bold">-include</strong> "simple_log.h"</p><p>The <strong class="source-inline">-include</strong> frontend flag, as its name suggests, <em class="italic">implicitly</em> includes the designated file in the compiling source code.</p><p>Using the same logic, if <strong class="source-inline">-fuse-simple-log=/other/file.h</strong> or <strong class="source-inline">-fuse-simple-log -fsimple-log-path=/other/file.h</strong> are given, they will be translated into the following:</p><p class="source-code">-include <strong class="bold">"/other/file.h"</strong></p></li>
				<li>If either <strong class="source-inline">-fuse-&lt;log level&gt;-simple-log</strong> or <strong class="source-inline">-fno-use-&lt;log level&gt;-simple-log</strong> is given – for instance, <strong class="source-inline">-fuse-error-simple-log</strong> – it will be<a id="_idTextAnchor115"/> translated into the following:<p class="source-code"><strong class="bold">-D</strong> SLG_ENABLE_ERROR</p><p>The <strong class="source-inline">-D</strong> flag implicitly defines a macro variable for the compiling source code.</p><p>However, if only <strong class="source-inline">-fuse-simple-only</strong> is given, the flag will implicitly include all the log printing functions. In other words, <strong class="source-inline">-fuse-simple-only</strong> will not only be translated into the <strong class="source-inline">-include</strong> flag, as introduced in previous bullet point, but also the following flags:</p><p class="source-code">-D <strong class="bold">SLG_ENABLE_ERROR</strong> -D <strong class="bold">SLG_ENABLE_DEBUG</strong> -D <strong class="bold">SLG_ENABLE_INFO</strong></p><p>Let's say a combination of <strong class="source-inline">-fuse-simple-log</strong> and <strong class="source-inline">-fno-use-&lt;log level&gt;-simple-log</strong> are used together, for example:</p><p class="source-code">-fuse-simple-log -fno-use-error-simple-log</p><p>They will be<a id="_idIndexMarker364"/> translated into the following code:</p><p class="source-code">-include "simple_log.h" -D SLG_ENABLE_DEBUG -D SLG_ENABLE_INFO</p><p>Last but not least, we also allow the following combinations:</p><p class="source-code">-fuse-info-simple-log -fsimple-log-path="my_log.h"</p><p>That is, we only enable a single log printing function without using <strong class="source-inline">-fuse-simple-log</strong> (instead of using the latter flag and subtracting two other log printing functions) and use a custom simple log header file. These driver flags will be translated into the following code:</p><p class="source-code">-include "my_log.h" -D SLG_ENABLE_INFO</p><p>The aforementioned rules and combinations of flags can actually be handled in a pretty elegant way, albeit being complex at first glance. We will show you how to do this shortly.</p></li>
			</ul>
			<p>Now that we have learned <em class="italic">what</em> frontend flags we are going to translate to, it is time to learn <em class="italic">how</em> to do these translations.</p>
			<p>The place where many driver flags translations happen is inside the <strong class="source-inline">driver::tools::Clang</strong> C++ class. More specifically, this happens in its <strong class="source-inline">Clang::ConstructJob</strong> method, which is located in the <strong class="source-inline">clang/lib/Driver/ToolChains/Clang.cpp</strong> file.</p>
			<p class="callout-heading">About driver::tools::Clang</p>
			<p class="callout">Some of the most prominent questions for this C++ class are probably, what <em class="italic">concept</em> does it represent? Why is it put under the folder named <em class="italic">ToolChains</em>? Does that mean it is also a toolchain? While we will answer these questions in detail in the next section, <em class="italic">Adding a custom toolchain</em>, for now, you can just think of it as the representative of Clang's frontend. This (kind of) explains why it is responsible for translating driver flags into frontend ones.</p>
			<p>Here are the <a id="_idIndexMarker365"/>steps to translate our custom driver flags. The following code can be inserted anywhere within the <strong class="source-inline">Clang::ConstructJob</strong> method, before the <strong class="source-inline">addDashXForInput</strong> function is called, which starts to wrap up the translation process:</p>
			<ol>
				<li value="1">First, we are defining a help class – <strong class="source-inline">SimpleLogOpts</strong> – to carry our custom flag's information:<p class="source-code">struct SimpleLogOpts {</p><p class="source-code">  // If a certain log level is enabled</p><p class="source-code">  bool Error = false,</p><p class="source-code">       Info = false,</p><p class="source-code">       Debug = false;</p><p class="source-code">  static inline SimpleLogOpts All() { </p><p class="source-code">    return {true, true, true};</p><p class="source-code">  }</p><p class="source-code">  // If any of the log level is enabled</p><p class="source-code">  inline operator bool() const {</p><p class="source-code">    return Error || Info || Debug;</p><p class="source-code">  }</p><p class="source-code">};</p><p class="source-code">// The object we are going to work on later</p><p class="source-code">SimpleLogOpts SLG;</p><p>The <strong class="source-inline">bool</strong> fields in <strong class="source-inline">SimpleLogOpts</strong> – <strong class="source-inline">Error</strong>, <strong class="source-inline">Info</strong>, and <strong class="source-inline">Debug</strong> – represent log levels that are enabled by our custom flags. We also define a helper function <strong class="source-inline">SimpleLogOpts::All()</strong> to create a <strong class="source-inline">SimpleLogOpts</strong> in which all log levels are enabled, and a <strong class="source-inline">bool</strong> type conversion operator such that we can use a cleaner <a id="_idIndexMarker366"/>syntax, shown here, to tell us if any of the levels are enabled:</p><p class="source-code">if (SLG) {</p><p class="source-code">  // At least one log level is enabled!</p><p class="source-code">}</p></li>
				<li>Let's handle the simplest case first – the <strong class="source-inline">-fuse-simple-log</strong> flag. In this step, we are only going to turn on all the log levels in <strong class="source-inline">SLG</strong> when we see a <strong class="source-inline">-fuse-simple-log</strong> flag.<p>Inside the <strong class="source-inline">Clang::ConstructJob</strong> method, the driver flags given by users are stored in the <strong class="source-inline">Args</strong> variable (one of the arguments for <strong class="source-inline">ConstructJob</strong>), which is of the <strong class="source-inline">ArgList</strong> type. There are many ways to query <strong class="source-inline">Args</strong>, but here, since we only care about the <em class="italic">presence</em> of <strong class="source-inline">-fuse-simple-log</strong>, <strong class="source-inline">hasArg</strong> is the most suitable option:</p><p class="source-code">if (Args.hasArg(options::OPT_fuse_simple_log)) {</p><p class="source-code">  SLG = SimpleLogOpts::All();</p><p class="source-code">}</p><p>Each flag we declared in the previous code via TableGen syntax will be represented by a unique <em class="italic">enum</em> under the <strong class="source-inline">options</strong> namespace. In this case, the enum value is <strong class="source-inline">OPT_fuse_simple_log</strong>. The name of the enum value is usually <strong class="source-inline">OPT_</strong>, followed by the <strong class="bold">TableGen record name</strong> (that is, the name follows <strong class="source-inline">def</strong> or <strong class="source-inline">defm</strong>) when we were declaring the flag. The <strong class="source-inline">ArgList::hasArg</strong> function will return true if the given flag identifier is present in the input driver flags.</p><p>In <a id="_idIndexMarker367"/>addition to <strong class="source-inline">-fuse-simple-log</strong>, we also need to turn on all the log levels when <strong class="source-inline">-fuse-simple-log=&lt;file path&gt;</strong> is given, even though we are only going to handle the file path that follows later. Thus, we will change the preceding snippet into the following:</p><p class="source-code">if (Args.hasArg(options::OPT_fuse_simple_log,</p><p class="source-code">                options::OPT_fuse_simple_log_EQ)) {</p><p class="source-code">  SLG = SimpleLogOpts::All();</p><p class="source-code">}</p><p><strong class="source-inline">ArgList::hasArg</strong> can actually take multiple flag identifiers and return true if <em class="italic">any</em> of them are present in the input driver flags. And again, the <strong class="source-inline">-fuse-simple-log=&lt;…&gt;</strong> flag is represented by <strong class="source-inline">OPT_fuse_simple_log_EQ</strong> since its TableGen record name is <strong class="source-inline">fuse_simple_log_EQ</strong>.</p></li>
				<li>Next, we are going to handle <strong class="source-inline">-fuse-&lt;log level&gt;-simple-log</strong>/<strong class="source-inline">-fno-use-&lt;log level&gt;-simple-log</strong>. Taking the error level, as an example (flags for other levels are used in the exact same way, so we are not showing them here), here, we are leveraging the <strong class="source-inline">ArgList::hasFlag</strong> function:<p class="source-code">SLG.Error = Args.hasFlag(options::OPT_fuse_error_simple_log, options::OPT_fno_use_error_simple_log, SLG.Error);</p><p>The <strong class="source-inline">hasFlag</strong> function will return true or false if the flag that's represented by the first (<strong class="source-inline">OPT_fuse_error_simple_log</strong> here) or second (<strong class="source-inline">OPT_fno_use_error_simple_log</strong> here) argument is present in the input driver flags, respectively.</p><p>If <em class="italic">neither</em> of the flags are present, <strong class="source-inline">hasFlag</strong> will return a default value that's designated by its third argument (<strong class="source-inline">SLG.Error</strong>, in this case).</p><p>Using this mechanism, we have already implemented some of the (complex) rule and flag combinations we mentioned earlier in this section:</p><p>a) The <strong class="source-inline">-fno-use-&lt;log level&gt;-simple-log</strong> flags can disable certain log printing function(s) when <strong class="source-inline">-fuse-simple-log</strong> – which effectively includes all the log printing functions in the first place – is present.</p><p>b) Even <em class="italic">without</em> the presence of <strong class="source-inline">-fuse-simple-log</strong>, we can still enable individual log printing functions by using the <strong class="source-inline">-fuse-&lt;log level&gt;-simple-log</strong> flag(s).</p></li>
				<li>Currently, we <a id="_idIndexMarker368"/>are only playing around with the <strong class="source-inline">SimpleLogOpts</strong> data structure. Starting from the next step, we will start to generate frontend flags according to the <strong class="source-inline">SimpleLogOpts</strong> instance we have built so far. The first frontend flag we are generating here is <strong class="source-inline">-include &lt;file path&gt;</strong>. First, it only makes sense to proceed if at least one log level has been enabled. Therefore, we will wrap the generation of <strong class="source-inline">-include</strong> with an <strong class="source-inline">if</strong> statement by checking on <strong class="source-inline">SLG</strong>, as we explained earlier:<p class="source-code">if (SLG) {</p><p class="source-code">  CmdArgs.push_back("-include");</p><p class="source-code">  …</p><p class="source-code">}</p><p>The <strong class="source-inline">CmdArgs</strong> (a local variable – with a vector-like type – inside <strong class="source-inline">Clang::ConstructJob</strong>) is the place where we will put our <strong class="bold">frontend</strong> flags.</p><p>Note that you cannot push a frontend flag containing any <em class="italic">white space</em>. For instance, you cannot do something like this:</p><p class="source-code">if (SLG) {</p><p class="source-code">  CmdArgs.push_back("-include simple_log.h"); // Error</p><p class="source-code">  …</p><p class="source-code">}</p><p>This is because, eventually, this vector (<strong class="source-inline">CmdArgs</strong>) will be treated as <strong class="source-inline">argv</strong>, which we can see in the <strong class="source-inline">main</strong> function of C/C++, and any white space within a single argument will create failures when those arguments are realized.</p><p>Instead, we are <a id="_idIndexMarker369"/>pushing the path to a simple log header file <em class="italic">separately</em>, as follows:</p><p class="source-code">if (SLG) {</p><p class="source-code">  CmdArgs.push_back("-include");</p><p class="source-code">  if (Arg *A = Args.getLastArg(options::OPT_fuse_simple_  log_EQ, options::OPT_fsimple_log_path_EQ))</p><p class="source-code">    CmdArgs.push_back(A-&gt;getValue());</p><p class="source-code">  else</p><p class="source-code">    CmdArgs.push_back("simple_log.h");</p><p class="source-code">  …</p><p class="source-code">}</p><p>The <strong class="source-inline">ArgList::getLastArg</strong> function will retrieve the value (the last value, if there are multiple occurrences of the same flag), follow a given flag, and return null if none of those flags are present. For instance, in this case, the flag is <strong class="source-inline">-fuse-simple-log=</strong> (<strong class="source-inline">-fsimple-log-path=</strong> in the second argument is just the <em class="italic">alias</em> flag of the first one).</p></li>
				<li>Finally, we are generating frontend flags that control which log printing functions should be enabled. Again, we are only showing the code for one of the log levels here since other levels are using the same approach:<p class="source-code">if (SLG) {</p><p class="source-code">  …</p><p class="source-code">  if (SLG.Error) {</p><p class="source-code">    CmdArgs.push_back("-D");</p><p class="source-code">    CmdArgs.push_back("SLG_ENABLE_ERROR");</p><p class="source-code">  }</p><p class="source-code">  …</p><p class="source-code">}</p></li>
			</ol>
			<p>These are basically <a id="_idIndexMarker370"/>all the modifications that are required for our project. The final thing we must do before we move on is verify our work. Recall the <strong class="source-inline">-###</strong> command-line flag, which is used to print all the flags that are passed to the frontend. We are using it here to see if our custom driver flags are translated pr<a id="_idTextAnchor116"/>operly.</p>
			<p>First, let's try this command:</p>
			<p class="source-code">$ clang++ <strong class="bold">-###</strong> <strong class="bold">-fuse-simple-log</strong> -c test.cc</p>
			<p>The output should contain these strings:</p>
			<p class="source-code">"-include" "simple_log.h" "-D" "SLG_ENABLE_ERROR" "-D" "SLG_ENABLE_INFO" "-D" "SLG_ENABLE_DEBUG"</p>
			<p>Now, let's try the following command:</p>
			<p class="source-code">$ clang++ -### <strong class="bold">-fuse-simple-log=my_log.h</strong> <strong class="bold">-fno-use-error-simple-log</strong> -c test.cc</p>
			<p>Tthe output should contain these strings:</p>
			<p class="source-code">"-include" "<strong class="bold">my_log.h</strong>" "-D" "SLG_ENABLE_INFO" "-D" "SLG_ENABLE_DEBUG"</p>
			<p>Finally, let's use the following command:</p>
			<p class="source-code">$ clang++ -### <strong class="bold">-fuse-info-simple-log</strong> <strong class="bold">-fsimple-log-path=my_log.h</strong> -c test.cc</p>
			<p>The output <a id="_idIndexMarker371"/>should contain the following strings :</p>
			<p class="source-code">"-include" "<strong class="bold">my_log.h</strong>" "-D" "SLG_ENABLE_INFO"</p>
			<p>In the last subsection of this section, we are going to talk about some miscellaneous ways to pass flags to the frontend.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor117"/>Passing flags to the frontend</h2>
			<p>In the previous <a id="_idIndexMarker372"/>sections, we showed you the differences between driver flags and frontend flags, how they are related, and how Clang's driver translates the former into the latter. At this point, you might be wondering, can we skip through the driver and pass the flags directly to the frontend? What flags are we allowed to pass?</p>
			<p>The short answer for the first question is <em class="italic">yes, and you have actually already done that several times in previous chapters</em>. Recall that in <a href="B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a>, <em class="italic">Handling AST</em>, we developed a plugin – more specifically, an AST plugin. We were using command-line arguments like the one shown here to load and run our plugin inside Clang:</p>
			<p class="source-code">$ clang++ -fplugin=MyPlugin.so \</p>
			<p class="source-code">          <strong class="bold">-Xclang</strong> -plugin <strong class="bold">-Xclang</strong> ternary-converter \</p>
			<p class="source-code">          -fsyntax-only test.cc</p>
			<p>You might already find that, somehow, we need to precede a <strong class="source-inline">-Xclang</strong> flag before the <strong class="source-inline">-plugin</strong> and <strong class="source-inline">ternary-converter</strong> arguments. And the answer is simple: this is because <strong class="source-inline">-plugin</strong> (and its value, <strong class="source-inline">ternary-converter</strong>) is a <em class="italic">frontend-only</em> flag.</p>
			<p>To pass a flag directly to the frontend, we can put <strong class="source-inline">-Xclang</strong> in front of it. But there is a caveat of using <strong class="source-inline">-Xclang</strong>: a single <strong class="source-inline">-Xclang</strong> will only relay <em class="italic">one</em> succeeding command-line argument (a string without any whitespace) to the frontend. In other words, you cannot rewrite the preceding plugin loading example like this:</p>
			<p class="source-code"># Error: `ternary-converter` will not be recognized</p>
			<p class="source-code">$ clang++ -fplugin=MyPlugin.so \</p>
			<p class="source-code">          <strong class="bold">-Xclang -plugin ternary-converter</strong> \</p>
			<p class="source-code">          -fsyntax-only test.cc</p>
			<p>This is because <strong class="source-inline">-Xclang</strong> will only transfer <strong class="source-inline">-plugin</strong> to the frontend and leave <strong class="source-inline">ternary-converter</strong> behind, in which case Clang will fail to know which plugin to run.</p>
			<p>Another way to<a id="_idIndexMarker373"/> pass flags directly to the frontend would be using <strong class="source-inline">-cc1</strong>. Recall that when we were using <strong class="source-inline">-###</strong> to print out the frontend flags that had been translated by the driver in the previous sections, among those frontend flags, the first one that followed the path to the <strong class="source-inline">clang</strong> executable was always <strong class="source-inline">-cc1</strong>. This flag effectively collects all the command-line arguments and sends them to the frontend. Though this looks handy – there's no need to prefix every flag we want to pass to the frontend with <strong class="source-inline">-Xclang</strong> anymore – be careful that you are not allowed to mix any <em class="italic">driver-only</em> flags inside that list of flags. For example, earlier in this section, when we were declaring our <strong class="source-inline">-fuse-simple-log</strong> flag in TableGen syntax, we annotated the flag with <strong class="source-inline">NoXarchOption</strong>, which stated that it can only be used by the driver. In that case, <strong class="source-inline">-fuse-simple-log</strong> cannot appear after <strong class="source-inline">-cc1</strong>.</p>
			<p>This leads us to our final question: what flags can be used by either the driver or the frontend, and what flags are accepted by both? The answer can actually be seen via <strong class="source-inline">NoXarchOption</strong>, which was just mentioned. When declaring flags – either for the driver or the frontend – in TableGen syntax, you can use the <strong class="source-inline">Flags&lt;…&gt;</strong> TableGen class and its template parameters to enforce some constraints. For instance, using the following directives, you can <em class="italic">prevent</em> the <strong class="source-inline">-foo</strong> flag from being used by the driver:</p>
			<p class="source-code">def foo : Flag&lt;["-"], "foo"&gt;, <strong class="bold">Flags</strong>&lt;[<strong class="bold">NoDriverOption</strong>]&gt;;</p>
			<p>In addition to <strong class="source-inline">NoXarchOption</strong> and <strong class="source-inline">NoDriverOption</strong>, here are some other common annotations you can use in <strong class="source-inline">Flags&lt;…&gt;</strong>:</p>
			<ul>
				<li><strong class="source-inline">CoreOption</strong>: States that this flag can be shared by both <strong class="source-inline">clang</strong> and <strong class="source-inline">clang-cl</strong>. <strong class="source-inline">clang-cl</strong> is an interesting driver that is compatible with the command-line interface (including command-line arguments) used<a id="_idIndexMarker374"/> by <strong class="bold">MSVC</strong> (the compiler framework used by Microsoft Visual Studio).</li>
				<li><strong class="source-inline">CC1Option</strong>: States that this flag can be accepted by the frontend. It doesn't say it's a frontend-only flag, though.</li>
				<li><strong class="source-inline">Ignored</strong>: States that this flag is going to be ignored by Clang's driver (but continue the compilation process). GCC has many flags that are not supported in Clang (either obsolete or just not applicable). However, Clang actually tries to <em class="italic">recognize</em> those flags but does nothing except show a warning message about a lack of implementation. The rationale behind this is we hope that Clang can be a <em class="italic">drop-in</em> replacement for<a id="_idIndexMarker375"/> GCC without the need to modify the existing building scripts in many projects (without this compatibility layer, Clang will terminate the compilation when it sees unknown flags).</li>
			</ul>
			<p>In this section, we learned how to add custom flags for Clang's driver and implemented the logic to translate them into frontend flags. This skill is pretty useful when you want to toggle custom features in a more straightforward and clean way.</p>
			<p>In the next section, we are going to learn the role of a toolchain and how it works in Clang by creating our own custom one.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor118"/>Adding a custom toolchain</h1>
			<p>In the previous<a id="_idIndexMarker376"/> section, we learned how to add custom flags for the driver in Clang and learned how the driver translated them into flags that are accepted by the frontend. In this section, we are going to talk about the toolchain – an important module inside the driver that helps it adapt to different platforms.</p>
			<p>Recall that in the first section of this chapter, <em class="italic">Understanding drivers and toolchains in Clang</em>, we showed the relationships between driver and toolchains in <em class="italic">Figure 8.1</em>: the driver chooses a proper toolchain based on the target platform before leveraging its knowledge to do the following:</p>
			<ol>
				<li value="1">Execute the correct <em class="italic">assembler</em>, <em class="italic">linker</em>, or any tool that is required for the target code's generation.</li>
				<li>Pass <em class="italic">platform-specific</em> flags to the compiler, assembler, or linker.</li>
			</ol>
			<p>This information is crucial for building the source code since each platform might have its own unique characteristics, such as system library paths and supported assembler/linker variants. Without them, a correct executable or library cannot even be generated.</p>
			<p>This section hopes to teach you how to create Clang toolchains for custom platforms in the future. The toolchain framework in Clang is powerful enough to be adapted to a wide variety of use cases. For example, you can create a toolchain that resembles conventional compilers on Linux – including using GNU AS to assemble and GNU LD for linking – without you needing to make many customizations to a default library path or compiler flags. On the other hand, you can have an exotic toolchain that does not even use Clang to compile source code and uses a propriety assembler and linker with uncommon command-line flags. This section will try to use an example that catches the most common use cases without missing this framework's flexible aspect.</p>
			<p>This section is<a id="_idIndexMarker377"/> organized as follows: as usual, we will start with an overview of the project we are going to work on. After that, we will break down our project workload into three parts – adding custom compiler options, setting up a custom assembler, and setting up a custom linker – before we put them together to wrap up this section.</p>
			<p class="callout-heading">System requirements</p>
			<p class="callout">As another friendly reminder, the following project can only work on Linux systems. Please make sure OpenSSL is installed.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor119"/>Project overview</h2>
			<p>We are going to <a id="_idIndexMarker378"/>create a toolchain<a id="_idIndexMarker379"/> called <strong class="bold">Zipline</strong>, which still uses Clang (its frontend and backend) to do normal compilation but encode the generated assembly code using <strong class="bold">Base64</strong> during the assembling phase, and package those Base64-encoded files into a <strong class="bold">ZIP file</strong> (or <strong class="source-inline">.tarbell</strong> file) during the linking phase.</p>
			<p class="callout-heading">Base64</p>
			<p class="callout"><strong class="bold">Base64</strong> is an<a id="_idIndexMarker380"/> encoding scheme that is commonly used to convert binary into plain text. It can be easily transmitted in a context that does not support binary format (for example, HTTP headers). You can also apply Base64 to normal textual files, just like in our case.</p>
			<p>This toolchain is basically useless in production environments. It's merely a demo that emulates common situations a developer might encounter when they're creating a new toolchain for custom platforms.</p>
			<p>This toolchain is<a id="_idIndexMarker381"/> enabled by a custom driver flag, <strong class="source-inline">-zipline</strong>/<strong class="source-inline">--zipline</strong>. When the flag is provided, first, the compiler will implicitly add the <strong class="source-inline">my_include</strong> folder to your home directory as one of the header files searching the path. For example, recall that in the previous section, <em class="italic">Adding custom driver flags</em>, our custom <strong class="source-inline">-fuse-simple-log</strong> flag would implicitly include a header file, <strong class="source-inline">simple_log.h</strong>, in the input source code:</p>
			<p class="source-code">$ ls</p>
			<p class="source-code">main.cc <strong class="bold">simple_log.h</strong></p>
			<p class="source-code">$ clang++ <strong class="bold">-fuse-simple-log</strong> -fsyntax-only main.cc</p>
			<p class="source-code">$ # OK</p>
			<p>However, if <strong class="source-inline">simple_log.h</strong> is not in the current directory, as in the preceding snippet, we need to specify its full path via another flag:</p>
			<p class="source-code">$ ls .</p>
			<p class="source-code"># No simple_log.h in current folder</p>
			<p class="source-code">main.cc</p>
			<p class="source-code">$ clang++ <strong class="bold">-fuse-simple-log=/path/to/simple_log.h</strong> -fsyntax-only main.cc</p>
			<p class="source-code">$ # OK</p>
			<p>With the help of Zipline, you can put <strong class="source-inline">simple_log.h</strong> inside <strong class="source-inline">/home/&lt;user name&gt;/my_include</strong>, and the compiler will find it:</p>
			<p class="source-code">$ ls .</p>
			<p class="source-code"># No simple_log.h in current folder</p>
			<p class="source-code">main.cc</p>
			<p class="source-code">$ ls ~/my_include</p>
			<p class="source-code">simple_log.h</p>
			<p class="source-code">$ clang++ <strong class="bold">-zipline</strong> -fuse-simple-log -fsyntax-only main.cc</p>
			<p class="source-code">$ # OK</p>
			<p>The second<a id="_idIndexMarker382"/> feature of Zipline is that the <strong class="source-inline">clang</strong> executable will compile the source code into assembly code that's encoded by Base64 under the <strong class="source-inline">-c</strong> flag, which <em class="italic">was</em> supposed to assemble the assembly file – coming out from the compiler – into an object file. Here is an example command:</p>
			<p class="source-code">$ clang <strong class="bold">-zipline</strong> -c test.c</p>
			<p class="source-code">$ file <strong class="bold">test.o</strong></p>
			<p class="source-code">test.o: <strong class="bold">ASCII</strong> text # Not (binary) object file anymore</p>
			<p class="source-code">$ cat <strong class="bold">test.o</strong></p>
			<p class="source-code">CS50ZXh0CgkuZmlsZQkidGVzdC5jYyIKCS 5nbG9ibAlfWjNmb29pCgkucDJhbGln</p>
			<p class="source-code">bgk0LCAweDkwCgkudHlwZQlfWjNmb29p LEBmdW5jdGlvbgpfWjNmb29pOgoJLmNm</p>
			<p class="source-code">… # Base64 encoded contents</p>
			<p class="source-code">$</p>
			<p>The preceding <strong class="source-inline">file</strong> command showed that the generated file, <strong class="source-inline">test.o</strong>, from the previous invocation of <strong class="source-inline">clang</strong>, is no longer a binary format object file. The content of this file is now a Base64-encoded version of the assembly code that was generated from the compiler's backend.</p>
			<p>Finally, Zipline replaces the original linking stage with a custom one that packages and compresses the aforementioned Base64-encoded assembly files into a <strong class="source-inline">.zip</strong> file. Here is an example:</p>
			<p class="source-code">$ clang -zipline test.c <strong class="bold">-o test.zip</strong></p>
			<p class="source-code">$ file test.zip</p>
			<p class="source-code">test.zip: <strong class="bold">Zip archive</strong>, at least v2.0 to extract</p>
			<p class="source-code">$</p>
			<p>If you unzip <strong class="source-inline">test.zip</strong>, you will find that those extracted files are Base64-encoded assembly files, as we mentioned earlier.</p>
			<p>Alternatively, we can<a id="_idIndexMarker383"/> use Linux's <strong class="source-inline">tar</strong> and <strong class="source-inline">gzip</strong> utilities to package and compress them in Zipline. Let's look at an example:</p>
			<p class="source-code">$ clang -zipline <strong class="bold">-fuse-ld=tar</strong> test.c -o <strong class="bold">test.tar.gz</strong></p>
			<p class="source-code">$ file test.tar.gz</p>
			<p class="source-code">test.tar.gz: <strong class="bold">gzip compressed data</strong>, from Unix, original size…</p>
			<p class="source-code">$</p>
			<p>By using the existing <strong class="source-inline">-fuse-ld=&lt;linker name&gt;</strong> flag, we can choose between using <strong class="source-inline">zip</strong> or <strong class="source-inline">tar</strong> and <strong class="source-inline">gzip</strong> for our custom linking phase.</p>
			<p>In the next section, we are going to create the skeleton code for this toolchain and show you how to add an additional folder to the header file searching path.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor120"/>Creating the toolchain and adding a custom include path</h2>
			<p>In this section, we<a id="_idIndexMarker384"/> are going to create the skeleton for our Zipline toolchain and<a id="_idIndexMarker385"/> show you how to add an extra include folder path – more specifically, an extra <strong class="bold">system include path</strong> – to the <a id="_idIndexMarker386"/>compilation stage within Zipline. Here are the detailed steps:</p>
			<ol>
				<li value="1">Before we add a real toolchain implementation, don't forget that we are going to use a custom driver flag, <strong class="source-inline">-zipline</strong>/<strong class="source-inline">--zipline</strong>, to enable our toolchain. Let's use the same skill we learned in the previous section, <em class="italic">Adding custom driver flags</em>, to do that. Inside <strong class="source-inline">clang/include/clang/Driver/Options.td</strong>, we will add the following lines:<p class="source-code">// zipline toolchain</p><p class="source-code">def zipline : Flag&lt;["-", "--"], "zipline"&gt;,</p><p class="source-code">              Flags&lt;[NoXarchOption]&gt;; </p><p>Again, <strong class="source-inline">Flag</strong> tells us this is a boolean flag and <strong class="source-inline">NoXarchOption</strong> tells us that this flag is driver-only. We will use this driver flag shortly.</p></li>
				<li>Toolchains in Clang are represented by the <strong class="source-inline">clang::driver::ToolChain</strong> class. Each toolchain supported by Clang is derived from it, and their source files are put <a id="_idIndexMarker387"/>under the <strong class="source-inline">clang/lib/Driver/ToolChains</strong> folder. We are going to create two new files there: <strong class="source-inline">Zipline.h</strong> and <strong class="source-inline">Zipline.cpp</strong>.</li>
				<li>For <strong class="source-inline">Zipline.h</strong>, let's add<a id="_idIndexMarker388"/> the following skeleton code first:<p class="source-code">namespace clang {</p><p class="source-code">namespace driver {</p><p class="source-code">namespace toolchains {</p><p class="source-code">struct LLVM_LIBRARY_VISIBILITY ZiplineToolChain </p><p class="source-code">  : public Generic_ELF {</p><p class="source-code">  ZiplineToolChain(const Driver &amp;D, const llvm::Triple    &amp;Triple, const llvm::opt::ArgList &amp;Args)</p><p class="source-code">    : Generic_ELF(D, Triple, Args) {}</p><p class="source-code">  ~ZiplineToolChain() override {}</p><p class="source-code">  // Disable the integrated assembler</p><p class="source-code">  bool IsIntegratedAssemblerDefault() const override</p><p class="source-code">    { return false; }</p><p class="source-code">  bool useIntegratedAs() const override { return false; }</p><p class="source-code">  void</p><p class="source-code">  AddClangSystemIncludeArgs(const llvm::opt::ArgList    &amp;DriverArgs, llvm::opt::ArgStringList &amp;CC1Args) </p><p class="source-code">    const override;</p><p class="source-code">protected:</p><p class="source-code">  Tool *buildAssembler() const override;</p><p class="source-code">  Tool *buildLinker() const override;</p><p class="source-code">};</p><p class="source-code">} // end namespace toolchains</p><p class="source-code">} // end namespace driver</p><p class="source-code">} // end namespace clang</p><p>The class we created here, <strong class="source-inline">ZiplineToolChain</strong>, is derived from <strong class="source-inline">Generic_ELF</strong>, which is a subclass of <strong class="source-inline">ToolChain</strong> that's specialized for systems that use ELF<a id="_idIndexMarker389"/> as its execution format – including Linux. In addition<a id="_idIndexMarker390"/> to the parent class, there are three important methods that we are going to implement in this or later sections: <strong class="source-inline">AddClangSystemIncludeArgs</strong>, <strong class="source-inline">buildAssembler</strong>, and <strong class="source-inline">buildLinker</strong>.</p></li>
				<li>The <strong class="source-inline">buildAssembler</strong> and <strong class="source-inline">buildLinker</strong> methods generate <strong class="source-inline">Tool</strong> instances that represent the <strong class="bold">commands</strong> or programs to be run in the assembling and linking stages, respectively. We will cover them in the following sections. Now, we are going to implement the <strong class="source-inline">AddClangSystemIncludeArgs</strong> method. Inside <strong class="source-inline">Zipline.cpp</strong>, we will add its method body:<p class="source-code">void ZiplineToolChain::AddClangSystemIncludeArgs(</p><p class="source-code">                       const ArgList &amp;DriverArgs,</p><p class="source-code">                       ArgStringList &amp;CC1Args) const {</p><p class="source-code">  using namespace llvm;</p><p class="source-code">  SmallString&lt;16&gt; CustomIncludePath;</p><p class="source-code">  sys::fs::expand_tilde("~/my_include",                         CustomIncludePath);</p><p class="source-code">  addSystemInclude(DriverArgs,</p><p class="source-code">                   CC1Args, CustomIncludePath.c_str());</p><p class="source-code">}</p><p>The only thing we are doing here is calling the <strong class="source-inline">addSystemInclude</strong> function with the full path to the <strong class="source-inline">my_include</strong> folder located in the home directory. Since each user's home directory is different, we are using the <strong class="source-inline">sys::fs::expand_tilde</strong> helper function to expand <strong class="source-inline">~/my_include</strong> – where <strong class="source-inline">~</strong> represents the home directory in Linux and Unix systems – in the absolute path. The <strong class="source-inline">addSystemInclude</strong> function, on the other hand, helps you add <strong class="source-inline">"-internal-isystem" "/path/to/my_include"</strong> flags to the list of all the<a id="_idIndexMarker391"/> frontend flags. The <strong class="source-inline">-internal-isystem</strong> flag is used <a id="_idIndexMarker392"/>for designating folders of system header files, including standard library headers and some platform-specific header files.</p></li>
				<li>Last but not least, we need to teach the driver to use the Zipline toolchain when it sees our newly created <strong class="source-inline">-zipline</strong>/<strong class="source-inline">--zipline</strong> driver flag. We are going to modify the <strong class="source-inline">Driver::getToolChain</strong> method inside <strong class="source-inline">clang/lib/Driver/Driver.cpp</strong> to do so. The <strong class="source-inline">Driver::getToolChain</strong> method contains a huge switch case for selecting different toolchains based on the target operating system and hardware architecture. Please navigate to the code handling the Linux system; we are going to add an extra branch condition there:<p class="source-code">const ToolChain</p><p class="source-code">&amp;Driver::getToolChain(const ArgList &amp;Args,</p><p class="source-code">                      const llvm::Triple &amp;Target) const {</p><p class="source-code">  …</p><p class="source-code">  switch (Target.getOS()) {</p><p class="source-code">  case llvm::Triple::Linux:</p><p class="source-code">  …</p><p class="source-code">    else if (Args.hasArg(options::OPT_zipline))</p><p class="source-code">     TC = std::make_unique&lt;toolchains::ZiplineToolChain&gt;     (*this, Target, Args);</p><p class="source-code">  …</p><p class="source-code">    break;</p><p class="source-code">  case …</p><p class="source-code">  case …</p><p class="source-code">  }</p><p class="source-code">}</p><p>The extra <strong class="source-inline"><a id="_idIndexMarker393"/></strong><strong class="source-inline">else-if</strong> statement basically says that if the target OS is<a id="_idIndexMarker394"/> Linux, then we will use Zipline when the <strong class="source-inline">-zipline</strong>/<strong class="source-inline">--zipline</strong> flag is given.</p></li>
			</ol>
			<p>With that, you have added the skeleton of Zipline and successfully told the driver to use Zipline when a custom driver flag is given. On top of that, you've also learned how to add extra system library folders to the header file search path.</p>
			<p>In the next section, we are going to create a custom assembling stage and connect it to the toolchain we created here.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor121"/>Creating a custom assembling stage</h2>
			<p>As we <a id="_idIndexMarker395"/>mentioned in the <em class="italic">Project overview</em> section, instead of doing regular assembling to convert assembly code into an object file in the assembling stage of Zipline, we are invoking a program to convert the assembly file we generated from Clang into its Base64-encoded counterpart. Before we go deeper into its implementation, let's learn how each of these <em class="italic">stages</em> in a toolchain is represented.</p>
			<p>In the previous section, we learned that a toolchain in Clang is represented by the <strong class="source-inline">ToolChain</strong> class. Each of these <strong class="source-inline">ToolChain</strong> instances is responsible for telling the driver what <em class="italic">tool</em> to run in each compilation stage – namely compiling, assembling, and linking. And this information is encapsulated inside a <strong class="source-inline">clang::driver::Tool</strong> type object. Recall the <strong class="source-inline">buildAssembler</strong> and <strong class="source-inline">buildLinker</strong> methods in the previous section; they return the very <strong class="source-inline">Tool</strong> type objects that depict the actions to perform and the tool to run in the assembling and linking stages, respectively. In this section, we will show you how to implement the <strong class="source-inline">Tool</strong> object that's returned by <strong class="source-inline">buildAssembler</strong>. Let's get started:</p>
			<ol>
				<li value="1">Let's go back to <strong class="source-inline">Zipline.h</strong> first. Here, we are adding an extra class, <strong class="source-inline">Assembler</strong>, inside the <strong class="source-inline">clang::driver::tools::zipline</strong> namespace:<p class="source-code">namespace clang {</p><p class="source-code">namespace driver {</p><p class="source-code">namespace tools {</p><p class="source-code">namespace zipline {</p><p class="source-code">struct LLVM_LIBRARY_VISIBILITY Assembler : public Tool {</p><p class="source-code">  Assembler(const ToolChain &amp;TC)</p><p class="source-code">    : Tool("zipeline::toBase64", "toBase64", TC) {}</p><p class="source-code">  bool hasIntegratedCPP() const override { return false; }</p><p class="source-code">  void ConstructJob(Compilation &amp;C, const JobAction &amp;JA,</p><p class="source-code">                    const InputInfo &amp;Output,</p><p class="source-code">                    const InputInfoList &amp;Inputs,</p><p class="source-code">                    const llvm::opt::ArgList &amp;TCArgs,</p><p class="source-code">                    const char *LinkingOutput) const                     override;</p><p class="source-code">};</p><p class="source-code">} // end namespace zipline</p><p class="source-code">} // end namespace tools</p><p class="source-code">namespace toolchains {</p><p class="source-code">struct LLVM_LIBRARY_VISIBILITY ZiplineToolChain … {</p><p class="source-code">…</p><p class="source-code">};</p><p class="source-code">} // end namespace toolchains</p><p class="source-code">} // end namespace driver</p><p class="source-code">} // end namespace clang</p><p>Be <a id="_idIndexMarker396"/>careful because the newly created <strong class="source-inline">Assembler</strong> resides in the <strong class="source-inline">clang::driver::tools::zipline</strong> namespace, while <strong class="source-inline">ZiplineToolChain</strong>, which we created in the previous section, is in <strong class="source-inline">clang::driver::toolchains</strong>.</p><p>The <strong class="source-inline">Assembler::ConstructJob</strong> method is where we will put our logic for invoking Base64 encoding tools.</p></li>
				<li>Inside <strong class="source-inline">Zipline.cpp</strong>, we will<a id="_idIndexMarker397"/> implement the method body of <strong class="source-inline">Assembler::ConstructJob</strong>:<p class="source-code">void</p><p class="source-code">tools::zipline::Assembler::ConstructJob(Compilation &amp;C,</p><p class="source-code">                            const JobAction &amp;JA,</p><p class="source-code">                            const InputInfo &amp;Output,</p><p class="source-code">                            const InputInfoList &amp;Inputs,</p><p class="source-code">                            const ArgList &amp;Args,</p><p class="source-code">                            const char *LinkingOutput)                            const {</p><p class="source-code">                            ArgStringList CmdArgs;</p><p class="source-code">                            const InputInfo &amp;II =                             Inputs[0];</p><p class="source-code">  std::string Exec =</p><p class="source-code">    Args.MakeArgString(getToolChain().     GetProgramPath("openssl"));</p><p class="source-code">  // opeenssl base64 arguments</p><p class="source-code">  CmdArgs.push_back("base64");</p><p class="source-code">  CmdArgs.push_back("-in");</p><p class="source-code">  CmdArgs.push_back(II.getFilename());</p><p class="source-code">  CmdArgs.push_back("-out");</p><p class="source-code">  CmdArgs.push_back(Output.getFilename());</p><p class="source-code">  </p><p class="source-code">  C.addCommand(</p><p class="source-code">    std::make_unique&lt;Command&gt;(</p><p class="source-code">           JA, *this, ResponseFileSupport::None(),</p><p class="source-code">           Args.MakeArgString(Exec), CmdArgs,</p><p class="source-code">           Inputs, Output));</p><p class="source-code">}</p><p>We are <a id="_idIndexMarker398"/>using OpenSSL to do the Base64 encoding, and the command we hope to run is as follows:</p><p class="source-code">$ openssl base64 -in &lt;input file&gt; -out &lt;output file&gt;</p><p>The job of the <strong class="source-inline">ConstructJob</strong> method is building a <em class="italic">program invocation</em> to run the previous command. It is realized by the <strong class="source-inline">C.addCommand(…)</strong> function call at the very end of <strong class="source-inline">ConstructJob</strong>. The <strong class="source-inline">Command</strong> instance that's passed to the <strong class="source-inline">addCommand</strong> call represents the concrete command to be run during the assembling stage. It contains necessary information such as the path to the program executable (the <strong class="source-inline">Exec</strong> variable) and its arguments (the <strong class="source-inline">CmdArgs</strong> variable).</p><p>For the <strong class="source-inline">Exec</strong> variable, the toolchain has provided a handy utility, the <strong class="source-inline">GetProgramPath</strong> function, to resolve the absolute path of an executable for you.</p><p>The way we build arguments for <strong class="source-inline">openssl</strong> (the <strong class="source-inline">CmdArgs</strong> variable), on the other hand, is very similar to the thing we did in the <em class="italic">Adding custom driver flags</em> section: translating driver flags (the <strong class="source-inline">Args</strong> argument) and the input/output file information (the <strong class="source-inline">Output</strong> and <strong class="source-inline">Inputs</strong> argument) into a new set of command-line arguments and storing them in <strong class="source-inline">CmdArgs</strong>.</p></li>
				<li>Finally, we <a id="_idIndexMarker399"/>connect this <strong class="source-inline">Assembler</strong> class with <strong class="source-inline">ZiplineToolChain</strong> by implementing the <strong class="source-inline">ZiplineToolChain::buildAssembler</strong> method:<p class="source-code">Tool *ZiplineToolChain::buildAssembler() const {</p><p class="source-code">  return new tools::zipline::Assembler(*this);</p><p class="source-code">}</p></li>
			</ol>
			<p>These are all the<a id="_idIndexMarker400"/> steps we need to follow to create a <strong class="source-inline">Tool</strong> instance that represents the command to run during the linking stage of our Zipline toolchain.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor122"/>Creating a custom linking stage</h2>
			<p>Now that we've<a id="_idIndexMarker401"/> finished the assembler stage, it's time to move on to the next stage – the linking stage. We are going to use the same approach we used in the previous section; that is, we will create a custom <strong class="source-inline">Tool</strong> class representing the linker. Here are the steps:</p>
			<ol>
				<li value="1">Inside <strong class="source-inline">Zipline.h</strong>, create a <strong class="source-inline">Linker</strong> class that is derived from <strong class="source-inline">Tool</strong>:<p class="source-code">namespace zipline {</p><p class="source-code">struct LLVM_LIBRARY_VISIBILITY Assembler : public Tool {</p><p class="source-code">…</p><p class="source-code">};</p><p class="source-code">struct LLVM_LIBRARY_VISIBILITY Linker : public Tool {</p><p class="source-code">  Linker(const ToolChain &amp;TC)</p><p class="source-code">    : Tool("zipeline::zipper", "zipper", TC) {}</p><p class="source-code">  bool hasIntegratedCPP() const override { return false; }</p><p class="source-code">  bool isLinkJob() const override { return true; }</p><p class="source-code">  void ConstructJob(Compilation &amp;C, const JobAction &amp;JA,</p><p class="source-code">                    const InputInfo &amp;Output,</p><p class="source-code">                    const InputInfoList &amp;Inputs,</p><p class="source-code">                    const llvm::opt::ArgList &amp;TCArgs,</p><p class="source-code">                    const char *LinkingOutput) const                     override;</p><p class="source-code">private:</p><p class="source-code">  void buildZipArgs(const JobAction&amp;, const InputInfo&amp;,</p><p class="source-code">                    const InputInfoList&amp;,</p><p class="source-code">                    const llvm::opt::ArgList&amp;, </p><p class="source-code">                    llvm::opt::ArgStringList&amp;) const;</p><p class="source-code">  void buildTarArgs(const JobAction&amp;,</p><p class="source-code">                    const InputInfo&amp;,                     const InputInfoList&amp;,</p><p class="source-code">                    const llvm::opt::ArgList&amp;, </p><p class="source-code">                    llvm::opt::ArgStringList&amp;) const;</p><p class="source-code">};</p><p class="source-code">} // end namespace zipline</p><p>In this <strong class="source-inline">Linker</strong> class, we also need to implement the <strong class="source-inline">ConstructJob</strong> method to tell <a id="_idIndexMarker402"/>the driver what to execute during the linking stage. Differently from <strong class="source-inline">Assembler</strong>, since we need to support both the <strong class="source-inline">zip</strong> and <strong class="source-inline">tar</strong> + <strong class="source-inline">gzip</strong> packaging/compression schemes, we will add two extra methods, <strong class="source-inline">buildZipArgs</strong> and <strong class="source-inline">buildTarArgs</strong>, to handle argument building for each.</p></li>
				<li>Inside <strong class="source-inline">Zipline.cpp</strong>, we'll<a id="_idIndexMarker403"/> focus on the implementation of <strong class="source-inline">Linker::ConstructJob</strong> first:<p class="source-code">void</p><p class="source-code">tools::zipline::Linker::ConstructJob(Compilation &amp;C,</p><p class="source-code">                        const JobAction &amp;JA,</p><p class="source-code">                        const InputInfo &amp;Output,</p><p class="source-code">                        const InputInfoList &amp;Inputs,</p><p class="source-code">                        const ArgList &amp;Args,</p><p class="source-code">                        const char *LinkingOutput) const {</p><p class="source-code">  ArgStringList CmdArgs;</p><p class="source-code">  std::string Compressor = "zip";</p><p class="source-code">  if (Arg *A = Args.getLastArg(options::OPT_fuse_ld_EQ))</p><p class="source-code">    Compressor = A-&gt;getValue();</p><p class="source-code">  std::string Exec = Args.MakeArgString(</p><p class="source-code">      getToolChain().GetProgramPath(Compressor.c_str()));</p><p class="source-code">  if (Compressor == "zip")</p><p class="source-code">    buildZipArgs(JA, Output, Inputs, Args, CmdArgs);</p><p class="source-code">  if (Compressor == "tar" || Compressor == "gzip")</p><p class="source-code">    buildTarArgs(JA, Output, Inputs, Args, CmdArgs);</p><p class="source-code">  else</p><p class="source-code">    llvm_unreachable("Unsupported compressor name");</p><p class="source-code">  C.addCommand(</p><p class="source-code">    std::make_unique&lt;Command&gt;(</p><p class="source-code">      JA, *this, ResponseFileSupport::None(), </p><p class="source-code">      Args.MakeArgString(Exec),</p><p class="source-code">      CmdArgs, Inputs, Output));</p><p class="source-code">}</p><p>In this <a id="_idIndexMarker404"/>custom linking stage, we hope to use either the <strong class="source-inline">zip</strong> command or the <strong class="source-inline">tar</strong> command – depending on the <strong class="source-inline">-fuse-ld</strong> flag specified by users – to package all the (Base64-encoded) files generated by our custom <strong class="source-inline">Assembler</strong>.</p><p>The detailed command format for both <strong class="source-inline">zip</strong> and <strong class="source-inline">tar</strong> will be explained shortly. From the preceding snippet, we can see that the thing we are doing here is similar to <strong class="source-inline">Assembler::ConstructJob</strong>. The <strong class="source-inline">Exec</strong> variable carries the absolute path to either the <strong class="source-inline">zip</strong> or <strong class="source-inline">tar</strong> program; the <strong class="source-inline">CmdArgs</strong> variable, which is populated by either <strong class="source-inline">buildZipArgs</strong> or <strong class="source-inline">buildTarArgs</strong>, which will be explained later, carries the command-line arguments for the tool (<strong class="source-inline">zip</strong> or <strong class="source-inline">tar</strong>).</p><p>The biggest difference compared to <strong class="source-inline">Assembler::ConstructJob</strong> is that the command to execute can be designated by the <strong class="source-inline">-fuse-ld</strong> flag that's supplied by users. Thus, we are using the skill we learned about in the <em class="italic">Adding custom driver flags</em> section to read that driver flag and set up the command.</p></li>
				<li>If your<a id="_idIndexMarker405"/> users decide to package files in a ZIP file (which is the default scheme, or you can specify it explicitly via <strong class="source-inline">-fuse-ld=zip</strong>), we are going to run the following command:<p class="source-code">$ zip &lt;output zip file&gt; &lt;input file 1&gt; &lt;input file 2&gt;…</p><p>Therefore, we will build our <strong class="source-inline">Linker::buildZipArgs</strong> method, which constructs an argument list for the preceding command, as follows:</p><p class="source-code">void</p><p class="source-code">tools::zipline::Linker::buildZipArgs(const JobAction &amp;JA,</p><p class="source-code">                             const InputInfo &amp;Output,</p><p class="source-code">                             const InputInfoList &amp;Inputs,</p><p class="source-code">                             const ArgList &amp;Args,</p><p class="source-code">                             ArgStringList &amp;CmdArgs)                             const {</p><p class="source-code">  // output file</p><p class="source-code">  CmdArgs.push_back(Output.getFilename());</p><p class="source-code">  // input files</p><p class="source-code">  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs, JA);</p><p class="source-code">}</p><p>The <strong class="source-inline">CmdArgs</strong> argument of <strong class="source-inline">Linker::buildZipArgs</strong> will be where we'll export our results. While<a id="_idIndexMarker406"/> we are still using the same way to fetch the output filename (via <strong class="source-inline">Output.getFilename()</strong>), since a linker might accept multiple inputs at a time, we are leveraging another helper function, <strong class="source-inline">AddLinkerInputs</strong>, to add all the input filenames to <strong class="source-inline">CmdArgs</strong> for us.</p></li>
				<li>If your users decide to use the <strong class="source-inline">tar</strong> + <strong class="source-inline">gzip</strong> packaging scheme (via the <strong class="source-inline">-fuse-ld=tar</strong> or <strong class="source-inline">-fuse-ld=gzip</strong> flags), we are going to run the following command:<p class="source-code">$ tar -czf &lt;output tar.gz file&gt; &lt;input file 1&gt; &lt;input file 2&gt;…</p><p>Therefore, we<a id="_idIndexMarker407"/> will build our <strong class="source-inline">Linker::buildTarArgs</strong> method, which constructs an argument list for the previous command, as follows:</p><p class="source-code">void</p><p class="source-code">tools::zipline::Linker::buildTarArgs(const JobAction &amp;JA,</p><p class="source-code">                             const InputInfo &amp;Output,</p><p class="source-code">                             const InputInfoList &amp;Inputs,</p><p class="source-code">                             const ArgList &amp;Args,</p><p class="source-code">                             ArgStringList &amp;CmdArgs)                              const {</p><p class="source-code">  // arguments and output file</p><p class="source-code">  CmdArgs.push_back("-czf");</p><p class="source-code">  CmdArgs.push_back(Output.getFilename());</p><p class="source-code">  // input files</p><p class="source-code">  AddLinkerInputs(getToolChain(), Inputs, Args, CmdArgs,    JA);</p><p class="source-code">}</p><p>Just like <strong class="source-inline">buildZipArgs</strong>, we grab the output filename via <strong class="source-inline">Output.getFilename()</strong> and add all the input filenames, using <strong class="source-inline">AddLinkerInput</strong>, into <strong class="source-inline">CmdArgs</strong>.</p></li>
				<li>Last but not least, let's connect our <strong class="source-inline">Linker</strong> to <strong class="source-inline">ZiplineToolChain</strong>:<p class="source-code">Tool *ZiplineToolChain::buildLinker() const {</p><p class="source-code">  return new tools::zipline::Linker(*this);</p><p class="source-code">}</p></li>
			</ol>
			<p>That's all of the<a id="_idIndexMarker408"/> steps for implementing a custom linking phase for our Zipline toolchain.</p>
			<p>Now that we have created the necessary components for the Zipline toolchain, we can execute our custom features – encode the source files and package them into an archive – when users select this toolchain. In the next section, we are going to learn how to verify these functionalities.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor123"/>Verifying the custom toolchain</h2>
			<p>To test the <a id="_idIndexMarker409"/>functionalities we implemented in this chapter, we can run the example commands depicted in the project overview or we can leverage the <strong class="source-inline">-###</strong> driver flag again to dump all the expected compiler, assembler, and linker command details.</p>
			<p>So far, we've learned that the <strong class="source-inline">-###</strong> flag will show all the frontend flags that have been translated by the driver. But actually, it will also show the assembler and linker commands that have been scheduled to run. For instance, let's invoke the following command:</p>
			<p class="source-code">$ clang -### <strong class="bold">-zipline</strong> <strong class="bold">-c</strong> test.c</p>
			<p>Since the <strong class="source-inline">-c</strong> flag always tries to run the assembler over the assembly file generated by Clang, our custom assembler (that is, the Base64 encoder) within Zipline will be triggered. Therefore, you will see an output similar to the following:</p>
			<p class="source-code">$ clang -### -zipline -c test.c</p>
			<p class="source-code">"/path/to/clang" "-cc1" …</p>
			<p class="source-code">"<strong class="bold">/usr/bin/openssl</strong>" "base64" "-in" "<strong class="bold">/tmp/test_ae4f5b.s</strong>" "-out" "<strong class="bold">test.o</strong>"</p>
			<p class="source-code">$</p>
			<p>The line starting with <strong class="source-inline">/path/to/clang -cc1</strong> contains the frontend flags we learned about earlier. The line that follows is the assembler invocation command. This, in our case, runs <strong class="source-inline">openssl</strong> to perform Base64 encoding.</p>
			<p>Note that the weird <strong class="source-inline">/tmp/test_ae4f5b.s</strong> filename is the temporary file that's created by the driver to accommodate the assembly code that's generated by the compiler.</p>
			<p>Using the same trick, we can verify our custom linker stage, as follows:</p>
			<p class="source-code">$ clang -### <strong class="bold">-zipline</strong> test.c <strong class="bold">-o</strong> test.zip</p>
			<p class="source-code">"/path/to/clang" "-cc1" …</p>
			<p class="source-code">"/usr/bin/openssl" "base64" "-in" "/tmp/test_ae4f5b.s" "-out" "<strong class="bold">/tmp/test_ae4f5b.o</strong>"</p>
			<p class="source-code">"<strong class="bold">/usr/bin/zip</strong>" "test.zip" "<strong class="bold">/tmp/test_ae4f5b.o</strong>"</p>
			<p class="source-code">$</p>
			<p>Since<a id="_idIndexMarker410"/> the <strong class="source-inline">-o</strong> flag was used in the previous command, Clang will build a complete executable from <strong class="source-inline">test.c</strong> involving the assembler and the linker. Therefore, our custom linking stage is up here due to the <strong class="source-inline">zip</strong> command taking the result (the <strong class="source-inline">/tmp/test_ae4f5b.o</strong> file) from the previous assembling stage. Feel free to add the <strong class="source-inline">-fuse-ld=tar</strong> flag to see the <strong class="source-inline">zip</strong> command replace the <strong class="source-inline">tar</strong> command with a completely different argument list.</p>
			<p>In this section, we showed you how to create a toolchain for Clang's driver. This is a crucial skill for supporting Clang on custom or new platforms. We also learned that the toolchain framework in Clang is flexible and can handle a variety of tasks that are required by the target platform.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor124"/>Summary</h1>
			<p>In this chapter, we started by introducing Clang's driver and the role of the toolchain – the module that provides platform-specific information such as the supported assemblers and linkers – that assisted it. Then, we showed you one of the most common ways to customize the driver – adding a new driver flag. After that, we talked about the toolchain and, most importantly, how to create a custom one. These skills are really useful when you want to create a new feature in Clang (or even LLVM) and need a custom compiler flag to enable it. Also, the ability to develop a custom toolchain is crucial for supporting Clang on new operating systems, or even new hardware architecture.</p>
			<p>This is the final chapter of the second part of this book. Starting from the next chapter, we will talk about LLVM's middle end – the <em class="italic">platform-independent</em> program analysis and optimization framework.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor125"/>Exercises</h1>
			<ol>
				<li value="1">It is common to override the assembling and linking stage since different platforms tend to support different assemblers and linkers. However, is it possible to override the <em class="italic">compiling</em> stage (which is Clang)? If it is possible, how can we do this? Why may people wish to do this? </li>
				<li>When we were working on <strong class="source-inline">tools::zipline::Linker::ConstructJob</strong>, we simply use <strong class="source-inline">llvm_unreachable</strong> to bail out the compilation process if a user provides an unsupported compressor name through the <strong class="source-inline">-fuse-ld</strong> flag. Can we replace it with Clang's <strong class="bold">diagnostic</strong> framework, which we learned about in <a href="B14590_07_Final_JC_ePub.xhtml#_idTextAnchor093"><em class="italic">Chapter 7</em></a>, <em class="italic">Handling AST</em>, to print out better messages?</li>
				<li>Just like we can use <strong class="source-inline">-Xclang</strong> to pass flags directly to the frontend, we can also pass assembler-specific or linker-specific flags directly to the assembler or linker using driver flags such as <strong class="source-inline">-Wa</strong> (for the assembler) or <strong class="source-inline">-Wl</strong> (for the linker). How can we consume those flags in our custom assembler and linker stages within Zipline?</li>
			</ol>
		</div>
	</body></html>