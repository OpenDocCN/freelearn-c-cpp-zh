["```cpp\nsudo apt-get install libboost-test-dev \n```", "```cpp\n    #define BOOST_TEST_MODULE My first test module\n    #include <boost/test/included/unit_test.hpp>\n    BOOST_AUTO_TEST_CASE(first_test_function)\n    {\n      int a = 42;\n      BOOST_TEST(a > 0);\n    } \n    ```", "```cpp\nRunning 1 test case...\n*** No errors detected \n```", "```cpp\n#define BOOST_TEST_MODULE My first test module\n#define BOOST_TEST_NO_MAIN\n#define BOOST_TEST_ALTERNATIVE_INIT_API\n#include <boost/test/included/unit_test.hpp>\nBOOST_AUTO_TEST_CASE(first_test_function)\n{\n  int a = 42;\n  BOOST_TEST(a > 0);\n}\nint main(int argc, char* argv[])\n{\n  return boost::unit_test::unit_test_main(init_unit_test, argc, argv);\n} \n```", "```cpp\n#define BOOST_TEST_NO_MAIN\n#define BOOST_TEST_ALTERNATIVE_INIT_API\n#include <boost/test/included/unit_test.hpp>\n#include <iostream>\nBOOST_AUTO_TEST_CASE(first_test_function)\n{\n  int a = 42;\n  BOOST_TEST(a > 0);\n}\nbool custom_init_unit_test()\n{\n  std::cout << \"test runner custom init\\n\";\n  return true;\n}\nint main(int argc, char* argv[])\n{\n  return boost::unit_test::unit_test_main(\n    custom_init_unit_test, argc, argv);\n} \n```", "```cpp\nclass point3d\n{\n  int x_;\n  int y_;\n  int z_;\npublic:\n  point3d(int const x = 0, \n          int const y = 0, \n          int const z = 0):x_(x), y_(y), z_(z) {}\n  int x() const { return x_; }\n  point3d& x(int const x) { x_ = x; return *this; }\n  int y() const { return y_; }\n  point3d& y(int const y) { y_ = y; return *this; }\n  int z() const { return z_; }\n  point3d& z(int const z) { z_ = z; return *this; }\n  bool operator==(point3d const & pt) const\n  {\n    return x_ == pt.x_ && y_ == pt.y_ && z_ == pt.z_;\n  }\n  bool operator!=(point3d const & pt) const\n  {\n    return !(*this == pt);\n  }\n  bool operator<(point3d const & pt) const\n  {\n    return x_ < pt.x_ || y_ < pt.y_ || z_ < pt.z_;\n  }\n  friend std::ostream& operator<<(std::ostream& stream, \n                                  point3d const & pt)\n  {\n    stream << \"(\" << pt.x_ << \",\" << pt.y_ << \",\" << pt.z_ << \")\";\n    return stream;\n  }\n  void offset(int const offsetx, int const offsety, int const offsetz)\n {\n    x_ += offsetx;\n    y_ += offsety;\n    z_ += offsetz;\n  }\n  static point3d origin() { return point3d{}; }\n}; \n```", "```cpp\n    BOOST_AUTO_TEST_SUITE(test_construction)\n    // test cases \n    BOOST_AUTO_TEST_SUITE_END() \n    ```", "```cpp\n    BOOST_AUTO_TEST_CASE(test_constructor)\n    {\n      auto p = point3d{ 1,2,3 };\n      BOOST_TEST(p.x() == 1);\n      BOOST_TEST(p.y() == 2);\n      BOOST_TEST(p.z() == 4); // will fail\n    }\n    BOOST_AUTO_TEST_CASE(test_origin)\n    {\n      auto p = point3d::origin();\n      BOOST_TEST(p.x() == 0);\n      BOOST_TEST(p.y() == 0);\n      BOOST_TEST(p.z() == 0);\n    } \n    ```", "```cpp\n    BOOST_AUTO_TEST_SUITE(test_operations)\n    BOOST_AUTO_TEST_SUITE(test_methods)\n    BOOST_AUTO_TEST_CASE(test_offset)\n    {\n      auto p = point3d{ 1,2,3 };\n      p.offset(1, 1, 1);\n      BOOST_TEST(p.x() == 2);\n      BOOST_TEST(p.y() == 3);\n      BOOST_TEST(p.z() == 3); // will fail\n    }\n    BOOST_AUTO_TEST_SUITE_END()\n    BOOST_AUTO_TEST_SUITE_END() \n    ```", "```cpp\n    BOOST_AUTO_TEST_SUITE(test_operations)\n    BOOST_AUTO_TEST_SUITE(test_operators)\n    BOOST_AUTO_TEST_CASE(\n      test_equal, \n      *boost::unit_test::description(\"test operator==\")\n      *boost::unit_test::label(\"opeq\"))\n    {\n      auto p1 = point3d{ 1,2,3 };\n      auto p2 = point3d{ 1,2,3 };\n      auto p3 = point3d{ 3,2,1 };\n      BOOST_TEST(p1 == p2);\n      BOOST_TEST(p1 == p3); // will fail\n    }\n    BOOST_AUTO_TEST_CASE(\n      test_not_equal, \n      *boost::unit_test::description(\"test operator!=\")\n      *boost::unit_test::label(\"opeq\")\n      *boost::unit_test::depends_on(\n        \"test_operations/test_operators/test_equal\"))\n    {\n      auto p1 = point3d{ 1,2,3 };\n      auto p2 = point3d{ 3,2,1 };\n      BOOST_TEST(p1 != p2);\n    }\n    BOOST_AUTO_TEST_CASE(test_less)\n    {\n      auto p1 = point3d{ 1,2,3 };\n      auto p2 = point3d{ 1,2,3 };\n      auto p3 = point3d{ 3,2,1 };\n      BOOST_TEST(!(p1 < p2));\n      BOOST_TEST(p1 < p3);\n    }\n    BOOST_AUTO_TEST_SUITE_END()\n    BOOST_AUTO_TEST_SUITE_END() \n    ```", "```cpp\n    chapter11bt_02.exe\n    Running 6 test cases...\n    f:/chapter11bt_02/main.cpp(12): error: in \"test_construction/test_\n    constructor\": check p.z() == 4 has failed [3 != 4]\n    f:/chapter11bt_02/main.cpp(35): error: in \"test_operations/test_\n    methods/test_offset\": check p.z() == 3 has failed [4 != 3]\n    f:/chapter11bt_02/main.cpp(55): error: in \"test_operations/test_\n    operators/test_equal\": check p1 == p3 has failed [(1,2,3) != \n    (3,2,1)]\n    *** 3 failures are detected in the test module \"Testing point 3d\" \n    ```", "```cpp\n    chapter11bt_02.exe --run_test=test_construction\n    Running 2 test cases...\n    f:/chapter11bt_02/main.cpp(12): error: in \"test_construction/test_\n    constructor\": check p.z() == 4 has failed [3 != 4]\n    *** 1 failure is detected in the test module \"Testing point 3d\" \n    ```", "```cpp\n    chapter11bt_02.exe --run_test=test_construction/test_origin\n    Running 1 test case...\n    *** No errors detected \n    ```", "```cpp\n    chapter11bt_02.exe --run_test=@opeq\n    Running 2 test cases...\n    f:/chapter11bt_02/main.cpp(56): error: in \"test_operations/test_\n    operators/test_equal\": check p1 == p3 has failed [(1,2,3) != \n    (3,2,1)]\n    *** 1 failure is detected in the test module \"Testing point 3d\" \n    ```", "```cpp\n    int a = 2, b = 4;\n    BOOST_TEST(a == b);\n    BOOST_TEST(4.201 == 4.200);\n    std::string s1{ \"sample\" };\n    std::string s2{ \"text\" };\n    BOOST_TEST(s1 == s2, \"not equal\"); \n    ```", "```cpp\n    BOOST_TEST(4.201 == 4.200, boost::test_tools::tolerance(0.001)); \n    ```", "```cpp\n    std::vector<int> v{ 1,2,3 };\n    std::list<short> l{ 1,2,3 };\n    BOOST_TEST(v == l, boost::test_tools::per_element()); \n    ```", "```cpp\n    BOOST_TEST((a > 0 ? true : false));\n    BOOST_TEST((a > 2 && b < 5)); \n    ```", "```cpp\n    BOOST_ERROR(\"this test will fail\"); \n    ```", "```cpp\n    BOOST_TEST_WARN(a == 4, \"something is not right\"); \n    ```", "```cpp\n    BOOST_TEST_REQUIRE(a == 4, \"this is critical\"); \n    ```", "```cpp\n    BOOST_FAIL(\"must be implemented\"); \n    ```", "```cpp\n    BOOST_TEST(BOOST_IS_DEFINED(UNICODE)); \n    ```", "```cpp\nBOOST_TEST(a == b);\n// error: in \"regular_tests\": check a == b has failed [2 != 4]\nBOOST_TEST(a == b, \"not equal\");\n// error: in \"regular_tests\": not equal \n```", "```cpp\nstruct global_fixture\n{\n   global_fixture()  { BOOST_TEST_MESSAGE(\"global setup\"); }\n   ~global_fixture() { BOOST_TEST_MESSAGE(\"global cleanup\"); }\n   int g{ 1 };\n};\nstruct standard_fixture\n{\n  standard_fixture()  {BOOST_TEST_MESSAGE(\"setup\");}\n  ~standard_fixture() {BOOST_TEST_MESSAGE(\"cleanup\");}\n  int n {42};\n};\nstruct extended_fixture\n{\n  std::string name;\n  int         data;\n  extended_fixture(std::string const & n = \"\") : name(n), data(0) \n  {\n    BOOST_TEST_MESSAGE(\"setup \"+ name);\n  }\n  ~extended_fixture()\n  {\n    BOOST_TEST_MESSAGE(\"cleanup \"+ name);\n  }\n};\nvoid fixture_setup()\n{\n  BOOST_TEST_MESSAGE(\"fixture setup\");\n}\nvoid fixture_cleanup()\n{\n  BOOST_TEST_MESSAGE(\"fixture cleanup\");\n} \n```", "```cpp\n    BOOST_FIXTURE_TEST_CASE(test_case, extended_fixture)\n    {\n      data++;\n      BOOST_TEST(data == 1);\n    } \n    ```", "```cpp\n    BOOST_FIXTURE_TEST_SUITE(suite1, extended_fixture)\n    BOOST_AUTO_TEST_CASE(case1)\n    {\n      BOOST_TEST(data == 0);\n    }\n    BOOST_AUTO_TEST_CASE(case2)\n    {\n      data++;\n      BOOST_TEST(data == 1);\n    }\n    BOOST_AUTO_TEST_SUITE_END() \n    ```", "```cpp\n    BOOST_FIXTURE_TEST_SUITE(suite2, extended_fixture)\n    BOOST_AUTO_TEST_CASE(case1)\n    {\n      BOOST_TEST(data == 0);\n    }\n    BOOST_FIXTURE_TEST_CASE(case2, standard_fixture)\n    {\n      BOOST_TEST(n == 42);\n    }\n    BOOST_AUTO_TEST_SUITE_END() \n    ```", "```cpp\n    BOOST_AUTO_TEST_CASE(test_case_multifix,\n      * boost::unit_test::fixture<extended_fixture>(std::string(\"fix1\"))\n      * boost::unit_test::fixture<extended_fixture>(std::string(\"fix2\"))\n      * boost::unit_test::fixture<standard_fixture>())\n    {\n      BOOST_TEST(true);\n    } \n    ```", "```cpp\n    BOOST_AUTO_TEST_CASE(test_case_funcfix,\n      * boost::unit_test::fixture(&fixture_setup, &fixture_cleanup))\n    {\n      BOOST_TEST(true);\n    } \n    ```", "```cpp\n    BOOST_GLOBAL_FIXTURE(global_fixture); \n    ```", "```cpp\nBOOST_GLOBAL_FIXTURE(global_fixture);\nBOOST_AUTO_TEST_CASE(test_case_globals)\n{\n   BOOST_TEST(g == 1); // error, g not accessible\nBOOST_TEST(true);\n} \n```", "```cpp\n#define BOOST_TEST_MODULE Controlling output\n#include <boost/test/included/unit_test.hpp>\nBOOST_AUTO_TEST_CASE(test_case)\n{\n  BOOST_TEST(true);\n}\nBOOST_AUTO_TEST_SUITE(test_suite)\nBOOST_AUTO_TEST_CASE(test_case)\n{\n  int a = 42;\n  BOOST_TEST(a == 0);\n}\nBOOST_AUTO_TEST_SUITE_END() \n```", "```cpp\nRunning 2 test cases...\nf:/chapter11bt_05/main.cpp(14): error: in \"test_suite/test_case\": \ncheck a == 0 has failed [42 != 0]\n*** 1 failure is detected in the test module \"Controlling output\" \n```", "```cpp\nchapter11bt_05.exe -f XML\n**<TestLog><Error file=\"f:/chapter11bt_05/main.cpp\"** \n**line=\"14\"><![CDATA[check a == 0 has failed [42 != 0]]]>**\n**</Error></TestLog>**\n*** 1 failure is detected in the test module \"Controlling output\"\nchapter11bt_05.exe -m XML\nRunning 2 test cases...\nf:/chapter11bt_05/main.cpp(14): error: in \"test_suite/test_case\": \ncheck a == 0 has failed [42 != 0]\n**<TestResult><TestSuite name=\"Controlling output\" result=\"failed\"** \n**assertions_passed=\"1\" assertions_failed=\"1\" warnings_failed=\"0\"** \n**expected_failures=\"0\" test_cases_passed=\"1\"** \n**test_cases_passed_with_warnings=\"0\" test_cases_failed=\"1\"** \n**test_cases_skipped=\"0\" test_cases_aborted=\"0\"></TestSuite>**\n</TestResult> \n```", "```cpp\n    #include <gtest/gtest.h>\n    TEST(FirstTestSuite, FirstTest)\n    {\n      int a = 42;\n      ASSERT_TRUE(a > 0);\n    }\n    int main(int argc, char **argv) \n    {\n      testing::InitGoogleTest(&argc, argv);\n      return RUN_ALL_TESTS();\n    } \n    ```", "```cpp\n[==========] Running 1 test from 1 test suite.\n[----------] Global test environment set-up.\n[----------] 1 test from FirstTestCase\n[ RUN      ] FirstTestCase.FirstTestFunction\n[       OK ] FirstTestCase.FirstTestFunction (1 ms)\n[----------] 1 test from FirstTestCase (1 ms total)\n[----------] Global test environment tear-down\n[==========] 1 test from 1 test suite ran. (2 ms total)\n[  PASSED  ] 1 test. \n```", "```cpp\n#include \"gtest/gtest.h\"\nint main(int argc, char** argv)\n{\n  testing::GTEST_FLAG(throw_on_failure) = true;\n  testing::InitGoogleTest(&argc, argv);\n} \n```", "```cpp\n    TEST(TestConstruction, TestConstructor)\n    {\n      auto p = point3d{ 1,2,3 };\n      ASSERT_EQ(p.x(), 1);\n      ASSERT_EQ(p.x(), 2);\n      ASSERT_EQ(p.x(), 3);\n    }\n    TEST(TestConstruction, TestOrigin)\n    {\n      auto p = point3d::origin();\n      ASSERT_EQ(p.x(), 0);\n      ASSERT_EQ(p.x(), 0);\n      ASSERT_EQ(p.x(), 0);\n    } \n    ```", "```cpp\nNote: Google Test filter = TestConstruction.*-TestConstruction.TestConstructor\n[==========] Running 1 test from 1 test suite.\n[----------] Global test environment set-up.\n[----------] 1 test from TestConstruction\n[ RUN      ] TestConstruction.TestOrigin\n[       OK ] TestConstruction.TestOrigin (0 ms)\n[----------] 1 test from TestConstruction (0 ms total)\n[----------] Global test environment tear-down\n[==========] 1 test from 1 test suite ran. (2 ms total)\n[  PASSED  ] 1 test. \n```", "```cpp\nTEST(TestConstruction, DISABLED_TestConversionConstructor) \n{ /* ... */ }\nTEST(DISABLED_TestComparisons, TestEquality) \n{ /* ... */ }\nTEST(DISABLED_TestComparisons, TestInequality)\n{ /* ... */ } \n```", "```cpp\n    EXPECT_TRUE(2 + 2 == 2 * 2);\n    EXPECT_FALSE(1 == 2);\n    ASSERT_TRUE(2 + 2 == 2 * 2);\n    ASSERT_FALSE(1 == 2); \n    ```", "```cpp\n    auto a = 42, b = 10;\n    EXPECT_EQ(a, 42);\n    EXPECT_NE(a, b);\n    EXPECT_LT(b, a);\n    EXPECT_LE(b, 11);\n    EXPECT_GT(a, b);\n    EXPECT_GE(b, 10); \n    ```", "```cpp\n    auto str = \"sample\";\n    EXPECT_STREQ(str, \"sample\");\n    EXPECT_STRNE(str, \"simple\");\n    ASSERT_STRCASEEQ(str, \"SAMPLE\");\n    ASSERT_STRCASENE(str, \"SIMPLE\"); \n    ```", "```cpp\n    EXPECT_FLOAT_EQ(1.9999999f, 1.9999998f);\n    ASSERT_FLOAT_EQ(1.9999999f, 1.9999998f); \n    ```", "```cpp\n    void function_that_throws()\n    {\n      throw std::runtime_error(\"error\");\n    }\n    void function_no_throw()\n    {\n    }\n    TEST(TestAssertions, Exceptions)\n    {\n      EXPECT_THROW(function_that_throws(), std::runtime_error);\n      EXPECT_ANY_THROW(function_that_throws());\n      EXPECT_NO_THROW(function_no_throw());\n\n      ASSERT_THROW(function_that_throws(), std::runtime_error);\n      ASSERT_ANY_THROW(function_that_throws());\n      ASSERT_NO_THROW(function_no_throw());\n    } \n    ```", "```cpp\n    bool is_positive(int const val)\n    {\n      return val != 0;\n    }\n    bool is_double(int const val1, int const val2)\n    {\n      return val2 + val2 == val1;\n    }\n    TEST(TestAssertions, Predicates)\n    {\n      EXPECT_PRED1(is_positive, 42);\n      EXPECT_PRED2(is_double, 42, 21);\n\n      ASSERT_PRED1(is_positive, 42);\n      ASSERT_PRED2(is_double, 42, 21);\n    } \n    ```", "```cpp\n    ADD_FAILURE();\n    ADD_FAILURE_AT(__FILE__, __LINE__); \n    ```", "```cpp\n    class TestFixture : public testing::Test\n    {\n    }; \n    ```", "```cpp\n    protected:\n      TestFixture()\n      {\n        std::cout << \"constructing fixture\\n\";\n        data.resize(10);\n        std::iota(std::begin(data), std::end(data), 1);\n      }\n      ~TestFixture()\n      {\n        std::cout << \"destroying fixture\\n\";\n      } \n    ```", "```cpp\n    protected:\n      std::vector<int> data; \n    ```", "```cpp\n    TEST_F(TestFixture, TestData)\n    {\n      ASSERT_EQ(data.size(), 10);\n      ASSERT_EQ(data[0], 1);\n      ASSERT_EQ(data[data.size()-1], data.size());\n    } \n    ```", "```cpp\n    class TestEnvironment : public testing::Environment\n    {\n    }; \n    ```", "```cpp\n    public:\n      virtual void SetUp() override \n     {\n        std::cout << \"environment setup\\n\";\n      }\n      virtual void TearDown() override \n     {\n        std::cout << \"environment cleanup\\n\";\n      }\n      int n{ 42 }; \n    ```", "```cpp\n    int main(int argc, char **argv)\n    {\n      testing::InitGoogleTest(&argc, argv);\n      testing::AddGlobalTestEnvironment(new TestEnvironment{});\n      return RUN_ALL_TESTS();\n    } \n    ```", "```cpp\n#include <gtest/gtest.h>\nTEST(Sample, Test)\n{\n  auto a = 42;\n  ASSERT_EQ(a, 0);\n}\nint main(int argc, char **argv)\n{\n  testing::InitGoogleTest(&argc, argv);\n  return RUN_ALL_TESTS();\n} \n```", "```cpp\n[==========] Running 1 test from 1 test suite.\n[----------] Global test environment set-up.\n[----------] 1 test from Sample\n[ RUN      ] Sample.Test\nf:\\chapter11gt_05\\main.cpp(6): error: Expected equality of these values:\n  a\n    Which is: 42\n  0\n[  FAILED  ] Sample.Test (1 ms)\n[----------] 1 test from Sample (1 ms total)\n[----------] Global test environment tear-down\n[==========] 1 test from 1 test suite ran. (3 ms total)\n[  PASSED  ] 0 tests.\n[  FAILED  ] 1 test, listed below:\n[  FAILED  ] Sample.Test\n 1 FAILED TEST \n```", "```cpp\n    chapter11gt_05.exe --gtest_output=xml:report.xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <testsuites tests=\"1\" failures=\"1\" disabled=\"0\" errors=\"0\" \n                time=\"0.007\" timestamp=\"2020-05-18T19:00:17\" \n                name=\"AllTests\">\n      <testsuite name=\"Sample\" tests=\"1\" failures=\"1\" disabled=\"0\" \n                 errors=\"0\" time=\"0.002\"\n                 timestamp=\"2020-05-18T19:00:17\">\n        <testcase name=\"Test\" status=\"run\" result=\"completed\" time=\"0\"\n                  timestamp=\"2020-05-18T19:00:17\" classname=\"Sample\">\n          <failure message=\"f:\\chapter11gt_05\\main.cpp:6&#x0A;Expected equality of these values:&#x0A;  a&#x0A;    Which is: 42&#x0A;  0&#x0A;\" type=\"\"><![CDATA[f:\\chapter11gt_05\\main.cpp:6\n    Expected equality of these values:\n      a\n        Which is: 42\n      0\n    ]]></failure> \n        </testcase>\n      </testsuite>\n    </testsuites> \n    ```", "```cpp\n    chapter11gt_05.exe --gtest_color=no \n    ```", "```cpp\n    chapter11gt_05.exe --gtest_print_time=0\n    [==========] Running 1 test from 1 test suite.\n    [----------] Global test environment set-up.\n    [----------] 1 test from Sample\n    [ RUN      ] Sample.Test\n    f:\\chapter11gt_05\\main.cpp(6): error: Expected equality of these values:\n      a\n        Which is: 42\n      0\n    [  FAILED  ] Sample.Test\n    [----------] Global test environment tear-down\n    [==========] 1 test from 1 test suite ran.\n    [  PASSED  ] 0 tests.\n    [  FAILED  ] 1 test, listed below:\n    [  FAILED  ] Sample.Test\n     1 FAILED TEST \n    ```", "```cpp\n    #include \"catch_amalgamated.hpp\"\n    TEST_CASE(\"first_test_case\", \"[learn][catch]\")\n    {\n      SECTION(\"first_test_function\")\n      {\n        auto i{ 42 };\n        REQUIRE(i == 42);\n      }\n    } \n    ```", "```cpp\n    cmake -Bbuild -H. -DBUILD_TESTING=OFF\n    sudo cmake --build build/ --target instal \n    ```", "```cpp\n    cmake -Bbuild -H. -DBUILD_TESTING=OFF\n    cmake --build build/ --target instal \n    ```", "```cpp\n    #include <catch2/catch_test_macros.hpp>\n    TEST_CASE(\"first_test_case\", \"[learn][catch]\")\n    {\n       SECTION(\"first_test_function\")\n       {\n          auto i{ 42 };\n          REQUIRE(i == 42);\n       }\n    } \n    ```", "```cpp\n    find_package(Catch2 3 REQUIRED)\n    add_executable(Test main.cpp)\n    target_link_libraries(Test PRIVATE Catch2::Catch2WithMain) \n    ```", "```cpp\n=========================================================\nAll tests passed (1 assertion in 1 test cases) \n```", "```cpp\nSCENARIO(\"first_scenario\", \"[learn][catch]\")\n{\n  GIVEN(\"an integer\")\n  {\n    auto i = 0;\n    WHEN(\"assigned a value\")\n    {\n      i = 42;\n      THEN(\"the value can be read back\")\n      {\n        REQUIRE(i == 42);\n      }\n    }\n  }\n} \n```", "```cpp\n=========================================================\nAll tests passed (1 assertion in 1 test cases) \n```", "```cpp\n---------------------------------------------------------------\nf:\\chapter11ca_01\\main.cpp(11)\n...............................................................\nf:\\chapter11ca_01\\main.cpp(13): FAILED:\n  REQUIRE( i == 0 )\nwith expansion:\n  42 == 0\n===============================================================\ntest cases: 1 | 1 failed\nassertions: 1 | 1 failed \n```", "```cpp\n    TEST_CASE(\"test construction\", \"[create]\")\n    {\n      // define sections here\n    } \n    ```", "```cpp\n    TEST_CASE(\"test construction\", \"[create]\")\n    {\n      SECTION(\"test constructor\")\n      {\n        auto p = point3d{ 1,2,3 };\n        REQUIRE(p.x() == 1);\n        REQUIRE(p.y() == 2);\n        REQUIRE(p.z() == 4);\n      }\n    } \n    ```", "```cpp\n    TEST_CASE(\"test operations\", \"[modify]\")\n    {\n      SECTION(\"test methods\")\n      {\n        SECTION(\"test offset\")\n        {\n          auto p = point3d{ 1,2,3 };\n          p.offset(1, 1, 1);\n          REQUIRE(p.x() == 2);\n          REQUIRE(p.y() == 3);\n          REQUIRE(p.z() == 3);\n        }\n      }\n    } \n    ```", "```cpp\n    SCENARIO(\"modify existing object\")\n    {\n      // define sections here\n    } \n    ```", "```cpp\n    SCENARIO(\"modify existing object\")\n    {\n      GIVEN(\"a default constructed point\")\n      {\n        auto p = point3d{};\n        REQUIRE(p.x() == 0);\n        REQUIRE(p.y() == 0);\n        REQUIRE(p.z() == 0);\n        WHEN(\"increased with 1 unit on all dimensions\")\n        {\n          p.offset(1, 1, 1);\n          THEN(\"all coordinates are equal to 1\")\n          {\n            REQUIRE(p.x() == 1);\n            REQUIRE(p.y() == 1);\n            REQUIRE(p.z() == 1);\n          }\n        }\n      }\n    } \n    ```", "```cpp\n    chapter11ca_02.exe \"test construction\"\n    test construction\n       test constructor\n    -------------------------------------------------\n    f:\\chapter11ca_02\\main.cpp(7)\n    .................................................\n    f:\\chapter11ca_02\\main.cpp(12): FAILED:\n      REQUIRE( p.z() == 4 )\n    with expansion:\n      3 == 4\n    =================================================\n    test cases: 1 | 1 failed\n    assertions: 6 | 5 passed | 1 failed \n    ```", "```cpp\n    chapter11ca_02.exe \"test construction\" --section \"test origin\"\n    Filters: test construction\n    ==================================================\n    All tests passed (3 assertions in 1 test case) \n    ```", "```cpp\n    chapter11ca_02.exe --order lex \n    ```", "```cpp\n#define SCENARIO( ... ) TEST_CASE( \"Scenario: \" __VA_ARGS__ )\n#define GIVEN(desc)     INTERNAL_CATCH_DYNAMIC_SECTION(\"    Given: \" << desc)\n#define AND_GIVEN(desc) INTERNAL_CATCH_DYNAMIC_SECTION(\"And given: \" << desc)\n#define WHEN(desc)      INTERNAL_CATCH_DYNAMIC_SECTION(\"     When: \" << desc)\n#define AND_WHEN(desc)  INTERNAL_CATCH_DYNAMIC_SECTION(\" And when: \" << desc)\n#define THEN(desc)      INTERNAL_CATCH_DYNAMIC_SECTION(\"     Then: \" << desc)\n#define AND_THEN(desc)  INTERNAL_CATCH_DYNAMIC_SECTION(\"      And: \" << desc) \n```", "```cpp\n    int a = 42;\n    CHECK(a == 42);\n    REQUIRE(a == 42); \n    ```", "```cpp\n    int a = 42;\n    CHECK_FALSE(a > 100);\n    REQUIRE_FALSE(a > 100); \n    ```", "```cpp\n    double a = 42.5;\n    CHECK_THAT(42.0, Catch::Matchers::WithinAbs(a, 0.5));\n    REQUIRE_THAT(42.0, Catch::Matchers::WithinAbs(a, 0.5));\n    CHECK_THAT(42.0, Catch::Matchers::WithinRel(a, 0.02));\n    REQUIRE_THAT(42.0, Catch::Matchers::WithinRel(a, 0.02)); \n    ```", "```cpp\n    void function_that_throws()\n    {\n      throw std::runtime_error(\"error\");\n    }\n    void function_no_throw()\n    {\n    }\n    SECTION(\"expressions\")\n    {\n      CHECK_NOTHROW(function_no_throw());\n      REQUIRE_NOTHROW(function_no_throw());\n\n      CHECK_THROWS(function_that_throws());\n      REQUIRE_THROWS(function_that_throws());\n\n      CHECK_THROWS_AS(function_that_throws(), std::runtime_error);\n      REQUIRE_THROWS_AS(function_that_throws(), std::runtime_error);\n\n      CHECK_THROWS_WITH(function_that_throws(), \"error\");\n      REQUIRE_THROWS_WITH(function_that_throws(), \n              Catch::Matchers::ContainsSubstring(\"error\"));\n    } \n    ```", "```cpp\n    std::string text = \"this is an example\";\n    CHECK_THAT(\n      text,\n      Catch::Matchers::ContainsSubstring(\"EXAMPLE\", Catch::CaseSensitive::No));\n    REQUIRE_THAT(\n      text,\n      Catch::Matchers::StartsWith(\"this\") && \n      Catch::Matchers::ContainsSubstring(\"an\")); \n    ```", "```cpp\nf:\\chapter11ca_03\\main.cpp(19): FAILED:\n  REQUIRE( a == 1 )\nwith expansion:\n  42 == 1 \n```", "```cpp\nREQUIRE(a < 10 || a %2 == 0);   // error \n```", "```cpp\nauto expr = a < 10 || a % 2 == 0;\nREQUIRE(expr); \n```", "```cpp\nREQUIRE((a < 10 || a %2 == 0)); // OK \n```", "```cpp\n    REQUIRE_THAT(42.0, WithinAbs(42.5, 0.5)); \n    ```", "```cpp\n    REQUIRE_THAT(42.0, WithinRel(42.4, 0.01)); \n    ```", "```cpp\n    REQUIRE_THAT(42.0, WithinRel(target, 4)); \n    ```", "```cpp\nREQUIRE_THAT(a,\n  Catch::Matchers::WithinRel(42.0, 0.001) ||\n  Catch::Matchers::WithinAbs(42.0, 0.000001)); \n```", "```cpp\nclass OnTheLine : public Catch::Matchers::MatcherBase<point3d>\n{\n  point3d const p1;\n  point3d const p2;\npublic:\n  OnTheLine(point3d const & p1, point3d const & p2):\n    p1(p1), p2(p2)\n  {}\n  virtual bool match(point3d const & p) const override\n {\n    auto rx = p2.x() - p1.x() != 0 ? \n             (p.x() - p1.x()) / (p2.x() - p1.x()) : 0;\n    auto ry = p2.y() - p1.y() != 0 ? \n             (p.y() - p1.y()) / (p2.y() - p1.y()) : 0;\n    auto rz = p2.z() - p1.z() != 0 ? \n             (p.z() - p1.z()) / (p2.z() - p1.z()) : 0;\n    return \n      Catch::Approx(rx).epsilon(0.01) == ry &&\n      Catch::Approx(ry).epsilon(0.01) == rz;\n  }\nprotected:\n  virtual std::string describe() const\n {\n    std::ostringstream ss;\n    ss << \"on the line between \" << p1 << \" and \" << p2;\n    return ss.str();\n  }\n};\ninline OnTheLine IsOnTheLine(point3d const & p1, point3d const & p2)\n{\n  return OnTheLine {p1, p2};\n} \n```", "```cpp\nclass OnTheLine : public Catch::Matchers::MatcherGenericBase\n{\n   point3d const p1;\n   point3d const p2;\npublic:\n   OnTheLine(point3d const& p1, point3d const& p2) :\n      p1(p1), p2(p2)\n   {\n   }\n   bool match(point3d const& p) const\n {\n      auto rx = p2.x() - p1.x() != 0 ? \n                (p.x() - p1.x()) / (p2.x() - p1.x()) : 0;\n      auto ry = p2.y() - p1.y() != 0 ? \n                (p.y() - p1.y()) / (p2.y() - p1.y()) : 0;\n      auto rz = p2.z() - p1.z() != 0 ? \n                (p.z() - p1.z()) / (p2.z() - p1.z()) : 0;\n      return\n         Catch::Approx(rx).epsilon(0.01) == ry &&\n         Catch::Approx(ry).epsilon(0.01) == rz;\n   }\nprotected:\n   std::string describe() const override\n {\n#ifdef __cpp_lib_format\nreturn std::format(\"on the line between ({},{},{}) and ({},{},{})\", p1.x(), p1.y(), p1.z(), p2.x(), p2.y(), p2.z());\n#else\n      std::ostringstream ss;\n      ss << \"on the line between \" << p1 << \" and \" << p2;\n      return ss.str();\n#endif\n   }\n}; \n```", "```cpp\nTEST_CASE(\"matchers\")\n{\n  SECTION(\"point origin\")\n  {\n    point3d p { 2,2,2 };\n    REQUIRE_THAT(p, IsOnTheLine(point3d{ 0,0,0 }, point3d{ 3,3,3 }));\n  }\n} \n```", "```cpp\nTEST_CASE(\"case1\")\n{\n  SECTION(\"function1\")\n  {\n    REQUIRE(true);\n  }\n}\nTEST_CASE(\"case2\")\n{\n  SECTION(\"function2\")\n  {\n    REQUIRE(false);\n  }\n} \n```", "```cpp\n----------------------------------------------------------\ncase2\n  function2\n----------------------------------------------------------\nf:\\chapter11ca_04\\main.cpp(14)\n..........................................................\nf:\\chapter11ca_04\\main.cpp(16): FAILED:\n  REQUIRE( false )\n==========================================================\ntest cases: 2 | 1 passed | 1 failed\nassertions: 2 | 1 passed | 1 failed \n```", "```cpp\n    chapter11ca_04.exe -r junit\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <testsuites>\n      <testsuite name=\"chapter11ca_04.exe\" errors=\"0\" \n                 failures=\"1\"\n                 tests=\"2\" hostname=\"tbd\" \n                 time=\"0.002039\" \n                 timestamp=\"2020-05-02T21:17:04Z\">\n        <testcase classname=\"case1\" name=\"function1\" \n                  time=\"0.00016\"/>\n        <testcase classname=\"case2\" \n                  name=\"function2\" time=\"0.00024\">\n          <failure message=\"false\" type=\"REQUIRE\">\n            at f:\\chapter11ca_04\\main.cpp(16)\n          </failure>\n        </testcase>\n        <system-out/>\n        <system-err/>\n      </testsuite>\n    </testsuites> \n    ```", "```cpp\n    chapter11ca_04.exe -s\n    --------------------------------------------------\n    case1\n      function1\n    --------------------------------------------------\n    f:\\chapter11ca_04\\main.cpp(6)\n    ..................................................\n    f:\\chapter11ca_04\\main.cpp(8):\n    PASSED:\n      REQUIRE( true )\n    --------------------------------------------------\n    case2\n      function2\n    --------------------------------------------------\n    f:\\chapter11ca_04\\main.cpp(14)\n    ..................................................\n    f:\\chapter11ca_04\\main.cpp(16): \n    FAILED:\n      REQUIRE( false )\n    ==================================================\n    test cases: 2 | 1 passed | 1 failed\n    assertions: 2 | 1 passed | 1 failed \n    ```", "```cpp\n    chapter11ca_04.exe -o test_report.log \n    ```", "```cpp\n    chapter11ca_04.exe -d yes\n    0.000 s: scenario1\n    0.000 s: case1\n    --------------------------------------------------\n    case2\n       scenario2\n    --------------------------------------------------\n    f:\\chapter11ca_04\\main.cpp(14)\n    ..................................................\n    f:\\chapter11ca_04\\main.cpp(16): \n    FAILED:\n      REQUIRE( false )\n    0.003 s: scenario2\n    0.000 s: case2\n    0.000 s: case2\n    ==================================================\n    test cases: 2 | 1 passed | 1 failed\n    assertions: 2 | 1 passed | 1 failed \n    ```", "```cpp\n#include <catch2/catch_test_macros.hpp>\n#include <catch2/reporters/catch_reporter_teamcity.hpp> \n```", "```cpp\nchapter11ca_04.exe -r junit -o test_report.xml \n```"]