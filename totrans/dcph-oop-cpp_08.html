<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-157"><a id="_idTextAnchor399"/>8</h1>
<h1 id="_idParaDest-158"><a id="_idTextAnchor400"/>Mastering Abstract Classes</h1>
<p>This chapter will continue expanding our knowledge of object-oriented programming in C++. We will begin by exploring a powerful OO concept, <strong class="bold">abstract classes</strong>, and then progress to understanding how this idea is implemented in C++ through <em class="italic">direct language support</em>.</p>
<p>We will implement abstract classes using pure virtual functions to ultimately support refinements in a hierarchy of related classes. We will understand how abstract classes augment and pair with our understanding of polymorphism. We will also recognize how the OO concept of abstract classes presented in this chapter will support powerful and adaptable designs, allowing us to create easily extensible C++ code.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Understanding the OO concept of an abstract class</li>
<li>Implementing abstract classes with pure virtual functions</li>
<li>Creating interfaces using abstract classes and pure virtual functions</li>
<li><a id="_idTextAnchor401"/>Generalizing derived class objects using abstract classes, and upcasting and downcasting </li>
</ul>
<p>By the end of this chapter, you will understand the OO concept of an abstract class, and how to implement this idea in C++ through pure virtual functions. You will learn how abstract classes containing only pure virtual functions can define an OOP concept of an interface. You will understand how abstract classes and interfaces contribute to powerful OO designs. </p>
<p>You will see how we can very easily generalize groups of related, specialized objects using sets of abstract types. We will further explore up and downcasting within the hierarchy to understand what is allowed and when such typecasting is reasonable to employ.</p>
<p>By understanding the direct language support of abstract classes in C++ using pure virtual functions, as well as why creating interfaces is useful, you will have more tools available to create an extensible hierarchy of related classes. Let us expand our understanding of C++ as an OOP language by understanding how these concepts are implemented in C++.</p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor402"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter08">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter08</a>. Each full program example can be found in the GitHub under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <code>Chapter08</code> in a file named <code>Chp8-Ex1.cpp</code> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3SZv0jy">https://bit.ly/3SZv0jy</a>.</p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor403"/>Understanding the OO concept of an abstract class</h1>
<p>In this section, we will introduce<a id="_idIndexMarker629"/> an essential object-oriented concept, that<a id="_idIndexMarker630"/> of an abstract class. This concept will add to your growing knowledge base of key OO ideas including encapsulation, information hiding, generalization, specialization, and polymorphism. You know how to encapsulate a class. You also know how to build inheritance hierarchies using single inheritance, and various reasons<a id="_idIndexMarker631"/> to build hierarchies, such as supporting <em class="italic">Is-A</em> relationships or for the lesser-used reason of supporting implementation inheritance. Furthermore, you know how to employ runtime binding of methods to operations using the concept of polymorphism, implemented by virtual functions. Let’s extend our growing OO terminology by exploring <strong class="bold">abstract classes</strong>.</p>
<p>An <strong class="bold">abstract class</strong> is a base class that is intended to collect<a id="_idIndexMarker632"/> commonalities that may exist in derived classes for the purpose of asserting a common interface (that is, a set of operations) on the derived class. An abstract class does not represent a class that is intended for instantiation. Only objects of the derived class types may be instantiated.</p>
<p>Let’s start by looking at the C++ language feature that allows us to implement abstract classes, that is, pure virtual functio<a id="_idTextAnchor404"/>ns.</p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor405"/>Implementing abstract classes with pure virtual functions</h1>
<p>An abstract class<a id="_idIndexMarker633"/> is specified by introducing at least<a id="_idIndexMarker634"/> one abstract method (that is, a pure virtual function prototype) in the class definition. The OO concept of an <strong class="bold">abstract method</strong> is the specification of an operation<a id="_idIndexMarker635"/> with only its protocol for usage (that is, with only the <em class="italic">name</em> and <em class="italic">signature</em> of the member function), but with no definition for the function. An abstract method will be polymorphic, in that, having no definition, it is expected to be redefined by derived cla<a id="_idTextAnchor406"/>sses. </p>
<p>A <code>=0</code> after the arguments to the function. Additionally, it is important to understand the following nuances<a id="_idIndexMarker636"/> regarding pure virtual functions:</p>
<ul>
<li>Usually, definitions for pure virtual functions are not provided. This equates to the operation (prototype only) being specified at the base class level and all methods (member function definitions) being supplied at the derived class level. </li>
<li>Derived classes that do not provide methods for all pure virtual functions introduced by their base classes are also considered abstract and are therefore not instan<a id="_idTextAnchor407"/>tiable.</li>
<li>The <code>=0</code> in the prototype is merely an indication to the linker that a definition for this function need not be linked in (or resolved) when creating an executable program.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">An abstract class is designated by including one or more pure virtual function prototypes in the class definition. The optional definitions for these methods are not typically provided.</p>
<p>The reason that pure virtual functions<a id="_idIndexMarker637"/> will most often not have a definition<a id="_idIndexMarker638"/> is because they are meant to provide a protocol of usage for polymorphic operations to be implemented in descendent classes. A pure virtual function designates a class to be abstract; an abstract class cannot be instantiated. Therefore, a definition provided in a pure virtual function will never be selected as the appropriate method for a polymorphic operation because instances of the abstract type will never exist. That being said, a pure virtual function can still provide a definition that could be explicitly called using the scope resolution operator (<code>::</code>) and base class name. Perhaps, this default behavior might be meaningful as a helper function used by derived class implementations. </p>
<p>Let’s begin with a brief overview of the syntax required to specify an abstract class. Remember, a potential keyword of <em class="italic">abstract</em> is not used to specify an abstract class. Rather, by merely introducing one or more pure virtual functions, we have indicated the class to be an abstract class:</p>
<pre class="source-code">
class LifeForm    // Abstract class definition
{
private:
    // all LifeForms have a lifeExpectancy
    int lifeExpectancy = 0; // in-class initialization
public:
    LifeForm() = default; // def. ctor, uses in-class init 
    LifeForm(int life): lifeExpectancy(life) { }
    // Remember, we get default copy, even w/o proto below
    // LifeForm(const LifeForm &amp;form) = default; 
    // Must include prototype to specify virtual destructor
    virtual ~LifeForm() = default;   // virtual destructor
    // Recall, [[nodiscard]] requires ret. value to be used
    [[nodiscard]] int GetLifeExpectancy() const 
        { return lifeExpectancy; }
    <strong class="bold">virtual void Print() const = 0;</strong> // pure virtual fns. 
    <strong class="bold">virtual string IsA() const = 0;   </strong>
    <strong class="bold">virtual string Speak() const = 0;</strong>
};</pre>
<p>Notice that in the abstract<a id="_idIndexMarker639"/> class definition, we have introduced four virtual<a id="_idIndexMarker640"/> functions, three of which are pure virtual functions. The virtual destructor has no memory to release but is indicated as <code>virtual</code> so that it will be polymorphic, and so that the correct destruction sequence can be applied to derived class instances stored as pointers to base class types. </p>
<p>The three pure virtual functions, <code>Print()</code>, <code>IsA()</code>, and <code>Speak()</code>, are indicated with <code>=0</code> in their prototype. There<a id="_idIndexMarker641"/> are no definitions<a id="_idIndexMarker642"/> for these<a id="_idIndexMarker643"/> operations (though there optionally can be). A pure virtual function can have a default implementation, but not as an inline function. It will be the derived class’ responsibility to provide methods for these operations using the interface (that is, signature) specified by this base class definition. Here, the pure virtual functions provide the <em class="italic">interface</em> for the polymorphic operations that will be defined in derived class definitions.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Abstract classes will certainly have derived classes (since we cannot instantiate an abstract class itself). In order to allow the virtual destructor mechanism to work appropriately in the eventual<a id="_idIndexMarker644"/> hierarchy, be sure to include a <em class="italic">virtual destructor</em> in the abstract class definition. This will ensure that all derived class destructors are <em class="italic">virtual</em>, and can be overridden to provide the correct entry point in an object’s destruction sequence.</p>
<p>Now, let’s take a deeper look at what it means to have an interface, from an OO perspective.</p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor408"/>Creating interfaces </h1>
<p>An <strong class="bold">interface class</strong> is an OO concept of a class that is a further<a id="_idIndexMarker645"/> refinement of an abstract class. Whereas<a id="_idIndexMarker646"/> an abstract class can contain generalized<a id="_idIndexMarker647"/> attributes and default behaviors (by including data members and default definitions for pure virtual functions or by providing non-virtual member functions), an interface class will only contain abstract methods. An abstract class in C++ containing only abstract methods (that is, pure virtual functions with no optional definitions) can be thought of as an <strong class="bold">interface class</strong>. </p>
<p>When considering interface classes<a id="_idIndexMarker648"/> as implemented in C++, it is useful to remember the following:</p>
<ul>
<li>Abstract classes are not instantiable; they provide (via inheritance) the interfaces (that is, operations) that a derived class must offer.</li>
<li>Although a pure virtual function may contain an optional implementation (that is, method body) in the abstract class, this implementation should not be provided if the class wishes to be considered an interface class in pure OO terms.</li>
<li>Although an abstract class may have data members, it should not if the class wishes to be considered an interface class.</li>
<li>An abstract method, in OO terms, is an operation without a method; it is the interface only and is implemented in C++ as a pure virtual function.</li>
<li>As a reminder, be sure to include a virtual destructor prototype in the interface class definition; this will ensure that derived class destructors will be virtual. The destructor definition should be empty.</li>
</ul>
<p>Let’s consider various motivations for having interface classes within our OOP arsenal of implementation techniques. Some OOP languages follow very strict OO concepts and only allow for the implementation of very pure OO designs. Other OOP languages, such as C++, offer more flexibility, by allowing more radical OOP ideas to be implemented by the language directly. </p>
<p>For example, in pure object-oriented<a id="_idIndexMarker649"/> terms, inheritance should<a id="_idIndexMarker650"/> be reserved for <em class="italic">Is-A</em> relationships. We’ve seen implementation<a id="_idIndexMarker651"/> inheritance, which C++ supports through private and protected base classes. We’ve seen some acceptable uses of implementation inheritance, that is, to implement a new class in terms of another (with the ability to hide the underlying implementation with the use of protected and public base classes). </p>
<p>Another example of a fringe OOP feature is that of multiple inheritance. We’ll see in <a href="B19087_09.xhtml#_idTextAnchor426"><em class="italic">Chapter 9</em></a>, <em class="italic">Exploring Multiple Inheritance</em>, that C++ allows a class to be derived from more than one base class. In some cases, we are truly saying that the derived class has an Is-A relationship with potentially many base classes, but not always.</p>
<p>Some OOP languages do not allow multiple inheritance and those that do not rely more on interface classes to mix in the functionality of (otherwise) multiple base classes. In these situations, the OOP language can allow a derived class to implement the functionality as specified in multiple interface classes without actually using multiple inheritance. Ideally, interfaces are used to <em class="italic">mix-in</em> functionality from multiple classes. These classes, not<a id="_idIndexMarker652"/> surprisingly, are sometimes referred to as <strong class="bold">mix-in</strong> classes. In these situations, we are not saying that the Is-A relationship necessarily applies between derived and base classes.</p>
<p>In C++, when we introduce an abstract class with only pure virtual functions, we can think of creating an interface class. When a new class mixes in functionality from multiple interfaces, we can think of this in OO terms as using each interface class as a means to mix-in the desired interfaces for behaviors. Note that the derived classes must override each of the pure virtual functions with their own implementation; we’re mixing in only the required API. </p>
<p>C++’s implementation of the OO concept of an interface is merely that of an abstract class containing only pure virtual functions. Here, we’re using public inheritance from an abstract class paired with polymorphism to simulate the OO concept of an interface class. Note that other languages (such as Java) implement this idea directly in the language (but then those languages do not support multiple inheritance). In C++, we can do almost anything, yet it remains important to understand how to implement OO ideals (even those not offered with direct language support) in reasonable and meaningful ways.</p>
<p>Let’s see an example to illustrate<a id="_idIndexMarker653"/> an abstract class used to implement<a id="_idIndexMarker654"/> an interface class:</p>
<pre class="source-code">
<strong class="bold">class Charitable</strong>    // interface class definition
{                   // implemented using <a id="_idTextAnchor409"/>an abstract class
public:
    <strong class="bold">virtual void Give(float) = 0;</strong> // interface for 'giving'
    // must include prototype to specify virtual destructor
    <strong class="bold">virtual ~Charitable() = default;</strong> // remember virt. dest
};
class Person<strong class="bold">: public Charitable</strong>   <strong class="bold">// mix-in an 'interface'</strong>
{
    // Assume typical Person class definition w/ data
    // members, constructors, member functions exist.
public:
    <strong class="bold">virtual void Give(float amt) override</strong>
    {  // implement a means for giving here 
    }
    <strong class="bold">~Person() override;</strong>  // virtual destructor prototype
};
<strong class="bold">// Student Is-A Person which mixes-in Charitable interface</strong>
class Student: public Person 
{   
    // Assume typical Student class definition w/ data
    // members, constructors, member functions exist.
public:
    <strong class="bold">virtual void Give(float amt) override</strong>
    {  // Should a Student have little money to give,
       // perhaps they can donate their time equivalent to
       // the desired monetary amount they'd like to give
    }
    <strong class="bold">~Student() override;</strong>  // virtual destructor prototype 
};</pre>
<p>In the aforementioned class definitions, we first notice a simple interface class, <code>Charitable</code>, implemented using a restricted abstract class. We include no data members and a pure virtual function <code>virtual void Give(float) = 0;</code> to define the interface class. We also incl<a id="_idTextAnchor410"/>ude a virtual destructor.</p>
<p>Next, <code>Person</code> is derived from <code>Charitable</code> using public inheritance to implement the <code>Charitable</code> interface. We simply override <code>virtual void Give(float);</code> to provide a default definition for <em class="italic">giving</em>. We then derive <code>Student</code> from <code>Person</code>; note that a <em class="italic">Student Is-A Person that mixes-in (or implements) the Charitable interface</em>. In our <code>Student</code> class, we choose to redefine <code>virtual void Give(float);</code> to provide a more suitable <code>Give()</code> definition for <code>Student</code> instances. Perhaps students have limited finances and opt to donate an amount of their time that is equivalent to a predetermined monetary amount.</p>
<p>Here, we have used<a id="_idIndexMarker655"/> an abstract class in C++ to model<a id="_idIndexMarker656"/> the OO concept of an interface class.</p>
<p>Let’s continue with our discussion relating to abstract classes overall by examining how derived class objects may be collected by abstract class types.</p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor411"/>Generalizing derived class objects as abstract types </h1>
<p>We’ve seen in <a href="B19087_07.xhtml#_idTextAnchor366"><em class="italic">Chapter 7</em></a>, <em class="italic">Utilizing Dynamic Binding through Polymorphism</em>, that it is reasonable at times<a id="_idIndexMarker657"/> to group related derived class instances<a id="_idIndexMarker658"/> in a collection that is stored using base class pointers. Doing so allows uniform processing of related derived class types using polymorphic operations as specified by the base class. We also know that when a polymorphic base class operation is invoked, the correct derived class method will be invoked at runtime by virtue of the virtual functions and internal v-table that implement polymorphism in C++.</p>
<p>You may contemplate, however, whether it is possible to collect a group of related derived class types by a base class type that is an abstract class. Remember, an abstract class is not instantiable, so how might we store a derived class object as an object that cannot be instantiated? The solution is to use <em class="italic">pointers</em> (or even a reference). Whereas we cannot collect derived class instances in a set of abstract base class instances (those types cannot be instantiated), we can collect derived class instances in a set of pointers of the abstract class type. We may also have a reference of the abstract class type refer to a derived class instance. We’ve been doing this type of grouping (with base class pointers) since we learned about polymorphism. </p>
<p>Generalized groups of specialized objects employ implicit upcasting. Undoing such an upcast must be done using an explicit downcast, and the programmer will need to be correct as to the derived type that has been previously generalized. An incorrect downcast to the wrong type will cause a runtime error. </p>
<p>When is it necessary to collect derived class objects by base class types, including abstract base class types? The answer is when it makes sense in your application to process related derived class types in a more generic way, that is, when the operations specified in the base class type account for all of the operations you’d like to utilize. Undeniably, you may find just as many situations where keeping derived class instances in their own type (to utilize specialized operations introduced at the derived class level) is reasonable. Now you understand what is possible.</p>
<p>Let’s continue by examining a comprehensive example showing abstract classes in action. </p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor412"/>Putting all the pieces together </h1>
<p>So far in this chapter, we have understood<a id="_idIndexMarker659"/> the subtleties of abstract classes, including pure virtual functions, and how to create interface classes using abstract classes and pure virtual functions. It is always important to see our code in action, with all its various components and their various nuances. </p>
<p>Let’s take a look at a more complex, full program example to fully illustrate abstract classes, implemented using pure virtual functions in C++. In this example, we will not further designate an abstract class as an interface class, but we will take the opportunity to collect related derived class types using a set of pointers of their abstract base class type. This example will be broken into many segments; the full program can be found in the following GitHub location:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter08/Chp8-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter08/Chp8-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using std::cout;     // preferred to:  using namespace std;
using std::endl;
using std::setprecision;
using std::string;
using std::to_string;
constexpr int MAX = 5;
class LifeForm   // abstract class definition
{
private:
   int lifeExpectancy = 0;  // in-class initialization
public:
   LifeForm() = default;
   LifeForm(int life): lifeExpectancy(life) { }
   // Remember, we get the default copy ctor included,
   // even without the prototype below:
   // LifeForm(const LifeForm &amp;) = default; 
   // Must include prototype to specify virtual destructor
   virtual ~LifeForm() = default;     // virtual destructor
   [[nodiscard]] int GetLifeExpectancy() const 
       { return lifeExpectancy; }
   <strong class="bold">virtual void Print() const = 0;</strong>   // pure virtual fns. 
   <strong class="bold">virtual string IsA() const = 0;   </strong>
   <strong class="bold">virtual string Speak() const = 0;</strong>
};</pre>
<p>In the aforementioned<a id="_idIndexMarker660"/> class definition, we notice that <code>LifeForm</code> is an abstract class. It is an abstract class because it contains at least one pure virtual function definition. In fact, it contains three pure virtual function definitions, name<a id="_idTextAnchor413"/>ly <code>Print()</code>, <code>IsA()</code>, and <code>Speak()</code>.</p>
<p>Now, let’s extend <code>Lifeform</code> with a concrete derived class, <code>Cat</code>: </p>
<pre class="source-code">
class Cat: public LifeForm
{
private:
   int numberLivesLeft = 9;  // in-class initialization
   string name;
   static constexpr int CAT_LIFE = 15;  // Life exp for cat
public:
   Cat(): LifeForm(CAT_LIFE) { } // note prior in-class init
   Cat(int lives): LifeForm(CAT_LIFE),
                   numberLivesLeft(lives) { }
   Cat(const string &amp;);
   // Because base class destructor is virtual, ~Cat() is 
   // automatically virtual (overridden) whether or not 
   // explicitly prototyped. Below prototype not needed:
   // ~Cat() override = default;   // virtual destructor
   const string &amp;GetName() const { return name; }
   int GetNumberLivesLeft() const 
       { return numberLivesLeft; }
   <strong class="bold">void Print() const o<a id="_idTextAnchor414"/>verride;</strong> // redef pure virt fns
   <strong class="bold">string IsA() const override</strong> { return "Cat"; }
   <strong class="bold">string Speak() const override</strong> { return "Meow!"; }
};
Cat::Cat(const string &amp;n) : LifeForm(CAT_LIFE), name(n)
{  // numLivesLeft will be set with in-class initialization
}
void Cat::Print() const
{
   cout &lt;&lt; "\t" &lt;&lt; name &lt;&lt; " has " &lt;&lt; numberLivesLeft;
   cout &lt;&lt; " lives left" &lt;&lt; endl;
}</pre>
<p>In the previous segment of code, we see the class definition for <code>Cat</code>. Notice that <code>Cat</code> has redefined <code>LifeForm</code>’s pure virtual<a id="_idIndexMarker661"/> functions <code>Print()</code>, <code>IsA()</code>, and <code>Speak()</code> by providing definitions<a id="_idIndexMarker662"/> for each of these<a id="_idIndexMarker663"/> methods in the <code>Cat</code> class. With<a id="_idIndexMarker664"/> the existing methods in place for these functions, any derived class of <code>Cat</code> may optionally choose to redefine these methods with more suitable versions (but they are no longer obligated to do so).</p>
<p>Note that if <code>Cat</code> had failed to redefine even one of the pure virtual functions of <code>LifeForm</code>, then <code>Cat</code> would also be considered an abstract class and therefore not instantiable.</p>
<p>As a reminder, even though virtual functions <code>IsA()</code> and <code>Speak()</code> are written inline to abbreviate the code, virtual functions will almost never be inlined by the compiler, as their correct method must be determined at runtime (except for a few cases involving compiler devirtualization, involving final methods, or when an instance’s dynamic type is known).</p>
<p>Notice that in the <code>Cat</code> constructors, the member initialization list is used to select the <code>LifeForm</code> constructor that takes an integer argument (that is, <code>:LifeForm(CAT_LIFE)</code>). A value of <code>15</code> (<code>CAT_LIFE</code>) is passed up to the <code>LifeForm</code> constructor to initialize <code>lifeExpectancy</code>, defined in <code>LifeForm</code>, to the value of <code>15</code>. The member initialization list is additionally used to initialize data members defined in the <code>Cat</code> class for the cases when in-class initialization is not used (that is, the value is determ<a id="_idTextAnchor415"/>ined by a parameter to the method).</p>
<p>Now, let’s move forward to the class definition for <code>Person</code>, along with its inline functions:</p>
<pre class="source-code">
class Person: public LifeForm
{
private: 
    string firstName;
    string lastName;
    char middleInitial = '\0';
    string title;  // Mr., Ms., Mrs., Miss, Dr., etc.
    static constexpr int PERSON_LIFE = 80;  // Life exp of
protected:                                  // a Person
    void ModifyTitle(const string &amp;);  
public:
    Person();   // programmer-specified default constructor
    Person(const string &amp;, const string &amp;, char, 
           const string &amp;);  
    // Default copy constructor prototype is not necessary:
    // Person(const Person &amp;) = default;  // copy const.
    // Because base class destructor is virtual, ~Person() 
    // is automatically virtual (overridden) whether or not 
    // explicitly prototyped. Below prototype not needed:
    // ~Person() override = default;  // destructor
    const string &amp;GetFirstName() const 
        { return firstName; }  
    const string &amp;GetLastName() const 
        { return lastName; }    
    const string &amp;GetTitle() const { return title; } 
    char GetMiddleInitia<a id="_idTextAnchor416"/>l() const { return middleInitial; }
    <strong class="bold">void Print() const override;</strong> // redef pure virt fns
    <strong class="bold">string IsA() const override;   </strong>
    <strong class="bold">string Speak() const override;</strong>
};</pre>
<p>Notice that <code>Person</code> now extends <code>LifeForm</code> using public<a id="_idIndexMarker665"/> inheritance. In previous chapters, <code>Person</code> was a base class at the top of the inheritance hierarchy. <code>Person</code> redefines the pure virtual functions from <code>LifeForm</code>, namely, <code>Print()</code>, <code>IsA()</code>, and <code>Speak()</code>. As such, <code>Person</code> is now a concrete class and can be instantiated.</p>
<p>Now, let’s review<a id="_idIndexMarker666"/> the member function definitions for <code>Person</code>:</p>
<pre class="source-code">
// select the desired <a id="_idTextAnchor417"/>base constructor using mbr. init list
Person::Person(): LifeForm(PERSON_LIFE) 
{  // Remember, middleInitial will be set w/ in-class init
   // and the strings will be default constructed to empty
}
Person::Person(const string &amp;fn, const string &amp;ln, char mi,
               const string &amp;t): LifeForm(PERSON_LIFE), 
                               firstName(fn), lastName(ln),
                               middleInitial(mi), title(t)
{
}
// We're using the default copy constructor. But if we did
// choose to prototype and define it, the method would be:
// Person::Person(const Person &amp;p): LifeForm(p),
//           firstName(p.firstName), lastName(p.lastName),
//           middleInitial(p.middleInitial), title(p.title)
// {
// }
void Person::ModifyTitle(const string &amp;newTitle)
{
   title = newTitle;
}
void Person::Print() const
{
   cout &lt;&lt; "\t" &lt;&lt; title &lt;&lt; " " &lt;&lt; firstName &lt;&lt; " ";
   cout &lt;&lt; middleInitial &lt;&lt; ". " &lt;&lt; lastName &lt;&lt; endl;
}
string Person::IsA() const
{  
   return "Person";  
}
string Person::Speak() const 
{  
   return "Hello!";  
}  </pre>
<p>In the <code>Person</code> member functions, notice<a id="_idIndexMarker667"/> that we have<a id="_idIndexMarker668"/> implementations for <code>Print()</code>, <code>IsA()</code>, and <code>Speak()</code>. Additionally, notice<a id="_idIndexMarker669"/> that in two of the <code>Person</code> constructors, we<a id="_idIndexMarker670"/> select <code>:LifeForm(PERSON_LIFE)</code> in their member initialization lists to call the <code>LifeForm(int)</code> constructor. This call will set the private inherited data member <code>LifeExpectancy</code> to <code>80</code> (<code>PERSON_LIFE</code>) in the <code>LifeForm</code> subobject of a given <code>Person</code> instance.</p>
<p>Next, let’s review the <code>Student</code> class definition, along with its inline function definitions:</p>
<pre class="source-code">
class Student: public Person
{
private: 
    float gpa = 0.0;  // in-class initialization
    string currentCourse;
    const string studentId;  
    static int numStudents;
public:
    Student();  // programmer-supplied default constructor
    Student(const string &amp;, const string &amp;, char, 
            const string &amp;, float, const string &amp;, 
            const string &amp;); 
    Student(const Student &amp;);  // copy constructor
    ~Student() override;  // virtual destructor
    void EarnPhD();  
    float GetGpa() const { return gpa; }
  <a id="_idTextAnchor418"/>  const string &amp;GetCurrentCourse() const 
       { return currentCourse; }
    const string &amp;GetStudentId() const 
       { return studentId; }
    void SetCurrentCourse(const string &amp;);
    // Redefine not all of the virtrtual function; don't 
    // override Person::Speak(). Also, m<a id="_idTextAnchor419"/>ark Print() as 
    // the final override
    <strong class="bold">void Print() const final override; </strong>
    <strong class="bold">string IsA() const override;</strong>
    <strong class="bold">static int GetNumberStudents();  </strong>
};
int Student::numStudents = 0; // static data mbr def/init
inline void Student::SetCurrentCourse(const string &amp;c)
{
    currentCourse = c; 
}
inline int Student::GetNumberStudents()
{
    return numStudents;
}</pre>
<p>The aforementioned class definition<a id="_idIndexMarker671"/> for <code>Student</code> looks much as we’ve seen in the past. <code>Student</code> extends <code>Person</code> using public inheritance because a <code>Student</code> <em class="italic">Is-A</em> <code>Person</code>.</p>
<p>Moving forward, we’ll recall the non-inline <code>Student</code> class member functions:</p>
<pre class="source-code">
// default constructor
Student::Student(): studentId(to_string(numStudents + 100) 
                                         + "Id")
{   // Set const studentId in mbr init list with unique id 
    // (based upon numStudents counter + 100), concatenated
    // with the string "Id". Remember, string member
    // currentCourse will be default constructed with
    <a id="_idTextAnchor420"/>// an empty string - it is a member object
    numStudents++;
}
// Alternate constructor member function definition
Student::Student(const string &amp;fn, const string &amp;ln, 
                 char mi, const string &amp;t, float avg, 
                 const string &amp;course, const string &amp;id):
                 Person(fn, ln, mi, t), gpa(avg),
                 currentCourse(course), studentId(id)
{
    numStudents++;
}
// Copy constructor definition
Student::Student(const Student &amp;s) : Person(s), 
                 gpa(s.gpa), 
                 currentCourse(s.currentCourse),
                 studentId(s.studentId)
{
    numStudents++;
}
// destructor definition
Student::~Student()
{
    numStudents--;
}
void Student::EarnPhD()  
{   
   ModifyTitle("Dr.");  
}
void Student::Print() const
{
   cout &lt;&lt; "\t" &lt;&lt; GetTitle() &lt;&lt; " " &lt;&lt; GetFirstName();
   cout &lt;&lt; " " &lt;&lt; GetMiddleInitial() &lt;&lt; ". " 
        &lt;&lt; GetLastName();
   cout &lt;&lt; " id: " &lt;&lt; studentId &lt;&lt; "\n\twith gpa: ";
   cout &lt;&lt; setprecision(3) &lt;&lt; " " &lt;&lt; gpa 
        &lt;&lt; " enrolled in: " &lt;&lt; currentCourse &lt;&lt; endl;
}
string Student::IsA() const
{  
   return "Student";  
}</pre>
<p>In the previously listed section<a id="_idIndexMarker672"/> of code, we see the non-inline member function definitions for <code>Student</code>. The complete class definition <a id="_idTextAnchor421"/>is, at this point, largely familiar to us. </p>
<p>Accordingly, let’s examine<a id="_idIndexMarker673"/> the <code>main()</code> function:</p>
<pre class="source-code">
int main()
{
   // Notice that we are creating an array of POINTERS to
   // LifeForms. Since LifeForm cannot be instantiated, 
   // we could not create an array of LifeForm(s).
   LifeForm *entity[MAX] = { }; // init. with nullptrs
   entity[0] = new Person("Joy", "Lin", 'M', "Ms.");
   entity[1] = new Student("Renee", "Alexander", 'Z',
                           "Dr.", 3.95, "C++", "21-MIT"); 
   entity[2] = new Student("Gabby", "Doone", 'A', "Ms.", 
                            3.95, "C++", "18-GWU"); 
   entity[3] = new Cat("Katje");
   entity[4] = new Person("Giselle", "LeBrun", 'R',
                          "Miss");
   // Use range for-loop to process each element of entity
   for (LifeForm *item : entity)  // each item is a 
   {                              // LifeForm *       
      cout &lt;&lt; item-&gt;Speak();
      cout &lt;&lt; " I am a " &lt;&lt; item-&gt;IsA() &lt;&lt; endl;
      item-&gt;Print();
      cout &lt;&lt; "\tHas a life expectancy of: ";
      cout &lt;&lt; item-&gt;GetLifeExpectancy();
      cout &lt;&lt; "\n";
   }
   for (LifeForm *item : entity) // process each element 
   {                             // in the entity array    
      delete item;
      item = nullptr;   // ensure deleted ptr isn't used
   }
   return 0;
}</pre>
<p>Here, in <code>main()</code>, we declare<a id="_idIndexMarker674"/> an array of pointers to <code>LifeForn</code>. Recall, <code>LifeForm</code> is an abstract class. We could not create an array of <code>LifeForm</code> objects, because that would require us to be able to instantiate a <code>LifeForm</code>; we can’t – <code>LifeForm</code> is an abstract class.</p>
<p>However, we can create a set of pointers to an abstract type and this allows us to collect related types, <code>Person</code>, <code>Student</code>, and <code>Cat</code> instances in this set. Of course, the only operations we may apply to instances stored in this generalized fashion are those found in the abstract base class, <code>LifeForm</code>.</p>
<p>Next, we allocate a variety of <code>Person</code>, <code>Student</code>, and <code>Cat</code> instances, storing each instance via an element in the generalized set of pointers of type <code>LifeForm</code>. When any of these derived class instances is stored in this fashion, an implicit upcast to the abstract base class type is performed (but the instance is not altered in any fashion – we’re just pointing to the most base class subobject comprising the entire memory layout).</p>
<p>Now, we proceed through a loop to apply<a id="_idIndexMarker675"/> operations as found in the abstract class <code>LifeForm</code> to all instances<a id="_idIndexMarker676"/> in this generalized<a id="_idIndexMarker677"/> collection, such as <code>Speak()</code>, <code>Print()</code>, and <code>IsA()</code>. These operations happen to be polymorphic, allowing each instance’s most appropriate implementation to be utilized via dynamic binding. We additionally invoke <code>GetLifeExpectancy()</code> on each of these instances, which is a non-virtual function found at the <code>LifeForm</code> level. This function merely returns the life expectancy of the <code>LifeForm</code> in question.</p>
<p>Lastly, we loop through deleting<a id="_idIndexMarker678"/> the dynamically allocated instances of <code>Person</code>, <code>Student</code>, and <code>Cat</code> again using the generalized <code>LifeForm</code> pointers. We know that <code>delete()</code> will patch in a call to the destructor, and because the destructor is virtual, the appropriate starting level of the destructor and proper destruction sequence will commence. Additionally, by setting <code>item = nullptr;</code>, we are ensuring that the deleted pointer will not be used mistakenly as a bonafide address (we are overwriting each relinquished address with a <code>nullptr</code>).</p>
<p>The utility of the abstract class <code>LifeForm</code> in this example is that its use allows us to generalize common aspects and behaviors of all <code>LifeForm</code> objects together in one base class (such as <code>lifeExpectancy</code> and <code>GetLifeExpectancy()</code>). The common behaviors also extend to a set of pure virtual functions with the desired interfaces that all <code>LifeForm</code> objects <a id="_idTextAnchor422"/>should have, namely <code>Print()</code>, <code>IsA()</code>, and <code>Speak()</code>. </p>
<p class="callout-heading">Important reminder</p>
<p class="callout">An abstract class is one that collects common traits of derived classes, yet does not itself represent a tangible entity or object that should be instantiated. In order to specify a class as abstract, it must contain at least one pure virtual function.</p>
<p>Looking at the output for the aforementioned program, we can see that objects of various related derived class types are instantiated and processed uniformly. Here, we’ve collected these objects by their abstract base class type and have overridden the pure virtual functions in the base class with meaningful definitions in various derived classes.</p>
<p>Here is the output for the full program example: </p>
<pre>Hello! I am a Person
        Ms. Joy M. Lin
        Has a life expectancy of: 80
Hello! I am a Student
        Dr. Renee Z. Alexander id: 21-MIT
        with gpa:  3.95 enrolled in: C++
        Has a life expectancy of: 80
Hello! I am a Student
        Ms. Gabby A. Doone id: 18-GWU
        with gpa:  3.95 enrolled in: C++
        Has a life expectancy of: 80
Meow! I am a Cat
        Katje has 9 lives left
        Has a life expectancy of: 15
Hello! I am a Person
        Miss Giselle R. LeBrun
        Has a life expectancy of: 80     </pre>
<p>We have now thoroughly examined<a id="_idIndexMarker679"/> the OO idea of an abstract class and how it is implemented in C++ using pure virtual functions, as well as how these ideas can extend to creating OO interfaces. Let’s briefly recap the language features and OO concepts we’ve covered in this chapter before moving onward to our next chapter.</p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor423"/>Summary</h1>
<p>In this chapter, we have continued our progression with object-oriented programming, foremost, by understanding how pure virtual functions in C++ provide direct language support for the OO concept of an abstract class. We have explored how abstract classes without data members that do not contain non-virtual functions can support the OO ideal of an interface class. We’ve talked about how other OOP languages utilize interface classes, and how C++ may choose to support this paradigm as well by using such restricted abstract classes. We’ve upcast related derived class types to be stored as pointers of the abstract base class type, as a typical, and overall very useful, programming technique.</p>
<p>We have seen how abstract classes complement polymorphism not only by providing a class to specify common attributes and behaviors that derived classes share, but most notably to provide the interfaces of polymorphic behaviors for the related classes since abstract classes themselves are not instantiable. </p>
<p>By adding abstract classes and potentially the OO concept of interface classes to our programming repertoire in C++, we are able to implement designs that promote easily extensible code.</p>
<p>We are now ready to continue to <a href="B19087_09.xhtml#_idTextAnchor426"><em class="italic">Chapter 9</em></a>, <em class="italic">Exploring Multiple Inheritance</em>, to enhance our OOP skills by next learning how and when to appropriately utilize the concept of multiple inheritance, while understanding trade-offs and potential <a id="_idTextAnchor424"/>design alternatives. Let’s move forward!</p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor425"/>Questions</h1>
<ol>
<li>Create a hierarchy of shapes using the following guidelines:<ol><li>Create an abstract base class called <code>Shape</code>, which defines an operation to compute the area of a shape. Do not include a method for the <code>Area()</code> operation. Hint: use a pure virtual function.</li><li>Derive classes <code>Rectangle</code>, <code>Circle</code>, and <code>Triangle</code> from <code>Shape</code> using public inheritance. Optionally, derive class <code>Square</code> from <code>Rectangle</code>. Redefine the operation <code>Area()</code> that <code>Shape</code> has introduced, in each derived class. Be sure to provide the method to support the operation in each derived class so that you can later instantiate each type of <code>Shape</code>.</li><li>Add data members and other member functions as necessary to complete the newly introduced class definitions. Remember, only common attributes and operations should be specified in <code>Shape</code> – all others belong in their respective derived classes. Don’t forget to implement the copy constructor and access functions within each class definition.</li><li>Create an array of pointers of the abstract class type, <code>Shape</code>. Assign elements in this array point to instances of type <code>Rectangle</code>, <code>Square</code>, <code>Circle</code>, and <code>Triangle</code>. Since you are now treating derived class objects as generalized <code>Shape</code> objects, loop through the array of pointers and invoke the <code>Area()</code> function for each. Be sure to <code>delete()</code> any dynamically allocated memory you have allocated.</li><li>Is your abstract <code>Shape</code> class also an interface class in conceptual OO terms? Why, or why not?</li></ol></li>
</ol>
</div>
<div><div></div>
</div>
</div></body></html>