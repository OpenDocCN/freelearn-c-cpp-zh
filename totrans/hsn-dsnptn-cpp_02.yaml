- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Class and Function Templates
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和函数模板
- en: The template programming features of C++ form a large and complex subject, with
    many books dedicated exclusively to teaching these features. In this book, we
    will use many of the advanced C++ generic programming features. How, then, should
    we prepare ourselves to understand these language constructs as they make their
    appearance throughout this book? This chapter takes an informal approach—instead
    of precise definitions, we demonstrate the use of templates through examples and
    explain what the different language features do. If you find your knowledge lacking
    at this point, you’re encouraged to seek a deeper understanding and read one or
    more of the books dedicated entirely to the C++ language that are focused on explaining
    its syntax and semantics. Of course, if you wish for a more precise, formal description,
    you can refer to the C++ standard or a reference book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C++的模板编程特性是一个庞大而复杂的主题，许多书籍专门用于教授这些特性。在这本书中，我们将使用许多高级的C++泛型编程特性。那么，我们应该如何准备自己，以便理解这些语言结构，它们将在本书的各个部分出现？本章采用非正式的方法——而不是精确的定义，我们通过示例演示模板的使用，并解释不同的语言特性是如何工作的。如果你在这个时候发现自己的知识不足，鼓励你寻求更深入的理解，并阅读一本或更多专注于解释C++语言语法和语义的书籍。当然，如果你希望有一个更精确、更正式的描述，你可以参考C++标准或参考书籍。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Templates in C++
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中的模板
- en: Class and function templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和函数模板
- en: Template instantiations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板实例化
- en: Template specializations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板特化
- en: Overloading of template functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板函数的重载
- en: Variadic templates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变模板
- en: Lambda expressions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: Concepts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概念
- en: Templates in C++
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的模板
- en: One of the greatest strengths of C++ is its support for generic programming.
    In generic programming, the algorithms and data structures are written in terms
    of generic types that will be specified later. This allows the programmer to implement
    a function or a class once, and later, instantiate it for many different types.
    Templates are a C++ feature that allows classes and functions to be defined on
    generic types. C++ supports three kinds of templates—function, class, and variable
    templates.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C++最伟大的优势之一是它对泛型编程的支持。在泛型编程中，算法和数据结构是用泛型类型编写的，这些类型将在以后指定。这允许程序员一次实现一个函数或一个类，然后，为许多不同的类型实例化它。模板是C++的一个特性，允许在泛型类型上定义类和函数。C++支持三种类型的模板——函数、类和变量模板。
- en: Function templates
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数模板
- en: 'Function templates are generic functions—unlike regular functions, a template
    function does not declare its argument types. Instead, the types are template
    parameters:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板是泛型函数——与常规函数不同，模板函数不声明其参数类型。相反，类型是模板参数：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This template function can be used to increment a value of any type by one,
    for which adding one is a valid operation:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板函数可用于将任何类型的值增加一，其中加一是一个有效的操作：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most template functions have some limitations on the types that are used as
    their template parameters. For example, our `increment()` function requires that
    the expression `x + 1` is valid for the type of `x`. Otherwise, the attempt to
    instantiate the template will fail, with a somewhat verbose compilation error.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数模板函数对其模板参数的类型有一些限制。例如，我们的`increment()`函数要求表达式`x + 1`对`x`的类型是有效的。否则，尝试实例化模板将失败，并伴随着一些冗长的编译错误。
- en: 'Both non-member and class member functions can be function templates; however,
    virtual functions cannot be templates. The generic types can be used not only
    to declare function parameters but to declare any variables inside the body of
    the function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 非成员函数和类成员函数都可以是函数模板；然而，虚函数不能是模板。泛型类型不仅可以用来声明函数参数，还可以用来声明函数体内的任何变量：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In C++20, simple template declarations can be abbreviated: instead of writing'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20中，简单的模板声明可以被缩写：我们不需要写
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: we can write
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以写
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Other than more terse declarations, there is no particular advantage to this
    abbreviation, and the feature is quite limited. First of all, `auto` can be used
    only as the “top-level” parameter type; for example, this is invalid (but allowed
    by some compilers):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更简洁的声明外，这种缩写没有特别的优势，这个特性相当有限。首先，`auto`只能用作“顶级”参数类型；例如，这是无效的（但某些编译器允许）：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: and must still be written as
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 并且仍然需要写成
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, if you need to use template type parameters elsewhere in the function
    declaration, you can’t abbreviate them:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你需要在函数声明的其他地方使用模板类型参数，你不能简化它们：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Of course, you could declare the return type as `auto` and use the trailing
    return type:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以将返回类型声明为`auto`并使用尾随返回类型：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: but at this point, the template is not really “abbreviated.”
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这个阶段，模板实际上并没有“简化”。
- en: We will see more of function templates later, but let’s introduce class templates
    next.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后看到更多关于函数模板的内容，但接下来我们先介绍类模板。
- en: Class templates
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类模板
- en: 'Class templates are classes that use generic types, usually to declare their
    data members, but also to declare methods and local variables inside them:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板是使用泛型类型的类，通常用于声明其数据成员，但也可以在它们内部声明方法和局部变量：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This class is implemented once, and can then be used to define an array of
    two elements of any type:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只实现一次，然后可以用来定义任何类型的两个元素的数组：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Pay particular attention to the last example—you might expect the `ArrayOf2`
    template not to be valid with a type such as `char*`—after all, it has a method,
    `sum()`, that does not compile if the type of `a_[0]` and `a_[1]` is a pointer.
    However, our example compiles as written—a method of a class template does not
    have to be valid until we try to use it. If we never call `c.sum()`, then the
    fact that it would not compile never comes up, and the program remains valid.
    If we do call a member function that does not compile for the chosen template
    arguments, we get a syntax error in the body of the template (in our example,
    something about not being able to add two pointers). These error messages are
    rarely straightforward. Even if they were, it is unclear if the problem is in
    the body of the function, or if the function was not supposed to be called in
    the first place. Later in this chapter, we will see how to improve this situation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意最后一个例子——你可能认为`ArrayOf2`模板与`char*`这样的类型不兼容——毕竟，它有一个`sum()`方法，如果`a_[0]`和`a_[1]`的类型是指针，则无法编译。然而，我们的示例按原样编译——类模板的方法不需要在我们尝试使用它之前就有效。如果我们从未调用`c.sum()`，那么它无法编译的事实永远不会出现，程序仍然有效。如果我们调用了一个对于所选模板参数无法编译的成员函数，我们会在模板体中得到语法错误（在我们的例子中，关于无法将两个指针相加的错误）。这些错误信息很少直接明了。即使它们是直接的，也不清楚问题是否出在函数体中，或者函数从一开始就不应该被调用。在本章的后面部分，我们将看到如何改善这种情况。
- en: Variable templates
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量模板
- en: 'The last kind of template in C++ is a variable template, which was introduced
    in C++14\. This template allows us to define a variable with a generic type:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的最后一种模板是变量模板，它在C++14中引入。这种模板允许我们定义一个具有泛型类型的变量：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Variable templates are, for the most part, very straightforward to use, mostly
    for defining your own constants, but there are some interesting patterns that
    take advantage of them; we will see one in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 变量模板在大多数情况下非常简单易用，主要用于定义自己的常量，但也有一些有趣的模式可以利用它们；我们将在下一节中看到一个例子。
- en: Non-type template parameters
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非类型模板参数
- en: 'Usually, template parameters are types, but C++ also allows for several kinds
    of non-type parameters. First of all, template parameters can be values of integer
    or enumeration types:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，模板参数是类型，但C++还允许几种非类型参数。首先，模板参数可以是整数或枚举类型的值：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a template with two parameters—the first is a type, but the second is
    not. It is a value of type `size_t` that determines the size of the array; the
    advantage of such a template over a built-in C-style array is that it can do range
    checking. The C++ standard library has a `std::array` class template that should
    be used instead of implementing your own array in any real program, but it does
    make for an easy-to-follow example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有两个参数的模板——第一个是类型，但第二个不是。它是一个`size_t`类型的值，用于确定数组的大小；这种模板与内置的C风格数组相比的优势在于它可以进行范围检查。C++标准库中有一个`std::array`类模板，应该用于替代在任意实际程序中实现自己的数组，但它确实是一个易于理解的示例。
- en: The values of non-type parameters that are used to instantiate a template must
    be compile-time constants or `constexpr` values—the last line in the preceding
    example is invalid because the value of `a[0]` is not known until the program
    reads it in at runtime. C++20 allows floating-point and user-defined types for
    non-type template parameters; until then, the parameters were limited to integral
    types, pointers (including function and member pointers), references, and enumerations.
    Of course, the value of a non-type parameter has to be a compile-time constant
    so, for example, pointers to local variables are not allowed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用于实例化模板的非类型参数的值必须是编译时常量或 `constexpr` 值——前一个示例中的最后一行是无效的，因为 `a[0]` 的值直到程序在运行时读取它才已知。C++20
    允许非类型模板参数使用浮点数和用户定义的类型；在此之前，参数仅限于整型、指针（包括函数和成员指针）、引用和枚举。当然，非类型参数的值必须是编译时常量，因此，例如，不允许指向局部变量的指针。
- en: 'The numeric template parameters used to be very popular in C++ because they
    allow complex compile-time calculations to be implemented, but in the recent versions
    of the standard, `constexpr` functions can be used to the same effect and are
    much easier to read. Of course, the standard takes with one hand and gives with
    the other, and so an interesting new use case emerged for non-template parameters
    combined with `constexpr` functions: these functions, first introduced in C++11,
    are used to define “immediate functions,” or functions that are evaluated at compile
    time. The problem with `constexpr` functions is that they *may* evaluate at compile
    time but it’s not required; they could also be evaluated at run time:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，数值模板参数曾经非常流行，因为它们允许实现复杂的编译时计算，但在最近的版本标准中，`constexpr` 函数可以用来达到相同的效果，并且更容易阅读。当然，标准一手拿走，一手又给予，因此非模板参数与
    `constexpr` 函数结合出现了一个有趣的新用例：这些函数首次在 C++11 中引入，用于定义“即时函数”，或编译时评估的函数。`constexpr`
    函数的问题在于它们*可能*在编译时评估，但这不是必需的；它们也可能在运行时评估：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here we have a `constexpr` function `length()`. Does the length computation
    actually happen at compile time? There is no way to know short of examining the
    generated assembly code (which can differ from one compiler to another). The only
    way to be sure is to invoke the function in a compile-time context, for example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个 `constexpr` 函数 `length()`。长度计算实际上是在编译时发生的吗？除了检查生成的汇编代码（这可能会因编译器而异）外，没有其他方法可以知道。唯一确定的方法是在编译时上下文中调用该函数，例如：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first assert compiles, and the second does not even though the value 7
    is correct: the argument is not a compile-time value, so the evaluation must happen
    at run time.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个断言可以编译，而第二个即使值 7 是正确的也无法编译：论点是它不是一个编译时值，因此评估必须在运行时发生。
- en: 'In C++20, the function may be declared `consteval` instead of `constexpr`:
    this guarantees that the evaluation happens at compile time or not at all (thus,
    the second `cout` statement in the preceding example will not compile). Prior
    to C++20, we have to get creative. Here is one way to enforce compile-time execution:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 中，函数可以被声明为 `consteval` 而不是 `constexpr`：这保证了评估发生在编译时或者根本不发生（因此，前一个示例中的第二个
    `cout` 语句将无法编译）。在 C++20 之前，我们必须发挥创意。这里有一种强制编译时执行的方法：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `force_consteval` variable template can be used to enforce compile-time
    evaluation as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`force_consteval` 变量模板可以用来强制编译时评估，如下所示：'
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second `cout` statement does not compile because the function `length()`
    cannot be evaluated as an immediate function. The variable template `force_consteval`
    uses a non-type template parameter whose type is not specified but deduced from
    the template argument (an `auto` template parameter). This is a C++17 feature;
    in C++14 we have to use a rather unelegant macro to achieve the same result:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `cout` 语句无法编译，因为 `length()` 函数不能被评估为即时函数。变量模板 `force_consteval` 使用一个非类型模板参数，其类型未指定，而是从模板参数（一个
    `auto` 模板参数）推导得出。这是一个 C++17 的特性；在 C++14 中，我们必须使用一个相当不优雅的宏来实现相同的结果：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If a non-type template parameter seems “less than a type,” you will like the
    next option, a parameter that is definitely more than a simple type.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个非类型模板参数看起来“不如类型”，你会喜欢下一个选项，一个肯定比简单类型更复杂的参数。
- en: Template template parameters
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板模板参数
- en: The second kind of non-type template parameter worth mentioning is a *template
    template* parameter—a template parameter that is itself a template. We will need
    them in the later chapters of this book. This template parameter is substituted—not
    with a name of a class, but a name of an entire template.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的第二种非类型模板参数是**模板模板**参数——即本身也是模板的模板参数。在本书的后续章节中我们将需要它们。这个模板参数的替换不是用类的名称，而是用整个模板的名称。
- en: 'Here is a class template with a template template parameter:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个具有模板模板参数的类模板：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Builder` template declares a class that is used to construct (build) a
    container of an arbitrary type `T`. The container itself does not have a specific
    type, it’s a template itself.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Builder`模板声明了一个用于构造（构建）任意类型`T`的容器的类。容器本身没有特定的类型，它本身就是一个模板。'
- en: 'It can be instantiated with any container template that takes one type argument:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用任何接受一个类型参数的容器模板实例化：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Of course, there are additional requirements on the `Container` template: it
    must have a single type parameter `T` (the rest may be defaulted), it should be
    default-constructible, it must have a `push_back()` method, and so on. C++20 gives
    us a concise way to state these requirements and make them a part of the template
    interface; we will learn about it later in this chapter, in the *Concepts* section.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对`Container`模板还有额外的要求：它必须有一个单一的类型参数`T`（其余可以默认），它应该可以默认构造，它必须有一个`push_back()`方法，等等。C++20为我们提供了一种简洁的方式来表述这些要求，并将它们作为模板接口的一部分；我们将在本章的*概念*部分学习它。
- en: 'Here is a function template that has two template template parameters:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个具有两个模板模板参数的函数模板：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This function takes an arbitrary container as an argument and returns another
    container, a different template, but instantiated on the same type, with the values
    copied from the input container:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个任意的容器作为参数，并返回另一个容器，一个不同的模板，但实例化在相同的类型上，其值从输入容器复制而来：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the compiler deduces both the type of the template argument (`In_container`
    as `my_vector`) and the type of its template parameter (`T` as `int`). Of course,
    the remaining template parameter `Out_container` cannot be deduced (it is not
    used in any parameters of the template function) and must be explicitly specified,
    which fits our intended use.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，编译器推导出模板参数的类型（`In_container`作为`my_vector`）以及其模板参数的类型（`T`作为`int`）。当然，剩余的模板参数`Out_container`无法推导（它不在模板函数的任何参数中使用），必须显式指定，这符合我们的预期用途。
- en: 'There is a major limitation on template template parameters that is made more
    complex by the fact that different compilers enforce it unevenly (i.e., some compilers
    let through the code that should not compile but you would really like it to).
    The limitation is that the number of template parameters specified for the template
    template must match the number of the template parameters of the argument. Consider
    this template function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 模板模板参数有一个主要的限制，由于不同的编译器执行不均，这使得问题更加复杂（即，一些编译器通过了本应无法编译的代码，但你确实希望它能编译）。限制是，为模板模板指定的模板参数数量必须与参数的数量匹配。考虑这个模板函数：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code may compile, but it depends on the version of the standard and the
    compiler’s strict adherence to the standard: the `std::vector` template has two
    template parameters, not one. The second parameter is the allocator; it has a
    default value, which is why we do not have to specify the allocator type when
    declaring a vector object. GCC, Clang, and MSVC all relax this requirement to
    some degree (but not to the same degree). Variadic templates, which we will see
    later in this chapter, offer another, more robust solution (at least in C++17
    and later).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能可以编译，但这取决于标准的版本和编译器对标准的严格遵循：`std::vector`模板有两个模板参数，而不是一个。第二个参数是分配器；它有一个默认值，这就是为什么在声明向量对象时我们不必指定分配器类型。GCC、Clang和MSVC都在一定程度上放宽了这一要求（但程度不同）。变长模板，我们将在本章后面看到，提供了一个更稳健的解决方案（至少在C++17及以后版本中）。
- en: Templates are a kind of recipe for generating code. Next, we will see how we
    can convert these recipes into actual code we can run.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是生成代码的一种配方。接下来，我们将看到如何将这些配方转换为我们可以运行的实际代码。
- en: Template instantiations
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板实例化
- en: The template name is not a type and cannot be used to declare a variable or
    call a function. To create a type or a function, the template must be instantiated.
    Most of the time, templates are instantiated implicitly when they are used. We
    will again start with function templates.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 模板名称不是一个类型，不能用来声明变量或调用函数。要创建类型或函数，模板必须被实例化。大多数时候，模板在使用时隐式实例化。我们再次从函数模板开始。
- en: Function templates
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数模板
- en: 'To use a function template to generate a function, we have to specify which
    types should be used for all template type parameters. We can just specify the
    types directly:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用函数模板生成函数，我们必须指定所有模板类型参数应使用的类型。我们可以直接指定这些类型：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This instantiates the `half` function template with the `int` type. The type
    is explicitly specified; we could call the function with an argument of another
    type, as long as it is convertible to the type we requested:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `half` 函数模板实例化为 `int` 类型。类型是显式指定的；我们可以用另一种类型的参数调用该函数，只要它可转换为请求的类型：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Even though the argument is an `int`, the instantiation is that of `half<double>`,
    and the return type is `double`. The integer value `5` is implicitly converted
    to `double`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 即使参数是 `int` 类型，实例化的是 `half<double>`，返回类型是 `double`。整数值 `5` 被隐式转换为 `double`。
- en: 'Even though every function template can be instantiated by specifying all its
    type parameters, this is rarely done. Most of the uses of function templates involve
    the automatic deduction of types. Consider the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个函数模板都可以通过指定所有类型参数来实例化，但这很少发生。函数模板的大部分使用都涉及到类型的自动推导。考虑以下情况：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The template type can be deduced only from the template function arguments—the
    compiler will attempt to select the type for the `T` parameter to match the type
    of the function argument that is declared with the same type. In our case, the
    function template has the argument `x` of the `T` type. Any call to this function
    has to provide some value for this argument, and this value must have a type.
    The compiler will deduce that `T` must be that type. In the first call in the
    preceding code block, the argument is `5`, and its type is `int`. There is nothing
    better to do than to assume that `T` should be `int` in this particular template
    instantiation. Similarly, in the second call, we can deduce that `T` must be `double`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 模板类型只能从模板函数参数推导——编译器将尝试选择 `T` 参数的类型以匹配声明为相同类型的函数参数。在我们的例子中，函数模板具有 `T` 类型的 `x`
    参数。对这个函数的任何调用都必须为这个参数提供某个值，并且这个值必须有一个类型。编译器将推导出 `T` 必须是那种类型。在前面的代码块中的第一次调用中，参数是
    `5`，其类型是 `int`。在这种情况下，假设 `T` 应该是 `int` 是最好的选择。同样，在第二次调用中，我们可以推导出 `T` 必须是 `double`。
- en: 'After this deduction, the compiler performs type substitution: all other mentions
    of the `T` type are replaced by the type that was deduced; in our case, there
    is only one other use of `T`, which is the return type.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在此推导之后，编译器执行类型替换：所有其他对 `T` 类型的提及都被推导出的类型所替换；在我们的例子中，`T` 的其他使用只有一个是返回类型。
- en: 'Template argument deduction is widely used to capture types that we cannot
    easily determine:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数推导广泛用于捕获我们难以确定类型的场景：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we deduce the `T` type to be whatever the type of the expression `y +
    z` is (it’s `long`, but with template deduction, we don’t need to specify that
    explicitly, and the deduced type will *follow* the argument type if we ever change
    the types of `y` and `z`). Consider the following example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们推导出 `T` 类型为表达式 `y + z` 的类型（它是 `long`，但使用模板推导时，我们不需要显式指定，并且推导出的类型将*跟随*参数类型，如果我们更改
    `y` 和 `z` 的类型）。考虑以下示例：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We deduce `T` to match whatever type the `f()` template function returns for
    an `int` argument (of course, the definition of the `f()` template function has
    to be provided before it can be called, but we do not need to dig into the header
    files where `f()` is defined, as the compiler will deduce the right type for us).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推导出 `T` 以匹配 `f()` 模板函数对于 `int` 参数返回的类型（当然，在调用之前必须提供 `f()` 模板函数的定义，但我们不需要深入到定义
    `f()` 的头文件中，因为编译器会为我们推导正确的类型）。
- en: 'Only the types that are used to declare function arguments can be deduced.
    There is no rule that all template type parameters must be somehow present in
    the argument list, but any parameters that cannot be deduced must be explicitly
    specified:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 只有用于声明函数参数的类型才能被推导。没有规则要求所有模板类型参数都必须以某种方式出现在参数列表中，但任何无法推导的参数必须显式指定：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the first template type parameter is explicitly specified, so `U` is double,
    and `V` is deduced to be `int`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个模板类型参数被显式指定，所以`U`是`double`，而`V`被推断为`int`。
- en: 'Sometimes, the compiler cannot deduce template type parameters, even if they
    are used to declare arguments:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，编译器无法推断模板类型参数，即使它们被用来声明参数：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we can deduce from the first argument that `T` must be `long`, but from
    the second argument, we deduce that `T` must be `int`. It is often surprising
    to programmers who learn their way around templates that the `long` type is not
    deduced in this case—after all, if we substitute `long` for `T` everywhere, the
    second argument will be implicitly converted, and the function will compile fine.
    So why isn’t the *larger* type deduced? Because the compiler does not attempt
    to find a type for which all argument conversions are possible: after all, there
    is usually more than one such type. In our example, `T` could be `double` or `unsigned
    long`, and the function would still be valid. If a type can be deduced from more
    than one argument, the result of all these deductions must be the same.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以从第一个论据中推断出`T`必须是`long`，但从第二个论据中，我们推断出`T`必须是`int`。对于学习模板的程序员来说，通常很令人惊讶的是在这种情况下`long`类型没有被推断出来——毕竟，如果我们将`long`替换到每个地方，第二个论据将隐式转换，函数将能够编译。那么为什么没有推断出*更大的*类型呢？因为编译器并不试图找到一个类型，使得所有参数转换都是可能的：毕竟，通常有不止一个这样的类型。在我们的例子中，`T`可以是`double`或`unsigned
    long`，函数仍然有效。如果一个类型可以从多个参数中推断出来，那么所有这些推断的结果必须相同。
- en: Otherwise, the template instantiation is considered ambiguous.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，模板实例化被认为是模糊的。
- en: 'The type deduction is not always as straightforward as using the type of the
    argument for a type parameter. The argument may be declared with a type that’s
    more complex than a type parameter itself:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断并不总是像使用类型参数的类型那样直接。参数可能被声明为一个比类型参数本身更复杂的类型：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, the type of the argument is a *pointer to* `int`, but the type that is
    deduced for `T` is `int`. The deduction of types can be arbitrarily complex, as
    long as it’s unambiguous:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，参数的类型是一个指向`int`的*指针*，但推断给`T`的类型是`int`。类型的推断可以是任意复杂的，只要它是明确的：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, the argument is an instantiation of another template, `std::vector`, and
    we have to deduce the template parameter type from the type that was used to create
    this vector instantiation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，参数是另一个模板`std::vector`的实例化，我们必须从创建这个向量实例化的类型中推断模板参数类型。
- en: 'As we have seen, if a type can be deduced from more than one function argument,
    the result of these deductions must be the same. On the other hand, one argument
    can be used to deduce more than one type:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，如果一个类型可以从多个函数参数中推断出来，那么这些推断的结果必须相同。另一方面，一个参数可以用来推断多个类型：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we deduce two types, `U` and `V`, from one argument, then use these two
    types to form a new type, `std::pair<V, U>`. This example is unnecessarily verbose,
    and we can take advantage of a few more C++ features to make it both more compact
    and easier to maintain. First of all, the standard already has a function that
    deduces the argument types and uses them to declare a pair, and we have even used
    this function—`std::make_pair()`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从单个论据中推断出两个类型，`U`和`V`，然后使用这两个类型来形成一个新类型，`std::pair<V, U>`。这个例子过于冗长，我们可以利用一些更多的C++特性来使其更加紧凑且易于维护。首先，标准已经有一个函数可以推断参数类型并使用它们来声明一个pair，我们甚至已经使用了这个函数——`std::make_pair()`。
- en: 'Secondly, the return type of the function can be deduced from the expression
    in the `return` statement (a C++14 feature). The rules of this deduction are similar
    to the rules of the template argument type deduction. With these simplifications,
    our example becomes the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，函数的返回类型可以从`return`语句中的表达式推断出来（这是一个C++14特性）。这种推断的规则与模板参数类型推断的规则相似。有了这些简化，我们的例子变成了以下这样：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that we don’t explicitly use the types `U` and `V` anymore. We still need
    this function to be a template, since it operates on a generic type, that is,
    a pair of two types that we don’t know until we instantiate the function. We could,
    however, use only one template parameter that would stand for the type of the
    argument:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不再显式使用类型`U`和`V`。我们仍然需要这个函数是一个模板，因为它操作的是通用类型，即两个类型的组合，我们不知道直到实例化函数。然而，我们可以只使用一个模板参数来代表参数的类型：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There is a significant difference between these two variants—the last function
    template will have its type deduced successfully from any call with one argument,
    no matter the type of that argument. If that argument is not `std::pair`, or,
    more generally, if the argument is not a class or a struct or it does not have
    the `first` and `second` data members, the deduction will still succeed, but the
    type substitution will fail. On the other hand, the previous version will not
    even be considered for arguments that are not a pair of some types. For any `std::pair`
    argument, the pair types are deduced, and the substitution should proceed without
    a problem. Can we use the last declaration and still restrict the type `T` to
    be a pair or another class with a similar interface? Yes, and we will see several
    ways to do so later in this book.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个变体之间存在一个显著的区别——最后一个函数模板将从任何只有一个参数的调用中成功推导出类型，无论该参数的类型如何。如果该参数不是 `std::pair`，或者更一般地说，如果参数不是一个类或结构体，或者它没有
    `first` 和 `second` 数据成员，推导仍然会成功，但类型替换会失败。另一方面，上一个版本甚至不会考虑不是某些类型对的参数。对于任何 `std::pair`
    参数，将推导出对类型，并且替换应该没有问题。我们能否使用最后一个声明并仍然将类型 `T` 限制为对或具有类似接口的另一个类？是的，我们将在本书后面的部分看到几种方法来实现这一点。
- en: Member function templates are very similar to non-member function templates,
    and their arguments are similarly deduced. Member function templates can be used
    in classes or class templates, which we will review next.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数模板与非成员函数模板非常相似，它们的参数也是类似推导的。成员函数模板可以在类或类模板中使用，我们将在下一节中回顾这一点。
- en: Class templates
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类模板
- en: 'Instantiation of class templates is similar to that of function templates—the
    use of a template to create a type implicitly instantiates the template. To use
    a class template, we need to specify the type arguments for the template parameters:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板的实例化类似于函数模板的实例化——使用模板创建类型会隐式地实例化模板。要使用类模板，我们需要指定模板参数的类型参数：
- en: '[PRE35]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The definition of the `r` variable implicitly instantiates the `Ratio` class
    template for the `int` and `double` types. It also instantiates the default constructor
    of this class. The second constructor is not used in this code and is not instantiated.
    It is this feature of class templates—instantiating a template instantiates all
    data members, but does not instantiate the methods until they are used—that allows
    us to write class templates where only some of the methods compile for certain
    types. If we use the second constructor to initialize the values of `Ratio`, then
    that constructor is instantiated, and must be valid for the given types:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`r` 变量的定义隐式地实例化了 `Ratio` 类模板的 `int` 和 `double` 类型。它还实例化了该类的默认构造函数。在这个代码中，第二个构造函数没有被使用，也没有被实例化。这是类模板的一个特性——实例化一个模板会实例化所有数据成员，但直到它们被使用时才实例化方法——这使得我们能够编写只针对某些类型编译部分方法的类模板。如果我们使用第二个构造函数来初始化
    `Ratio` 的值，那么这个构造函数就会被实例化，并且必须对给定的类型有效：'
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In C++17, these constructors can be used to deduce the types of the class template
    from the constructor arguments:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++17 中，这些构造函数可以用来从构造函数参数推导出类模板的类型：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Of course, this works only if there are enough constructor arguments to deduce
    the types. For example, the default-constructed `Ratio` object has to be instantiated
    with explicitly specified types; there is simply no other way to deduce them.
    Prior to C++17, a helper function template was often used to construct an object
    whose type can be deduced from the arguments. Similarly to `std::make_pair()`,
    which we looked at previously, we can implement a `make_ratio` function that will
    do the same thing as the C++17 constructor argument deduction:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只有在有足够的构造函数参数可以推导类型时才有效。例如，默认构造的 `Ratio` 对象必须使用显式指定的类型来实例化；没有其他方法可以推导它们。在
    C++17 之前，经常使用辅助函数模板来构造一个可以从参数推导出类型的对象。类似于我们之前看过的 `std::make_pair()`，我们可以实现一个 `make_ratio`
    函数，它将执行与 C++17 构造函数参数推导相同的功能：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The C++17 way of deducing template arguments should be preferred, if it is
    available: it does not require writing another function that essentially duplicates
    the class constructor, and does not make an additional call to the copy or move
    constructor to initialize the object (although in practice most compilers will
    perform return value optimization and optimize away the call to the copy or move
    constructor).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 C++17 提供了推导模板参数的方式，应该优先使用：它不需要编写另一个本质上重复类构造函数的函数，也不需要调用复制或移动构造函数来初始化对象（尽管在实践中，大多数编译器都会执行返回值优化并优化掉对复制或移动构造函数的调用）。
- en: 'When a template is used to generate a type, it is instantiated implicitly.
    Both class and function templates can be explicitly instantiated as well. Doing
    so instantiates a template without using it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用模板生成类型时，它会隐式实例化。类和函数模板也可以显式实例化。这样做会实例化模板而不使用它：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Explicit instantiations are rarely needed, and will not be used elsewhere in
    this book.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 显式实例化很少需要，并且本书的其他地方不会使用。
- en: 'While instantiations of class templates with specific template parameters behave
    (mostly) like regular classes, static data members of class templates deserve
    special mention. First, let us recall the common challenge of static class data
    members: they must be defined somewhere, and only once:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然具有特定模板参数的类模板实例化行为（主要是）像常规类一样，但类模板的静态数据成员值得特别提及。首先，让我们回顾一下静态类数据成员的常见挑战：它们必须在某个地方定义，并且只能定义一次：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Without such a definition, the program will not link: the name `A::n` is not
    defined. But if the definition is moved into the header and the header is included
    in several compilation units, the program also will not link, this time the name
    `A::n` is multiply defined.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这样的定义，程序将无法链接：名称 `A::n` 未定义。但如果定义被移动到头文件中，并且头文件被包含在几个编译单元中，程序也将无法链接，这次名称 `A::n`
    是多重定义的。
- en: 'The requirement to define static data members exactly once is not feasible
    for class templates: we need them defined for every set of template parameters
    the template is instantiated with, and we can’t do that in any one compilation
    unit (other compilation units may instantiate the same template with different
    types). Fortunately, this is not necessary. Static members of class templates
    can (and should) be defined together with the template itself:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类模板，要求恰好定义一次静态数据成员是不切实际的：我们需要为模板实例化的每一组模板参数定义它们，我们无法在任何一个编译单元中做到这一点（其他编译单元可能以不同的类型实例化相同的模板）。幸运的是，这并不必要。类模板的静态成员可以（并且应该）与模板本身一起定义：
- en: '[PRE41]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: While this technically results in multiple definitions, it is the job of the
    linker to consolidate them so we are left with a single definition (there is only
    one value of a static member variable for all objects of the same type).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从技术上讲这会导致多个定义，但链接器的任务是合并它们，这样我们就能得到一个单一的定义（对于相同类型的所有对象，静态成员变量的值只有一个）。
- en: 'In C++17, inline variables offer a simpler solution:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++17 中，内联变量提供了一个更简单的解决方案：
- en: '[PRE42]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This also works for non-template classes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于非模板类：
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If the static data member of a class template has a non-trivial constructor,
    this constructor is invoked once for every instantiation of this template (not
    for every object – there is only one instance of a static member variable for
    all objects of the same type).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类模板的静态数据成员有一个非平凡的构造函数，则该构造函数会为每个模板实例化调用一次（而不是每个对象——对于相同类型的所有对象，静态成员变量只有一个实例）。
- en: Class templates, as we have used them so far, allow us to declare generic classes,
    that is, classes that can be instantiated with many different types. So far, all
    of these classes look exactly the same, except for the types, and generate the
    same code. This is not always desirable—different types may need to be handled
    somewhat differently.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的类模板允许我们声明泛型类，即可以用许多不同类型实例化的类。到目前为止，所有这些类看起来完全相同，除了类型外，并且生成相同的代码。这并不总是希望的——不同的类型可能需要以某种方式有所不同地处理。
- en: For example, let’s say that we want to be able to represent not only a ratio
    of two numbers stored in the `Ratio` object but also a ratio of two numbers stored
    elsewhere, with the `Ratio` object containing pointers to these numbers. Clearly,
    some of the methods of the `Ratio` object, such as the conversion operator to
    `double`, need to be implemented differently if the object stores pointers to
    the numerator and denominator. In C++, this is accomplished by specializing the
    template, which we will do next.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要能够表示不仅存储在`Ratio`对象中的两个数字的比例，而且还想表示存储在其他地方的两个数字的比例，其中`Ratio`对象包含对这些数字的指针。显然，如果对象存储了分子和分母的指针，那么`Ratio`对象的一些方法，如转换为`double`的转换操作符，需要以不同的方式实现。在C++中，这是通过特化模板来实现的，我们将在下面进行操作。
- en: Template specializations
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板特化
- en: Template specializations allow us to make the generated template code differently
    for some types—not just the same code with different types substituted, but completely
    different code. There are two kinds of template specializations in C++—explicit,
    or full, specializations and partial specialization. Let’s start with the former.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 模板特化允许我们对某些类型生成不同的模板代码——不仅仅是用不同类型替换后的相同代码，而是完全不同的代码。在C++中，模板特化有两种类型——显式特化（或完全特化）和部分特化。让我们先从前者开始。
- en: Explicit specialization
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式特化
- en: Explicit template specialization defines a special version of the template for
    a particular set of types. In an explicit specialization, all generic types are
    replaced by specific, concrete types. Since an explicit specialization is not
    a generic class or function, it does not need to be instantiated later. For the
    same reason, it is sometimes called **full specialization**. If the generic types
    are fully substituted, there is nothing generic left. An explicit specialization
    should not be confused with an explicit template instantiation—while both create
    an instantiation of a template for a given set of type arguments, an explicit
    instantiation creates an instantiation of the generic code, with the generic types
    substituted by the specific types. An explicit specialization creates an instantiation
    of the function or class with the same name but it overrides the implementation,
    so the resulting code can be completely different. An example should help us understand
    this distinction.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 显式模板特化定义了针对一组特定类型的模板的特殊版本。在显式特化中，所有泛型类型都被替换为具体的、具体的类型。由于显式特化不是一个泛型类或函数，因此它不需要在以后进行实例化。出于同样的原因，有时它被称为**完全特化**。如果泛型类型被完全替换，就没有任何泛型剩余了。显式特化不应与显式模板实例化混淆——虽然两者都为给定的一组类型参数创建了一个模板的实例，但显式实例化创建了一个泛型代码的实例，其中泛型类型被具体类型替换。显式特化创建了一个具有相同名称的函数或类的实例，但它覆盖了实现，因此生成的代码可以完全不同。一个例子可以帮助我们理解这种区别。
- en: 'Let’s start with a class template. Let’s say that, if both the numerator and
    the denominator of `Ratio` are `double`, we want to compute the ratio and store
    it as a single number. The generic `Ratio` code should remain the same, but for
    one particular set of types, we want the class to look entirely different. We
    can do this with an explicit specialization:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从类模板开始。假设，如果`Ratio`的分子和分母都是`double`类型，我们想要计算这个比例并将其存储为一个单独的数字。通用的`Ratio`代码应该保持不变，但对于一组特定的类型，我们希望类看起来完全不同。我们可以通过显式特化来实现这一点：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Both template type parameters are specified to be `double`. The class implementation
    is totally unlike the generic version—instead of two data members, we have just
    one; the conversion operator simply returns the value, and the constructor now
    computes the ratio of the numerator and the denominator. But it is not even the
    same constructor—instead of the non-template constructor `Ratio(const double&,
    const double&)` that the generic version would have if it was instantiated for
    two `double` template arguments, we provided a template constructor that can take
    two arguments of any types as long as they are convertible to `double`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 两个模板类型参数都被指定为`double`。类的实现与通用版本完全不同——我们只有一个数据成员，而不是两个；转换操作符简单地返回值，而构造函数现在计算分子和分母的比例。但这甚至不是同一个构造函数——我们提供了一个模板构造函数，它可以接受任何类型的两个参数，只要它们可以转换为`double`，而不是通用版本中如果为两个`double`模板参数实例化时将拥有的非模板构造函数`Ratio(const
    double&, const double&)`。
- en: 'Sometimes, we don’t need to specialize the whole class template, because most
    of the generic code is still applicable. However, we may want to change the implementation
    of one or a few member functions. We can explicitly specialize the member function
    as well:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不需要特化整个类模板，因为大部分泛型代码仍然适用。然而，我们可能想要更改一个或几个成员函数的实现。我们也可以显式特化成员函数：
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Template functions can be explicitly specialized as well. Again, unlike an
    explicit instantiation, we get to write the body of the function, and we can implement
    it any way we want:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 模板函数也可以显式特化。同样，与显式实例化不同，我们可以编写函数体，并以我们想要的方式实现它：
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We cannot, however, change the number or the types of arguments or the return
    type—they must match the result of the substitution of the generic types, so the
    following does not compile:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们无法更改参数的数量或类型，或者返回类型——它们必须与泛型类型的替换结果相匹配，因此以下代码无法编译：
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: An explicit specialization must be declared before the first use of the template
    that would cause an implicit instantiation of the generic template for the same
    types. This makes sense—the implicit instantiation would create a class or a function
    with the same name and the same types as the explicit specialization. We would
    now have two versions of the same class or function in the program, and this violates
    the one definition rule and makes the program ill-formed (the exact rules can
    be found in the standard under *[basic.def.odr]*).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模板之前，必须显式声明一个特化，以避免对相同类型的泛型模板进行隐式实例化。这很有道理——隐式实例化将创建一个与显式特化具有相同名称和相同类型的类或函数。现在程序中会有两个相同类或函数的版本，这违反了单一定义规则，并使程序无效（具体规则可以在标准中的*[基本定义.ODR]*部分找到）。
- en: Explicit specializations are useful when we have one or a few types for which
    we need the template to behave very differently. However, this does not solve
    our problem with the ratio of pointers—we want a specialization that is still
    *somewhat generic*, that is, it can handle pointers to any types, just not any
    other types. This is accomplished by a partial specialization, which we will look
    at next.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个或几个类型需要模板以非常不同的方式行为时，显式特化是有用的。然而，这并没有解决我们关于指针比例的问题——我们想要一个仍然*部分泛型*的特化，即它可以处理任何类型的指针，但不能处理其他类型的指针。这是通过部分特化实现的，我们将在下一节中探讨。
- en: Partial specialization
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分特化
- en: 'Now, we are getting to the really interesting part of C++ template programming—partial
    template specializations. When a class template is partially specialized, it remains
    as generic code, but *less generic* than the original template. The simplest form
    of a partial template is one where some of the generic types are replaced by concrete
    types, but other types remain generic:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们正在进入C++模板编程的真正有趣部分——部分模板特化。当一个类模板部分特化时，它仍然保持为泛型代码，但比原始模板*不那么泛型*。部分模板的最简单形式是其中一些泛型类型被具体类型替换，但其他类型仍然是泛型：
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we convert `Ratio` to a `double` value if the numerator is `double`,
    regardless of the denominator type. More than one partial specialization can be
    defined for the same template. For example, we can also specialize for the case
    when the denominator is `double` and the numerator is anything:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果分子是`double`类型，无论分母类型如何，我们都将`Ratio`转换为`double`值。可以为同一个模板定义多个部分特化。例如，我们还可以为分母是`double`而分子是任何类型的情况进行特化：
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When the template is instantiated, the best specialization for the given set
    of types is selected. In our case, if neither the numerator nor the denominator
    is `double`, then the general template has to be instantiated—there are no other
    choices. If the numerator is `double`, then the first partial specialization is
    a better (more specific) match than the general template. If the denominator is
    `double`, then the second partial specialization is a better match. But what happens
    if both terms are `double`? In this case, the two partial specializations are
    equivalent; neither is more specific than the other. This situation is considered
    ambiguous and the instantiation fails. Note that only this particular instantiation,
    `Ratio<double, double>`, fails—it is not an error (at least, not a syntax error)
    to define both specializations, but it is an error to request an instantiation
    that cannot be uniquely resolved to the narrowest specialization. To allow any
    instantiation of our template, we have to remove this ambiguity, and the only
    way to do that is to provide an even more narrow specialization that would be
    preferred over the other two. In our case, there is only one option—a full specialization
    for `Ratio<double, double>`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板被实例化时，会选择给定类型集的最佳特殊化。在我们的情况下，如果分子和分母都不是`double`，那么必须实例化通用模板——没有其他选择。如果分子是`double`，那么第一个部分特殊化比通用模板是一个更好的（更具体的）匹配。如果分母是`double`，那么第二个部分特殊化是一个更好的匹配。但如果两个项都是`double`呢？在这种情况下，两个部分特殊化是等效的；没有一个比另一个更具体。这种情况被认为是模糊的，实例化失败。请注意，只有这个特定的实例化`Ratio<double,
    double>`失败——定义两个特殊化不是错误（至少，不是一个语法错误），但请求一个无法唯一解析到最窄特殊化的实例化是错误的。为了允许我们的模板的任何实例化，我们必须消除这种模糊性，而做到这一点的方法是提供一个比其他两个更窄的特殊化。在我们的情况下，只有一个选项——为`Ratio<double,
    double>`提供一个完全特殊化：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, the fact that the partial specializations are ambiguous for the instantiation
    of `Ratio<double, double>` is no longer relevant—we have a more specific version
    of the template than either of them, so that version is preferred over both.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于`Ratio<double, double>`实例化而言，部分特殊化是不明确的这一事实已不再相关——我们有一个比它们任何一个都更具体的模板版本，因此该版本优先于两者。
- en: 'Partial specializations do not have to specify some of the generic types fully.
    Therefore, can keep all types generic, but impose some restrictions on them. For
    example, we still want a specialization where both the numerator and the denominator
    are pointers. They can be pointers to anything, so they are generic types, but
    *less generic* than the arbitrary types of the general template:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 部分特殊化不必完全指定一些泛型类型。因此，可以保持所有类型都是泛型，但对其施加一些限制。例如，我们仍然想要一个特殊化，其中分子和分母都是指针。它们可以是任何东西的指针，所以它们是泛型类型，但比通用模板的任意类型*不那么泛型*：
- en: '[PRE51]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This partial specialization still has two generic types, but they are both pointer
    types, `N*` and `D*`, for any `N` and `D` types. The implementation is totally
    unlike that of the general template. When instantiated with two pointer types,
    the partial specialization is *more specific* than the general template and is
    considered a better match. Note that, in our example, the denominator is `double`.
    So why isn’t a partial specialization for the `double` denominator considered?
    That is because, while the denominator is `double` as far as the program logic
    is concerned, technically it is `double*`, a completely different type, and we
    do not have a specialization for that.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分特殊化仍然有两个泛型类型，但它们都是指针类型，`N*`和`D*`，对于任何`N`和`D`类型。其实现与通用模板完全不同。当用两个指针类型实例化时，部分特殊化比通用模板更具体，被认为是更好的匹配。请注意，在我们的例子中，分母是`double`。那么为什么没有考虑对`double`分母的特殊化呢？那是因为，尽管从程序逻辑的角度来看，分母是`double`，但从技术上讲，它是`double*`，这是一个完全不同的类型，我们没有为其提供特殊化。
- en: 'To define a specialization, a general template must first be declared. It does
    not, however, need to be defined—it is possible to specialize a template that
    does not exist in the general case. To do so, we must forward-declare the general
    template, then define all the specializations we need:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个特殊化，必须首先声明一个通用模板。然而，它不需要被定义——可以特殊化在通用情况下不存在的模板。为此，我们必须提前声明通用模板，然后定义我们需要的所有特殊化：
- en: '[PRE52]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we have no general `Value` template, but we have partial specializations
    for any pointer or reference types. If we try to instantiate the template on some
    other type, like `int`, we will get an error stating that the `Value<int>` type
    is incomplete—this is no different than trying to define an object with only a
    forward declaration of the class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有通用的`Value`模板，但我们为任何指针或引用类型提供了部分特殊化。如果我们尝试在某种其他类型上实例化该模板，例如`int`，我们将得到一个错误，指出`Value<int>`类型是不完整的——这和尝试仅使用类的声明前缀来定义一个对象没有区别。
- en: So far, we have seen only examples of partial specializations for class templates.
    Unlike the earlier discussion of full specializations, we have not seen a single
    function specialization here. There is a very good reason for that—a partial function
    template specialization does not exist in C++. What is sometimes incorrectly called
    a partial specialization is nothing more than overloading template functions.
    On the other hand, overloading template functions can get quite complex and is
    worth learning about—we will cover this next.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了类模板的部分特殊化示例。与前面关于完全特殊化的讨论不同，我们没有在这里看到单个函数特殊化。这有一个非常好的原因——C++中不存在部分函数模板特殊化。有时错误地称为部分特殊化的是模板函数重载的简单形式。另一方面，模板函数的重载可以变得相当复杂，值得学习——我们将在下一节中介绍这一点。
- en: Template function overloading
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板函数重载
- en: 'We are used to regular functions, or class methods, being overloaded—multiple
    functions with the same name have different parameter types. Each call invokes
    the function with the best match of the parameter types to the call arguments,
    as shown in the following example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯于常规函数或类方法的重载——具有相同名称的多个函数具有不同的参数类型。每个调用都会调用与调用参数参数类型最佳匹配的函数，如下例所示：
- en: '[PRE53]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If the arguments are a perfect match for one of the overloaded functions with
    the given name, that function is called. Otherwise, the compiler considers conversions
    to the parameter types of the available functions. If one of the functions offers
    *better* conversions, that function is selected. Otherwise, the call is ambiguous,
    just as in the last line of the preceding example. The precise definition of what
    constitutes the *best* conversion can be found in the standard (see the section
    *Overloading*, more specifically, subsection *[over.match]*). Generally, the *cheapest*
    conversions are the ones such as adding `const` or removing a reference; then,
    there are conversions between built-in types, conversions from derived to base
    class pointers, and so on. In the case of multiple arguments, each argument for
    the chosen function must have the best conversion. There is no *voting*—if a function
    has three arguments, and two are an exact match for the first overload, while
    the third one is an exact match for the second overload, then even if the remaining
    arguments are implicitly convertible to their corresponding parameter types, the
    overloaded call is ambiguous.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数与给定名称的重载函数之一完全匹配，则调用该函数。否则，编译器会考虑将参数类型转换为可用函数的转换。如果其中一个函数提供了*更好的*转换，则选择该函数。否则，调用是模糊的，就像在前面示例的最后一行一样。关于构成*最佳*转换的确切定义可以在标准中找到（见*重载*部分，更具体地说，见子部分*[over.match]*）。一般来说，*最便宜*的转换是添加`const`或移除引用等；然后，有内置类型之间的转换，从派生类指针到基类指针的转换等。在多个参数的情况下，所选函数的每个参数都必须有最佳转换。没有*投票*——如果一个函数有三个参数，其中两个与第一个重载完全匹配，而第三个与第二个重载完全匹配，那么即使剩余的参数可以隐式转换为相应的参数类型，重载调用仍然是模糊的。
- en: The presence of templates makes the overload resolution much more complex. Multiple
    function templates with the same name and, possibly, the same number of arguments,
    can be defined, in addition to non-template functions. All of these functions
    are the candidates for an overloaded function call, but the function templates
    can generate functions with different parameter types, so how do we decide what
    the actual overloaded functions are? The exact rules are even more complex than
    the ones for non-template functions, but the basic idea is this—if there is a
    non-template function that is a near-perfect match to the call arguments, that
    function is selected. The standard, of course, uses much more precise terms than
    *near-perfect*, but *trivial* conversions, such as adding `const`, fall under
    that category—you get them *at no cost*. If there is no such function, the compiler
    will attempt to instantiate all function templates with the same name to a near-perfect
    match, using the template argument deduction. If exactly one of the templates
    was instantiated, the function created by this instantiation is called. Otherwise,
    overload resolution continues the usual way among the non-template functions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的存在使得重载解析变得更加复杂。除了非模板函数外，还可以定义具有相同名称和可能相同数量的参数的多个函数模板。所有这些函数都是重载函数调用的候选者，但函数模板可以生成具有不同参数类型的函数，那么我们如何决定实际的重载函数是什么？确切的规则甚至比非模板函数的规则更复杂，但基本思想是这样的——如果有一个非模板函数与调用参数几乎完美匹配，则选择该函数。当然，标准使用比“几乎完美”更精确的术语，但“平凡”转换，如添加`const`，属于这一类别——你可以“免费”获得它们。如果没有这样的函数，编译器将尝试将所有具有相同名称的函数模板实例化成与调用参数几乎完美匹配的形式，使用模板参数推导。如果恰好只有一个模板被实例化，则调用由这种实例化创建的函数。否则，重载解析将在非模板函数中继续以通常的方式进行。
- en: 'This is a very simplified description of a very complex process, but there
    are two important points—firstly, if there is an equally good match of a call
    to a template and a non-template function, the non-template function is preferred,
    and secondly, the compiler does not attempt to instantiate the function templates
    into something that might be convertible to the types we need. The template functions
    must match the call almost perfectly after the argument type deduction, or they
    are not called at all. Let’s add a template to our previous example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对一个非常复杂过程的非常简化的描述，但有两个重要的要点——首先，如果对一个模板函数和一个非模板函数的调用有同样好的匹配，则优先选择非模板函数，其次，编译器不会尝试将函数模板实例化成可能转换为所需类型的对象。模板函数在参数类型推导后必须几乎完美匹配调用，否则根本不会被调用。让我们在我们的上一个例子中添加一个模板：
- en: '[PRE54]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we have what looks like a partial specialization of a function template.
    But it really isn’t—it is just a function template—there is no general template
    for which it could be a specialization. Instead, it is simply a function template
    whose type parameter is deduced from the same arguments, but using different rules.
    The template can have its type deduced if the argument is a pointer of any kind.
    This includes a pointer to `const`—`T` could be a `const` type, so if we call
    `whatami(ptr)`, where `ptr` is `const int*`, that first template overload is a
    perfect match when `T` is `const int`. If the deduction succeeds, the function
    generated by the template, that is, the template instantiation, is added to the
    overload set.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里看起来像是一个函数模板的部分特化。但实际上并不是——它只是一个函数模板——没有一般模板可以特化。相反，它只是一个类型参数从相同参数推导出来的函数模板，但使用不同的规则。如果参数是任何类型的指针，则可以推导出模板的类型。这包括指向`const`的指针——`T`可以是`const`类型，所以如果我们调用`whatami(ptr)`，其中`ptr`是`const
    int*`，那么当`T`是`const int`时，第一个模板重载是一个完美的匹配。如果推导成功，由模板生成的函数，即模板实例化，将被添加到重载集中。
- en: 'For the `int*` argument, it is the only overload that works, so it is called.
    But what happens if more than one function template can match the call, and both
    instantiations are valid overloads? Let’s add one more template:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`int*`参数，它是唯一可以工作的重载，因此被调用。但如果多个函数模板可以匹配调用，并且两种实例化都是有效的重载会发生什么？让我们再添加一个模板：
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This template function accepts its arguments by the universal reference, so
    it can be instantiated for any call to `whatami()` with one argument. The first
    call, `whatami(c)`, is easy—the last overload, with `T&&`, is the only one that
    can be called. There are no conversions from `c` to a pointer or an integer. But
    the second call is tricky—we have not one, but two template instantiations that
    are a perfect match for the call, with no conversions needed. So why is this not
    an ambiguous overload? Because the rules for resolving overloaded function templates
    are different than the rules for non-template functions and resemble the rules
    for selecting the partial specialization of a class template (which is another
    reason why function template overloads are often confused with partial specializations).
    The template that is more specific is a better match.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板函数通过通用引用接受其参数，因此它可以针对任何只有一个参数的 `whatami()` 调用进行实例化。第一次调用，`whatami(c)`，很简单——最后一个重载，带有
    `T&&`，是唯一可以调用的。没有从 `c` 到指针或整数的转换。但第二次调用很棘手——我们有一个，而不是一个，与调用完全匹配的模板实例化，且不需要任何转换。那么为什么这不是一个模糊的重载呢？因为解决重载函数模板的规则与非模板函数的规则不同，类似于选择类模板部分特殊化的规则（这也是为什么函数模板重载经常与部分特殊化混淆的另一个原因）。更具体的模板是一个更好的匹配。
- en: In our case, the first template is more specific—it can accept any pointer argument,
    but only pointers. The second template can accept any argument at all, so any
    time the first template is a possible match, the second is too, but not the reverse.
    If a more specific template can be used to instantiate a function that is a valid
    overload, then this template is used.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，第一个模板更具体——它可以接受任何指针参数，但只能是指针。第二个模板可以接受任何参数，所以每次第一个模板是一个可能的匹配时，第二个也是，但反之则不然。如果可以使用更具体的模板实例化一个有效的重载函数，那么就使用这个模板。
- en: Otherwise, we have to fall back to the more general template.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们必须回退到更通用的模板。
- en: 'The very general template functions in the overload set sometimes lead to unexpected
    results. Let’s say we have the following three overloads for `int`, `double`,
    and anything:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重载集中的非常通用的模板函数有时会导致意想不到的结果。假设我们有以下三个针对 `int`、`double` 和任何东西的重载：
- en: '[PRE56]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first call has an `int` argument, so `whatami(int)` is a perfect match.
    The second call would have gone to `whatami(double)` if we did not have the template
    overload—the conversion from `float` to `double` is implicit (so is the conversion
    from `float` to `int`, but the conversion to `double` is preferred). But it’s
    still a conversion, so when the function template instantiates to a perfect match
    of `whatami(float&&)`, that is the best match and the chosen overload. The last
    call has a `double` argument, and again we have a perfect match to a non-template
    function `whatami(double)`, so it is preferred over any alternative.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用有一个 `int` 参数，所以 `whatami(int)` 是一个完美的匹配。如果我没有模板重载，第二次调用将转到 `whatami(double)`——从
    `float` 到 `double` 的转换是隐式的（从 `float` 到 `int` 的转换也是隐式的，但到 `double` 的转换更优先）。但这仍然是一个转换，所以当函数模板实例化到
    `whatami(float&&)` 的完美匹配时，这是最佳匹配，也是选择的重载。最后一个调用有一个 `double` 参数，再次我们有一个与非模板函数 `whatami(double)`
    的完美匹配，所以它比任何其他替代方案更优先。
- en: 'It should be noted that overloading pass-by-value and pass-by-reference functions
    for the same parameter types often creates ambiguities in overload resolution.
    For example, these two functions are almost always ambiguous:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，为相同参数类型重载按值传递和按引用传递的函数通常会在重载解析中产生歧义。例如，这两个函数几乎总是模糊的：
- en: '[PRE57]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As long as the argument to the function can be copied (and our object `c` is
    copyable), the overload is ambiguous and the call will not compile. The problem
    does not happen when a more specific function overloads a more general one (in
    all our previous examples, `whatami(int)` used pass-by-value with no problems),
    but mixing the two types of parameter passing for similarly general functions
    is inadvisable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 只要函数的参数可以被复制（并且我们的对象 `c` 是可复制的），重载就是模糊的，调用将无法编译。当更具体的函数重载更一般的函数时，问题不会发生（在我们所有的前例中，`whatami(int)`
    使用按值传递且没有问题），但将两种类型的参数传递混合在类似通用的函数中是不明智的。
- en: Finally, there is one more kind of function that has a special place in the
    overload resolution order—a variadic function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一种函数在重载解析顺序中有一个特殊的位置——可变参数函数。
- en: 'A variadic function is declared with `...` instead of arguments, and it can
    be called with any number of arguments of any type (`printf` is one such function).
    This function is the overload of the last resort—it is called only if no other
    overloads can be used:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数函数使用 `...` 而不是参数来声明，并且可以用任何类型和数量的参数调用（`printf` 就是一个这样的函数）。这个函数是最后的手段重载——只有当没有其他重载可用时才会调用：
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As long as we have the overload `whatami(T&& x)` available, a variadic function
    will never be the preferred overload, at least not for any calls to `whatami()`
    with one argument. Without that template, `whatami(...)` is called for any argument
    that is not a number or a pointer. The variadic functions were around since the
    days of C, and are not to be confused with variadic templates that were introduced
    in C++11, and this is what we’ll talk about next.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们有 `whatami(T&& x)` 重载可用，可变参数函数就不会是首选的重载，至少对于任何只有一个参数的 `whatami()` 调用来说是这样。没有那个模板，`whatami(...)`
    将会用于任何非数字或指针类型的参数。可变参数函数自 C 语言时代起就存在了，不要与在 C++11 中引入的可变参数模板混淆，这正是我们接下来要讨论的内容。
- en: Variadic templates
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变参数模板
- en: Probably the greatest difference between generic programming in C and C++ is
    type safety. It is possible to write generic code in C—the standard function `qsort()`
    is a perfect example—it can sort values of any type and they are passed in using
    a `void*` pointer, which can really be a pointer to any type. Of course, the programmer
    has to know what the real type is and cast the pointer to the right type. In a
    generic C++ program, the types are either explicitly specified or deduced at the
    time of the instantiation, and the type system for generic types is as strong
    as it is for regular types. Unless we want a function with an unknown number of
    arguments, that is, prior to C++11, the only way was the old C-style variadic
    functions where the compiler had no idea what the argument types were; the programmer
    just had to know and unpack the variable arguments correctly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 之间最显著的差异可能是类型安全。在 C 中可以编写泛型代码——标准函数 `qsort()` 就是一个完美的例子——它可以对任何类型的值进行排序，并且它们通过
    `void*` 指针传递，这实际上可以是任何类型的指针。当然，程序员必须知道实际的类型，并将指针转换为正确的类型。在泛型 C++ 程序中，类型要么在实例化时显式指定，要么推导出来，泛型类型的类型系统与常规类型的类型系统一样强大。除非我们想要一个具有未知数量参数的函数，即在
    C++11 之前，唯一的方法是使用旧的 C 风格的可变参数函数，其中编译器根本不知道参数类型是什么；程序员只需知道并正确地解包可变参数即可。
- en: 'C++11 introduced the modern equivalent to a variadic function—a variadic template.
    We can now declare a generic function with any number of arguments:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 引入了可变参数函数的现代等价物——可变参数模板。现在我们可以声明具有任何数量参数的泛型函数：
- en: '[PRE59]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This function takes one or more arguments, possibly of different types, and
    computes their sum. The return type is not easy to determine, but, fortunately,
    we can let the compiler figure it out—we just declare the return type as `auto`.
    How do we actually implement the function to add up the unknown number of values
    whose types we can’t name, not even as generic types? In C++17, it’s easy, because
    it has fold expressions:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个或多个参数，这些参数可能具有不同的类型，并计算它们的总和。返回类型不容易确定，但幸运的是，我们可以让编译器来决定——我们只需将返回类型声明为
    `auto`。我们实际上如何实现这个函数来累加未知数量的值，而这些值的类型我们甚至无法命名，甚至不能作为泛型类型？在 C++17 中，这很容易，因为有了折叠表达式：
- en: '[PRE60]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can verify that the type of the result is what we say it is:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以验证结果类型正是我们所声称的类型：
- en: '[PRE61]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In C++14, as well as in C++17, when a fold expression is not sufficient (and
    they are useful only in limited contexts, mostly when the arguments and combines
    using binary or unary operators), the standard technique is recursion, which is
    ever-popular in template programming:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++14 以及 C++17 中，当折叠表达式不足以使用（并且它们仅在有限的上下文中有用，主要是在使用二进制或一元运算符组合参数时），标准技术是递归，这在模板编程中一直很受欢迎：
- en: '[PRE62]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The first overload (not a partial specialization!) is for the `sum()` function
    with one argument of any type. That value is returned. The second overload is
    for more than one argument, and the first argument is explicitly added to the
    sum of the remaining arguments. The recursion continues until there is only one
    argument left, at which point the other overload is called and the recursion stops.
    This is the standard technique for unraveling the parameter packs in variadic
    templates, and we will see this many times in this book. The compiler will inline
    all the recursive function calls and generate straightforward code that adds all
    arguments together.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个重载（不是部分特化！）是为具有任何类型单个参数的 `sum()` 函数。该值将被返回。第二个重载用于一个以上的参数，并且第一个参数被明确地加到剩余参数的总和中。递归继续进行，直到只剩下一个参数，此时将调用另一个重载并停止递归。这是在变长模板中解开参数包的标准技术，我们将在本书中多次看到这一点。编译器将内联所有递归函数调用并生成直接将所有参数相加的代码。
- en: 'The class templates can also be variadic—they have an arbitrary number of type
    arguments and can build classes from a varying number of objects of different
    types. The declaration is similar to that of a function template. For example,
    let’s build a class template, `Group`, that can hold any number of objects of
    different types and return the right object when it’s converted to one of the
    types it holds:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板也可以是变长的——它们有任意数量的类型参数，并且可以从不同类型的不同数量的对象构建类。其声明与函数模板类似。例如，让我们构建一个类模板 `Group`，它可以保存任何数量的不同类型的对象，并在转换为它所保存的类型时返回正确的对象：
- en: '[PRE63]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The usual implementation of such templates is again recursive, using deeply
    nested inheritance, although a non-recursive implementation is sometimes possible.
    We will see one in the next section. The recursion has to be terminated when there
    is only one type parameter left. This is done using a partial specialization,
    so we will leave the general template we showed previously as a declaration only,
    and define a specialization for one type parameter:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模板的通常实现仍然是递归的，使用深度嵌套的继承，尽管有时可能存在非递归实现。我们将在下一节中看到一个例子。当只剩下一个类型参数时，递归必须终止。这是通过部分特化来完成的，因此我们将之前显示的通用模板仅作为声明保留，并为一个类型参数定义一个特化：
- en: '[PRE64]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This class holds the value of one type, `T1`, initializes it by copy or move
    and returns a reference to it when converted to the `T1` type. The specialization
    for an arbitrary number of type parameters contains the first one as a data member,
    together with the corresponding initialization and conversion methods, and inherits
    from the `Group` class template of the remaining types:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类保存一个类型 `T1` 的值，通过复制或移动来初始化它，并在转换为 `T1` 类型时返回对其的引用。对于任意数量的类型参数的特化包含第一个类型作为数据成员，以及相应的初始化和转换方法，并从剩余类型的
    `Group` 类模板继承：
- en: '[PRE65]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: For every type contained in a `Group` class, there are two possible ways it
    can be initialized—copy or move. Fortunately, we do not have to spell out the
    constructors for every combination of copy and move operations. Instead, we have
    two versions of the constructor for the two ways to initialize the first argument
    (the one stored in the specialization); we use perfect forwarding for the remaining
    arguments.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Group` 类中包含的每个类型，它有两种可能的初始化方式——复制或移动。幸运的是，我们不必为复制和移动操作的每种组合指定构造函数。相反，我们有两种构造函数版本，用于初始化第一个参数（存储在特化中的那个）；我们使用完美转发来处理剩余的参数。
- en: 'Now, we can use our `Group` class template to hold some values of different
    types (it cannot handle multiple values of the same type since the attempt to
    retrieve this type would be ambiguous):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的 `Group` 类模板来保存不同类型的一些值（它无法处理相同类型的多个值，因为检索此类型的尝试将是模糊的）：
- en: '[PRE66]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'It is rather inconvenient to write all the group types explicitly and to make
    sure they match the argument types. In C++17, we can use a deduction guide to
    enable class template parameter deduction from the constructor:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 明确写出所有组类型并确保它们与参数类型匹配相当不方便。在 C++17 中，我们可以使用推导指南来启用从构造函数的类模板参数推导：
- en: '[PRE67]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Before C++17, the usual solution to this problem is to use a helper function
    template (a variadic template, of course) to take advantage of the template argument
    deduction:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++17 之前，解决这个问题的通常方法是使用辅助函数模板（当然是一个变长模板）来利用模板参数推导：
- en: '[PRE68]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that the C++ standard library contains a class template, `std::tuple`,
    which is a much more complete and full-featured version of our `Group`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，C++ 标准库包含一个类模板 `std::tuple`，这是我们的 `Group` 的一个更完整、功能更丰富的版本。
- en: 'Variadic templates can have non-type parameters as well; in this case, the
    `makeGroup` template can be instantiated with an arbitrary number of arguments.
    Often, these non-type parameter packs are used in combination with `auto` (deduced)
    types. For example, here is a template that holds a list of compile-time constant
    values of different types:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 变长模板也可以有非类型参数；在这种情况下，`makeGroup` 模板可以用任意数量的参数实例化。通常，这些非类型参数包会与 `auto`（推导）类型结合使用。例如，这里有一个模板，它持有不同类型编译时常量值的列表：
- en: '[PRE69]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Without `auto` (i.e., prior to C++17) it is almost impossible to declare such
    a template since the types must be explicitly specified. Note that this is the
    entire template: it holds the constant values as a part of its definition. To
    extract them, we need another variadic template:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用 `auto`（即，在 C++17 之前），几乎不可能声明这样的模板，因为类型必须被显式指定。请注意，这是一个完整的模板：它将其定义的一部分作为常量值持有。为了提取它们，我们需要另一个变长模板：
- en: '[PRE70]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The template function `nth_value` deduces the parameter pack `Values` from the
    type of the `value_list` argument (the argument itself contains no data and is
    of no interest except for its type). A recursive instantiation of partial class
    specializations is then used to iterate over the parameter pack until we get to
    the `N`-th value. Note that to store floating-point constants in this manner,
    we need C++20.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 模板函数 `nth_value` 从 `value_list` 参数（该参数本身不包含数据，除了其类型外没有其他兴趣）的类型推导出参数包 `Values`。然后使用部分类特化的递归实例化来遍历参数包，直到我们得到第
    `N` 个值。请注意，为了以这种方式存储浮点常量，我们需要 C++20。
- en: 'Variadic templates can be used in combination with template template parameters
    to resolve some of the problems created when, for example, standard library containers
    are used as arguments substituted for template template parameters. A simple solution
    is to declare the parameter as taking any number of types:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 变长模板可以与模板模板参数结合使用，以解决例如当标准库容器用作模板模板参数的替代参数时产生的一些问题。一个简单的解决方案是将参数声明为接受任意数量的类型：
- en: '[PRE71]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that the `std::vector` template has two type parameters. In C++17, a standard
    change made this a valid match for the parameter pack specified in the `Container`
    template template parameter. Most compilers allowed such matches even earlier.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`std::vector` 模板有两个类型参数。在 C++17 中，一个标准更改使其成为 `Container` 模板模板参数中指定的参数包的有效匹配。大多数编译器甚至更早之前就允许这种匹配。
- en: The variadic templates, especially combined with perfect forwarding, are extremely
    useful for writing very general template classes—for example, a vector can contain
    objects of an arbitrary type, and, to construct these objects in place instead
    of copying them, we have to call constructors with a different number of arguments.
    When the vector template is written, there is no way to know how many arguments
    are needed to initialize the objects the vector will contain, so a variadic template
    has to be used (indeed, the in-place constructors of `std::vector`, such as `emplace_back`,
    are variadic templates).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 变长模板，特别是与完美转发结合使用，对于编写非常通用的模板类非常有用——例如，一个向量可以包含任意类型的对象，为了就地构造这些对象而不是复制它们，我们必须调用具有不同数量参数的构造函数。当编写向量模板时，无法知道需要多少参数来初始化向量将包含的对象，因此必须使用变长模板（实际上，`std::vector`
    的就地构造函数，如 `emplace_back`，是变长模板）。
- en: There is one more kind of template-like entity in C++ that we have to mention,
    one that has the appearance of both a class and a function—a lambda expression.
    The next section is dedicated to this.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，我们还要提到一种类似于模板的实体，它既有类又有函数的外观——这就是 lambda 表达式。下一节将专门介绍这个内容。
- en: Lambda expressions
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: 'In C++, the regular function syntax is extended with the concept of a *callable*,
    short for *callable entity*—a callable is something that can be called in the
    same way as a function. Some examples of callables are functions (of course),
    function pointers, or objects with the `operator()`, also known as **functors**:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，常规函数语法通过 *可调用* 的概念得到了扩展，可调用是 *可调用实体* 的简称——可调用是像函数一样可以调用的东西。可调用的例子包括函数（当然）、函数指针或具有
    `operator()` 的对象，也称为**仿函数**：
- en: '[PRE72]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'It is often useful to define a callable entity in a local context, right next
    to the place it is used. For example, to sort a sequence of objects, we may want
    to define a custom comparison function. We can use an ordinary function for this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在局部上下文中定义一个可调用实体通常很有用，就在它被使用的地方附近。例如，为了对一个对象的序列进行排序，我们可能需要定义一个自定义的比较函数。我们可以使用普通函数来完成这个任务：
- en: '[PRE73]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: However, in C++, functions cannot be defined inside other functions, so our
    `compare()` function may have to be defined quite far from the place it is used.
    If it is a single-use comparison function, such separation is inconvenient and
    reduces the readability and maintainability of the code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在C++中，函数不能在其它函数内部定义，因此我们的`compare()`函数可能必须定义在它被使用的地方相当远的地方。如果它是一个单次使用的比较函数，这种分离是不方便的，并且会降低代码的可读性和可维护性。
- en: 'There is a way around this limitation—while we cannot declare functions inside
    functions, we can declare classes, and classes can be callable:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以绕过这个限制——虽然我们无法在函数内部声明函数，但我们可以在函数内部声明类，并且类是可以调用的：
- en: '[PRE74]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This is compact and local, but rather verbose. We do not actually need to give
    this class a name, and we only ever want one instance of this class. In C++11,
    we have a much better option, the lambda expression:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这既紧凑又局部，但相当冗长。实际上，我们并不需要给这个类命名，而且我们只希望有一个这个类的实例。在C++11中，我们有一个更好的选择，那就是Lambda表达式：
- en: '[PRE75]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If we use this comparison function for just one call to `std::sort`, we don’t
    even need to give it a name and can define it inside the call:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只为一次调用`std::sort`使用这个比较函数，甚至不需要给它命名，可以直接在调用内部定义：
- en: '[PRE76]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This is as compact as it gets. The return type can be specified, but can usually
    be deduced by the compiler. The lambda expression creates an object, so it has
    a type, but that type is generated by the compiler, so the object declaration
    must use `auto`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最紧凑的方式。可以指定返回类型，但通常可以由编译器推导出来。Lambda表达式创建了一个对象，因此它有一个类型，但这个类型是由编译器生成的，因此对象声明必须使用`auto`。
- en: 'The lambda expressions are objects, so they can have data members. Of course,
    a local callable class can also have data members. Usually, they are initialized
    from the local variables in the containing scope:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式是对象，因此它们可以有数据成员。当然，局部可调用类也可以有数据成员。通常，它们是从包含作用域中的局部变量初始化的：
- en: '[PRE77]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Again, this is a very verbose way to do something simple. We have to mention
    the tolerance variable three times—as a data member, a constructor argument, and
    in the member initialization list. A lambda expression makes this code simpler
    as well because it can capture local variables. In local classes, we are not allowed
    to reference variables from the containing scope, except by passing them through
    the constructor arguments, but for lambda expressions, the compiler automatically
    generates a constructor to capture all local variables mentioned in the body of
    the expression:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一种非常冗长的简单操作方式。我们必须三次提到容差变量——作为数据成员、构造函数参数以及在成员初始化列表中。Lambda表达式使这段代码更简洁，因为它可以捕获局部变量。在局部类中，我们不允许通过构造函数参数以外的任何方式引用包含作用域中的变量，但对于Lambda表达式，编译器会自动生成一个构造函数来捕获表达式体中提到的所有局部变量：
- en: '[PRE78]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here, the name `tolerance` inside the lambda expression refers to the local
    variable with the same name. The variable is captured by value, which is specified
    in the lambda expression’s capture clause `[=]`. We could have captured by reference
    using `[&]` like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Lambda表达式内部的`tolerance`这个名字指的是具有相同名称的局部变量。变量是通过值捕获的，这在Lambda表达式的捕获子句`[=]`中指定。我们也可以通过`[&]`像这样使用引用捕获：
- en: '[PRE79]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The difference is that, when capturing by value, a copy of the captured variable
    is created inside the lambda object at the point where it is constructed. This
    local copy is `const` by default, although we can declare the lambda mutable,
    which would let us change the captured values:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，当按值捕获时，在Lambda对象构造的点会创建捕获变量的副本。这个局部副本默认是`const`的，尽管我们可以声明Lambda为可变的，这样我们就可以改变捕获的值：
- en: '[PRE80]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'On the other hand, capturing the variables from the outer scope by reference
    makes every mention of this variable inside the lambda a reference to the original
    variable. Values captured by reference can be changed:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，通过引用捕获外部作用域中的变量会使Lambda表达式内部对这个变量的每次提及都指向原始变量。通过引用捕获的值可以被更改：
- en: '[PRE81]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: It is also possible to explicitly capture some variables by value or by reference;
    for example, the capture `[=, &count]` captures everything by value except `count`,
    which is captured by reference.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过值或引用显式捕获一些变量；例如，捕获 `[=, &count]` 通过值捕获了一切，除了 `count`，它通过引用捕获。
- en: Instead of changing the arguments of the lambda expression from `int` in the
    earlier example to `double`, we can declare them as `auto`, which effectively
    makes the `operator()` of the lambda expression a template (this is a C++14 feature).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将早期示例中的 lambda 表达式的参数从 `int` 改为 `double`，我们可以将它们声明为 `auto`，这实际上使得 lambda
    表达式的 `operator()` 成为一个模板（这是一个 C++14 特性）。
- en: Lambda expressions are most commonly used as local functions. However, they
    are not really functions; they are callable objects, and so they are missing one
    feature that functions have—the ability to overload them. The last trick we will
    learn in this section is how to work around that and create an overload set from
    lambda expressions.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式最常被用作局部函数。然而，它们实际上并不是函数；它们是可调用对象，因此它们缺少函数的一个特性——重载它们的能力。在本节中我们将学习的最后一个技巧是如何绕过这一点，并从
    lambda 表达式中创建一个重载集。
- en: First, the main idea—it is indeed impossible to overload callable objects. On
    the other hand, it is very easy to overload several `operator()` methods in the
    same object—methods are overloaded like any other function. Of course, the `operator()`
    of a lambda expression object is generated by the compiler, not declared by us,
    so it is not possible to force the compiler to generate more than one `operator()`
    in the same lambda expression. But classes have their own advantages, the main
    one being that we can inherit from them.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，主要思想——确实不可能重载可调用对象。另一方面，在同一个对象中重载多个 `operator()` 方法非常容易——方法的重载就像任何其他函数一样。当然，lambda
    表达式对象的 `operator()` 是由编译器生成的，而不是由我们声明的，因此不可能强迫编译器在同一个 lambda 表达式中生成多个 `operator()`。但类有自己的优点，主要优点是我们可以从它们继承。
- en: Lambda expressions are objects—their types are classes, so we can inherit from
    them too. If a class inherits publicly from a base class, all public methods of
    the base class become public methods of the derived class. If a class inherits
    publicly from several base classes (multiple inheritance), its public interface
    is formed from all the public methods of all the base classes. If there are multiple
    methods with the same name in this set, they become overloaded and the usual overloading
    resolution rules apply (in particular, it is possible to create an ambiguous set
    of overloads, in which case the program will not compile).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式是对象——它们的类型是类，因此我们也可以从它们继承。如果一个类公开继承自基类，那么基类的所有公共方法都成为派生类的公共方法。如果一个类公开继承自多个基类（多重继承），那么它的公共接口是由所有基类的所有公共方法组成的。如果在这个集合中有多个同名方法，它们将变成重载方法，并应用通常的重载解析规则（特别是，可能创建一个模糊的重载集，在这种情况下程序将无法编译）。
- en: 'So, we need to create a class that automatically inherits from any number of
    base classes. We have just seen the right tool for that—variadic templates. As
    we have learned in the previous section, the usual way to iterate over an arbitrary
    number of items in the parameter pack of a variadic template is through recursion:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要创建一个类，它可以自动从任意数量的基类继承。我们刚刚看到了完成这个任务的正确工具——变长模板。正如我们在上一节中学到的，遍历变长模板参数包中的任意数量项的通常方法是递归：
- en: '[PRE82]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `overload_set` is a variadic class template; the general template has to
    be declared before we can specialize it, but it has no definition. The first definition
    is for the special case of only one lambda expression—the `overload_set` class
    inherits from the lambda expression and adds its `operator()` to its public interface.
    The specialization for `N` lambda expressions (`N>1`) inherits from the first
    one and from the `overload_set` constructed from the remaining `N-1` lambda expressions.
    Finally, we have a helper function that constructs the overload set from any number
    of lambda expressions—in our case, this is a necessity and not mere convenience
    since we cannot explicitly specify the types of the lambda expressions, but have
    to let the function template deduce them. Now, we can construct an overload set
    from any number of lambda expressions:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`overload_set` 是一个变长类模板；在我们可以特化它之前，必须先声明通用模板，但它没有定义。第一个定义是为只有一个 lambda 表达式的特殊情况——`overload_set`
    类从 lambda 表达式继承，并将其 `operator()` 添加到其公共接口中。对于 `N` 个 lambda 表达式（`N>1`）的特化从第一个继承，并从剩余的
    `N-1` 个 lambda 表达式构成的 `overload_set` 继承。最后，我们有一个辅助函数，可以从任意数量的 lambda 表达式中构建重载集——在我们的情况下，这是一个必要性而不是便利性，因为我们不能显式指定
    lambda 表达式的类型，而必须让函数模板推导它们。现在，我们可以从任意数量的 lambda 表达式中构建重载集：'
- en: '[PRE83]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This solution is not perfect, because it does not handle ambiguous overloads
    well. In C++17, we can do better, and it gives us a chance to demonstrate an alternative
    way of using a parameter pack that does not need recursion. Here is the C++17
    version:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案并不完美，因为它处理模糊重载的能力不佳。在 C++17 中，我们可以做得更好，这给了我们一个机会来展示一种使用参数包的替代方法，这种方法不需要递归。以下是
    C++17 版本：
- en: '[PRE84]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The variadic template does not rely on partial specializations anymore; instead,
    it inherits directly from the parameter pack (this part of the implementation
    works in C++14 as well, but the `using` declaration needs C++17). The template
    helper function is the same—it deduces the types of all lambda expressions and
    constructs an object from the `overload_set` instantiation with these types. The
    lambda expressions themselves are passed to the base classes using perfect forwarding,
    where they are used to initialize all the base objects of the `overload_set` objects
    (lambda expressions are movable). Without the need for recursion or partial specialization,
    this is a much more compact and straightforward template. Its use is identical
    to the previous version of `overload_set`, but it handles near-ambiguous overloads
    better.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数模板不再依赖于部分特化；相反，它直接从参数包继承（这部分实现也在 C++14 中工作，但 `using` 声明需要 C++17）。模板辅助函数与之前相同——它推导所有
    lambda 表达式的类型，并从具有这些类型的 `overload_set` 实例化中构建一个对象。lambda 表达式本身通过完美转发传递给基类，在那里它们用于初始化
    `overload_set` 对象的所有基对象（lambda 表达式是可移动的）。无需递归或部分特化，这是一个更加紧凑和直接的模板。它的使用与 `overload_set`
    的上一个版本相同，但它更好地处理了几乎模糊的重载。
- en: 'We can get rid of the template function as well and use template deduction
    guides:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以弃用模板函数，并使用模板推导指南：
- en: '[PRE85]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The use of the `overload` template remains largely unchanged; note the curly
    braces used to construct an object:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`overload` 模板的使用基本保持不变；注意用于构建对象的括号：'
- en: '[PRE86]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We will see lambdas used extensively in later chapters of this book when we
    will need to write a fragment of code and attach it to an object so that it can
    be executed later.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续章节中，我们将广泛使用 lambda 表达式，当我们需要编写一段代码并将其附加到对象上以便稍后执行时。
- en: 'Next, we are going to learn about a new C++ feature that, in a way, does the
    opposite of what we were trying to do so far: it makes templates *less* general.
    As we have seen already, it is easy to over-promise with a template: we can define
    templates whose definitions then do not compile in some cases. It would be better
    to make any restrictions on the template arguments to be a part of the declaration,
    so let us see how that is done.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习一个新的 C++ 特性，它在某种程度上与我们迄今为止试图做的相反：它使模板 *更不通用*。正如我们已经看到的，使用模板过度承诺很容易：我们可以定义模板，其定义在某些情况下无法编译。最好将任何对模板参数的限制作为声明的一部分，让我们看看这是如何实现的。
- en: Concepts
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概念
- en: 'C++20 introduced a major enhancement to the C++ template machinery: concepts.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 对 C++ 模板机制进行了重大增强：概念。
- en: In C++20, templates (both class and function templates), as well as non-template
    functions (members of class templates, usually) may use a constraint to specify
    the requirements on template arguments. These constraints are useful to produce
    better error messages, but they are truly indispensable when there is a need to
    select a function overload or a template specialization based on some properties
    of template arguments.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 中，模板（包括类模板和函数模板）以及非模板函数（通常是类模板的成员）可以使用约束来指定对模板参数的要求。这些约束对于生成更好的错误消息很有用，但在需要根据模板参数的一些属性来选择函数重载或模板特化时，它们确实是不可或缺的。
- en: 'The basic syntax for a constraint is quite simple: a constraint is introduced
    by the keyword `requires` which can be specified after the function declaration
    or before the return type (in this book, we use both ways interchangeably so the
    reader becomes familiar with different styles of writing code). The expression
    itself usually uses the template parameters and must evaluate to a boolean value,
    for example:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 约束的基本语法相当简单：约束是通过关键字 `requires` 引入的，它可以在函数声明之后或返回类型之前指定（在这本书中，我们两种方式交替使用，以便读者熟悉不同的代码编写风格）。表达式本身通常使用模板参数，并且必须评估为布尔值，例如：
- en: '[PRE87]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Here the function `copy()` requires that the type of its argument has a size
    of at least two bytes. If we attempt to call this function with a `char` argument,
    the call will not compile. Note that if a constraint is violated, it is as if
    the function did not exist for the purposes of a particular call: if there is
    another overload, it will be considered next even if, without the constraint,
    the overloads were ambiguous.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数 `copy()` 要求其参数的类型至少有 2 个字节的长度。如果我们尝试用 `char` 参数调用此函数，该调用将无法编译。请注意，如果违反了约束，它就相当于在特定调用中该函数不存在：如果有另一个重载，即使在没有约束的情况下重载是模糊的，它也会被考虑。
- en: 'Here is a more complex (and more useful) example:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个更复杂（也更实用）的例子：
- en: '[PRE88]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This is a function similar to `std::min`, except it takes two arguments of
    different types. This creates two potential issues: first, what is the return
    type? The return value is one of the two arguments, but there has to be a single
    return type. We can use the `std::common_type` trait from the `<type_traits>`
    header as a reasonable answer: for numeric types, it does the usual type promotion,
    for classes, it converts from base class to derived class if possible, and it
    respects implicit user-specified conversions. But there is a second problem: if
    the expression `t1 < t2` does not compile, we get an error in the body of the
    function. This is unfortunate because the error is hard to analyze and may be
    misleading: it suggests that the body of the function is implemented incorrectly.
    We can address the second concern by adding a static assert:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个类似于 `std::min` 的函数，但它接受两个不同类型的参数。这会引发两个潜在问题：首先，返回类型是什么？返回值是两个参数之一，但必须有一个单一的返回类型。我们可以使用来自
    `<type_traits>` 头文件的 `std::common_type` 特性作为合理的答案：对于数值类型，它执行通常的类型提升，对于类，如果可能，它将基类转换为派生类，并且它尊重隐式用户指定的转换。但还有一个问题：如果表达式
    `t1 < t2` 无法编译，我们会在函数体中得到一个错误。这是不幸的，因为错误很难分析，可能具有误导性：它暗示函数体实现不正确。我们可以通过添加一个静态断言来解决第二个问题：
- en: '[PRE89]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This at least makes clear that we intended for the code to not compile if there
    is no matching `operator<()`. Note the weird way we had to formulate the assert:
    the expression `t1 < t2` itself must, in general, evaluate at run time, and is
    just as likely to be false. We need a compile-time value, and we don’t care which
    argument is less, just that they can be compared. So we assert something not about
    the result of the comparison but about the size of this result: `sizeof()` is
    always a compile-time value and the size of anything is at least 1 in C++. The
    only way this assertion can fail is if the expression does not compile at all.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这至少清楚地表明，如果没有匹配的 `operator<()`，我们希望代码无法编译。注意我们表达断言的奇怪方式：表达式 `t1 < t2` 本身通常必须在运行时评估，并且很可能为假。我们需要一个编译时值，而不关心哪个参数较小，只关心它们可以进行比较。因此，我们断言的不是比较的结果，而是这个结果的大小：`sizeof()`
    总是编译时值，而在 C++ 中任何东西的大小至少为 1。这个断言唯一可能失败的方式是表达式根本无法编译。
- en: 'This still does not solve the other part of the problem: the requirement on
    the argument types is not included in the interface of the function. The function
    can be called on any two types and then may or may not compile. With C++20 constraints,
    we can move the requirement from the implicit (compilation failure) or explicit
    (static assert) error in the function body to the function declaration and make
    it part of the function interface:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然没有解决问题的另一部分：对参数类型的约束没有被包含在函数的接口中。函数可以在任何两种类型上调用，然后可能编译或不编译。使用 C++20 约束，我们可以将要求从函数体内的隐式（编译失败）或显式（静态断言）错误移动到函数声明中，并使其成为函数接口的一部分：
- en: '[PRE90]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'As you learn to build more complex constraints, it is important to remember
    that the constraint expression must evaluate to a `bool` value; no conversions
    whatsoever are permitted, which is why a very similar expression does not work:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当您学习构建更复杂的约束时，重要的是要记住，约束表达式必须评估为 `bool` 值；不允许任何转换，这就是为什么一个非常类似的表达式不起作用的原因：
- en: '[PRE91]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The integer value of `sizeof()` is always non-zero and would have converted
    to `true`, but not in this context. The good news is that we don’t have to use
    the `sizeof()` hack at all to write constraints. There is yet another type of
    constraint expression, a *requires expression*, that is much more powerful and
    expresses our intent much clearer:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`sizeof()` 的整数值始终非零，并且会转换为 `true`，但在这个上下文中不会。好消息是，我们根本不需要使用 `sizeof()` 诡计来编写约束。还有一种类型的约束表达式，即
    *requires 表达式*，它更强大，并且能更清晰地表达我们的意图：'
- en: '[PRE92]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The requires expression begins with the `requires` keyword followed by braces
    `{}`; it can contain any number of expressions that have to compile, or the value
    of the entire requires expression is false (it does not matter what the results
    of these expressions are, they just have to be valid C++). You can also use types,
    type traits, and combinations of requirements of different kinds. By a quirk of
    the language, the parentheses around the requires expression are optional, which
    means you can see code like `requires requires { t1 < t2 }` where the first and
    the second `requires` are completely different keywords.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires` 表达式以 `requires` 关键字开头，后跟大括号 `{}`；它可以包含任意数量的必须编译的表达式，或者整个 `requires`
    表达式的值为假（这些表达式的结果如何并不重要，它们只需是有效的 C++ 表达式）。您还可以使用类型、类型特性和不同类型要求的组合。由于语言的一个特性，`requires`
    表达式周围的大括号是可选的，这意味着您可能会看到像 `requires requires { t1 < t2 }` 这样的代码，其中第一个和第二个 `requires`
    是完全不同的关键字。'
- en: The requirements on template types can be quite complex; often, the same requirements
    apply in many different templates. Sets of such requirements can be given names
    and defined for later use; these named requirements are called concepts. Each
    concept is a condition that is evaluated at compile time when used in a constraint.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 模板类型的要求可能相当复杂；通常，相同的约束在许多不同的模板中都适用。这样的要求集可以命名并定义以供以后使用；这些命名要求被称为概念。每个概念都是在约束中使用时在编译时评估的条件。
- en: 'The syntax for a constraint is similar to a template:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 约束的语法类似于模板：
- en: '[PRE93]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We are not going to cover the syntax in detail in this book – for that, use
    a reference source such as [cppreference.com](http://cppreference.com). A concept
    can be used instead of the requirement it contains:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中不会详细讲解语法——对于这一点，请使用像 [cppreference.com](http://cppreference.com) 这样的参考资源。一个概念可以用它所包含的要求来代替：
- en: '[PRE94]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Concepts that constrain a single type can also be used as template parameter
    placeholders. Let us consider an example of a `swap()` function. For integral
    types, there is a trick that allows us to swap two values without using a temporary
    variable. It relies on the properties of a bitwise XOR operation. Let us assume,
    for the purposes of this demonstration, that, on a particular hardware, this version
    is faster than the usual way of implementing swap. We would like to write a swap
    template function `MySwap(T& a, T& b)` that automatically detects whether the
    type T supports an XOR operation and use it, if available; otherwise we fall back
    on the usual swap.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 限制单个类型的概念也可以用作模板参数占位符。让我们考虑一个 `swap()` 函数的例子。对于整型，有一个技巧允许我们在不使用临时变量的情况下交换两个值。它依赖于位异或操作的性质。为了演示的目的，我们假设，在特定的硬件上，这个版本比通常实现交换的方式更快。我们希望编写一个自动检测类型
    T 是否支持异或操作并使用它的 `MySwap(T& a, T& b)` 模板函数；如果可用，否则我们回退到常规的交换。
- en: 'First, we need a concept for a type that supports XOR:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个支持异或操作的类型的概念：
- en: '[PRE95]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The concept has a requires expression; every expression inside the curly braces
    must compile, otherwise, the requirement of the concept is not met.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 该概念有一个`requires`表达式；大括号内的每个表达式都必须编译，否则，概念的要求没有得到满足。
- en: 'Now, we can implement an XOR-based swap template. We could do it with a `requires`
    constraint, but there is a more compact way:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现一个基于XOR的交换模板。我们可以使用`requires`约束来实现，但有一个更紧凑的方法：
- en: '[PRE96]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The concept name `HasXOR` can be used instead of the `typename` keyword to
    declare the template parameter. This restricts our `MySwap()` function to the
    types that have `operator^()`. But we need a general case overload, too. We should
    also note that *general* does not mean *any* in our case: the type has to support
    move assignment and move construction. We need another concept:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 概念名称`HasXOR`可以用作`typename`关键字来声明模板参数。这限制了我们的`MySwap()`函数只能用于具有`operator^()`的类型。但我们也需要一个通用情况的重载。我们还应该注意，在我们的情况下，“通用”并不意味着“任何”：类型必须支持移动赋值和移动构造。我们需要另一个概念：
- en: '[PRE97]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This is a very similar concept, except we have two expressions; both must be
    valid for the concept to be true.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常类似的概念，只不过我们有两个表达式；这两个表达式都必须有效，这个概念才是正确的。
- en: 'The second `MySwap()` overload accepts all `Assignable` types. However, we
    must explicitly exclude the types with XOR, or we will have ambiguous overloads.
    This is a perfect example to show that we can combine concepts as template placeholders
    with concepts in requirements:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`MySwap()`重载接受所有`Assignable`类型。然而，我们必须明确排除具有XOR的类型，否则我们将有模糊的重载。这是一个很好的例子，说明了我们可以将概念作为模板占位符与要求中的概念结合起来：
- en: '[PRE98]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Now a call to `MySwap()` will select the XOR-based overload if possible, otherwise,
    it will use the general overload (swapping non-assignable types will not compile
    at all).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果可能的话，调用`MySwap()`将选择基于XOR的重载，否则，它将使用通用重载（交换不可赋值类型根本无法编译）。
- en: 'Finally, let us return to one of the first examples in this chapter: that of
    a class template `ArrayOf2` in the section “*Class templates*.” Recall that it
    has a member function sum() which has much more strict requirements on the template
    type than the rest of the class: it adds the values of the array elements. If
    the elements do not have `operator+()`, there is no problem as long as we don’t
    call `sum()`, but if we do, we get a syntax error. It would have been better if
    this function was not a part of the class interface at all unless the type supports
    it. We can accomplish this with a constraint:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们回到本章的第一个例子之一：在“*类模板*”部分中的类模板`ArrayOf2`。回想一下，它有一个成员函数`sum()`，这个函数对模板类型的要求比类中的其他部分要严格得多：它添加数组元素的值。如果元素没有`operator+()`，只要我们不调用`sum()`，就没有问题，但如果我们调用它，就会得到一个语法错误。如果这个函数根本不是类接口的一部分，除非类型支持它，那就更好了。我们可以通过一个约束来实现这一点：
- en: '[PRE99]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: If the expression `a + b` does not compile, the code behaves as if there was
    no member function `sum()` declared in the class interface. Of course, we could
    also use a named concept for this.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式`a + b`无法编译，代码的行为就像在类接口中没有声明成员函数`sum()`一样。当然，我们也可以使用一个命名的概念来实现这一点。
- en: We will see more ways to manage requirements on template parameters in [*Chapter
    7*](B19262_07.xhtml#_idTextAnchor314). For now, let us review what we have learned
    and go on to use these tools to solve common C++ problems.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第7章*](B19262_07.xhtml#_idTextAnchor314)中看到更多管理模板参数要求的方法。现在，让我们回顾我们已经学到的内容，并继续使用这些工具来解决常见的C++问题。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Templates, variadic templates, and lambda expressions are all powerful features
    of C++, offering simplicity in use, but are rich in complex details. The examples
    in this chapter should serve to prepare the reader for the later chapters of this
    book, where we use these techniques to implement design patterns, both classic
    and novel, with the tools of the modern C++ language. The reader wishing to learn
    the art of using these complex and powerful tools to their fullest potential is
    referred to other books that are dedicated to teaching these subjects, some of
    which can be found at the end of this chapter.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 模板、变长模板和lambda表达式都是C++的强大功能，它们在用法上简单，但在细节上丰富。本章中的示例应该有助于为读者准备本书的后续章节，在这些章节中，我们将使用这些技术使用现代C++语言工具来实现经典和新型设计模式。希望学习如何充分利用这些复杂而强大的工具的读者可以参考其他专门教授这些主题的书籍，其中一些可以在本章末尾找到。
- en: The reader is now ready to learn common C++ idioms, starting with idioms for
    expressing memory ownership, in the next chapter.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，读者已经准备好学习常见的C++惯用法，从下一章中表达内存所有权的惯用法开始。
- en: Questions
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a type and a template?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型与模板之间有什么区别？
- en: What kind of templates does C++ have?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++ 有哪些类型的模板？
- en: What kinds of template parameters do C++ templates have?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++ 模板有哪些类型的模板参数？
- en: What is the difference between a template specialization and a template instantiation?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板特化与模板实例化之间有什么区别？
- en: How can you access the parameter pack of a variadic template?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何访问变长模板的参数包？
- en: What are lambda expressions used for?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: lambda 表达式有什么用途？
- en: How do concepts refine template interfaces?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 概念是如何细化模板接口的？
- en: Further reading
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*C++* *Fundamentals*: [https://www.packtpub.com/product/c-fundamentals](https://www.packtpub.com/product/c-fundamentals)'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++* 基础知识：[https://www.packtpub.com/product/c-fundamentals](https://www.packtpub.com/product/c-fundamentals)'
- en: '*C++ Data Structures and* *Algorithms*: [https://www.packtpub.com/product/c-data-structures-and-algorithms](https://www.packtpub.com/product/c-data-structures-and-algorithms)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++ 数据结构与算法*：[https://www.packtpub.com/product/c-data-structures-and-algorithms](https://www.packtpub.com/product/c-data-structures-and-algorithms)'
- en: '*Mastering C++* *Programming*: [https://www.packtpub.com/product/mastering-c-programming](https://www.packtpub.com/product/mastering-c-programming)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精通 C++ 编程*：[https://www.packtpub.com/product/mastering-c-programming](https://www.packtpub.com/product/mastering-c_programming)'
