- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Class and Function Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The template programming features of C++ form a large and complex subject, with
    many books dedicated exclusively to teaching these features. In this book, we
    will use many of the advanced C++ generic programming features. How, then, should
    we prepare ourselves to understand these language constructs as they make their
    appearance throughout this book? This chapter takes an informal approach—instead
    of precise definitions, we demonstrate the use of templates through examples and
    explain what the different language features do. If you find your knowledge lacking
    at this point, you’re encouraged to seek a deeper understanding and read one or
    more of the books dedicated entirely to the C++ language that are focused on explaining
    its syntax and semantics. Of course, if you wish for a more precise, formal description,
    you can refer to the C++ standard or a reference book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Templates in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class and function templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template instantiations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template specializations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overloading of template functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variadic templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the greatest strengths of C++ is its support for generic programming.
    In generic programming, the algorithms and data structures are written in terms
    of generic types that will be specified later. This allows the programmer to implement
    a function or a class once, and later, instantiate it for many different types.
    Templates are a C++ feature that allows classes and functions to be defined on
    generic types. C++ supports three kinds of templates—function, class, and variable
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: Function templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Function templates are generic functions—unlike regular functions, a template
    function does not declare its argument types. Instead, the types are template
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This template function can be used to increment a value of any type by one,
    for which adding one is a valid operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Most template functions have some limitations on the types that are used as
    their template parameters. For example, our `increment()` function requires that
    the expression `x + 1` is valid for the type of `x`. Otherwise, the attempt to
    instantiate the template will fail, with a somewhat verbose compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both non-member and class member functions can be function templates; however,
    virtual functions cannot be templates. The generic types can be used not only
    to declare function parameters but to declare any variables inside the body of
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++20, simple template declarations can be abbreviated: instead of writing'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: we can write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Other than more terse declarations, there is no particular advantage to this
    abbreviation, and the feature is quite limited. First of all, `auto` can be used
    only as the “top-level” parameter type; for example, this is invalid (but allowed
    by some compilers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: and must still be written as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, if you need to use template type parameters elsewhere in the function
    declaration, you can’t abbreviate them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you could declare the return type as `auto` and use the trailing
    return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: but at this point, the template is not really “abbreviated.”
  prefs: []
  type: TYPE_NORMAL
- en: We will see more of function templates later, but let’s introduce class templates
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Class templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Class templates are classes that use generic types, usually to declare their
    data members, but also to declare methods and local variables inside them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This class is implemented once, and can then be used to define an array of
    two elements of any type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Pay particular attention to the last example—you might expect the `ArrayOf2`
    template not to be valid with a type such as `char*`—after all, it has a method,
    `sum()`, that does not compile if the type of `a_[0]` and `a_[1]` is a pointer.
    However, our example compiles as written—a method of a class template does not
    have to be valid until we try to use it. If we never call `c.sum()`, then the
    fact that it would not compile never comes up, and the program remains valid.
    If we do call a member function that does not compile for the chosen template
    arguments, we get a syntax error in the body of the template (in our example,
    something about not being able to add two pointers). These error messages are
    rarely straightforward. Even if they were, it is unclear if the problem is in
    the body of the function, or if the function was not supposed to be called in
    the first place. Later in this chapter, we will see how to improve this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Variable templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last kind of template in C++ is a variable template, which was introduced
    in C++14\. This template allows us to define a variable with a generic type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Variable templates are, for the most part, very straightforward to use, mostly
    for defining your own constants, but there are some interesting patterns that
    take advantage of them; we will see one in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Non-type template parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Usually, template parameters are types, but C++ also allows for several kinds
    of non-type parameters. First of all, template parameters can be values of integer
    or enumeration types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is a template with two parameters—the first is a type, but the second is
    not. It is a value of type `size_t` that determines the size of the array; the
    advantage of such a template over a built-in C-style array is that it can do range
    checking. The C++ standard library has a `std::array` class template that should
    be used instead of implementing your own array in any real program, but it does
    make for an easy-to-follow example.
  prefs: []
  type: TYPE_NORMAL
- en: The values of non-type parameters that are used to instantiate a template must
    be compile-time constants or `constexpr` values—the last line in the preceding
    example is invalid because the value of `a[0]` is not known until the program
    reads it in at runtime. C++20 allows floating-point and user-defined types for
    non-type template parameters; until then, the parameters were limited to integral
    types, pointers (including function and member pointers), references, and enumerations.
    Of course, the value of a non-type parameter has to be a compile-time constant
    so, for example, pointers to local variables are not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The numeric template parameters used to be very popular in C++ because they
    allow complex compile-time calculations to be implemented, but in the recent versions
    of the standard, `constexpr` functions can be used to the same effect and are
    much easier to read. Of course, the standard takes with one hand and gives with
    the other, and so an interesting new use case emerged for non-template parameters
    combined with `constexpr` functions: these functions, first introduced in C++11,
    are used to define “immediate functions,” or functions that are evaluated at compile
    time. The problem with `constexpr` functions is that they *may* evaluate at compile
    time but it’s not required; they could also be evaluated at run time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have a `constexpr` function `length()`. Does the length computation
    actually happen at compile time? There is no way to know short of examining the
    generated assembly code (which can differ from one compiler to another). The only
    way to be sure is to invoke the function in a compile-time context, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first assert compiles, and the second does not even though the value 7
    is correct: the argument is not a compile-time value, so the evaluation must happen
    at run time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++20, the function may be declared `consteval` instead of `constexpr`:
    this guarantees that the evaluation happens at compile time or not at all (thus,
    the second `cout` statement in the preceding example will not compile). Prior
    to C++20, we have to get creative. Here is one way to enforce compile-time execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `force_consteval` variable template can be used to enforce compile-time
    evaluation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The second `cout` statement does not compile because the function `length()`
    cannot be evaluated as an immediate function. The variable template `force_consteval`
    uses a non-type template parameter whose type is not specified but deduced from
    the template argument (an `auto` template parameter). This is a C++17 feature;
    in C++14 we have to use a rather unelegant macro to achieve the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If a non-type template parameter seems “less than a type,” you will like the
    next option, a parameter that is definitely more than a simple type.
  prefs: []
  type: TYPE_NORMAL
- en: Template template parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second kind of non-type template parameter worth mentioning is a *template
    template* parameter—a template parameter that is itself a template. We will need
    them in the later chapters of this book. This template parameter is substituted—not
    with a name of a class, but a name of an entire template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a class template with a template template parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `Builder` template declares a class that is used to construct (build) a
    container of an arbitrary type `T`. The container itself does not have a specific
    type, it’s a template itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be instantiated with any container template that takes one type argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, there are additional requirements on the `Container` template: it
    must have a single type parameter `T` (the rest may be defaulted), it should be
    default-constructible, it must have a `push_back()` method, and so on. C++20 gives
    us a concise way to state these requirements and make them a part of the template
    interface; we will learn about it later in this chapter, in the *Concepts* section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a function template that has two template template parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes an arbitrary container as an argument and returns another
    container, a different template, but instantiated on the same type, with the values
    copied from the input container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that the compiler deduces both the type of the template argument (`In_container`
    as `my_vector`) and the type of its template parameter (`T` as `int`). Of course,
    the remaining template parameter `Out_container` cannot be deduced (it is not
    used in any parameters of the template function) and must be explicitly specified,
    which fits our intended use.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a major limitation on template template parameters that is made more
    complex by the fact that different compilers enforce it unevenly (i.e., some compilers
    let through the code that should not compile but you would really like it to).
    The limitation is that the number of template parameters specified for the template
    template must match the number of the template parameters of the argument. Consider
    this template function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This code may compile, but it depends on the version of the standard and the
    compiler’s strict adherence to the standard: the `std::vector` template has two
    template parameters, not one. The second parameter is the allocator; it has a
    default value, which is why we do not have to specify the allocator type when
    declaring a vector object. GCC, Clang, and MSVC all relax this requirement to
    some degree (but not to the same degree). Variadic templates, which we will see
    later in this chapter, offer another, more robust solution (at least in C++17
    and later).'
  prefs: []
  type: TYPE_NORMAL
- en: Templates are a kind of recipe for generating code. Next, we will see how we
    can convert these recipes into actual code we can run.
  prefs: []
  type: TYPE_NORMAL
- en: Template instantiations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The template name is not a type and cannot be used to declare a variable or
    call a function. To create a type or a function, the template must be instantiated.
    Most of the time, templates are instantiated implicitly when they are used. We
    will again start with function templates.
  prefs: []
  type: TYPE_NORMAL
- en: Function templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use a function template to generate a function, we have to specify which
    types should be used for all template type parameters. We can just specify the
    types directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This instantiates the `half` function template with the `int` type. The type
    is explicitly specified; we could call the function with an argument of another
    type, as long as it is convertible to the type we requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Even though the argument is an `int`, the instantiation is that of `half<double>`,
    and the return type is `double`. The integer value `5` is implicitly converted
    to `double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though every function template can be instantiated by specifying all its
    type parameters, this is rarely done. Most of the uses of function templates involve
    the automatic deduction of types. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The template type can be deduced only from the template function arguments—the
    compiler will attempt to select the type for the `T` parameter to match the type
    of the function argument that is declared with the same type. In our case, the
    function template has the argument `x` of the `T` type. Any call to this function
    has to provide some value for this argument, and this value must have a type.
    The compiler will deduce that `T` must be that type. In the first call in the
    preceding code block, the argument is `5`, and its type is `int`. There is nothing
    better to do than to assume that `T` should be `int` in this particular template
    instantiation. Similarly, in the second call, we can deduce that `T` must be `double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this deduction, the compiler performs type substitution: all other mentions
    of the `T` type are replaced by the type that was deduced; in our case, there
    is only one other use of `T`, which is the return type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Template argument deduction is widely used to capture types that we cannot
    easily determine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we deduce the `T` type to be whatever the type of the expression `y +
    z` is (it’s `long`, but with template deduction, we don’t need to specify that
    explicitly, and the deduced type will *follow* the argument type if we ever change
    the types of `y` and `z`). Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We deduce `T` to match whatever type the `f()` template function returns for
    an `int` argument (of course, the definition of the `f()` template function has
    to be provided before it can be called, but we do not need to dig into the header
    files where `f()` is defined, as the compiler will deduce the right type for us).
  prefs: []
  type: TYPE_NORMAL
- en: 'Only the types that are used to declare function arguments can be deduced.
    There is no rule that all template type parameters must be somehow present in
    the argument list, but any parameters that cannot be deduced must be explicitly
    specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first template type parameter is explicitly specified, so `U` is double,
    and `V` is deduced to be `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the compiler cannot deduce template type parameters, even if they
    are used to declare arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can deduce from the first argument that `T` must be `long`, but from
    the second argument, we deduce that `T` must be `int`. It is often surprising
    to programmers who learn their way around templates that the `long` type is not
    deduced in this case—after all, if we substitute `long` for `T` everywhere, the
    second argument will be implicitly converted, and the function will compile fine.
    So why isn’t the *larger* type deduced? Because the compiler does not attempt
    to find a type for which all argument conversions are possible: after all, there
    is usually more than one such type. In our example, `T` could be `double` or `unsigned
    long`, and the function would still be valid. If a type can be deduced from more
    than one argument, the result of all these deductions must be the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the template instantiation is considered ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type deduction is not always as straightforward as using the type of the
    argument for a type parameter. The argument may be declared with a type that’s
    more complex than a type parameter itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the type of the argument is a *pointer to* `int`, but the type that is
    deduced for `T` is `int`. The deduction of types can be arbitrarily complex, as
    long as it’s unambiguous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, the argument is an instantiation of another template, `std::vector`, and
    we have to deduce the template parameter type from the type that was used to create
    this vector instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen, if a type can be deduced from more than one function argument,
    the result of these deductions must be the same. On the other hand, one argument
    can be used to deduce more than one type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we deduce two types, `U` and `V`, from one argument, then use these two
    types to form a new type, `std::pair<V, U>`. This example is unnecessarily verbose,
    and we can take advantage of a few more C++ features to make it both more compact
    and easier to maintain. First of all, the standard already has a function that
    deduces the argument types and uses them to declare a pair, and we have even used
    this function—`std::make_pair()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, the return type of the function can be deduced from the expression
    in the `return` statement (a C++14 feature). The rules of this deduction are similar
    to the rules of the template argument type deduction. With these simplifications,
    our example becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we don’t explicitly use the types `U` and `V` anymore. We still need
    this function to be a template, since it operates on a generic type, that is,
    a pair of two types that we don’t know until we instantiate the function. We could,
    however, use only one template parameter that would stand for the type of the
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There is a significant difference between these two variants—the last function
    template will have its type deduced successfully from any call with one argument,
    no matter the type of that argument. If that argument is not `std::pair`, or,
    more generally, if the argument is not a class or a struct or it does not have
    the `first` and `second` data members, the deduction will still succeed, but the
    type substitution will fail. On the other hand, the previous version will not
    even be considered for arguments that are not a pair of some types. For any `std::pair`
    argument, the pair types are deduced, and the substitution should proceed without
    a problem. Can we use the last declaration and still restrict the type `T` to
    be a pair or another class with a similar interface? Yes, and we will see several
    ways to do so later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Member function templates are very similar to non-member function templates,
    and their arguments are similarly deduced. Member function templates can be used
    in classes or class templates, which we will review next.
  prefs: []
  type: TYPE_NORMAL
- en: Class templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instantiation of class templates is similar to that of function templates—the
    use of a template to create a type implicitly instantiates the template. To use
    a class template, we need to specify the type arguments for the template parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the `r` variable implicitly instantiates the `Ratio` class
    template for the `int` and `double` types. It also instantiates the default constructor
    of this class. The second constructor is not used in this code and is not instantiated.
    It is this feature of class templates—instantiating a template instantiates all
    data members, but does not instantiate the methods until they are used—that allows
    us to write class templates where only some of the methods compile for certain
    types. If we use the second constructor to initialize the values of `Ratio`, then
    that constructor is instantiated, and must be valid for the given types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++17, these constructors can be used to deduce the types of the class template
    from the constructor arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this works only if there are enough constructor arguments to deduce
    the types. For example, the default-constructed `Ratio` object has to be instantiated
    with explicitly specified types; there is simply no other way to deduce them.
    Prior to C++17, a helper function template was often used to construct an object
    whose type can be deduced from the arguments. Similarly to `std::make_pair()`,
    which we looked at previously, we can implement a `make_ratio` function that will
    do the same thing as the C++17 constructor argument deduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++17 way of deducing template arguments should be preferred, if it is
    available: it does not require writing another function that essentially duplicates
    the class constructor, and does not make an additional call to the copy or move
    constructor to initialize the object (although in practice most compilers will
    perform return value optimization and optimize away the call to the copy or move
    constructor).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a template is used to generate a type, it is instantiated implicitly.
    Both class and function templates can be explicitly instantiated as well. Doing
    so instantiates a template without using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Explicit instantiations are rarely needed, and will not be used elsewhere in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'While instantiations of class templates with specific template parameters behave
    (mostly) like regular classes, static data members of class templates deserve
    special mention. First, let us recall the common challenge of static class data
    members: they must be defined somewhere, and only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Without such a definition, the program will not link: the name `A::n` is not
    defined. But if the definition is moved into the header and the header is included
    in several compilation units, the program also will not link, this time the name
    `A::n` is multiply defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirement to define static data members exactly once is not feasible
    for class templates: we need them defined for every set of template parameters
    the template is instantiated with, and we can’t do that in any one compilation
    unit (other compilation units may instantiate the same template with different
    types). Fortunately, this is not necessary. Static members of class templates
    can (and should) be defined together with the template itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: While this technically results in multiple definitions, it is the job of the
    linker to consolidate them so we are left with a single definition (there is only
    one value of a static member variable for all objects of the same type).
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++17, inline variables offer a simpler solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This also works for non-template classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If the static data member of a class template has a non-trivial constructor,
    this constructor is invoked once for every instantiation of this template (not
    for every object – there is only one instance of a static member variable for
    all objects of the same type).
  prefs: []
  type: TYPE_NORMAL
- en: Class templates, as we have used them so far, allow us to declare generic classes,
    that is, classes that can be instantiated with many different types. So far, all
    of these classes look exactly the same, except for the types, and generate the
    same code. This is not always desirable—different types may need to be handled
    somewhat differently.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say that we want to be able to represent not only a ratio
    of two numbers stored in the `Ratio` object but also a ratio of two numbers stored
    elsewhere, with the `Ratio` object containing pointers to these numbers. Clearly,
    some of the methods of the `Ratio` object, such as the conversion operator to
    `double`, need to be implemented differently if the object stores pointers to
    the numerator and denominator. In C++, this is accomplished by specializing the
    template, which we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: Template specializations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Template specializations allow us to make the generated template code differently
    for some types—not just the same code with different types substituted, but completely
    different code. There are two kinds of template specializations in C++—explicit,
    or full, specializations and partial specialization. Let’s start with the former.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit specialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Explicit template specialization defines a special version of the template for
    a particular set of types. In an explicit specialization, all generic types are
    replaced by specific, concrete types. Since an explicit specialization is not
    a generic class or function, it does not need to be instantiated later. For the
    same reason, it is sometimes called **full specialization**. If the generic types
    are fully substituted, there is nothing generic left. An explicit specialization
    should not be confused with an explicit template instantiation—while both create
    an instantiation of a template for a given set of type arguments, an explicit
    instantiation creates an instantiation of the generic code, with the generic types
    substituted by the specific types. An explicit specialization creates an instantiation
    of the function or class with the same name but it overrides the implementation,
    so the resulting code can be completely different. An example should help us understand
    this distinction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a class template. Let’s say that, if both the numerator and
    the denominator of `Ratio` are `double`, we want to compute the ratio and store
    it as a single number. The generic `Ratio` code should remain the same, but for
    one particular set of types, we want the class to look entirely different. We
    can do this with an explicit specialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Both template type parameters are specified to be `double`. The class implementation
    is totally unlike the generic version—instead of two data members, we have just
    one; the conversion operator simply returns the value, and the constructor now
    computes the ratio of the numerator and the denominator. But it is not even the
    same constructor—instead of the non-template constructor `Ratio(const double&,
    const double&)` that the generic version would have if it was instantiated for
    two `double` template arguments, we provided a template constructor that can take
    two arguments of any types as long as they are convertible to `double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we don’t need to specialize the whole class template, because most
    of the generic code is still applicable. However, we may want to change the implementation
    of one or a few member functions. We can explicitly specialize the member function
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Template functions can be explicitly specialized as well. Again, unlike an
    explicit instantiation, we get to write the body of the function, and we can implement
    it any way we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We cannot, however, change the number or the types of arguments or the return
    type—they must match the result of the substitution of the generic types, so the
    following does not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: An explicit specialization must be declared before the first use of the template
    that would cause an implicit instantiation of the generic template for the same
    types. This makes sense—the implicit instantiation would create a class or a function
    with the same name and the same types as the explicit specialization. We would
    now have two versions of the same class or function in the program, and this violates
    the one definition rule and makes the program ill-formed (the exact rules can
    be found in the standard under *[basic.def.odr]*).
  prefs: []
  type: TYPE_NORMAL
- en: Explicit specializations are useful when we have one or a few types for which
    we need the template to behave very differently. However, this does not solve
    our problem with the ratio of pointers—we want a specialization that is still
    *somewhat generic*, that is, it can handle pointers to any types, just not any
    other types. This is accomplished by a partial specialization, which we will look
    at next.
  prefs: []
  type: TYPE_NORMAL
- en: Partial specialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we are getting to the really interesting part of C++ template programming—partial
    template specializations. When a class template is partially specialized, it remains
    as generic code, but *less generic* than the original template. The simplest form
    of a partial template is one where some of the generic types are replaced by concrete
    types, but other types remain generic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we convert `Ratio` to a `double` value if the numerator is `double`,
    regardless of the denominator type. More than one partial specialization can be
    defined for the same template. For example, we can also specialize for the case
    when the denominator is `double` and the numerator is anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When the template is instantiated, the best specialization for the given set
    of types is selected. In our case, if neither the numerator nor the denominator
    is `double`, then the general template has to be instantiated—there are no other
    choices. If the numerator is `double`, then the first partial specialization is
    a better (more specific) match than the general template. If the denominator is
    `double`, then the second partial specialization is a better match. But what happens
    if both terms are `double`? In this case, the two partial specializations are
    equivalent; neither is more specific than the other. This situation is considered
    ambiguous and the instantiation fails. Note that only this particular instantiation,
    `Ratio<double, double>`, fails—it is not an error (at least, not a syntax error)
    to define both specializations, but it is an error to request an instantiation
    that cannot be uniquely resolved to the narrowest specialization. To allow any
    instantiation of our template, we have to remove this ambiguity, and the only
    way to do that is to provide an even more narrow specialization that would be
    preferred over the other two. In our case, there is only one option—a full specialization
    for `Ratio<double, double>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, the fact that the partial specializations are ambiguous for the instantiation
    of `Ratio<double, double>` is no longer relevant—we have a more specific version
    of the template than either of them, so that version is preferred over both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Partial specializations do not have to specify some of the generic types fully.
    Therefore, can keep all types generic, but impose some restrictions on them. For
    example, we still want a specialization where both the numerator and the denominator
    are pointers. They can be pointers to anything, so they are generic types, but
    *less generic* than the arbitrary types of the general template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This partial specialization still has two generic types, but they are both pointer
    types, `N*` and `D*`, for any `N` and `D` types. The implementation is totally
    unlike that of the general template. When instantiated with two pointer types,
    the partial specialization is *more specific* than the general template and is
    considered a better match. Note that, in our example, the denominator is `double`.
    So why isn’t a partial specialization for the `double` denominator considered?
    That is because, while the denominator is `double` as far as the program logic
    is concerned, technically it is `double*`, a completely different type, and we
    do not have a specialization for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a specialization, a general template must first be declared. It does
    not, however, need to be defined—it is possible to specialize a template that
    does not exist in the general case. To do so, we must forward-declare the general
    template, then define all the specializations we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have no general `Value` template, but we have partial specializations
    for any pointer or reference types. If we try to instantiate the template on some
    other type, like `int`, we will get an error stating that the `Value<int>` type
    is incomplete—this is no different than trying to define an object with only a
    forward declaration of the class.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen only examples of partial specializations for class templates.
    Unlike the earlier discussion of full specializations, we have not seen a single
    function specialization here. There is a very good reason for that—a partial function
    template specialization does not exist in C++. What is sometimes incorrectly called
    a partial specialization is nothing more than overloading template functions.
    On the other hand, overloading template functions can get quite complex and is
    worth learning about—we will cover this next.
  prefs: []
  type: TYPE_NORMAL
- en: Template function overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are used to regular functions, or class methods, being overloaded—multiple
    functions with the same name have different parameter types. Each call invokes
    the function with the best match of the parameter types to the call arguments,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If the arguments are a perfect match for one of the overloaded functions with
    the given name, that function is called. Otherwise, the compiler considers conversions
    to the parameter types of the available functions. If one of the functions offers
    *better* conversions, that function is selected. Otherwise, the call is ambiguous,
    just as in the last line of the preceding example. The precise definition of what
    constitutes the *best* conversion can be found in the standard (see the section
    *Overloading*, more specifically, subsection *[over.match]*). Generally, the *cheapest*
    conversions are the ones such as adding `const` or removing a reference; then,
    there are conversions between built-in types, conversions from derived to base
    class pointers, and so on. In the case of multiple arguments, each argument for
    the chosen function must have the best conversion. There is no *voting*—if a function
    has three arguments, and two are an exact match for the first overload, while
    the third one is an exact match for the second overload, then even if the remaining
    arguments are implicitly convertible to their corresponding parameter types, the
    overloaded call is ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: The presence of templates makes the overload resolution much more complex. Multiple
    function templates with the same name and, possibly, the same number of arguments,
    can be defined, in addition to non-template functions. All of these functions
    are the candidates for an overloaded function call, but the function templates
    can generate functions with different parameter types, so how do we decide what
    the actual overloaded functions are? The exact rules are even more complex than
    the ones for non-template functions, but the basic idea is this—if there is a
    non-template function that is a near-perfect match to the call arguments, that
    function is selected. The standard, of course, uses much more precise terms than
    *near-perfect*, but *trivial* conversions, such as adding `const`, fall under
    that category—you get them *at no cost*. If there is no such function, the compiler
    will attempt to instantiate all function templates with the same name to a near-perfect
    match, using the template argument deduction. If exactly one of the templates
    was instantiated, the function created by this instantiation is called. Otherwise,
    overload resolution continues the usual way among the non-template functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very simplified description of a very complex process, but there
    are two important points—firstly, if there is an equally good match of a call
    to a template and a non-template function, the non-template function is preferred,
    and secondly, the compiler does not attempt to instantiate the function templates
    into something that might be convertible to the types we need. The template functions
    must match the call almost perfectly after the argument type deduction, or they
    are not called at all. Let’s add a template to our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have what looks like a partial specialization of a function template.
    But it really isn’t—it is just a function template—there is no general template
    for which it could be a specialization. Instead, it is simply a function template
    whose type parameter is deduced from the same arguments, but using different rules.
    The template can have its type deduced if the argument is a pointer of any kind.
    This includes a pointer to `const`—`T` could be a `const` type, so if we call
    `whatami(ptr)`, where `ptr` is `const int*`, that first template overload is a
    perfect match when `T` is `const int`. If the deduction succeeds, the function
    generated by the template, that is, the template instantiation, is added to the
    overload set.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `int*` argument, it is the only overload that works, so it is called.
    But what happens if more than one function template can match the call, and both
    instantiations are valid overloads? Let’s add one more template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This template function accepts its arguments by the universal reference, so
    it can be instantiated for any call to `whatami()` with one argument. The first
    call, `whatami(c)`, is easy—the last overload, with `T&&`, is the only one that
    can be called. There are no conversions from `c` to a pointer or an integer. But
    the second call is tricky—we have not one, but two template instantiations that
    are a perfect match for the call, with no conversions needed. So why is this not
    an ambiguous overload? Because the rules for resolving overloaded function templates
    are different than the rules for non-template functions and resemble the rules
    for selecting the partial specialization of a class template (which is another
    reason why function template overloads are often confused with partial specializations).
    The template that is more specific is a better match.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the first template is more specific—it can accept any pointer argument,
    but only pointers. The second template can accept any argument at all, so any
    time the first template is a possible match, the second is too, but not the reverse.
    If a more specific template can be used to instantiate a function that is a valid
    overload, then this template is used.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, we have to fall back to the more general template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The very general template functions in the overload set sometimes lead to unexpected
    results. Let’s say we have the following three overloads for `int`, `double`,
    and anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The first call has an `int` argument, so `whatami(int)` is a perfect match.
    The second call would have gone to `whatami(double)` if we did not have the template
    overload—the conversion from `float` to `double` is implicit (so is the conversion
    from `float` to `int`, but the conversion to `double` is preferred). But it’s
    still a conversion, so when the function template instantiates to a perfect match
    of `whatami(float&&)`, that is the best match and the chosen overload. The last
    call has a `double` argument, and again we have a perfect match to a non-template
    function `whatami(double)`, so it is preferred over any alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that overloading pass-by-value and pass-by-reference functions
    for the same parameter types often creates ambiguities in overload resolution.
    For example, these two functions are almost always ambiguous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As long as the argument to the function can be copied (and our object `c` is
    copyable), the overload is ambiguous and the call will not compile. The problem
    does not happen when a more specific function overloads a more general one (in
    all our previous examples, `whatami(int)` used pass-by-value with no problems),
    but mixing the two types of parameter passing for similarly general functions
    is inadvisable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is one more kind of function that has a special place in the
    overload resolution order—a variadic function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variadic function is declared with `...` instead of arguments, and it can
    be called with any number of arguments of any type (`printf` is one such function).
    This function is the overload of the last resort—it is called only if no other
    overloads can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As long as we have the overload `whatami(T&& x)` available, a variadic function
    will never be the preferred overload, at least not for any calls to `whatami()`
    with one argument. Without that template, `whatami(...)` is called for any argument
    that is not a number or a pointer. The variadic functions were around since the
    days of C, and are not to be confused with variadic templates that were introduced
    in C++11, and this is what we’ll talk about next.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably the greatest difference between generic programming in C and C++ is
    type safety. It is possible to write generic code in C—the standard function `qsort()`
    is a perfect example—it can sort values of any type and they are passed in using
    a `void*` pointer, which can really be a pointer to any type. Of course, the programmer
    has to know what the real type is and cast the pointer to the right type. In a
    generic C++ program, the types are either explicitly specified or deduced at the
    time of the instantiation, and the type system for generic types is as strong
    as it is for regular types. Unless we want a function with an unknown number of
    arguments, that is, prior to C++11, the only way was the old C-style variadic
    functions where the compiler had no idea what the argument types were; the programmer
    just had to know and unpack the variable arguments correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++11 introduced the modern equivalent to a variadic function—a variadic template.
    We can now declare a generic function with any number of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes one or more arguments, possibly of different types, and
    computes their sum. The return type is not easy to determine, but, fortunately,
    we can let the compiler figure it out—we just declare the return type as `auto`.
    How do we actually implement the function to add up the unknown number of values
    whose types we can’t name, not even as generic types? In C++17, it’s easy, because
    it has fold expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify that the type of the result is what we say it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++14, as well as in C++17, when a fold expression is not sufficient (and
    they are useful only in limited contexts, mostly when the arguments and combines
    using binary or unary operators), the standard technique is recursion, which is
    ever-popular in template programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The first overload (not a partial specialization!) is for the `sum()` function
    with one argument of any type. That value is returned. The second overload is
    for more than one argument, and the first argument is explicitly added to the
    sum of the remaining arguments. The recursion continues until there is only one
    argument left, at which point the other overload is called and the recursion stops.
    This is the standard technique for unraveling the parameter packs in variadic
    templates, and we will see this many times in this book. The compiler will inline
    all the recursive function calls and generate straightforward code that adds all
    arguments together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class templates can also be variadic—they have an arbitrary number of type
    arguments and can build classes from a varying number of objects of different
    types. The declaration is similar to that of a function template. For example,
    let’s build a class template, `Group`, that can hold any number of objects of
    different types and return the right object when it’s converted to one of the
    types it holds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The usual implementation of such templates is again recursive, using deeply
    nested inheritance, although a non-recursive implementation is sometimes possible.
    We will see one in the next section. The recursion has to be terminated when there
    is only one type parameter left. This is done using a partial specialization,
    so we will leave the general template we showed previously as a declaration only,
    and define a specialization for one type parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This class holds the value of one type, `T1`, initializes it by copy or move
    and returns a reference to it when converted to the `T1` type. The specialization
    for an arbitrary number of type parameters contains the first one as a data member,
    together with the corresponding initialization and conversion methods, and inherits
    from the `Group` class template of the remaining types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: For every type contained in a `Group` class, there are two possible ways it
    can be initialized—copy or move. Fortunately, we do not have to spell out the
    constructors for every combination of copy and move operations. Instead, we have
    two versions of the constructor for the two ways to initialize the first argument
    (the one stored in the specialization); we use perfect forwarding for the remaining
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use our `Group` class template to hold some values of different
    types (it cannot handle multiple values of the same type since the attempt to
    retrieve this type would be ambiguous):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'It is rather inconvenient to write all the group types explicitly and to make
    sure they match the argument types. In C++17, we can use a deduction guide to
    enable class template parameter deduction from the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Before C++17, the usual solution to this problem is to use a helper function
    template (a variadic template, of course) to take advantage of the template argument
    deduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Note that the C++ standard library contains a class template, `std::tuple`,
    which is a much more complete and full-featured version of our `Group`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variadic templates can have non-type parameters as well; in this case, the
    `makeGroup` template can be instantiated with an arbitrary number of arguments.
    Often, these non-type parameter packs are used in combination with `auto` (deduced)
    types. For example, here is a template that holds a list of compile-time constant
    values of different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Without `auto` (i.e., prior to C++17) it is almost impossible to declare such
    a template since the types must be explicitly specified. Note that this is the
    entire template: it holds the constant values as a part of its definition. To
    extract them, we need another variadic template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The template function `nth_value` deduces the parameter pack `Values` from the
    type of the `value_list` argument (the argument itself contains no data and is
    of no interest except for its type). A recursive instantiation of partial class
    specializations is then used to iterate over the parameter pack until we get to
    the `N`-th value. Note that to store floating-point constants in this manner,
    we need C++20.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variadic templates can be used in combination with template template parameters
    to resolve some of the problems created when, for example, standard library containers
    are used as arguments substituted for template template parameters. A simple solution
    is to declare the parameter as taking any number of types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `std::vector` template has two type parameters. In C++17, a standard
    change made this a valid match for the parameter pack specified in the `Container`
    template template parameter. Most compilers allowed such matches even earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The variadic templates, especially combined with perfect forwarding, are extremely
    useful for writing very general template classes—for example, a vector can contain
    objects of an arbitrary type, and, to construct these objects in place instead
    of copying them, we have to call constructors with a different number of arguments.
    When the vector template is written, there is no way to know how many arguments
    are needed to initialize the objects the vector will contain, so a variadic template
    has to be used (indeed, the in-place constructors of `std::vector`, such as `emplace_back`,
    are variadic templates).
  prefs: []
  type: TYPE_NORMAL
- en: There is one more kind of template-like entity in C++ that we have to mention,
    one that has the appearance of both a class and a function—a lambda expression.
    The next section is dedicated to this.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++, the regular function syntax is extended with the concept of a *callable*,
    short for *callable entity*—a callable is something that can be called in the
    same way as a function. Some examples of callables are functions (of course),
    function pointers, or objects with the `operator()`, also known as **functors**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'It is often useful to define a callable entity in a local context, right next
    to the place it is used. For example, to sort a sequence of objects, we may want
    to define a custom comparison function. We can use an ordinary function for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: However, in C++, functions cannot be defined inside other functions, so our
    `compare()` function may have to be defined quite far from the place it is used.
    If it is a single-use comparison function, such separation is inconvenient and
    reduces the readability and maintainability of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a way around this limitation—while we cannot declare functions inside
    functions, we can declare classes, and classes can be callable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This is compact and local, but rather verbose. We do not actually need to give
    this class a name, and we only ever want one instance of this class. In C++11,
    we have a much better option, the lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use this comparison function for just one call to `std::sort`, we don’t
    even need to give it a name and can define it inside the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This is as compact as it gets. The return type can be specified, but can usually
    be deduced by the compiler. The lambda expression creates an object, so it has
    a type, but that type is generated by the compiler, so the object declaration
    must use `auto`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lambda expressions are objects, so they can have data members. Of course,
    a local callable class can also have data members. Usually, they are initialized
    from the local variables in the containing scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this is a very verbose way to do something simple. We have to mention
    the tolerance variable three times—as a data member, a constructor argument, and
    in the member initialization list. A lambda expression makes this code simpler
    as well because it can capture local variables. In local classes, we are not allowed
    to reference variables from the containing scope, except by passing them through
    the constructor arguments, but for lambda expressions, the compiler automatically
    generates a constructor to capture all local variables mentioned in the body of
    the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the name `tolerance` inside the lambda expression refers to the local
    variable with the same name. The variable is captured by value, which is specified
    in the lambda expression’s capture clause `[=]`. We could have captured by reference
    using `[&]` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference is that, when capturing by value, a copy of the captured variable
    is created inside the lambda object at the point where it is constructed. This
    local copy is `const` by default, although we can declare the lambda mutable,
    which would let us change the captured values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, capturing the variables from the outer scope by reference
    makes every mention of this variable inside the lambda a reference to the original
    variable. Values captured by reference can be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to explicitly capture some variables by value or by reference;
    for example, the capture `[=, &count]` captures everything by value except `count`,
    which is captured by reference.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of changing the arguments of the lambda expression from `int` in the
    earlier example to `double`, we can declare them as `auto`, which effectively
    makes the `operator()` of the lambda expression a template (this is a C++14 feature).
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions are most commonly used as local functions. However, they
    are not really functions; they are callable objects, and so they are missing one
    feature that functions have—the ability to overload them. The last trick we will
    learn in this section is how to work around that and create an overload set from
    lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: First, the main idea—it is indeed impossible to overload callable objects. On
    the other hand, it is very easy to overload several `operator()` methods in the
    same object—methods are overloaded like any other function. Of course, the `operator()`
    of a lambda expression object is generated by the compiler, not declared by us,
    so it is not possible to force the compiler to generate more than one `operator()`
    in the same lambda expression. But classes have their own advantages, the main
    one being that we can inherit from them.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions are objects—their types are classes, so we can inherit from
    them too. If a class inherits publicly from a base class, all public methods of
    the base class become public methods of the derived class. If a class inherits
    publicly from several base classes (multiple inheritance), its public interface
    is formed from all the public methods of all the base classes. If there are multiple
    methods with the same name in this set, they become overloaded and the usual overloading
    resolution rules apply (in particular, it is possible to create an ambiguous set
    of overloads, in which case the program will not compile).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we need to create a class that automatically inherits from any number of
    base classes. We have just seen the right tool for that—variadic templates. As
    we have learned in the previous section, the usual way to iterate over an arbitrary
    number of items in the parameter pack of a variadic template is through recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The `overload_set` is a variadic class template; the general template has to
    be declared before we can specialize it, but it has no definition. The first definition
    is for the special case of only one lambda expression—the `overload_set` class
    inherits from the lambda expression and adds its `operator()` to its public interface.
    The specialization for `N` lambda expressions (`N>1`) inherits from the first
    one and from the `overload_set` constructed from the remaining `N-1` lambda expressions.
    Finally, we have a helper function that constructs the overload set from any number
    of lambda expressions—in our case, this is a necessity and not mere convenience
    since we cannot explicitly specify the types of the lambda expressions, but have
    to let the function template deduce them. Now, we can construct an overload set
    from any number of lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution is not perfect, because it does not handle ambiguous overloads
    well. In C++17, we can do better, and it gives us a chance to demonstrate an alternative
    way of using a parameter pack that does not need recursion. Here is the C++17
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The variadic template does not rely on partial specializations anymore; instead,
    it inherits directly from the parameter pack (this part of the implementation
    works in C++14 as well, but the `using` declaration needs C++17). The template
    helper function is the same—it deduces the types of all lambda expressions and
    constructs an object from the `overload_set` instantiation with these types. The
    lambda expressions themselves are passed to the base classes using perfect forwarding,
    where they are used to initialize all the base objects of the `overload_set` objects
    (lambda expressions are movable). Without the need for recursion or partial specialization,
    this is a much more compact and straightforward template. Its use is identical
    to the previous version of `overload_set`, but it handles near-ambiguous overloads
    better.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get rid of the template function as well and use template deduction
    guides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of the `overload` template remains largely unchanged; note the curly
    braces used to construct an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We will see lambdas used extensively in later chapters of this book when we
    will need to write a fragment of code and attach it to an object so that it can
    be executed later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to learn about a new C++ feature that, in a way, does the
    opposite of what we were trying to do so far: it makes templates *less* general.
    As we have seen already, it is easy to over-promise with a template: we can define
    templates whose definitions then do not compile in some cases. It would be better
    to make any restrictions on the template arguments to be a part of the declaration,
    so let us see how that is done.'
  prefs: []
  type: TYPE_NORMAL
- en: Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++20 introduced a major enhancement to the C++ template machinery: concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: In C++20, templates (both class and function templates), as well as non-template
    functions (members of class templates, usually) may use a constraint to specify
    the requirements on template arguments. These constraints are useful to produce
    better error messages, but they are truly indispensable when there is a need to
    select a function overload or a template specialization based on some properties
    of template arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax for a constraint is quite simple: a constraint is introduced
    by the keyword `requires` which can be specified after the function declaration
    or before the return type (in this book, we use both ways interchangeably so the
    reader becomes familiar with different styles of writing code). The expression
    itself usually uses the template parameters and must evaluate to a boolean value,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the function `copy()` requires that the type of its argument has a size
    of at least two bytes. If we attempt to call this function with a `char` argument,
    the call will not compile. Note that if a constraint is violated, it is as if
    the function did not exist for the purposes of a particular call: if there is
    another overload, it will be considered next even if, without the constraint,
    the overloads were ambiguous.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a more complex (and more useful) example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a function similar to `std::min`, except it takes two arguments of
    different types. This creates two potential issues: first, what is the return
    type? The return value is one of the two arguments, but there has to be a single
    return type. We can use the `std::common_type` trait from the `<type_traits>`
    header as a reasonable answer: for numeric types, it does the usual type promotion,
    for classes, it converts from base class to derived class if possible, and it
    respects implicit user-specified conversions. But there is a second problem: if
    the expression `t1 < t2` does not compile, we get an error in the body of the
    function. This is unfortunate because the error is hard to analyze and may be
    misleading: it suggests that the body of the function is implemented incorrectly.
    We can address the second concern by adding a static assert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This at least makes clear that we intended for the code to not compile if there
    is no matching `operator<()`. Note the weird way we had to formulate the assert:
    the expression `t1 < t2` itself must, in general, evaluate at run time, and is
    just as likely to be false. We need a compile-time value, and we don’t care which
    argument is less, just that they can be compared. So we assert something not about
    the result of the comparison but about the size of this result: `sizeof()` is
    always a compile-time value and the size of anything is at least 1 in C++. The
    only way this assertion can fail is if the expression does not compile at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This still does not solve the other part of the problem: the requirement on
    the argument types is not included in the interface of the function. The function
    can be called on any two types and then may or may not compile. With C++20 constraints,
    we can move the requirement from the implicit (compilation failure) or explicit
    (static assert) error in the function body to the function declaration and make
    it part of the function interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'As you learn to build more complex constraints, it is important to remember
    that the constraint expression must evaluate to a `bool` value; no conversions
    whatsoever are permitted, which is why a very similar expression does not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The integer value of `sizeof()` is always non-zero and would have converted
    to `true`, but not in this context. The good news is that we don’t have to use
    the `sizeof()` hack at all to write constraints. There is yet another type of
    constraint expression, a *requires expression*, that is much more powerful and
    expresses our intent much clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The requires expression begins with the `requires` keyword followed by braces
    `{}`; it can contain any number of expressions that have to compile, or the value
    of the entire requires expression is false (it does not matter what the results
    of these expressions are, they just have to be valid C++). You can also use types,
    type traits, and combinations of requirements of different kinds. By a quirk of
    the language, the parentheses around the requires expression are optional, which
    means you can see code like `requires requires { t1 < t2 }` where the first and
    the second `requires` are completely different keywords.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements on template types can be quite complex; often, the same requirements
    apply in many different templates. Sets of such requirements can be given names
    and defined for later use; these named requirements are called concepts. Each
    concept is a condition that is evaluated at compile time when used in a constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for a constraint is similar to a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We are not going to cover the syntax in detail in this book – for that, use
    a reference source such as [cppreference.com](http://cppreference.com). A concept
    can be used instead of the requirement it contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Concepts that constrain a single type can also be used as template parameter
    placeholders. Let us consider an example of a `swap()` function. For integral
    types, there is a trick that allows us to swap two values without using a temporary
    variable. It relies on the properties of a bitwise XOR operation. Let us assume,
    for the purposes of this demonstration, that, on a particular hardware, this version
    is faster than the usual way of implementing swap. We would like to write a swap
    template function `MySwap(T& a, T& b)` that automatically detects whether the
    type T supports an XOR operation and use it, if available; otherwise we fall back
    on the usual swap.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a concept for a type that supports XOR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The concept has a requires expression; every expression inside the curly braces
    must compile, otherwise, the requirement of the concept is not met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can implement an XOR-based swap template. We could do it with a `requires`
    constraint, but there is a more compact way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The concept name `HasXOR` can be used instead of the `typename` keyword to
    declare the template parameter. This restricts our `MySwap()` function to the
    types that have `operator^()`. But we need a general case overload, too. We should
    also note that *general* does not mean *any* in our case: the type has to support
    move assignment and move construction. We need another concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This is a very similar concept, except we have two expressions; both must be
    valid for the concept to be true.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second `MySwap()` overload accepts all `Assignable` types. However, we
    must explicitly exclude the types with XOR, or we will have ambiguous overloads.
    This is a perfect example to show that we can combine concepts as template placeholders
    with concepts in requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Now a call to `MySwap()` will select the XOR-based overload if possible, otherwise,
    it will use the general overload (swapping non-assignable types will not compile
    at all).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let us return to one of the first examples in this chapter: that of
    a class template `ArrayOf2` in the section “*Class templates*.” Recall that it
    has a member function sum() which has much more strict requirements on the template
    type than the rest of the class: it adds the values of the array elements. If
    the elements do not have `operator+()`, there is no problem as long as we don’t
    call `sum()`, but if we do, we get a syntax error. It would have been better if
    this function was not a part of the class interface at all unless the type supports
    it. We can accomplish this with a constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: If the expression `a + b` does not compile, the code behaves as if there was
    no member function `sum()` declared in the class interface. Of course, we could
    also use a named concept for this.
  prefs: []
  type: TYPE_NORMAL
- en: We will see more ways to manage requirements on template parameters in [*Chapter
    7*](B19262_07.xhtml#_idTextAnchor314). For now, let us review what we have learned
    and go on to use these tools to solve common C++ problems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates, variadic templates, and lambda expressions are all powerful features
    of C++, offering simplicity in use, but are rich in complex details. The examples
    in this chapter should serve to prepare the reader for the later chapters of this
    book, where we use these techniques to implement design patterns, both classic
    and novel, with the tools of the modern C++ language. The reader wishing to learn
    the art of using these complex and powerful tools to their fullest potential is
    referred to other books that are dedicated to teaching these subjects, some of
    which can be found at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The reader is now ready to learn common C++ idioms, starting with idioms for
    expressing memory ownership, in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between a type and a template?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kind of templates does C++ have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kinds of template parameters do C++ templates have?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a template specialization and a template instantiation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you access the parameter pack of a variadic template?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are lambda expressions used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do concepts refine template interfaces?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*C++* *Fundamentals*: [https://www.packtpub.com/product/c-fundamentals](https://www.packtpub.com/product/c-fundamentals)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C++ Data Structures and* *Algorithms*: [https://www.packtpub.com/product/c-data-structures-and-algorithms](https://www.packtpub.com/product/c-data-structures-and-algorithms)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering C++* *Programming*: [https://www.packtpub.com/product/mastering-c-programming](https://www.packtpub.com/product/mastering-c-programming)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
