["```cpp\nextends Node2D\n@export var camera_distance: float = 200\n@onready var _player: CharacterBody2D = get_parent()\nfunc _process(_delta):\n   var move_direction: Vector2 = _player.velocity.normalized()\n   position = move_direction * camera_distance\n```", "```cpp\n@export var position_interpolation_speed: float = 1.0\n```", "```cpp\nfunc _physics_process(delta):\n   var move_direction: Vector2 = _player.velocity.normalized()\n   var target_position: Vector2 = move_direction * camera_distance\n   position = CameraPosition to have as a target_position. Then, in the next line, we calculate the actual position.\n\t\t\tTo calculate the position, we use a new function, `lerp()`. This is short for `move_towards()`, which we used in [*Chapter 7*](B19358_07.xhtml#_idTextAnchor523). However, while `move_towards()` moves the position a certain number of pixels toward the target position, `lerp` moves the position toward the `target_position` according to a percentage between the two, which is the last argument in the function. This percentage is expressed in a value from `0.0` to `1.0`, where `0.0` is `0%` and `1.0` is `100%`.\n\t\t\tSo, let’s say we want to move `50%` between the position and its target, then the resulting position will be right in the middle between the two points.\n\t\t\tThis process is called **linear interpolation** because we interpolate between two values linearly. The way we use linear interpolation in our camera position script is to move toward the target position a little bit every frame.\n\t\t\tThe percentage of the linear interpolation that I chose was `5.0 * delta`. I put this value in an exported variable so we can easily tweak it from the editor. Because delta is the time between two frames, the result of this product is very small and should result in an interpolation of around `10%` per frame. We multiply by `delta` because, just like for the movement speed of the player, we want the speed of the camera not to change on faster or slower computers that run at a higher or lower framerate. We talked about frame rate independent calculations in [*Chapter 7*](B19358_07.xhtml#_idTextAnchor523) too when making the character move.\n\t\t\tYou can play around with the speed of the interpolation by changing the `position_interpolation_speed` to anything else through the inspector.\n\t\t\tIn this section, we learned a great deal about creating a smooth and useful camera that frames where the player is moving toward. As mentioned in the introduction of this chapter, big-budget games have whole teams that work on nothing else but the camera. But using some smart tricks, we achieved a fairly nice camera for our little game. Now, we’ll shift gears and make sure the player stops running through walls by adding collision detection.\n\t\t\tCollisions\n\t\t\tWith our brand-new camera in place, let’s take a look at collisions. For now, we have the visuals of a nice arena, including walls and rocks, but they don’t really act like them. The player character is able to just run through them as if they were made out of air instead of solid matter.\n\t\t\tJust like with the movement of the player, we can solve this using the built-in physics engine. Let’s start by taking a look at the different physics bodies at our disposal.\n\t\t\tThe different physics bodies\n\t\t\tFor the player character, we used the **CharacterBody2D** physics body. But this is not the only kind that comes with the physics engine Godot. There are a few other ones:\n\t\t\t![Figure 9.8 – The three different physics bodies as displayed in the scene tree](img/B19358_09_8.jpg)\n\n\t\t\tFigure 9.8 – The three different physics bodies as displayed in the scene tree\n\t\t\tFor 2D games, there are three different kinds of physics bodies available. Each has its own uses within a game or physics simulation. Let’s take a look at each.\n\t\t\tRigidBody2D\n\t\t\tA rigid body is a physics object that is fully simulated. Rigid bodies are completely dependent on outside physical forces and collisions. You are not supposed to control them directly.\n\t\t\tImportant note\n\t\t\tThese bodies are called rigid because the body itself does not deform. So, it gets used for simulating solid objects from cars to bones to walls. The **StaticBody2D** and **CharacterBody2D** can also not deform and are therefore also rigid bodies, but more in the mathematical sense of the word and not in how they are implemented within the engine.\n\t\t\tWe cannot directly control a rigid body; they are fully managed by the physics engine, which resolves how it moves and how the velocities and forces get applied. The only way to control a rigid body is by applying external forces to it. This is like hitting a golf ball with a stick. With enough practice and fine-tuning, you can get the ball in the general direction of the hole, but picking it up and dropping it in there, though easier, is not an option.\n\t\t\tSimulating non-rigid, bodies, also known as soft bodies, is generally harder to do mathematically and performantly within a game. Soft bodies could be sponges, rubber objects that deform, jelly, and so on. There are ways to simulate these within a rigid body simulation, but it’s not advised to do this. In 3D, there is a **Softbody3D** node, but it is not for 2D.\n\t\t\tStaticBody2D\n\t\t\tA static body is a physics body that stays static, meaning it does not move around and also cannot be pushed by external forces. This is the simplest of physics bodies to deal with and will be ideal for making our walls and rocks out of.\n\t\t\tCharacterBody2D\n\t\t\tA character body is a physics body that we are able to control through code. A **RigidBody2D**, as we saw earlier, is fully managed by the physics engine. This makes it hard to control to get it to do what you want it to.\n\t\t\tA character body, on the other hand, gives us a good middle ground. Like in the `player.gd` script, we have to calculate the `velocity` ourselves and call `move_and_slide()`. But the physics engine still helps us out with collisions and calculating where the body is supposed to move based on the velocity.\n\t\t\tMore information\n\t\t\tThe Godot documentation also has a great write-up of the different physics bodies and how they can be used: [https://docs.godotengine.org/en/stable/tutorials/physics/physics_introduction.html#collision-objects](https://docs.godotengine.org/en/stable/tutorials/physics/physics_introduction.html#collision-objects).\n\t\t\tThese were the three types of physics bodies available in Godot. But there is actually a fourth physics object, which is not a body. Let’s take a look at the **Area2D** node.\n\t\t\tThe Area2D node\n\t\t\tThe three physics bodies we just saw all collide with each other and react to this collision or make other bodies react to it. In essence, their movements get processed by the physics engine.\n\t\t\tThe last physics object, **Area2D**, only detects and influences other physics objects. It is not subjected to physics calculation, like for movement. But it can detect if another physics object is overlapping it and throws a signal when these other physics objects enter or leave.\n\t\t\tWe will use this functionality near the end of this chapter to make the player pick up health potions when they come near them.\n\t\t\t![Figure 9.9 – The four different physics objects as they are displayed in the scene tree](img/B19358_09_9.jpg)\n\n\t\t\tFigure 9.9 – The four different physics objects as they are displayed in the scene tree\n\t\t\tNow that you know about the three types of physics bodies currently available, we can start utilizing them to create proper collisions.\n\t\t\tAdding a collision shape to the player node\n\t\t\tSince we created the player node all the way back in [*Chapter 6*](B19358_06.xhtml#_idTextAnchor411), there has been this little orange triangle next to it. When we hover over it, the tool tip explains to us that this node is missing a shape. This makes sense, how can the physics engine detect collisions if it doesn’t know what shape a physics body is?\n\t\t\tLet’s solve this little warning:\n\n\t\t\t\t1.  Find and add the `Player` node:\n\n\t\t\t![Figure 9.10 – Add a CollisionShape2D to the player scene](img/B19358_09_10.jpg)\n\n\t\t\tFigure 9.10 – Add a CollisionShape2D to the player scene\n\n\t\t\t\t1.  Select this newly created **CollisionShape2D** node and click on the empty **Shape** field to reveal a drop-down menu with different shapes.\n\t\t\t\t2.  Select the **CapsuleShape2D** option.\n\n\t\t\t![Figure 9.11 – Select a CapsuleShape2D as the CollisionShape2D’s shape](img/B19358_09_11.jpg)\n\n\t\t\tFigure 9.11 – Select a CapsuleShape2D as the CollisionShape2D’s shape\n\n\t\t\t\t1.  A capsule-like blue shape will appear on the screen. This is the shape of the physics body. Use the orange circles on the periphery of the shape to change its size and try to cover most of the player sprite:\n\n\t\t\t![Figure 9.12 – Make sure the CapsuleShape2D covers the player sprite](img/B19358_09_12.jpg)\n\n\t\t\tFigure 9.12 – Make sure the CapsuleShape2D covers the player sprite\n\t\t\tThe **CollisionShape2D** node in itself does not have a shape, but it will hold one for us. That is why we had to add one to the **Shape** property.\n\t\t\tOther shapes that are interesting as collision shapes are **RectangleShape2D** and **CircleShape2D**. The others are used in specialized situations, such as for very thin or disjointed objects, so don’t worry too much about them just yet.\n\t\t\t![Figure 9.13 – The CircleShape2D and RectangleShape2D](img/B19358_09_13.jpg)\n\n\t\t\tFigure 9.13 – The CircleShape2D and RectangleShape2D\n\t\t\tRunning the game now will not result in the player colliding with the boulders or walls, simply because first, we’ll also need to add physics bodies and shapes to the scenes of these two.\n\t\t\tCreating static bodies for the boulders\n\t\t\tIn the *The different physics bodies* section, we learned that **StaticBody2D** nodes don’t move; that sounds ideal for a boulder. So, let’s make them solid:\n\n\t\t\t\t1.  Go into our `boulder.tscn` scene.\n\t\t\t\t2.  Add a **StaticBody2D** node under the root node:\n\n\t\t\t![Figure 9.14 – Adding a StaticBody2D with a CollisionPolygon2D as a child of the boulder scene](img/B19358_09_14.jpg)\n\n\t\t\tFigure 9.14 – Adding a StaticBody2D with a CollisionPolygon2D as a child of the boulder scene\n\n\t\t\t\t1.  Add a `CollisionPolygon2D` node under this newly created static body.\n\t\t\t\t2.  Now add points to the collision polygon by clicking within the 2D editor. Try to cover the boulder completely:\n\n\t\t\t![Figure 9.15 – Cover the boulder with the PolygonShape2D](img/B19358_09_15.jpg)\n\n\t\t\tFigure 9.15 – Cover the boulder with the PolygonShape2D\n\t\t\tNote that we use a different kind of collision shape. Now we use `CollisionPolygon2D`. This shape lets us define our own arbitrary shape. The advantage is that we can create any shape we like. The disadvantage is that arbitrary polygons are a bit slower for the physics engine to handle. But this should not be a big problem in our game because we will not have thousands of objects that require complex physics calculations.\n\t\t\tNow that we know how to create static bodies, we can do the same for other static objects in our game, such as walls.\n\t\t\tCreating static bodies for the walls\n\t\t\tLet’s do something similar by adding collision to the walls within the game:\n\n\t\t\t\t1.  Open up `wall.tscn`.\n\t\t\t\t2.  Add a **StaticBody2D** node.\n\n\t\t\t![Figure 9.16 – The wall’s StaticBody2D has two CollisioniShape2D children](img/B19358_09_16.jpg)\n\n\t\t\tFigure 9.16 – The wall’s StaticBody2D has two CollisioniShape2D children\n\n\t\t\t\t1.  Instead of using a **CollisionPolygon2D**, add two **CollisionShape2D** nodes.\n\t\t\t\t2.  Give them each a **RectangleShape2D** in their **Shape** property.\n\t\t\t\t3.  Now make sure that the combination of these two shapes covers the wall:\n\n\t\t\t![Figure 9.17 – Covering the wall using the two RectangleShape2Ds](img/B19358_09_17.jpg)\n\n\t\t\tFigure 9.17 – Covering the wall using the two RectangleShape2Ds\n\t\t\tFrom this example, you can see that a single physics body can actually contain multiple collision shapes. This is very useful when constructing complex shapes without having to resort to a **CollisionPolygon2D**. Although we used two rectangle shapes, we could have used two different shapes if we wanted to, even combining regular shapes and polygons. We can add as many shapes under one physics body as we desire.\n\t\t\tIn this section, we learned how to use different physics bodies to do collision detection and make sure the player doesn’t walk through walls and boulders. In the next section, we’ll extend this knowledge to also use the physics engine to detect whether the player is within a certain region or not.\n\t\t\tCreating collectibles\n\t\t\tNow, let’s create some collectibles for our hero to pick up. We’ll create two different collectibles:\n\n\t\t\t\t*   A health potion, which will replenish the health of the character\n\t\t\t\t*   A coin, which will add one gold to the player’s money\n\n\t\t\tWe’ll start off by creating a base collectible, from which we can easily implement the two different behaviors we want the two collectibles to have.\n\t\t\tCreating the base collectible scene\n\t\t\tThe base scene and class that we will build to inherit each specific collectible is very important; it should cover the use case of all other collectibles that we want to create. So let’s start:\n\n\t\t\t\t1.  Create a new scene called `collectible.tscn` in a new folder, `parts/collectibles`.\n\t\t\t\t2.  Set up the scene as shown in *Figure 9**.18*:\n    1.  Make the root node a `Collectible`.\n    2.  Add an **Area2D** node and a **Sprite2D** as direct children.\n    3.  Add a **CollisionShape2D** to the area.\n\n\t\t\t![Figure 9.18 – The base scene structure for our collectibles](img/B19358_09_18.jpg)\n\n\t\t\tFigure 9.18 – The base scene structure for our collectibles\n\n\t\t\t\t1.  Fill the **Shape** property of the **CollisionShape2D** with a **CircleShape2D**.\n\t\t\t\t2.  Update the radius of the circle shape to be `25` pixels.\n\n\t\t\tWe use a new node type, **Area2D**. An **Area2D** node can detect collisions when another physics body or area enters its shape. As we are using this physics object, the **Area2D** node will not act out any physics, nor will it influence the physics of the other physics body. **Area2D** nodes are used to detect whether other bodies or areas overlap their collision shape. We will use this functionality to detect if the player character overlaps the collectible because when this happens, we have to execute the code associated with the collectible.\n\t\t\tWith the base collectible scene ready, we can easily inherit from it in the next section.\n\t\t\tInheriting from a base scene\n\t\t\tIf you were wondering why we didn’t add a texture to the collectible scene yet, that’s because we want to do that for specific collectibles, such as the health potion and coin, and not for the base.\n\t\t\tSo let’s create a specific collectible:\n\n\t\t\t\t1.  Right-click on the `collectible.tscn` scene in the file manager and select **New** **Inherited Scene**.\n\n\t\t\t![Figure 9.19 - Right-clicking the collectible.tscn file and choosing New Inherited Scene](img/B19358_09_19.jpg)\n\n\t\t\tFigure 9.19 - Right-clicking the collectible.tscn file and choosing New Inherited Scene\n\n\t\t\t\t1.  A new scene will open up. Rename the root node to `HealthPotion`:\n\n\t\t\t![Figure 9.20 – The inherited nodes are greyed out](img/B19358_09_20.jpg)\n\n\t\t\tFigure 9.20 – The inherited nodes are greyed out\n\n\t\t\t\t1.  Save the inherited scene as `health_potion.tscn` in the same folder as the `collectible.tscn`, which is `parts/collectibles`.\n\t\t\t\t2.  Now add the `HealthPotion.png`, from `assets/visual/collectibles`, as a texture to the **Sprite2D** node.\n\t\t\t\t3.  The sprite is a little small, so set the scale to `(2, 2)`, as we did for the player’s sprite in [*Chapter 6*](B19358_06.xhtml#_idTextAnchor411):\n\n\t\t\t![Figure 9.21 – This is how our health potion collectible should look in the editor](img/B19358_09_21.jpg)\n\n\t\t\tFigure 9.21 – This is how our health potion collectible should look in the editor\n\t\t\tYou can see that all the nodes, except for the root node, are greyed out, as in *Figure 9**.22*. That is because these nodes are managed by the scene we are inheriting from, the `collectible.tscn` scene in this case.\n\t\t\t![Figure 9.22 – When inheriting a scene, the inherited nodes are greyed out](img/B19358_09_22.jpg)\n\n\t\t\tFigure 9.22 – When inheriting a scene, the inherited nodes are greyed out\n\t\t\tTry it yourself\n\t\t\tJust as an experiment, go back to the `collectible.tscn` scene, put the sprite node in a different location, and save. If you have a look in the `health_potion.tscn` scene, you’ll see that the sprite moved to the same location too!\n\t\t\tWith the technique of inheriting scenes, we can easily build out the functionality of collectibles without having to alter each collectible’s scene separately or copy-pasting. We can just define the base structure and functionality once.\n\t\t\tWith our base health potion scene done, we can now add its logic. First, we need to know when the player is actually close enough to pick up the collectible. We’ll learn how to do this in the next section.\n\t\t\tConnecting to a signal\n\t\t\tIn the *Creating the base collectible scene* section, I told you that we were going to use an **Area2D** node to detect when the player’s physics shape enters and thus when we know the collectible should be collected.\n\t\t\tTo do this, we’ll learn about a new concept in Godot Engine: **signals**. All nodes can throw signals; a signal could be something such as *“a physics body entered my shape”*. We could listen, or connect, to this signal and run a piece of code whenever it happens.\n\t\t\tWe will now do this for the signal that the **Area2D** node throws when a physics body enters its collision shape:\n\n\t\t\t\t1.  Go to the `collectible.tscn` scene.\n\t\t\t\t2.  Add an empty script to the root node. To connect to a signal, we first need a script. Make sure to delete all the code within the script except for the first one that says it extends the `collectible.gb`.\n\t\t\t\t3.  Now select the **Area2D** node. In the right panel, where we normally see the Inspector for a node, there is also a tab called **Node**. Click it.\n\n\t\t\t![Figure 9.23 – The list of signals an Area2D node can throw; body_entered is the one we need](img/B19358_09_23.jpg)\n\n\t\t\tFigure 9.23 – The list of signals an Area2D node can throw; body_entered is the one we need\n\n\t\t\t\t1.  This tab shows us the different signals a node can throw. The one we want to connect to is called `body_entered` because it gets thrown from the moment a physics body enters the **Area2D** node. Select this signal and press the **Connect** button in the bottom right.\n\t\t\t\t2.  A modal pops up asking us to which node in the current scene we want to connect this signal. The root `Collectible` node should already be selected, so just press the **Connect** button.\n\n\t\t\t![Figure 9.24 – Selecting the node we want to connect the signal with, the Collectible node in our case](img/B19358_09_24.jpg)\n\n\t\t\tFigure 9.24 – Selecting the node we want to connect the signal with, the Collectible node in our case\n\n\t\t\t\t1.  We will now directly be taken to the `collectible.gb` script and you can see that a new function, `_on_area_2d_body_entered`, got added for us:\n\n\t\t\t![Figure 9.25 – A new function will automatically be created for us after connecting the signal](img/B19358_09_25.jpg)\n\n\t\t\tFigure 9.25 – A new function will automatically be created for us after connecting the signal\n\t\t\tThe connection of the signal is done; now, every time the `body_entered` signal is thrown by the `_on_area_2d_body_entered` function of that collectible will be executed.\n\t\t\tAlso notice that the generated function has a parameter called `body`. This is the body object that overlapped the **Area2D**; for example, the player. Signals can give some context when they are being throw in the form of these parameters. Different signals have different parameters, and most have no parameters at all.\n\t\t\tWriting the code for collectibles\n\t\t\tNow we’ll finally write some real code to give the player some new health points when picking up the health potion, though it will not be that much, to be honest. Let’s write the code necessary to make our health potion functional:\n\n\t\t\t\t1.  First, go back to the `collectible.gd` script. We’ll make this script a named class by adding a line defining the class name at the top:\n\n    ```", "```cpp\n\n\t\t\tImportant note\n\t\t\tCreating a named class with `class_name` is not 100% necessary here, but it is good practice to name classes that you are going to inherit from.\n\n\t\t\t\t1.  Now in the `health_potion.tscn` scene, right-click on the root node, and select **Extend Script**.\n\t\t\t\t2.  Save the new script as `health_potion.gd` in the same folder as `health_potion.tscn`. This will create a script that inherits from the `Collectible` class and assigns it to the **HealthPotion** node for us.\n\n\t\t\t![Figure 9.26 – Right-clicking the HealthPotion node and selecting Extend Script](img/B19358_09_26.jpg)\n\n\t\t\tFigure 9.26 – Right-clicking the HealthPotion node and selecting Extend Script\n\n\t\t\t\t1.  Next, override the `_on_area_2d_body_entered()` function by defining a new one, like so:\n\n    ```", "```cpp\n\n\t\t\tThis function is used in the `Collectible` class to connect to the `body_entered` signal. By overriding it here, we effectively replace the function that will be executed.\n\t\t\tYou can see that we take the body that is provided as an argument and simply update its health value by adding `5`.\n\t\t\tThe last line introduces a new function that we can call on nodes: `queue_free()`. This function will queue the node for deletion so that the engine knows it can be removed from the scene tree. The engine will delete the node at the end of the current frame.\n\t\t\tLet’s try this out! Go back to the main scene and add a health potion somewhere by dragging and dropping the scene anywhere in the arena:\n\t\t\t![Figure 9.27 – Adding a HealthPotion in the main scene](img/B19358_09_27.jpg)\n\n\t\t\tFigure 9.27 – Adding a HealthPotion in the main scene\n\t\t\tIf you put the health potion somewhere without boulders or walls, you will be able to walk over there with the player character and pick it up. But if you put the health potion too close to a boulder or wall, you’ll get an error! Oh no! Let’s learn how to solve this next.\n\t\t\tUsing collision layers and masks\n\t\t\tThere is one problem! The signal will now be thrown for every physics body that enters the **Area2D** of the collectible, so even for boulders and walls. But we only want to trigger the functionality when our player enters the area.\n\t\t\tLuckily, we can only trigger the overlap detection for certain bodies using collision layers and masks.\n\t\t\tIntroducing collision layers and masks\n\t\t\tIf you select the `collectible.tscn` scene, you’ll see the **Collision Layer** and **Collision Mask** properties in the inspector. These two dictate what other physics bodies and areas can interact with the area.\n\n\t\t\t\t*   **Collision Layers** dictates what layer the physics object is in and can be detected by other physics objects.\n\t\t\t\t*   **Collision Mask** dictates what layers this physics object is looking at for collision detection.\n\n\t\t\t![Figure 9.28 – There are 32 separate collision layers and masks](img/B19358_09_28.jpg)\n\n\t\t\tFigure 9.28 – There are 32 separate collision layers and masks\n\t\t\tThis means that the collision layers are used to tell other bodies and areas that you exist, while the collision mask is used to detect other bodies and areas. Note that these don’t need to be the same. The layers could be different from the mask, and that one body or area can be active in multiple layers and can look at multiple masks.\n\t\t\tEach collision layer has a number associated with it, but we can actually give them a name that is easier to read for humans. We’ll do that in the next section.\n\t\t\tNaming collision layers\n\t\t\tWhat we are going to do is use one layer, `layer number 1`, as the layer for wall collisions and another layer, `layer number 2`, for collectible detection. Because it is difficult and non-descriptive to talk about `layer number 1` and `layer number 2`, we can name layers within the Godot Editor. This will help us in the long run:\n\n\t\t\t\t1.  Open up the **Project Settings**.\n\t\t\t\t2.  Navigate to **Layer Names** | **2D Physics**:\n\n\t\t\t![Figure 9.29 – Naming collision layers under the 2D Physics category](img/B19358_09_29.jpg)\n\n\t\t\tFigure 9.29 – Naming collision layers under the 2D Physics category\n\t\t\tHere, you can see the different collision layers and their names. None of them have a name yet.\n\n\t\t\t\t1.  Give `Collision` and `Collectible`:\n\n\t\t\t![Figure 9.30 – Naming two of the layers](img/B19358_09_30.jpg)\n\n\t\t\tFigure 9.30 – Naming two of the layers\n\n\t\t\t\t1.  If we now select the **Area2D** node from the collectible scene again and hover over the layer numbers, we’ll see the name pop up:\n\n\t\t\t![Figure 9.31 – Hovering over a collision layer number shows us its name](img/B19358_09_31.jpg)\n\n\t\t\tFigure 9.31 – Hovering over a collision layer number shows us its name\n\n\t\t\t\t1.  We can also click on the ellipses next to the layers for easier layer selection to see our names there.\n\n\t\t\t![Figure 9.32 – Pressing the ellipses makes it easy to select named collision layers](img/B19358_09_32.jpg)\n\n\t\t\tFigure 9.32 – Pressing the ellipses makes it easy to select named collision layers\n\t\t\tWith these collision layers having a name, it will be easier to assign them in the future. So let’s do that in the next section.\n\t\t\tAssigning the right layers\n\t\t\tNow that we understand collision layers and masks and know how to name them, let’s use them so that only the player can trigger collectibles.\n\t\t\tWe’ll have to adjust the collision layers and masks of all physics bodies in the game. Luckily, we made separate scenes for all of them, so this will go fast and, in the future, we can take these layers into account while making the scenes.\n\t\t\tFor the `player.tscn` root node, configure the layers and mask as follows:\n\t\t\t![Figure 9.33 – The collision layer and mask configuration for the player](img/B19358_09_33.jpg)\n\n\t\t\tFigure 9.33 – The collision layer and mask configuration for the player\n\t\t\tFor the `boulder.tscn` and `wall.tscn`, we want the following configuration:\n\t\t\t![Figure 9.34 – The collision layer and mask configuration for boulders and walls](img/B19358_09_34.jpg)\n\n\t\t\tFigure 9.34 – The collision layer and mask configuration for boulders and walls\n\t\t\tLastly, for the `collectible.tscn` scene, set the configuration as follows:\n\t\t\t![Figure 9.35 – The collision layer and mask configuration for collectibles](img/B19358_09_35.jpg)\n\n\t\t\tFigure 9.35 – The collision layer and mask configuration for collectibles\n\t\t\tYou can see that the player, boulders, and wall are in both the collision layer and collision mask. This is because they need to be able to interact with each other. On the other hand, the player is in the collectible layer and not the collectible mask, while the collectible scene does the opposite. We define the layer and mask for collectibles this way because the player doesn’t directly need to interact with collectibles and doesn’t need to detect them; the collectible scene does all the work for us.\n\t\t\tYour turn!\n\t\t\tGreat, we created our health potion! Now you can implement the coin so the player can collect gold. Here are some of the steps you could take:\n\n\t\t\t\t1.  Make a new inherited scene from the `collectible.tscn` scene as we saw in the *Inheriting from a base* *scene* section.\n\t\t\t\t2.  Extend the collectible script, as we did in the *Writing the collectible* *code* section.\n\t\t\t\t3.  Track the amount of gold the player owns using a variable.\n\t\t\t\t4.  Show how many coins the player owns on the screen using a label.\n\n\t\t\tI’ll leave a possible implementation of all this in the repository of the project.\n\t\t\tWe learned a lot in this section. We discovered what **Area2D** nodes are, and collision layers and masks are no longer a mystery but a useful tool for defining what bodies and areas we want to interact with. Let’s do some last exercises before summarizing and ending the chapter.\n\t\t\tAdditional exercises – Sharpening the axe\n\n\t\t\t\t1.  Oh no! We added collisions to the boulders and inner walls of the arena, but not to the outer walls. Add a **StaticBody2D** that stops the player from escaping the arena.\n\t\t\t\t2.  Create a base scene for the boulders, inherit two boulders from that, and make their shapes different. Also, make sure you update the collision shape so that the player collides correctly with them.\n\n\t\t\tSummary\n\t\t\tWe started this chapter learning all about the **Camera2D** node and making it smooth and usable for the player so that they don’t have to think about it while navigating around the playing field.\n\t\t\tAfter, we added colliders to the player and all solid objects within the game. We even used collision shapes to create little collectible items, such as a health potion.\n\t\t\tAlong the way, we saw what signals are and how we can connect them to functions in a node’s script.\n\t\t\tIn the next chapter, we’ll flesh out our game with enemies and menus so that we have a full game loop.\n\t\t\tQuiz time\n\n\t\t\t\t*   Why did we use a point in front of the player to position the camera?\n\t\t\t\t*   What does the last parameter of a `Vector2`’s `lerp` function represent? Here is an example:\n\n    ```", "```cpp\n\n    \t\t\t\t*   Why did we use a **CharacterBody2D** for the player character and not a **RigidBody2D**?\n\t\t\t\t*   What are **Area2D** nodes used for?\n\t\t\t\t*   We have two objects: an **Area2D** node and a **CharacterBody2D** node. We want to be able to detect the **CharacterBody2D** with the **Area2D** node. How do we need to configure their collision layers and masks?\n\t\t\t\t*   The **Area2D** and **CharacterBody2D** nodes should be in the same collision layer.\n\t\t\t\t*   The **Area2D** node should be in the same collision mask as the **CharacterBody2D** node’s collision layer.\n\t\t\t\t*   The **Area2D** and the **CharacterBody2D** nodes should be in the same collision mask.\n\t\t\t\t*   Signals notify us of certain actions that happen in a node. To what signal did we connect to detect if a player entered the **Area2D** node of a collectible?\n\n```"]