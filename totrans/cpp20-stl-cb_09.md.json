["```cpp\n    using namespace std::this_thread;\n    using namespace std::chrono_literals;\n    ```", "```cpp\n    int main() {\n        auto t1 = steady_clock::now();\n        cout << \"sleep for 1.3 seconds\\n\";\n        sleep_for(1s + 300ms);\n        cout << \"sleep for 2 seconds\\n\";\n        sleep_until(steady_clock::now() + 2s);\n        duration<double> dur1 = steady_clock::now() - t1;\n        cout << format(\"total duration: {:.5}s\\n\", \n          dur1.count());\n    }\n    ```", "```cpp\nsleep for 1.3 seconds\nsleep for 2 seconds\ntotal duration: 3.3005s\n```", "```cpp\nunsigned int sleep(unsigned int seconds);\n```", "```cpp\n    void sleepms(const unsigned ms) {\n        using std::chrono::milliseconds;\n        std::this_thread::sleep_for(milliseconds(ms));\n    }\n    ```", "```cpp\n    void fthread(const int n) {\n        cout << format(\"This is t{}\\n\", n);\n\n        for(size_t i{}; i < 5; ++i) {\n            sleepms(100 * n);\n            cout << format(\"t{}: {}\\n\", n, i + 1);\n        }\n        cout << format(\"Finishing t{}\\n\", n);\n    }\n    ```", "```cpp\n    int main() {\n        thread t1(fthread, 1);\n        cout << \"end of main()\\n\";\n    }\n    ```", "```cpp\nterminate called without an active exception\nAborted\n```", "```cpp\n    int main() {\n        thread t1(fthread, 1);\n        t1.join();\n        cout << \"end of main()\\n\";\n    }\n    ```", "```cpp\nThis is t1\nt1: 1\nt1: 2\nt1: 3\nt1: 4\nt1: 5\nFinishing t1\nend of main()\n```", "```cpp\n    thread t1(fthread, 1);\n    t1.detach();\n    ```", "```cpp\nend of main()\n```", "```cpp\n    thread t1(fthread, 1);\n    t1.detach();\n    cout << \"main() sleep 2 sec\\n\";\n    sleepms(2000);\n    ```", "```cpp\nmain() sleep 2 sec\nThis is t1\nt1: 1\nt1: 2\nt1: 3\nt1: 4\nt1: 5\nFinishing t1\nend of main()\n```", "```cpp\n    int main() {\n        thread t1(fthread, 1);\n        thread t2(fthread, 2);\n        t1.detach();\n        t2.detach();\n        cout << \"main() sleep 2 sec\\n\";\n        sleepms(2000);\n        cout << \"end of main()\\n\";\n    }\n    ```", "```cpp\nmain() sleep 2 sec\nThis is t1\nThis is t2\nt1: 1\nt2: 1\nt1: 2\nt1: 3\nt2: 2\nt1: 4\nt1: 5\nFinishing t1\nt2: 3\nt2: 4\nt2: 5\nFinishing t2\nend of main()\n```", "```cpp\n    int main() {\n        thread t1(fthread, 1);\n        thread t2(fthread, 2);\n        t1.join();\n        t2.join();\n        cout << \"end of main()\\n\";\n    }\n    ```", "```cpp\nThis is t1\nThis is t2\nt1: 1\nt2: 1\nt1: 2\nt1: 3\nt2: 2\nt1: 4\nt1: 5\nFinishing t1\nt2: 3\nt2: 4\nt2: 5\nFinishing t2\nend of main()\n```", "```cpp\nexplicit thread( Function&& f, Args&&… args );\n```", "```cpp\nthread t1(fthread, 1);\n```", "```cpp\nt1.join();\n```", "```cpp\nt1.detach();\n```", "```cpp\nint main() {\n    std::jthread t1(fthread, 1);\n    cout \"< \"end of main(\"\\n\";\n}\n```", "```cpp\nend of main()\nThis is t1\nt1: 1\nt1: 2\nt1: 3\nt1: 4\nt1: 5\nFinishing t1\n```", "```cpp\n    using launch = std::launch;\n    using secs = std::chrono::duration<double>;\n    ```", "```cpp\n    struct prime_time {\n        secs dur{};\n        uint64_t count{};\n    };\n    prime_time count_primes(const uint64_t& max) {\n        prime_time ret{};\n        constexpr auto isprime = [](const uint64_t& n) {\n            for(uint64_t i{ 2 }; i < n / 2; ++i) {\n                if(n % i == 0) return false;\n            }\n            return true;\n        };\n        uint64_t start{ 2 };\n        uint64_t end{ max };\n        auto t1 = steady_clock::now();\n        for(uint64_t i{ start }; i <= end ; ++i) {\n            if(isprime(i)) ++ret.count;\n        }\n        ret.dur = steady_clock::now() - t1;\n        return ret;\n    }\n    ```", "```cpp\n    int main() {\n        constexpr uint64_t MAX_PRIME{ 0x1FFFF };\n        auto pt = count_primes(MAX_PRIME);\n        cout << format(\"primes: {} {:.3}\\n\", pt.count, \n          pt.dur);\n    }\n    ```", "```cpp\nprimes: 12252 1.88008s\n```", "```cpp\n    int main() {\n        constexpr uint64_t MAX_PRIME{ 0x1FFFF };\n        auto primes1 = async(count_primes, MAX_PRIME);\n        auto pt = primes1.get();\n        cout << format(\"primes: {} {:.3}\\n\", pt.count, \n          pt.dur);\n    }\n    ```", "```cpp\nprimes: 12252 1.97245s\n```", "```cpp\n    auto primes1 = async(launch::async, count_primes, MAX_PRIME);\n    ```", "```cpp\n    int main() {\n        constexpr uint64_t MAX_PRIME{ 0x1FFFF };\n        list<std::future<prime_time>> swarm;\n        cout << \"start parallel primes\\n\";\n        auto t1{ steady_clock::now() };\n        for(size_t i{}; i < 15; ++i) {\n            swarm.emplace_back(\n                async(launch::async, count_primes, \n                  MAX_PRIME)\n            );\n        }\n        for(auto& f : swarm) {\n            static size_t i{};\n            auto pt = f.get();\n            cout << format(\"primes({:02}): {} {:.5}\\n\",\n                ++i, pt.count, pt.dur);\n        }\n        secs dur_total{ steady_clock::now() - t1 };\n        cout << format(\"total duration: {:.5}s\\n\", \n            dur_total.count());\n    }\n    ```", "```cpp\nstart parallel primes\nprimes(01): 12252 4.1696s\nprimes(02): 12252 3.7754s\nprimes(03): 12252 3.78089s\nprimes(04): 12252 3.72149s\nprimes(05): 12252 3.72006s\nprimes(06): 12252 4.1306s\nprimes(07): 12252 4.26015s\nprimes(08): 12252 3.77283s\nprimes(09): 12252 3.77176s\nprimes(10): 12252 3.72038s\nprimes(11): 12252 3.72416s\nprimes(12): 12252 4.18738s\nprimes(13): 12252 4.07128s\nprimes(14): 12252 2.1967s\nprimes(15): 12252 2.22414s\ntotal duration: 5.9461s\n```", "```cpp\nstart parallel primes\nprimes(01): 12252 0.96221s\nprimes(02): 12252 0.97346s\nprimes(03): 12252 0.92189s\nprimes(04): 12252 0.97499s\nprimes(05): 12252 0.98135s\nprimes(06): 12252 0.93426s\nprimes(07): 12252 0.90294s\nprimes(08): 12252 0.96307s\nprimes(09): 12252 0.95015s\nprimes(10): 12252 0.94255s\nprimes(11): 12252 0.94971s\nprimes(12): 12252 0.95639s\nprimes(13): 12252 0.95938s\nprimes(14): 12252 0.92115s\nprimes(15): 12252 0.94122s\ntotal duration: 0.98166s\n```", "```cpp\nvoid f() {\n    cout << \"this is f()\\n\";\n}\n```", "```cpp\nint main() {\n    std::thread t1(f);\n    t1.join();\n    cout << \"end of main()\\n\";\n}\n```", "```cpp\nint main() {\n    std::promise<int> value_promise;\n    std::future<int> value_future = \n      value_promise.get_future();\n    std::thread t1(f, std::move(value_promise));\n    t1.detach();\n    cout << format(\"value is {}\\n\", value_future.get());\n    cout << \"end of main()\\n\";\n}\n```", "```cpp\nvoid f(std::promise<int> value) {\n    cout << \"this is f()\\n\";\n    value.set_value(47);\n}\n```", "```cpp\nint f() {\n    cout << \"this is f()\\n\";\n    return 47;\n}\nint main() {\n    auto value_future = std::async(f);\n    cout << format(\"value is {}\\n\", value_future.get());\n    cout << \"end of main()\\n\";\n}\n```", "```cpp\n    using dur_t = duration<double, std::milli>;\n    ```", "```cpp\n    int main() {\n        std::vector<unsigned> v(10 * 1000 * 1000);\n        std::random_device rng;\n        for(auto &i : v) i = rng() % 0xFFFF;\n        ...\n    ```", "```cpp\n    auto mul2 = [](int n){ return n * 2; };\n    auto t1 = steady_clock::now();\n    std::transform(v.begin(), v.end(), v.begin(), mul2);\n    dur_t dur1 = steady_clock::now() - t1;\n    cout << format(\"no policy: {:.3}ms\\n\", dur1.count());\n    ```", "```cpp\nno policy: 4.71ms\n```", "```cpp\n    std::transform(execution::seq,\n        v.begin(), v.end(), v.begin(), mul2);\n    ```", "```cpp\nexecution::seq: 4.91ms\n```", "```cpp\n    std::transform(execution::par,\n        v.begin(), v.end(), v.begin(), mul2);\n    ```", "```cpp\nexecution::par: 3.22ms\n```", "```cpp\n    std::transform(execution::par_unseq,\n        v.begin(), v.end(), v.begin(), mul2);\n    ```", "```cpp\nexecution::par_unseq: 2.93ms\n```", "```cpp\nauto t0 = steady_clock::now();\nstd::sort(v.begin(), v.end());\ndur_t dur0 = steady_clock::now() - t0;\ncout << format(\"sort: {:.3}ms\\n\", dur0.count());\n```", "```cpp\nsort: 751ms\n```", "```cpp\nstd::sort(execution::par, v.begin(), v.end());\n```", "```cpp\nsort: 163ms\n```", "```cpp\nstd::sort(execution::par_unseq, v.begin(), v.end());\n```", "```cpp\nsort: 152ms\n```", "```cpp\n    std::mutex animal_mutex;\n    ```", "```cpp\n    class Animal {\n        using friend_t = list<Animal>;\n        string_view s_name{ \"unk\" };\n        friend_t l_friends{};\n    public:\n        Animal() = delete;\n        Animal(const string_view n) : s_name{n} {}\n        ...\n    }\n    ```", "```cpp\n    bool operator==(const Animal& o) const {\n        return s_name.data() == o.s_name.data();\n    }\n    ```", "```cpp\n    bool is_friend(const Animal& o) const {\n        for(const auto& a : l_friends) {\n            if(a == o) return true;\n        }\n        return false;\n    }\n    ```", "```cpp\n    optional<friend_t::iterator>\n    find_friend(const Animal& o) noexcept {\n        for(auto it{l_friends.begin()};\n                it != l_friends.end(); ++it) {\n            if(*it == o) return it;\n        }\n        return {};\n    }\n    ```", "```cpp\n    void print() const noexcept {\n        auto n_animals{ l_friends.size() };\n        cout << format(\"Animal: {}, friends: \", s_name);\n        if(!n_animals) cout << \"none\";\n        else {\n            for(auto n : l_friends) {\n                cout << n.s_name;\n                if(--n_animals) cout << \", \";\n            }\n        }\n        cout << '\\n';\n    }\n    ```", "```cpp\n    bool add_friend(Animal& o) noexcept {\n        cout << format(\"add_friend {} -> {}\\n\", s_name, \n          o.s_name);\n        if(*this == o) return false;\n        std::lock_guard<std::mutex> l(animal_mutex);\n        if(!is_friend(o)) l_friends.emplace_back(o);\n        if(!o.is_friend(*this))\n          o.l_friends.emplace_back(*this);\n        return true;\n    }\n    ```", "```cpp\n    bool delete_friend(Animal& o) noexcept {\n        cout << format(\"delete_friend {} -> {}\\n\",\n            s_name, o.s_name);\n        if(*this == o) return false;\n        if(auto it = find_friend(o)) \n          l_friends.erase(it.value());\n        if(auto it = o.find_friend(*this))\n            o.l_friends.erase(it.value());\n        return true;\n    }\n    ```", "```cpp\n    int main() {\n        auto cat1 = std::make_unique<Animal>(\"Felix\");\n        auto tiger1 = std::make_unique<Animal>(\"Hobbes\");\n        auto dog1 = std::make_unique<Animal>(\"Astro\");\n        auto rabbit1 = std::make_unique<Animal>(\"Bugs\");\n        ...\n    ```", "```cpp\n    auto a1 = std::async([&]{ cat1->add_friend(*tiger1); });\n    auto a2 = std::async([&]{ cat1->add_friend(*rabbit1); });\n    auto a3 = std::async([&]{ rabbit1->add_friend(*dog1); });\n    auto a4 = std::async([&]{ rabbit1->add_friend(*cat1); });\n    a1.wait();\n    a2.wait();\n    a3.wait();\n    a4.wait();\n    ```", "```cpp\n    auto p1 = std::async([&]{ cat1->print(); });\n    auto p2 = std::async([&]{ tiger1->print(); });\n    auto p3 = std::async([&]{ dog1->print(); });\n    auto p4 = std::async([&]{ rabbit1->print(); });\n    p1.wait();\n    p2.wait();\n    p3.wait();\n    p4.wait();\n    ```", "```cpp\n    auto a5 = std::async([&]{ cat1->delete_friend(*rabbit1); });\n    a5.wait();\n    auto p5 = std::async([&]{ cat1->print(); });\n    auto p6 = std::async([&]{ rabbit1->print(); });\n    ```", "```cpp\n    add_friend Bugs -> Felix\n    add_friend Felix -> Hobbes\n    add_friend Felix -> Bugs\n    add_friend Bugs -> Astro\n    Animal: Felix, friends: Bugs, Hobbes\n    Animal: Hobbes, friends: Animal: Bugs, friends: FelixAnimal: Astro, friends: Felix\n    , Astro\n    Bugs\n    delete_friend Felix -> Bugs\n    Animal: Felix, friends: Hobbes\n    Animal: Bugs, friends: Astro\n    ```", "```cpp\n    bool add_friend(Animal& o) noexcept {\n        cout << format(\"add_friend {} -> {}\\n\", s_name, o.s_name);\n        if(*this == o) return false;\n        animal_mutex.lock();\n        if(!is_friend(o)) l_friends.emplace_back(o);\n        if(!o.is_friend(*this)) o.l_friends.emplace_back(*this);\n        animal_mutex.unlock();\n        return true;\n    }\n    ```", "```cpp\n    bool delete_friend(Animal& o) noexcept {\n        cout << format(\"delete_friend {} -> {}\\n\",\n            s_name, o.s_name);\n        if(*this == o) return false;\n        animal_mutex.lock();\n        if(auto it = find_friend(o)) \n          l_friends.erase(it.value());\n        if(auto it = o.find_friend(*this))\n            o.l_friends.erase(it.value());\n        animal_mutex.unlock();\n        return true;\n    }\n    ```", "```cpp\n    void print() const noexcept {\n        animal_mutex.lock();\n        auto n_animals{ l_friends.size() };\n        cout << format(\"Animal: {}, friends: \", s_name);\n        if(!n_animals) cout << \"none\";\n        else {\n            for(auto n : l_friends) {\n                cout << n.s_name;\n                if(--n_animals) cout << \", \";\n            }\n        }\n        cout << '\\n';\n        animal_mutex.unlock();\n    }\n    ```", "```cpp\nadd_friend Bugs -> Felix\nadd_friend Bugs -> Astro\nadd_friend Felix -> Hobbes\nadd_friend Felix -> Bugs\nAnimal: Felix, friends: Bugs, Hobbes\nAnimal: Hobbes, friends: Felix\nAnimal: Astro, friends: Bugs\nAnimal: Bugs, friends: Felix, Astro\ndelete_friend Felix -> Bugs\nAnimal: Felix, friends: Hobbes\nAnimal: Bugs, friends: Astro\n```", "```cpp\n    bool add_friend(Animal& o) noexcept {\n        cout << format(\"add_friend {} -> {}\\n\", s_name, o.s_name);\n        if(*this == o) return false;\n        std::lock_guard<std::mutex> l(animal_mutex);\n        if(!is_friend(o)) l_friends.emplace_back(o);\n        if(!o.is_friend(*this)) \n          o.l_friends.emplace_back(*this);\n        return true;\n    }\n    ```", "```cpp\nbool delete_friend(Animal& o) noexcept {\n    cout << format(\"delete_friend {} -> {}\\n\",\n        s_name, o.s_name);\n    if(*this == o) return false;\n    std::lock_guard<std::mutex> l(animal_mutex);\n    if(auto it = find_friend(o)) \n      l_friends.erase(it.value());\n    if(auto it = o.find_friend(*this))\n        o.l_friends.erase(it.value());\n    return true;\n}\n```", "```cpp\nvoid print() const noexcept {\n    std::lock_guard<std::mutex> l(animal_mutex);\n    auto n_animals{ l_friends.size() };\n    cout << format(\"Animal: {}, friends: \", s_name);\n    if(!n_animals) cout << \"none\";\n    else {\n        for(auto n : l_friends) {\n            cout << n.s_name;\n            if(--n_animals) cout << \", \";\n        }\n    }\n    cout << '\\n';\n}\n```", "```cpp\nadd_friend Felix -> Hobbes\nadd_friend Bugs -> Astro\nadd_friend Felix -> Bugs\nadd_friend Bugs -> Felix\nAnimal: Felix, friends: Bugs, Hobbes\nAnimal: Astro, friends: Bugs\nAnimal: Hobbes, friends: Felix\nAnimal: Bugs, friends: Astro, Felix\ndelete_friend Felix -> Bugs\nAnimal: Felix, friends: Hobbes\nAnimal: Bugs, friends: Astro\n```", "```cpp\n    std::atomic<bool> ready{};\n    std::atomic<uint64_t> g_count{};\n    std::atomic_flag winner{};\n    ```", "```cpp\n    constexpr int max_count{1000 * 1000};\n    constexpr int max_threads{100};\n    ```", "```cpp\n    void countem (int id) {\n        while(!ready) std::this_thread::yield();\n        for(int i{}; i < max_count; ++i) ++g_count;\n        if(!winner.test_and_set()) {\n            std::cout << format(\"thread {:02} won!\\n\", \n              id);\n        }\n    };\n    ```", "```cpp\n    string make_commas(const uint64_t& num) {\n        string s{ std::to_string(num) };\n        for(long l = s.length() - 3; l > 0; l -= 3) {\n            s.insert(l, \",\");\n        }\n        return s;\n    }\n    ```", "```cpp\n    int main() {\n        vector<std::thread> swarm;\n        cout << format(\"spawn {} threads\\n\", max_threads);\n        for(int i{}; i < max_threads; ++i) {\n            swarm.emplace_back(countem, i);\n        }\n        ready = true;\n        for(auto& t : swarm) t.join();\n        cout << format(\"global count: {}\\n\",\n            make_commas(g_count));\n        return 0;\n    }\n    ```", "```cpp\nspawn 100 threads\nthread 67 won!\nglobal count: 100,000,000\n```", "```cpp\nstruct Trivial {\n    int a;\n    int b;\n};\nstd::atomic<Trivial> triv1;\n```", "```cpp\nstd::atomic<bool> ready{};\nstd::atomic<uint64_t> g_count{};\n```", "```cpp\nstd::atomic_bool ready{};\nstd::atomic_uint64_t g_count{};\n```", "```cpp\ncout << format(\"is g_count lock-free? {}\\n\", \n    g_count.is_lock_free());\n```", "```cpp\nis g_count lock-free? true\n```", "```cpp\ng_count.fetch_add(1, std::memory_order_seq_cst);\n```", "```cpp\n    constexpr size_t max_threads{ 25 };\n    ```", "```cpp\nstd::once_flag init_flag;\n```", "```cpp\n    void do_init(size_t id) {\n        cout << format(\"do_init ({}): \", id);\n    }\n    ```", "```cpp\n    void do_print(size_t id) {\n        std::call_once(init_flag, do_init, id);\n        cout << format(\"{} \", id);\n    }\n    ```", "```cpp\n    int main() {\n        list<thread> spawn;\n        for (size_t id{}; id < max_threads; ++id) {\n            spawn.emplace_back(do_print, id);\n        }\n        for (auto& t : spawn) t.join();\n        cout << '\\n';\n    }\n    ```", "```cpp\ndo_init (8): 12 0 2 1 9 6 13 10 11 5 16 3 4 17 7 15 8 14 18 19 20 21 22 23 24 \n```", "```cpp\ntemplate<class Callable, class... Args>\nvoid call_once(once_flag& flag, Callable&& f, Args&&... args);\n```", "```cpp\n    using namespace std::chrono_literals;\n    namespace this_thread = std::this_thread;\n    using guard_t = std::lock_guard<std::mutex>;\n    using lock_t = std::unique_lock<std::mutex>;\n    ```", "```cpp\n    constexpr size_t num_items{ 10 };\n    constexpr auto delay_time{ 200ms };\n    ```", "```cpp\n    std::deque<size_t> q{};\n    std::mutex mtx{};\n    std::condition_variable cond{};\n    bool finished{};\n    ```", "```cpp\n    void producer() {\n        for(size_t i{}; i < num_items; ++i) {\n            this_thread::sleep_for(delay_time);\n            guard_t x{ mtx };\n            q.push_back(i);\n            cond.notify_all();\n        }\n        guard_t x{ mtx };\n        finished = true;\n        cond.notify_all();\n    }\n    ```", "```cpp\n    void consumer() {\n        while(!finished) {\n            lock_t lck{ mtx };\n            cond.wait(lck, [] { return !q.empty() || \n              finished; });\n            while(!q.empty()) {\n                cout << format(\"Got {} from the queue\\n\",\n                    q.front());\n                q.pop_front();\n            }\n        }\n    }\n    ```", "```cpp\n    int main() {\n        thread t1{ producer };\n        thread t2{ consumer };\n        t1.join();\n        t2.join();\n        cout << \"finished!\\n\";\n    }\n    ```", "```cpp\nGot 0 from the queue\nGot 1 from the queue\nGot 2 from the queue\nGot 3 from the queue\nGot 4 from the queue\nGot 5 from the queue\nGot 6 from the queue\nGot 7 from the queue\nGot 8 from the queue\nGot 9 from the queue\nfinished!\n```", "```cpp\nstd::deque<size_t> q{};\n```", "```cpp\nstd::lock_guard x{ mtx };\nq.push_back(i);\ncond.notify_all();\n```", "```cpp\nvoid wait( std::unique_lock<std::mutex>& lock );\nvoid wait( std::unique_lock<std::mutex>& lock,\n    Pred stop_waiting );\n```", "```cpp\nwhile (!stop_waiting()) {\n    wait(lock);\n}\n```", "```cpp\ncond.wait(lck, []{ return !q.empty() || finished; });\n```", "```cpp\n    constexpr auto delay_time is a duration object, used with sleep_for().\n    ```", "```cpp\n    deque<string> qs is a deque of string that holds the produced objects.\n    ```", "```cpp\n    void producer(const size_t id) {\n        for(size_t i{}; i < num_items; ++i) {\n            this_thread::sleep_for(delay_time * id);\n            unique_lock<mutex> lock(q_mutex);\n            cv_producer.wait(lock,\n                [&]{ return qs.size() < queue_limit; });\n            qs.push_back(format(\"pid {}, qs {}, \n              item {:02}\\n\", id, qs.size(), i + 1));\n            cv_consumer.notify_all();\n        }\n    }\n    ```", "```cpp\n    void consumer(const size_t id) {\n        while(!production_complete) {\n            unique_lock<mutex> lock(q_mutex);\n            cv_consumer.wait_for(lock, consumer_wait,\n                [&]{ return !qs.empty(); });\n            if(!qs.empty()){\n                cout << format(\"cid {}: {}\", id, \n                  qs.front());\n                qs.pop_front();\n            }\n            cv_producer.notify_all();\n        }\n    }\n    ```", "```cpp\n    int main() {\n        list<future<void>> producers;\n        list<future<void>> consumers;\n        for(size_t i{}; i < num_producers; ++i) {\n            producers.emplace_back(async(producer, i));\n        }\n        for(size_t i{}; i < num_consumers; ++i) {\n            consumers.emplace_back(async(consumer, i));\n        }\n        ...\n    ```", "```cpp\n    for(auto& f : producers) f.wait();\n    production_complete = true;\n    cout << \"producers done.\\n\";\n    for(auto& f : consumers) f.wait();\n    cout << \"consumers done.\\n\";\n    ```", "```cpp\n    cid 0: pid 0, qs  0, item 01\n    cid 0: pid 0, qs  1, item 02\n    cid 0: pid 0, qs  2, item 03\n    cid 0: pid 0, qs  3, item 04\n    cid 0: pid 0, qs  4, item 05\n    ...\n    cid 4: pid 2, qs  0, item 12\n    cid 4: pid 2, qs  0, item 13\n    cid 3: pid 2, qs  0, item 14\n    cid 0: pid 2, qs  0, item 15\n    producers done.\n    consumers done.\n    ```", "```cpp\ncondition_variable cv_producer{};\ncondition_variable cv_consumer{};\n```", "```cpp\nvoid producer(const size_t id) {\n    for(size_t i{}; i < num_items; ++i) {\n        this_thread::sleep_for(delay_time * id);\n        unique_lock<mutex> lock(q_mutex);\n        cv_producer.wait(lock,\n            [&]{ return qs.size() < queue_limit; });\n        qs.push_back(format(\"pid {}, qs  {}, item {:02}\\n\",\n            id, qs.size(), i + 1));\n        cv_consumer.notify_all();\n    }\n}\n```", "```cpp\nvoid consumer(const size_t id) {\n    while(!production_complete) {\n        unique_lock<mutex> lock(q_mutex);\n        cv_consumer.wait_for(lock, consumer_wait,\n            [&]{ return !qs.empty(); });\n        if(!qs.empty()) {\n            cout << format(\"cid {}: {}\", id, qs.front());\n            qs.pop_front();\n        }\n        cv_producer.notify_all();\n    }\n}\n```"]