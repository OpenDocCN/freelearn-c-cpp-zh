- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project #6 – Making Your Home Smarter with a Voice Assistant'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to smart homes. **Smart homes** is a wide field that
    aims to automate everything in your home to make your life experience better and
    more comfortable, for example, smart light systems, smart air conditioning, smart
    TVs, and so on. But in this chapter, we will explore how we can build a multi-color
    smart bulb that is controlled by the **Arduino IoT Cloud** web and mobile dashboard.
    We’ll also add the Amazon Alexa voice assistant to control the smart bulb using
    voice commands.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will practically explore smart homes, picking up the **WS2812 RGB LED**
    ring and Seeed Studio’s newest, and very small, development board in the XIAO
    series, which is based on ESP32 with a lot of features. With the help of the light
    module, development board, and the Arduino IoT Cloud, we will build a smart light
    system.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have the confidence to build smart home
    solutions with the help of any open source ESP32/ESP8266 or Arduino series development
    board using the Arduino IoT Cloud. In particular, you will learn how easy it is
    to integrate Amazon Alexa Voice assistant into your smart home projects to make
    them more convenient for end users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating smarter homes with IoT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essential components – sensors and development boards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blueprint for your smart home IoT project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial setup – Thing, network credentials, cloud variables, and code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-friendly controls – building web and mobile dashboards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing controls – integrating the Arduino IoT Cloud with Amazon Alexa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following hardware components are required to complete this chapter’s exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Seeed Studio XIAO ESP32C3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USB type-C cable for XIAO ESP32C3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WS2812 RGB LED ring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Male headers, female headers, and a veroboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper cables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soldering iron
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon Echo Dot and the Amazon Alexa mobile app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For coding, we will use the **Arduino Web Editor**, which includes a large collection
    of development boards and sensor libraries, and the Arduino IoT Cloud for the
    Thing and dashboard setup. To develop hardware and sensor designs, we need the
    **Fritzing** desktop software and the **Arduino IDE** for testing the WS2812 ring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will use the **Amazon Echo Dot** as a voice assistant for voice commands
    to control the smart bulb. If you don’t have an Echo Dot, then you can use the
    **Amazon Alexa** app for Android/iOS. The chapter’s code is available in the official
    GitHub repository for the book by following this link: [https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers](https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating smarter homes with IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Internet of Things** (**IoT**) technology plays a crucial role in the development
    of smart homes. It enables various devices and appliances within a home to connect,
    communicate, and automate tasks for the convenience, comfort, and efficiency of
    homeowners. Here are some key aspects of IoT for smart homes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connectivity**: IoT devices in a smart home are connected to the internet,
    allowing them to communicate with each other, as well as with the homeowner, remotely.
    This connectivity facilitates the control, monitoring, and automation of devices
    from anywhere, using smartphones, tablets, or computers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Home automation**: IoT enables the automation of various tasks within a smart
    home. For example, lights can automatically turn on or off based on occupancy
    or the time of day. Thermostats can adjust temperature settings based on the homeowner’s
    preferences or presence in the house. IoT-powered automation helps optimize energy
    usage, enhance security, and simplify routine activities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and surveillance**: IoT devices can enhance the security of a smart
    home. Smart locks provide keyless entry and allow remote access control. Video
    doorbells enable homeowners to see and communicate with visitors remotely. Surveillance
    cameras can be accessed and monitored from anywhere, providing an additional layer
    of security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Energy management**: IoT devices help optimize energy consumption within
    a smart home. Smart thermostats learn user preferences and adjust temperature
    settings accordingly, conserving energy when rooms are unoccupied. Smart plugs
    and power strips can monitor and control the energy usage of appliances and electronics,
    helping identify energy-hungry devices and promoting efficient usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Voice control**: Voice assistants, such as Amazon Alexa or **Google Assistant**,
    integrated with IoT devices enable hands-free control of various functions in
    a smart home. Homeowners can use voice commands to control lights, adjust thermostats,
    play music, check the weather, and perform other tasks, enhancing convenience
    and accessibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health and wellness**: IoT devices can contribute to health and wellness
    within a smart home. Wearable devices, such as fitness trackers or smartwatches,
    can integrate with other home devices, such as smart scales or health monitors,
    to provide comprehensive health data and insights. This data can be shared with
    healthcare professionals or used to automate certain health-related tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Appliance control**: IoT enables the remote control and monitoring of various
    appliances in a smart home. Refrigerators, ovens, washing machines, and other
    appliances can be connected to the internet, allowing homeowners to check their
    status, receive alerts, or control their operation remotely. This connectivity
    adds convenience and flexibility to household chores and management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration and interoperability**: A crucial aspect of IoT for smart homes
    is the integration and interoperability of devices from different manufacturers.
    Standards and protocols, such as **Zigbee** or **Z-Wave**, facilitate the seamless
    connection and communication between devices, ensuring that different IoT products
    can work together in a unified ecosystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to note that while IoT technology brings numerous benefits to
    smart homes, it also introduces potential security and privacy risks. Homeowners
    should take measures to secure their IoT devices, such as using strong passwords,
    keeping firmware up to date, and ensuring proper network security configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have discussed in detail how IoT is reshaping the lives of human beings
    in homes and offices. Next, we are going to talk about the hardware and components
    that we require to carry on with this chapter’s project.
  prefs: []
  type: TYPE_NORMAL
- en: Essential components – sensors and development boards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the ESP32 series, we have a wide collection of development boards, which
    vary in size and pins. In this chapter, we are using Seeed Studio’s latest development
    board, the **XIAO ESP32C3**, as it’s very compact and smaller in size than other
    boards, and of course, cheaper and is suitable for 5V as well as 3.3V. The following
    figure is the pin layout diagram of XIAO ESP32C3.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – XIAO ESP32C pinout diagram](img/B19752_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – XIAO ESP32C pinout diagram
  prefs: []
  type: TYPE_NORMAL
- en: XIAO ESP32C provides multiple pins for digital input/output. In the previous
    ESP series board, we found only one analog pin, but on this development board,
    we have four analog pins, which removes the biggest hurdle while developing a
    solution that uses multiple analog pins. With previous ESP series boards, we used
    ADS1115/ADS1015 for extra analog pins, so this development board will save us
    some bucks as we will get four analog pins by default on the development board.
  prefs: []
  type: TYPE_NORMAL
- en: Besides all those features, XIAO provides a built-in battery charge module and
    the board is optimized for power consumption, which helps to use this board as
    a wearable device. For connectivity, there are both Wi-Fi and Bluetooth options
    available. It also supports **Bluetooth Low Energy** (**BLE 5**), which is more
    specific to IoT use cases. For further details, please visit [https://wiki.seeedstudio.com/XIAO_ESP32C3_Getting_Started/](https://wiki.seeedstudio.com/XIAO_ESP32C3_Getting_Started/).
  prefs: []
  type: TYPE_NORMAL
- en: In the current project, we need one digital pin for the WS2812 RGB LED ring.
    One of the good features of the development board is that we have a 5V power pin,
    which is not available on most of the ESP32 series development boards.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the WS2812 16-pixel RGB ring but it comes in different pixels and
    shapes, such as a stick, matrix, and strip. For the lamp, we prefer the ring shape,
    but you guys can choose according to your preferences. WS2812 also comes in long
    strip cables for room decoration and computer tables – especially for gamers,
    hotels, and so on. There are different vendors who provide the WS2812 module,
    but we are using a WS2812 that we purchased from AliExpress and it’s working perfectly.
    You can buy it from Amazon, AdaFruit, SparkFun, or from AliExpress.
  prefs: []
  type: TYPE_NORMAL
- en: WS2812 comes with RGB color, and it also allows you to control the brightness
    of the module, which varies from 1–100%. It also allows you to control every single
    pixel of the LED – either on/off, or any color, which provides a broad range of
    use cases to develop interesting solutions and prototypes. The WS2812 RGB LED
    comes in different sizes and shapes. The following figure shows the RGB LED ring
    with both the front and back sides.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – WS2812 RGB LED ring and pinout diagram](img/B19752_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – WS2812 RGB LED ring and pinout diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram depicts the pinout layout of the WS2812 RGB ring. The
    complete configuration of the pin connections of WS2812 with XIAO ESP32C3 is shown
    in *Table 10.1*. *Pin #1* is a GND pin that connects with the onboard GND pin
    of XIAO ESP32C3\. *Pin #2* is a Power 5V DC pin that works with both 3.3V and
    5V. *Pin #3* is **Data Input**, which connects with any digital pin. *Pin #4*
    is **Data Out**, which is only used if you want to extend the WS2812 ring with
    another ring or stick – this pin will connect to the other ring’s data input pin
    as an extension. Here, I am connecting **Data Input** with *Pin #D3* of the board.
    You can solder the male headers with WS2812 or directly solder the cables without
    any header pins.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The WS2812 module works perfectly, but still it’s necessary to verify that all
    pixels of the ring/strip are working perfectly. In my case, my last pixel is not
    working.
  prefs: []
  type: TYPE_NORMAL
- en: In the current section, we have discussed the XIAO ESP32C3 and WS2812 RGH LED
    ring, as well as its pins. Next, we are going to discuss the project architecture
    in detail, which includes the project schematics and assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint for your smart home IoT project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding sections, we discussed the sensors and development board in
    detail. Now, it’s time to cook the recipe. In hardware development, before starting
    to work with sensors and development boards, we need to develop the design concepts
    to get a better understanding of how things will be connected. There is a lot
    of software available to design and develop design concepts regarding electronics
    projects, but we are going to use Fritzing.
  prefs: []
  type: TYPE_NORMAL
- en: In the following two subsections, first, we will talk about the schematics and
    design of a project and explain how to connect the pins of the development board
    with soldering. Next, we will do some testing of the WS2812 to check all the colors
    and pixels are working.
  prefs: []
  type: TYPE_NORMAL
- en: Schematic design and assembly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of the design is to clearly understand how sensors will connect
    with the development board. It helps engineers to develop a prototype on a breadboard
    or on a veroboard by using these design files. Another major benefit of designing
    is that Fritzing builds hardware schematics and a **Printed Circuit Board** (**PCB**)
    design in the background according to your design, which could be adjusted by
    designers according to system requirements. The complete connection diagram of
    the XIAO ESP32C3 and WS2812 RGB LED ring is shown in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – XIAO ESP32C and WS2812 system design](img/B19752_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – XIAO ESP32C and WS2812 system design
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.3* illustrates the pin diagram of the whole setup, but for easy
    guidance, we also created *Table 10.1*, which explains, in a simple way, how to
    connect the pins of WS2812 to XIAO ESP32C.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **XIAO ESP32C** | **WS2812 Ring** |'
  prefs: []
  type: TYPE_TB
- en: '| A3 | Data Input |'
  prefs: []
  type: TYPE_TB
- en: '| 5V | Power 5V DC |'
  prefs: []
  type: TYPE_TB
- en: '| GND | Power Signal Ground |'
  prefs: []
  type: TYPE_TB
- en: Table 10.1 – XIAO ESP32C and WS2812 connection
  prefs: []
  type: TYPE_NORMAL
- en: The preceding design and table provide a full overview of how you can connect
    the sensors to the development board. According to the design, we have common
    5V and GND pins from the XIAO ESP32C3 board to the WS2812 module. WS2812 is a
    digital module so we connected its **Data Input** pin to the D3 pin of the development
    board. The following figure shows the final prototype of the smart bulb on the
    veroboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Final prototype](img/B19752_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Final prototype
  prefs: []
  type: TYPE_NORMAL
- en: After soldering cables to the module and the male header to the XIAO ESP32C3,
    connect the pins according to the schematic diagram. There is only one module,
    so there is no requirement for a veroboard. But I am developing a proper prototype
    this time – that’s why I used a Veroboard. Now it’s time to verify the colors
    and pixels of the WS2812 using ESP32C3.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the WS2812 with the Arduino IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install the ESP32 series development board in the Arduino IDE, first, add
    the board’s definition file in the preferences. To proceed further, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **File** > **Preferences** and fill **Additional Boards Manager
    URLs** with the URL [https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_dev_index.json](https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_dev_index.json),
    as shown in the following figure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.5 – ESP32 board information in the Arduino IDE](img/B19752_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – ESP32 board information in the Arduino IDE
  prefs: []
  type: TYPE_NORMAL
- en: Later on, navigate to `esp32` in the search box, select the latest version of
    **esp32**, and install it, as shown in the following figure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.6 – ESP32 series board installation in the Arduino IDE](img/B19752_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – ESP32 series board installation in the Arduino IDE
  prefs: []
  type: TYPE_NORMAL
- en: Finally, select the board, navigate to **Tools** > **Board** > **ESP32 Arduino**,
    and select **XIAO_ESP32C3**. The list of boards is a little long and you need
    to scroll to the bottom, as shown in the following figure.![](img/B19752_10_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 10.7 – XIAO ESP32C3 board selection in the Arduino IDE
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to install the WS2812 library. Navigate to `Adafruit neopixel` in
    the search bar. Here, you will get different libraries, but you need to install
    the specific library that matches the search query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to proceed with the testing steps. Download the code from
    the official GitHub repository for the book, navigate to the `WS2812_Testing`
    folder, and open up the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `LED_PIN` constant to `D3` or `D5`. Next, assign the number of pixels
    to the `LED_COUNT` constant. Right now, I have 16 pixels in the WS2812 – that’s
    why I am inserting `16`. After making modifications, upload the code to the board.
    Later, you will see the color white on the LED and a moving animation in a circular
    form. In the `setup()` method, we initialized `NeoPixel strip` and set the brightness
    to 50%:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Later, in the `loop()` method, there are two loops. The first loop is used to
    assign the white color to each pixel and turn on the pixel according to the loop
    value, with a delay of 200 milliseconds, while in the second loop, we turn off
    all the pixels one by one by changing the brightness to `0` and RGB colors to
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have assembled the hardware component on the veroboard and
    used the code to verify that the WS2812 RGB LED is working. Next, we will set
    up the Thing and cloud variables in the Arduino IoT Cloud to make our prototype
    live.
  prefs: []
  type: TYPE_NORMAL
- en: Initial setup – Thing, network credentials, cloud variables, and code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After setting up the hardware, it’s time to set up Thing in the Arduino IoT
    Cloud. For this project, we need one cloud variable to control the LED brightness
    and color, and turn on/off the WS2812 ring, but I am using three different cloud
    variables so you will get an idea of when and why we need to use these cloud variables,
    and every variable connects with a specific widget. The network settings will
    be different from Arduino development boards due to using ESP series board.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Air quality monitoring system Thing setup](img/B19752_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Air quality monitoring system Thing setup
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up a new `Voice Controlled Smart Lamp` and follow these steps to create
    variables, associate a device and network configuration, and finally, write the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we need to set up three cloud variables for the WS2812\. Complete details
    regarding cloud variables are available in the following section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we need to associate the device with the Thing. In the current project,
    we are using the XIAO ESP32C3, so the wizard will be different than for Arduino
    boards. The complete details are available in the *Associating a* *device* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to set up the network configuration for the device, but this
    time we need to provide a security key for ESP series boards to make the connection
    secure. Arduino-compatible boards are configured by the Arduino IoT Cloud automatically
    during the device setup wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cloud variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following table provides all the properties of the variables that we need
    to use during cloud variable creation. For the WS2812, we can use the integer
    and bool data types, which creates a lot of mess, but thanks to the Arduino IoT
    Cloud’s extended group of variables, we have the **Dimmed light**, **Color**,
    and **Colored Light** type variables. Next, make sure the same variables are declared
    as shown in *Table 10.2*, otherwise, you’ll need to modify the example code according
    to your naming.
  prefs: []
  type: TYPE_NORMAL
- en: Here, I made the permission read and write, as this time we will send commands
    from the cloud dashboard or voice assistant, so it’s mandatory to give cloud variables
    permission to read and write.
  prefs: []
  type: TYPE_NORMAL
- en: '| **S#** | **Variable Name** | **Variable Type** | **Declaration** | **Permission**
    | **Update** **Policy** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `LightBrightness` | Dimmed light | `lightBrightness` | Read and write
    | On change |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `RGBLightColor` | Color | `rGBLightColor` | Read and write | On change
    |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `TableLight` | Colored Light | `tableLight` | Read and write | On change
    |'
  prefs: []
  type: TYPE_TB
- en: Table 10.2 – Cloud variables properties table
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, I mentioned that we only need one cloud variable, but I am using
    three different cloud variables and will explain their usage. If I start from
    the `RGBLightColor`, has only one option regarding the color change. But if we
    come to the **Colored Light** type cloud variable, then it provides all three
    options: brightness, color, and an on/off switch. This cloud variable is also
    compatible with Amazon Alexa and that type cloud variable will be represented
    as a device in the Amazon Alexa Smart Home skills portal, which is discussed in
    the *Enhancing control – Integrating Arduino IoT Cloud with Amazon* *Alexa* section.'
  prefs: []
  type: TYPE_NORMAL
- en: Associating a device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After variable creation, it’s time to add a device associated with the Thing.
    Before adding the device, connect the development board to the computer and open
    the **Arduino Create Agent** application. The following figure shows how to select
    the ESP32 and then the XIAO_ESP32C3 development board in the popup.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Device selection wizard](img/B19752_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Device selection wizard
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to associate the XIAO ESP32C3 to the Thing:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Select Device** button under the **Associated Device** section
    on the Thing page shown in *Figure 10**.8*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A popup will appear where you can see all the devices that are already available.
    If you have already added your XIAO ESP32C3, select it. Otherwise, click on **SET
    UP** **NEW DEVICE**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the **Third party** **device** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **ESP32** and **XIAO_ESP32C3** from the dropdown and click on the **CONTINUE**
    button shown in *Figure 10**.9*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in **Device Name** and click on the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the final wizard, **Device ID** and **Secret Key** will be displayed. Copy
    the secret key to a safe place as it will be used during the network configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s move to the network configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After associating the device with the Thing, it is time to configure the Wi-Fi
    settings for device communication. The following figure shows the network configuration
    popup with the **Wi-Fi Name** and **Password** fields.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 10.10 – Network configuration for \uFEFFthe Thing](img/B19752_10_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Network configuration for the Thing
  prefs: []
  type: TYPE_NORMAL
- en: You will find a new field – **Secret Key**. Paste the secret key that we received
    from the system during device creation.
  prefs: []
  type: TYPE_NORMAL
- en: Coding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The chapter’s code is available at the official GitHub repository for the book.
    Download the `Voice_Controlled_Smart_Lamp_may13a` code from the repository and
    import it to the Arduino Web Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code and put it into your Thing by navigating to the `delay()`
    method – it will block the `ArduinoCloud.update()` method. But before moving forward,
    at the start of the code, we need to change the `LED_PIN` constant to `5` and
    assign a value to `LED_COUNT` according to the number of pixels in the ring/strip.
    Here, I am assigning the value `16` as I am using a 16-pixel ring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we review the preceding code for the constant, then we will see there is
    one `NeoPixel strip` object and four global variables for the switch (`swi`),
    brightness (`bright`), saturation (`sat`), and hue that will be used later to
    sync the values from one widget control to another widget control to enable the
    synchronization between widgets.
  prefs: []
  type: TYPE_NORMAL
- en: After filling the preceding constants with appropriate values, it’s time to
    explore some other methods. If we talk about the setup, then there are only a
    few lines that initiate the `NeoPixel strip` object as well as the Arduino IoT
    Cloud and some other operations. In this project, our `loop()` method will include
    one line regarding an Arduino Cloud update and nothing else. Actually, in this
    project, code will be executed where any change happens on the widget side.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project, we have four more methods. Three are event-oriented and one
    is a common helper method that will be used by three `onLightBrightnessChange()`,
    `onRGBLightColorChange()`, and `onTableLightChange()` methods are event-oriented
    and the `ControlTheWS2812()` method is a **common helper method**. Next, we are
    going to explore all the methods step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onLightBrightnessChange()` method, we take brightness and switch values
    from the `lightBrightness` cloud variable and later assign the values with global
    variables. The last calling method, `ControlTheWS2812()`, performs the operation
    on the WS2812 ring according to global variable values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onRGBLightColorChange()` method is the second method that will be called
    when there is any change in the color widget control. This method fetches hue,
    saturation, and brightness values from the `Color` type cloud variable and later
    assigns these values to other cloud variables as well as global variables. The
    last calling method, `ControlTheWS2812()`, performs the operation on the WS2812
    ring according to global variable values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onTableLightChange()` method is associated with the `tablelight` cloud
    variable and assign these values to global variables as well to two other cloud
    variables for synchronization. The last calling method, `ControlTheWS2812()`,
    will perform the operation on the WS2812 ring according to global variable values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have our last, common helper method, `ControlTheWS2812()`. This
    method will first generate RGB color from hue, saturation, and brightness. Then
    it will check the switch value – if it is true, then the condition will assign
    the brightness and color to the WS2812 ring and turn on every pixel of the ring
    with the help of the `for` loop. Otherwise, it will set the brightness to `0`
    and turn off all the pixels of the WS2812.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you used different *naming* in the variable declaration, then update the
    code according to your naming scheme. But it’s better if you first follow all
    the steps according to the book and later change the cloud variable names and
    modify your code respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud only updates the values on the dashboard whenever a variable
    value is changed. For example, if the temperature is 30 and after 5 minutes it’s
    the same, then the Arduino IoT Cloud will not record the value. So, don’t get
    confused if values are not changed on the widget controls. Another benefit of
    this feature is you will not get duplicated data when you are exporting the content.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we set up the Thing, associated the XIAO ESP32C3 with the Thing,
    and set up cloud variables of different types to control LED operations. We also
    discussed the code for the device in detail, step by step, according to different
    methods. Now, in the next section, we will set up the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: User-friendly controls – building web and mobile dashboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After uploading the code to the device, it’s time to set up a dashboard for
    web and mobile to visualize the data with different widgets. The following screenshot
    shows a visualization of light controls with different widgets.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Thing dashboard](img/B19752_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Thing dashboard
  prefs: []
  type: TYPE_NORMAL
- en: We have three core functionalities of WS2812, which include RGB color, brightness,
    and the on/off switch. In the previous section, we created three different cloud
    variables, which provide different functionalities. That’s why here we have three
    different widget controls, which only work with these cloud variables. The first
    widget is `tableLight` cloud variable and capable of performing all of the operations
    on the WS2812, such as color change, brightness control, and switching it on and
    off.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have two more controls with limited functionalities. The second widget
    is `lightBrightness` cloud variable and only provides an on/off switch and brightness
    control, while our third widget control is `rGBLightColor` cloud variable and
    only provides the option to choose the color. If we compare all three widgets,
    then the **Colored Light** widget is equal to both **Dimmed light** and the **Color**
    widget, as the **Colored Light** widget has three functionalities, which include
    turning it on and off, color selection, and brightness control, while the **Dimmed
    light** widget control has only two options, brightness control and turning on
    and off functionality, and the **Color** widget control only has the option to
    choose the color.
  prefs: []
  type: TYPE_NORMAL
- en: So, the final conclusion is if you have a multi-color strip with a brightness
    control feature, then the **Colored Light** widget and cloud variable are good
    to go; otherwise, for a single-color light with brightness control, the **Dimmed
    light** widget and cloud variable are perfect. And if you have only a strip with
    the multi-color option without a brightness control, then a simple **Color** widget
    and cloud variable type are enough but remember the **Color** type cloud variable
    is not compatible with Amazon Alexa.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have set up the dashboard with different types of widget
    controls, which help you to control WS2812 in different ways, such as controlling
    the brightness, color, and turning on and off the LED ring. Next, we are going
    to set up the Amazon Alexa Skill with the Arduino IoT Cloud to control our table
    lamp with voice commands using Amazon Alexa.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing controls – integrating the Arduino IoT Cloud with Amazon Alexa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After testing everything on the device using the Arduino IoT Cloud dashboard,
    it’s time to link Amazon Alexa with our thing for the voice control system. We
    have a physical hardware device for Alexa as well mobile apps for Android/iOS.
    Please visit [https://alexa.amazon.com/](https://alexa.amazon.com/) to set up
    this project. I am using Amazon Echo Dot second generation, but if you don’t have
    access to an Alexa hardware device, then you can simply use the mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Arduino Skill for Amazon Alexa](img/B19752_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Arduino Skill for Amazon Alexa
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud natively developed a skill for Amazon Alexa, which can
    be found at [https://www.amazon.com/Arduino-LLC/dp/B07ZT2PK2H](https://www.amazon.com/Arduino-LLC/dp/B07ZT2PK2H).
    Set up your Amazon Alexa and navigate to the preceding URL to enable a skill,
    which is shown in the preceding figure. When you link the account, it will automatically
    link the Arduino IoT cloud account that is already logged in with this Skill.
    So, make sure you are already logged in to the Arduino IoT Cloud. The preceding
    figure shows the Arduino Skill for Amazon Alexa.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Amazon Alexa Smart Home and devices](img/B19752_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Amazon Alexa Smart Home and devices
  prefs: []
  type: TYPE_NORMAL
- en: After enabling the Arduino skill in Amazon Alexa, navigate to [https://alexa.amazon.com/spa/index.html](https://alexa.amazon.com/spa/index.html)
    and click on the **Smart Home** link, which is located in the left sidebar, then
    click on **Devices**, shown in the preceding figure. Here, you will see cloud
    variables will become devices, as shown in the following figure. If you don’t
    see your desired Arduino IoT Cloud variables as a device, then at the bottom,
    click on the **Discover** button on the **Devices** page, which will take around
    20 seconds to load all the stuff.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Arduino Cloud variables as devices at Amazon Alexa](img/B19752_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Arduino Cloud variables as devices at Amazon Alexa
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, turn on your Amazon Echo Dot and WS2812-based smart lamp and try the
    following voice commands on Amazon Alexa. Firstly, try these commands, which will
    help you turn on/off **TableLight**. As shown in the preceding figure, **TableLight**
    is now acting as a device in the Amazon Alexa smart home:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it’s time to change the brightness and colors of the WS2812 using voice
    commands. Try the following commands, which will help you to update the brightness
    and colors. Right now, I have just written four different colors, but you can
    choose any color name that you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, I am using the Alexa timer functionality to schedule turning on/off
    the table light after a specific time interval. But you can also use this function
    just like an alarm and turn on/off the WS2812 for long intervals, such as to turn
    on the light early in the morning, turning off the lamp at 10:00 P.M., and so
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have discussed different voice commands for Amazon Alexa, but you can search
    on the internet for more commands regarding light controls and colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to talk about which Arduino Cloud variables are compatible with
    Amazon Alexa. You can get up-to-date information at [https://www.amazon.com/Arduino-LLC/dp/B07ZT2PK2H](https://www.amazon.com/Arduino-LLC/dp/B07ZT2PK2H).
    At the moment, we have the following list of cloud variables that work perfectly
    with Amazon Alexa:'
  prefs: []
  type: TYPE_NORMAL
- en: Temperature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motion detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light, smart plug, and smart switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dimmed light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Colored light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to the preceding list, you can create a thermostat for a room, which
    will help you to change the room or kitchen temperature according to outdoor and
    indoor thermostat temperature, you can control your heating and cooling system.
    To turn on/off any device, we have four different types of cloud variables, which
    have the same data type Boolean but different names, including light, smart plug,
    smart switch, and motion detection. These four variables could be used to control
    any relay/magnetic contactors to turn home appliances on/off, such as cooling/heating
    systems. We have already discussed **Dimmed light** and **Colored Light** in previous
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have set up the Amazon Alexa with Arduino Cloud skill and
    tried different voice commands related to turning lights on and off, as well as
    how to change the color and brightness of the WS2812 RGB LED ring.
  prefs: []
  type: TYPE_NORMAL
- en: What next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We still have lots of options available to explore, but now your assignment
    is to use different relays, sensors, and development boards to do some more experiments
    and learn from them. In the current chapter, we have only used one WS2812 module
    for light control, but you can use temperature sensors, relays, and motion sensors
    to automate your devices in your home, such as automating room switches to control
    fans, exhaust fans, lights, and air conditioning systems according to room temperature.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when playing with high-voltage power cables when patching the cables
    to relays.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored how to develop a low-cost, multi-color smart
    table lamp for our room using the XIAO ESP32C3 and WS2812\. We have set up the
    Thing, which included cloud variable creation, device association, network configuration,
    and coding of the development board. Later, we created a dashboard using different
    widgets to control the WS2812 RGB ring. Finally, we used the Amazon Alexa voice
    assistant to turn our table lamp on/off and control its color and brightness with
    voice commands.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will give you the confidence to build more interesting stuff to
    make your home and office smarter. In the next chapter, we will talk about Cloud
    Scheduler and over-the-air update’ features. Both features are interesting and
    specially designed to carry out operations on IoT nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Learning Advanced Features of the Arduino IoT Cloud and Looking Ahead'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Part 4*, the reader is guided through the advanced features of the Arduino
    IoT Cloud platform, how to use them to develop professional applications, and
    the tools for maintaining solutions during their life cycle. The book ends with
    some suggestions for further learning, experimenting, and sourcing information.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19752_11.xhtml#_idTextAnchor229), *Implementing the Arduino
    IoT Cloud Scheduler and Over-the-Air Features*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19752_12.xhtml#_idTextAnchor251), *Project #6 – Tracking and
    Notifying about Your Heart Rate*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19752_13.xhtml#_idTextAnchor268), *Scripting the Arduino IoT
    Cloud with Cloud CLI*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19752_14.xhtml#_idTextAnchor296), *Moving Ahead in the Arduino
    IoT Cloud*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
