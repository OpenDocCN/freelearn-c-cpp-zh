["```cpp\n unsigned int numAnims = scene->mNumAnimations;\n  for (unsigned int i = 0; i < numAnims; ++i) {\n    const auto& animation = scene->Animations[i];\n    mMaxClipDuration =\n      std::max(mMaxClipDuration,\n      static_cast<float>(animation->mDuration));\n } \n```", "```cpp\n for (unsigned int i = 0; i < numAnims; ++i) {\n  ...\n    animClip->addChannels(animation, mMaxClipDuration,\n      mBoneList);\n  ...\n  } \n```", "```cpp\nfor (unsigned int i = 0; i < animation->mNumChannels; ++i) {\n  ...\n  channel->loadChannelData(animation->Channels[i],\n    maxClipDuration);\n  ...\n} \n```", "```cpp\n mMinTranslateTime =\n    static_cast<float>(nodeAnim->mPositionKeys[0].mTime);\n  mMaxTranslateTime =\n   static_cast<float>(\n   nodeAnim->mPositionKeys[mNumTranslations - 1].mTime); \n```", "```cpp\n float translateScaleFactor = maxClipDuration /\n    mMaxTranslateTime;\n  mTranslateTimeScaleFactor = maxClipDuration /\n    static_cast<float>(LOOKUP_TABLE_WIDTH);\n  mInvTranslateTimeScaleFactor = 1.0f /\n    mTranslateTimeScaleFactor; \n```", "```cpp\n int timeIndex = 0;\n  for (int i = 0; i < LOOKUP_TABLE_WIDTH; ++i) { \n```", "```cpp\n glm::vec4 currentTranslate = glm::vec4(\n      nodeAnim->mPositionKeys[timeIndex].mValue.x,\n      nodeAnim->mPositionKeys[timeIndex].mValue.y,\n      nodeAnim->mPositionKeys[timeIndex].mValue.z, 1.0f);\n    glm::vec4 nextTranslate = glm::vec4(\n      nodeAnim->mPositionKeys[timeIndex + 1].mValue.x,\n      nodeAnim->mPositionKeys[timeIndex + 1].mValue.y,\n      nodeAnim->mPositionKeys[timeIndex + 1].mValue.z,\n      1.0f); \n```", "```cpp\n float currentKey = static_cast<float>(\n      nodeAnim->mPositionKeys[timeIndex].mTime);\n    float nextKey = static_cast<float>(\n      nodeAnim->mPositionKeys[timeIndex + 1].mTime);\n    float currentTime = i * mTranslateTimeScaleFactor /\n      translateScaleFactor; \n```", "```cpp\n mTranslations.emplace_back(glm::mix(\n      currentTranslate,\n      nextTranslate,\n      (currentTime - currentKey) / (nextKey - currentKey))); \n```", "```cpp\n if (currentTime > nextKey) {\n      if (timeIndex < mNumTranslations - 1) {\n        ++timeIndex;\n      }\n    }\n  } \n```", "```cpp\n std::vector<glm::vec4> animLookupData{}; \n```", "```cpp\n const int LOOKUP_SIZE = 1023 + 1; \n```", "```cpp\n std::vector<glm::vec4> emptyTranslateVector(\n      LOOKUP_SIZE, glm::vec4(0.0f));\n    emptyTranslateVector.at(0) = glm::vec4(0.0f); \n```", "```cpp\n for (int i = 0; i < mBoneList.size() *\n      mAnimClips.at(0)->getNumChannels(); ++i) {\n      animLookupData.insert(animLookupData.end(),\n        emptyTranslateVector.begin(),\n        emptyTranslateVector.end());\n      animLookupData.insert(animLookupData.end(),\n        emptyRotateVector.begin(),\n        emptyRotateVector.end());\n      animLookupData.insert(animLookupData.end(),\n        emptyScaleVector.begin(),\n        emptyScaleVector.end());\n    } \n```", "```cpp\n int boneId = channel->getBoneId();\n        if (boneId >= 0) { \n```", "```cpp\n int offset = clipId * mBoneList.size() *\n            LOOKUP_SIZE * 3 + boneId * LOOKUP_SIZE * 3; \n```", "```cpp\n animLookupData.at(offset) =\n            glm::vec4(channel->getInvTranslationScaling(),\n            0.0f, 0.0f, 0.0f);\n          const std::vector<glm::vec4>& translations =\n            channel->getTranslationData();\n          std::copy(translations.begin(),\n            translations.end(),\n            animLookupData.begin() + offset + 1); \n```", "```cpp\n offset += LOOKUP_SIZE; \n```", "```cpp\n mAnimLookupBuffer.uploadSsboData(animLookupData); \n```", "```cpp\nstruct PerInstanceAnimData {\n  uint32_t firstAnimClipNum;\n  uint32_t secondAnimClipNum;\n  float firstClipReplayTimestamp;\n  float secondClipReplayTimestamp;\n  float blendFactor;\n}; \n```", "```cpp\n std::vector<PerInstanceAnimData> mPerInstanceAnimData{};\n    ShaderStorageBuffer mPerInstanceAnimDataBuffer{}; \n```", "```cpp\n PerInstanceAnimData animData{};\n          animData.firstAnimClipNum =\n            instSettings.isFirstAnimClipNr;\n          animData.secondAnimClipNum =\n            instSettings.isSecondAnimClipNr;\n          animData.firstClipReplayTimestamp =\n            instSettings.isFirstClipAnimPlayTimePos;\n          animData.secondClipReplayTimestamp =\n            instSettings.isSecondClipAnimPlayTimePos;\n          animData.blendFactor =\n            instSettings.isAnimBlendFactor;\n          mPerInstanceAnimData.at(i) = animData; \n```", "```cpp\n mAssimpTransformComputeShader.use();\n        mUploadToUBOTimer.start();\n        modelType.second.at(0->getModel()\n          ->bindAnimLookupBuffer(0);\n        mPerInstanceAnimDataBuffer.uploadSsboData(\n          mPerInstanceAnimData, 1);\n        mShaderTRSMatrixBuffer.bind(2); \n```", "```cpp\nstruct PerInstanceAnimData {\n  uint firstAnimClipNum;\n  uint secondAnimClipNum;\n  float firstClipReplayTimestamp;\n  float secondClipReplayTimestamp;\n  float blendFactor;\n}; \n```", "```cpp\nlayout (std430, binding = 0) readonly restrict\n    buffer AnimLookup {\n  vec4 lookupData[];\n};\nlayout (std430, binding = 1) readonly restrict\n    buffer InstanceAnimData {\n  PerInstanceAnimData instAnimData[];\n}; \n```", "```cpp\n **int** **lookupWidth =** **1023** **+** **1****;**\n  uint node = gl_GlobalInvocationID.x;\n  uint instance = gl_GlobalInvocationID.y;\n  uint numberOfBones = gl_NumWorkGroups.x;\n  **uint** **boneOffset = lookupWidth *** **3**;\n  **uint** **clipOffset = numberOfBones * boneOffset**; \n```", "```cpp\n uint firstClip = instAnimData[instance].firstAnimClipNum;\n  uint secondClip =\n    instAnimData[instance].secondAnimClipNum;\n  float blendFactor = instAnimData[instance].blendFactor; \n```", "```cpp\n float firstTransInvScaleFactor = lookupData[firstClip *\n    clipOffset + node * boneOffset].x; \n```", "```cpp\n int firstTransLookupIndex =\n    int(instAnimData[instance].firstClipReplayTimestamp *\n    transInvScaleFactor) + 1; \n```", "```cpp\n vec4 firstTranslation = lookupData[firstClip *\n    clipOffset + node * boneOffset +\n    firstTransLookupIndex];\n  ...\n  vec4 secondTanslation = lookupData[secondClip *\n    clipOffset + node * boneOffset +\n    secondTransLookupIndex]; \n```", "```cpp\n vec4 finalTranslation = mix(firstTanslation,\n    secondTanslation, blendFactor); \n```", "```cpp\n uint index = node + numberOfBones * instance;\n  trsMat[index] =\n    createTranslationMatrix(finalTranslation) *\n    createRotationMatrix(finalRotation) *\n    createScaleMatrix(finalScale); \n```", "```cpp\n mInstanceSettings.isFirstClipAnimPlayTimePos +=\n    deltaTime *\n    mInstanceSettings.isAnimSpeedFactor * 1000.0f;\n  mInstanceSettings.isAnimPlayTimePos =\n    std::fmod(mInstanceSettings.isFirstClipAnimPlayTimePos,\n    mAssimpMode->getMaxClipDuration());\n  mModelRootMatrix = mLocalTransformMatrix *\n    mAssimpModel->getRootTranformationMatrix(); \n```", "```cpp\nenum class moveDirection : uint8_t {\n  none = 0x00,\n  forward = 0x01,\n  back = 0x02,\n  right = 0x04,\n  left = 0x08,\n  any = 0xff\n}; \n```", "```cpp\ninline moveDirection operator | (moveDirection lhs,\n     moveDirection rhs) {\n  using T = std::underlying_type_t <moveDirection>;\n  return static_cast<moveDirection>(static_cast<T>(lhs) |\n    static_cast<T>(rhs));\n} \n```", "```cpp\nenum class moveState  {\n  idle = 0,\n  walk,\n  run,\n  hop,\n  jump,\n  ...\n  wave,\n  NUM\n}; \n```", "```cpp\n std::unordered_map<moveDirection, std::string>\n    micMoveDirectionMap{};\n  std::unordered_map<moveState, std::string>\n    micMoveStateMap{}; \n```", "```cpp\nstruct IdleWalkRunBlending {\n  int iwrbIdleClipNr = 0;\n  float iwrbIdleClipSpeed = 1.0f;\n  int iwrbWalkClipNr = 0;\n  float iwrbWalkClipSpeed = 1.0f;\n  int iwrbRunClipNr = 0;\n  float iwrbRunClipSpeed = 1.0f;\n}; \n```", "```cpp\nstruct ModelSettings {\n  std::string msModelFilenamePath;\n  std::string msModelFilename;\n  std::map<moveDirection, IdleWalkRunBlending>\n    msIWRBlendings;\n}; \n```", "```cpp\n ModelSettings mModelSettings; \n```", "```cpp\n moveDirection isMoveDirection = moveDirection::none;\n  moveState isMoveState = moveState::idle; \n```", "```cpp\n unsigned int isFirstAnimClipNr = 0;\n  unsigned int isSecondAnimClipNr = 0;\n  float isAnimBlendFactor = 0.0f; \n```", "```cpp\n glm::vec3 isAccel = glm::vec3(0.0f);\n  glm::vec3 isSpeed = glm::vec3(0.0f); \n```", "```cpp\n float instanceSpeed =\n    glm::length(mInstanceSettings.isSpeed);\n  ModelSettings modSettings =\n    mAssimpMode->getModelSettings();\n  IdleWalkRunBlending blend; \n```", "```cpp\n if (modSettings.msIWRBlendings.count(\n      mInstanceSettings.isMoveDirection) > 0 ) {\n    blend = modSettings.msIWRBlendings[\n      mInstanceSettings.isMoveDirection];\n  } else if (modSettings.msIWRBlendings.count(\n      moveDirection::any) > 0) {\n    blend = modSettings.msIWRBlendings[moveDirection::any];\n  } else if (modSettings.msIWRBlendings.count(\n      moveDirection::none) > 0) {\n    blend = modSettings.msIWRBlendings[moveDirection::none];\n  } else {\n    return;\n  } \n```", "```cpp\n if (instanceSpeed <= 1.0f) {\n    mInstanceSettings.isFirstAnimClipNr =\n      blend.iwrbIdleClipNr;\n    mInstanceSettings.isSecondAnimClipNr =\n      blend.iwrbWalkClipNr;\n    mInstanceSettings.isAnimSpeedFactor = glm::mix(\n      blend.iwrbIdleClipSpeed,\n      blend.iwrbWalkClipSpeed, instanceSpeed);\n    mInstanceSettings.isAnimBlendFactor = instanceSpeed;\n  } else { \n```", "```cpp\n mInstanceSettings.isFirstAnimClipNr =\n      blend.iwrbWalkClipNr;\n    mInstanceSettings.isSecondAnimClipNr =\n      blend.iwrbRunClipNr;\n    mInstanceSettings.isAnimSpeedFactor = glm::mix(\n      blend.iwrbWalkClipSpeed,\n      blend.iwrbRunClipSpeed, instanceSpeed – 1.0f);\n    mInstanceSettings.isAnimBlendFactor =\n      instanceSpeed – 1.0f;\n  } \n```", "```cpp\n const float MAX_ACCEL = 4.0f;\n    const float MAX_ABS_SPEED = 1.0f;\n    const float MIN_STOP_SPEED = 0.01f; \n```", "```cpp\n if (state == moveState::walk || state == moveState::run) {\n    if ((dir & moveDirection::forward) ==\n        moveDirection::forward) {\n      mInstanceSettings.isMoveKeyPressed = true;\n      mInstanceSettings.isAccel.x = 5.0f;\n    }\n    ... \n```", "```cpp\n float currentSpeed =\n    glm::length(mInstanceSettings.isSpeed);\n  static float maxSpeed = MAX_ABS_SPEED; \n```", "```cpp\n if (!mInstanceSettings.isMoveKeyPressed) {\n    if (currentSpeed > 0.0f) {\n      if (mInstanceSettings.isSpeed.x > 0.0f) {\n        mInstanceSettings.isAccel.x = -2.5f;\n      }\n      ... \n```", "```cpp\n if (currentSpeed < MIN_STOP_SPEED) {\n      currentSpeed = 0.0f;\n      mInstanceSettings.isAccel = glm::vec3(0.0f);\n      mInstanceSettings.isSpeed = glm::vec3(0.0f);\n      mInstanceSettings.isMoveState = moveState::idle;\n      mInstanceSettings.isMoveDirection =\n        moveDirection::none;\n    }\n  } \n```", "```cpp\n float currentAccel =\n    glm::length(mInstanceSettings.isAccel);\n  if (currentAccel > MAX_ACCEL) {\n    mInstanceSettings.isAccel =\n      glm::normalize(mInstanceSettings.isAccel); \n```", "```cpp\n mInstanceSettings.isAccel *= MAX_ACCEL; \n```", "```cpp\n mInstanceSettings.isSpeed +=\n    mInstanceSettings.isAccel * deltaTime; \n```", "```cpp\n if (mInstanceSettings.isMoveState == moveState::run) {\n    maxSpeed = MAX_ABS_SPEED * 2.0f;\n  } \n```", "```cpp\n if (currentSpeed > maxSpeed) {\n    if (mInstanceSettings.isMoveState != moveState::run) {\n      maxSpeed -=\n        glm::length(mInstanceSettings.isAccel) * deltaTime;\n      if (maxSpeed <= MAX_ABS_SPEED) {\n        maxSpeed = MAX_ABS_SPEED;\n      }\n    } \n```", "```cpp\n mInstanceSettings.isSpeed =\n      glm::normalize(mInstanceSettings.isSpeed);\n    mInstanceSettings.isSpeed *= maxSpeed; \n```", "```cpp\n ImGui::PushID(buttonId++);\n        if (ImGui::Button(\"Edit##Blending\")) {\n          ...\n        }\n        ImGui::PopID(); \n```", "```cpp\n ImGui::GetStateStorage()->SetInt(\n      ImGui::GetID(\"Model Animation Mappings\"), 0); \n```", "```cpp\n std::map<moveState, ActionAnimation>\n    msActionClipMappings; \n```", "```cpp\nstruct ActionAnimation {\n  int aaClipNr = 0;\n  float aaClipSpeed = 1.0f;\n}; \n```", "```cpp\n mInstanceSettings.isSecondAnimClipNr =\n    modSettings.msActionClipMappings[mActionMoveState]\n    .aaClipNr;\n  float animSpeed =\n    modSettings.msActionClipMappings[mActionMoveState]\n    .aaClipSpeed; \n```", "```cpp\n moveState nextState = moveState::idle;\n      ..\n      if (glfwGetKey(mRenderData.rdWindow, GLFW_KEY_E) ==\n          GLFW_PRESS) {\n        nextState = moveState::punch;\n      }\n      ...\n      currentInstance->setNextInstanceState(nextState); \n```", "```cpp\n std::set<std::pair<moveState, moveState>>\n    msAllowedStateOrder; \n```", "```cpp\nenum class animationState : uint8_t {\n  playIdleWalkRun = 0,\n  transitionFromIdleWalkRun,\n  transitionToAction,\n  playActionAnim,\n  transitionToIdleWalkRun\n}; \n```", "```cpp\n switch (mAnimState) {\n    case animationState::playIdleWalkRun:\n      playIdleWalkRunAnimation();\n      ...\n      break;\n    case animationState::transitionFromIdleWalkRun:\n      blendIdleWalkRunAnimation(deltaTime);\n      break;\n    case animationState::transitionToAction:\n      blendActionAnimation(deltaTime);\n      break;\n    case animationState::playActionAnim:\n      playActionAnimation();\n      ...\n      break;\n    case animationState::transitionToIdleWalkRun:\n      blendActionAnimation(deltaTime, true);\n      break;\n  } \n```", "```cpp\n template<>\n  struct convert<moveState> {\n    static Node encode(const moveState& rhs) {\n      Node node;\n      node = static_cast<int>(rhs);\n      return node;\n    }\n    static bool decode(const Node& node, moveState& rhs) {\n      rhs = static_cast<moveState>(node.as<int>());\n      return true;\n    }\n  }; \n```", "```cpp\nYAML::Emitter& operator<<(YAML::Emitter& out,\n    const moveState& state) {\n  out << YAML::Flow;\n  out << static_cast<int>(state);\n  return out;\n} \n```", "```cpp\nstatic bool decode(const Node& node, ActionAnimation& rhs) {\n  rhs.aaClipNr = node[\"clip\"].as<int>();\n  rhs.aaClipSpeed = node[\"clip-speed\"].as<float>();\n  return true;\n} \n```", "```cpp\n ...\n  if (settings.msActionClipMappings.size() > 0) {\n    out << YAML::Key << \"action-clips\";\n    out << YAML::Value;\n    out << YAML::BeginSeq;;\n    for (auto& setting : settings.msActionClipMappings) {\n      out << YAML::BeginMap;\n      out << YAML::Key << setting.first;\n      out << YAML::Value << setting.second;\n      out << YAML::EndMap;\n    }\n    out << YAML::EndSeq;\n  }\n  ... \n```", "```cpp\nmodSettings.emplace_back(modelsNode[i].\n  as<ModelSettings>()); \n```", "```cpp\n if (Node clipNode = node[\"idle-walk-run-clips\"]) {\n    for (size_t i = 0; i < clipNode.size(); ++i) {\n      std::map<moveDirection, IdleWalkRunBlending> entry =\n        clipNode[i].as<std::map<moveDirection,\n        IdleWalkRunBlending>>();\n      rhs.msIWRBlendings.insert(entry.begin(),\n        entry.end());\n    }\n  } \n```", "```cpp\n std::vector<ModelSettings> savedModelSettings =\n    parser.getModelConfigs(); \n```", "```cpp\n for (const auto& modSetting : savedModelSettings) {\n    if (!addModel(modSetting.msModelFilenamePath,\n        false, false)) {\n      return false;\n    } \n```", "```cpp\n std::shared_ptr<AssimpModel> model =\n      getModel(modSetting.msModelFilenamePath);\n    model->setModelSettings(modSetting); \n```", "```cpp\n mModelInstCamData.micSelectedModel =\n    parser.getSelectedModelNum(); \n```"]