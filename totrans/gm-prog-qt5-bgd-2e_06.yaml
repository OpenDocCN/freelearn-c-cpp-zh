- en: Qt Core Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will help you master Qt ways of basic data processing and storage.
    First of all, you will learn how to handle textual data and how to match text
    against regular expressions. Next, we will provide an overview of Qt containers
    and describe common pitfalls related to them. Then, you will see how to store
    and fetch data from files and how to use different storage formats for text and
    binary data. By the end of this chapter, you will be able to implement non-trivial
    logic and data processing in your games efficiently. You will also know how to
    load external data in your games and how to save your own data in permanent storage
    for future use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Main topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Text handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialization to INI, JSON, XML, and binary data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving the application's settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications with a graphical user interface (and games surely fall into this
    category) are able to interact with users by displaying text and by expecting
    textual input from the user. We have already scratched the surface of this topic
    in the previous chapters using the `QString` class. Now, we will go into further
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: String encodings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ language does not specify encoding of strings. Thus, any `char*` array
    and any `std::string` object can use an arbitrary encoding. When using these types
    for interaction with native APIs and third-party libraries, you have to refer
    to their documentation to find out which encoding they use. The encoding used
    by native APIs of the operating system usually depends on the current locale.
    Third-party libraries often use the same encoding as native APIs, but some libraries
    may expect another encoding, for example, UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: 'A string literal (that is, each bare text you wrap in quotation marks) will
    use an implementation defined encoding. Since C++11, you have an option to specify
    the encoding your text will have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`u8"text"` will produce a UTF-8 encoded `const char[]` array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u"text"` will produce a UTF-16 encoded `const char16_t[]` array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`U"text"` will produce a UTF-32 encoded `const char32_t[]` array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, the encoding used for interpreting the source files is still
    implementation defined, so it's not safe to put non-ASCII symbols in string literals.
    You should use escape sequences (such as `\unnnn`) to write such literals.
  prefs: []
  type: TYPE_NORMAL
- en: Text in Qt is stored using the `QString` class that uses Unicode internally.
    Unicode allows us to represent characters in almost all languages spoken in the
    world and is the de facto standard for native encoding of text in most modern
    operating systems. There are multiple Unicode-based encodings. Memory representation
    of the content of `QString` resembles UTF-16 encoding. Basically, it consists
    of an array of 16-bit values where each Unicode character is represented by either
    1 or 2 values.
  prefs: []
  type: TYPE_NORMAL
- en: When constructing a `QString` from a `char` array or an `std::string` object,
    it's important to use a proper conversion method that depends on the initial encoding
    of the text. By default, `QString` assumes UTF-8 encoding of the input text. UTF-8
    is compatible with ASCII, so passing UTF-8 or ASCII-only text to `QString(const
    char *str)` is correct. `QString` provides a number of static methods to convert
    from other encodings such as `QString::fromLatin1()` or `QString::fromUtf16()`.
    `QString::fromLocal8Bit()` method assumes the encoding corresponding to the system
    locale.
  prefs: []
  type: TYPE_NORMAL
- en: If you have to combine both `QString` and `std::string` in one program, `QString`
    offers you the `toStdString()` and `fromStdString()` methods to perform a conversion.
    These methods also assume UTF-8 encoding of `std::string`, so you can't use them
    if your strings are in another encoding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Default representation of string literals (for example, `"text"`) is not UTF-16,
    so each time you convert it to a `QString`, an allocation and conversion happens.
    This overhead can be avoided using the `QStringLiteral` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`QStringLiteral` does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It adds a `u` prefix to your string literal to ensure that it will be encoded
    in UTF-16 at compile time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It cheaply creates a `QString` and instructs it to use the literal without performing
    any allocation or encoding conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's a good habit to wrap all your string literals (except the ones that need
    to be translated) into `QStringLiteral` but it is not required, so don't worry
    if you forget to do that.
  prefs: []
  type: TYPE_NORMAL
- en: QByteArray and QString
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QString` always contains UTF-16 encoded strings, but what if you have data
    in an unknown (yet) encoding? Also, what if the data is not even text? In these
    cases, Qt uses the `QByteArray` class. When you read data directly from a file
    or receive it from a network socket, Qt will return the data as a `QByteArray`,
    indicating that this is an arbitrary array of bytes without any information about
    the encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The closest equivalent of `QByteArray` in the standard library would be `std::vector<char>`.
    As the name implies, this is just an array of bytes with some helpful methods.
    In the preceding example, if you know that the file you read is in UTF-8, you
    can convert the data to a string, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have no idea what encoding the file uses, it may be best to use the
    system encoding, so `QString::fromLocal8Bit` would be better. Similarly, when
    writing to a file, you need to convert the string to a byte array before passing
    it to the `write()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can use `file.close()` to close the file. `QFile` will also automatically
    close the file when deleted, so if your `QFile` object goes out of scope immediately
    after you've finished working with the file, there is no need for an explicit
    `close()` call.
  prefs: []
  type: TYPE_NORMAL
- en: Using other encodings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve already mentioned, `QString` has convenient methods for decoding
    and encoding data in the most popular encodings, such as UTF-8, UTF-16, and Latin1\.
    However, Qt knows how to handle many other encodings as well. You can access them
    using the `QTextCodec` class. For example, if you have a file in Big-5 encoding, you
    can ask Qt for a codec object by its name and make use of the `fromUnicode()`
    and `toUnicode()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can list the codecs supported on your installation using the `QTextCodec::availableCodecs()`
    static method. In most installations, Qt can handle almost 1,000 different text
    codecs.
  prefs: []
  type: TYPE_NORMAL
- en: Basic string operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic tasks that involve text strings are the ones where you add or
    remove characters from the string, concatenate strings, and access the string's
    content. In this regard, `QString` offers an interface that is compatible with
    `std::string`, but it also goes beyond that, exposing many more useful methods.
  prefs: []
  type: TYPE_NORMAL
- en: Adding data at the beginning or at the end of the string can be done using the
    `prepend()` and `append()` methods. Inserting data in the middle of a string can
    be done with the `insert()` method that takes the position of the character where
    we need to start inserting as its first argument and the actual text as its second
    argument. All these methods have a couple of overloads that accept different objects
    that can hold textual data, including the classic `const char*` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing characters from a string is similar. The basic way to do this is to
    use the `remove()` method that accepts the position at which we need to delete
    characters, and the number of characters to delete is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a `remove()` overload that accepts another string. When called,
    all its occurrences are removed from the original string. This overload has an
    optional argument that states whether comparison should be done in the default
    case-sensitive (`Qt::CaseSensitive`) or case-insensitive (`Qt::CaseInsensitive`)
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To concatenate strings, you can either simply add two strings together, or
    you can append one string to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing strings can be divided into two use cases. The first is when you
    wish to extract a part of the string. For this, you can use one of these three
    methods—`left()`, `right()`, and `mid()`—that return the given number of characters
    from the beginning or end of the string or extract a substring of a specified
    length, starting from a given position in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The second use case is when you wish to access a single character of the string.
    The use of the index operator works with `QString` in a similar fashion as with
    `std::string`, returning a copy or non-const reference to a given character that
    is represented by the `QChar` class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to this, Qt offers a dedicated method—`at()`—that returns a copy
    of the character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You should prefer to use `at()` instead of the index operator for operations
    that do not modify the character, as this explicitly uses a constant method.
  prefs: []
  type: TYPE_NORMAL
- en: The string search and lookup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second group of functionalities is related to searching for the string.
    You can use methods such as `startsWith()`, `endsWith()`, and `contains()` to
    search for substrings in the beginning or end or in an arbitrary place in the
    string. The number of occurrences of a substring in the string can be retrieved
    using the `count()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful, there is also a `count()` method that doesn't take any parameters
    and returns the number of characters in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to know the exact position of the match, you can use `indexOf()`
    or `lastIndexOf()` to receive the position in the string where the match occurs.
    The first call works by searching forward, and the other one searches backwards.
    Each of these calls takes two optional parameters—the second one determines whether
    the search is case-sensitive (similar to how `remove` works). The first one is
    the position in the string where the search begins. It lets you find all the occurrences
    of a given substring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Dissecting strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one more group of useful string functionalities that makes `QString`
    different from `std::string`, that is, cutting strings into smaller parts and
    building larger strings from smaller pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Very often, a string contains substrings that are glued together by a repeating
    separator (for example, `"1,4,8,15"`). While you can extract each field from the
    record using functions that you already know (for example, `indexOf`), an easier
    way exists. `QString` contains a `split()` method that takes the separator string
    as its parameter and returns a list of strings that are represented in Qt by the
    `QStringList` class. Then, dissecting the record into separate fields is as easy
    as calling the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The inverse of this method is the `join()` method present in the `QStringList`
    class, which returns all the items in the list as a single string merged with
    a given separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Converting between numbers and strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QString` also provides some methods for convenient conversion between textual
    and numerical values. Methods such as `toInt()`, `toDouble()`, or `toLongLong()`
    make it easy to extract numerical values from strings. All such methods take an
    optional `bool *ok` parameter. If you pass a pointer to a `bool` variable as this
    parameter, the variable will be set to `true` or `false`, depending on whether
    the conversion was successful or not. Methods returning integers also take the
    second optional parameter that specifies the numerical base (for example, binary,
    octal, decimal, or hexadecimal) of the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A static method called `number()` performs the conversion in the other direction—it
    takes a numerical value and number base and returns the textual representation
    of the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This function has some optional arguments that allow you to control the string
    representation of the number. For integers, you can specify the numerical base.
    For doubles, you can choose the scientific format `''e''` or the conventional
    format `''f''` and specify the number of digits after the decimal delimiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Some of the other classes that represent values also provide conversions to
    and from `QString`. An example of such a class is `QDate`, which represents a
    date and provides the `fromString()` and `toString()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: These methods are nice and easy to use for technical purposes, for example,
    for reading and writing numbers to configuration files. However, they are not
    suitable when you need to display a number to the user or parse a user input because
    numbers are written differently in different countries. This brings us to the
    topic of *internationalization*.
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most real projects have a target audience in multiple countries. The most notable
    difference between them is the spoken language, but there are other aspects some
    developers may not think of. For example, dot `"."` and comma `","` are both fairly
    common as the decimal separator throughout the world. Date formats are also very
    different and incompatible, and using a wrong format (for example, `mm/dd/yyyy`
    instead of `dd/mm/yyyy`) will result in a completely different date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt provides the `QLocale` class for dealing with locale-dependent operations,
    including conversions between numbers in strings. In the following code, `text`
    and `number` may have different values, depending on the system locale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`QLocale` also provides methods for formatting dates and prices, and allows
    us to request additional information about local conventions.'
  prefs: []
  type: TYPE_NORMAL
- en: As for translations, we've already mentioned that any text visible to users
    should be wrapped in a `tr()` function. Now we will explain this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt''s translation system makes it possible for developing and translation teams
    to work independently. The project goes through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Developers create an application and wrap all text that should be translated
    in special translation functions (such as `tr()`). Visible text in forms is automatically
    wrapped in translation functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A special Qt tool (**lupdate**) searches for all strings wrapped in translation
    functions and generates a translation file (`.ts`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Translators open this file in a special application called **Qt Linguist**.
    In that application, they are able to see all strings grouped by *context*, which
    is usually the class this text belongs to. They can add translations and save
    them in the translation file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When this new translation file is copied back to the project and applied using
    the `QCoreApplication::installTranslator` function, the translation functions
    start returning translated text instead of simply returning the argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the application evolves and a new untranslated text appears, it's shown untranslated
    by default. However, it can be automatically added to translation files, and translators
    can add new translations for new content, without losing the existing translations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will not go into the details of this process. As a developer, you only need
    to ensure that all visible strings are wrapped in a translation function and a
    proper context is provided. The context is necessary because a short text (for
    example, one word on a button) may not be enough to understand the meaning and
    provide a proper translation, but how do we specify the context?
  prefs: []
  type: TYPE_NORMAL
- en: 'The main translation function is `QCoreApplication::translate()`. It accepts
    three arguments: the context, the text to translate, and an optional disambiguation
    text. The disambiguation argument is rarely needed. It can be used to distinguish
    between multiple instances of the same text in the same context and when they
    should have different translations.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of `QCoreApplication::translate()`, you should usually use the `tr()`
    function, which is declared in each class that inherits `QObject`. `MyClass::tr(text,
    disambiguation)` is a shortcut for `QCoreApplication::translate(**"MyClass"**,
    text, disambiguation)`. Due to this, all translatable texts located in one class
    will share the same `context` string, so they will be grouped in Qt Linguist to
    make the translator's job easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a translatable text outside of a subclass of `QObject`, the `tr()`
    function will not be available by default. In this case, you have the following
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `QCoreApplication::translate()` function and write the `context` argument
    explicitly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse the `tr()` function of a relevant class (for example, `MyClass::tr()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare the `tr()` function in your (non-`QObject`-based) class by adding the `Q_DECLARE_TR_FUNCTIONS(context)`
    macro at the top of the class declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that the translation functions should receive the string literals directly.
    Otherwise, **lupdate** will not be able to understand which text is being translated.
    The following code is incorrect, because the two strings will not be seen by translators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest way to fix this issue is to apply the `tr()` function directly
    to each string literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Another solution is to mark translatable text with the `QT_TR_NOOP` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `QT_TR_NOOP` macro returns its argument as is, but **lupdate** will recognize
    that these strings must be translated.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also possible to add a comment for the translator using a special form
    of C++ comments: `//: ...` or `/*: ... */`. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we only described the absolute minimum you need to know before
    starting work on a multilanguage game. This knowledge can save you a lot of time,
    because it's much easier to mark some text for translation as you write it than
    to go through a large code base and do it later. However, you will need to learn
    more to actually implement internationalization in your project. We will cover
    this topic in depth later (*Online* c*hapter, *[https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf](https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf)).
  prefs: []
  type: TYPE_NORMAL
- en: Using arguments in strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common task is to have a string that needs to be dynamic in such a way that
    its content depends on the value of some external variable—for instance, you would
    like to inform the user about the number of files being copied, showing "copying
    file 1 of 2" or "copying file 2 of 5" depending on the value of counters that
    denote the current file and the total number of files. It might be tempting to
    do this by assembling all the pieces together using one of the available approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of drawbacks to such an approach; the biggest one is the
    problem of translating the string into other languages, wherein different languages
    their grammar might require the two arguments to be positioned differently than
    in English.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, Qt allows us to specify positional parameters in strings and then
    replace them with real values. This approach is called **string interpolation**.
    Positions in the string are marked with the `%` sign (for example, `%1`, `%2`,
    and so on) and they are replaced by making a call to `arg()` and passing it the
    value that is used to replace the next lowest marker in the string. Our file copy
    message construction code then becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Contrary to the behavior of the `printf()` built-in function, you don''t need
    to specify the types of values in the placeholders (like `%d` or `%s`). Instead,
    the `arg()` method has a number of overloads that accept single characters, strings,
    integers, and real numbers. The `arg()` method has the same optional arguments
    that `QString::number()` has, allowing you to configure how numbers are formatted.
    Additionally, the `arg()` method has the `fieldWidth` argument that forces it
    to always output the string of a specified length, which is convenient for formatting
    tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you want to use a character other than space to fill empty spaces, use the `fillChar`
    optional argument of `arg()`.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's briefly talk about **regular expressions**—usually shortened as "regex"
    or "regexp". You will need these regular expressions whenever you have to check
    whether a string or part of it matches a given pattern or when you want to find
    specific parts inside the text and possibly want to extract them. Both the validity
    check and the finding/extraction are based on the so-called pattern of the regular
    expression, which describes the format a string must have to be valid, to be found,
    or to be extracted. Since this book is focused on Qt, there is unfortunately no
    time to cover regular expressions in depth. This is not a huge problem, however,
    since you can find plenty of good websites that provide introductions to regular
    expressions on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Even though there are many flavors of the regular expression's syntax, the one
    that Perl uses has become the *de facto* standard. In Qt, the `QRegularExpression`
    class provides Perl-compatible regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '`QRegularExpression` was first introduced with Qt 5.0\. In the previous versions,
    the only regular exception class was `QRegExp`, and it''s still available for
    compatibility. Since `QRegularExpression` is closer to the Perl standard and since
    its execution speed is much faster as compared to `QRegExp`, we advise you to
    use `QRegularExpression` whenever possible. Nevertheless, you can read the `QRegExp`
    documentation, which contains a nice general introduction of regular expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – A simple quiz game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To introduce you to the main usage of `QRegularExpression`, let''s imagine
    this game: a photo, showing an object, is shown to multiple players, and each
    of them has to estimate the object''s weight. The player whose estimate is closest
    to the actual weight wins. The estimates will be submitted via `QLineEdit`. Since
    you can write anything in a line edit, we have to ensure that the content is valid.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So what does valid mean? In this example, we define that a value between 1g
    and 999kg is valid. Knowing this specification, we can construct a regular expression
    that will verify the format. The first part of the text is a number, which can
    be between 1 and 999\. Thus, the corresponding pattern looks like `[1-9]\d{0,2}`,
    where `[1-9]` allows—and demands—exactly one digit, except zero. It''s optionally
    followed by up to two digits, including zero. This is expressed through `\d{0,2}`,
    where `\d` means "any digit", 0 is the minimal allowed count, and 2 is the maximal
    allowed count. The last part of the input is the weight''s unit. With a pattern
    such as `(mg|g|kg)`, we allow the weight to be input in milligrams (`mg`), grams
    (`g`), or kilograms (`kg`). With `\s*`, we finally allow an arbitrary number of
    whitespace characters between the number and unit. Let''s combine it all together
    and test our regular expression right away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first line, we constructed the aforementioned `QRegularExpression` object,
    while passing the regular expression's pattern as a parameter to the constructor.
    Note that we have to escape the `\` character, because it has special meaning
    in C++ syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions are case-sensitive by default. However, we want to allow
    the input to be in uppercase or mixed case. To achieve this, we can, of course,
    write `(mg|mG|Mg|MG|g|G|kg|kG|Kg|KG)` or convert the string to lowercase before
    matching, but there is a much cleaner and more readable solution. On the second
    line of the code example, you see the answer—a pattern option. We used `setPatternOptions()`
    to set the `QRegularExpression::CaseInsensitiveOption` option, which does not
    respect the case of the characters used. Of course, there are a few more options
    that you can read about in Qt''s documentation on `QRegularExpression::PatternOption`.
    Instead of calling `setPatternOptions()`, we could also have passed the option
    as a second parameter to the constructor of `QRegularExpression`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When we need to test an input, all we have to do is call `match()`, passing
    the string we would like to check against it. In return, we get an object of the
    `QRegularExpressionMatch` type that contains all the information that is further
    needed—and not only to check the validity. With `QRegularExpressionMatch::hasMatch()`,
    we then can determine whether the input matches our criteria, as it returns `true`
    if the pattern could be found. Otherwise, of course, `false` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our pattern is not quite finished. The `hasMatch()` method would also return
    `true` if we matched it against "foo 142g bar". So, we have to define that the
    pattern is checked from the beginning to the end of the matched string. This is
    done by the `\A` and `\z` anchors. The former marks the start of a string and
    the latter the end of a string. Don''t forget to escape the slashes when you use
    such anchors. The correct pattern will then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Extracting information out of a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have checked that the sent guess is well formed, we have to extract
    the actual weight from the string. In order to be able to easily compare the different
    guesses, we further need to transform all values to a common reference unit. In
    this case, it should be a milligram, the lowest unit. So, let's see what `QRegularExpressionMatch`
    can offer us for this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `capturedTexts()`, we get a string list of the pattern''s captured groups.
    In our example, this list will contain "23kg" and "kg". The first element is always
    the string that was fully matched by the pattern. The next elements are all the
    substrings captured by the used brackets. Since we are missing the actual number,
    we have to alter the pattern''s beginning to `([1-9]\d{0,2})`. Now, the list''s
    second element is the number, and the third element is the unit. Thus, we can
    write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the function's first two lines, we set up the pattern and its option. Then,
    we match it against the passed argument. If `QRegularExpressionMatch::hasMatch()`
    returns `true`, the input is valid and we extract the number and unit. Instead
    of fetching the entire list of captured text with `capturedTexts()`, we query
    specific elements directly by calling `QRegularExpressionMatch::captured()`. The
    passed integer argument signifies the element's position inside the list. So,
    calling `captured(1)` returns the matched digits as a `QString`.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that adding a group at a later time will shift the indices of all the
    following groups by 1, and you will have to adjust your code! If you have long
    patterns or if there is a high probability that further brackets will be added
    in future, you can use **named groups** to make your code more maintainable. There
    is a  `QRegularExpressionMatch::captured()` overload that allows you to specify
    the group name instead of index. For example, if you have written `(?<number>[1-9][0-9]{0,2})`,
    then you can get the digits by calling `match.captured("number")`.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to calculate using the extracted number, we need to convert `QString`
    into an integer. This is done by calling `QString::toInt()`. The result of this
    conversion is then stored in the `weight` variable. Next, we fetch the unit and
    transform it to lowercase characters on the fly. This way, we can, for example,
    easily determine whether the user's guess is expressed in grams by checking the
    unit against the lowercase "g". We do not need to take care of the capital "G"
    or the variants "KG", "Kg", and the unusual "kG" for kilogram.
  prefs: []
  type: TYPE_NORMAL
- en: To get the standardized weight in milligrams, we multiply `weight` by 1,000
    or 1,000,000, depending on whether this was expressed in g or kg. Lastly, we return
    this standardized weight. If the string wasn't well formed, we return `-1` to
    indicate that the given guess was invalid. It is then the caller's duty to determinate
    which player's guess was the best.
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention to whether your chosen integer type can handle the weight's value.
    For our example, 999 million is the biggest possible result, and, fortunately,
    it's smaller than the maximum possible value of a signed 32-bit integer (2,147,483,647).
    If you're unsure whether the type you use is big enough on all target systems,
    use a fixed width integer type (for example, `int64_t`).
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, try to extend the example by allowing decimal numbers so that
    "23.5g" is a valid guess. To achieve this, you have to alter the pattern in order
    to enter decimal numbers, and you also have to deal with `double` instead of `int`
    for the standardized weight.
  prefs: []
  type: TYPE_NORMAL
- en: Finding all pattern occurrences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lastly, let''s take a final look at how to find, for example, all numbers inside
    a string, even those leading with zeros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `input` string contains an exemplary text in which we would like to find
    all numbers. The "foo" as well as "1a" variables should not be found by the pattern,
    since these are not valid numbers. Therefore, we set up the pattern, defining
    that we require at least one digit, `\d+`, and that this digit—or these digits—should
    be wrapped by word boundaries, `\b`. Note that you have to escape the slashes.
    With this pattern, we initiate the `QRegularExpression` object and call `globalMatch()`
    on it. Inside the passed argument, the pattern will be searched. This time, we
    do not get `QRegularExpressionMatch` back; instead, we get an iterator of the
    `QRegularExpressionMatchIterator` type. Since `QRegularExpressionMatchIterator`
    has a convenient `hasNext()` method, we check whether there is a further match
    and if so, we bring up the next match by calling `next()`. The type of the returned
    match is then `QRegularExpressionMatch`, which you already know.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to know about the next match inside the `while` loop, you can use
    `QRegularExpressionMatchIterator::peekNext()` to receive it. The benefit of this
    function is that it does not move the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: This way, you can iterate all pattern occurrences in the string. This is helpful
    if you, for example, want to highlight a search string in text.
  prefs: []
  type: TYPE_NORMAL
- en: Our example will give the output of `"123"`, `"09"`, and `"3"`.
  prefs: []
  type: TYPE_NORMAL
- en: Taking into account that this was just a brief introduction to regular expressions,
    we would like to encourage you to read the Detailed Description section in the
    documentation to `QRegularExpression`, `QRegularExpressionMatch`, and `QRegularExpressionMatchIterator`.
    Regular expressions are very powerful and useful, so, in your daily programming
    life, you can benefit from the profound knowledge of regular expressions!
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you need to store a collection of objects, you need a container to hold
    them. The C++ standard library provides many powerful containers, such as `std::vector`,
    `std::list`, or `std::map`. However, Qt doesn''t use these containers (actually,
    it hardly uses any standard library classes at all) and provides its own alternative
    implementation of containers instead. When Qt containers were introduced, they
    provided significantly more consistent performance on different platforms compared
    to standard library implementations, so they were required to create reliable
    cross-platform applications. This is not really the case now, as STL implementations
    and compilers have since evolved and gained new optimizations and features. However,
    there are still reasons to use Qt containers, especially in an application that
    heavily uses other Qt classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Qt API always uses Qt containers. When you receive a `QList`, it will almost
    never be more efficient or convenient to convert it to a standard library container.
    Before calling a method that accepts `QList`, you should populate the input data
    in a `QList` instead of converting it from an STL container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt containers provide unique features, like implicit sharing (we will discuss
    it later in this chapter) or Java-style iterators, and some convenience methods
    STL containers lack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt containers follow Qt's naming scheme and its API conventions, so they look
    more natural in an application that is centered around Qt. For example, `QVector::isEmpty()`
    is more Qt-like than `std::vector::empty()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, Qt containers provide STL-compatible API (for example, the `append()`
    method has the `push_back()` alias) that allows us to replace Qt containers with
    STL ones without changing much of the code. Range based `for` loop and some of
    the standard library algorithms are also compatible with Qt containers. That being
    said, if you need some features that are not available in Qt containers, using
    STL containers is a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: Main container types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you interact with a Qt API method, you don't have much choice on the container
    type, because you need to use the container the method uses. However, generally,
    you are free to choose containers to store your data. Let's go through the main
    Qt containers and learn when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: We will only give a brief overview of Qt containers and won't go into details
    such as the algorithmic complexity of different operations. For most Qt containers,
    there is a similar STL container that we will name. The topic of choosing the
    right container is widely discussed, and it's not hard to find more information
    on it, especially for STL containers. You can also find more information on the
    Container Classes Qt documentation page.
  prefs: []
  type: TYPE_NORMAL
- en: '`QVector` stores items in a continuous region of memory. The items are densely
    packed, meaning that this type is the most memory efficient and cache friendly.
    Its STL equivalent is `std::vector`. `QVector` should be the container of default
    choice, meaning that you should only use a different container if you have a reason
    to do it. `QVector` provides fast lookup by item number, fast on average appending
    items to the end and removing items from the end. Inserting and removing items
    from the beginning or middle of the vector is slow, because it causes all items
    to the right to shift in memory. Using `QVector` is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `QLinkedList` container, as the name implies, implements a linked list.
    Its STL equivalent is `std::list`. As opposed to `QVector`, it provides fast inserting
    and removing items at any location (the beginning, middle, or the end), but slow
    lookup by index, because it needs to iterate over items from the beginning to
    find the item by its index. `QLinkedList` is suitable when you need to insert
    or remove items at the middle of a huge list multiple times. However, note that
    in practice, `QVector` still may sometimes be more performant in this case, because
    `QLinkedList` is not densely packed in memory, which adds some overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '`QSet`, a Qt equivalent of `std::unordered_set`, is an unordered collection
    of unique items. Its advantage is the ability to efficiently add items, remove
    items, and check whether a particular item is present in a collection. The other
    list classes are not able to do the last operation quickly, because they need
    to iterate over all items and compare each item with the argument. Like with any
    other collection, you can iterate over the set''s items, but the iteration order
    is not specified, that is, any item may appear on the first iteration, and so
    on. An example of the `QSet` API is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The last flat collection is `QList`. Using it is currently not recommended,
    except when interacting with methods that accept or produce `QList` objects. Its
    performance and memory efficiency depends on the item type, and the rules that
    define "good" item types are complicated. For a "bad" type, `QList` is represented
    as a vector of `void *`, with each item stored as a separately allocated object
    on the heap. It's possible that `QList` implementation will change in Qt 6, but
    there is no official information about this yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some specialized list containers that provide extra functionality
    for a particular item type:'
  prefs: []
  type: TYPE_NORMAL
- en: The already familiar `QString` class is essentially a vector of `QChar` (16-bit
    Unicode characters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The familiar `QByteArray` is a vector of `char`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QStringList` is a `QList<QString>` with additional convenient operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QBitArray` provides a memory-efficient array of bits with some useful APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, there are two main key-value collections: `QMap<K, T>` and `QHash<K,
    T>`. They allow you to associate a value (or multiple values) of type `T` with
    a key of type `K`. They both provide relatively fast lookup by key. When iterating
    over a `QMap` (similar to `std::map`), the items are sorted by keys, regardless
    of the insertion order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`QHash` (similar to `std::unordered_map`) has very similar APIs to `QMap`,
    but will iterate over items in unspecified order, like `QSet`. You can replace
    `QMap` with `QHash` in the previous example and see that the iteration order will
    change even when running the same program repeatedly. In exchange, `QHash` provides
    faster on-average insertions and lookups by key than `QMap`. You should use `QHash`
    instead of `QMap` if the iteration order doesn''t matter to you.'
  prefs: []
  type: TYPE_NORMAL
- en: An attentive reader may wonder how the code that looks very deterministic can
    produce random results. This randomness was intentionally introduced to protect
    against *algorithmic complexity attacks* on `QHash` and `QSet`. You can read the
    corresponding section of the `QHash` documentation page for more details about
    the attack and ways to configure the randomization.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `QPair<T1, T2>` is a simple class that can hold two values of different
    types, just like `std::pair`. You can use the `qMakePair()` function to make a
    pair out of two values.
  prefs: []
  type: TYPE_NORMAL
- en: Convenience containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the containers described earlier, there are a few containers
    built on top of them that provide APIs and behavior that are more convenient in
    some special cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Container** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `QStack` | A `QVector` implementing the **last in, first out** (**LIFO**)
    structure. It contains the `push()` function for adding items to the stack, the `pop()`
    function for removing the top element, and the `top()` function for reading the
    top element without removing it. |'
  prefs: []
  type: TYPE_TB
- en: '| `QQueue` | A `QList` implementing the **first in, first out** (**FIFO**)
    structure. Use `enqueue()` to append an item to the queue, `dequeue()` to take
    the head item from the queue, and `head()` to read the head item without removing
    it. |'
  prefs: []
  type: TYPE_TB
- en: '| `QMultiMap` | A `QMap` with an API tailored for having multiple values for
    one key. `QMap` already allows us to do it; for example, you can add multiple
    items with one key using the `QMap::insertMulti()` method. However, `QMultiMap`
    renames it to `insert()` and hides the original `QMap::insert()` method that doesn''t
    allow multiple values per key. |'
  prefs: []
  type: TYPE_TB
- en: '| `QMultiHash` | Similar to `QMultiMap`, it''s a `QHash` with a more convenient
    API for storing multiple values per key. |'
  prefs: []
  type: TYPE_TB
- en: '| `QCache` | A key-value storage similar to `QHash` that allows you to implement
    a cache. `QCache` will delete its elements when they weren''t recently used to
    keep the size of cache under the maximum allowed size. Since there is no way to
    know how much space an arbitrary item actually consumes, you can manually specify
    a *cost* for each item and the maximum total cost for a particular `QCache` object.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QContiguousCache` | A flat container that allows you to cache a sublist
    of a large list. This is useful, for example, when implementing a viewer for a
    large table, where reads and writes are likely to happen near the current scroll
    location. |'
  prefs: []
  type: TYPE_TB
- en: It's a good idea to use one of these classes when your task matches their use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Allowed item types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all types can be put in containers. All containers can only hold types that
    provide a default constructor, a copy constructor, and an assignment operator.
    All primitive types and most Qt data types (such as `QString` or `QPointF`) satisfy
    these requirements. Simple structs also can be stored in a container because the
    required constructors and operators are generated for them automatically, as per
    C++ standard.
  prefs: []
  type: TYPE_NORMAL
- en: A particular type usually cannot be put in a container because it doesn't have
    a constructor without arguments or copying this type was deliberately disabled.
    This is actually the case for `QObject` and all its descendants. The usage patterns
    of `QObject` suggest that you usually want to store pointers to a `QObject` to
    refer to it later. If that object was moved to a container or moved within a container,
    the pointer would be invalidated, so there is no copy constructor for these types.
    However, you can put pointers to `QObject` in containers (for example, `QVector<QObject
    *>`) because a pointer is a primitive type that satisfies all requirements. In
    this case, you have to manually ensure that your container will not contain any
    dangling pointers after the objects are deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding restrictions apply to items of lists and *values* of key-value
    collections, but what about their keys? It turns out that the key types have more
    restrictions that depend on the collection type.
  prefs: []
  type: TYPE_NORMAL
- en: '`QMap<K, T>` additionally requires that the key type `K` has the comparison
    operator `operator<` that provides a *total order* (that is, satisfies a particular
    set of axioms). As an exception, pointer types are also allowed as a key type.'
  prefs: []
  type: TYPE_NORMAL
- en: '`QHash<K, T>` and `QSet<K>` require that the `K` type has `operator==`, and
    a `qHash(K key)` function overload exists. Qt provides these overloads for a large
    number of types for which it''s possible, and you can create an overload for your
    custom type if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most significant differences between standard library containers
    and Qt''s is the implicit sharing feature. In STL, creating a copy of a container
    immediately results in a memory allocation and copying the data buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If you don't intend to edit the copy, this is essentially a waste of resources,
    and you want to avoid it. This can be easily done in some cases by providing a
    reference (`const std::vector<int> &`) instead of making a copy. However, sometimes
    it becomes hard to ensure that the reference will be valid long enough, for example,
    if you want to store it in a class field. An alternative way to solve this task
    is to wrap a vector in a `shared_ptr` to explicitly share it between multiple
    objects. This becomes unnecessary when you work with Qt containers and some other
    Qt types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Qt, all main container types implement **implicit sharing** or **copy-on-write**
    semantics. Copying a `QVector` will not result in a new memory allocation until
    either of the two vectors is changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As long as no edits are made to the copy or the original object, the copying
    is very cheap. This allows you to cheaply and easily share constant data between
    objects without cluttering the code with manual management of shared objects.
    This feature is also implemented for `QString`, `QPen`, and many other Qt value
    types. Any copy operation still has some runtime overhead caused by reference
    counting, so you are encouraged to pass references instead of making copies when
    it's easy. However, this overhead is insignificant in most cases, except places
    with heavy computations.
  prefs: []
  type: TYPE_NORMAL
- en: If you like implicit sharing, you can implement it in your own data types using
    `QSharedDataPointer`. Refer to its documentation for the in-depth instructions.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you can just use the containers as if they didn't implement implicit
    sharing, but there are a few cases where you have to be aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: Pointer invalidation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, implicit sharing means that holding any references or pointers to the
    container''s content is disallowed when there is a possibility of changing this
    object or any object that shares the same buffer. The following small example
    illustrates the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We initialized the `x0` variable with the pointer to the first element of the `x`
    vector. However, when we set a new value for that element and then tried to read
    it using the pointer, we got the old value again.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we copied the `x` vector to `y`, the state of two vectors became shared and
    the original buffer was available to both of them. However, when we modified `x`
    using `operator[]`, it became **detached**, that is, a new buffer was allocated
    for it, and `y` retained the original buffer. The `x0` pointer continues to point
    at the original buffer, which is now only available to `y`. If you remove the
    `QVector<int> y = x;` line, the output will change to the expected 42\. The general
    rule is that you should avoid storing pointers or references to the object's content
    while it's changed or shared with another object.
  prefs: []
  type: TYPE_NORMAL
- en: Unnecessary allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next question is what actions on the object trigger the actual allocation
    of a new buffer? Obviously, `x[0] = 42` will trigger an allocation because the
    vector needs a buffer to write the new data to. However, `int i = x[0]` will also
    trigger an allocation if `x` is not declared as a `const` value or reference.
    That happens because in C++ this code triggers the non-const overload of `operator[]`
    if it's available, even though it's not necessary in this case. The vector doesn't
    know whether the requested item will or will not be changed, so it has to assume
    that it will be, and it triggers an allocation before returning a reference to
    the item in the new buffer.
  prefs: []
  type: TYPE_NORMAL
- en: The same issue takes effect when using other methods that have const and non-const
    overloads, for example, `begin()` or `data()`. The range-based `for` loop also
    calls `begin()`, so it will also detach if you iterate over a non-const value.
  prefs: []
  type: TYPE_NORMAL
- en: If you explicitly declare the container variable as const (for example, `const
    QVector<int> y` or `const QVector<int> &y`), the non-const methods will not be
    available, and it will not be possible to trigger an allocation using this variable.
    An alternative solution is to use special method aliases that are only available
    for const versions, such as `at()` for `operator=`, `constBegin()` for `begin()`,
    and `constData()` for `data()`. This solution is not usable with range-based `for`
    loop, though.
  prefs: []
  type: TYPE_NORMAL
- en: Range-based for and Qt foreach macro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt provides the `foreach` macro for iterating over Qt containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This macro was available long before the range-based `for` loop made it into
    the C++ standard, so it's still very common in Qt code, and you should be familiar
    with it. The `foreach` loop always creates a temporary constant copy of the iterated
    object. Since it uses implicit sharing, this is very cheap. If you edit `x` while
    iterating over it, the changes will not affect the values of `i` because the iteration
    uses a copy, but this also means that such an operation is safe. Note that when
    using range-based `for` loop, STL-style iterators, or Java-style iterators, editing
    the same container you're iterating over is generally not safe. For example, changing
    item values may be permitted, but deleting an item may result in undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how range-based `for` loop can cause a deep copy of the containers.
    The `foreach` macro by itself will never cause a deep copy. However, if you edit
    the container while iterating over it, this will result in a deep copy, because
    two versions of data have to be stored somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the range-based `for` loop, you should be careful not to pass a
    reference to a temporary object. For example, this code looks legitimate, but
    it results in undefined behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We created a temporary `QString` object and called its `replace()` method.
    This method'' s return type is `QString &`, so it doesn''t own the string''s data.
    If we immediately assigned this value to an owning variable, it would be correct
    because the life of the original temporary `QString` lasts until the end of the
    full expression (in this case, the assignment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: However, the temporary object in the original example doesn't live until the
    end of the `for` loop, so this will result in a use-after-free bug. The `foreach`
    version of this code would contain an implicit assignment to a variable, so it
    would be correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the macro nature of `foreach` is its disadvantage. For example,
    the following code does not compile because the item type contains a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The error is "macro `Q_FOREACH` passed 3 arguments, but takes just 2". To fix
    this issue, you have to create a `typedef` for the item type.
  prefs: []
  type: TYPE_NORMAL
- en: Since C++11, range-based `for` loop is a native, clean alternative to `foreach`,
    so we suggest that you prefer the native construct over the macro, but keep in
    mind the pitfalls we described.
  prefs: []
  type: TYPE_NORMAL
- en: Data storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When implementing games, you will often have to work with persistent data; you
    will need to store the saved game data, load maps, and so on. For that, you have
    to learn about the mechanisms that let you use the data stored on digital media.
  prefs: []
  type: TYPE_NORMAL
- en: Files and devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic and low-level mechanism that is used to access data is to save
    and load it from the files. While you can use the classic file access approaches
    provided by C and C++, such as `stdio` or `iostream`, Qt provides its own file
    abstraction that hides platform-dependent details and provides a clean API that
    works across all platforms in a uniform manner.
  prefs: []
  type: TYPE_NORMAL
- en: The two basic classes that you will work with when using files are `QDir` and
    `QFile`. The former represents the contents of a directory, lets you traverse
    filesystems, creates and remove directories, and finally, accesses all files in
    a particular directory.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traversing directories with `QDir` is really easy. The first thing to do is
    to have an instance of `QDir` in the first place. The easiest way to do this is
    to pass the directory path to the `QDir` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Qt handles file paths in a platform-independent way. Even though the regular
    directory separator on Windows is a backward slash character (`\`) and on other
    platforms it is the forward slash (`/`), Qt internally always uses the forward
    slash, and paths returned by most Qt methods never contain backward slashes. You
    can always use forward slashes when passing paths to Qt methods, even on Windows.
    If you need to convert the Qt's path representation to the native form (for example,
    for passing it to the standard library or a third-party library), you can use
    `QDir::toNativeSeparators()`. `QDir::fromNativeSeparators()`  to perform the inverse
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt provides a number of static methods to access some special directories.
    The following table lists these special directories and functions that access
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Access function** | **Directory** |'
  prefs: []
  type: TYPE_TB
- en: '| `QDir::current()` | The current working directory |'
  prefs: []
  type: TYPE_TB
- en: '| `QDir::home()` | The home directory of the current user |'
  prefs: []
  type: TYPE_TB
- en: '| `QDir::root()` | The root directory—usually `/` for Unix and `C:\` for Windows
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QDir::temp()` | The system temporary directory |'
  prefs: []
  type: TYPE_TB
- en: The `QStandardPaths` class provides information about other standard locations
    present in the system. For example, `QStandardPaths::writableLocation(QStandardPaths::MusicLocation)`
    returns path to the user's music folder.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the `QStandardPaths::StandardLocation` enum documentation for the list
    of available locations.
  prefs: []
  type: TYPE_NORMAL
- en: When you already have a valid `QDir` object, you can start moving between directories.
    To do that, you can use the `cd()` and `cdUp()` methods. The former moves to the
    named subdirectory, while the latter moves to the parent directory. You should
    always check that these commands were successful. If they return `false`, your
    `QDir` object will remain in the same directory!
  prefs: []
  type: TYPE_NORMAL
- en: 'To list files and subdirectories in a particular directory, you can use the
    `entryList()` method, which returns a list of entries in the directory that match
    the criteria passed to `entryList()`. The `filters` argument takes a list of flags
    that correspond to the different attributes that an entry needs to have to be
    included in the result. The most useful flags are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Filter** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `QDir::Dirs`, `QDir::Files`, `QDir::Drives` | List directories, files, or
    Windows drives. You should specify at least one of these filters to get any results.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QDir::AllEntries` | List directories, files, and drives. This is a shortcut
    for `Dirs &#124; Files &#124; Drives`. |'
  prefs: []
  type: TYPE_TB
- en: '| `QDir::AllDirs` | List directories even if they don''t match the name filters.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `QDir::NoDotAndDotDot` | Don''t list `.` (current directory) and `..` (parent
    directory) entries. If `Dirs` flag is present and `NoDotAndDotDot` is not, these
    entries will always be listed. |'
  prefs: []
  type: TYPE_TB
- en: '| `QDir::Readable`, `QDir::Writable`, `QDir::Executable` | List only entries
    that can be read, written to, or executed. |'
  prefs: []
  type: TYPE_TB
- en: '| `QDir::Hidden`, `QDir::System` | List hidden files and system files. If these
    flags are not specified, hidden and system flags will not be listed. |'
  prefs: []
  type: TYPE_TB
- en: 'The `sort` argument of `entryList()` allows you to choose the ordering of the
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flag** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `QDir::Unsorted` | The order of entries is undefined. It''s a good idea to
    use it if the order doesn''t matter to you, since it may be faster. |'
  prefs: []
  type: TYPE_TB
- en: '| `QDir::Name`, `QDir::Time`, `QDir::Size`, `QDir::Type` | Sort by appropriate
    entry attributes. |'
  prefs: []
  type: TYPE_TB
- en: '| `QDir::DirsFirst`, `QDir::DirsLast` | Determines whether directories should
    be listed before or after files. If neither flag is specified, directories will
    be mixed with files in the output. |'
  prefs: []
  type: TYPE_TB
- en: '| `QDir::Reversed` | Reverses the order. |'
  prefs: []
  type: TYPE_TB
- en: 'Additionally, there is an overload of `entryList()` that accepts a list of
    file name patterns in the form of `QStringList` as its first parameter. Here''s
    an example call that returns all JPEG files in the directory sorted by size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Besides `entryList()`, there is the `entryInfoList()` method that wraps each
    returned file name in a `QFileInfo` object that has many convenient functions.
    For example, `QFileInfo::absoluteFilePath()` returns the absolute path to the
    file, and `QFileInfo::suffix()` returns the extension of the file.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to traverse directories recursively (for example, for finding all
    files in all subdirectories), you can use the `QDirIterator` class.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you know the path to a file (for example, using `QDir::entryList()`, `QFileDialog::getOpenFileName()`,
    or some external source), you can pass it to `QFile` to receive an object that
    acts as a handle to the file. Before the file contents can be accessed, the file
    needs to be opened using the `open()` method. The basic variant of this method
    takes a mode in which we need to open the file. The following table explains the
    modes that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mode** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadOnly` | This file can be read from. |'
  prefs: []
  type: TYPE_TB
- en: '| `WriteOnly` | This file can be written to. |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadWrite` | This file can be read from and written to. |'
  prefs: []
  type: TYPE_TB
- en: '| `Append` | All data writes will be written at the end of the file. |'
  prefs: []
  type: TYPE_TB
- en: '| `Truncate` | If the file is present, its content is deleted before we open
    it. |'
  prefs: []
  type: TYPE_TB
- en: '| `Text` | When reading, all line endings are transformed to `\n`. When writing,
    all `\n` symbols are transformed to the native format (for example, `\r\n` on
    Windows or `\n` on Linux). |'
  prefs: []
  type: TYPE_TB
- en: '| `Unbuffered` | The flag prevents the file from being buffered. |'
  prefs: []
  type: TYPE_TB
- en: 'The `open()` method returns `true` or `false`, depending on whether the file
    was opened or not. The current status of the file can be checked by calling `isOpen()`
    on the file object. Once the file is open, it can be read from or written to,
    depending on the options that are passed when the file is opened. Reading and
    writing is done using the `read()` and `write()` methods. These methods have a
    number of overloads, but we suggest that you focus on using those variants that
    accept or return the already familiar `QByteArray` objects, because they manage
    the memory automatically. If you are working with plain text, then a useful overload
    for `write` is the one that accepts the text directly as input. Just remember
    that the text has to be null terminated. When reading from a file, Qt offers a
    number of other methods that might come in handy in some situations. One of these
    methods is `readLine()`, which tries to read from the file until it encounters
    a new line character. If you use it along with the `atEnd()` method that tells
    you whether you have reached the end of the file, you can realize the line-by-line
    reading of a text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Another useful method is `readAll()`, which simply returns the file content,
    starting from the current position of the file pointer until the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: You have to remember, though, that when using these helper methods, you should
    be really careful if you don't know how much data the file contains. It might
    happen that when reading line by line or trying to read the whole file into memory
    in one step, you exhaust the amount of memory that is available for your process.
    If you only intend to work with small files that fit into memory, you can check
    the size of the file by calling `size()` on the `QFile` instance and abort if
    the file is too large. If you need to handle arbitrary files, however, you should
    process the file's data in steps, reading only a small portion of bytes at a time.
    This makes the code more complex but allows us to manage the available resources
    better.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you require constant access to the file, you can use the `map()` and `unmap()`
    calls that add and remove mappings of the parts of a file to a memory address
    that you can then use like a regular array of bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The mapping will automatically be removed when the `QFile` object is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QFile` is really a descendant class of `QIODevice` ("input/output device"),
    which is a Qt interface used to abstract entities related to reading and writing
    of blocks of data. There are two types of devices: sequential and random access
    devices. `QFile` belongs to the latter group; it has the concepts of start, end,
    size, and current position that can be changed by the user with the `seek()` method.
    Sequential devices, such as sockets and pipes, represent streams of data—there
    is no way to rewind the stream or check its size; you can only keep reading the
    data sequentially—piece by piece, and you can check how far away you currently
    are from the end of data. We will work with such devices in [Chapter 7](b2ab510e-2a42-4ccb-b121-ab4ce5541893.xhtml),
    *Networking*.'
  prefs: []
  type: TYPE_NORMAL
- en: All I/O devices can be opened and closed. They all implement the `open()`, `read()`,
    and `write()` interfaces. Writing to the device queues the data for writing; when
    the data is actually written, the `bytesWritten()` signal is emitted that carries
    the amount of data that was written to the device. If more data becomes available
    in the sequential device, it emits the `readyRead()` signal, which informs you
    that if you call `read` now, you can expect to receive some data from the device.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – Implementing a device to encrypt data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's implement a really simple device that encrypts or decrypts the data that
    is streamed through it using a very simple algorithm—the Caesar cipher. When encrypting,
    it shifts each character in the plaintext by a number of characters defined by
    the key. It does the reverse when decrypting. Thus, if the key is `2` and the
    plaintext character is `a`, the ciphertext becomes `c`. Decrypting `z` with the
    key `4` will yield the value `v`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new empty project by selecting the Empty qmake Project template
    from the Other Project category. Next, add a `main.cpp` file and a new `CaesarCipherDevice`
    class derived from `QIODevice`. The basic interface of the class will accept an
    integer key and set an underlying device that serves as the source or destination
    of data. This is all simple coding that you should already understand, so it shouldn''t
    need any extra explanation, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing is to ensure that the device cannot be used if there is no device
    to operate on (that is, when `m_baseDevice == nullptr`). For this, we have to
    reimplement the `QIODevice::open()` method and return `false` when we want to
    prevent operating on our device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The method accepts the mode that the user wants to open the device with. We
    perform an additional check to verify that the base device was opened in the same
    mode before calling the base class implementation that will mark the device as
    open.
  prefs: []
  type: TYPE_NORMAL
- en: It's a good idea to call `QIODevice::setErrorString` to let the user know about
    an error. Additionally, you can use `qWarning("message")` to print a warning to
    the console when an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have a fully functional device, we still need to implement the two protected
    pure virtual methods, which do the actual reading and writing. These methods are
    called by Qt from other methods of the class when needed. Let''s start with `writeData()`,
    which accepts a pointer to a buffer containing the data and size equal to that
    of a buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a local byte array and resize it to the length of the input.
    Then, we iterate bytes of the input, add the value of the key to each byte (which
    effectively performs the encryption) and put it in the byte array. Finally, we
    try to write the byte array to the underlying device. Before informing the caller
    about the amount of data that was really written, we emit a signal that carries
    the same information.
  prefs: []
  type: TYPE_NORMAL
- en: The last method we need to implement is the one that performs decryption by
    reading from the base device and adding the key to each cell of the data. This
    is done by implementing `readData()`, which accepts a pointer to the buffer that
    the method needs to write to and the size of the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is quite similar to that of `writeData()`, except that we are subtracting
    the key value instead of adding it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: First, we try to read `maxlen` bytes from the underlying device and store the
    data in a byte array. Note that the byte array can contain fewer bytes than `maxlen`
    (for example, if we reached the end of the file) but it can't contain more. Then,
    we iterate the array and set subsequent bytes of data buffer to the decrypted
    value. Finally, we return the amount of data that was really read.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple `main()` function that can test the class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We use the `QBuffer` class that implements the `QIODevice` API and acts as an
    adapter for `QByteArray` or `QString`.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created an encryption object and set its key to `3`. We also told it to use
    a `QBuffer` instance to store the processed content. After opening it for writing,
    we sent some data to it that gets encrypted and written to the base device. Then,
    we created a similar device, passing the same buffer again as the base device,
    but now, we open the device for reading. This means that the base device contains
    ciphertext. After this, we read all data from the device, which results in reading
    data from the buffer, decrypting it, and returning the data so that it can be
    written to the debug console.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – A GUI for the Caesar cipher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can combine what you already know by implementing a full-blown GUI application
    that is able to encrypt or decrypt files using the Caesar cipher `QIODevice` class
    that we just implemented. Remember that `QFile` is also `QIODevice`, so you can
    pass its pointer directly to `setBaseDevice()`.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a starting point for you. The `QIODevice` API is quite rich and
    contains numerous methods that are virtual, so you can reimplement them in subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Text streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much of the data produced by computers nowadays is based on text. You can create
    such files using a mechanism that you already know—opening `QFile` to write, converting
    all data into strings using `QString::arg()`, optionally encoding strings using
    `QTextCodec`, and dumping the resulting bytes to the file by calling `write`.
    However, Qt provides a nice mechanism that does most of this automatically for
    you in a way similar to how the standard C++ `iostream` classes work. The `QTextStream`
    class operates on any `QIODevice` API in a stream-oriented way. You can send tokens
    to the stream using the `<<` operator, where they get converted into strings,
    separated by spaces, encoded using a codec of your choice, and written to the
    underlying device. It also works the other way round; using the `>>` operator,
    you can stream data from a text file, transparently converting it from strings
    to appropriate variable types. If the conversion fails, you can discover it by
    inspecting the result of the `status()` method—if you get `ReadPastEnd` or `ReadCorruptData`,
    it means that the read has failed.
  prefs: []
  type: TYPE_NORMAL
- en: While `QIODevice` is the main class that `QTextStream` operates on, it can also
    manipulate `QString` or `QByteArray`, which makes it useful for us to compose
    or parse strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `QTextStream` is simple—you just pass a device to its constructor, and
    you''re good to go. The  `QTextStream` object will read to or write from that
    device. By default, `QTextStream` uses the encoding specified by the current locale,
    but if it encounters a UTF-16 or UTF-32 BOM (byte order mark), it will switch
    to the encoding specified by the BOM. The stream accepts strings and numerical
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from directing content into the stream, the stream can accept a number
    of manipulators, such as `endl`, which have a direct or indirect influence on
    how the stream behaves. For instance, you can tell the stream to display a number
    as decimal and another as hexadecimal with uppercase digits using the following
    code (highlighted in the code are all manipulators):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not the end of the capabilities of `QTextStream`. It also allows us
    to display data in a tabular manner by defining column widths and alignments.
    Consider a game player record defined by the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you have a set of records for players stored in a `QVector<Player>
    players` variable. Let''s dump such information into a file in a tabular manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The program creates a file that should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'One last thing about `QTextStream` is that it can operate on standard C file
    structures, which makes it possible for us to use `QTextStream` to, for example,
    write to `stdout` or read from `stdin`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Binary streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More than often, we have to store object data in a device-independent way so
    that it can be restored later, possibly on a different machine with a different
    data layout and so on. In computer science, this is called **serialization**.
    Qt provides several serialization mechanisms and now we will take a brief look
    at some of them.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at `QTextStream` from a distance, you will note that what it really
    does is serialize and deserialize data to a text format. Its close cousin is the
    `QDataStream` class that handles serialization and deserialization of arbitrary
    data to a binary format. It uses a custom data format to store and retrieve data
    from `QIODevice` in a platform-independent way. It stores enough data so that
    a stream written on one platform can be successfully read on a different platform.
  prefs: []
  type: TYPE_NORMAL
- en: '`QDataStream` is used in a similar fashion as `QTextStream`—the `<<` and `>>`
    operators are used to redirect data into or out of the stream. The class supports
    most of the built-in Qt data types so that you can operate on classes such as
    `QColor`, `QPoint`, or `QStringList` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If you want to serialize custom data types, you can teach `QDataStream` to do
    that by implementing proper redirection operators.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – Serialization of a custom structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform another small exercise by implementing functions that are required
    to use `QDataStream` to serialize the same simple structure that contains the
    player information that we used for text streaming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For this, two functions need to be implemented, both returning a `QDataStream`
    reference that was taken earlier as an argument to the call. Apart from the stream
    itself, the serialization operator accepts a constant reference to the class that
    is being saved. The most simple implementation just streams each member into the
    stream and returns the stream afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Complementary to this, deserializing is done by implementing a redirection
    operator that accepts a mutable reference to the structure that is filled by data
    that is read from the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Again, at the end, the stream itself is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use `QDataStream` to write our object to any I/O device (for example,
    a file, a buffer, or a network socket):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading the object back is just as simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We provided two standalone functions that define redirection operators for the
    `Player` class to and from a `QDataStream` instance. This lets your class be serialized
    and deserialized using mechanisms offered and used by Qt.
  prefs: []
  type: TYPE_NORMAL
- en: XML streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'XML has become one of the most popular standards that is used to store hierarchical
    data. Despite its verbosity and difficulty to read by human eye, it is used in
    virtually any domain where data persistency is required, as it is very easy to
    read by machines. Qt provides support for reading and writing XML documents in
    two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: The Qt Xml module provides access using the **Document Object Model** (**DOM**)
    standard with classes such as `QDomDocument`, `QDomElement`, and others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Qt Core module contains `QXmlStreamReader` and `QXmlStreamWriter` classes
    that implement streaming API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the downsides of `QDomDocument` is that it requires us to load the whole
    XML tree into the memory before parsing it. Additionally, Qt Xml is not actively
    maintained. Therefore, we will focus on the streaming approach provided by Qt
    Core.
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, downsides of the DOM approach are compensated for by its
    ease of use as compared to a streamed approach, so you can consider using it if
    you feel that you have found the right task for it. If you want to use the DOM
    access to XML in Qt, remember to enable the `QtXml` module in your applications
    by adding a `QT += xml` line in the project configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – Implementing an XML parser for player data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a parser to fill data that represents players
    and their inventory in an RPG game. First, let''s create the types that will hold
    the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to use the `Q_ENUM` macro on our enum, because it will allow us to easily
    convert enum values to strings and back, which is very useful for serialization.
    Since `InventoryItem` is not a `QObject`, we need to add a `Q_GADGET` macro to
    the beginning of the class declaration to make the `Q_ENUM` macro work. Think
    of `Q_GADGET` as of a lightweight variation of `Q_OBJECT` that enables some of
    its features but not others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `typeByName()` method will receive a string and return the corresponding
    enum variant. We can implement this method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The implementation may look complicated, but it's much less error-prone than
    manually writing a bunch of `if` statements to choose the correct return value
    manually. First, we use the `QMetaEnum::fromType<T>()` template method to get
    the `QMetaEnum` object corresponding to our `enum`. The `keyToValue()` method
    of this object performs the conversion that we need, but it needs to be accompanied
    with a few conversions.
  prefs: []
  type: TYPE_NORMAL
- en: You can note that we are using a class called `QStringRef`. It represents a
    string reference—a substring in an existing string—and is implemented in a way
    that avoids expensive string construction; therefore, it is very fast. The similar
    `std::string_view` type was added to the standard library in C++17\. We use it
    as the argument type because `QXmlStreamReader` will provide strings in this format.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `keyToValue()` method expects a `const char *` argument, so we
    use the `toLatin1()` method to convert our string to `QByteArray`, and then use
    `constData()` to get the `const char *` pointer to its buffer. Finally, we use
    `static_cast` to convert the result from `int` to our `enum` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the following XML document somewhere. We will use it to test whether the
    parser can read it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a class called `PlayerInfoReader` that will wrap `QXmlStreamReader`
    and expose a parser interface for the `PlayerInfo` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The class constructor accepts a `QIODevice` pointer that the reader will use
    to retrieve data as it needs it. The constructor is trivial, as it simply passes
    the device to the `reader` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we go into parsing, let''s prepare some code to help us with the process.
    First, let''s add an enumeration type to the class that will list all the possible
    tokens—tag names that we want to handle in the parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Then, just like we did in the `InventoryItem` class, we use the `Q_GADGET` and
    `Q_ENUM` macros and implement the `PlayerInfoReader::tokenByName()` convenience
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the entry point of the parsing process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: First, we call `readNextStartElement()` on the reader to make it find the starting
    tag of the first element, and if it is found, we check whether the root tag of
    the document is what we expect it to be. If not, we return a default-constructed
    `PlayerInfo`, indicating that no data is available.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a `PlayerInfo` variable. We iterate all the starting sub-elements
    in the current tag (`PlayerInfo`). For each of them, we check whether it is a
    `Player` tag and call `readPlayer()` to descend into the level of parsing data
    for a single player. Otherwise, we call `skipCurrentElement()`, which fast-forwards
    the stream until a matching ending element is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: The other methods in this class will usually follow the same pattern. Each parsing
    method iterates all the starting elements, handling those it knows and ignoring
    all others. Such an approach lets us maintain forward compatibility, since all
    tags introduced in the newer versions of the document are silently skipped by
    an older parser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of `readPlayer()` is similar; however, it is more complicated,
    as we also want to read data from the attributes of the `Player` tag itself. Let''s
    take a look at the function piece by piece. First, we get the list of attributes
    associated with the opening tag and ask for values of the two attributes that
    we are interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we loop all child tags and fill the `Player` structure based on
    the tag names. By converting tag names to tokens, we can use a `switch` statement
    to neatly structure the code in order to extract information from different tag
    types, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If we are interested in the textual content of the tag, we can use `readElementText()`
    to extract it. This method reads until it encounters the closing tag and returns
    the text contained within it. For the `Inventory` tag, we call the dedicated `readInventory()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `Location` tag, the code is more complex than earlier as we again descend
    into reading child tags, extracting the required information and skipping all
    unknown tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Next, we again skip the tags that didn't match any known tokens. At the end
    of `readPlayer()`, we simply return the populated `Player` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method is similar in structure to the previous one—iterate all the
    tags, skip everything that we don''t want to handle (everything that is not an
    inventory item), fill the inventory item data structure, and append the item to
    the list of already parsed items, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In `main()` of your project, write some code that will check whether the parser
    works correctly. You can use the `qDebug()` statements to output the sizes of
    lists and contents of variables. Take a look at the following code for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code you just wrote implements a full top-down parser of the XML data. First,
    the data goes through a tokenizer, which returns identifiers that are much easier
    to handle than strings. Then, each method can easily check whether the token it
    receives is an acceptable input for the current parsing stage. Based on the child
    token, the next parsing function is determined and the parser descends to a lower
    level until there is nowhere to descend to. Then, the flow goes back up one level
    and processes the next child. If, at any point, an unknown tag is found, it gets
    ignored. This approach supports a situation when a new version of software introduces
    new tags to the file format specification, but an old version of software can
    still read the file by skipping all the tags that it doesn't understand.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero – An XML serializer for player data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to parse XML data, you can create the complementary part—a
    module that will serialize `PlayerInfo` structures into XML documents using `QXmlStreamWriter`.
    Use methods such as `writeStartDocument()`, `writeStartElement()`, `writeCharacters()`,
    and `writeEndElement()` for this. Verify that the documents saved with your code
    can be parsed with what we implemented together.
  prefs: []
  type: TYPE_NORMAL
- en: QVariant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QVariant` is a class that can hold values of multiple types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: When you assign a value to a `QVariant` object, that value is stored inside
    along with the type information. You can use its `type()` method to find out which
    type of value it holds. The default constructor of `QVariant` creates an invalid
    value that you can detect using the `isValid()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`QVariant` supports a great amount of types, including Qt value types such
    as `QDateTime`, `QColor`, and `QPoint`. You can also register your own types to
    store them in `QVariant`. One of the most powerful features of `QVariant` is the
    ability to store a collection or a hierarchy of values. You can use the `QVariantList` type
    (which is a `typedef` for `QList<QVariant>`) to create a list of `QVariant` objects,
    and you can actually put the whole list into a single `QVariant` object! You''ll
    be able to retrieve the list and examine individual values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can use `QVariantMap` or `QVariantHash` to create a key-value
    collection with `QString` keys and `QVariant` values. Needless to say, you can
    store such a collection in a single `QVariant` as well. This allows you to construct
    a hierarchy with unlimited depth and arbitrary structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, `QVariant` is a pretty powerful class, but how can we use it
    for serializing? For a start, `QVariant` is supported by `QDataStream`, so you
    can use the binary serialization described earlier to serialize and restore any `QVariant` value
    you can construct. For example, instead of putting each field of your structure
    into `QDataStream`, you can put them into a `QVariantMap` and then put it into
    the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Loading the data is also straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This approach allows you to store arbitrary data in an arbitrary location. However,
    you can also use `QVariant` along with `QSettings` to conveniently store the data
    in an appropriate location.
  prefs: []
  type: TYPE_NORMAL
- en: QSettings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While not strictly a serialization issue, the aspect of storing application
    settings is closely related to the described subject. A Qt solution for this is
    the `QSettings` class. By default, it uses different backends on different platforms,
    such as system registry on Windows or INI files on Linux. The basic use of `QSettings` is
    very easy—you just need to create the object and use `setValue()` and `value()` to
    store and load data from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing you need to remember is that it operates on `QVariant`, so the
    return value needs to be converted to the proper type if needed, like `toInt()` in
    the preceding code. A call to `value()` can take an additional argument that contains
    the value to be returned if the requested key is not present in the map. This
    allows you to handle default values, for example, in a situation when the application
    is first started and the settings are not saved yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: If you don't specify the default value, an invalid `QVariant` will be returned
    when nothing is stored, and you can check for that using the `isValid()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for the default settings location to be correct, you need to set the
    organization name and the application name. They determine where exactly `QSettings` store
    data by default and ensure that the stored data will not conflict with another
    application. This is typically done at the beginning of your `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Settings hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest scenario assumes that settings are "flat", in that all keys are
    defined on the same level. However, this does not have to be the case—correlated
    settings can be put into named groups. To operate on a group, you can use the `beginGroup()` 
     and  `endGroup()` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'When using this syntax, you have to remember to end the group after you are
    done with it. An alternative way to do the same thing is to pass the group name
    directly to invocation of `value()`, using `/` to separate it from the value name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: You can create multiple nested groups by calling `beginGroup()` multiple times
    (or, equivalently, writing multiple slashes in the value name).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way to introduce a non-flat structure to `QSettings`. It can
    handle composite `QVariant` values—`QVariantMap` and `QVariantList`. You can simply
    convert your data to a `QVariant`, much like we converted it to a `QJsonValue` earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This `QVariant` value can be passed to `QSettings::setValue()`. Of course, you
    will need to implement the inverse operation as well. More than that, nothing
    stops you from converting your data to JSON and saving it to `QSettings` as a `QByteArray`.
    However, these approaches may be slower than proper serialization, and the resulting
    settings file will be hard to edit manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Various Qt classes have methods that are meant to be used with `QSettings` to
    easily save a set of properties. For example, `QWidget::saveGeometry()`  and 
    `QWidget::restoreGeometry()` helpers allow you to save the window''s position
    and size to `QSettings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, multiple widget classes have `saveState()` and `restoreState()` methods
    to save information about the widget''s state:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QMainWindow` can save positions of toolbars and dock widgets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QSplitter` can save positions of its handles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QHeaderView` can save sizes of the table''s rows or columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QFileDialog` can save the dialog''s layout, history, and current directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods are a great way to preserve all changes the user has made in your
    application's interface.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the settings location and format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The constructor of the `QSettings` class has a number of overloads that allow
    you to change the location where the data will be stored by a particular `QSettings` object,
    instead of using the default location. First, you can override the organization
    name and the application name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can use the system-wide storage location by passing  `QSettings::SystemScope `
    as the `scope` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `QSettings` will try to read the settings for all users and then
    fall back to the user-specific location. Note that a system-wide location may
    not be writable, so using `setValue()` on it won't have the desired effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also opt out of the preferred format detection using the  `QSettings::setDefaultFormat()` function.
    For example, use the following code on Windows to disable using the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there is one more option available for total control of where the
    settings data resides—tell the constructor directly where the data should be located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: If you pass `QSettings::NativeFormat` to this constructor, the meaning of the
    path will depend on the platform. For example, it will be interpreted as a registry
    path on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Since you can use `QSettings` to read and write to an arbitrary INI file, it's
    a convenient and easy way to implement serialization of an object to the INI format,
    which is suitable in simple cases.
  prefs: []
  type: TYPE_NORMAL
- en: '`QSettings` also allows you to register your own formats so that you can control
    the way your settings are stored, for example, by storing them using XML or by
    adding on-the-fly encryption. This is done using `QSettings::registerFormat()`,
    where you need to pass the file extension and two pointers to functions that perform
    reading and writing of the settings, respectively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: JSON files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON** stands for "JavaScript Object Notation", which is a popular lightweight
    textual format that is used to store object-oriented data in a human-readable
    form. It comes from JavaScript where it is the native format used to store object
    information; however, it is commonly used across many programming languages and
    a popular format for web data exchange. Qt Core supports JSON format, as we''ll
    see in the following code. A simple JSON-formatted definition looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'JSON objects can contain values of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| bool | A boolean value (`true` or `false`). |'
  prefs: []
  type: TYPE_TB
- en: '| double | A number value (for example, `42.1`). |'
  prefs: []
  type: TYPE_TB
- en: '| string | A quoted string (for example, `"Qt"`). |'
  prefs: []
  type: TYPE_TB
- en: '| array | A collection of values of any type enclosed in square brackets (for
    example, `[42.1, "Qt"]`). |'
  prefs: []
  type: TYPE_TB
- en: '| object | A set of key-value pairs enclosed in braces. Keys are strings, and
    values can be of any type (for example, `{ "key1": 42.1, "key2": [42.1, "Qt"]
    }`). |'
  prefs: []
  type: TYPE_TB
- en: '| null | A special value (`null`) indicating lack of data. |'
  prefs: []
  type: TYPE_TB
- en: 'A proper **JSON document** must have either an array or an object at the top
    level. In the preceding example, we had an object containing three properties:
    name, age, and inventory. The first two properties are simple values, and the
    last property is an array that contains two objects with two properties each.'
  prefs: []
  type: TYPE_NORMAL
- en: Qt can create and read JSON descriptions using the `QJsonDocument` class. A
    document can be created from the UTF-8-encoded text using the `QJsonDocument::fromJson()`
    static method, and can later be stored in a textual form again using `toJson()`.
    Once a JSON document is created, you can check whether it represents an object
    or an array using one of the `isArray()` and `isObject()` calls. Then, the document
    can be transformed into `QJsonArray` or `QJsonObject` using the `array()` or `object()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Since the structure of JSON closely resembles that of `QVariant` (which can
    also hold key-value pairs using `QVariantMap` and arrays using `QVariantList`),
    conversion methods `QJsonDocument::fromVariant()` and `QJsonDocument::toVariant()`
    also exist.
  prefs: []
  type: TYPE_NORMAL
- en: '`QJsonObject` is an iterable type that can be queried for a list of keys (using
    `keys()`) or asked for a value of a specific key (with a `value()` method or `operator[]`).
    Values are represented using the `QJsonValue` class, which can store any of the
    value types listed earlier. New properties can be added to the object using the
    `insert()` method that takes a key as a string, and a value can be added as `QJsonValue`.
    The existing properties can be removed using `remove()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`QJsonArray` is also an iterable type that contains a classic list API; it
    contains methods such as `append()`, `insert()`, `removeAt()`, `at()`, and `size()`
    to manipulate entries in the array, again working on `QJsonValue` as the item
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – The player data JSON serializer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next exercise is to create a serializer of the same `PlayerInfo` structure
    as we used for the XML exercise, but this time the destination data format will
    be JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a `PlayerInfoJson` class and give it an interface similar
    to the one shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'All that is really required is to implement the `playerInfoToJson` method.
    Generally, we need to convert our `PlayerInfo` data to a `QJsonArray` and then
    use `QJsonDocument` to encode it as JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s start implementing the `toJson()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the structure is really a list of players, we can iterate over it, convert
    each player to a `QJsonValue`, and append the result to `QJsonArray`. Having this
    function ready, we can descend a level and implement an overload for `toJson()`
    that takes a `Player` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we are using `QJsonObject` as our base type, since we want to associate
    values with keys. For each key, we use the index operator to add entries to the
    object. The position key holds a `QPoint` value, which is not a valid JSON value,
    so we convert the point to a `QJsonObject` with two keys (`x` and `y`) using the
    C++11 initializer list. The situation is different with the inventory—again, we
    have to write an overload for `toJson` that will perform the conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is almost identical to the one handling `PlayerInfo` objects, so let''s
    focus on the last overload of `toVariant`—the one that accepts `Item` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'There is not much to comment here—we add all keys to the object, converting
    the item type to a string. For this, we have to add the static `InventoryItem::typeToName()`
    method that is the reverse of `typeByName()`, that is, it takes a enum variant
    and outputs its name as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty much a wrapper over the `QMetaEnum::valueToKey()` method that
    does all the magic that wouldn't be possible without Qt.
  prefs: []
  type: TYPE_NORMAL
- en: The serializer is complete! Now you can use `PlayerInfoJson::playerInfoToJson()`
    to convert `PlayerInfo` into a `QByteArray` containing the JSON. It's suitable
    for writing it to a file or sending it over the network. However, to make it more
    useful, we need to implement the reverse operation (deserialization).
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – Implementing a JSON parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s extend the `PlayerInfoJSON` class and equip it with a `playerInfoFromJson()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we read the document and check whether it is valid and holds the expected
    array. Upon failure, an empty structure is returned; otherwise, we iterate over
    the received array and convert each of its elements to an object. Similar to the
    serialization example, we create a helper function for each complex item of our
    data structure. Thus, we write a new `playerFromJson()` method that converts `QJsonObject`
    to a `Player`, that is, performs a reverse operation as compared to `toJson(Player)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we used `operator[]` to extract data from `QJsonObject`,
    and then we used different functions to convert the data to the desired type.
    Note that in order to convert to `QPoint`, we first converted it to `QJsonObject`
    and then extracted the values before using them to build `QPoint`. In each case,
    if the conversion fails, we get a default value for that type (for example, an
    empty string or a zero number). To read the inventory, we employ another custom
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'What remains is to implement `inventoryItemFromJson()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, our `typeByName()` function requires `QStringRef`, not `QString`.
    We can fix this by adding a couple of overloads and forwarding them to a single
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The class that was implemented can be used for bidirectional conversion between
    `Item` instances and a `QByteArray` object, which contains the object data in
    the JSON format. We didn't do any error checking here; instead, we relied on Qt's
    rule that an error results in a sensible default value.
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to perform error checking? The most straightforward solution
    in this case is to use exceptions, as they will automatically propagate from the
    multiple nested calls to the caller's location. Ensure that you catch any exceptions
    you throw, or the application will terminate. A more Qt-like solution is to create
    a `bool *ok` argument in all methods (including internal ones) and set the boolean
    value to `false` in case of any error.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1\. What is the closest equivalent of `std::string` in Qt?
  prefs: []
  type: TYPE_NORMAL
- en: '`QString`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QByteArray`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QStringLiteral`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. Which strings match the `\A\d\z` regular expression?
  prefs: []
  type: TYPE_NORMAL
- en: Strings consisting of digits
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Strings consisting of a single digit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is not a valid regular expression
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. Which of the following container types can you use to store a list of widgets?
  prefs: []
  type: TYPE_NORMAL
- en: '`QVector<QWidget>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QList<QWidget>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QVector<QWidget*>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q4\. Which class can you use to convert a text string containing JSON to a Qt
    JSON representation?
  prefs: []
  type: TYPE_NORMAL
- en: '`QJsonValue`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QJsonObject`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QJsonDocument`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned a number of core Qt technologies, ranging from
    text manipulation and containers to accessing devices that can be used to transfer
    or store data, using a number of popular technologies such as XML or JSON. You
    should be aware that we have barely scratched the surface of what Qt offers and
    there are many other interesting classes you should familiarize yourself with,
    but this minimum amount of information should give you a head start and show you
    the direction to follow with your future research.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go beyond the boundaries of your computer and explore
    ways to use the powerful world of the modern internet. You will learn how to interact
    with the existing network services, check the current network availability, and
    implement your own servers and clients. This knowledge will come in handy if you
    want to implement multiplayer networked games.
  prefs: []
  type: TYPE_NORMAL
