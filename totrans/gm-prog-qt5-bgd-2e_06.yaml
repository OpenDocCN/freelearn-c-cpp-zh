- en: Qt Core Essentials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt 核心基础
- en: This chapter will help you master Qt ways of basic data processing and storage.
    First of all, you will learn how to handle textual data and how to match text
    against regular expressions. Next, we will provide an overview of Qt containers
    and describe common pitfalls related to them. Then, you will see how to store
    and fetch data from files and how to use different storage formats for text and
    binary data. By the end of this chapter, you will be able to implement non-trivial
    logic and data processing in your games efficiently. You will also know how to
    load external data in your games and how to save your own data in permanent storage
    for future use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你掌握 Qt 基本数据处理和存储的方法。首先，你将学习如何处理文本数据以及如何将文本与正则表达式进行匹配。接下来，我们将概述 Qt 容器并描述与它们相关的常见陷阱。然后，你将了解如何从文件中存储和检索数据，以及如何使用不同的存储格式来存储文本和二进制数据。到本章结束时，你将能够高效地在你的游戏中实现非平凡逻辑和数据处理。你还将知道如何在游戏中加载外部数据，以及如何将你的数据保存到永久存储中以便将来使用。
- en: 'Main topics covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主要主题：
- en: Text handling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本处理
- en: Qt containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 容器
- en: Serialization to INI, JSON, XML, and binary data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据序列化为 INI、JSON、XML 和二进制数据
- en: Saving the application's settings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存应用程序的设置
- en: Text handling
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本处理
- en: Applications with a graphical user interface (and games surely fall into this
    category) are able to interact with users by displaying text and by expecting
    textual input from the user. We have already scratched the surface of this topic
    in the previous chapters using the `QString` class. Now, we will go into further
    detail.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 具有图形用户界面（游戏当然属于这一类别）的应用程序能够通过显示文本并期望用户输入文本与用户交互。我们已经在之前的章节中通过使用 `QString` 类触及了这一主题的表面。现在，我们将进一步深入探讨。
- en: String encodings
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串编码
- en: The C++ language does not specify encoding of strings. Thus, any `char*` array
    and any `std::string` object can use an arbitrary encoding. When using these types
    for interaction with native APIs and third-party libraries, you have to refer
    to their documentation to find out which encoding they use. The encoding used
    by native APIs of the operating system usually depends on the current locale.
    Third-party libraries often use the same encoding as native APIs, but some libraries
    may expect another encoding, for example, UTF-8.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 语言没有指定字符串的编码。因此，任何 `char*` 数组和任何 `std::string` 对象都可以使用任意编码。当使用这些类型与原生 API
    和第三方库交互时，你必须参考它们的文档以了解它们使用的编码。操作系统原生 API 使用的编码通常取决于当前的区域设置。第三方库通常使用与原生 API 相同的编码，但某些库可能期望另一种编码，例如
    UTF-8。
- en: 'A string literal (that is, each bare text you wrap in quotation marks) will
    use an implementation defined encoding. Since C++11, you have an option to specify
    the encoding your text will have:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量（即你用引号包裹的每个裸文本）将使用实现定义的编码。自 C++11 以来，你可以指定你的文本将具有的编码：
- en: '`u8"text"` will produce a UTF-8 encoded `const char[]` array'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u8"text"` 将生成一个 UTF-8 编码的 `const char[]` 数组'
- en: '`u"text"` will produce a UTF-16 encoded `const char16_t[]` array'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u"text"` 将生成一个 UTF-16 编码的 `const char16_t[]` 数组'
- en: '`U"text"` will produce a UTF-32 encoded `const char32_t[]` array'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`U"text"` 将生成一个 UTF-32 编码的 `const char32_t[]` 数组'
- en: Unfortunately, the encoding used for interpreting the source files is still
    implementation defined, so it's not safe to put non-ASCII symbols in string literals.
    You should use escape sequences (such as `\unnnn`) to write such literals.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，用于解释源文件的编码仍然是实现定义的，因此将非 ASCII 符号放入字符串字面量中是不安全的。你应该使用转义序列（例如 `\unnnn`）来编写这样的字面量。
- en: Text in Qt is stored using the `QString` class that uses Unicode internally.
    Unicode allows us to represent characters in almost all languages spoken in the
    world and is the de facto standard for native encoding of text in most modern
    operating systems. There are multiple Unicode-based encodings. Memory representation
    of the content of `QString` resembles UTF-16 encoding. Basically, it consists
    of an array of 16-bit values where each Unicode character is represented by either
    1 or 2 values.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 中，文本使用 `QString` 类进行存储，该类内部使用 Unicode。Unicode 允许我们表示世界上几乎所有的语言中的字符，并且是大多数现代操作系统中文本原生编码的事实标准。存在多种基于
    Unicode 的编码。`QString` 内容的内存表示类似于 UTF-16 编码。基本上，它由一个 16 位值的数组组成，其中每个 Unicode 字符由
    1 或 2 个值表示。
- en: When constructing a `QString` from a `char` array or an `std::string` object,
    it's important to use a proper conversion method that depends on the initial encoding
    of the text. By default, `QString` assumes UTF-8 encoding of the input text. UTF-8
    is compatible with ASCII, so passing UTF-8 or ASCII-only text to `QString(const
    char *str)` is correct. `QString` provides a number of static methods to convert
    from other encodings such as `QString::fromLatin1()` or `QString::fromUtf16()`.
    `QString::fromLocal8Bit()` method assumes the encoding corresponding to the system
    locale.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 `char` 数组或 `std::string` 对象构造 `QString` 时，使用适当的转换方法非常重要，该转换方法取决于文本的初始编码。默认情况下，`QString`
    假设输入文本的编码为 UTF-8。UTF-8 与 ASCII 兼容，因此将 UTF-8 或仅 ASCII 文本传递给 `QString(const char
    *str)` 是正确的。`QString` 提供了多个静态方法来从其他编码转换，例如 `QString::fromLatin1()` 或 `QString::fromUtf16()`。`QString::fromLocal8Bit()`
    方法假定与系统区域设置对应的编码。
- en: If you have to combine both `QString` and `std::string` in one program, `QString`
    offers you the `toStdString()` and `fromStdString()` methods to perform a conversion.
    These methods also assume UTF-8 encoding of `std::string`, so you can't use them
    if your strings are in another encoding.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须在同一个程序中结合使用 `QString` 和 `std::string`，`QString` 提供了 `toStdString()` 和 `fromStdString()`
    方法来执行转换。这些方法也假设 `std::string` 的编码为 UTF-8，因此如果您的字符串使用其他编码，则不能使用它们。
- en: 'Default representation of string literals (for example, `"text"`) is not UTF-16,
    so each time you convert it to a `QString`, an allocation and conversion happens.
    This overhead can be avoided using the `QStringLiteral` macro:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量的默认表示（例如，`"text"`）不是 UTF-16，因此每次将其转换为 `QString` 时，都会发生分配和转换。可以使用 `QStringLiteral`
    宏避免这种开销：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`QStringLiteral` does two things:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`QStringLiteral` 执行两个操作：'
- en: It adds a `u` prefix to your string literal to ensure that it will be encoded
    in UTF-16 at compile time
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在您的字符串字面量前添加一个 `u` 前缀，以确保它在编译时以 UTF-16 编码
- en: It cheaply creates a `QString` and instructs it to use the literal without performing
    any allocation or encoding conversion
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以低廉的成本创建一个 `QString` 并指示它使用字面量，而不进行任何分配或编码转换
- en: It's a good habit to wrap all your string literals (except the ones that need
    to be translated) into `QStringLiteral` but it is not required, so don't worry
    if you forget to do that.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有字符串字面量（除了需要翻译的）包装在 `QStringLiteral` 中是一个好习惯，但这不是必需的，所以如果您忘记这样做，请不要担心。
- en: QByteArray and QString
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`QByteArray` 和 `QString`'
- en: '`QString` always contains UTF-16 encoded strings, but what if you have data
    in an unknown (yet) encoding? Also, what if the data is not even text? In these
    cases, Qt uses the `QByteArray` class. When you read data directly from a file
    or receive it from a network socket, Qt will return the data as a `QByteArray`,
    indicating that this is an arbitrary array of bytes without any information about
    the encoding:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`QString` 总是包含 UTF-16 编码的字符串，但如果有未知（尚未确定）编码的数据怎么办？或者，如果数据甚至不是文本怎么办？在这些情况下，Qt
    使用 `QByteArray` 类。当您直接从文件读取数据或从网络套接字接收数据时，Qt 将数据作为 `QByteArray` 返回，表示这是一个没有关于编码信息的任意字节数组：'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The closest equivalent of `QByteArray` in the standard library would be `std::vector<char>`.
    As the name implies, this is just an array of bytes with some helpful methods.
    In the preceding example, if you know that the file you read is in UTF-8, you
    can convert the data to a string, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中，`QByteArray` 的最接近等价物是 `std::vector<char>`。正如其名称所暗示的，这只是一个带有一些有用方法的字节数组。在前面的示例中，如果您知道您读取的文件是
    UTF-8 编码的，您可以按以下方式将数据转换为字符串：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you have no idea what encoding the file uses, it may be best to use the
    system encoding, so `QString::fromLocal8Bit` would be better. Similarly, when
    writing to a file, you need to convert the string to a byte array before passing
    it to the `write()` function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道文件使用什么编码，最好使用系统编码，因此 `QString::fromLocal8Bit` 会更好。同样，在写入文件时，您需要在将字符串传递给
    `write()` 函数之前将其转换为字节数组：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can use `file.close()` to close the file. `QFile` will also automatically
    close the file when deleted, so if your `QFile` object goes out of scope immediately
    after you've finished working with the file, there is no need for an explicit
    `close()` call.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `file.close()` 来关闭文件。`QFile` 也会在删除时自动关闭文件，因此如果您的 `QFile` 对象在完成文件操作后立即超出作用域，则不需要显式调用
    `close()`。
- en: Using other encodings
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他编码
- en: 'As we''ve already mentioned, `QString` has convenient methods for decoding
    and encoding data in the most popular encodings, such as UTF-8, UTF-16, and Latin1\.
    However, Qt knows how to handle many other encodings as well. You can access them
    using the `QTextCodec` class. For example, if you have a file in Big-5 encoding, you
    can ask Qt for a codec object by its name and make use of the `fromUnicode()`
    and `toUnicode()` methods:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，`QString` 提供了方便的方法来解码和编码在最受欢迎的编码中，如 UTF-8、UTF-16 和 Latin1。然而，Qt 也能处理许多其他编码。你可以使用
    `QTextCodec` 类来访问它们。例如，如果你有一个 Big-5 编码的文件，你可以通过其名称请求 Qt 的编解码器对象，并使用 `fromUnicode()`
    和 `toUnicode()` 方法：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can list the codecs supported on your installation using the `QTextCodec::availableCodecs()`
    static method. In most installations, Qt can handle almost 1,000 different text
    codecs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `QTextCodec::availableCodecs()` 静态方法列出你的安装上支持的编解码器。在大多数安装中，Qt 可以处理近 1,000
    种不同的文本编解码器。
- en: Basic string operations
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本字符串操作
- en: The most basic tasks that involve text strings are the ones where you add or
    remove characters from the string, concatenate strings, and access the string's
    content. In this regard, `QString` offers an interface that is compatible with
    `std::string`, but it also goes beyond that, exposing many more useful methods.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及文本字符串的最基本任务包括添加或删除字符串中的字符、连接字符串以及访问字符串内容。在这方面，`QString` 提供了一个与 `std::string`
    兼容的接口，但它还超越了这一点，暴露了许多更多有用的方法。
- en: Adding data at the beginning or at the end of the string can be done using the
    `prepend()` and `append()` methods. Inserting data in the middle of a string can
    be done with the `insert()` method that takes the position of the character where
    we need to start inserting as its first argument and the actual text as its second
    argument. All these methods have a couple of overloads that accept different objects
    that can hold textual data, including the classic `const char*` array.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `prepend()` 和 `append()` 方法可以在字符串的开始或末尾添加数据。使用 `insert()` 方法可以在字符串的中间插入数据，该方法将其第一个参数作为我们需要开始插入字符的位置，第二个参数是实际文本。所有这些方法都有一些重载，可以接受不同可以包含文本数据的对象，包括经典的
    `const char*` 数组。
- en: 'Removing characters from a string is similar. The basic way to do this is to
    use the `remove()` method that accepts the position at which we need to delete
    characters, and the number of characters to delete is as shown:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从字符串中删除字符的方式类似。基本方法是使用接受我们需要删除字符的位置和要删除的字符数的 `remove()` 方法，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There is also a `remove()` overload that accepts another string. When called,
    all its occurrences are removed from the original string. This overload has an
    optional argument that states whether comparison should be done in the default
    case-sensitive (`Qt::CaseSensitive`) or case-insensitive (`Qt::CaseInsensitive`)
    way:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个接受另一个字符串的 `remove()` 重载。当调用时，它会从原始字符串中删除所有其出现。这个重载有一个可选参数，它指定比较应该是在默认的大小写敏感（`Qt::CaseSensitive`）还是大小写不敏感（`Qt::CaseInsensitive`）的方式下进行：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To concatenate strings, you can either simply add two strings together, or
    you can append one string to the other:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接字符串，你可以简单地将两个字符串相加，或者将一个字符串追加到另一个字符串的末尾：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Accessing strings can be divided into two use cases. The first is when you
    wish to extract a part of the string. For this, you can use one of these three
    methods—`left()`, `right()`, and `mid()`—that return the given number of characters
    from the beginning or end of the string or extract a substring of a specified
    length, starting from a given position in the string:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 访问字符串可以分为两种用例。第一种是你希望提取字符串的一部分。为此，你可以使用这些三种方法之一——`left()`、`right()` 和 `mid()`——它们从字符串的开始或结束返回指定数量的字符，或者从字符串的指定位置提取指定长度的子字符串：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The second use case is when you wish to access a single character of the string.
    The use of the index operator works with `QString` in a similar fashion as with
    `std::string`, returning a copy or non-const reference to a given character that
    is represented by the `QChar` class, as shown in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种用例是你希望访问字符串的单个字符。索引操作符的使用与 `QString` 类似于 `std::string`，返回一个副本或非常量引用到由 `QChar`
    类表示的给定字符，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In addition to this, Qt offers a dedicated method—`at()`—that returns a copy
    of the character:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Qt 还提供了一个专门的方法——`at()`，它返回字符的副本：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should prefer to use `at()` instead of the index operator for operations
    that do not modify the character, as this explicitly uses a constant method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该优先使用 `at()` 而不是索引操作符来执行不修改字符的操作，因为这明确地使用了常量方法。
- en: The string search and lookup
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串搜索和查找
- en: The second group of functionalities is related to searching for the string.
    You can use methods such as `startsWith()`, `endsWith()`, and `contains()` to
    search for substrings in the beginning or end or in an arbitrary place in the
    string. The number of occurrences of a substring in the string can be retrieved
    using the `count()` method.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组功能与搜索字符串相关。你可以使用 `startsWith()`、`endsWith()` 和 `contains()` 等方法在字符串的开始、结束或任意位置搜索子字符串。可以使用
    `count()` 方法检索字符串中子字符串的出现次数。
- en: Be careful, there is also a `count()` method that doesn't take any parameters
    and returns the number of characters in the string.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 小心，还有一个不接收任何参数的 `count()` 方法，它返回字符串中的字符数。
- en: 'If you need to know the exact position of the match, you can use `indexOf()`
    or `lastIndexOf()` to receive the position in the string where the match occurs.
    The first call works by searching forward, and the other one searches backwards.
    Each of these calls takes two optional parameters—the second one determines whether
    the search is case-sensitive (similar to how `remove` works). The first one is
    the position in the string where the search begins. It lets you find all the occurrences
    of a given substring:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要知道匹配的确切位置，你可以使用 `indexOf()` 或 `lastIndexOf()` 来接收字符串中匹配发生的位置。第一个调用通过向前搜索工作，而另一个调用通过向后搜索。这些调用中的每一个都接受两个可选参数——第二个参数确定搜索是否区分大小写（类似于
    `remove` 的工作方式）。第一个参数是字符串中搜索开始的起始位置。它让你找到给定子字符串的所有出现：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Dissecting strings
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串分解
- en: There is one more group of useful string functionalities that makes `QString`
    different from `std::string`, that is, cutting strings into smaller parts and
    building larger strings from smaller pieces.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一组有用的字符串功能使得 `QString` 与 `std::string` 不同，那就是将字符串切割成更小的部分，并从更小的片段构建更大的字符串。
- en: 'Very often, a string contains substrings that are glued together by a repeating
    separator (for example, `"1,4,8,15"`). While you can extract each field from the
    record using functions that you already know (for example, `indexOf`), an easier
    way exists. `QString` contains a `split()` method that takes the separator string
    as its parameter and returns a list of strings that are represented in Qt by the
    `QStringList` class. Then, dissecting the record into separate fields is as easy
    as calling the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见，一个字符串包含由重复分隔符粘合在一起的子字符串（例如，`"1,4,8,15"`）。虽然你可以使用你已知的函数（例如，`indexOf`）从记录中提取每个字段，但存在一种更简单的方法。`QString`
    包含一个 `split()` 方法，它接受分隔符字符串作为其参数，并返回一个由 Qt 中的 `QStringList` 类表示的字符串列表。然后，将记录分解成单独的字段就像调用以下代码一样简单：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The inverse of this method is the `join()` method present in the `QStringList`
    class, which returns all the items in the list as a single string merged with
    a given separator:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的逆操作是 `QStringList` 类中存在的 `join()` 方法，它返回列表中的所有项作为一个由给定分隔符合并的单个字符串：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Converting between numbers and strings
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数字和字符串之间转换
- en: '`QString` also provides some methods for convenient conversion between textual
    and numerical values. Methods such as `toInt()`, `toDouble()`, or `toLongLong()`
    make it easy to extract numerical values from strings. All such methods take an
    optional `bool *ok` parameter. If you pass a pointer to a `bool` variable as this
    parameter, the variable will be set to `true` or `false`, depending on whether
    the conversion was successful or not. Methods returning integers also take the
    second optional parameter that specifies the numerical base (for example, binary,
    octal, decimal, or hexadecimal) of the value:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`QString` 还提供了一些方便地在文本和数值之间进行转换的方法。例如 `toInt()`、`toDouble()` 或 `toLongLong()`
    的方法使得从字符串中提取数值变得容易。所有这些方法都接受一个可选的 `bool *ok` 参数。如果你将一个指向 `bool` 变量的指针作为此参数传递，该变量将被设置为
    `true` 或 `false`，具体取决于转换是否成功。返回整数的方法还接受第二个可选参数，该参数指定值的数值基数（例如，二进制、八进制、十进制或十六进制）：'
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A static method called `number()` performs the conversion in the other direction—it
    takes a numerical value and number base and returns the textual representation
    of the value:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `number()` 的静态方法执行相反方向的转换——它接受一个数值和数字基数，并返回该值的文本表示：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function has some optional arguments that allow you to control the string
    representation of the number. For integers, you can specify the numerical base.
    For doubles, you can choose the scientific format `''e''` or the conventional
    format `''f''` and specify the number of digits after the decimal delimiter:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有一些可选参数，允许您控制数字的字符串表示形式。对于整数，您可以指定数值基数。对于双精度浮点数，您可以选择科学格式`'e'`或传统格式`'f'`，并指定小数分隔符后的数字位数：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Some of the other classes that represent values also provide conversions to
    and from `QString`. An example of such a class is `QDate`, which represents a
    date and provides the `fromString()` and `toString()` methods.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一些表示值的其他类也提供了与`QString`之间的转换功能。这样的一个例子是`QDate`，它表示日期并提供`fromString()`和`toString()`方法。
- en: These methods are nice and easy to use for technical purposes, for example,
    for reading and writing numbers to configuration files. However, they are not
    suitable when you need to display a number to the user or parse a user input because
    numbers are written differently in different countries. This brings us to the
    topic of *internationalization*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法对于技术目的来说很棒且易于使用，例如，在配置文件中读取和写入数字。然而，当您需要向用户显示数字或解析用户输入时，它们并不适用，因为不同国家的数字书写方式不同。这引出了*国际化*这一主题。
- en: Internationalization
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化
- en: Most real projects have a target audience in multiple countries. The most notable
    difference between them is the spoken language, but there are other aspects some
    developers may not think of. For example, dot `"."` and comma `","` are both fairly
    common as the decimal separator throughout the world. Date formats are also very
    different and incompatible, and using a wrong format (for example, `mm/dd/yyyy`
    instead of `dd/mm/yyyy`) will result in a completely different date.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数实际项目都有多个国家的目标受众。它们之间最显著的区别是 spoken language，但还有其他一些开发者可能没有考虑到的方面。例如，点`.`和逗号`,`在全球范围内都相当常见，作为小数分隔符。日期格式也非常不同且不兼容，使用错误的格式（例如，`mm/dd/yyyy`而不是`dd/mm/yyyy`）将导致日期完全不同。
- en: 'Qt provides the `QLocale` class for dealing with locale-dependent operations,
    including conversions between numbers in strings. In the following code, `text`
    and `number` may have different values, depending on the system locale:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了`QLocale`类来处理与区域设置相关的操作，包括字符串中数字之间的转换。在以下代码中，`text`和`number`的值可能因系统区域设置的不同而不同：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`QLocale` also provides methods for formatting dates and prices, and allows
    us to request additional information about local conventions.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLocale`还提供了格式化日期和价格的方法，并允许我们请求有关本地约定的更多信息。'
- en: As for translations, we've already mentioned that any text visible to users
    should be wrapped in a `tr()` function. Now we will explain this requirement.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 关于翻译，我们已提到，任何用户可见的文本都应该包裹在`tr()`函数中。现在我们将解释这一要求。
- en: 'Qt''s translation system makes it possible for developing and translation teams
    to work independently. The project goes through the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的翻译系统使得开发和翻译团队能够独立工作。项目经过以下步骤：
- en: Developers create an application and wrap all text that should be translated
    in special translation functions (such as `tr()`). Visible text in forms is automatically
    wrapped in translation functions.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者创建一个应用程序，并将所有应翻译的文本包裹在特殊的翻译函数中（例如`tr()`）。表单中的可见文本会自动包裹在翻译函数中。
- en: A special Qt tool (**lupdate**) searches for all strings wrapped in translation
    functions and generates a translation file (`.ts`).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个特殊的Qt工具（**lupdate**）搜索所有包裹在翻译函数中的字符串，并生成一个翻译文件（`.ts`）。
- en: Translators open this file in a special application called **Qt Linguist**.
    In that application, they are able to see all strings grouped by *context*, which
    is usually the class this text belongs to. They can add translations and save
    them in the translation file.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 翻译者在一个称为**Qt Linguist**的特殊应用程序中打开此文件。在该应用程序中，他们能够看到所有按*上下文*分组排列的字符串，这通常是指文本所属的类。他们可以在翻译文件中添加翻译并保存。
- en: When this new translation file is copied back to the project and applied using
    the `QCoreApplication::installTranslator` function, the translation functions
    start returning translated text instead of simply returning the argument.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当这个新的翻译文件被复制回项目并使用`QCoreApplication::installTranslator`函数应用时，翻译函数开始返回翻译后的文本，而不是简单地返回参数。
- en: As the application evolves and a new untranslated text appears, it's shown untranslated
    by default. However, it can be automatically added to translation files, and translators
    can add new translations for new content, without losing the existing translations.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着应用程序的发展和新未翻译文本的出现，它默认显示为未翻译。然而，它可以自动添加到翻译文件中，翻译者可以为新内容添加新的翻译，而不会丢失现有的翻译。
- en: We will not go into the details of this process. As a developer, you only need
    to ensure that all visible strings are wrapped in a translation function and a
    proper context is provided. The context is necessary because a short text (for
    example, one word on a button) may not be enough to understand the meaning and
    provide a proper translation, but how do we specify the context?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入这个过程的细节。作为一个开发者，你只需要确保所有可见的字符串都被包裹在翻译函数中，并提供适当的上下文。上下文是必要的，因为简短的文本（例如，按钮上的一个单词）可能不足以理解其含义并提供适当的翻译，但我们如何指定上下文呢？
- en: 'The main translation function is `QCoreApplication::translate()`. It accepts
    three arguments: the context, the text to translate, and an optional disambiguation
    text. The disambiguation argument is rarely needed. It can be used to distinguish
    between multiple instances of the same text in the same context and when they
    should have different translations.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的翻译函数是`QCoreApplication::translate()`。它接受三个参数：上下文、要翻译的文本和一个可选的歧义文本。歧义参数很少需要。它可以用来区分同一上下文中多个相同文本的实例，以及它们应该有不同的翻译。
- en: Instead of `QCoreApplication::translate()`, you should usually use the `tr()`
    function, which is declared in each class that inherits `QObject`. `MyClass::tr(text,
    disambiguation)` is a shortcut for `QCoreApplication::translate(**"MyClass"**,
    text, disambiguation)`. Due to this, all translatable texts located in one class
    will share the same `context` string, so they will be grouped in Qt Linguist to
    make the translator's job easier.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该使用`tr()`函数而不是`QCoreApplication::translate()`，该函数在每个继承自`QObject`的类中声明。`MyClass::tr(text,
    disambiguation)`是`QCoreApplication::translate(**"MyClass"**, text, disambiguation)`的快捷方式。因此，位于一个类中的所有可翻译文本将共享相同的`context`字符串，这样它们将在Qt
    Linguist中分组，以便使翻译者的工作更容易。
- en: 'If you have a translatable text outside of a subclass of `QObject`, the `tr()`
    function will not be available by default. In this case, you have the following
    options:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个不在`QObject`子类之外的翻译文本，默认情况下`tr()`函数将不可用。在这种情况下，你有以下选项：
- en: Use the `QCoreApplication::translate()` function and write the `context` argument
    explicitly
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QCoreApplication::translate()`函数并显式写出`context`参数
- en: Reuse the `tr()` function of a relevant class (for example, `MyClass::tr()`)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新使用相关类的`tr()`函数（例如，`MyClass::tr()`）
- en: Declare the `tr()` function in your (non-`QObject`-based) class by adding the `Q_DECLARE_TR_FUNCTIONS(context)`
    macro at the top of the class declaration
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的（非`QObject`基于的）类中声明`tr()`函数，通过在类声明顶部添加`Q_DECLARE_TR_FUNCTIONS(context)`宏
- en: 'Note that the translation functions should receive the string literals directly.
    Otherwise, **lupdate** will not be able to understand which text is being translated.
    The following code is incorrect, because the two strings will not be seen by translators:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，翻译函数应该直接接收字符串字面量。否则，**lupdate**将无法理解正在翻译哪个文本。以下代码是不正确的，因为两个字符串将不会被翻译者看到：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The simplest way to fix this issue is to apply the `tr()` function directly
    to each string literal:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最简单方法是直接将`tr()`函数应用到每个字符串字面量上：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Another solution is to mark translatable text with the `QT_TR_NOOP` macro:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是使用`QT_TR_NOOP`宏标记可翻译文本：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `QT_TR_NOOP` macro returns its argument as is, but **lupdate** will recognize
    that these strings must be translated.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`QT_TR_NOOP`宏返回其参数不变，但**lupdate**将识别这些字符串必须被翻译。'
- en: 'It''s also possible to add a comment for the translator using a special form
    of C++ comments: `//: ...` or `/*: ... */`. Consider this example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '还可以通过使用特殊的C++注释形式为翻译者添加注释：`//: ...`或`/*: ... */`。考虑以下示例：'
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this section, we only described the absolute minimum you need to know before
    starting work on a multilanguage game. This knowledge can save you a lot of time,
    because it's much easier to mark some text for translation as you write it than
    to go through a large code base and do it later. However, you will need to learn
    more to actually implement internationalization in your project. We will cover
    this topic in depth later (*Online* c*hapter, *[https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf](https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们仅描述了在开始开发多语言游戏之前你需要了解的绝对最小知识。这些知识可以为你节省大量时间，因为在你编写时标记一些文本进行翻译比在大型代码库中后期进行要容易得多。然而，你需要学习更多才能在你的项目中实际实现国际化。我们将在稍后深入探讨这个主题（*在线*章节，*[https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf](https://www.packtpub.com/sites/default/files/downloads/MiscellaneousandAdvancedConcepts.pdf)）。
- en: Using arguments in strings
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在字符串中使用参数
- en: 'A common task is to have a string that needs to be dynamic in such a way that
    its content depends on the value of some external variable—for instance, you would
    like to inform the user about the number of files being copied, showing "copying
    file 1 of 2" or "copying file 2 of 5" depending on the value of counters that
    denote the current file and the total number of files. It might be tempting to
    do this by assembling all the pieces together using one of the available approaches:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的任务是拥有一个需要动态变化的字符串，其内容取决于某些外部变量的值——例如，你可能想通知用户正在复制的文件数量，显示“正在复制文件 1/2”或“正在复制文件
    2/5”，这取决于表示当前文件和文件总数的计数器的值。可能会诱使你通过使用可用的方法之一将所有片段组装在一起来完成这项任务：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There are a number of drawbacks to such an approach; the biggest one is the
    problem of translating the string into other languages, wherein different languages
    their grammar might require the two arguments to be positioned differently than
    in English.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法存在一些缺点；最大的问题是将字符串翻译成其他语言时，不同语言的语法可能要求两个参数的位置与英语不同。
- en: 'Instead, Qt allows us to specify positional parameters in strings and then
    replace them with real values. This approach is called **string interpolation**.
    Positions in the string are marked with the `%` sign (for example, `%1`, `%2`,
    and so on) and they are replaced by making a call to `arg()` and passing it the
    value that is used to replace the next lowest marker in the string. Our file copy
    message construction code then becomes this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Qt 允许我们在字符串中指定位置参数，然后使用实际值替换它们。这种方法称为**字符串插值**。字符串中的位置用 `%` 符号标记（例如，`%1`、`%2`
    等等），并通过调用 `arg()` 并传递用于替换字符串中下一个最低标记的值来替换它们。然后我们的文件复制消息构建代码变为如下：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Contrary to the behavior of the `printf()` built-in function, you don''t need
    to specify the types of values in the placeholders (like `%d` or `%s`). Instead,
    the `arg()` method has a number of overloads that accept single characters, strings,
    integers, and real numbers. The `arg()` method has the same optional arguments
    that `QString::number()` has, allowing you to configure how numbers are formatted.
    Additionally, the `arg()` method has the `fieldWidth` argument that forces it
    to always output the string of a specified length, which is convenient for formatting
    tables:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与内置的 `printf()` 函数的行为相反，你不需要在占位符中指定值的类型（如 `%d` 或 `%s`）。相反，`arg()` 方法有几个重载，可以接受单个字符、字符串、整数和实数。`arg()`
    方法具有与 `QString::number()` 相同的可选参数，允许你配置数字的格式。此外，`arg()` 方法还有一个 `fieldWidth` 参数，它强制它始终输出指定长度的字符串，这对于格式化表格来说很方便：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you want to use a character other than space to fill empty spaces, use the `fillChar`
    optional argument of `arg()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用除空格以外的字符来填充空白，请使用 `arg()` 的可选参数 `fillChar`。
- en: Regular expressions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Let's briefly talk about **regular expressions**—usually shortened as "regex"
    or "regexp". You will need these regular expressions whenever you have to check
    whether a string or part of it matches a given pattern or when you want to find
    specific parts inside the text and possibly want to extract them. Both the validity
    check and the finding/extraction are based on the so-called pattern of the regular
    expression, which describes the format a string must have to be valid, to be found,
    or to be extracted. Since this book is focused on Qt, there is unfortunately no
    time to cover regular expressions in depth. This is not a huge problem, however,
    since you can find plenty of good websites that provide introductions to regular
    expressions on the internet.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地谈谈**正则表达式**——通常简称为 "regex" 或 "regexp"。当您需要检查一个字符串或其部分是否与给定的模式匹配，或者当您想要在文本中找到特定的部分并可能提取它们时，您将需要这些正则表达式。验证有效性和查找/提取都基于所谓的正则表达式模式，它描述了字符串必须具有的格式才能有效、可找到或可提取。由于本书专注于
    Qt，很遗憾没有时间深入探讨正则表达式。然而，这并不是一个大问题，因为您可以在互联网上找到许多提供正则表达式介绍的优质网站。
- en: Even though there are many flavors of the regular expression's syntax, the one
    that Perl uses has become the *de facto* standard. In Qt, the `QRegularExpression`
    class provides Perl-compatible regular expressions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管正则表达式的语法有很多变体，但 Perl 使用的那个已经成为了*事实上的*标准。在 Qt 中，`QRegularExpression` 类提供了与
    Perl 兼容的正则表达式。
- en: '`QRegularExpression` was first introduced with Qt 5.0\. In the previous versions,
    the only regular exception class was `QRegExp`, and it''s still available for
    compatibility. Since `QRegularExpression` is closer to the Perl standard and since
    its execution speed is much faster as compared to `QRegExp`, we advise you to
    use `QRegularExpression` whenever possible. Nevertheless, you can read the `QRegExp`
    documentation, which contains a nice general introduction of regular expressions.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`QRegularExpression` 首次在 Qt 5.0 中引入。在之前的版本中，唯一的正则异常类是 `QRegExp`，但为了兼容性它仍然可用。由于
    `QRegularExpression` 更接近 Perl 标准，并且与 `QRegExp` 相比执行速度要快得多，我们建议尽可能使用 `QRegularExpression`。尽管如此，您仍然可以阅读
    `QRegExp` 的文档，其中包含对正则表达式的一个很好的通用介绍。'
- en: Time for action – A simple quiz game
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 一个简单的问答游戏
- en: 'To introduce you to the main usage of `QRegularExpression`, let''s imagine
    this game: a photo, showing an object, is shown to multiple players, and each
    of them has to estimate the object''s weight. The player whose estimate is closest
    to the actual weight wins. The estimates will be submitted via `QLineEdit`. Since
    you can write anything in a line edit, we have to ensure that the content is valid.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向您介绍 `QRegularExpression` 的主要用法，让我们想象这个游戏：一张显示物体的照片被展示给多个玩家，他们中的每一个都必须估计物体的重量。估计值最接近实际重量的玩家获胜。估计将通过
    `QLineEdit` 提交。由于您可以在行编辑中写入任何内容，我们必须确保内容是有效的。
- en: 'So what does valid mean? In this example, we define that a value between 1g
    and 999kg is valid. Knowing this specification, we can construct a regular expression
    that will verify the format. The first part of the text is a number, which can
    be between 1 and 999\. Thus, the corresponding pattern looks like `[1-9]\d{0,2}`,
    where `[1-9]` allows—and demands—exactly one digit, except zero. It''s optionally
    followed by up to two digits, including zero. This is expressed through `\d{0,2}`,
    where `\d` means "any digit", 0 is the minimal allowed count, and 2 is the maximal
    allowed count. The last part of the input is the weight''s unit. With a pattern
    such as `(mg|g|kg)`, we allow the weight to be input in milligrams (`mg`), grams
    (`g`), or kilograms (`kg`). With `\s*`, we finally allow an arbitrary number of
    whitespace characters between the number and unit. Let''s combine it all together
    and test our regular expression right away:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 那么“有效”是什么意思呢？在这个例子中，我们定义一个介于 1g 和 999kg 之间的值是有效的。了解这个规范后，我们可以构建一个验证格式的正则表达式。文本的第一部分是一个数字，可以是
    1 到 999 之间的任何数字。因此，相应的模式看起来像 `[1-9]\d{0,2}`，其中 `[1-9]` 允许并且要求恰好一个数字，除了零。它可以选择性地后面跟多达两个数字，包括零。这通过
    `\d{0,2}` 来表达，其中 `\d` 表示“任何数字”，0 是最小允许的计数，2 是最大允许的计数。输入的最后部分是重量的单位。使用如 `(mg|g|kg)`
    这样的模式，我们允许重量以毫克（`mg`）、克（`g`）或千克（`kg`）输入。通过 `\s*`，我们最终允许在数字和单位之间有任意数量的空白字符。让我们将它们全部组合起来，并立即测试我们的正则表达式：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What just happened?
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: In the first line, we constructed the aforementioned `QRegularExpression` object,
    while passing the regular expression's pattern as a parameter to the constructor.
    Note that we have to escape the `\` character, because it has special meaning
    in C++ syntax.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们构建了上述的 `QRegularExpression` 对象，并将正则表达式的模式作为参数传递给构造函数。请注意，我们必须转义 `\` 字符，因为它在
    C++ 语法中有特殊含义。
- en: 'Regular expressions are case-sensitive by default. However, we want to allow
    the input to be in uppercase or mixed case. To achieve this, we can, of course,
    write `(mg|mG|Mg|MG|g|G|kg|kG|Kg|KG)` or convert the string to lowercase before
    matching, but there is a much cleaner and more readable solution. On the second
    line of the code example, you see the answer—a pattern option. We used `setPatternOptions()`
    to set the `QRegularExpression::CaseInsensitiveOption` option, which does not
    respect the case of the characters used. Of course, there are a few more options
    that you can read about in Qt''s documentation on `QRegularExpression::PatternOption`.
    Instead of calling `setPatternOptions()`, we could also have passed the option
    as a second parameter to the constructor of `QRegularExpression`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，正则表达式是区分大小写的。然而，我们希望允许输入为大写或混合大小写。为了实现这一点，我们当然可以写出 `(mg|mG|Mg|MG|g|G|kg|kG|Kg|KG)`
    或者匹配之前将字符串转换为小写，但有一个更干净、更易读的解决方案。在代码示例的第二行，你可以看到答案——一个模式选项。我们使用了 `setPatternOptions()`
    来设置 `QRegularExpression::CaseInsensitiveOption` 选项，它不尊重使用的字符的大小写。当然，你还可以在 Qt 的
    `QRegularExpression::PatternOption` 文档中了解更多选项。我们也可以将选项作为 `QRegularExpression`
    构造函数的第二个参数传递，而不是调用 `setPatternOptions()`：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When we need to test an input, all we have to do is call `match()`, passing
    the string we would like to check against it. In return, we get an object of the
    `QRegularExpressionMatch` type that contains all the information that is further
    needed—and not only to check the validity. With `QRegularExpressionMatch::hasMatch()`,
    we then can determine whether the input matches our criteria, as it returns `true`
    if the pattern could be found. Otherwise, of course, `false` is returned.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要测试一个输入时，我们只需要调用 `match()`，传递我们想要检查的字符串。作为回报，我们得到一个 `QRegularExpressionMatch`
    类型的对象，它包含进一步所需的所有信息——而不仅仅是检查有效性。然后，我们可以通过 `QRegularExpressionMatch::hasMatch()`
    确定输入是否匹配我们的标准，因为它在找到模式时返回 `true`。否则，当然返回 `false`。
- en: 'Our pattern is not quite finished. The `hasMatch()` method would also return
    `true` if we matched it against "foo 142g bar". So, we have to define that the
    pattern is checked from the beginning to the end of the matched string. This is
    done by the `\A` and `\z` anchors. The former marks the start of a string and
    the latter the end of a string. Don''t forget to escape the slashes when you use
    such anchors. The correct pattern will then look like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式还没有完成。如果我们将它匹配到 "foo 142g bar"，`hasMatch()` 方法也会返回 `true`。因此，我们必须定义模式是从匹配字符串的开始到结束进行检查的。这是通过
    `\A` 和 `\z` 锚点完成的。前者标记字符串的开始，后者标记字符串的结束。当你使用这样的锚点时，不要忘记转义斜杠。正确的模式将看起来像这样：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Extracting information out of a string
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从字符串中提取信息
- en: After we have checked that the sent guess is well formed, we have to extract
    the actual weight from the string. In order to be able to easily compare the different
    guesses, we further need to transform all values to a common reference unit. In
    this case, it should be a milligram, the lowest unit. So, let's see what `QRegularExpressionMatch`
    can offer us for this task.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查发送的猜测是否格式良好之后，我们必须从字符串中提取实际的重量。为了能够轻松比较不同的猜测，我们还需要将所有值转换为共同的参考单位。在这种情况下，应该是毫克，这是最低的单位。那么，让我们看看
    `QRegularExpressionMatch` 可以为我们提供什么来完成任务。
- en: 'With `capturedTexts()`, we get a string list of the pattern''s captured groups.
    In our example, this list will contain "23kg" and "kg". The first element is always
    the string that was fully matched by the pattern. The next elements are all the
    substrings captured by the used brackets. Since we are missing the actual number,
    we have to alter the pattern''s beginning to `([1-9]\d{0,2})`. Now, the list''s
    second element is the number, and the third element is the unit. Thus, we can
    write the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `capturedTexts()`，我们可以得到一个包含模式捕获组的字符串列表。在我们的例子中，这个列表将包含 "23kg" 和 "kg"。列表的第一个元素总是被模式完全匹配的字符串。接下来的元素都是被使用的括号捕获的子字符串。由于我们缺少实际的数字，我们必须将模式的开始更改为
    `([1-9]\d{0,2})`。现在，列表的第二个元素是数字，第三个元素是单位。因此，我们可以写出以下内容：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the function's first two lines, we set up the pattern and its option. Then,
    we match it against the passed argument. If `QRegularExpressionMatch::hasMatch()`
    returns `true`, the input is valid and we extract the number and unit. Instead
    of fetching the entire list of captured text with `capturedTexts()`, we query
    specific elements directly by calling `QRegularExpressionMatch::captured()`. The
    passed integer argument signifies the element's position inside the list. So,
    calling `captured(1)` returns the matched digits as a `QString`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的前两行中，我们设置了模式和其选项。然后，我们将它与传递的参数进行匹配。如果`QRegularExpressionMatch::hasMatch()`返回`true`，则输入有效，我们提取数字和单位。我们不是通过调用`capturedTexts()`获取捕获文本的整个列表，而是通过调用`QRegularExpressionMatch::captured()`直接查询特定元素。传递的整数参数表示元素在列表中的位置。因此，调用`captured(1)`返回匹配的数字作为一个`QString`。
- en: Be aware that adding a group at a later time will shift the indices of all the
    following groups by 1, and you will have to adjust your code! If you have long
    patterns or if there is a high probability that further brackets will be added
    in future, you can use **named groups** to make your code more maintainable. There
    is a  `QRegularExpressionMatch::captured()` overload that allows you to specify
    the group name instead of index. For example, if you have written `(?<number>[1-9][0-9]{0,2})`,
    then you can get the digits by calling `match.captured("number")`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在以后的时间添加一个组将使所有后续组的索引增加1，您将不得不调整您的代码！如果您有长的模式，或者有很高的概率未来会添加更多的括号，您可以使用**命名组**来使您的代码更易于维护。有一个`QRegularExpressionMatch::captured()`重载，允许您指定组名而不是索引。例如，如果您已经编写了`(?<number>[1-9][0-9]{0,2})`，那么您可以通过调用`match.captured("number")`来获取数字。
- en: To be able to calculate using the extracted number, we need to convert `QString`
    into an integer. This is done by calling `QString::toInt()`. The result of this
    conversion is then stored in the `weight` variable. Next, we fetch the unit and
    transform it to lowercase characters on the fly. This way, we can, for example,
    easily determine whether the user's guess is expressed in grams by checking the
    unit against the lowercase "g". We do not need to take care of the capital "G"
    or the variants "KG", "Kg", and the unusual "kG" for kilogram.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用提取的数字进行计算，我们需要将`QString`转换为整数。这是通过调用`QString::toInt()`完成的。此转换的结果随后存储在`weight`变量中。接下来，我们获取单位并将其转换为小写字符。这样，我们可以轻松地确定用户的猜测是否以克为单位，只需将单位与小写的"g"进行比较。我们不需要关心大写的"G"或变体"KG"、"Kg"和奇特的"kG"（千克）。
- en: To get the standardized weight in milligrams, we multiply `weight` by 1,000
    or 1,000,000, depending on whether this was expressed in g or kg. Lastly, we return
    this standardized weight. If the string wasn't well formed, we return `-1` to
    indicate that the given guess was invalid. It is then the caller's duty to determinate
    which player's guess was the best.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到标准化的毫克重量，我们需要将`weight`乘以1,000或1,000,000，具体取决于这是否以g或kg表示。最后，我们返回这个标准化重量。如果字符串格式不正确，我们返回`-1`以指示给定的猜测无效。然后，调用者负责确定哪个玩家的猜测是最好的。
- en: Pay attention to whether your chosen integer type can handle the weight's value.
    For our example, 999 million is the biggest possible result, and, fortunately,
    it's smaller than the maximum possible value of a signed 32-bit integer (2,147,483,647).
    If you're unsure whether the type you use is big enough on all target systems,
    use a fixed width integer type (for example, `int64_t`).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意您选择的整数类型是否可以处理重量的值。在我们的例子中，9.99亿是可能的最大结果，幸运的是，它小于有符号32位整数的最大可能值（2,147,483,647）。如果您不确定您使用的类型在所有目标系统上是否足够大，请使用固定宽度整数类型（例如，`int64_t`）。
- en: As an exercise, try to extend the example by allowing decimal numbers so that
    "23.5g" is a valid guess. To achieve this, you have to alter the pattern in order
    to enter decimal numbers, and you also have to deal with `double` instead of `int`
    for the standardized weight.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试通过允许小数来扩展示例，使得"23.5g"是一个有效的猜测。为了实现这一点，您必须更改模式以输入小数，并且您还必须处理`double`而不是`int`作为标准化重量。
- en: Finding all pattern occurrences
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找所有模式出现
- en: 'Lastly, let''s take a final look at how to find, for example, all numbers inside
    a string, even those leading with zeros:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何查找字符串中的所有数字，即使是那些以零开头的数字：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `input` string contains an exemplary text in which we would like to find
    all numbers. The "foo" as well as "1a" variables should not be found by the pattern,
    since these are not valid numbers. Therefore, we set up the pattern, defining
    that we require at least one digit, `\d+`, and that this digit—or these digits—should
    be wrapped by word boundaries, `\b`. Note that you have to escape the slashes.
    With this pattern, we initiate the `QRegularExpression` object and call `globalMatch()`
    on it. Inside the passed argument, the pattern will be searched. This time, we
    do not get `QRegularExpressionMatch` back; instead, we get an iterator of the
    `QRegularExpressionMatchIterator` type. Since `QRegularExpressionMatchIterator`
    has a convenient `hasNext()` method, we check whether there is a further match
    and if so, we bring up the next match by calling `next()`. The type of the returned
    match is then `QRegularExpressionMatch`, which you already know.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 输入字符串包含一段示例文本，我们希望在其中找到所有数字。模式不应找到“foo”以及“1a”变量，因为这些不是有效的数字。因此，我们设置了模式，定义我们需要至少一个数字，`\d+`，并且这个数字——或者这些数字——应该被单词边界`\b`包围。请注意，您必须转义斜杠。使用这个模式，我们初始化`QRegularExpression`对象，并在其上调用`globalMatch()`。在传递的参数中，将搜索该模式。这次，我们没有返回`QRegularExpressionMatch`；相反，我们得到了`QRegularExpressionMatchIterator`类型的迭代器。由于`QRegularExpressionMatchIterator`有一个方便的`hasNext()`方法，我们检查是否存在进一步的匹配，如果有，就通过调用`next()`来获取下一个匹配。返回的匹配类型是`QRegularExpressionMatch`，您已经知道了。
- en: If you need to know about the next match inside the `while` loop, you can use
    `QRegularExpressionMatchIterator::peekNext()` to receive it. The benefit of this
    function is that it does not move the iterator.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在`while`循环中了解下一个匹配项，您可以使用`QRegularExpressionMatchIterator::peekNext()`来获取它。这个函数的好处是它不会移动迭代器。
- en: This way, you can iterate all pattern occurrences in the string. This is helpful
    if you, for example, want to highlight a search string in text.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您就可以遍历字符串中的所有模式出现。如果您，例如，想在文本中突出显示搜索字符串，这将很有帮助。
- en: Our example will give the output of `"123"`, `"09"`, and `"3"`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将给出输出`"123"`、`"09"`和`"3"`。
- en: Taking into account that this was just a brief introduction to regular expressions,
    we would like to encourage you to read the Detailed Description section in the
    documentation to `QRegularExpression`, `QRegularExpressionMatch`, and `QRegularExpressionMatchIterator`.
    Regular expressions are very powerful and useful, so, in your daily programming
    life, you can benefit from the profound knowledge of regular expressions!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这只是一个对正则表达式的简要介绍，我们鼓励您阅读文档中关于`QRegularExpression`、`QRegularExpressionMatch`和`QRegularExpressionMatchIterator`的详细描述部分。正则表达式非常强大且有用，因此，在您的日常编程生活中，您可以从正则表达式的深刻知识中受益！
- en: Containers
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: 'When you need to store a collection of objects, you need a container to hold
    them. The C++ standard library provides many powerful containers, such as `std::vector`,
    `std::list`, or `std::map`. However, Qt doesn''t use these containers (actually,
    it hardly uses any standard library classes at all) and provides its own alternative
    implementation of containers instead. When Qt containers were introduced, they
    provided significantly more consistent performance on different platforms compared
    to standard library implementations, so they were required to create reliable
    cross-platform applications. This is not really the case now, as STL implementations
    and compilers have since evolved and gained new optimizations and features. However,
    there are still reasons to use Qt containers, especially in an application that
    heavily uses other Qt classes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要存储一组对象时，您需要一个容器来容纳它们。C++标准库提供了许多强大的容器，例如`std::vector`、`std::list`或`std::map`。然而，Qt不使用这些容器（实际上，它几乎不使用任何标准库类）而是提供了自己的容器实现。当Qt容器被引入时，它们在不同平台上提供了比标准库实现显著更一致的性能，因此它们被要求创建可靠的跨平台应用程序。现在这并不是真的，因为STL实现和编译器已经发展并获得了新的优化和功能。然而，仍然有使用Qt容器的原因，尤其是在一个大量使用其他Qt类的应用程序中：
- en: Qt API always uses Qt containers. When you receive a `QList`, it will almost
    never be more efficient or convenient to convert it to a standard library container.
    Before calling a method that accepts `QList`, you should populate the input data
    in a `QList` instead of converting it from an STL container.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt API始终使用Qt容器。当您收到一个`QList`时，几乎永远不会比将其转换为标准库容器更高效或方便。在调用接受`QList`的方法之前，您应该在`QList`中填充输入数据，而不是将其从STL容器中转换。
- en: Qt containers provide unique features, like implicit sharing (we will discuss
    it later in this chapter) or Java-style iterators, and some convenience methods
    STL containers lack.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 容器提供了独特的功能，如隐式共享（我们将在本章后面讨论）或 Java 风格的迭代器，以及 STL 容器缺乏的一些便利方法。
- en: Qt containers follow Qt's naming scheme and its API conventions, so they look
    more natural in an application that is centered around Qt. For example, `QVector::isEmpty()`
    is more Qt-like than `std::vector::empty()`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 容器遵循 Qt 的命名方案和 API 习惯，因此在以 Qt 为中心的程序中看起来更自然。例如，`QVector::isEmpty()` 比 `std::vector::empty()`
    更像 Qt 风格。
- en: In addition, Qt containers provide STL-compatible API (for example, the `append()`
    method has the `push_back()` alias) that allows us to replace Qt containers with
    STL ones without changing much of the code. Range based `for` loop and some of
    the standard library algorithms are also compatible with Qt containers. That being
    said, if you need some features that are not available in Qt containers, using
    STL containers is a good idea.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Qt 容器提供了与 STL 兼容的 API（例如，`append()` 方法有 `push_back()` 别名），这使得我们可以在不改变代码大部分内容的情况下用
    STL 容器替换 Qt 容器。基于范围的 `for` 循环和一些标准库算法也与 Qt 容器兼容。话虽如此，如果你需要 Qt 容器中不可用的某些功能，使用 STL
    容器是个不错的选择。
- en: Main container types
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要容器类型
- en: When you interact with a Qt API method, you don't have much choice on the container
    type, because you need to use the container the method uses. However, generally,
    you are free to choose containers to store your data. Let's go through the main
    Qt containers and learn when to use them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与 Qt API 方法交互时，你在容器类型上没有太多选择，因为你需要使用该方法使用的容器。然而，通常，你可以自由选择容器来存储你的数据。让我们了解一下主要的
    Qt 容器以及何时使用它们。
- en: We will only give a brief overview of Qt containers and won't go into details
    such as the algorithmic complexity of different operations. For most Qt containers,
    there is a similar STL container that we will name. The topic of choosing the
    right container is widely discussed, and it's not hard to find more information
    on it, especially for STL containers. You can also find more information on the
    Container Classes Qt documentation page.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只提供一个简要概述 Qt 容器，不会深入到不同操作的算法复杂度等细节。对于大多数 Qt 容器，都有一个类似的 STL 容器，我们将命名它。选择正确容器的主题被广泛讨论，并且不难找到更多相关信息，特别是对于
    STL 容器。你还可以在 Qt 容器类文档页面找到更多信息。
- en: '`QVector` stores items in a continuous region of memory. The items are densely
    packed, meaning that this type is the most memory efficient and cache friendly.
    Its STL equivalent is `std::vector`. `QVector` should be the container of default
    choice, meaning that you should only use a different container if you have a reason
    to do it. `QVector` provides fast lookup by item number, fast on average appending
    items to the end and removing items from the end. Inserting and removing items
    from the beginning or middle of the vector is slow, because it causes all items
    to the right to shift in memory. Using `QVector` is straightforward:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`QVector` 在内存的连续区域存储项目。项目是紧密打包的，这意味着这种类型是最节省内存和缓存友好的。它的 STL 等价物是 `std::vector`。`QVector`
    应该是默认选择的容器，这意味着只有在你有理由这样做的情况下才应该使用不同的容器。`QVector` 提供了按项目编号快速查找、平均快速在末尾追加项目和从末尾删除项目。从向量开始或中间插入和删除项目较慢，因为这会导致右侧的所有项目在内存中移动。使用
    `QVector` 是直接的：'
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `QLinkedList` container, as the name implies, implements a linked list.
    Its STL equivalent is `std::list`. As opposed to `QVector`, it provides fast inserting
    and removing items at any location (the beginning, middle, or the end), but slow
    lookup by index, because it needs to iterate over items from the beginning to
    find the item by its index. `QLinkedList` is suitable when you need to insert
    or remove items at the middle of a huge list multiple times. However, note that
    in practice, `QVector` still may sometimes be more performant in this case, because
    `QLinkedList` is not densely packed in memory, which adds some overhead.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLinkedList` 容器，正如其名所示，实现了一个链表。它的 STL 等价物是 `std::list`。与 `QVector` 相比，它可以在任何位置（开始、中间或末尾）快速插入和删除项目，但按索引查找较慢，因为它需要从开始遍历项目以找到按索引的项目。`QLinkedList`
    适用于需要多次在长列表中间插入或删除项目的情况。然而，请注意，在实际应用中，`QVector` 在这种情况下可能仍然更高效，因为 `QLinkedList`
    在内存中不是紧密打包的，这增加了额外的开销。'
- en: '`QSet`, a Qt equivalent of `std::unordered_set`, is an unordered collection
    of unique items. Its advantage is the ability to efficiently add items, remove
    items, and check whether a particular item is present in a collection. The other
    list classes are not able to do the last operation quickly, because they need
    to iterate over all items and compare each item with the argument. Like with any
    other collection, you can iterate over the set''s items, but the iteration order
    is not specified, that is, any item may appear on the first iteration, and so
    on. An example of the `QSet` API is shown in the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSet` 是 Qt 的 `std::unordered_set` 等效物，是一个无序的唯一项目集合。它的优点是能够高效地添加项目、删除项目以及检查特定项目是否存在于集合中。其他列表类无法快速执行最后操作，因为它们需要遍历所有项目并将每个项目与参数进行比较。像任何其他集合一样，你可以遍历集合的项目，但迭代顺序未指定，也就是说，任何项目都可能出现在第一次迭代中，依此类推。以下代码展示了
    `QSet` API 的一个示例：'
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The last flat collection is `QList`. Using it is currently not recommended,
    except when interacting with methods that accept or produce `QList` objects. Its
    performance and memory efficiency depends on the item type, and the rules that
    define "good" item types are complicated. For a "bad" type, `QList` is represented
    as a vector of `void *`, with each item stored as a separately allocated object
    on the heap. It's possible that `QList` implementation will change in Qt 6, but
    there is no official information about this yet.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个平面集合是 `QList`。目前不推荐使用它，除非与接受或生成 `QList` 对象的方法交互。它的性能和内存效率取决于项目类型，而定义“良好”项目类型的规则很复杂。对于“不良”类型，`QList`
    表示为一个 `void *` 向量，每个项目都作为单独分配的对象存储在堆上。`QList` 实现可能在 Qt 6 中发生变化，但目前还没有官方信息。
- en: 'There are some specialized list containers that provide extra functionality
    for a particular item type:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些专门列表容器为特定项目类型提供了额外的功能：
- en: The already familiar `QString` class is essentially a vector of `QChar` (16-bit
    Unicode characters)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经熟悉的 `QString` 类本质上是一个 `QChar`（16位Unicode字符）的向量
- en: The familiar `QByteArray` is a vector of `char`
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉的 `QByteArray` 是一个 `char` 向量
- en: '`QStringList` is a `QList<QString>` with additional convenient operations'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QStringList` 是一个带有额外便利操作的 `QList<QString>`'
- en: '`QBitArray` provides a memory-efficient array of bits with some useful APIs'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QBitArray` 提供了一个具有一些有用API的内存高效位数组'
- en: 'Next, there are two main key-value collections: `QMap<K, T>` and `QHash<K,
    T>`. They allow you to associate a value (or multiple values) of type `T` with
    a key of type `K`. They both provide relatively fast lookup by key. When iterating
    over a `QMap` (similar to `std::map`), the items are sorted by keys, regardless
    of the insertion order:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有两个主要的键值集合：`QMap<K, T>` 和 `QHash<K, T>`。它们允许你将类型为 `T` 的值（或多个值）与类型为 `K` 的键关联起来。它们都提供了相对快速的键查找。当遍历
    `QMap`（类似于 `std::map`）时，项目按键排序，而不考虑插入顺序：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`QHash` (similar to `std::unordered_map`) has very similar APIs to `QMap`,
    but will iterate over items in unspecified order, like `QSet`. You can replace
    `QMap` with `QHash` in the previous example and see that the iteration order will
    change even when running the same program repeatedly. In exchange, `QHash` provides
    faster on-average insertions and lookups by key than `QMap`. You should use `QHash`
    instead of `QMap` if the iteration order doesn''t matter to you.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`QHash`（类似于 `std::unordered_map`）与 `QMap` 有非常相似的API，但会按未指定的顺序遍历项目，就像 `QSet`。你可以在前面的例子中将
    `QMap` 替换为 `QHash`，并看到即使重复运行相同的程序，迭代顺序也会改变。作为交换，`QHash` 在平均插入和键查找方面比 `QMap` 更快。如果你不关心迭代顺序，你应该使用
    `QHash` 而不是 `QMap`。'
- en: An attentive reader may wonder how the code that looks very deterministic can
    produce random results. This randomness was intentionally introduced to protect
    against *algorithmic complexity attacks* on `QHash` and `QSet`. You can read the
    corresponding section of the `QHash` documentation page for more details about
    the attack and ways to configure the randomization.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一个细心的读者可能会想知道看起来非常确定性的代码如何产生随机结果。这种随机性是故意引入的，以防止对 `QHash` 和 `QSet` 的 *算法复杂性攻击*。你可以阅读
    `QHash` 文档页面的相应部分，了解更多关于攻击和配置随机化的方法。
- en: Finally, `QPair<T1, T2>` is a simple class that can hold two values of different
    types, just like `std::pair`. You can use the `qMakePair()` function to make a
    pair out of two values.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`QPair<T1, T2>` 是一个简单的类，可以持有两种不同类型的两个值，就像 `std::pair`。你可以使用 `qMakePair()`
    函数从两个值中创建一个对。
- en: Convenience containers
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 便利容器
- en: 'In addition to the containers described earlier, there are a few containers
    built on top of them that provide APIs and behavior that are more convenient in
    some special cases:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '| **Container** | **Description** |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| `QStack` | A `QVector` implementing the **last in, first out** (**LIFO**)
    structure. It contains the `push()` function for adding items to the stack, the `pop()`
    function for removing the top element, and the `top()` function for reading the
    top element without removing it. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| `QQueue` | A `QList` implementing the **first in, first out** (**FIFO**)
    structure. Use `enqueue()` to append an item to the queue, `dequeue()` to take
    the head item from the queue, and `head()` to read the head item without removing
    it. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| `QMultiMap` | A `QMap` with an API tailored for having multiple values for
    one key. `QMap` already allows us to do it; for example, you can add multiple
    items with one key using the `QMap::insertMulti()` method. However, `QMultiMap`
    renames it to `insert()` and hides the original `QMap::insert()` method that doesn''t
    allow multiple values per key. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| `QMultiHash` | Similar to `QMultiMap`, it''s a `QHash` with a more convenient
    API for storing multiple values per key. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| `QCache` | A key-value storage similar to `QHash` that allows you to implement
    a cache. `QCache` will delete its elements when they weren''t recently used to
    keep the size of cache under the maximum allowed size. Since there is no way to
    know how much space an arbitrary item actually consumes, you can manually specify
    a *cost* for each item and the maximum total cost for a particular `QCache` object.
    |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| `QContiguousCache` | A flat container that allows you to cache a sublist
    of a large list. This is useful, for example, when implementing a viewer for a
    large table, where reads and writes are likely to happen near the current scroll
    location. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: It's a good idea to use one of these classes when your task matches their use
    case.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Allowed item types
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all types can be put in containers. All containers can only hold types that
    provide a default constructor, a copy constructor, and an assignment operator.
    All primitive types and most Qt data types (such as `QString` or `QPointF`) satisfy
    these requirements. Simple structs also can be stored in a container because the
    required constructors and operators are generated for them automatically, as per
    C++ standard.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: A particular type usually cannot be put in a container because it doesn't have
    a constructor without arguments or copying this type was deliberately disabled.
    This is actually the case for `QObject` and all its descendants. The usage patterns
    of `QObject` suggest that you usually want to store pointers to a `QObject` to
    refer to it later. If that object was moved to a container or moved within a container,
    the pointer would be invalidated, so there is no copy constructor for these types.
    However, you can put pointers to `QObject` in containers (for example, `QVector<QObject
    *>`) because a pointer is a primitive type that satisfies all requirements. In
    this case, you have to manually ensure that your container will not contain any
    dangling pointers after the objects are deleted.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 特定类型通常不能放入容器中，因为它没有无参构造函数，或者故意禁用了此类型的复制。对于`QObject`及其所有子类来说，情况确实如此。`QObject`的使用模式表明，你通常想要存储指向`QObject`的指针以供以后引用。如果该对象被移动到容器中或容器内部移动，指针将被无效化，因此这些类型没有复制构造函数。然而，你可以将指向`QObject`的指针放入容器中（例如，`QVector<QObject
    *>`），因为指针是一种满足所有要求的基本类型。在这种情况下，你必须手动确保在对象被删除后，你的容器不会包含任何悬垂指针。
- en: The preceding restrictions apply to items of lists and *values* of key-value
    collections, but what about their keys? It turns out that the key types have more
    restrictions that depend on the collection type.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的限制适用于列表项和键值集合的*值*，但它们的键呢？事实证明，键类型有更多的限制，这取决于集合类型。
- en: '`QMap<K, T>` additionally requires that the key type `K` has the comparison
    operator `operator<` that provides a *total order* (that is, satisfies a particular
    set of axioms). As an exception, pointer types are also allowed as a key type.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMap<K, T>`还要求键类型`K`具有比较运算符`operator<`，它提供了一种*全序*（即满足一组特定的公理）。作为一个例外，指针类型也被允许作为键类型。'
- en: '`QHash<K, T>` and `QSet<K>` require that the `K` type has `operator==`, and
    a `qHash(K key)` function overload exists. Qt provides these overloads for a large
    number of types for which it''s possible, and you can create an overload for your
    custom type if needed.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`QHash<K, T>`和`QSet<K>`要求`K`类型具有`operator==`运算符，并且存在`qHash(K key)`函数重载。Qt为大量可能实现这些重载的类型提供了支持，如果需要，你可以为你的自定义类型创建重载。'
- en: Implicit sharing
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式共享
- en: 'One of the most significant differences between standard library containers
    and Qt''s is the implicit sharing feature. In STL, creating a copy of a container
    immediately results in a memory allocation and copying the data buffer:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库容器和Qt容器之间最显著的区别是隐式共享功能。在STL中，创建容器副本会立即导致内存分配并复制数据缓冲区：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you don't intend to edit the copy, this is essentially a waste of resources,
    and you want to avoid it. This can be easily done in some cases by providing a
    reference (`const std::vector<int> &`) instead of making a copy. However, sometimes
    it becomes hard to ensure that the reference will be valid long enough, for example,
    if you want to store it in a class field. An alternative way to solve this task
    is to wrap a vector in a `shared_ptr` to explicitly share it between multiple
    objects. This becomes unnecessary when you work with Qt containers and some other
    Qt types.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有打算编辑副本，这本质上是一种资源的浪费，你想要避免这种情况。在某些情况下，通过提供一个引用（`const std::vector<int> &`）而不是创建副本，可以轻松地做到这一点。然而，有时很难确保引用能够有效足够长的时间，例如，如果你想将其存储在类字段中。解决这个任务的另一种方法是使用`shared_ptr`包装一个向量，以显式地在多个对象之间共享它。当你使用Qt容器和一些其他Qt类型时，这变得不再必要。
- en: 'In Qt, all main container types implement **implicit sharing** or **copy-on-write**
    semantics. Copying a `QVector` will not result in a new memory allocation until
    either of the two vectors is changed:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt中，所有主要的容器类型都实现了**隐式共享**或**写时复制**语义。复制一个`QVector`不会导致新的内存分配，直到两个向量中的任何一个发生变化：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As long as no edits are made to the copy or the original object, the copying
    is very cheap. This allows you to cheaply and easily share constant data between
    objects without cluttering the code with manual management of shared objects.
    This feature is also implemented for `QString`, `QPen`, and many other Qt value
    types. Any copy operation still has some runtime overhead caused by reference
    counting, so you are encouraged to pass references instead of making copies when
    it's easy. However, this overhead is insignificant in most cases, except places
    with heavy computations.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 只要不对副本或原始对象进行编辑，复制成本非常低。这允许你以低成本轻松地在对象之间共享常量数据，而无需在代码中手动管理共享对象。此功能也适用于`QString`、`QPen`和许多其他Qt值类型。任何复制操作仍然有一些由引用计数引起的运行时开销，因此当容易时，你被鼓励传递引用而不是创建副本。然而，在大多数情况下，这种开销微不足道，除了计算密集型的地方。
- en: If you like implicit sharing, you can implement it in your own data types using
    `QSharedDataPointer`. Refer to its documentation for the in-depth instructions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢隐式共享，你可以使用`QSharedDataPointer`在自己的数据类型中实现它。请参阅其文档以获取详细说明。
- en: In most cases, you can just use the containers as if they didn't implement implicit
    sharing, but there are a few cases where you have to be aware of it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你可以像它们没有实现隐式共享一样使用容器，但有一些情况下你必须注意这一点。
- en: Pointer invalidation
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针失效
- en: 'First, implicit sharing means that holding any references or pointers to the
    container''s content is disallowed when there is a possibility of changing this
    object or any object that shares the same buffer. The following small example
    illustrates the problem:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，隐式共享意味着在有可能更改此对象或任何共享相同缓冲区的对象时，不允许持有对容器内容的任何引用或指针。以下小型示例说明了问题：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We initialized the `x0` variable with the pointer to the first element of the `x`
    vector. However, when we set a new value for that element and then tried to read
    it using the pointer, we got the old value again.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`x`向量的第一个元素的指针初始化了`x0`变量。然而，当我们为该元素设置新值然后尝试使用该指针读取它时，我们再次得到了旧值。
- en: What just happened?
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: As we copied the `x` vector to `y`, the state of two vectors became shared and
    the original buffer was available to both of them. However, when we modified `x`
    using `operator[]`, it became **detached**, that is, a new buffer was allocated
    for it, and `y` retained the original buffer. The `x0` pointer continues to point
    at the original buffer, which is now only available to `y`. If you remove the
    `QVector<int> y = x;` line, the output will change to the expected 42\. The general
    rule is that you should avoid storing pointers or references to the object's content
    while it's changed or shared with another object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`x`向量复制到`y`时，两个向量的状态变得共享，原始缓冲区对它们两个都可用。然而，当我们使用`operator[]`修改`x`时，它变成了**分离的**，也就是说，为它分配了新的缓冲区，而`y`保留了原始缓冲区。`x0`指针继续指向原始缓冲区，现在它只对`y`可用。如果你删除`QVector<int>
    y = x;`这一行，输出将变为预期的42。一般规则是，你应该避免在对象被修改或与另一个对象共享时存储指向其内容的指针或引用。
- en: Unnecessary allocation
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不必要的分配
- en: The next question is what actions on the object trigger the actual allocation
    of a new buffer? Obviously, `x[0] = 42` will trigger an allocation because the
    vector needs a buffer to write the new data to. However, `int i = x[0]` will also
    trigger an allocation if `x` is not declared as a `const` value or reference.
    That happens because in C++ this code triggers the non-const overload of `operator[]`
    if it's available, even though it's not necessary in this case. The vector doesn't
    know whether the requested item will or will not be changed, so it has to assume
    that it will be, and it triggers an allocation before returning a reference to
    the item in the new buffer.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的问题是，对对象采取哪些操作会触发新缓冲区的实际分配？显然，`x[0] = 42`会触发分配，因为向量需要一个缓冲区来写入新数据。然而，如果`x`没有声明为`const`值或引用，`int
    i = x[0]`也会触发分配。这是因为即使在这次情况下并不必要，C++中的此代码也会触发可用的非`const`重载的`operator[]`。向量不知道请求的项目是否会更改，因此它必须假设它将会更改，并在返回新缓冲区中项目引用之前触发分配。
- en: The same issue takes effect when using other methods that have const and non-const
    overloads, for example, `begin()` or `data()`. The range-based `for` loop also
    calls `begin()`, so it will also detach if you iterate over a non-const value.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用具有const和非const重载的其他方法时，也会出现相同的问题，例如`begin()`或`data()`。基于范围的`for`循环也会调用`begin()`，所以如果你迭代非`const`值，它也会分离。
- en: If you explicitly declare the container variable as const (for example, `const
    QVector<int> y` or `const QVector<int> &y`), the non-const methods will not be
    available, and it will not be possible to trigger an allocation using this variable.
    An alternative solution is to use special method aliases that are only available
    for const versions, such as `at()` for `operator=`, `constBegin()` for `begin()`,
    and `constData()` for `data()`. This solution is not usable with range-based `for`
    loop, though.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你显式地将容器变量声明为 const（例如，`const QVector<int> y` 或 `const QVector<int> &y`），则不可用非
    const 方法，并且无法使用此变量触发分配。一个替代方案是使用仅对 const 版本可用的特殊方法别名，例如 `at()` 用于 `operator=`，`constBegin()`
    用于 `begin()`，以及 `constData()` 用于 `data()`。然而，此解决方案不适用于基于范围的 `for` 循环。
- en: Range-based for and Qt foreach macro
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于范围的 `for` 循环和 Qt `foreach` 宏
- en: 'Qt provides the `foreach` macro for iterating over Qt containers:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 提供了用于遍历 Qt 容器的 `foreach` 宏：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This macro was available long before the range-based `for` loop made it into
    the C++ standard, so it's still very common in Qt code, and you should be familiar
    with it. The `foreach` loop always creates a temporary constant copy of the iterated
    object. Since it uses implicit sharing, this is very cheap. If you edit `x` while
    iterating over it, the changes will not affect the values of `i` because the iteration
    uses a copy, but this also means that such an operation is safe. Note that when
    using range-based `for` loop, STL-style iterators, or Java-style iterators, editing
    the same container you're iterating over is generally not safe. For example, changing
    item values may be permitted, but deleting an item may result in undefined behavior.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏在基于范围的 `for` 循环进入 C++ 标准之前就已经可用，因此在 Qt 代码中仍然非常常见，你应该熟悉它。`foreach` 循环始终创建迭代对象的临时常量副本。由于它使用隐式共享，这非常便宜。如果你在遍历
    `x` 时编辑它，更改将不会影响 `i` 的值，因为迭代使用的是副本，但这也意味着这种操作是安全的。请注意，当使用基于范围的 `for` 循环、STL 风格迭代器或
    Java 风格迭代器时，编辑你正在遍历的同一容器通常是不安全的。例如，更改项目值可能是允许的，但删除项目可能会导致未定义的行为。
- en: We discussed how range-based `for` loop can cause a deep copy of the containers.
    The `foreach` macro by itself will never cause a deep copy. However, if you edit
    the container while iterating over it, this will result in a deep copy, because
    two versions of data have to be stored somewhere.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了基于范围的 `for` 循环如何导致容器深拷贝。`foreach` 宏本身永远不会导致深拷贝。然而，如果你在遍历容器的同时编辑它，这将导致深拷贝，因为必须将两个数据版本存储在某个地方。
- en: 'When using the range-based `for` loop, you should be careful not to pass a
    reference to a temporary object. For example, this code looks legitimate, but
    it results in undefined behavior:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基于范围的 `for` 循环时，你应该小心不要传递临时对象的引用。例如，此代码看起来合法，但它会导致未定义的行为：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: What just happened?
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: 'We created a temporary `QString` object and called its `replace()` method.
    This method'' s return type is `QString &`, so it doesn''t own the string''s data.
    If we immediately assigned this value to an owning variable, it would be correct
    because the life of the original temporary `QString` lasts until the end of the
    full expression (in this case, the assignment):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个临时的 `QString` 对象并调用了它的 `replace()` 方法。此方法的返回类型是 `QString &`，因此它不拥有字符串的数据。如果我们立即将此值赋给拥有变量，则它是正确的，因为原始临时
    `QString` 的生命周期持续到整个表达式结束（在这种情况下，赋值）：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: However, the temporary object in the original example doesn't live until the
    end of the `for` loop, so this will result in a use-after-free bug. The `foreach`
    version of this code would contain an implicit assignment to a variable, so it
    would be correct.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，原始示例中的临时对象在 `for` 循环结束时不会存活，因此这会导致使用后释放的漏洞。此代码的 `foreach` 版本将包含对变量的隐式赋值，因此它是正确的。
- en: 'On the other hand, the macro nature of `foreach` is its disadvantage. For example,
    the following code does not compile because the item type contains a comma:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`foreach` 的宏特性是其缺点。例如，以下代码无法编译，因为项目类型包含逗号：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The error is "macro `Q_FOREACH` passed 3 arguments, but takes just 2". To fix
    this issue, you have to create a `typedef` for the item type.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是 "宏 `Q_FOREACH` 传递了 3 个参数，但它只接受 2 个"。要修复此问题，你必须为项目类型创建一个 `typedef`。
- en: Since C++11, range-based `for` loop is a native, clean alternative to `foreach`,
    so we suggest that you prefer the native construct over the macro, but keep in
    mind the pitfalls we described.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C++11 以来，基于范围的 `for` 循环是 `foreach` 的本地、干净的替代方案，因此我们建议你优先选择本地构造而不是宏，但请记住我们描述的陷阱。
- en: Data storage
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据存储
- en: When implementing games, you will often have to work with persistent data; you
    will need to store the saved game data, load maps, and so on. For that, you have
    to learn about the mechanisms that let you use the data stored on digital media.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现游戏时，你经常会需要处理持久数据；你需要存储保存的游戏数据、加载地图等。为此，你必须了解让你可以使用存储在数字媒体上的数据的机制。
- en: Files and devices
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和设备
- en: The most basic and low-level mechanism that is used to access data is to save
    and load it from the files. While you can use the classic file access approaches
    provided by C and C++, such as `stdio` or `iostream`, Qt provides its own file
    abstraction that hides platform-dependent details and provides a clean API that
    works across all platforms in a uniform manner.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 用于访问数据的最低级和最基本机制是从文件中保存和加载它。虽然你可以使用C和C++提供的经典文件访问方法，例如`stdio`或`iostream`，但Qt提供了自己的文件抽象，它隐藏了平台相关的细节，并提供了一个在所有平台上以统一方式工作的干净API。
- en: The two basic classes that you will work with when using files are `QDir` and
    `QFile`. The former represents the contents of a directory, lets you traverse
    filesystems, creates and remove directories, and finally, accesses all files in
    a particular directory.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用文件时，你将与之合作的两个基本类是`QDir`和`QFile`。前者代表目录的内容，允许你遍历文件系统、创建和删除目录，最后，访问特定目录中的所有文件。
- en: Traversing directories
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历目录
- en: Traversing directories with `QDir` is really easy. The first thing to do is
    to have an instance of `QDir` in the first place. The easiest way to do this is
    to pass the directory path to the `QDir` constructor.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`QDir`遍历目录非常简单。首先，你需要有一个`QDir`实例。最简单的方法是将目录路径传递给`QDir`构造函数。
- en: Qt handles file paths in a platform-independent way. Even though the regular
    directory separator on Windows is a backward slash character (`\`) and on other
    platforms it is the forward slash (`/`), Qt internally always uses the forward
    slash, and paths returned by most Qt methods never contain backward slashes. You
    can always use forward slashes when passing paths to Qt methods, even on Windows.
    If you need to convert the Qt's path representation to the native form (for example,
    for passing it to the standard library or a third-party library), you can use
    `QDir::toNativeSeparators()`. `QDir::fromNativeSeparators()`  to perform the inverse
    operation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Qt以平台无关的方式处理文件路径。尽管Windows上的常规目录分隔符是反斜杠字符（`\`），而其他平台上是正斜杠（`/`），Qt内部始终使用正斜杠，并且大多数Qt方法返回的路径从不包含反斜杠。你始终可以使用正斜杠将路径传递给Qt方法，即使在Windows上也是如此。如果你需要将Qt的路径表示形式转换为本地形式（例如，传递给标准库或第三方库），可以使用`QDir::toNativeSeparators()`。`QDir::fromNativeSeparators()`执行相反的操作。
- en: 'Qt provides a number of static methods to access some special directories.
    The following table lists these special directories and functions that access
    them:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了一系列静态方法来访问一些特殊目录。以下表格列出了这些特殊目录及其访问函数：
- en: '| **Access function** | **Directory** |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| **访问函数** | **目录** |'
- en: '| `QDir::current()` | The current working directory |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::current()` | 当前工作目录 |'
- en: '| `QDir::home()` | The home directory of the current user |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::home()` | 当前用户的家目录 |'
- en: '| `QDir::root()` | The root directory—usually `/` for Unix and `C:\` for Windows
    |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::root()` | 根目录——通常在Unix系统中为`/`，在Windows系统中为`C:\` |'
- en: '| `QDir::temp()` | The system temporary directory |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::temp()` | 系统临时目录 |'
- en: The `QStandardPaths` class provides information about other standard locations
    present in the system. For example, `QStandardPaths::writableLocation(QStandardPaths::MusicLocation)`
    returns path to the user's music folder.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`QStandardPaths`类提供了关于系统中存在的其他标准位置的信息。例如，`QStandardPaths::writableLocation(QStandardPaths::MusicLocation)`返回用户音乐文件夹的路径。'
- en: Refer to the `QStandardPaths::StandardLocation` enum documentation for the list
    of available locations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考`QStandardPaths::StandardLocation`枚举文档以获取可用位置列表。
- en: When you already have a valid `QDir` object, you can start moving between directories.
    To do that, you can use the `cd()` and `cdUp()` methods. The former moves to the
    named subdirectory, while the latter moves to the parent directory. You should
    always check that these commands were successful. If they return `false`, your
    `QDir` object will remain in the same directory!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当你已经有一个有效的`QDir`对象时，你可以开始在不同目录之间移动。为此，你可以使用`cd()`和`cdUp()`方法。前者移动到命名的子目录，而后者移动到父目录。你应该始终检查这些命令是否成功。如果它们返回`false`，你的`QDir`对象将保持在同一目录！
- en: 'To list files and subdirectories in a particular directory, you can use the
    `entryList()` method, which returns a list of entries in the directory that match
    the criteria passed to `entryList()`. The `filters` argument takes a list of flags
    that correspond to the different attributes that an entry needs to have to be
    included in the result. The most useful flags are listed in the following table:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出特定目录中的文件和子目录，您可以使用 `entryList()` 方法，该方法返回与 `entryList()` 传递的准则匹配的目录条目列表。`filters`
    参数接受一个标志列表，这些标志对应于条目需要具有的不同属性才能包含在结果中。以下表格列出了最有用的标志：
- en: '| **Filter** | **Meaning** |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| **过滤器** | **含义** |'
- en: '| `QDir::Dirs`, `QDir::Files`, `QDir::Drives` | List directories, files, or
    Windows drives. You should specify at least one of these filters to get any results.
    |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::Dirs`, `QDir::Files`, `QDir::Drives` | 列出目录、文件或 Windows 驱动器。您至少应指定这些过滤器之一以获取任何结果。
    |'
- en: '| `QDir::AllEntries` | List directories, files, and drives. This is a shortcut
    for `Dirs &#124; Files &#124; Drives`. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::AllEntries` | 列出目录、文件和驱动器。这是 `Dirs | Files | Drives` 的快捷方式。 |'
- en: '| `QDir::AllDirs` | List directories even if they don''t match the name filters.
    |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::AllDirs` | 即使它们不匹配名称过滤器，也会列出目录。 |'
- en: '| `QDir::NoDotAndDotDot` | Don''t list `.` (current directory) and `..` (parent
    directory) entries. If `Dirs` flag is present and `NoDotAndDotDot` is not, these
    entries will always be listed. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::NoDotAndDotDot` | 不要列出 `.`（当前目录）和 `..`（父目录）条目。如果存在 `Dirs` 标志且未指定 `NoDotAndDotDot`，则这些条目将始终列出。
    |'
- en: '| `QDir::Readable`, `QDir::Writable`, `QDir::Executable` | List only entries
    that can be read, written to, or executed. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::Readable`, `QDir::Writable`, `QDir::Executable` | 仅列出可读、可写或可执行的项目。
    |'
- en: '| `QDir::Hidden`, `QDir::System` | List hidden files and system files. If these
    flags are not specified, hidden and system flags will not be listed. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::Hidden`, `QDir::System` | 列出隐藏文件和系统文件。如果未指定这些标志，则不会列出隐藏和系统标志。 |'
- en: 'The `sort` argument of `entryList()` allows you to choose the ordering of the
    results:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`entryList()` 的 `sort` 参数允许您选择结果的排序方式：'
- en: '| **Flag** | **Meaning** |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **标志** | **含义** |'
- en: '| `QDir::Unsorted` | The order of entries is undefined. It''s a good idea to
    use it if the order doesn''t matter to you, since it may be faster. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::Unsorted` | 项目顺序未定义。如果您不关心顺序，使用它是个好主意，因为它可能更快。 |'
- en: '| `QDir::Name`, `QDir::Time`, `QDir::Size`, `QDir::Type` | Sort by appropriate
    entry attributes. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::Name`, `QDir::Time`, `QDir::Size`, `QDir::Type` | 按适当的条目属性排序。 |'
- en: '| `QDir::DirsFirst`, `QDir::DirsLast` | Determines whether directories should
    be listed before or after files. If neither flag is specified, directories will
    be mixed with files in the output. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::DirsFirst`, `QDir::DirsLast` | 确定目录是否应在文件之前或之后列出。如果未指定任何标志，则目录将与文件混合在输出中。
    |'
- en: '| `QDir::Reversed` | Reverses the order. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `QDir::Reversed` | 反转顺序。 |'
- en: 'Additionally, there is an overload of `entryList()` that accepts a list of
    file name patterns in the form of `QStringList` as its first parameter. Here''s
    an example call that returns all JPEG files in the directory sorted by size:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`entryList()` 方法还有一个重载版本，它接受一个以 `QStringList` 形式的文件名模式列表作为其第一个参数。以下是一个示例调用，它返回目录中所有按大小排序的
    JPEG 文件：
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Besides `entryList()`, there is the `entryInfoList()` method that wraps each
    returned file name in a `QFileInfo` object that has many convenient functions.
    For example, `QFileInfo::absoluteFilePath()` returns the absolute path to the
    file, and `QFileInfo::suffix()` returns the extension of the file.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `entryList()` 方法之外，还有一个 `entryInfoList()` 方法，它将每个返回的文件名包裹在一个具有许多方便功能的 `QFileInfo`
    对象中。例如，`QFileInfo::absoluteFilePath()` 返回文件的绝对路径，而 `QFileInfo::suffix()` 返回文件的扩展名。
- en: If you need to traverse directories recursively (for example, for finding all
    files in all subdirectories), you can use the `QDirIterator` class.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要递归遍历目录（例如，用于在所有子目录中查找所有文件），则可以使用 `QDirIterator` 类。
- en: Reading and writing files
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入文件
- en: 'Once you know the path to a file (for example, using `QDir::entryList()`, `QFileDialog::getOpenFileName()`,
    or some external source), you can pass it to `QFile` to receive an object that
    acts as a handle to the file. Before the file contents can be accessed, the file
    needs to be opened using the `open()` method. The basic variant of this method
    takes a mode in which we need to open the file. The following table explains the
    modes that are available:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您知道了文件的路径（例如，使用 `QDir::entryList()`、`QFileDialog::getOpenFileName()` 或某些外部来源），您就可以将其传递给
    `QFile` 以接收一个作为文件句柄的对象。在可以访问文件内容之前，需要使用 `open()` 方法打开文件。此方法的基本变体需要一个模式，其中我们需要打开文件。以下表格解释了可用的模式：
- en: '| **Mode** | **Description** |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **描述** |'
- en: '| `ReadOnly` | This file can be read from. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `只读` | 此文件可读取。|'
- en: '| `WriteOnly` | This file can be written to. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `只写` | 此文件可写入。|'
- en: '| `ReadWrite` | This file can be read from and written to. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `读写` | 此文件可读取和写入。|'
- en: '| `Append` | All data writes will be written at the end of the file. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `追加` | 所有数据写入都将写入文件末尾。|'
- en: '| `Truncate` | If the file is present, its content is deleted before we open
    it. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `截断` | 如果文件存在，在打开文件之前，其内容将被删除。|'
- en: '| `Text` | When reading, all line endings are transformed to `\n`. When writing,
    all `\n` symbols are transformed to the native format (for example, `\r\n` on
    Windows or `\n` on Linux). |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `文本` | 读取时，所有行结束符都转换为 `\n`。写入时，所有 `\n` 符号都转换为本地格式（例如，Windows 上的 `\r\n` 或
    Linux 上的 `\n`）。|'
- en: '| `Unbuffered` | The flag prevents the file from being buffered. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `无缓冲` | 该标志防止文件被缓冲。|'
- en: 'The `open()` method returns `true` or `false`, depending on whether the file
    was opened or not. The current status of the file can be checked by calling `isOpen()`
    on the file object. Once the file is open, it can be read from or written to,
    depending on the options that are passed when the file is opened. Reading and
    writing is done using the `read()` and `write()` methods. These methods have a
    number of overloads, but we suggest that you focus on using those variants that
    accept or return the already familiar `QByteArray` objects, because they manage
    the memory automatically. If you are working with plain text, then a useful overload
    for `write` is the one that accepts the text directly as input. Just remember
    that the text has to be null terminated. When reading from a file, Qt offers a
    number of other methods that might come in handy in some situations. One of these
    methods is `readLine()`, which tries to read from the file until it encounters
    a new line character. If you use it along with the `atEnd()` method that tells
    you whether you have reached the end of the file, you can realize the line-by-line
    reading of a text file:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()` 方法返回 `true` 或 `false`，取决于文件是否已打开。可以通过在文件对象上调用 `isOpen()` 来检查文件当前的状态。一旦文件打开，就可以根据打开文件时传递的选项进行读取或写入。读取和写入是通过
    `read()` 和 `write()` 方法完成的。这些方法有许多重载，但我们建议您专注于使用那些接受或返回已熟悉的 `QByteArray` 对象的变体，因为它们自动管理内存。如果您正在处理纯文本，那么
    `write` 的一个有用的重载是直接接受文本作为输入的变体。只需记住，文本必须以空字符终止。当从文件读取时，Qt 提供了其他一些可能在某些情况下很有用的方法。其中一种方法是
    `readLine()`，它尝试从文件中读取，直到遇到新行字符。如果您与 `atEnd()` 方法一起使用，后者告诉您是否已到达文件末尾，您就可以实现逐行读取文本文件：'
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Another useful method is `readAll()`, which simply returns the file content,
    starting from the current position of the file pointer until the end of the file.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的方法是 `readAll()`，它简单地返回文件内容，从文件指针的当前位置开始，直到文件末尾。
- en: You have to remember, though, that when using these helper methods, you should
    be really careful if you don't know how much data the file contains. It might
    happen that when reading line by line or trying to read the whole file into memory
    in one step, you exhaust the amount of memory that is available for your process.
    If you only intend to work with small files that fit into memory, you can check
    the size of the file by calling `size()` on the `QFile` instance and abort if
    the file is too large. If you need to handle arbitrary files, however, you should
    process the file's data in steps, reading only a small portion of bytes at a time.
    This makes the code more complex but allows us to manage the available resources
    better.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你必须记住，在使用这些辅助方法时，如果你不知道文件包含多少数据，你应该非常小心。可能会发生这种情况，当你逐行读取或尝试一次性将整个文件读入内存时，你会耗尽进程可用的内存量。如果你只想处理适合内存的小文件，你可以通过在`QFile`实例上调用`size()`来检查文件大小，如果文件太大则终止。然而，如果你需要处理任意大小的文件，你应该分步骤处理文件数据，每次只读取一小部分字节。这使得代码更复杂，但可以更好地管理可用资源。
- en: 'If you require constant access to the file, you can use the `map()` and `unmap()`
    calls that add and remove mappings of the parts of a file to a memory address
    that you can then use like a regular array of bytes:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要持续访问文件，你可以使用`map()`和`unmap()`调用，这些调用将文件的部分映射到内存地址，然后你可以像使用常规字节数组一样使用它：
- en: '[PRE42]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The mapping will automatically be removed when the `QFile` object is destroyed.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当`QFile`对象被销毁时，映射将自动删除。
- en: Devices
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备
- en: '`QFile` is really a descendant class of `QIODevice` ("input/output device"),
    which is a Qt interface used to abstract entities related to reading and writing
    of blocks of data. There are two types of devices: sequential and random access
    devices. `QFile` belongs to the latter group; it has the concepts of start, end,
    size, and current position that can be changed by the user with the `seek()` method.
    Sequential devices, such as sockets and pipes, represent streams of data—there
    is no way to rewind the stream or check its size; you can only keep reading the
    data sequentially—piece by piece, and you can check how far away you currently
    are from the end of data. We will work with such devices in [Chapter 7](b2ab510e-2a42-4ccb-b121-ab4ce5541893.xhtml),
    *Networking*.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`QFile`实际上是`QIODevice`（"输入/输出设备"）的子类，`QIODevice`是Qt接口，用于抽象与读取和写入数据块相关的实体。有两种类型的设备：顺序访问设备和随机访问设备。`QFile`属于后者；它具有起始、结束、大小和当前位置的概念，用户可以通过`seek()`方法更改这些概念。顺序设备，如套接字和管道，表示数据流——无法回滚流或检查其大小；你只能按顺序逐个读取数据——一次读取一部分，你可以检查你目前距离数据末尾有多远。我们将在[第7章](b2ab510e-2a42-4ccb-b121-ab4ce5541893.xhtml)，*网络*中处理此类设备。'
- en: All I/O devices can be opened and closed. They all implement the `open()`, `read()`,
    and `write()` interfaces. Writing to the device queues the data for writing; when
    the data is actually written, the `bytesWritten()` signal is emitted that carries
    the amount of data that was written to the device. If more data becomes available
    in the sequential device, it emits the `readyRead()` signal, which informs you
    that if you call `read` now, you can expect to receive some data from the device.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 所有I/O设备都可以打开和关闭。它们都实现了`open()`、`read()`和`write()`接口。向设备写入数据会将数据排队等待写入；当数据实际写入时，会发出`bytesWritten()`信号，该信号携带写入设备的数据量。如果在顺序设备中还有更多数据可用，它会发出`readyRead()`信号，通知你如果现在调用`read`，你可以期待从设备接收一些数据。
- en: Time for action – Implementing a device to encrypt data
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 实现加密数据的设备
- en: Let's implement a really simple device that encrypts or decrypts the data that
    is streamed through it using a very simple algorithm—the Caesar cipher. When encrypting,
    it shifts each character in the plaintext by a number of characters defined by
    the key. It does the reverse when decrypting. Thus, if the key is `2` and the
    plaintext character is `a`, the ciphertext becomes `c`. Decrypting `z` with the
    key `4` will yield the value `v`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个非常简单的设备，该设备使用一个非常简单的算法——凯撒密码来加密或解密通过它的数据流。在加密时，它将明文中的每个字符按密钥定义的字符数进行移位。解密时执行相反操作。因此，如果密钥是`2`，明文字符是`a`，密文变为`c`。使用密钥`4`解密`z`将得到值`v`。
- en: 'First, create a new empty project by selecting the Empty qmake Project template
    from the Other Project category. Next, add a `main.cpp` file and a new `CaesarCipherDevice`
    class derived from `QIODevice`. The basic interface of the class will accept an
    integer key and set an underlying device that serves as the source or destination
    of data. This is all simple coding that you should already understand, so it shouldn''t
    need any extra explanation, as shown:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过从“其他项目”类别中选择“空qmake项目模板”来创建一个新的空项目。接下来，添加一个`main.cpp`文件和一个新的`CaesarCipherDevice`类，该类从`QIODevice`派生。该类的基本接口将接受一个整数密钥并设置一个作为数据源或目的地的底层设备。这些都是你应该已经理解的简单编码，因此不需要任何额外的解释，如下所示：
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The next thing is to ensure that the device cannot be used if there is no device
    to operate on (that is, when `m_baseDevice == nullptr`). For this, we have to
    reimplement the `QIODevice::open()` method and return `false` when we want to
    prevent operating on our device:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确保如果没有设备可以操作（即当`m_baseDevice == nullptr`时），则不能使用该设备。为此，我们必须重新实现`QIODevice::open()`方法，并在我们想要防止操作我们的设备时返回`false`：
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The method accepts the mode that the user wants to open the device with. We
    perform an additional check to verify that the base device was opened in the same
    mode before calling the base class implementation that will mark the device as
    open.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受用户想要以何种模式打开设备。我们在调用基类实现之前执行一个额外的检查，以验证基础设备是否以相同的模式打开，这将标记设备为打开。
- en: It's a good idea to call `QIODevice::setErrorString` to let the user know about
    an error. Additionally, you can use `qWarning("message")` to print a warning to
    the console when an error occurs.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`QIODevice::setErrorString`来让用户知道错误是一个好主意。此外，当发生错误时，可以使用`qWarning("message")`将警告打印到控制台。
- en: 'To have a fully functional device, we still need to implement the two protected
    pure virtual methods, which do the actual reading and writing. These methods are
    called by Qt from other methods of the class when needed. Let''s start with `writeData()`,
    which accepts a pointer to a buffer containing the data and size equal to that
    of a buffer:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要有一个完全功能性的设备，我们仍然需要实现两个受保护的纯虚方法，这些方法执行实际的读取和写入。这些方法在需要时由Qt从类的其他方法调用。让我们从`writeData()`开始，它接受一个包含数据的缓冲区的指针和与缓冲区大小相等的大小：
- en: '[PRE45]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: First, we create a local byte array and resize it to the length of the input.
    Then, we iterate bytes of the input, add the value of the key to each byte (which
    effectively performs the encryption) and put it in the byte array. Finally, we
    try to write the byte array to the underlying device. Before informing the caller
    about the amount of data that was really written, we emit a signal that carries
    the same information.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个局部字节数组并将其调整到输入的长度。然后，我们迭代输入的字节，将密钥的值添加到每个字节（这实际上执行了加密）并将其放入字节数组中。最后，我们尝试将字节数组写入底层设备。在通知调用者实际写入的数据量之前，我们发出一个携带相同信息的信号。
- en: The last method we need to implement is the one that performs decryption by
    reading from the base device and adding the key to each cell of the data. This
    is done by implementing `readData()`, which accepts a pointer to the buffer that
    the method needs to write to and the size of the buffer.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一种方法是通过对基础设备进行读取并添加密钥到数据中的每个单元格来执行解密。这是通过实现`readData()`来完成的，它接受一个指向方法需要写入的缓冲区的指针以及缓冲区的大小。
- en: 'The code is quite similar to that of `writeData()`, except that we are subtracting
    the key value instead of adding it:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与`writeData()`非常相似，只是我们是在减去密钥值而不是添加它：
- en: '[PRE46]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First, we try to read `maxlen` bytes from the underlying device and store the
    data in a byte array. Note that the byte array can contain fewer bytes than `maxlen`
    (for example, if we reached the end of the file) but it can't contain more. Then,
    we iterate the array and set subsequent bytes of data buffer to the decrypted
    value. Finally, we return the amount of data that was really read.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们尝试从底层设备读取`maxlen`个字节并将数据存储在字节数组中。请注意，字节数组可能包含少于`maxlen`个字节（例如，如果我们到达了文件的末尾），但它不能包含更多。然后，我们迭代数组并将数据缓冲区的后续字节设置为解密值。最后，我们返回实际读取的数据量。
- en: 'A simple `main()` function that can test the class looks as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`main()`函数，可以测试该类，如下所示：
- en: '[PRE47]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We use the `QBuffer` class that implements the `QIODevice` API and acts as an
    adapter for `QByteArray` or `QString`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用实现`QIODevice` API并作为`QByteArray`或`QString`适配器的`QBuffer`类。
- en: What just happened?
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We created an encryption object and set its key to `3`. We also told it to use
    a `QBuffer` instance to store the processed content. After opening it for writing,
    we sent some data to it that gets encrypted and written to the base device. Then,
    we created a similar device, passing the same buffer again as the base device,
    but now, we open the device for reading. This means that the base device contains
    ciphertext. After this, we read all data from the device, which results in reading
    data from the buffer, decrypting it, and returning the data so that it can be
    written to the debug console.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个加密对象，并将其密钥设置为`3`。我们还告诉它使用一个`QBuffer`实例来存储处理后的内容。在打开它以供写入后，我们向其中发送了一些数据，这些数据被加密并写入到基本设备中。然后，我们创建了一个类似的设备，再次将相同的缓冲区作为基本设备传递，但现在，我们打开设备以供读取。这意味着基本设备包含密文。在此之后，我们从设备中读取所有数据，这导致从缓冲区中读取数据，解密它，并将数据返回以便写入调试控制台。
- en: Have a go hero – A GUI for the Caesar cipher
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄——凯撒密码的GUI
- en: You can combine what you already know by implementing a full-blown GUI application
    that is able to encrypt or decrypt files using the Caesar cipher `QIODevice` class
    that we just implemented. Remember that `QFile` is also `QIODevice`, so you can
    pass its pointer directly to `setBaseDevice()`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过实现一个完整的GUI应用程序来结合你已知的知识，该应用程序能够使用我们刚刚实现的凯撒密码`QIODevice`类加密或解密文件。记住，`QFile`也是`QIODevice`，所以你可以直接将其指针传递给`setBaseDevice()`。
- en: This is just a starting point for you. The `QIODevice` API is quite rich and
    contains numerous methods that are virtual, so you can reimplement them in subclasses.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是你的起点。`QIODevice` API非常丰富，包含许多虚拟方法，因此你可以在子类中重新实现它们。
- en: Text streams
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本流
- en: Much of the data produced by computers nowadays is based on text. You can create
    such files using a mechanism that you already know—opening `QFile` to write, converting
    all data into strings using `QString::arg()`, optionally encoding strings using
    `QTextCodec`, and dumping the resulting bytes to the file by calling `write`.
    However, Qt provides a nice mechanism that does most of this automatically for
    you in a way similar to how the standard C++ `iostream` classes work. The `QTextStream`
    class operates on any `QIODevice` API in a stream-oriented way. You can send tokens
    to the stream using the `<<` operator, where they get converted into strings,
    separated by spaces, encoded using a codec of your choice, and written to the
    underlying device. It also works the other way round; using the `>>` operator,
    you can stream data from a text file, transparently converting it from strings
    to appropriate variable types. If the conversion fails, you can discover it by
    inspecting the result of the `status()` method—if you get `ReadPastEnd` or `ReadCorruptData`,
    it means that the read has failed.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现今计算机产生的数据大多基于文本。你可以使用你已知的机制创建此类文件——打开`QFile`以供写入，使用`QString::arg()`将所有数据转换为字符串，可选地使用`QTextCodec`对字符串进行编码，并通过调用`write`将生成的字节写入文件。然而，Qt提供了一个很好的机制，可以自动为你完成大部分工作，其工作方式类似于标准C++
    `iostream`类。`QTextStream`类以流式方式操作任何`QIODevice` API。你可以使用`<<`运算符向流中发送标记，它们将被转换为字符串，用空格分隔，并使用你选择的编解码器编码，然后写入底层设备。它也可以反过来工作；使用`>>`运算符，你可以从文本文件中流式传输数据，透明地将字符串转换为适当的变量类型。如果转换失败，你可以通过检查`status()`方法的结果来发现它——如果你得到`ReadPastEnd`或`ReadCorruptData`，这意味着读取失败。
- en: While `QIODevice` is the main class that `QTextStream` operates on, it can also
    manipulate `QString` or `QByteArray`, which makes it useful for us to compose
    or parse strings.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`QIODevice`是`QTextStream`操作的主要类，但它也可以操作`QString`或`QByteArray`，这使得它在为我们组合或解析字符串时非常有用。
- en: 'Using `QTextStream` is simple—you just pass a device to its constructor, and
    you''re good to go. The  `QTextStream` object will read to or write from that
    device. By default, `QTextStream` uses the encoding specified by the current locale,
    but if it encounters a UTF-16 or UTF-32 BOM (byte order mark), it will switch
    to the encoding specified by the BOM. The stream accepts strings and numerical
    values:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`QTextStream`很简单——你只需将其设备传递给构造函数，然后就可以使用了。`QTextStream`对象将从这个设备中读取或写入。默认情况下，`QTextStream`使用当前区域设置的编码，但如果它遇到UTF-16或UTF-32的字节顺序标记（BOM），它将切换到由BOM指定的编码。流接受字符串和数值：
- en: '[PRE48]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Apart from directing content into the stream, the stream can accept a number
    of manipulators, such as `endl`, which have a direct or indirect influence on
    how the stream behaves. For instance, you can tell the stream to display a number
    as decimal and another as hexadecimal with uppercase digits using the following
    code (highlighted in the code are all manipulators):'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将内容定向到流中，流还可以接受多个操纵器，例如`endl`，它们直接或间接地影响流的行为。例如，你可以告诉流将一个数字以十进制显示，另一个以大写十六进制数字显示，如下面的代码所示（代码中突出显示的都是操纵器）：
- en: '[PRE49]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This is not the end of the capabilities of `QTextStream`. It also allows us
    to display data in a tabular manner by defining column widths and alignments.
    Consider a game player record defined by the following structure:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是`QTextStream`功能的终点。它还允许我们通过定义列宽和对齐方式以表格形式显示数据。考虑以下由以下结构定义的游戏玩家记录：
- en: '[PRE50]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Suppose you have a set of records for players stored in a `QVector<Player>
    players` variable. Let''s dump such information into a file in a tabular manner:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一组存储在`QVector<Player> players`变量中的玩家记录。让我们以表格形式将这些信息写入文件：
- en: '[PRE51]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The program creates a file that should look like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 程序创建的文件应该看起来像这样：
- en: '[PRE52]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'One last thing about `QTextStream` is that it can operate on standard C file
    structures, which makes it possible for us to use `QTextStream` to, for example,
    write to `stdout` or read from `stdin`, as shown in the following code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`QTextStream`的最后一件事是，它可以操作标准的C文件结构，这使得我们能够使用`QTextStream`，例如，写入`stdout`或从`stdin`读取，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Binary streams
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制流
- en: More than often, we have to store object data in a device-independent way so
    that it can be restored later, possibly on a different machine with a different
    data layout and so on. In computer science, this is called **serialization**.
    Qt provides several serialization mechanisms and now we will take a brief look
    at some of them.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的时候，我们必须以设备无关的方式存储对象数据，以便以后可以恢复，可能在不同的机器上，具有不同的数据布局等等。在计算机科学中，这被称为**序列化**。Qt提供了几种序列化机制，现在我们将简要地看看其中的一些。
- en: If you look at `QTextStream` from a distance, you will note that what it really
    does is serialize and deserialize data to a text format. Its close cousin is the
    `QDataStream` class that handles serialization and deserialization of arbitrary
    data to a binary format. It uses a custom data format to store and retrieve data
    from `QIODevice` in a platform-independent way. It stores enough data so that
    a stream written on one platform can be successfully read on a different platform.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从远处看`QTextStream`，你会注意到它真正做的是将数据序列化和反序列化到文本格式。它的近亲是`QDataStream`类，它处理任意数据的序列化和反序列化到二进制格式。它使用自定义数据格式以平台无关的方式从`QIODevice`存储和检索数据。它存储足够的数据，以便在一个平台上写入的流可以在不同的平台上成功读取。
- en: '`QDataStream` is used in a similar fashion as `QTextStream`—the `<<` and `>>`
    operators are used to redirect data into or out of the stream. The class supports
    most of the built-in Qt data types so that you can operate on classes such as
    `QColor`, `QPoint`, or `QStringList` directly:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDataStream`的使用方式与`QTextStream`类似——使用`<<`和`>>`运算符将数据重定向到或从流中。该类支持大多数内置的Qt数据类型，因此你可以直接操作`QColor`、`QPoint`或`QStringList`等类：'
- en: '[PRE54]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you want to serialize custom data types, you can teach `QDataStream` to do
    that by implementing proper redirection operators.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要序列化自定义数据类型，你可以通过实现适当的重定向运算符来教会`QDataStream`如何做到这一点。
- en: Time for action – Serialization of a custom structure
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 自定义结构的序列化
- en: 'Let''s perform another small exercise by implementing functions that are required
    to use `QDataStream` to serialize the same simple structure that contains the
    player information that we used for text streaming:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现使用`QDataStream`序列化包含我们用于文本流中的玩家信息的简单结构的函数来进行另一个小练习：
- en: '[PRE55]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For this, two functions need to be implemented, both returning a `QDataStream`
    reference that was taken earlier as an argument to the call. Apart from the stream
    itself, the serialization operator accepts a constant reference to the class that
    is being saved. The most simple implementation just streams each member into the
    stream and returns the stream afterward:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，需要实现两个函数，这两个函数都返回一个`QDataStream`引用，该引用是作为调用参数传递的。除了流本身之外，序列化运算符接受一个对正在保存的类的常量引用。最简单的实现是将每个成员流式传输到流中，然后返回流：
- en: '[PRE56]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Complementary to this, deserializing is done by implementing a redirection
    operator that accepts a mutable reference to the structure that is filled by data
    that is read from the stream:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，反序列化是通过实现一个接受从流中读取的数据填充的结构可变引用的重新定向运算符来完成的：
- en: '[PRE57]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Again, at the end, the stream itself is returned.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，最后，流本身被返回。
- en: 'Now we can use `QDataStream` to write our object to any I/O device (for example,
    a file, a buffer, or a network socket):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`QDataStream`将我们的对象写入任何I/O设备（例如，文件、缓冲区或网络套接字）：
- en: '[PRE58]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Reading the object back is just as simple:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 读取对象同样简单：
- en: '[PRE59]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: What just happened?
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We provided two standalone functions that define redirection operators for the
    `Player` class to and from a `QDataStream` instance. This lets your class be serialized
    and deserialized using mechanisms offered and used by Qt.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了两个独立的函数，用于为`Player`类定义到`QDataStream`实例的重新定向运算符。这使得你的类可以使用Qt提供和使用的机制进行序列化和反序列化。
- en: XML streams
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML流
- en: 'XML has become one of the most popular standards that is used to store hierarchical
    data. Despite its verbosity and difficulty to read by human eye, it is used in
    virtually any domain where data persistency is required, as it is very easy to
    read by machines. Qt provides support for reading and writing XML documents in
    two modules:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: XML已经成为用于存储层次化数据的最受欢迎的标准之一。尽管它冗长且难以用肉眼阅读，但它几乎在需要数据持久化的任何领域都被使用，因为它非常容易由机器读取。Qt提供了两个模块来支持读取和写入XML文档：
- en: The Qt Xml module provides access using the **Document Object Model** (**DOM**)
    standard with classes such as `QDomDocument`, `QDomElement`, and others
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Xml模块通过`QDomDocument`、`QDomElement`等类提供使用**文档对象模型**（**DOM**）标准的访问。
- en: The Qt Core module contains `QXmlStreamReader` and `QXmlStreamWriter` classes
    that implement streaming API
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Core模块包含`QXmlStreamReader`和`QXmlStreamWriter`类，它们实现了流式API。
- en: One of the downsides of `QDomDocument` is that it requires us to load the whole
    XML tree into the memory before parsing it. Additionally, Qt Xml is not actively
    maintained. Therefore, we will focus on the streaming approach provided by Qt
    Core.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDomDocument`的一个缺点是它要求我们在解析之前将整个XML树加载到内存中。此外，Qt Xml没有积极维护。因此，我们将专注于Qt Core提供的流式方法。'
- en: In some situations, downsides of the DOM approach are compensated for by its
    ease of use as compared to a streamed approach, so you can consider using it if
    you feel that you have found the right task for it. If you want to use the DOM
    access to XML in Qt, remember to enable the `QtXml` module in your applications
    by adding a `QT += xml` line in the project configuration file.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，与流式方法相比，DOM方法的缺点可以通过其易用性得到补偿，所以如果你觉得你已经找到了适合它的任务，你可以考虑使用它。如果你想在Qt中使用DOM访问XML，记得在项目配置文件中添加`QT
    += xml`行以启用`QtXml`模块。
- en: Time for action – Implementing an XML parser for player data
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候采取行动 - 实现玩家数据的XML解析器
- en: 'In this exercise, we will create a parser to fill data that represents players
    and their inventory in an RPG game. First, let''s create the types that will hold
    the data:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个解析器来填充表示RPG游戏中玩家及其库存的数据。首先，让我们创建将保存数据的类型：
- en: '[PRE60]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: What just happened?
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We want to use the `Q_ENUM` macro on our enum, because it will allow us to easily
    convert enum values to strings and back, which is very useful for serialization.
    Since `InventoryItem` is not a `QObject`, we need to add a `Q_GADGET` macro to
    the beginning of the class declaration to make the `Q_ENUM` macro work. Think
    of `Q_GADGET` as of a lightweight variation of `Q_OBJECT` that enables some of
    its features but not others.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在我们的枚举上使用`Q_ENUM`宏，因为它将使我们能够轻松地将枚举值转换为字符串并反向转换，这对于序列化非常有用。由于`InventoryItem`不是`QObject`，我们需要在类声明开头添加`Q_GADGET`宏，以便`Q_ENUM`宏能够工作。将`Q_GADGET`视为`Q_OBJECT`的一个轻量级变体，它启用了一些功能但不是全部。
- en: 'The `typeByName()` method will receive a string and return the corresponding
    enum variant. We can implement this method as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeByName()`方法将接收一个字符串并返回相应的枚举变体。我们可以按以下方式实现此方法：'
- en: '[PRE61]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The implementation may look complicated, but it's much less error-prone than
    manually writing a bunch of `if` statements to choose the correct return value
    manually. First, we use the `QMetaEnum::fromType<T>()` template method to get
    the `QMetaEnum` object corresponding to our `enum`. The `keyToValue()` method
    of this object performs the conversion that we need, but it needs to be accompanied
    with a few conversions.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可能看起来很复杂，但它比手动编写一大堆 `if` 语句来手动选择正确的返回值要少出错。首先，我们使用 `QMetaEnum::fromType<T>()`
    模板方法来获取与我们的 `enum` 对应的 `QMetaEnum` 对象。此对象的 `keyToValue()` 方法执行我们需要的转换，但它需要伴随一些转换。
- en: You can note that we are using a class called `QStringRef`. It represents a
    string reference—a substring in an existing string—and is implemented in a way
    that avoids expensive string construction; therefore, it is very fast. The similar
    `std::string_view` type was added to the standard library in C++17\. We use it
    as the argument type because `QXmlStreamReader` will provide strings in this format.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注意到我们正在使用一个名为 `QStringRef` 的类。它代表一个字符串引用——现有字符串中的子串——并且以避免昂贵的字符串构造的方式实现；因此，它非常快。类似的
    `std::string_view` 类型是在 C++17 中添加到标准库中的。我们将其用作参数类型，因为 `QXmlStreamReader` 将以这种格式提供字符串。
- en: However, the `keyToValue()` method expects a `const char *` argument, so we
    use the `toLatin1()` method to convert our string to `QByteArray`, and then use
    `constData()` to get the `const char *` pointer to its buffer. Finally, we use
    `static_cast` to convert the result from `int` to our `enum` type.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`keyToValue()` 方法期望一个 `const char *` 参数，所以我们使用 `toLatin1()` 方法将我们的字符串转换为
    `QByteArray`，然后使用 `constData()` 获取其缓冲区的 `const char *` 指针。最后，我们使用 `static_cast`
    将结果从 `int` 转换为我们的 `enum` 类型。
- en: 'Save the following XML document somewhere. We will use it to test whether the
    parser can read it:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下 XML 文档保存在某个地方。我们将使用它来测试解析器是否可以读取它：
- en: '[PRE62]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s create a class called `PlayerInfoReader` that will wrap `QXmlStreamReader`
    and expose a parser interface for the `PlayerInfo` instances:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `PlayerInfoReader` 的类，该类将封装 `QXmlStreamReader` 并为 `PlayerInfo` 实例提供解析器接口：
- en: '[PRE63]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The class constructor accepts a `QIODevice` pointer that the reader will use
    to retrieve data as it needs it. The constructor is trivial, as it simply passes
    the device to the `reader` object:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数接受一个 `QIODevice` 指针，该指针将用于读取所需的数据。构造函数很简单，因为它只是将设备传递给 `reader` 对象：
- en: '[PRE64]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Before we go into parsing, let''s prepare some code to help us with the process.
    First, let''s add an enumeration type to the class that will list all the possible
    tokens—tag names that we want to handle in the parser:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始解析之前，让我们准备一些代码来帮助我们处理这个过程。首先，让我们向类中添加一个枚举类型，该类型将列出所有可能的令牌——我们希望在解析器中处理的标签名称：
- en: '[PRE65]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Then, just like we did in the `InventoryItem` class, we use the `Q_GADGET` and
    `Q_ENUM` macros and implement the `PlayerInfoReader::tokenByName()` convenience
    method.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像我们在 `InventoryItem` 类中所做的那样，我们使用 `Q_GADGET` 和 `Q_ENUM` 宏，并实现 `PlayerInfoReader::tokenByName()`
    便利方法。
- en: 'Now, let''s implement the entry point of the parsing process:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现解析过程的入口点：
- en: '[PRE66]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: First, we call `readNextStartElement()` on the reader to make it find the starting
    tag of the first element, and if it is found, we check whether the root tag of
    the document is what we expect it to be. If not, we return a default-constructed
    `PlayerInfo`, indicating that no data is available.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在读取器上调用 `readNextStartElement()`，使其找到第一个元素的起始标签，如果找到了，我们检查文档的根标签是否是我们期望的。如果不是，我们返回一个默认构造的
    `PlayerInfo`，表示没有可用的数据。
- en: Next, we create a `PlayerInfo` variable. We iterate all the starting sub-elements
    in the current tag (`PlayerInfo`). For each of them, we check whether it is a
    `Player` tag and call `readPlayer()` to descend into the level of parsing data
    for a single player. Otherwise, we call `skipCurrentElement()`, which fast-forwards
    the stream until a matching ending element is encountered.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个 `PlayerInfo` 变量。我们遍历当前标签（`PlayerInfo`）中的所有起始子元素。对于每个子元素，我们检查它是否是
    `Player` 标签，并调用 `readPlayer()` 下降到解析单个玩家数据的级别。否则，我们调用 `skipCurrentElement()`，这将快速前进流，直到遇到匹配的结束元素。
- en: The other methods in this class will usually follow the same pattern. Each parsing
    method iterates all the starting elements, handling those it knows and ignoring
    all others. Such an approach lets us maintain forward compatibility, since all
    tags introduced in the newer versions of the document are silently skipped by
    an older parser.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中的其他方法通常遵循相同的模式。每个解析方法迭代所有起始元素，处理它所知道的元素，并忽略所有其他元素。这种做法使我们能够保持向前兼容性，因为较新版本的文档中引入的所有标签都会被较旧的解析器静默跳过。
- en: 'The structure of `readPlayer()` is similar; however, it is more complicated,
    as we also want to read data from the attributes of the `Player` tag itself. Let''s
    take a look at the function piece by piece. First, we get the list of attributes
    associated with the opening tag and ask for values of the two attributes that
    we are interested in:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`readPlayer()`的结构与之前相似；然而，它更复杂，因为我们还想要从`Player`标签本身的属性中读取数据。让我们逐部分查看这个函数。首先，我们获取与打开标签关联的属性列表，并请求我们感兴趣的两种属性的值：'
- en: '[PRE67]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'After this, we loop all child tags and fill the `Player` structure based on
    the tag names. By converting tag names to tokens, we can use a `switch` statement
    to neatly structure the code in order to extract information from different tag
    types, as in the following code:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们循环所有子标签，并根据标签名称填充`Player`结构。通过将标签名称转换为标记，我们可以使用`switch`语句来整洁地组织代码，以便从不同的标签类型中提取信息，如下面的代码所示：
- en: '[PRE68]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If we are interested in the textual content of the tag, we can use `readElementText()`
    to extract it. This method reads until it encounters the closing tag and returns
    the text contained within it. For the `Inventory` tag, we call the dedicated `readInventory()`
    method.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对标签的文本内容感兴趣，我们可以使用`readElementText()`来提取它。此方法读取直到遇到关闭标签，并返回其内的文本。对于`Inventory`标签，我们调用专门的`readInventory()`方法。
- en: 'For the `Location` tag, the code is more complex than earlier as we again descend
    into reading child tags, extracting the required information and skipping all
    unknown tags:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Location`标签，代码比之前更复杂，因为我们再次进入读取子标签，提取所需信息并跳过所有未知标签：
- en: '[PRE69]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Next, we again skip the tags that didn't match any known tokens. At the end
    of `readPlayer()`, we simply return the populated `Player` value.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次跳过与任何已知标记不匹配的标签。在`readPlayer()`的末尾，我们简单地返回填充好的`Player`值。
- en: 'The last method is similar in structure to the previous one—iterate all the
    tags, skip everything that we don''t want to handle (everything that is not an
    inventory item), fill the inventory item data structure, and append the item to
    the list of already parsed items, as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法在结构上与之前的方法类似——迭代所有标签，跳过我们不想处理的任何内容（即不是库存项目的所有内容），填充库存项目数据结构，并将项目追加到已解析项目列表中，如下所示：
- en: '[PRE70]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In `main()` of your project, write some code that will check whether the parser
    works correctly. You can use the `qDebug()` statements to output the sizes of
    lists and contents of variables. Take a look at the following code for an example:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目的`main()`函数中，编写一些代码来检查解析器是否工作正常。你可以使用`qDebug()`语句来输出列表的大小和变量的内容。以下代码是一个示例：
- en: '[PRE71]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: What just happened?
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The code you just wrote implements a full top-down parser of the XML data. First,
    the data goes through a tokenizer, which returns identifiers that are much easier
    to handle than strings. Then, each method can easily check whether the token it
    receives is an acceptable input for the current parsing stage. Based on the child
    token, the next parsing function is determined and the parser descends to a lower
    level until there is nowhere to descend to. Then, the flow goes back up one level
    and processes the next child. If, at any point, an unknown tag is found, it gets
    ignored. This approach supports a situation when a new version of software introduces
    new tags to the file format specification, but an old version of software can
    still read the file by skipping all the tags that it doesn't understand.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才编写的代码实现了XML数据的完整自顶向下解析器。首先，数据通过一个标记化器，它返回比字符串更容易处理的标识符。然后，每个方法都可以轻松检查它接收到的标记是否是当前解析阶段的可接受输入。根据子标记，确定下一个解析函数，并解析器下降到较低级别，直到没有下降的地方。然后，流程向上回退一级并处理下一个子元素。如果在任何时刻发现未知标签，它将被忽略。这种方法支持一种情况，即新版本的软件引入了新的标签到文件格式规范中，但旧版本的软件仍然可以通过跳过它不理解的标签来读取文件。
- en: Have a go hero – An XML serializer for player data
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一下英雄——玩家数据的XML序列化器
- en: Now that you know how to parse XML data, you can create the complementary part—a
    module that will serialize `PlayerInfo` structures into XML documents using `QXmlStreamWriter`.
    Use methods such as `writeStartDocument()`, `writeStartElement()`, `writeCharacters()`,
    and `writeEndElement()` for this. Verify that the documents saved with your code
    can be parsed with what we implemented together.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何解析XML数据，你可以创建互补的部分——一个模块，它将使用`QXmlStreamWriter`将`PlayerInfo`结构序列化到XML文档中。为此，你可以使用`writeStartDocument()`、`writeStartElement()`、`writeCharacters()`和`writeEndElement()`等方法。验证使用你的代码保存的文档是否可以使用我们共同实现的代码进行解析。
- en: QVariant
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QVariant
- en: '`QVariant` is a class that can hold values of multiple types:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`QVariant`是一个可以持有多种类型值的类：'
- en: '[PRE72]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: When you assign a value to a `QVariant` object, that value is stored inside
    along with the type information. You can use its `type()` method to find out which
    type of value it holds. The default constructor of `QVariant` creates an invalid
    value that you can detect using the `isValid()` method.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个值赋给一个`QVariant`对象时，该值及其类型信息将存储在其中。你可以使用它的`type()`方法来找出它持有哪种类型的值。`QVariant`的默认构造函数创建了一个无效值，你可以使用`isValid()`方法来检测它。
- en: '`QVariant` supports a great amount of types, including Qt value types such
    as `QDateTime`, `QColor`, and `QPoint`. You can also register your own types to
    store them in `QVariant`. One of the most powerful features of `QVariant` is the
    ability to store a collection or a hierarchy of values. You can use the `QVariantList` type
    (which is a `typedef` for `QList<QVariant>`) to create a list of `QVariant` objects,
    and you can actually put the whole list into a single `QVariant` object! You''ll
    be able to retrieve the list and examine individual values:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`QVariant`支持大量类型，包括Qt值类型，如`QDateTime`、`QColor`和`QPoint`。你还可以注册自己的类型以将它们存储在`QVariant`中。`QVariant`最强大的功能之一是能够存储值集合或值的层次结构。你可以使用`QVariantList`类型（它是`QList<QVariant>`的`typedef`）来创建一个`QVariant`对象的列表，并且你实际上可以将整个列表放入一个单一的`QVariant`对象中！你将能够检索列表并检查单个值：'
- en: '[PRE73]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Similarly, you can use `QVariantMap` or `QVariantHash` to create a key-value
    collection with `QString` keys and `QVariant` values. Needless to say, you can
    store such a collection in a single `QVariant` as well. This allows you to construct
    a hierarchy with unlimited depth and arbitrary structure.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以使用`QVariantMap`或`QVariantHash`来创建一个具有`QString`键和`QVariant`值的键值集合。不用说，你还可以将这样的集合存储在一个单一的`QVariant`中。这允许你构建深度无限且结构任意的层次结构。
- en: 'As you can see, `QVariant` is a pretty powerful class, but how can we use it
    for serializing? For a start, `QVariant` is supported by `QDataStream`, so you
    can use the binary serialization described earlier to serialize and restore any `QVariant` value
    you can construct. For example, instead of putting each field of your structure
    into `QDataStream`, you can put them into a `QVariantMap` and then put it into
    the stream:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`QVariant`是一个相当强大的类，但我们如何用它进行序列化呢？首先，`QVariant`由`QDataStream`支持，因此你可以使用之前描述的二进制序列化来序列化和恢复你构造的任何`QVariant`值。例如，你不必将你的结构体中的每个字段放入`QDataStream`，你可以将它们放入一个`QVariantMap`，然后将其放入流中：
- en: '[PRE74]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Loading the data is also straightforward:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 加载数据也是直截了当的：
- en: '[PRE75]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This approach allows you to store arbitrary data in an arbitrary location. However,
    you can also use `QVariant` along with `QSettings` to conveniently store the data
    in an appropriate location.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许你在任意位置存储任意数据。然而，你也可以使用`QVariant`和`QSettings`一起方便地将数据存储在适当的位置。
- en: QSettings
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QSettings
- en: 'While not strictly a serialization issue, the aspect of storing application
    settings is closely related to the described subject. A Qt solution for this is
    the `QSettings` class. By default, it uses different backends on different platforms,
    such as system registry on Windows or INI files on Linux. The basic use of `QSettings` is
    very easy—you just need to create the object and use `setValue()` and `value()` to
    store and load data from it:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是严格意义上的序列化问题，但存储应用程序设置的方面与描述的主题密切相关。Qt为此提供了一个解决方案，即`QSettings`类。默认情况下，它在不同的平台上使用不同的后端，例如在Windows上使用系统注册表或在Linux上使用INI文件。`QSettings`的基本使用非常简单——你只需要创建对象并使用`setValue()`和`value()`来存储和加载数据：
- en: '[PRE76]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The only thing you need to remember is that it operates on `QVariant`, so the
    return value needs to be converted to the proper type if needed, like `toInt()` in
    the preceding code. A call to `value()` can take an additional argument that contains
    the value to be returned if the requested key is not present in the map. This
    allows you to handle default values, for example, in a situation when the application
    is first started and the settings are not saved yet:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住的唯一一件事是它操作的是`QVariant`，所以如果需要，返回值需要转换为适当的类型，就像前面代码中的`toInt()`一样。如果请求的键不在映射中，`value()`调用可以接受一个额外的参数，该参数包含要返回的值。这允许你在应用程序首次启动且设置尚未保存的情况下处理默认值，例如：
- en: '[PRE77]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: If you don't specify the default value, an invalid `QVariant` will be returned
    when nothing is stored, and you can check for that using the `isValid()` method.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定默认值，当没有存储任何内容时，将返回一个无效的`QVariant`，你可以使用`isValid()`方法来检查这一点。
- en: 'In order for the default settings location to be correct, you need to set the
    organization name and the application name. They determine where exactly `QSettings` store
    data by default and ensure that the stored data will not conflict with another
    application. This is typically done at the beginning of your `main()` function:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保默认设置位置正确，你需要设置组织名称和应用程序名称。它们决定了`QSettings`默认存储数据的确切位置，并确保存储的数据不会与其他应用程序冲突。这通常在`main()`函数的开始处完成：
- en: '[PRE78]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Settings hierarchy
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置层次结构
- en: 'The simplest scenario assumes that settings are "flat", in that all keys are
    defined on the same level. However, this does not have to be the case—correlated
    settings can be put into named groups. To operate on a group, you can use the `beginGroup()` 
     and  `endGroup()` calls:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况假设设置是“扁平”的，即所有键都在同一级别上定义。然而，这不必是这种情况——相关的设置可以放入命名的组中。要操作一个组，你可以使用`beginGroup()`和`endGroup()`调用：
- en: '[PRE79]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'When using this syntax, you have to remember to end the group after you are
    done with it. An alternative way to do the same thing is to pass the group name
    directly to invocation of `value()`, using `/` to separate it from the value name:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这种语法时，你必须记住在完成操作后结束组。做同样事情的一种替代方法是直接将组名传递给`value()`的调用，使用`/`来分隔它和值名：
- en: '[PRE80]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You can create multiple nested groups by calling `beginGroup()` multiple times
    (or, equivalently, writing multiple slashes in the value name).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多次调用`beginGroup()`（或者，等价地，在值名中写入多个斜杠）来创建多个嵌套组。
- en: 'There is another way to introduce a non-flat structure to `QSettings`. It can
    handle composite `QVariant` values—`QVariantMap` and `QVariantList`. You can simply
    convert your data to a `QVariant`, much like we converted it to a `QJsonValue` earlier:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 向`QSettings`引入非扁平结构还有另一种方法。它可以处理复合`QVariant`值——`QVariantMap`和`QVariantList`。你可以简单地将你的数据转换为`QVariant`，就像我们之前将其转换为`QJsonValue`一样：
- en: '[PRE81]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This `QVariant` value can be passed to `QSettings::setValue()`. Of course, you
    will need to implement the inverse operation as well. More than that, nothing
    stops you from converting your data to JSON and saving it to `QSettings` as a `QByteArray`.
    However, these approaches may be slower than proper serialization, and the resulting
    settings file will be hard to edit manually.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`QVariant`值可以传递给`QSettings::setValue()`。当然，你还需要实现逆操作。更重要的是，没有任何阻止你将数据转换为JSON并将其作为`QByteArray`保存到`QSettings`中。然而，这些方法可能比适当的序列化要慢，并且生成的设置文件难以手动编辑。
- en: 'Various Qt classes have methods that are meant to be used with `QSettings` to
    easily save a set of properties. For example, `QWidget::saveGeometry()`  and 
    `QWidget::restoreGeometry()` helpers allow you to save the window''s position
    and size to `QSettings`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 各种Qt类都有旨在与`QSettings`一起使用的方法，以便轻松保存一组属性。例如，`QWidget::saveGeometry()`和`QWidget::restoreGeometry()`辅助函数允许你将窗口的位置和大小保存到`QSettings`：
- en: '[PRE82]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Similarly, multiple widget classes have `saveState()` and `restoreState()` methods
    to save information about the widget''s state:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，多个小部件类有`saveState()`和`restoreState()`方法来保存小部件状态的信息：
- en: '`QMainWindow` can save positions of toolbars and dock widgets'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QMainWindow`可以保存工具栏和停靠小部件的位置'
- en: '`QSplitter` can save positions of its handles'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSplitter`可以保存其手柄的位置'
- en: '`QHeaderView` can save sizes of the table''s rows or columns'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QHeaderView`可以保存表格的行或列的大小'
- en: '`QFileDialog` can save the dialog''s layout, history, and current directory'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QFileDialog`可以保存对话框的布局、历史记录和当前目录'
- en: These methods are a great way to preserve all changes the user has made in your
    application's interface.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法是保留用户在应用程序界面中做出的所有更改的绝佳方式。
- en: Customizing the settings location and format
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义设置位置和格式
- en: 'The constructor of the `QSettings` class has a number of overloads that allow
    you to change the location where the data will be stored by a particular `QSettings` object,
    instead of using the default location. First, you can override the organization
    name and the application name:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSettings` 类的构造函数有多个重载，允许您通过特定的 `QSettings` 对象更改数据存储的位置，而不是使用默认位置。首先，您可以覆盖组织名称和应用程序名称：'
- en: '[PRE83]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next, you can use the system-wide storage location by passing  `QSettings::SystemScope `
    as the `scope` argument:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以通过传递 `QSettings::SystemScope` 作为 `scope` 参数来使用系统范围的存储位置：
- en: '[PRE84]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In this case, `QSettings` will try to read the settings for all users and then
    fall back to the user-specific location. Note that a system-wide location may
    not be writable, so using `setValue()` on it won't have the desired effect.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，`QSettings` 将尝试读取所有用户的设置，然后回退到用户特定的位置。请注意，系统范围的存储位置可能不可写，因此在该位置上使用 `setValue()`
    不会产生预期效果。
- en: 'You can also opt out of the preferred format detection using the  `QSettings::setDefaultFormat()` function.
    For example, use the following code on Windows to disable using the registry:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `QSettings::setDefaultFormat()` 函数禁用首选格式检测。例如，在Windows上，使用以下代码禁用使用注册表：
- en: '[PRE85]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Finally, there is one more option available for total control of where the
    settings data resides—tell the constructor directly where the data should be located:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个选项可以完全控制设置数据的位置——直接告诉构造函数数据应该位于何处：
- en: '[PRE86]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: If you pass `QSettings::NativeFormat` to this constructor, the meaning of the
    path will depend on the platform. For example, it will be interpreted as a registry
    path on Windows.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将 `QSettings::NativeFormat` 传递给此构造函数，路径的含义将取决于平台。例如，在Windows上，它将被解释为注册表路径。
- en: Since you can use `QSettings` to read and write to an arbitrary INI file, it's
    a convenient and easy way to implement serialization of an object to the INI format,
    which is suitable in simple cases.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您可以使用 `QSettings` 读取和写入任意INI文件，因此它是实现对象序列化为INI格式的方便且简单的方法，这在简单情况下是合适的。
- en: '`QSettings` also allows you to register your own formats so that you can control
    the way your settings are stored, for example, by storing them using XML or by
    adding on-the-fly encryption. This is done using `QSettings::registerFormat()`,
    where you need to pass the file extension and two pointers to functions that perform
    reading and writing of the settings, respectively, as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSettings` 还允许您注册自己的格式，以便您可以控制设置存储的方式，例如，通过使用XML存储或添加即时加密。这是通过使用 `QSettings::registerFormat()`
    实现的，您需要传递文件扩展名和两个函数指针，分别用于读取和写入设置，如下所示：'
- en: '[PRE87]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: JSON files
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON文件
- en: '**JSON** stands for "JavaScript Object Notation", which is a popular lightweight
    textual format that is used to store object-oriented data in a human-readable
    form. It comes from JavaScript where it is the native format used to store object
    information; however, it is commonly used across many programming languages and
    a popular format for web data exchange. Qt Core supports JSON format, as we''ll
    see in the following code. A simple JSON-formatted definition looks as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON** 代表“JavaScript对象表示法”，这是一种流行的轻量级文本格式，用于以可读的形式存储面向对象的数据。它起源于JavaScript，在那里它是存储对象信息的原生格式；然而，它被广泛应用于许多编程语言，并且是网络数据交换的流行格式。Qt
    Core支持JSON格式，如下面的代码所示。一个简单的JSON格式定义如下：'
- en: '[PRE88]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'JSON objects can contain values of the following types:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: JSON对象可以包含以下类型的值：
- en: '| **Type** | **Description** |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **描述** |'
- en: '| bool | A boolean value (`true` or `false`). |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| bool | 布尔值（`true` 或 `false`）。|'
- en: '| double | A number value (for example, `42.1`). |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| double | 一个数值（例如，`42.1`）。|'
- en: '| string | A quoted string (for example, `"Qt"`). |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| string | 引号中的字符串（例如，`"Qt"`）。|'
- en: '| array | A collection of values of any type enclosed in square brackets (for
    example, `[42.1, "Qt"]`). |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| array | 用方括号括起来的任何类型的值集合（例如，`[42.1, "Qt"]`）。|'
- en: '| object | A set of key-value pairs enclosed in braces. Keys are strings, and
    values can be of any type (for example, `{ "key1": 42.1, "key2": [42.1, "Qt"]
    }`). |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| object | 用大括号括起来的键值对集合。键是字符串，值可以是任何类型（例如，`{ "key1": 42.1, "key2": [42.1,
    "Qt"] }`）。|'
- en: '| null | A special value (`null`) indicating lack of data. |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| null | 表示数据缺失的特殊值（`null`）。|'
- en: 'A proper **JSON document** must have either an array or an object at the top
    level. In the preceding example, we had an object containing three properties:
    name, age, and inventory. The first two properties are simple values, and the
    last property is an array that contains two objects with two properties each.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合适的 **JSON 文档** 必须在顶层有一个数组或对象。在前面的例子中，我们有一个包含三个属性的对象：name、age 和 inventory。前两个属性是简单值，最后一个属性是一个包含两个对象且每个对象有两个属性的数组。
- en: Qt can create and read JSON descriptions using the `QJsonDocument` class. A
    document can be created from the UTF-8-encoded text using the `QJsonDocument::fromJson()`
    static method, and can later be stored in a textual form again using `toJson()`.
    Once a JSON document is created, you can check whether it represents an object
    or an array using one of the `isArray()` and `isObject()` calls. Then, the document
    can be transformed into `QJsonArray` or `QJsonObject` using the `array()` or `object()`
    methods.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 可以使用 `QJsonDocument` 类创建和读取 JSON 描述。可以使用 `QJsonDocument::fromJson()` 静态方法从
    UTF-8 编码的文本创建文档，并且可以使用 `toJson()` 方法再次将其存储为文本形式。一旦创建了一个 JSON 文档，就可以使用 `isArray()`
    和 `isObject()` 调用之一来检查它是否表示一个对象或数组。然后，可以使用 `array()` 或 `object()` 方法将文档转换为 `QJsonArray`
    或 `QJsonObject`。
- en: Since the structure of JSON closely resembles that of `QVariant` (which can
    also hold key-value pairs using `QVariantMap` and arrays using `QVariantList`),
    conversion methods `QJsonDocument::fromVariant()` and `QJsonDocument::toVariant()`
    also exist.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JSON 的结构紧密地类似于 `QVariant`（它也可以使用 `QVariantMap` 来存储键值对，使用 `QVariantList` 来存储数组），因此也存在转换方法
    `QJsonDocument::fromVariant()` 和 `QJsonDocument::toVariant()`。
- en: '`QJsonObject` is an iterable type that can be queried for a list of keys (using
    `keys()`) or asked for a value of a specific key (with a `value()` method or `operator[]`).
    Values are represented using the `QJsonValue` class, which can store any of the
    value types listed earlier. New properties can be added to the object using the
    `insert()` method that takes a key as a string, and a value can be added as `QJsonValue`.
    The existing properties can be removed using `remove()`.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`QJsonObject` 是一种可迭代的类型，可以查询其键列表（使用 `keys()` 方法）或请求特定键的值（使用 `value()` 方法或 `operator[]`）。值使用
    `QJsonValue` 类表示，它可以存储前面列出的任何值类型。可以使用 `insert()` 方法向对象添加新属性，该方法接受一个字符串键和一个作为 `QJsonValue`
    的值。可以使用 `remove()` 方法删除现有属性。'
- en: '`QJsonArray` is also an iterable type that contains a classic list API; it
    contains methods such as `append()`, `insert()`, `removeAt()`, `at()`, and `size()`
    to manipulate entries in the array, again working on `QJsonValue` as the item
    type.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`QJsonArray` 也是一种可迭代的类型，它包含一个经典列表 API；它包含 `append()`、`insert()`、`removeAt()`、`at()`
    和 `size()` 等方法来操作数组中的条目，再次以 `QJsonValue` 作为项目类型。'
- en: Time for action – The player data JSON serializer
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 玩家数据 JSON 序列化器
- en: Our next exercise is to create a serializer of the same `PlayerInfo` structure
    as we used for the XML exercise, but this time the destination data format will
    be JSON.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的练习是创建一个序列化器，其结构与我们在 XML 练习中使用的 `PlayerInfo` 结构相同，但这次的目标数据格式将是 JSON。
- en: 'Start by creating a `PlayerInfoJson` class and give it an interface similar
    to the one shown in the following code:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个 `PlayerInfoJson` 类，并给它一个类似于以下代码的接口：
- en: '[PRE89]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'All that is really required is to implement the `playerInfoToJson` method.
    Generally, we need to convert our `PlayerInfo` data to a `QJsonArray` and then
    use `QJsonDocument` to encode it as JSON:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上所需做的就是实现 `playerInfoToJson` 方法。通常，我们需要将我们的 `PlayerInfo` 数据转换为 `QJsonArray`，然后使用
    `QJsonDocument` 将其编码为 JSON：
- en: '[PRE90]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, let''s start implementing the `toJson()` method:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始实现 `toJson()` 方法：
- en: '[PRE91]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Since the structure is really a list of players, we can iterate over it, convert
    each player to a `QJsonValue`, and append the result to `QJsonArray`. Having this
    function ready, we can descend a level and implement an overload for `toJson()`
    that takes a `Player` object:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 由于结构实际上是一个玩家列表，我们可以遍历它，将每个玩家转换为 `QJsonValue`，并将结果追加到 `QJsonArray` 中。有了这个函数，我们就可以向下级实现
    `toJson()` 的重载，它接受一个 `Player` 对象：
- en: '[PRE92]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This time, we are using `QJsonObject` as our base type, since we want to associate
    values with keys. For each key, we use the index operator to add entries to the
    object. The position key holds a `QPoint` value, which is not a valid JSON value,
    so we convert the point to a `QJsonObject` with two keys (`x` and `y`) using the
    C++11 initializer list. The situation is different with the inventory—again, we
    have to write an overload for `toJson` that will perform the conversion:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用 `QJsonObject` 作为我们的基本类型，因为我们想将值与键关联起来。对于每个键，我们使用索引操作符向对象添加条目。位置键包含一个
    `QPoint` 值，这不是一个有效的 JSON 值，因此我们使用 C++11 初始化列表将点转换为包含两个键（`x` 和 `y`）的 `QJsonObject`。情况与存货不同——我们再次需要为
    `toJson` 编写一个重载，以便执行转换：
- en: '[PRE93]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The code is almost identical to the one handling `PlayerInfo` objects, so let''s
    focus on the last overload of `toVariant`—the one that accepts `Item` instances:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 代码几乎与处理 `PlayerInfo` 对象的代码相同，所以让我们关注 `toVariant` 的最后一个重载——接受 `Item` 实例的那个：
- en: '[PRE94]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'There is not much to comment here—we add all keys to the object, converting
    the item type to a string. For this, we have to add the static `InventoryItem::typeToName()`
    method that is the reverse of `typeByName()`, that is, it takes a enum variant
    and outputs its name as a string:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多可评论的——我们向对象添加所有键，将项目类型转换为字符串。为此，我们必须添加一个静态的 `InventoryItem::typeToName()`
    方法，它是 `typeByName()` 的反向操作，即它接受枚举变体并输出其名称作为字符串：
- en: '[PRE95]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This is pretty much a wrapper over the `QMetaEnum::valueToKey()` method that
    does all the magic that wouldn't be possible without Qt.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是 `QMetaEnum::valueToKey()` 方法的包装，它执行所有不可能在没有 Qt 的情况下完成的魔法。
- en: The serializer is complete! Now you can use `PlayerInfoJson::playerInfoToJson()`
    to convert `PlayerInfo` into a `QByteArray` containing the JSON. It's suitable
    for writing it to a file or sending it over the network. However, to make it more
    useful, we need to implement the reverse operation (deserialization).
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化器已经完成！现在你可以使用 `PlayerInfoJson::playerInfoToJson()` 将 `PlayerInfo` 转换为包含 JSON
    的 `QByteArray`。它适合写入文件或通过网络发送。然而，为了使其更有用，我们需要实现反向操作（反序列化）。
- en: Time for action – Implementing a JSON parser
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 实现一个 JSON 解析器
- en: 'Let''s extend the `PlayerInfoJSON` class and equip it with a `playerInfoFromJson()`
    method:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展 `PlayerInfoJSON` 类，并为其添加一个 `playerInfoFromJson()` 方法：
- en: '[PRE96]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'First, we read the document and check whether it is valid and holds the expected
    array. Upon failure, an empty structure is returned; otherwise, we iterate over
    the received array and convert each of its elements to an object. Similar to the
    serialization example, we create a helper function for each complex item of our
    data structure. Thus, we write a new `playerFromJson()` method that converts `QJsonObject`
    to a `Player`, that is, performs a reverse operation as compared to `toJson(Player)`:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们读取文档并检查它是否有效以及是否包含预期的数组。如果失败，则返回一个空结构；否则，我们遍历接收到的数组并将每个元素转换为对象。类似于序列化示例，我们为我们的数据结构中的每个复杂项创建一个辅助函数。因此，我们编写一个新的
    `playerFromJson()` 方法，将 `QJsonObject` 转换为 `Player`，即与 `toJson(Player)` 相比执行反向操作：
- en: '[PRE97]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'In this function, we used `operator[]` to extract data from `QJsonObject`,
    and then we used different functions to convert the data to the desired type.
    Note that in order to convert to `QPoint`, we first converted it to `QJsonObject`
    and then extracted the values before using them to build `QPoint`. In each case,
    if the conversion fails, we get a default value for that type (for example, an
    empty string or a zero number). To read the inventory, we employ another custom
    method:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用了 `operator[]` 从 `QJsonObject` 中提取数据，然后使用不同的函数将数据转换为所需的类型。请注意，为了转换为
    `QPoint`，我们首先将其转换为 `QJsonObject`，然后提取值，在它们用于构建 `QPoint` 之前使用。在每种情况下，如果转换失败，我们将为该类型获取一个默认值（例如，一个空字符串或一个零数字）。为了读取存货，我们采用另一个自定义方法：
- en: '[PRE98]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'What remains is to implement `inventoryItemFromJson()`:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是实现 `inventoryItemFromJson()`：
- en: '[PRE99]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Unfortunately, our `typeByName()` function requires `QStringRef`, not `QString`.
    We can fix this by adding a couple of overloads and forwarding them to a single
    implementation:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的 `typeByName()` 函数需要 `QStringRef`，而不是 `QString`。我们可以通过添加几个重载并将它们转发到单个实现来修复这个问题：
- en: '[PRE100]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: What just happened?
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The class that was implemented can be used for bidirectional conversion between
    `Item` instances and a `QByteArray` object, which contains the object data in
    the JSON format. We didn't do any error checking here; instead, we relied on Qt's
    rule that an error results in a sensible default value.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的类可用于在`Item`实例和包含JSON格式对象数据的`QByteArray`对象之间进行双向转换。在这里我们没有进行任何错误检查；相反，我们依赖于Qt的规则，即错误会导致一个合理的默认值。
- en: What if you want to perform error checking? The most straightforward solution
    in this case is to use exceptions, as they will automatically propagate from the
    multiple nested calls to the caller's location. Ensure that you catch any exceptions
    you throw, or the application will terminate. A more Qt-like solution is to create
    a `bool *ok` argument in all methods (including internal ones) and set the boolean
    value to `false` in case of any error.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进行错误检查，在这种情况下最直接的方法是使用异常，因为它们会自动从多个嵌套调用传播到调用者的位置。确保你捕获你抛出的任何异常，否则应用程序将终止。一个更Qt的方法是在所有方法（包括内部方法）中创建一个`bool
    *ok`参数，并在发生任何错误时将该布尔值设置为`false`。
- en: Pop quiz
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. What is the closest equivalent of `std::string` in Qt?
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 在Qt中，`std::string`最接近的等效是什么？
- en: '`QString`'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QString`'
- en: '`QByteArray`'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QByteArray`'
- en: '`QStringLiteral`'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QStringLiteral`'
- en: Q2\. Which strings match the `\A\d\z` regular expression?
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 哪些字符串与`\A\d\z`正则表达式匹配？
- en: Strings consisting of digits
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由数字组成的字符串
- en: Strings consisting of a single digit
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由单个数字组成的字符串
- en: This is not a valid regular expression
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这不是一个有效的正则表达式
- en: Q3\. Which of the following container types can you use to store a list of widgets?
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 你可以使用哪种容器类型来存储小部件列表？
- en: '`QVector<QWidget>`'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QVector<QWidget>`'
- en: '`QList<QWidget>`'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QList<QWidget>`'
- en: '`QVector<QWidget*>`'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QVector<QWidget*>`'
- en: Q4\. Which class can you use to convert a text string containing JSON to a Qt
    JSON representation?
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. 你可以使用哪个类将包含JSON的文本字符串转换为Qt JSON表示？
- en: '`QJsonValue`'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QJsonValue`'
- en: '`QJsonObject`'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QJsonObject`'
- en: '`QJsonDocument`'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QJsonDocument`'
- en: Summary
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned a number of core Qt technologies, ranging from
    text manipulation and containers to accessing devices that can be used to transfer
    or store data, using a number of popular technologies such as XML or JSON. You
    should be aware that we have barely scratched the surface of what Qt offers and
    there are many other interesting classes you should familiarize yourself with,
    but this minimum amount of information should give you a head start and show you
    the direction to follow with your future research.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了大量的核心Qt技术，从文本操作和容器到使用XML或JSON等流行技术访问可用于传输或存储数据的设备。你应该意识到，我们只是触及了Qt所能提供的皮毛，还有许多其他有趣的类你应该熟悉，但这个最小量的信息应该能让你领先一步，并展示你未来研究的方向。
- en: In the next chapter, we will go beyond the boundaries of your computer and explore
    ways to use the powerful world of the modern internet. You will learn how to interact
    with the existing network services, check the current network availability, and
    implement your own servers and clients. This knowledge will come in handy if you
    want to implement multiplayer networked games.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将超越你电脑的边界，探索使用现代互联网强大世界的方法。你将学习如何与现有的网络服务交互，检查当前网络可用性，并实现你自己的服务器和客户端。如果你想要实现多人网络游戏，这些知识将非常有用。
