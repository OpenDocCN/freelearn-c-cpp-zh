<html><head></head><body>
<div><div><div><h1 id="_idParaDest-96" class="chapter-number"><a id="_idTextAnchor171"/>5</h1>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor172"/>The “Make” Build System</h1>
			<p>In this chapter, we will learn how to automate our entire build process using build systems, specifically focusing on the <strong class="bold">make</strong> build system – an indispensable tool<a id="_idIndexMarker429"/> for automating the compilation and linking processes in software development. We start by defining what a build system is and then exploring its fundamental purpose, which primarily involves automatically transforming source code into deployable software, such as executables or libraries.</p>
			<p>Throughout the chapter, we will systematically uncover the components of the <code>make</code> build system, starting<a id="_idIndexMarker430"/> with the essential elements of a <strong class="bold">Makefile</strong>, including <em class="italic">targets</em>, <em class="italic">prerequisites</em>, and <em class="italic">recipes</em>. In the latter part of the chapter, I will provide a step-by-step guide on writing a Makefile, highlighting the syntax and structure necessary to execute builds effectively.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>An introduction to build system<a id="_idTextAnchor173"/>s</li>
				<li>The Make build system</li>
				<li>Writing Makefiles for firmware projects</li>
			</ul>
			<p>By the end of this chapter, you will have a solid understanding of how to leverage the <code>make</code> build system to streamline your development process, improve build times, and reduce manual errors in building and deploying your firmware.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor174"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a>.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor175"/>An introduction to build systems</h1>
			<p>In the world of software development, build systems<a id="_idIndexMarker431"/> are pivotal tools that enable the transformation of source code into executable programs or other usable software formats. These systems automate the process of compiling and linking code, managing dependencies, and ensuring that software builds are reproducible and efficient. Simply put, a build system refers to a set of tools that automate the processes of compiling source code into binary code, linking binaries with libraries, and packaging the results into deployable software units. These systems are designed to handle complex dependency chains by tracking which parts of a software project need recompilation, thereby optimizing the build process. Build systems are responsible for a range of tasks. These include <a id="_idIndexMarker432"/>the following:</p>
			<ul>
				<li><strong class="bold">Dependency management</strong>: This involves identifying and resolving interdependencies among various components or libraries that software requires.</li>
				<li><strong class="bold">Code compilation</strong>: Converting source code, whether it’s written in C, C++, or another programming language, into machine-readable object code.</li>
				<li><strong class="bold">Linking</strong>: This process integrates the compiled object files and necessary libraries into a unified executable or library file.</li>
				<li><strong class="bold">Packaging</strong>: This step prepares the software for deployment, which might include creating installer packages or compressing software into distributable archives.</li>
				<li><strong class="bold">Testing and validation</strong>: Executing automated tests to confirm that software adheres to the predefined quality benchmarks before its release.</li>
				<li><strong class="bold">Documentation generation</strong>: Build systems can also automate the creation of documentation. This is achieved by integrating with tools such as Doxygen for C/C++, Javadoc for Java, or Sphinx for Python, which extract annotated comments and metadata from source code to produce structured documentation. This automation ensures that documentation stays synchronized with changes in the source code, thereby maintaining consistency and reducing manual errors.</li>
			</ul>
			<p>By incorporating these diverse functions, build systems significantly boost the efficiency and reliability of the software development process. Modern software projects often involve complex configurations, including thousands of source files and a wide array of external dependencies. Build systems provide a crucial framework to manage these complexities efficiently. They automate repetitive tasks, minimize the likelihood of human errors, and guarantee consistent builds across various environments. This streamlining not only enhances productivity but also supports the adoption of continuous integration and continuous delivery practices, which are essential for timely and effective software delivery.</p>
			<p>Choosing a build system<a id="_idIndexMarker433"/> depends on various factors, including the programming language used in a project, the platform compatibility required, and the development team’s familiarity with the tool. Some of the commonly used build systems include <code>make</code> and <code>maven</code>.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor176"/>Make</h2>
			<p>Make is one of the oldest<a id="_idIndexMarker434"/> and most fundamental build systems available. It is primarily used for C and C++ projects. Make uses Makefiles to specify how to compile and link source files. Its primary advantage lies in its simplicity and broad support across different platforms.</p>
			<p>Its key features<a id="_idIndexMarker435"/> include the following:</p>
			<ul>
				<li><strong class="bold">Flexibility</strong>: Make allows us to define explicit rules on how files should be compiled and linked.</li>
				<li><code>make</code> can be used with a variety of compilers and programming languages. On Windows, <code>make</code> can be<a id="_idIndexMarker436"/> used in environments such as <strong class="bold">Minimalist GNU for Windows</strong> (<strong class="bold">MinGW</strong>) or Cygwin.</li>
			</ul>
			<p>Next, let’s look at maven.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor177"/>Maven</h2>
			<p><code>Maven</code> is primarily used<a id="_idIndexMarker437"/> for Java projects. It is designed to provide a comprehensive and standard framework for building projects, handling documentation, reporting, dependencies, <strong class="bold">Source Control Management</strong> (<strong class="bold">SCM</strong>) systems, releases, and<a id="_idIndexMarker438"/> distribution. The key features<a id="_idIndexMarker439"/> include the following:</p>
			<ul>
				<li><strong class="bold">Convention over configuration</strong>: Maven uses a standard directory layout and a default build life cycle to decrease the time spent on configuring projects</li>
				<li><strong class="bold">Dependency management</strong>: It can automatically download libraries and plugins from repositories and incorporate them into the build process</li>
				<li><strong class="bold">Project information management</strong>: Maven can generate project documentation, reports, and other information from a project’s metadata</li>
				<li><strong class="bold">Build and release management</strong>: Maven supports the entire build life cycle, from compilation, packaging, and testing to deployment and release management</li>
				<li><strong class="bold">Extensibility</strong>: Maven’s plugin-based architecture allows it to be extended with custom plugins to support additional tasks</li>
			</ul>
			<p>Other notable build systems include <code>Apache Ant</code>, which is a Java-based build system, and <code>Gradle</code>, which supports multiple programming languages but is especially favored within the Java ecosystem.</p>
			<p>Before exploring the specifics of the <code>make</code> build system, it is important to familiarize ourselves with the fundamental components of build systems. These components form the backbone of the build process<a id="_idIndexMarker440"/> and include the following:</p>
			<ul>
				<li><strong class="bold">Source code</strong>: The raw, human-readable code written in programming languages such as C, Java, and Python.</li>
				<li><code>javac</code> for Java.</li>
				<li><strong class="bold">Linker</strong>: The tool that combines object files into a single executable or library file.</li>
				<li><strong class="bold">Build scripts</strong>: Scripts that describe the build process. They define what commands need to be run and their order.</li>
				<li><strong class="bold">Dependencies</strong>: External code libraries or tools required by a project that need to be integrated during the build process.</li>
				<li><strong class="bold">Artifacts</strong>: The output of build systems, which can include executables, libraries, or other formats needed<a id="_idIndexMarker441"/> to deploy or run software.</li>
			</ul>
			<p>In the upcoming section, we will explore the fundamentals of the <code>make</code> build system and learn how to write Makefiles that automate the build process for firmware projects.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor178"/>The Make build system</h1>
			<p>In this section, we will explore<a id="_idIndexMarker442"/> the Make build system, from its basic concepts to practical usage in firmware development.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor179"/>The basics of Make</h2>
			<p>The primary component<a id="_idIndexMarker443"/> of the <code>make</code> build system is the Makefile, which contains a set of directives used by the tool to generate a <em class="italic">target</em>. At its core, a Makefile consists of <strong class="bold">rules</strong>. Each rule begins<a id="_idIndexMarker444"/> with a <em class="italic">target</em>, followed by <em class="italic">prerequisites</em>, and then a <em class="italic">recipe</em>:</p>
			<ul>
				<li><code>main.o</code> or <code>app.exe</code>. The target can also be the name of the action to carry out.</li>
				<li><code>main.c</code> and <code>adc.c</code>).</li>
				<li><code>make</code> executes in order to build the target.</li>
			</ul>
			<p>The following diagram illustrates a simple make rule:</p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B21914_05_1.jpg" alt="Figure 5.1: A Make rule, with main.o as the target file to be generated from the prerequisite, main.c, using the arm-none-eabi-gcc main.c –o main.o recipe" width="833" height="437"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: A Make rule, with main.o as the target file to be generated from the prerequisite, main.c, using the arm-none-eabi-gcc main.c –o main.o recipe</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The line of the recipe must start with a tab.</p>
			<p>Makefiles also allow<a id="_idIndexMarker445"/> us to use variables to simplify and manage complex build commands and configurations. For instance, we can define a variable name, <code>CC</code>, to represent the <code>compiler</code> command, as shown in <em class="italic">Figure 5</em><em class="italic">.2</em>:</p>
			<div><div><img src="img/B21914_05_2.jpg" alt="Figure 5.2: A Make rule, with main.o as the target file to be generated from the prerequisite, main.c, where the compiler command in the recipe is replaced by a variable" width="720" height="611"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2: A Make rule, with main.o as the target file to be generated from the prerequisite, main.c, where the compiler command in the recipe is replaced by a variable</p>
			<p>Variables in Makefiles allow us to store text strings that can be reused throughout a file. The most basic way to define a variable is by simple assignment (<code>=</code>):</p>
			<pre class="console">
CC = arm-none-eabi-gcc</pre>			<p>This line sets the <code>CC</code> variable to the <code>arm-none-eabi-gcc</code> cross-compiler.</p>
			<p>Once defined, variables can be used throughout the Makefile to simplify commands and definitions. To use a variable, enclose its name in <code>$(...)</code> or <code>${...}</code>:</p>
			<pre class="console">
$(CC) main.c –o main.o</pre>			<p>The recipe uses the <code>$(CC)</code> variable to refer to the compiler set earlier (<code>arm-none-eabi-gcc</code>).</p>
			<p>Apart from user-defined<a id="_idIndexMarker446"/> variables, there are special variables related to targets and prerequisites that come in handy when writing Makefiles.</p>
			<p>In <code>make</code>, special variables related to targets help streamline the process of specifying filenames and file paths, making the rules within a Makefile more general and reusable. One of the most commonly used special variables for targets is <code>'$@' - Target Name</code>. This variable represents the name of the target for the rule. It is particularly useful when the target name is repeated multiple times within a rule, which is common in link and compile commands.</p>
			<p>Let’s <a id="_idTextAnchor180"/>see an example:</p>
			<pre class="console">
main.o :  main.c
     arm-none-eabi-gcc main.c –o $@</pre>			<p>In this example, <code>$@</code> is replaced by <code>main.o</code>, which is the target of the rule.</p>
			<p>Make also provides special variables to reference prerequisites. One of the most commonly used is <code>$^</code>. This variable lists all the prerequisites of a target, with spaces between them (if more than one). Let’s see an example:</p>
			<pre class="console">
main.o :  main.c
     arm-none-eabi-gcc $^ –o main.o</pre>			<p>When the preceding snippet of the Makefile is executed, <code>$^</code> is replaced with <code>main.c</code>, effectively running the <code>arm-none-eabi-gcc main.c –o </code><code>main.o</code> command.</p>
			<p>Special variables in Makefiles are very useful in improving efficiency and flexibility when defining build rules. By effectively using these variables, we can create more robust and maintainable build systems.</p>
			<p>We will conclude this section with <em class="italic">Figure 5</em><em class="italic">.3</em>. This figure illustrates<a id="_idIndexMarker447"/> the revised rule from <em class="italic">Figure 5</em><em class="italic">.2</em>, now incorporating our user-defined variable along with the special variables related to targets and prerequisites.</p>
			<div><div><img src="img/B21914_05_3.jpg" alt="Figure 5.3: A Make rule using a user-defined variable and two special variables" width="567" height="345"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3: A Make rule using a user-defined variable and two spe<a id="_idTextAnchor181"/>cial variables</p>
			<p>In the next section, I will guide you through the process of setting up a <code>make</code> build system on your development computer.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor182"/>Installing and configuring Make</h2>
			<p>In this section, we will go through the process of downloading, installing, and configuring the <code>make</code> build system on a Windows environment. Let’s begin:</p>
			<ol>
				<li><strong class="bold">Download make</strong>: We begin by navigating<a id="_idIndexMarker448"/> to the appropriate website to download GNU Make for Windows. For this example, we’ll use SourceForge, a popular repository for open source projects. Go to <a href="https://gnuwin32.sourceforge.net/packages/make.htm">https://gnuwin32.sourceforge.net/packages/make.htm</a>.<p class="list-inset">Under the <strong class="bold">Complete package, except sources</strong> option description, click <strong class="bold">Setup</strong> under the <strong class="bold">Download</strong> column to start downloading.</p></li>
				<li><code>make</code> on your computer. When you reach the step titled <code>C:\Program </code><code>Files (x86)\GnuWin32</code>.</li>
				<li><code>make</code> from any command line<a id="_idIndexMarker450"/> or script, we need to add its executable to our system environment variables, following the same process we used in <a href="B21914_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a> to add OpenOCD to the environment variables.<p class="list-inset">We do this by navigating to the <code>bin</code> folder where <code>make</code> was installed (<code>C:\Program Files (x86)\GnuWin32\bin</code>) and then copying the path.</p><p class="list-inset">Then, we do the following:</p><ol><li class="upper-roman">Right-click on <code>make</code> path into this new row.</li><li class="upper-roman">Confirm your changes by clicking <strong class="bold">OK</strong> on the various pop-up windows.</li></ol></li>
			</ol>
			<p>To confirm that the <code>make</code> is properly set up, open command prompt and simply type <code>make</code>, as shown here:</p>
			<pre class="console">
make</pre>			<p>It should return the following:</p>
			<pre class="console">
make: *** No targets specified and no makefile found.  Stop.</pre>			<p>This confirms that the <code>make</code> build system is properly configured on the Windows machine.</p>
			<p>On many Linux distributions, <code>make</code> is readily available<a id="_idIndexMarker451"/> through the distribution’s package manager. For instance, on Ubuntu and other Debian-based distributions, we can install make (along with other build essentials, such as the GCC compiler) by running the following:</p>
			<pre class="console">
 sudo apt install build-essential</pre>			<p>On macOS, <code>make</code> is part of the Command Line Tools package that comes with Xcode, Apple’s suite of development tools. This means that if you have installed Xcode, you will have <code>make</code> already installed. We can also install the standalone Command Line Tools package by running the following<a id="_idIndexMarker452"/> command in the terminal:</p>
			<pre class="console">
xcode-select –-install</pre>			<p>In this section, we successfully set up the <code>make</code> build system on our development machine. In the following section, we will apply the concepts covered in this chapter to write our own Makefile.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor184"/>Writing Makefiles for firmware projects</h1>
			<p>The focus of this section<a id="_idIndexMarker453"/> is to write a Makefile<a id="_idIndexMarker454"/> and successfully test it. Let’s begin.</p>
			<p>In our workspace folder, let’s make a new folder named <code>4_Makefiles</code>. In this folder, create a file called <code>Makefile</code>. This file must start with a capital <strong class="bold">M</strong> and should have <strong class="bold">no extension</strong>.</p>
			<p>If you’re using Windows and it asks whether you really want to change the file extension, click <strong class="bold">Yes</strong>. Then, right-click the file and open it with a basic text editor, such as Notepad++.</p>
			<p>Our objectives with the Makefile <a id="_idIndexMarker455"/>can be summarized as follows:</p>
			<ol>
				<li><code>main.c</code> and <code>stm32f411_startup.c</code>) into object files (<code>main.o</code> and <code>stm32f411_startup.o</code>).</li>
				<li><code>stm32_ls.ld</code>) to create a final executable (<code>4_makefile_project.elf</code>).</li>
				<li><code>*.o</code>, <code>*.elf.</code>, and <code>*.map</code>), allowing for a fresh start with no leftover artifacts<a id="_idIndexMarker456"/> from previous builds</li></ol></li>
			</ol>
			<p>This is our<a id="_idIndexMarker457"/> complete<a id="_idIndexMarker458"/> Makefile:</p>
			<pre class="source-code">
final : 4_makefile_project.elf
main.o : main.c
    arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 main.c -o 
    main.o
stm32f411_startup.o : stm32f411_startup.c
    arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 stm32f411_
    startup.c -o stm32f411_startup.o
4_makefile_project.elf : main.o stm32f411_startup.o
    arm-none-eabi-gcc -nostdlib -T stm32_ls.ld *.o -o 4_makefile_
    project.elf -Wl,-Map=4_makefile_project.map
load :
    openocd -f board/st_nucleo_f4.cfg
clean:
del    -f *.o *.elf *.map</pre>			<p>Let’s break it down:</p>
			<ol>
				<li><code>final : </code><code>4_makefile_project.elf</code><p class="list-inset">This line deals<a id="_idIndexMarker459"/> with the creation of the final<a id="_idIndexMarker460"/> target.</p><p class="list-inset">When we execute <code>make final</code>,<a id="_idTextAnchor185"/> <code>make</code> will check whether the <code>4_makefile_project.elf</code> target needs to be updated before executing it. This is a dependency relationship where <code>final</code> acts purely as an aggregation point to invoke all the build processes leading up to <code>4_makefile_project.elf</code>.</p></li>
				<li><code>main.o : </code><code>main.c</code></p><p class="list-inset"><code>arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 main.c -</code><code>o main.o</code></p><p class="list-inset">The <code>make</code> rule compiles the <code>main.c</code> source file into an object file named <code>main.o.</code> Upon close inspection, you can see that the command employed here is identical to the one we used at the command prompt to manually compile <code>main.c</code> in the previous chapter.</p></li>
				<li><code>stm32f411_startup.o : </code><code>stm32f411_startup.c</code></p><p class="list-inset"><code>arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 stm32f411_startup.c -</code><code>o stm32f411_startup.o</code></p><p class="list-inset">This compiles the <code>stm32f411_startup.c</code> source file into an object file, named <code>stm32f411_startup.o</code>.</p></li>
				<li><code>4_makefile_project.elf : </code><code>main.o stm32f411_startup.o</code></p><p class="list-inset"><code>arm-none-eabi-gcc -no<a id="_idTextAnchor186"/>stdlib -T stm32_ls.ld *.o -o </code><code>4_makefile_project.elf -Wl,-Map=4_makefile_project.map</code></p><p class="list-inset">This rule links<a id="_idIndexMarker461"/> the <code>main.o</code> and <code>stm32f411_startup.o</code> object files<a id="_idIndexMarker462"/> to produce the final executable, <code>4_makefile_project.elf</code>. Additionally, it generates a map file named <code>4_makefile_project.map</code> that shows where each part of the code and data is loaded in memory, which is useful for debugging.</p></li>
				<li><code>load:</code></p><p class="list-inset"><code>openocd -</code><code>f board/st_nucleo_f4.cfg</code></p><p class="list-inset">This rule initiates OpenOCD to begin the process of loading the final executable onto the target hardware. It executes OpenOCD, using a configuration file tailored for the STM32 Nucleo F4 board, specifically <code>st_nucleo_f4.cfg</code>.</p></li>
				<li><code>clean:</code></p><p class="list-inset"><code>del</code> <code>-f *.o *.</code><code>elf *.map</code></p><p class="list-inset">This command cleans the build directory by removing all generated files, ensuring a clean environment for subsequent builds. The <code>del -f</code> command forcefully deletes files, preventing prompts that ask for deletion confirmation. The <code>*.o</code>, <code>*.elf</code>, and <code>*.map</code> patterns specify that all object files, ELF executables, and map<a id="_idIndexMarker463"/> files, respectively, should<a id="_idIndexMarker464"/> be deleted.</p></li>
			</ol>
			<p>With the Makefile ready, it is time to test it out.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor187"/>Testing our Makefile</h2>
			<p>Before proceeding<a id="_idIndexMarker465"/> to the command line, let’s ensure that the linker script, startup file, and all source files are placed in the correct directory. Additionally, we will slightly update the <code>main.c</code> file, which will allow us to validate that the most recent version of the firmware executes correctly:</p>
			<ol>
				<li><code>main.c</code> file from the previous project (<code>3_LinkerscriptAndStartup</code>), which includes the foundational application code.</li><li class="upper-roman">Additionally, locate <code>stm32_ls.ld</code> (the linker script) and <code>stm32f411_startup.c</code> (the startup file).</li><li class="upper-roman">Copy and paste these files (<code>stm32_ls.ld</code>, <code>stm32f411_startup.c</code>, and <code>main.c</code>) into the <code>4_Makefiles</code> folder.</li></ol></li>
				<li><code>main.c</code> file from slow to fast:<ol><li class="upper-roman"><code>main.c</code> file within the <code>4_ Makefiles</code> folder and select the option to open it with a simple text editor, such as Notepad++.</li><li class="upper-roman"><code>LED_PIN</code>). Adjust the delay intervals within this section to change the LED’s blink rate from its current slower pace to a rapid one. The curre<a id="_idTextAnchor188"/>nt one should look like this:</li></ol><pre class="source-code">
        //  22: Toggle PA5(LED_PIN)
        GPIOA_OD_R ^= LED_PIN;
    for(int i = 0; i &lt; 5000000; i++){}</pre><p class="list-inset">Replace the current code<a id="_idIndexMarker466"/> with the following snippet to toggle the state of PA5 to a faster rate:</p><pre class="source-code">        //  22: Toggle PA5(LED_PIN)
        GPIOA_OD_R ^= LED_PIN;
for(int i = 0; i &lt; <code>main.c</code> file.</li></ol></li>			</ol>
			<p>Now, let’s access our new folder through the command prompt, following the steps we used in the previous chapter.</p>
			<p>In the command prompt, simply execute the following:</p>
			<pre class="console">
make final</pre>			<p>This will create our final executable, <code>4_makefile_project.elf</code>.</p>
			<p>Next, we will begin uploading the final executable onto our microcontroller by executing the following:</p>
			<pre class="console">
make load</pre>			<p>This will launch OpenOCD. The next <a id="_idIndexMarker467"/>step involves using the <strong class="bold">GNU Debugger</strong> (<strong class="bold">GDB</strong>) to upload the firmware to the microcontroller, as we did in the previous chapter. Let’s access another command prompt window (as OpenOCD should keep running in the first one) and enter the following command to start the GDB:</p>
			<pre class="console">
arm-none-eabi-gdb</pre>			<p>Once GDB is open, we establish a connection to our microcontroller by running the following:</p>
			<pre class="console">
target remote localhost:3333</pre>			<p>Let’s reset and initialize the board, as we learned in <a href="B21914_03.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, using the following command:</p>
			<pre class="console">
monitor reset init</pre>			<p>Next, we load the firmware onto the microcontroller using the following command:</p>
			<pre class="console">
monitor flash write_image erase 4_makefile_project.elf</pre>			<p>After successfully loading the firmware, we reset the board again with the same reset command:</p>
			<pre class="console">
monitor reset init</pre>			<p>Finally, we resume the execution of the firmware on the <a id="_idTextAnchor189"/>microcontroller with the following:</p>
			<pre class="console">
monitor resume</pre>			<p>You should see the LED blinking <a id="_idIndexMarker468"/>at a rapid rate, indicating the successful upload and execution of our new firmware.</p>
			<p>We can stop the GDB by executing the following:</p>
			<pre class="console">
quit</pre>			<p>And then, we execute the following when asked if we want to quit anyway:</p>
			<pre class="console">
y</pre>			<p>To clean our build directory, we will open the command prompt in the build directory and execute the following command:</p>
			<pre class="console">
make clean</pre>			<p>This will delete all the <code>.o</code>, <code>.elf</code>, and <code>.map</code> files in the build directory.</p>
			<p>Before concluding this chapter, let’s explore how our Makefile appears when we incorporate special and user-defined variables.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor190"/>Applying special and user-defined variables</h2>
			<p>Let’s apply special variables<a id="_idIndexMarker469"/> and user-defined<a id="_idIndexMarker470"/> variables to our makefile:</p>
			<pre class="source-code">
CC = arm-none-eabi-gcc
CFLAGS = -c -mcpu=cortex-m4 -mthumb -std=gnu11
LDFLAGS = -nostdlib -T stm32_ls.ld -Wl,-Map= 5_makefile_project_v2.map
final : 5_makefile_project_v2.elf
main.o : main.c
    $(CC) $(CFLAGS) $^ -o $@
stm32f411_startup.o : stm32f411_startup.c
    $(CC) $(CFLAGS) $^ -o $@
5_makefile_project_v2.elf : main.o stm32f411_startup.o
    $(CC) $(LDFLAGS) $^ -o $@
load :
    openocd -f board/st_nucleo_f4.cfg
clean:
    del    -f *.o *.elf *.map</pre>			<p>In this version, we’ve defined three essential variables to streamline our Makefile:</p>
			<ul>
				<li><code>CC</code>: This variable represents<a id="_idIndexMarker471"/> the compiler used to compile the source files. It simplifies the Makefile by centralizing the compiler definition, making it easier to update or change if needed.</li>
				<li><code>CFLAGS</code>: This holds the compilation<a id="_idIndexMarker472"/> flags necessary to build the source files.</li>
				<li><code>LDFLAGS</code>: This contains<a id="_idIndexMarker473"/> the linker flags that dictate how an executable is linked from the object files.</li>
			</ul>
			<p>Additionally, we’ve used special variables for target names (<code>$@</code>) and prerequisite lists (<code>$^</code>) to replace explicit mentions<a id="_idIndexMarker474"/> of these components in the <code>make</code> recipes, further simplifying<a id="_idIndexMarker475"/> the Makefile structure.</p>
			<p>Update your current makefile to this new version and upload the new executable, named <code>5_makefile_project_v2.elf</code>, onto your microcontroller. This updated version should function seamlessly, just like the previous one.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor191"/>Summary</h1>
			<p>In this chapter, we embarked on an exploration of the <code>make</code> build system, a cornerstone tool for automating the build process in software development. The journey began with an introduction to what build systems are and their critical role in converting source code into deployable software, such as executables and libraries.</p>
			<p>We then delved into the specific mechanics of the <code>make</code> build system, starting with the foundational elements of a Makefile, which include <em class="italic">targets</em>, <em class="italic">prerequisites</em>, and <em class="italic">recipes</em>. These components were thoroughly discussed to provide a clear understanding of how they interact within <code>make</code> to manage and streamline the compilation and linking of software projects.</p>
			<p>This chapter wrapped up with a practical demonstration of writing Makefiles, effectively consolidating the theoretical concepts discussed throughout. This hands-on experience ensures that you are well-equipped to apply these strategies to your own firmware projects.</p>
			<p>In the next chapter, we will transition to another critical aspect of firmware development – the development of peripheral drivers, beginning with <strong class="bold">General Purpose Input/Output</strong> (<strong class="bold">GPI/O</strong>) drivers. This shift will introduce you to the fundamentals of interfacing with hardware components, a pivotal skill in embedded systems development.</p>
		</div>
	</div>
</div>
</body></html>