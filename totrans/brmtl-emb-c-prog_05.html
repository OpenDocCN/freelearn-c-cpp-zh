<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer071">
			<h1 id="_idParaDest-96" class="chapter-number"><a id="_idTextAnchor171"/>5</h1>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor172"/>The “Make” Build System</h1>
			<p>In this chapter, we will learn how to automate our entire build process using build systems, specifically focusing on the <strong class="bold">make</strong> build system – an indispensable tool<a id="_idIndexMarker429"/> for automating the compilation and linking processes in software development. We start by defining what a build system is and then exploring its fundamental purpose, which primarily involves automatically transforming source code into deployable software, such as executables <span class="No-Break">or libraries.</span></p>
			<p>Throughout the chapter, we will systematically uncover the components of the <strong class="source-inline">make</strong> build system, starting<a id="_idIndexMarker430"/> with the essential elements of a <strong class="bold">Makefile</strong>, including <em class="italic">targets</em>, <em class="italic">prerequisites</em>, and <em class="italic">recipes</em>. In the latter part of the chapter, I will provide a step-by-step guide on writing a Makefile, highlighting the syntax and structure necessary to execute <span class="No-Break">builds effectively.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>An introduction to <span class="No-Break">build system<a id="_idTextAnchor173"/>s</span></li>
				<li>The Make <span class="No-Break">build system</span></li>
				<li>Writing Makefiles for <span class="No-Break">firmware projects</span></li>
			</ul>
			<p>By the end of this chapter, you will have a solid understanding of how to leverage the <strong class="source-inline">make</strong> build system to streamline your development process, improve build times, and reduce manual errors in building and deploying <span class="No-Break">your firmware.</span></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor174"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor175"/>An introduction to build systems</h1>
			<p>In the world of software development, build systems<a id="_idIndexMarker431"/> are pivotal tools that enable the transformation of source code into executable programs or other usable software formats. These systems automate the process of compiling and linking code, managing dependencies, and ensuring that software builds are reproducible and efficient. Simply put, a build system refers to a set of tools that automate the processes of compiling source code into binary code, linking binaries with libraries, and packaging the results into deployable software units. These systems are designed to handle complex dependency chains by tracking which parts of a software project need recompilation, thereby optimizing the build process. Build systems are responsible for a range of tasks. These include <a id="_idIndexMarker432"/><span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Dependency management</strong>: This involves identifying and resolving interdependencies among various components or libraries that <span class="No-Break">software requires.</span></li>
				<li><strong class="bold">Code compilation</strong>: Converting source code, whether it’s written in C, C++, or another programming language, into machine-readable <span class="No-Break">object code.</span></li>
				<li><strong class="bold">Linking</strong>: This process integrates the compiled object files and necessary libraries into a unified executable or <span class="No-Break">library file.</span></li>
				<li><strong class="bold">Packaging</strong>: This step prepares the software for deployment, which might include creating installer packages or compressing software into <span class="No-Break">distributable archives.</span></li>
				<li><strong class="bold">Testing and validation</strong>: Executing automated tests to confirm that software adheres to the predefined quality benchmarks before <span class="No-Break">its release.</span></li>
				<li><strong class="bold">Documentation generation</strong>: Build systems can also automate the creation of documentation. This is achieved by integrating with tools such as Doxygen for C/C++, Javadoc for Java, or Sphinx for Python, which extract annotated comments and metadata from source code to produce structured documentation. This automation ensures that documentation stays synchronized with changes in the source code, thereby maintaining consistency and reducing <span class="No-Break">manual errors.</span></li>
			</ul>
			<p>By incorporating these diverse functions, build systems significantly boost the efficiency and reliability of the software development process. Modern software projects often involve complex configurations, including thousands of source files and a wide array of external dependencies. Build systems provide a crucial framework to manage these complexities efficiently. They automate repetitive tasks, minimize the likelihood of human errors, and guarantee consistent builds across various environments. This streamlining not only enhances productivity but also supports the adoption of continuous integration and continuous delivery practices, which are essential for timely and effective <span class="No-Break">software delivery.</span></p>
			<p>Choosing a build system<a id="_idIndexMarker433"/> depends on various factors, including the programming language used in a project, the platform compatibility required, and the development team’s familiarity with the tool. Some of the commonly used build systems include <strong class="source-inline">make</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">maven</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor176"/>Make</h2>
			<p>Make is one of the oldest<a id="_idIndexMarker434"/> and most fundamental build systems available. It is primarily used for C and C++ projects. Make uses Makefiles to specify how to compile and link source files. Its primary advantage lies in its simplicity and broad support across <span class="No-Break">different platforms.</span></p>
			<p>Its key features<a id="_idIndexMarker435"/> include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Flexibility</strong>: Make allows us to define explicit rules on how files should be compiled <span class="No-Break">and linked.</span></li>
				<li><strong class="bold">Wide support</strong>: It is available on most Unix-like systems as well as Windows. Also, <strong class="source-inline">make</strong> can be used with a variety of compilers and programming languages. On Windows, <strong class="source-inline">make</strong> can be<a id="_idIndexMarker436"/> used in environments such as <strong class="bold">Minimalist GNU for Windows</strong> (<strong class="bold">MinGW</strong>) <span class="No-Break">or Cygwin.</span></li>
			</ul>
			<p>Next, let’s look <span class="No-Break">at maven.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor177"/>Maven</h2>
			<p><strong class="source-inline">Maven</strong> is primarily used<a id="_idIndexMarker437"/> for Java projects. It is designed to provide a comprehensive and standard framework for building projects, handling documentation, reporting, dependencies, <strong class="bold">Source Control Management</strong> (<strong class="bold">SCM</strong>) systems, releases, and<a id="_idIndexMarker438"/> distribution. The key features<a id="_idIndexMarker439"/> include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Convention over configuration</strong>: Maven uses a standard directory layout and a default build life cycle to decrease the time spent on <span class="No-Break">configuring projects</span></li>
				<li><strong class="bold">Dependency management</strong>: It can automatically download libraries and plugins from repositories and incorporate them into the <span class="No-Break">build process</span></li>
				<li><strong class="bold">Project information management</strong>: Maven can generate project documentation, reports, and other information from a <span class="No-Break">project’s metadata</span></li>
				<li><strong class="bold">Build and release management</strong>: Maven supports the entire build life cycle, from compilation, packaging, and testing to deployment and <span class="No-Break">release management</span></li>
				<li><strong class="bold">Extensibility</strong>: Maven’s plugin-based architecture allows it to be extended with custom plugins to support <span class="No-Break">additional tasks</span></li>
			</ul>
			<p>Other notable build systems include <strong class="source-inline">Apache Ant</strong>, which is a Java-based build system, and <strong class="source-inline">Gradle</strong>, which supports multiple programming languages but is especially favored within the <span class="No-Break">Java ecosystem.</span></p>
			<p>Before exploring the specifics of the <strong class="source-inline">make</strong> build system, it is important to familiarize ourselves with the fundamental components of build systems. These components form the backbone of the build process<a id="_idIndexMarker440"/> and include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Source code</strong>: The raw, human-readable code written in programming languages such as C, Java, <span class="No-Break">and Python.</span></li>
				<li><strong class="bold">Compiler</strong>: The tool that converts source code into machine-readable object files. Common compilers include GCC for C/C++ and <strong class="source-inline">javac</strong> <span class="No-Break">for Java.</span></li>
				<li><strong class="bold">Linker</strong>: The tool that combines object files into a single executable or <span class="No-Break">library file.</span></li>
				<li><strong class="bold">Build scripts</strong>: Scripts that describe the build process. They define what commands need to be run and <span class="No-Break">their order.</span></li>
				<li><strong class="bold">Dependencies</strong>: External code libraries or tools required by a project that need to be integrated during the <span class="No-Break">build process.</span></li>
				<li><strong class="bold">Artifacts</strong>: The output of build systems, which can include executables, libraries, or other formats needed<a id="_idIndexMarker441"/> to deploy or <span class="No-Break">run software.</span></li>
			</ul>
			<p>In the upcoming section, we will explore the fundamentals of the <strong class="source-inline">make</strong> build system and learn how to write Makefiles that automate the build process for <span class="No-Break">firmware projects.</span></p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor178"/>The Make build system</h1>
			<p>In this section, we will explore<a id="_idIndexMarker442"/> the Make build system, from its basic concepts to practical usage in <span class="No-Break">firmware development.</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor179"/>The basics of Make</h2>
			<p>The primary component<a id="_idIndexMarker443"/> of the <strong class="source-inline">make</strong> build system is the Makefile, which contains a set of directives used by the tool to generate a <em class="italic">target</em>. At its core, a Makefile consists of <strong class="bold">rules</strong>. Each rule begins<a id="_idIndexMarker444"/> with a <em class="italic">target</em>, followed by <em class="italic">prerequisites</em>, and then <span class="No-Break">a </span><span class="No-Break"><em class="italic">recipe</em></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Target</strong>: This is typically the name of the file that the rule generates – in other words, the output file that needs to be generated, such as <strong class="source-inline">main.o</strong> or <strong class="source-inline">app.exe</strong>. The target can also be the name of the action to <span class="No-Break">carry out.</span></li>
				<li><strong class="bold">Prerequisites</strong>: These are the source files needed to create the target (e.g., <strong class="source-inline">main.c</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">adc.c</strong></span><span class="No-Break">).</span></li>
				<li><strong class="bold">Recipes</strong>: The recipe is a series of commands that <strong class="source-inline">make</strong> executes in order to build <span class="No-Break">the target.</span></li>
			</ul>
			<p>The following diagram illustrates a simple <span class="No-Break">make rule:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B21914_05_1.jpg" alt="Figure 5.1: A Make rule, with main.o as the target file to be generated from the prerequisite, main.c, using the arm-none-eabi-gcc main.c –o main.o recipe" width="833" height="437"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: A Make rule, with main.o as the target file to be generated from the prerequisite, main.c, using the arm-none-eabi-gcc main.c –o main.o recipe</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The line of the recipe must start with <span class="No-Break">a tab.</span></p>
			<p>Makefiles also allow<a id="_idIndexMarker445"/> us to use variables to simplify and manage complex build commands and configurations. For instance, we can define a variable name, <strong class="source-inline">CC</strong>, to represent the <strong class="source-inline">compiler</strong> command, as shown in <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B21914_05_2.jpg" alt="Figure 5.2: A Make rule, with main.o as the target file to be generated from the prerequisite, main.c, where the compiler command in the recipe is replaced by a variable" width="720" height="611"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2: A Make rule, with main.o as the target file to be generated from the prerequisite, main.c, where the compiler command in the recipe is replaced by a variable</p>
			<p>Variables in Makefiles allow us to store text strings that can be reused throughout a file. The most basic way to define a variable is by simple <span class="No-Break">assignment (</span><span class="No-Break"><strong class="source-inline">=</strong></span><span class="No-Break">):</span></p>
			<pre class="console">
CC = arm-none-eabi-gcc</pre>			<p>This line sets the <strong class="source-inline">CC</strong> variable to the <span class="No-Break"><strong class="source-inline">arm-none-eabi-gcc</strong></span><span class="No-Break"> cross-compiler.</span></p>
			<p>Once defined, variables can be used throughout the Makefile to simplify commands and definitions. To use a variable, enclose its name in <strong class="source-inline">$(...)</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">${...}</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$(CC) main.c –o main.o</pre>			<p>The recipe uses the <strong class="source-inline">$(CC)</strong> variable to refer to the compiler set <span class="No-Break">earlier (</span><span class="No-Break"><strong class="source-inline">arm-none-eabi-gcc</strong></span><span class="No-Break">).</span></p>
			<p>Apart from user-defined<a id="_idIndexMarker446"/> variables, there are special variables related to targets and prerequisites that come in handy when <span class="No-Break">writing Makefiles.</span></p>
			<p>In <strong class="source-inline">make</strong>, special variables related to targets help streamline the process of specifying filenames and file paths, making the rules within a Makefile more general and reusable. One of the most commonly used special variables for targets is <strong class="source-inline">'$@' - Target Name</strong>. This variable represents the name of the target for the rule. It is particularly useful when the target name is repeated multiple times within a rule, which is common in link and <span class="No-Break">compile commands.</span></p>
			<p>Let’s <a id="_idTextAnchor180"/>see <span class="No-Break">an example:</span></p>
			<pre class="console">
main.o :  main.c
     arm-none-eabi-gcc main.c –o $@</pre>			<p>In this example, <strong class="source-inline">$@</strong> is replaced by <strong class="source-inline">main.o</strong>, which is the target of <span class="No-Break">the rule.</span></p>
			<p>Make also provides special variables to reference prerequisites. One of the most commonly used is <strong class="source-inline">$^</strong>. This variable lists all the prerequisites of a target, with spaces between them (if more than one). Let’s see <span class="No-Break">an example:</span></p>
			<pre class="console">
main.o :  main.c
     arm-none-eabi-gcc $^ –o main.o</pre>			<p>When the preceding snippet of the Makefile is executed, <strong class="source-inline">$^</strong> is replaced with <strong class="source-inline">main.c</strong>, effectively running the <strong class="source-inline">arm-none-eabi-gcc main.c –o </strong><span class="No-Break"><strong class="source-inline">main.o</strong></span><span class="No-Break"> command.</span></p>
			<p>Special variables in Makefiles are very useful in improving efficiency and flexibility when defining build rules. By effectively using these variables, we can create more robust and maintainable <span class="No-Break">build systems.</span></p>
			<p>We will conclude this section with <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.3</em>. This figure illustrates<a id="_idIndexMarker447"/> the revised rule from <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.2</em>, now incorporating our user-defined variable along with the special variables related to targets <span class="No-Break">and prerequisites.</span></p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B21914_05_3.jpg" alt="Figure 5.3: A Make rule using a user-defined variable and two special variables" width="567" height="345"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3: A Make rule using a user-defined variable and two spe<a id="_idTextAnchor181"/>cial variables</p>
			<p>In the next section, I will guide you through the process of setting up a <strong class="source-inline">make</strong> build system on your <span class="No-Break">development computer.</span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor182"/>Installing and configuring Make</h2>
			<p>In this section, we will go through the process of downloading, installing, and configuring the <strong class="source-inline">make</strong> build system on a Windows environment. <span class="No-Break">Let’s begin:</span></p>
			<ol>
				<li><strong class="bold">Download make</strong>: We begin by navigating<a id="_idIndexMarker448"/> to the appropriate website to download GNU Make for Windows. For this example, we’ll use SourceForge, a popular repository for open source projects. Go <span class="No-Break">to </span><a href="https://gnuwin32.sourceforge.net/packages/make.htm"><span class="No-Break">https://gnuwin32.sourceforge.net/packages/make.htm</span></a><span class="No-Break">.</span><p class="list-inset">Under the <strong class="bold">Complete package, except sources</strong> option description, click <strong class="bold">Setup</strong> under the <strong class="bold">Download</strong> column to <span class="No-Break">start downloading.</span></p></li>
				<li><strong class="bold">Install make</strong>: Once the download<a id="_idIndexMarker449"/> is complete, follow the installation wizard to install <strong class="source-inline">make</strong> on your computer. When you reach the step titled <strong class="bold">Select Destination Location</strong>, make sure t<a id="_idTextAnchor183"/>he path is set to <strong class="source-inline">C:\Program </strong><span class="No-Break"><strong class="source-inline">Files (x86)\GnuWin32</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Set up the environment variable</strong>: To use <strong class="source-inline">make</strong> from any command line<a id="_idIndexMarker450"/> or script, we need to add its executable to our system environment variables, following the same process we used in <a href="B21914_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a> to add OpenOCD to the <span class="No-Break">environment variables.</span><p class="list-inset">We do this by navigating to the <strong class="source-inline">bin</strong> folder where <strong class="source-inline">make</strong> was installed (<strong class="source-inline">C:\Program Files (x86)\GnuWin32\bin</strong>) and then copying <span class="No-Break">the path.</span></p><p class="list-inset">Then, we do <span class="No-Break">the following:</span></p><ol><li class="upper-roman">Right-click on <strong class="bold">This PC</strong>, and then <span class="No-Break">choose </span><span class="No-Break"><strong class="bold">Properties</strong></span><span class="No-Break">.</span></li><li class="upper-roman">Search for and select <strong class="bold">Edit the system </strong><span class="No-Break"><strong class="bold">environment variables</strong></span><span class="No-Break">.</span></li><li class="upper-roman">Click the <strong class="bold">Environment Variables</strong> button in the <strong class="bold">System Properties</strong> <span class="No-Break">pop-up window.</span></li><li class="upper-roman">Under the <strong class="bold">User Variables</strong> section of the <strong class="bold">Environment Variables</strong> pop-up, double-click the <span class="No-Break"><strong class="bold">Path</strong></span><span class="No-Break"> entry.</span></li><li class="upper-roman">In the <strong class="bold">Edit environment variable</strong> popup, click on <strong class="bold">New</strong> to create a row for a new <span class="No-Break">path entry.</span></li><li class="upper-roman">Paste the previously copied <strong class="source-inline">make</strong> path into this <span class="No-Break">new row.</span></li><li class="upper-roman">Confirm your changes by clicking <strong class="bold">OK</strong> on the various <span class="No-Break">pop-up windows.</span></li></ol></li>
			</ol>
			<p>To confirm that the <strong class="source-inline">make</strong> is properly set up, open command prompt and simply type <strong class="source-inline">make</strong>, as <span class="No-Break">shown here:</span></p>
			<pre class="console">
make</pre>			<p>It should return <span class="No-Break">the following:</span></p>
			<pre class="console">
make: *** No targets specified and no makefile found.  Stop.</pre>			<p>This confirms that the <strong class="source-inline">make</strong> build system is properly configured on the <span class="No-Break">Windows machine.</span></p>
			<p>On many Linux distributions, <strong class="source-inline">make</strong> is readily available<a id="_idIndexMarker451"/> through the distribution’s package manager. For instance, on Ubuntu and other Debian-based distributions, we can install make (along with other build essentials, such as the GCC compiler) by running <span class="No-Break">the following:</span></p>
			<pre class="console">
 sudo apt install build-essential</pre>			<p>On macOS, <strong class="source-inline">make</strong> is part of the Command Line Tools package that comes with Xcode, Apple’s suite of development tools. This means that if you have installed Xcode, you will have <strong class="source-inline">make</strong> already installed. We can also install the standalone Command Line Tools package by running the following<a id="_idIndexMarker452"/> command in <span class="No-Break">the terminal:</span></p>
			<pre class="console">
xcode-select –-install</pre>			<p>In this section, we successfully set up the <strong class="source-inline">make</strong> build system on our development machine. In the following section, we will apply the concepts covered in this chapter to write our <span class="No-Break">own Makefile.</span></p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor184"/>Writing Makefiles for firmware projects</h1>
			<p>The focus of this section<a id="_idIndexMarker453"/> is to write a Makefile<a id="_idIndexMarker454"/> and successfully test it. <span class="No-Break">Let’s begin.</span></p>
			<p>In our workspace folder, let’s make a new folder named <strong class="source-inline">4_Makefiles</strong>. In this folder, create a file called <strong class="source-inline">Makefile</strong>. This file must start with a capital <strong class="bold">M</strong> and should have <span class="No-Break"><strong class="bold">no extension</strong></span><span class="No-Break">.</span></p>
			<p>If you’re using Windows and it asks whether you really want to change the file extension, click <strong class="bold">Yes</strong>. Then, right-click the file and open it with a basic text editor, such <span class="No-Break">as Notepad++.</span></p>
			<p>Our objectives with the Makefile <a id="_idIndexMarker455"/>can be summarized <span class="No-Break">as follows:</span></p>
			<ol>
				<li><strong class="bold">The compilation of source code</strong>: We want to compile source files (<strong class="source-inline">main.c</strong> and <strong class="source-inline">stm32f411_startup.c</strong>) into object files (<strong class="source-inline">main.o</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">stm32f411_startup.o</strong></span><span class="No-Break">).</span></li>
				<li><strong class="bold">Linking object files into an executable</strong>: Then, link the compiled object files, along with setting a specific memory layout using the linker script, (<strong class="source-inline">stm32_ls.ld</strong>) to create a final <span class="No-Break">executable (</span><span class="No-Break"><strong class="source-inline">4_makefile_project.elf</strong></span><span class="No-Break">).</span></li>
				<li><strong class="bold">Loading </strong><span class="No-Break"><strong class="bold">and cleaning</strong></span><span class="No-Break">:</span><ol><li class="upper-roman">Invoke OpenOCD to start the process of uploading the final executable onto the <span class="No-Break">target hardware</span></li><li class="upper-roman">Conclude by providing a way to clean the build environment by removing all generated files (<strong class="source-inline">*.o</strong>, <strong class="source-inline">*.elf.</strong>, and <strong class="source-inline">*.map</strong>), allowing for a fresh start with no leftover artifacts<a id="_idIndexMarker456"/> from <span class="No-Break">previous builds</span></li></ol></li>
			</ol>
			<p>This is our<a id="_idIndexMarker457"/> <span class="No-Break">complete</span><span class="No-Break"><a id="_idIndexMarker458"/></span><span class="No-Break"> Makefile:</span></p>
			<pre class="source-code">
final : 4_makefile_project.elf
main.o : main.c
    arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 main.c -o 
    main.o
stm32f411_startup.o : stm32f411_startup.c
    arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 stm32f411_
    startup.c -o stm32f411_startup.o
4_makefile_project.elf : main.o stm32f411_startup.o
    arm-none-eabi-gcc -nostdlib -T stm32_ls.ld *.o -o 4_makefile_
    project.elf -Wl,-Map=4_makefile_project.map
load :
    openocd -f board/st_nucleo_f4.cfg
clean:
del    -f *.o *.elf *.map</pre>			<p>Let’s break <span class="No-Break">it down:</span></p>
			<ol>
				<li><strong class="bold">Create the final target</strong>: <strong class="source-inline">final : </strong><span class="No-Break"><strong class="source-inline">4_makefile_project.elf</strong></span><p class="list-inset">This line deals<a id="_idIndexMarker459"/> with the creation of the <span class="No-Break">final</span><span class="No-Break"><a id="_idIndexMarker460"/></span><span class="No-Break"> target.</span></p><p class="list-inset">When we execute <strong class="source-inline">make final</strong>,<a id="_idTextAnchor185"/> <strong class="source-inline">make</strong> will check whether the <strong class="source-inline">4_makefile_project.elf</strong> target needs to be updated before executing it. This is a dependency relationship where <strong class="source-inline">final</strong> acts purely as an aggregation point to invoke all the build processes leading up <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">4_makefile_project.elf</strong></span><span class="No-Break">.</span></p></li>
				<li><strong class="bold">Create an object file </strong><span class="No-Break"><strong class="bold">for main.c</strong></span><span class="No-Break">:</span><p class="list-inset"><strong class="source-inline">main.o : </strong><span class="No-Break"><strong class="source-inline">main.c</strong></span></p><p class="list-inset"><strong class="source-inline">arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 main.c -</strong><span class="No-Break"><strong class="source-inline">o main.o</strong></span></p><p class="list-inset">The <strong class="source-inline">make</strong> rule compiles the <strong class="source-inline">main.c</strong> source file into an object file named <strong class="source-inline">main.o.</strong> Upon close inspection, you can see that the command employed here is identical to the one we used at the command prompt to manually compile <strong class="source-inline">main.c</strong> in the <span class="No-Break">previous chapter.</span></p></li>
				<li><strong class="bold">Create an object file </strong><span class="No-Break"><strong class="bold">for stm32f411_startup.c</strong></span><span class="No-Break">:</span><p class="list-inset"><strong class="source-inline">stm32f411_startup.o : </strong><span class="No-Break"><strong class="source-inline">stm32f411_startup.c</strong></span></p><p class="list-inset"><strong class="source-inline">arm-none-eabi-gcc -c -mcpu=cortex-m4 -mthumb -std=gnu11 stm32f411_startup.c -</strong><span class="No-Break"><strong class="source-inline">o stm32f411_startup.o</strong></span></p><p class="list-inset">This compiles the <strong class="source-inline">stm32f411_startup.c</strong> source file into an object file, <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">stm32f411_startup.o</strong></span><span class="No-Break">.</span></p></li>
				<li><strong class="bold">Link to create the </strong><span class="No-Break"><strong class="bold">final executable</strong></span><span class="No-Break">:</span><p class="list-inset"><strong class="source-inline">4_makefile_project.elf : </strong><span class="No-Break"><strong class="source-inline">main.o stm32f411_startup.o</strong></span></p><p class="list-inset"><strong class="source-inline">arm-none-eabi-gcc -no<a id="_idTextAnchor186"/>stdlib -T stm32_ls.ld *.o -o </strong><span class="No-Break"><strong class="source-inline">4_makefile_project.elf -Wl,-Map=4_makefile_project.map</strong></span></p><p class="list-inset">This rule links<a id="_idIndexMarker461"/> the <strong class="source-inline">main.o</strong> and <strong class="source-inline">stm32f411_startup.o</strong> object files<a id="_idIndexMarker462"/> to produce the final executable, <strong class="source-inline">4_makefile_project.elf</strong>. Additionally, it generates a map file named <strong class="source-inline">4_makefile_project.map</strong> that shows where each part of the code and data is loaded in memory, which is useful <span class="No-Break">for debugging.</span></p></li>
				<li><strong class="bold">Load </strong><span class="No-Break"><strong class="bold">the target</strong></span><span class="No-Break">:</span><p class="list-inset"><span class="No-Break"><strong class="source-inline">load:</strong></span></p><p class="list-inset"><strong class="source-inline">openocd -</strong><span class="No-Break"><strong class="source-inline">f board/st_nucleo_f4.cfg</strong></span></p><p class="list-inset">This rule initiates OpenOCD to begin the process of loading the final executable onto the target hardware. It executes OpenOCD, using a configuration file tailored for the STM32 Nucleo F4 board, <span class="No-Break">specifically </span><span class="No-Break"><strong class="source-inline">st_nucleo_f4.cfg</strong></span><span class="No-Break">.</span></p></li>
				<li><strong class="bold">Clean </strong><span class="No-Break"><strong class="bold">the target</strong></span><span class="No-Break">:</span><p class="list-inset"><span class="No-Break"><strong class="source-inline">clean:</strong></span></p><p class="list-inset"><strong class="source-inline">del</strong> <strong class="source-inline">-f *.o *.</strong><span class="No-Break"><strong class="source-inline">elf *.map</strong></span></p><p class="list-inset">This command cleans the build directory by removing all generated files, ensuring a clean environment for subsequent builds. The <strong class="source-inline">del -f</strong> command forcefully deletes files, preventing prompts that ask for deletion confirmation. The <strong class="source-inline">*.o</strong>, <strong class="source-inline">*.elf</strong>, and <strong class="source-inline">*.map</strong> patterns specify that all object files, ELF executables, and map<a id="_idIndexMarker463"/> files, respectively, should<a id="_idIndexMarker464"/> <span class="No-Break">be deleted.</span></p></li>
			</ol>
			<p>With the Makefile ready, it is time to test <span class="No-Break">it out.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor187"/>Testing our Makefile</h2>
			<p>Before proceeding<a id="_idIndexMarker465"/> to the command line, let’s ensure that the linker script, startup file, and all source files are placed in the correct directory. Additionally, we will slightly update the <strong class="source-inline">main.c</strong> file, which will allow us to validate that the most recent version of the firmware <span class="No-Break">executes correctly:</span></p>
			<ol>
				<li><strong class="bold">Transfer the </strong><span class="No-Break"><strong class="bold">required files</strong></span><span class="No-Break">:</span><ol><li class="upper-roman">Locate the <strong class="source-inline">main.c</strong> file from the previous project (<strong class="source-inline">3_LinkerscriptAndStartup</strong>), which includes the foundational <span class="No-Break">application code.</span></li><li class="upper-roman">Additionally, locate <strong class="source-inline">stm32_ls.ld</strong> (the linker script) and <strong class="source-inline">stm32f411_startup.c</strong> (the <span class="No-Break">startup file).</span></li><li class="upper-roman">Copy and paste these files (<strong class="source-inline">stm32_ls.ld</strong>, <strong class="source-inline">stm32f411_startup.c</strong>, and <strong class="source-inline">main.c</strong>) into the <span class="No-Break"><strong class="source-inline">4_Makefiles</strong></span><span class="No-Break"> folder.</span></li></ol></li>
				<li><strong class="bold">Modify the main application code</strong>: To visually confirm the successful execution of our latest firmware, let’s adjust the LED blink rate within the <strong class="source-inline">main.c</strong> file from slow <span class="No-Break">to fast:</span><ol><li class="upper-roman"><strong class="bold">Open the main.c file for editing</strong>: Right-click on the <strong class="source-inline">main.c</strong> file within the <strong class="source-inline">4_ Makefiles</strong> folder and select the option to open it with a simple text editor, such <span class="No-Break">as Notepad++.</span></li><li class="upper-roman"><strong class="bold">Change the blink rate</strong>: Search for the code segment that controls the toggling of PA5 (<strong class="source-inline">LED_PIN</strong>). Adjust the delay intervals within this section to change the LED’s blink rate from its current slower pace to a rapid one. The curre<a id="_idTextAnchor188"/>nt one should look <span class="No-Break">like this:</span></li></ol><pre class="source-code">
        //  22: Toggle PA5(LED_PIN)
        GPIOA_OD_R ^= LED_PIN;
    for(int i = 0; i &lt; 5000000; i++){}</pre><p class="list-inset">Replace the current code<a id="_idIndexMarker466"/> with the following snippet to toggle the state of PA5 to a <span class="No-Break">faster rate:</span></p><pre class="source-code">        //  22: Toggle PA5(LED_PIN)
        GPIOA_OD_R ^= LED_PIN;
for(int i = 0; i &lt; <strong class="bold">100000</strong>; i++){}</pre><p class="list-inset">We simply change the loop iteration from 5 million <span class="No-Break">to 100,000.</span></p><ol><li class="upper-roman" value="3"><strong class="bold">Save the changes</strong>: After updating the code, save the <span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break"> file.</span></li></ol></li>			</ol>
			<p>Now, let’s access our new folder through the command prompt, following the steps we used in the <span class="No-Break">previous chapter.</span></p>
			<p>In the command prompt, simply execute <span class="No-Break">the following:</span></p>
			<pre class="console">
make final</pre>			<p>This will create our final <span class="No-Break">executable, </span><span class="No-Break"><strong class="source-inline">4_makefile_project.elf</strong></span><span class="No-Break">.</span></p>
			<p>Next, we will begin uploading the final executable onto our microcontroller by executing <span class="No-Break">the following:</span></p>
			<pre class="console">
make load</pre>			<p>This will launch OpenOCD. The next <a id="_idIndexMarker467"/>step involves using the <strong class="bold">GNU Debugger</strong> (<strong class="bold">GDB</strong>) to upload the firmware to the microcontroller, as we did in the previous chapter. Let’s access another command prompt window (as OpenOCD should keep running in the first one) and enter the following command to start <span class="No-Break">the GDB:</span></p>
			<pre class="console">
arm-none-eabi-gdb</pre>			<p>Once GDB is open, we establish a connection to our microcontroller by running <span class="No-Break">the following:</span></p>
			<pre class="console">
target remote localhost:3333</pre>			<p>Let’s reset and initialize the board, as we learned in <a href="B21914_03.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, using the <span class="No-Break">following command:</span></p>
			<pre class="console">
monitor reset init</pre>			<p>Next, we load the firmware onto the microcontroller using the <span class="No-Break">following command:</span></p>
			<pre class="console">
monitor flash write_image erase 4_makefile_project.elf</pre>			<p>After successfully loading the firmware, we reset the board again with the same <span class="No-Break">reset command:</span></p>
			<pre class="console">
monitor reset init</pre>			<p>Finally, we resume the execution of the firmware on the <a id="_idTextAnchor189"/>microcontroller with <span class="No-Break">the following:</span></p>
			<pre class="console">
monitor resume</pre>			<p>You should see the LED blinking <a id="_idIndexMarker468"/>at a rapid rate, indicating the successful upload and execution of our <span class="No-Break">new firmware.</span></p>
			<p>We can stop the GDB by executing <span class="No-Break">the following:</span></p>
			<pre class="console">
quit</pre>			<p>And then, we execute the following when asked if we want to <span class="No-Break">quit anyway:</span></p>
			<pre class="console">
y</pre>			<p>To clean our build directory, we will open the command prompt in the build directory and execute the <span class="No-Break">following command:</span></p>
			<pre class="console">
make clean</pre>			<p>This will delete all the <strong class="source-inline">.o</strong>, <strong class="source-inline">.elf</strong>, and <strong class="source-inline">.map</strong> files in the <span class="No-Break">build directory.</span></p>
			<p>Before concluding this chapter, let’s explore how our Makefile appears when we incorporate special and <span class="No-Break">user-defined variables.</span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor190"/>Applying special and user-defined variables</h2>
			<p>Let’s apply special variables<a id="_idIndexMarker469"/> and user-defined<a id="_idIndexMarker470"/> variables to <span class="No-Break">our makefile:</span></p>
			<pre class="source-code">
CC = arm-none-eabi-gcc
CFLAGS = -c -mcpu=cortex-m4 -mthumb -std=gnu11
LDFLAGS = -nostdlib -T stm32_ls.ld -Wl,-Map= 5_makefile_project_v2.map
final : 5_makefile_project_v2.elf
main.o : main.c
    $(CC) $(CFLAGS) $^ -o $@
stm32f411_startup.o : stm32f411_startup.c
    $(CC) $(CFLAGS) $^ -o $@
5_makefile_project_v2.elf : main.o stm32f411_startup.o
    $(CC) $(LDFLAGS) $^ -o $@
load :
    openocd -f board/st_nucleo_f4.cfg
clean:
    del    -f *.o *.elf *.map</pre>			<p>In this version, we’ve defined three essential variables to streamline <span class="No-Break">our Makefile:</span></p>
			<ul>
				<li><strong class="source-inline">CC</strong>: This variable represents<a id="_idIndexMarker471"/> the compiler used to compile the source files. It simplifies the Makefile by centralizing the compiler definition, making it easier to update or change <span class="No-Break">if needed.</span></li>
				<li><strong class="source-inline">CFLAGS</strong>: This holds the compilation<a id="_idIndexMarker472"/> flags necessary to build the <span class="No-Break">source files.</span></li>
				<li><strong class="source-inline">LDFLAGS</strong>: This contains<a id="_idIndexMarker473"/> the linker flags that dictate how an executable is linked from the <span class="No-Break">object files.</span></li>
			</ul>
			<p>Additionally, we’ve used special variables for target names (<strong class="source-inline">$@</strong>) and prerequisite lists (<strong class="source-inline">$^</strong>) to replace explicit mentions<a id="_idIndexMarker474"/> of these components in the <strong class="source-inline">make</strong> recipes, further simplifying<a id="_idIndexMarker475"/> the <span class="No-Break">Makefile structure.</span></p>
			<p>Update your current makefile to this new version and upload the new executable, named <strong class="source-inline">5_makefile_project_v2.elf</strong>, onto your microcontroller. This updated version should function seamlessly, just like the <span class="No-Break">previous one.</span></p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor191"/>Summary</h1>
			<p>In this chapter, we embarked on an exploration of the <strong class="source-inline">make</strong> build system, a cornerstone tool for automating the build process in software development. The journey began with an introduction to what build systems are and their critical role in converting source code into deployable software, such as executables <span class="No-Break">and libraries.</span></p>
			<p>We then delved into the specific mechanics of the <strong class="source-inline">make</strong> build system, starting with the foundational elements of a Makefile, which include <em class="italic">targets</em>, <em class="italic">prerequisites</em>, and <em class="italic">recipes</em>. These components were thoroughly discussed to provide a clear understanding of how they interact within <strong class="source-inline">make</strong> to manage and streamline the compilation and linking of <span class="No-Break">software projects.</span></p>
			<p>This chapter wrapped up with a practical demonstration of writing Makefiles, effectively consolidating the theoretical concepts discussed throughout. This hands-on experience ensures that you are well-equipped to apply these strategies to your own <span class="No-Break">firmware projects.</span></p>
			<p>In the next chapter, we will transition to another critical aspect of firmware development – the development of peripheral drivers, beginning with <strong class="bold">General Purpose Input/Output</strong> (<strong class="bold">GPI/O</strong>) drivers. This shift will introduce you to the fundamentals of interfacing with hardware components, a pivotal skill in embedded <span class="No-Break">systems development.</span></p>
		</div>
	</div>
</div>
</body></html>