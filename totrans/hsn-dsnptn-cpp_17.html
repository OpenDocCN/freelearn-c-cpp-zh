<html><head></head><body>
<div id="_idContainer036">
<h1 class="chapter-number" id="_idParaDest-301"><a id="_idTextAnchor783"/><span class="koboSpan" id="kobo.1.1">17</span></h1>
<h1 id="_idParaDest-302"><a id="_idTextAnchor784"/><span class="koboSpan" id="kobo.2.1">The Visitor Pattern and Multiple Dispatch</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The Visitor pattern is another classic object-oriented design pattern, one of the 23 patterns introduced in the book </span><em class="italic"><span class="koboSpan" id="kobo.4.1">Design Patterns – Elements of Reusable Object-Oriented Software</span></em><span class="koboSpan" id="kobo.5.1">, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </span><span class="koboSpan" id="kobo.5.2">It was one of the more popular patterns during the golden age of object-oriented programming since it can be used to make large class hierarchies more maintainable. </span><span class="koboSpan" id="kobo.5.3">In recent years, the use of Visitor in C++ declined, as large complex hierarchies became less common, and the Visitor pattern is a fairly complex pattern to implement. </span><span class="koboSpan" id="kobo.5.4">Generic programming - in particular, the language features added in C++11 and C++14 - makes it easier to implement and maintain the Visitor classes, while the new applications of the old pattern have served to rekindle some of the fading interest </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">in it.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Visitor pattern</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Implementations of Visitor </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">in C++</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">The use of generic programming to simplify the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Visitor classes</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">The use of Visitor for </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">composite objects</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Compile-time Visitor </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">and reflection</span></span></li>
</ul>
<p><a id="_idTextAnchor785"/><a id="_idTextAnchor786"/><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Technical requirements</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">The example code for this chapter can be found at the following GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">link: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter17"><span class="No-Break"><span class="koboSpan" id="kobo.22.1">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter17</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.23.1">.</span></span></p>
<h1 id="_idParaDest-303"><a id="_idTextAnchor787"/><a id="_idTextAnchor788"/><span class="koboSpan" id="kobo.24.1">The Visitor pattern</span></h1>
<p><span class="koboSpan" id="kobo.25.1">The Visitor pattern </span><a id="_idIndexMarker990"/><span class="koboSpan" id="kobo.26.1">stands out from the other classic object-oriented patterns due to its complexity. </span><span class="koboSpan" id="kobo.26.2">On the one hand, the basic structure of the Visitor pattern is quite complex and involves many coordinated classes that must work together to form the pattern. </span><span class="koboSpan" id="kobo.26.3">On the other hand, even the description of the Visitor pattern is complex - there are several very different ways to describe the same pattern. </span><span class="koboSpan" id="kobo.26.4">Many patterns can be applied to multiple kinds of problems, but the Visitor pattern goes beyond that - there are several ways to describe what it does that use completely different languages, talk about seemingly unrelated problems, and overall have nothing in common. </span><span class="koboSpan" id="kobo.26.5">However, they all describe the same pattern. </span><span class="koboSpan" id="kobo.26.6">Let’s start by examining the many faces of the Visitor pattern, and then move on to </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">the implementation</span><a id="_idTextAnchor789"/><span class="koboSpan" id="kobo.28.1">.</span></span><a id="_idTextAnchor790"/></p>
<h2 id="_idParaDest-304"><a id="_idTextAnchor791"/><span class="koboSpan" id="kobo.29.1">What is the Visitor pattern?</span></h2>
<p><span class="koboSpan" id="kobo.30.1">The Visitor pattern is a pattern that separates the algorithm from the object structure, which is the data for this algorithm. </span><span class="koboSpan" id="kobo.30.2">Using the Visitor pattern, we can add a new operation to the class hierarchy without modifying the classes themselves. </span><span class="koboSpan" id="kobo.30.3">The use of the Visitor pattern</span><a id="_idIndexMarker991"/><span class="koboSpan" id="kobo.31.1"> follows the </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">open/closed principle</span></strong><span class="koboSpan" id="kobo.33.1"> of software design - a class (or another unit of code, such as a module) should be closed for modifications; once the class presents an interface to its clients, the clients come to depend on this interface and the functionality it provides. </span><span class="koboSpan" id="kobo.33.2">This interface should remain stable; it should not be necessary to modify the classes in order to maintain the software and continue its development. </span><span class="koboSpan" id="kobo.33.3">At the same time, a class should be open for extensions - new functionality can be added to satisfy new requirements. </span><span class="koboSpan" id="kobo.33.4">As with all very general principles, a counter-example can be found where the rigorous application of a rule is worse than breaking it. </span><span class="koboSpan" id="kobo.33.5">Again, as with all general principles, its value lies not in being an absolute rule for every case, but rather a </span><em class="italic"><span class="koboSpan" id="kobo.34.1">default</span></em><span class="koboSpan" id="kobo.35.1"> rule, a guideline that should be followed in the absence of a good reason not to; the reality is that the majority of everyday work is </span><em class="italic"><span class="koboSpan" id="kobo.36.1">not special</span></em><span class="koboSpan" id="kobo.37.1"> and the result is better if this principle </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">is followed.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">When viewed this way, the Visitor pattern allows us to add functionality to a class or an entire class hierarchy without having to modify the class. </span><span class="koboSpan" id="kobo.39.2">This feature can be particularly useful when dealing with public APIs - the users of the API can extend it with additional operations without having to modify the </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">source code.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">A very different, more technical way to describe the Visitor pattern is to say that it implements </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">double dispatch</span></strong><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">This </span><a id="_idIndexMarker992"/><span class="koboSpan" id="kobo.44.1">requires some explanation. </span><span class="koboSpan" id="kobo.44.2">Let’s start with the regular virtual </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">function calls:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.46.1">
class Base {
  virtual void f() = 0;
};
class Derived1 : public Base {
  void f() override;
};
class Derived2 : public Base {
  void f() override;
};</span></pre>
<p><span class="koboSpan" id="kobo.47.1">If we invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">b-&gt;f()</span></strong><span class="koboSpan" id="kobo.49.1"> virtual function through a pointer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">b</span></strong><span class="koboSpan" id="kobo.51.1"> base class, the call is dispatched to </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">Derived1::f()</span></strong><span class="koboSpan" id="kobo.53.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">Derived2::f()</span></strong><span class="koboSpan" id="kobo.55.1">, depending on the real type of the object. </span><span class="koboSpan" id="kobo.55.2">This is the </span><strong class="bold"><span class="koboSpan" id="kobo.56.1">single dispatch</span></strong><span class="koboSpan" id="kobo.57.1"> - the </span><a id="_idIndexMarker993"/><span class="koboSpan" id="kobo.58.1">function that is actually called is determined by a single factor, the type of </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">the object.</span></span></p>
<p><a id="_idIndexMarker994"/><span class="koboSpan" id="kobo.60.1">Now let's assume that the function </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">f()</span></strong><span class="koboSpan" id="kobo.62.1"> also takes an argument that is a pointer to a </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">base class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.64.1">
class Base {
  virtual void f(Base* p) = 0;
};
class Derived1 : public Base {
  void f(Base* p) override;
};
class Derived2 : public Base {
  void f(Base* p) override;
};</span></pre>
<p><span class="koboSpan" id="kobo.65.1">The actual type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">*p</span></strong><span class="koboSpan" id="kobo.67.1"> object is also one of the derived classes. </span><span class="koboSpan" id="kobo.67.2">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">b-&gt;f(p)</span></strong><span class="koboSpan" id="kobo.69.1"> call can have four different versions; both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">*b</span></strong><span class="koboSpan" id="kobo.71.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">*p</span></strong><span class="koboSpan" id="kobo.73.1"> objects can be of either of the two derived types. </span><span class="koboSpan" id="kobo.73.2">It is reasonable to want the implementation to do something different in each of these cases. </span><span class="koboSpan" id="kobo.73.3">This would be double dispatch - the code that ultimately runs is determined by two separate factors. </span><span class="koboSpan" id="kobo.73.4">Virtual functions do not provide a way to implement double dispatch directly, but the Visitor pattern does </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">exactly that.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">When presented this way, it is not obvious that the </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">double-dispatch</span></strong><span class="koboSpan" id="kobo.77.1"> Visitor pattern has anything to do with the </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">operation-adding</span></strong><span class="koboSpan" id="kobo.79.1"> Visitor pattern. </span><span class="koboSpan" id="kobo.79.2">However, they are exactly the same pattern, and the two requirements are really one and the same. </span><span class="koboSpan" id="kobo.79.3">Here is a way to look at it that might help - if we want to add an operation to all classes in a hierarchy, that is equivalent to adding a virtual function, so we have one factor controlling the final disposition of each call, the object type. </span><span class="koboSpan" id="kobo.79.4">But, if we can effectively add virtual functions, we can add more than one - one for each operation we need to support. </span><span class="koboSpan" id="kobo.79.5">The type of operation is the second factor controlling the dispatch, similar to the argument to the function in our previous example. </span><span class="koboSpan" id="kobo.79.6">Thus, the operation-adding visitor is able to provide double dispatch. </span><span class="koboSpan" id="kobo.79.7">Alternatively, if we had a way to implement double dispatch, we could do what </span><a id="_idIndexMarker995"/><span class="koboSpan" id="kobo.80.1">the Visitor pattern does - effectively add a virtual function for each operation we want </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">to support.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">Now that we know what the Visitor pattern does, it is reasonable to ask, </span><em class="italic"><span class="koboSpan" id="kobo.83.1">why</span></em><span class="koboSpan" id="kobo.84.1"> would we want to do it? </span><em class="italic"><span class="koboSpan" id="kobo.85.1">What</span></em><span class="koboSpan" id="kobo.86.1"> is the use of double dispatch? </span><span class="koboSpan" id="kobo.86.2">And why would we want </span><em class="italic"><span class="koboSpan" id="kobo.87.1">another way</span></em><span class="koboSpan" id="kobo.88.1"> to add a virtual function substitute to a class when we can just add a </span><em class="italic"><span class="koboSpan" id="kobo.89.1">genuine</span></em><span class="koboSpan" id="kobo.90.1"> virtual function? </span><span class="koboSpan" id="kobo.90.2">Setting aside the case of the public API with unavailable source code, why would we want to add an operation </span><em class="italic"><span class="koboSpan" id="kobo.91.1">externally</span></em><span class="koboSpan" id="kobo.92.1"> instead of implementing it in every class? </span><span class="koboSpan" id="kobo.92.2">Consider the example of the serialization/deserialization problem. </span><span class="koboSpan" id="kobo.92.3">Serialization is an operation that converts an object into a format that can be stored or transmitted (for example, written into a file). </span><span class="koboSpan" id="kobo.92.4">Deserialization is the inverse operation - it constructs a new object from its serialized and stored image. </span><span class="koboSpan" id="kobo.92.5">To support serialization and deserialization in a straightforward, object-oriented way, each class in the hierarchy would need two methods, one for each operation. </span><span class="koboSpan" id="kobo.92.6">But what if there is more than one way to store an object? </span><span class="koboSpan" id="kobo.92.7">For example, we may need to write an object into a memory buffer, to be transmitted across the network and deserialized on another machine. </span><span class="koboSpan" id="kobo.92.8">Alternatively, we may need to save the object to disk, or else we may need to convert all objects in a container to a markup format such as JSON. </span><span class="koboSpan" id="kobo.92.9">The straightforward approach would have us add a serialization and a deserialization method to every object for every serialization mechanism. </span><span class="koboSpan" id="kobo.92.10">If a new and different serialization approach is needed, we have to go over the entire class hierarchy and add support </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">for it.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">An alternative is to implement the entire serialization/deserialization operation in a separate function that can handle all classes. </span><span class="koboSpan" id="kobo.94.2">The resulting code is a loop that iterates over all objects, with a large decision tree inside of it. </span><span class="koboSpan" id="kobo.94.3">The code must interrogate every object and determine its type, for example, using dynamic casts. </span><span class="koboSpan" id="kobo.94.4">When a new class is added to the hierarchy, all serialization and deserialization implementations must be updated to handle the </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">new objects.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">Both implementations are difficult to maintain for large hierarchies. </span><span class="koboSpan" id="kobo.96.2">The Visitor pattern offers a solution - it allows us to implement a new operation - in our case, the serialization - outside of the classes and without modifying them, but also without the downside of a huge decision tree in a loop  (note that the Visitor pattern is not the only solution to the serialization problem; C++ offers other possible approaches as well, but we focus on the Visitor pattern in this chapter). </span></p>
<p><span class="koboSpan" id="kobo.97.1">As we stated at the </span><a id="_idIndexMarker996"/><span class="koboSpan" id="kobo.98.1">beginning, the Visitor pattern is a complex pattern with a complex description. </span><span class="koboSpan" id="kobo.98.2">We can best handle this difficult pattern by studying concrete examples, starting from the very simple ones in the </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">next s</span><a id="_idTextAnchor792"/><span class="koboSpan" id="kobo.100.1">e</span><a id="_idTextAnchor793"/><span class="koboSpan" id="kobo.101.1">ction.</span></span></p>
<h2 id="_idParaDest-305"><a id="_idTextAnchor794"/><span class="koboSpan" id="kobo.102.1">Basic Visitor in C++</span></h2>
<p><span class="koboSpan" id="kobo.103.1">The only way to</span><a id="_idIndexMarker997"/><span class="koboSpan" id="kobo.104.1"> really understand how the Visitor pattern operates is to</span><a id="_idIndexMarker998"/><span class="koboSpan" id="kobo.105.1"> work through an example. </span><span class="koboSpan" id="kobo.105.2">Let’s start with a very simple one. </span><span class="koboSpan" id="kobo.105.3">First, we need a </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">class hierarchy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.107.1">
// Example 01
class Pet {
  public:
  virtual ~Pet() {}
  Pet(std::string_view color) : color_(color) {}
  const std::string&amp; color() const { return color_; }
  private:
  const std::string color_;
};
class Cat : public Pet {
  public:
  Cat(std::string_view color) : Pet(color) {}
};
class Dog : public Pet {
  public:
  Dog(std::string_view color) : Pet(color) {}
};</span></pre>
<p><span class="koboSpan" id="kobo.108.1">In this hierarchy, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">Pet</span></strong><span class="koboSpan" id="kobo.110.1"> base class and several derived classes for different pet animals. </span><span class="koboSpan" id="kobo.110.2">Now we want to add some operations to our classes, such as “feed the pet” or “play with the pet.” </span><span class="koboSpan" id="kobo.110.3">The implementation depends on the type of pet, so these would have to be virtual functions if added directly to each class. </span><span class="koboSpan" id="kobo.110.4">This is not a problem for such a simple class hierarchy, but we are anticipating the future need for maintaining a much larger system in which modifying every class in the hierarchy is going to be expensive and time-consuming. </span><span class="koboSpan" id="kobo.110.5">We need a better way, and we begin by creating a new class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">PetVisitor</span></strong><span class="koboSpan" id="kobo.112.1">, which will be applied to every </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">Pet</span></strong><span class="koboSpan" id="kobo.114.1"> object (visit it) and perform the operations we need. </span><span class="koboSpan" id="kobo.114.2">First, we </span><a id="_idIndexMarker999"/><span class="koboSpan" id="kobo.115.1">need </span><a id="_idIndexMarker1000"/><span class="koboSpan" id="kobo.116.1">to declare </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">the class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.118.1">
// Example 01
class Cat;
class Dog;
class PetVisitor {
  public:
  virtual void visit(Cat* c) = 0;
  virtual void visit(Dog* d) = 0;
};</span></pre>
<p><span class="koboSpan" id="kobo.119.1">We had to forward-declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">Pet</span></strong><span class="koboSpan" id="kobo.121.1"> hierarchy classes because </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">PetVisitor</span></strong><span class="koboSpan" id="kobo.123.1"> has to be declared before the concrete </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">Pet</span></strong><span class="koboSpan" id="kobo.125.1"> classes. </span><span class="koboSpan" id="kobo.125.2">Now we need to make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">Pet</span></strong><span class="koboSpan" id="kobo.127.1"> hierarchy visitable, which means we do need to modify it, but only once, regardless of how many operations we want to add later. </span><span class="koboSpan" id="kobo.127.2">We need to add a virtual function to accept the Visitor pattern to every class that can </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">be visited:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.129.1">
// Example 01
class Pet {
  public:
  virtual void accept(PetVisitor&amp; v) = 0;
  ...
</span><span class="koboSpan" id="kobo.129.2">};
class Cat : public Pet {
  public:
  void accept(PetVisitor&amp; v) override { v.visit(this); }
  ...
</span><span class="koboSpan" id="kobo.129.3">};
class Dog : public Pet {
  public:
  void accept(PetVisitor&amp; v) override { v.visit(this); }
  ...
</span><span class="koboSpan" id="kobo.129.4">};</span></pre>
<p><span class="koboSpan" id="kobo.130.1">Now our </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">Pet</span></strong><span class="koboSpan" id="kobo.132.1"> hierarchy is visitable, and we have an abstract </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">PetVisitor</span></strong><span class="koboSpan" id="kobo.134.1"> class. </span><span class="koboSpan" id="kobo.134.2">Everything is </span><a id="_idIndexMarker1001"/><span class="koboSpan" id="kobo.135.1">ready to</span><a id="_idIndexMarker1002"/><span class="koboSpan" id="kobo.136.1"> implement new operations for our classes (note that nothing we have done so far depends on what operations we are going to add; we have created the visiting infrastructure that has to be implemented once). </span><span class="koboSpan" id="kobo.136.2">The operations are added by implementing concrete Visitor classes derived </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">PetVisitor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.140.1">
// Example 01
class FeedingVisitor : public PetVisitor {
  public:
  void visit(Cat* c) override {
    std::cout &lt;&lt; "Feed tuna to the " &lt;&lt; c-&gt;color()
              &lt;&lt; " cat" &lt;&lt; std::endl;
  }
  void visit(Dog* d) override {
    std::cout &lt;&lt; "Feed steak to the " &lt;&lt; d-&gt;color()
              &lt;&lt; " dog" &lt;&lt; std::endl;
  }
};
class PlayingVisitor : public PetVisitor {
  public:
  void visit(Cat* c) override {
    std::cout &lt;&lt; "Play with a feather with the "
              &lt;&lt; c-&gt;color() &lt;&lt; " cat" &lt;&lt; std::endl;
  }
  void visit(Dog* d) override {
    std::cout &lt;&lt; "Play fetch with the " &lt;&lt; d-&gt;color()
              &lt;&lt; " dog" &lt;&lt; std::endl;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.141.1">Assuming the</span><a id="_idIndexMarker1003"/><span class="koboSpan" id="kobo.142.1"> visitation </span><a id="_idIndexMarker1004"/><span class="koboSpan" id="kobo.143.1">infrastructure is already built into our class hierarchy, we can implement a new operation by implementing a derived Visitor class, and all its virtual functions overrides for </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">visit()</span></strong><span class="koboSpan" id="kobo.145.1">. </span><span class="koboSpan" id="kobo.145.2">To invoke one of the new operations on an object from our class hierarchy, we need to create a visitor and visit </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">the object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.147.1">
// Example 01
Cat c("orange");
FeedingVisitor fv;
c.accept(fv); // Feed tuna to the orange cat</span></pre>
<p><span class="koboSpan" id="kobo.148.1">The latest example of the call is too simple in one important way - at the point of calling the visitor, we know the exact type of the object we are visiting. </span><span class="koboSpan" id="kobo.148.2">To make the example more realistic, we have to visit an </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">object polymorphically:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.150.1">
// Example 02
std::unique_ptr&lt;Pet&gt; p(new Cat("orange"));
...
</span><span class="koboSpan" id="kobo.150.2">FeedingVisitor fv;
p-&gt;accept(fv);</span></pre>
<p><span class="koboSpan" id="kobo.151.1">Here we do not know at compile time the actual type of the object pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">p</span></strong><span class="koboSpan" id="kobo.153.1">; at the point where the visitor is accepted, </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">p</span></strong><span class="koboSpan" id="kobo.155.1"> could have come from different sources. </span><span class="koboSpan" id="kobo.155.2">While less common, the visitor can also be </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">used polymorphically:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.157.1">
// Example 03
std::unique_ptr&lt;Pet&gt; p(new Cat("orange"));
std::unique_ptr&lt;PetVisitor&gt; v(new FeedingVisitor);
...
</span><span class="koboSpan" id="kobo.157.2">p-&gt;accept(*v);</span></pre>
<p><span class="koboSpan" id="kobo.158.1">When</span><a id="_idIndexMarker1005"/><span class="koboSpan" id="kobo.159.1"> written </span><a id="_idIndexMarker1006"/><span class="koboSpan" id="kobo.160.1">this way, the code highlights the double-dispatch aspect of the Visitor pattern - the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">accept()</span></strong><span class="koboSpan" id="kobo.162.1"> ends up dispatched to a particular </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">visit()</span></strong><span class="koboSpan" id="kobo.164.1"> function based on two factors - the type of the visitable </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">*p</span></strong><span class="koboSpan" id="kobo.166.1"> object and the type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">*v</span></strong><span class="koboSpan" id="kobo.168.1"> visitor. </span><span class="koboSpan" id="kobo.168.2">If we wish to stress this aspect of the Visitor pattern, we can invoke the visitors using a </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">helper function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.170.1">
// Example 03
void dispatch(Pet&amp; p, PetVisitor&amp; v) { p.accept(v); }
std::unique_ptr&lt;Pet&gt; p = ...;
std::unique_ptr&lt;PetVisitor&gt; v = ...;
dispatch(*p, *v); // Double dispatch</span></pre>
<p><span class="koboSpan" id="kobo.171.1">We now have the most bare-bones example of the classic object-oriented visitor in C++. </span><span class="koboSpan" id="kobo.171.2">Despite its simplicity, it has all the necessary components; an implementation for a large real-life class hierarchy and multiple visitor operations has a lot more code, but no new kinds of code, just more of the things we have already done. </span><span class="koboSpan" id="kobo.171.3">This example shows both aspects of the Visitor pattern; on the one hand, if we focus on the functionality of the software, with the visitation infrastructure now in place, we can add new operations without any changes to the classes themselves. </span><span class="koboSpan" id="kobo.171.4">On the other hand, if we look just at the way the operation is invoked, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">accept()</span></strong><span class="koboSpan" id="kobo.173.1"> call, we have implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">double dispatch.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">We can immediately see the appeal of the Visitor pattern, we can add any number of new operations without having to modify every class in the hierarchy. </span><span class="koboSpan" id="kobo.175.2">If a new class is added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">Pet</span></strong><span class="koboSpan" id="kobo.177.1"> hierarchy, it is impossible to forget to handle it - if we do nothing at all to the visitor, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">accept()</span></strong><span class="koboSpan" id="kobo.179.1"> call on the new class will not compile since there is no corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">visit()</span></strong><span class="koboSpan" id="kobo.181.1"> function to call. </span><span class="koboSpan" id="kobo.181.2">Once we add the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">visit()</span></strong><span class="koboSpan" id="kobo.183.1"> overload to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">PetVisitor</span></strong><span class="koboSpan" id="kobo.185.1"> base class, we have to add it to all derived classes as well; otherwise, the compiler will let us know that we have a pure virtual function without an override. </span><span class="koboSpan" id="kobo.185.2">The latter is also one of the main disadvantages of the Visitor pattern - if a new class is added to the hierarchy, all visitors must be updated, whether the new classes actually need to support these operations or not. </span><span class="koboSpan" id="kobo.185.3">For this reason, it is sometimes recommended to use the visitor only on </span><em class="italic"><span class="koboSpan" id="kobo.186.1">relatively stable</span></em><span class="koboSpan" id="kobo.187.1"> hierarchies that do not have new classes added often. </span><span class="koboSpan" id="kobo.187.2">There is also an alternative visitor implementation that somewhat mitigates this </span><a id="_idIndexMarker1007"/><span class="koboSpan" id="kobo.188.1">problem; we </span><a id="_idIndexMarker1008"/><span class="koboSpan" id="kobo.189.1">will see it later in </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">The example in this section is very simple - our new operations take no arguments and return no results. </span><span class="koboSpan" id="kobo.191.2">We will now consider whether these limitations are significant, and how t</span><a id="_idTextAnchor795"/><span class="koboSpan" id="kobo.192.1">h</span><a id="_idTextAnchor796"/><span class="koboSpan" id="kobo.193.1">ey can </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">be removed.</span></span></p>
<h2 id="_idParaDest-306"><a id="_idTextAnchor797"/><span class="koboSpan" id="kobo.195.1">Visitor generalizations and limitations</span></h2>
<p><span class="koboSpan" id="kobo.196.1">Our very first</span><a id="_idIndexMarker1009"/><span class="koboSpan" id="kobo.197.1"> visitor, in the previous section, allowed us to effectively add a virtual function to every class in the hierarchy. </span><span class="koboSpan" id="kobo.197.2">That virtual function had no parameters and no return value. </span><span class="koboSpan" id="kobo.197.3">The former is easy to extend; there is no reason at all why our </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">visit()</span></strong><span class="koboSpan" id="kobo.199.1"> functions cannot have parameters. </span><span class="koboSpan" id="kobo.199.2">Let’s expand our class hierarchy by allowing our pets to have kittens and puppies. </span><span class="koboSpan" id="kobo.199.3">This extension cannot be done using only the Visitor pattern - we need to add not only new operations but also new data members. </span><span class="koboSpan" id="kobo.199.4">The Visitor pattern can be used for the former, but the latter requires code changes. </span><span class="koboSpan" id="kobo.199.5">A policy-based design could have let us factor out this change into a new implementation of an existing policy if we had the foresight to provide the appropriate policy. </span><span class="koboSpan" id="kobo.199.6">We do have a separate chapter on </span><a href="B19262_15.xhtml#_idTextAnchor689"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.200.1">Chapter 15</span></em></span></a><span class="koboSpan" id="kobo.201.1">, </span><em class="italic"><span class="koboSpan" id="kobo.202.1">Policy-Based Design</span></em><span class="koboSpan" id="kobo.203.1"> in this book, so here we will avoid mixing several patterns together and just add the new </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">data members:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.205.1">
// Example 04
class Pet {
  public:
  ..
</span><span class="koboSpan" id="kobo.205.2">  void add_child(Pet* p) { children_.push_back(p); }
  virtual void accept(PetVisitor&amp; v, Pet* p = nullptr) = 0;
  private:
  std::vector&lt;Pet*&gt; children_;
};</span></pre>
<p><span class="koboSpan" id="kobo.206.1">Each parent </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">Pet</span></strong><span class="koboSpan" id="kobo.208.1"> object tracks its child objects (note that the container is a vector of pointers, not a vector of unique pointers, so the object does not own its children, but merely has access to them). </span><span class="koboSpan" id="kobo.208.2">We have also added the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">add_child()</span></strong><span class="koboSpan" id="kobo.210.1"> member function to add objects to the vector. </span><span class="koboSpan" id="kobo.210.2">We could have done this with a visitor, but this function is non-virtual, so</span><a id="_idIndexMarker1010"/><span class="koboSpan" id="kobo.211.1"> we have to add it only once to the base class, not to every derived class - the visitor is unnecessary here. </span><span class="koboSpan" id="kobo.211.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">accept()</span></strong><span class="koboSpan" id="kobo.213.1"> function has been modified to have an additional parameter that would have to be added to all derived classes as well, where it is simply forwarded to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">visit()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.215.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.216.1">
// Example 04
class Cat : public Pet {
  public:
  Cat(std::string_view color) : Pet(color) {}
  void accept(PetVisitor&amp; v, Pet* p = nullptr) override {
    v.visit(this, p);
  }
};
class Dog : public Pet {
  public:
  Dog(std::string_view color) : Pet(color) {}
  void accept(PetVisitor&amp; v, Pet* p = nullptr) override {
    v.visit(this, p);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.217.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">visit()</span></strong><span class="koboSpan" id="kobo.219.1"> function also has to be modified to accept the additional argument, even for the visitors that do not need it. </span><span class="koboSpan" id="kobo.219.2">Changing the parameters of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">accept()</span></strong><span class="koboSpan" id="kobo.221.1"> function is, therefore, an expensive global operation that should not be done often, if at all. </span><span class="koboSpan" id="kobo.221.2">Note that all overrides for the same virtual function in the hierarchy already have to have the same parameters. </span><span class="koboSpan" id="kobo.221.3">The Visitor pattern extends this restriction to all operations added using the same base Visitor object. </span><span class="koboSpan" id="kobo.221.4">A common workaround for this problem is to pass parameters using aggregates (classes or structures that combine multiple parameters together). </span><span class="koboSpan" id="kobo.221.5">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">visit()</span></strong><span class="koboSpan" id="kobo.223.1"> function is declared to accept a pointer to the base aggregate class, while each visitor receives a pointer to a derived class that may have additional fields, and uses them </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">as needed.</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">Now, our </span><a id="_idIndexMarker1011"/><span class="koboSpan" id="kobo.226.1">additional argument is forwarded through the chain of virtual function calls to the visitor, where we can make use of it. </span><span class="koboSpan" id="kobo.226.2">Let’s create a visitor that records the pet births and adds new pet objects as children to their </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">parent objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.228.1">
// Example 04
class BirthVisitor : public PetVisitor {
  public:
  void visit(Cat* c, Pet* p) override {
    assert(dynamic_cast&lt;Cat*&gt;(p));
    c-&gt;add_child(p);
  }
  void visit(Dog* d, Pet* p) override {
    assert(dynamic_cast&lt;Dog*&gt;(p));
    d-&gt;add_child(p);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.229.1">Note that if we want to make sure that there are no biological impossibilities in our family tree, the verification has to be done at run time - at compile time, we do not know the actual types of the polymorphic objects. </span><span class="koboSpan" id="kobo.229.2">The new visitor is just as easy to use as the ones from the </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">last section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.231.1">
Pet* parent; // A cat
BirthVisitor bv;
Pet* child(new Cat("calico"));
parent-&gt;accept(bv, child);</span></pre>
<p><span class="koboSpan" id="kobo.232.1">Once we have established the parenthood relationships, we may want to examine our pet families. </span><span class="koboSpan" id="kobo.232.2">That is </span><a id="_idIndexMarker1012"/><span class="koboSpan" id="kobo.233.1">another operation we want to add, which calls for </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">another Visitor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.235.1">
// Example 04
class FamilyTreeVisitor : public PetVisitor {
  public:
  void visit(Cat* c, Pet*) override {
    std::cout &lt;&lt; "Kittens: ";
    for (auto k : c-&gt;children_) {
      std::cout &lt;&lt; k-&gt;color() &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
  }
  void visit(Dog* d, Pet*) override {
    std::cout &lt;&lt; "Puppies: ";
    for (auto p : d-&gt;children_) {
      std::cout &lt;&lt; p-&gt;color() &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.236.1">We have hit a slight problem, though, because as written, the code will not compile. </span><span class="koboSpan" id="kobo.236.2">The reason is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">FamilyTreeVisitor</span></strong><span class="koboSpan" id="kobo.238.1"> class is trying to access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">Pet::children_</span></strong><span class="koboSpan" id="kobo.240.1"> data member, which is private. </span><span class="koboSpan" id="kobo.240.2">This is another weakness of the Visitor pattern - from our point of view, the visitors add new operations to the classes, just like virtual functions, but from the compiler’s point of view, they are completely separate classes, not at all like member functions of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">Pet</span></strong><span class="koboSpan" id="kobo.242.1"> classes and have no special access. </span><span class="koboSpan" id="kobo.242.2">Application of the Visitor pattern usually requires that the encapsulation is relaxed in one of two ways - we can either allow public access to the data (directly or through accessor member functions) or declare the Visitor classes to be friends (which does require changes to </span><a id="_idIndexMarker1013"/><span class="koboSpan" id="kobo.243.1">the source code). </span><span class="koboSpan" id="kobo.243.2">In our example, we will follow the </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">second route:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.245.1">
class Pet {
  ...
</span><span class="koboSpan" id="kobo.245.2">  friend class FamilyTreeVisitor;
};</span></pre>
<p><span class="koboSpan" id="kobo.246.1">Now the family tree visitor works </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">as expected:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
Pet* parent; // A cat
...
</span><span class="koboSpan" id="kobo.248.2">amilyTreeVisitor tv;
parent-&gt;accept(tv); // Prints kitten colors</span></pre>
<p><span class="koboSpan" id="kobo.249.1">Unlike </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">BirthVisitor</span></strong><span class="koboSpan" id="kobo.251.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">FamilyTreeVisitor</span></strong><span class="koboSpan" id="kobo.253.1"> does not need the </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">additional argument.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">Now we have visitors that implement operations with parameters. </span><span class="koboSpan" id="kobo.255.2">What about the return values? </span><span class="koboSpan" id="kobo.255.3">Technically, there is no requirement for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">visit()</span></strong><span class="koboSpan" id="kobo.257.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">accept()</span></strong><span class="koboSpan" id="kobo.259.1"> functions to return </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">void</span></strong><span class="koboSpan" id="kobo.261.1">. </span><span class="koboSpan" id="kobo.261.2">They can return anything else. </span><span class="koboSpan" id="kobo.261.3">However, the limitation that they have to all return the same type usually makes this capability useless. </span><span class="koboSpan" id="kobo.261.4">Virtual functions can have covariant return types, where the base class virtual function returns an object of some class and the derived class overrides return objects derived from that class, but even that is usually too limiting. </span><span class="koboSpan" id="kobo.261.5">There is another, much simpler solution - the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">visit()</span></strong><span class="koboSpan" id="kobo.263.1"> functions of every Visitor object have full access to the data members of that object. </span><span class="koboSpan" id="kobo.263.2">There is no reason why we cannot store the return value in the Visitor class itself and access it later. </span><span class="koboSpan" id="kobo.263.3">This fits well with the most common use where each visitor adds a different operation and is likely to have a unique return type, but the operation itself usually has the same return type for all classes in the hierarchy. </span><span class="koboSpan" id="kobo.263.4">For example, we can make our </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">FamilyTreeVisitor</span></strong><span class="koboSpan" id="kobo.265.1"> count the total number of children and return the value through the</span><a id="_idIndexMarker1014"/> <span class="No-Break"><span class="koboSpan" id="kobo.266.1">Visitor object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
// Example 05
class FamilyTreeVisitor : public PetVisitor {
  public:
  FamilyTreeVisitor() : child_count_(0) {}
  void reset() { child_count_ = 0; }
  size_t child_count() const { return child_count_; }
  void visit(Cat* c, Pet*) override {
    visit_impl(c, "Kittens: ");
  }
  void visit(Dog* d, Pet*) override {
    visit_impl(d, "Puppies: ");
  }
  private:
  template &lt;typename T&gt;
  void visit_impl(T* t, const char* s) {
    std::cout &lt;&lt; s;
    for (auto p : t-&gt;children_) {
      std::cout &lt;&lt; p-&gt;color() &lt;&lt; " ";
        ++child_count_;
      }
      std::cout &lt;&lt; std::endl;
  }
  size_t child_count_;
};
FamilyTreeVisitor tv;
parent-&gt;accept(tv);
std::cout &lt;&lt; tv.child_count() &lt;&lt; " kittens total"
          &lt;&lt; std::endl;</span></pre>
<p><span class="koboSpan" id="kobo.268.1">This approach imposes some limitations in multithreaded programs - the visitor is now not thread-safe since multiple threads cannot use the same Visitor object to visit different pet objects. </span><span class="koboSpan" id="kobo.268.2">The most common solution is to use one Visitor object per thread, usually a local variable created on the stack of the function that calls the visitor. </span><span class="koboSpan" id="kobo.268.3">If this is not possible, more complex options are available to give the visitor a per-thread (thread-local) state, but the analysis of such options lies outside of the scope of this book. </span><span class="koboSpan" id="kobo.268.4">On the other hand, sometimes we want to accumulate results over multiple visitations, in which case the previous technique of storing the result in the Visitor object works perfectly. </span><span class="koboSpan" id="kobo.268.5">Also note that the same solution can be used to pass arguments into the Visitor </span><a id="_idIndexMarker1015"/><span class="koboSpan" id="kobo.269.1">operations, instead of adding them to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">visit()</span></strong><span class="koboSpan" id="kobo.271.1"> functions; we can store the arguments inside the Visitor object itself, and then we don’t need anything special to access them from the visitor. </span><span class="koboSpan" id="kobo.271.2">This technique works particularly well when the arguments don’t change on every invocation of the visitor, but may vary from one Visitor object </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">to another.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">Let’s return for a moment and examine the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">FamilyTreeVisitor</span></strong><span class="koboSpan" id="kobo.275.1"> implementation again. </span><span class="koboSpan" id="kobo.275.2">Note that it iterates over the child objects of the parent object and calls the same operation on each one, in turn. </span><span class="koboSpan" id="kobo.275.3">It does not, however, process the children of the child object - our family tree is only one-generation deep. </span><span class="koboSpan" id="kobo.275.4">The problem of visiting objects that contain other objects is very general and occurs rather often. </span><span class="koboSpan" id="kobo.275.5">Our motivational example from the very beginning of this chapter, the problem of serialization, demonstrates this need perfectly - every complex object is serialized by serializing its components, one by one, and they, in turn, are serialized the same way, until we get all the way down to the built-in types such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">int</span></strong><span class="koboSpan" id="kobo.277.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">double</span></strong><span class="koboSpan" id="kobo.279.1">, which we know how to read and write. </span><span class="koboSpan" id="kobo.279.2">The next section deals with visiting complex objects in a more comprehensive way than</span><a id="_idTextAnchor798"/> <a id="_idTextAnchor799"/><span class="koboSpan" id="kobo.280.1">what we have done </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">so far.</span></span></p>
<h1 id="_idParaDest-307"><a id="_idTextAnchor800"/><span class="koboSpan" id="kobo.282.1">Visiting complex objects</span></h1>
<p><span class="koboSpan" id="kobo.283.1">In the last section, we</span><a id="_idIndexMarker1016"/><span class="koboSpan" id="kobo.284.1"> saw how the Visitor pattern </span><a id="_idIndexMarker1017"/><span class="koboSpan" id="kobo.285.1">allows us to add new operations to the existing hierarchy. </span><span class="koboSpan" id="kobo.285.2">In one of the examples, we visited a complex object that contained pointers to other objects. </span><span class="koboSpan" id="kobo.285.3">The visitor iterated over these pointers, in a limited way. </span><span class="koboSpan" id="kobo.285.4">We are now going to consider the general problem of visiting objects that are composed of other objects, or objects that contain other objects and build up to the demonstration of a working serialization/deserial</span><a id="_idTextAnchor801"/><span class="koboSpan" id="kobo.286.1">i</span><a id="_idTextAnchor802"/><span class="koboSpan" id="kobo.287.1">zation solution at </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">the end.</span></span></p>
<h2 id="_idParaDest-308"><a id="_idTextAnchor803"/><span class="koboSpan" id="kobo.289.1">Visiting composite objects</span></h2>
<p><span class="koboSpan" id="kobo.290.1">The general idea </span><a id="_idIndexMarker1018"/><span class="koboSpan" id="kobo.291.1">of visiting complex objects is quite </span><a id="_idIndexMarker1019"/><span class="koboSpan" id="kobo.292.1">straightforward - when visiting the object itself, we generally do not know all the details of how to handle each component or contained object. </span><span class="koboSpan" id="kobo.292.2">But there is something else that does - the visitor for that object type is written specifically to handle that class and nothing else. </span><span class="koboSpan" id="kobo.292.3">This observation suggests that the correct way to handle the component objects is to simply visit each one, and thus delegate the problem to someone else (a generally powerful technique, in programming </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">and otherwise).</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">Let’s first demonstrate this idea on the example of a simple container class, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">Shelter</span></strong><span class="koboSpan" id="kobo.296.1"> class, which can contain any number of pet objects representing the pets waiting </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">for adoption:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.298.1">
// Example 06
class Shelter {
  public:
  void add(Pet* p) {
    pets_.emplace_back(p);
  }
  void accept(PetVisitor&amp; v) {
    for (auto&amp; p : pets_) {
      p-&gt;accept(v);
    }
  }
  private:
  std::vector&lt;std::unique_ptr&lt;Pet&gt;&gt; pets_;
};</span></pre>
<p><span class="koboSpan" id="kobo.299.1">This class is essentially an adapter to make a vector of pet objects visitable (we have discussed the Adapter pattern in detail in the eponymous chapter). </span><span class="koboSpan" id="kobo.299.2">Note that the objects of this class do own the pet objects they contain - when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">Shelter</span></strong><span class="koboSpan" id="kobo.301.1"> object is destroyed, so are all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">Pet</span></strong><span class="koboSpan" id="kobo.303.1"> objects in the vector. </span><span class="koboSpan" id="kobo.303.2">Any container of unique pointers is a container that owns its contained objects; this is how polymorphic objects should be stored in a container such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">std::vector</span></strong><span class="koboSpan" id="kobo.305.1"> (For non-polymorphic objects we can store objects themselves, but that won’t work in our case, objects derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">Pet</span></strong><span class="koboSpan" id="kobo.307.1"> are of </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">different types.)</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">The code relevant to our current problem is, of course, </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">Shelter::accept()</span></strong><span class="koboSpan" id="kobo.311.1">, which determines how a </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">Shelter</span></strong><span class="koboSpan" id="kobo.313.1"> object is visited. </span><span class="koboSpan" id="kobo.313.2">As you can see, we do not invoke the Visitor on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">Shelter</span></strong><span class="koboSpan" id="kobo.315.1"> object itself. </span><span class="koboSpan" id="kobo.315.2">Instead, we delegate the visitation to each of the containing </span><a id="_idIndexMarker1020"/><span class="koboSpan" id="kobo.316.1">objects. </span><span class="koboSpan" id="kobo.316.2">Since our Visitors are already written to </span><a id="_idIndexMarker1021"/><span class="koboSpan" id="kobo.317.1">handle Pet objects, nothing more needs to be done. </span><span class="koboSpan" id="kobo.317.2">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">Shelter</span></strong><span class="koboSpan" id="kobo.319.1"> is visited by, say, </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">FeedingVisitor</span></strong><span class="koboSpan" id="kobo.321.1">, every pet in the shelter gets fed, and we didn’t have to write any special code to make </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">it happen.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">Visitation of composite objects is done in a similar manner - if an object is composed of several smaller objects, we have to visit each of these objects. </span><span class="koboSpan" id="kobo.323.2">Let’s consider an object representing a family with two family pets, a dog and a cat (the humans who serve the pets are not included in the following code, but we assume they are </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">there too):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.325.1">
// Example 07
class Family {
  public:
  Family(const char* cat_color, const char* dog_color) :
  cat_(cat_color), dog_(dog_color) {}
  void accept(PetVisitor&amp; v) {
    cat_.accept(v);
    dog_.accept(v);
  }
  private: // Other family members not shown for brevity
  Cat cat_;
  Dog dog_;
};</span></pre>
<p><span class="koboSpan" id="kobo.326.1">Again, visiting the family with a visitor from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">PetVisitor</span></strong><span class="koboSpan" id="kobo.328.1"> hierarchy is delegated so that each </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">Pet</span></strong><span class="koboSpan" id="kobo.330.1"> object is visited, and the visitors already have everything they need to handle these objects (of course, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Family</span></strong><span class="koboSpan" id="kobo.332.1"> object could accept visitors of other types as well, we would have to write separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">accept()</span></strong><span class="koboSpan" id="kobo.334.1"> methods </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">for them).</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">Now, at last, we </span><a id="_idIndexMarker1022"/><span class="koboSpan" id="kobo.337.1">have all the pieces we need to tackle </span><a id="_idIndexMarker1023"/><span class="koboSpan" id="kobo.338.1">the problem of serialization and deserialization of arbitrary objects. </span><span class="koboSpan" id="kobo.338.2">The next subsection shows how this can </span><a id="_idTextAnchor804"/><span class="koboSpan" id="kobo.339.1">b</span><a id="_idTextAnchor805"/><span class="koboSpan" id="kobo.340.1">e done using the </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">Visitor pattern.</span></span></p>
<h2 id="_idParaDest-309"><a id="_idTextAnchor806"/><span class="koboSpan" id="kobo.342.1">Serialization and deserialization with Visitor</span></h2>
<p><span class="koboSpan" id="kobo.343.1">The problem itself </span><a id="_idIndexMarker1024"/><span class="koboSpan" id="kobo.344.1">was described in detail in the previous section - for</span><a id="_idIndexMarker1025"/><span class="koboSpan" id="kobo.345.1"> serialization, each object needs to</span><a id="_idIndexMarker1026"/><span class="koboSpan" id="kobo.346.1"> be converted to a sequence of bits, and these bits need to be stored, copied, or sent. </span><span class="koboSpan" id="kobo.346.2">The first part of the action depends on the object (each object is converted differently) but the second part depends on the specific application of the serialization (saving to disk is different from sending across the network). </span><span class="koboSpan" id="kobo.346.3">The implementation depends on two factors, hence the need for double dispatch, which is exactly what the Visitor pattern provides. </span><span class="koboSpan" id="kobo.346.4">Furthermore, if we have a way to serialize some object and then deserialize it (reconstruct the object from the sequence of bits), we should use the same method when this object is included in </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">another object.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">To demonstrate serialization/deserialization of a class hierarchy using the Visitor pattern, we need a more complex hierarchy than the toy examples we have used so far. </span><span class="koboSpan" id="kobo.348.2">Let’s consider this hierarchy of two-dimensional </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">geometric objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.350.1">
// Example 08
class Geometry {
  public:
  virtual ~Geometry() {}
};
class Point : public Geometry {
  public:
  Point() = default;
  Point(double x, double y) : x_(x), y_(y) {}
  private:
  double x_ {};
  double y_ {};
};
class Circle : public Geometry {
  public:
  Circle() = default;
  Circle(Point c, double r) : c_(c), r_(r) {}
  private:
  Point c_;
  double r_ {};
};
class Line : public Geometry {
  public:
  Line() = default;
  Line(Point p1, Point p2) : p1_(p1), p2_(p2) {}
  private:
  Point p1_;
  Point p2_;
};</span></pre>
<p><span class="koboSpan" id="kobo.351.1">All objects are derived from the abstract </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">Geometry</span></strong><span class="koboSpan" id="kobo.353.1"> base class, but the more complex object contains one or more of the simpler objects; for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">Line</span></strong><span class="koboSpan" id="kobo.355.1"> is defined by two </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">Point</span></strong><span class="koboSpan" id="kobo.357.1"> objects. </span><span class="koboSpan" id="kobo.357.2">Note that, at the end of the day, all our objects are made of </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">double</span></strong><span class="koboSpan" id="kobo.359.1"> numbers, and, therefore, will serialize into a sequence of numbers. </span><span class="koboSpan" id="kobo.359.2">The key is knowing which </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">double</span></strong><span class="koboSpan" id="kobo.361.1"> represents which field of which object; we need this to restore the original </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">objects correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">To serialize these objects using the Visitor pattern, we follow the same process we used in the last section. </span><span class="koboSpan" id="kobo.363.2">First, we need to declare the base </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">Visitor class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.365.1">
// Example 08
class Visitor {
public:
  virtual void visit(double&amp; x) = 0;
  virtual void visit(Point&amp; p) = 0;
  virtual void visit(Circle&amp; c) = 0;
  virtual void visit(Line&amp; l) = 0;
};</span></pre>
<p><span class="koboSpan" id="kobo.366.1">There is </span><a id="_idIndexMarker1027"/><span class="koboSpan" id="kobo.367.1">one</span><a id="_idIndexMarker1028"/><span class="koboSpan" id="kobo.368.1"> additional </span><a id="_idIndexMarker1029"/><span class="koboSpan" id="kobo.369.1">detail here - we can also visit double values; each visitor would need to handle them appropriately (write them, read them, and so on). </span><span class="koboSpan" id="kobo.369.2">Visiting any geometry object will result, eventually, in visiting the numbers it is </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">composed of.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Our base </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">Geometry</span></strong><span class="koboSpan" id="kobo.373.1"> class and all the classes derived from it need to accept </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">this visitor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.375.1">
// Example 08
class Geometry {
  public:
  virtual ~Geometry() {}
  virtual void accept(Visitor&amp; v) = 0;
};</span></pre>
<p><span class="koboSpan" id="kobo.376.1">There is, of course, no way to add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">accept()</span></strong><span class="koboSpan" id="kobo.378.1"> member function to double, but we won’t have to. </span><span class="koboSpan" id="kobo.378.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">accept()</span></strong><span class="koboSpan" id="kobo.380.1"> member functions for the derived classes, each of which is composed of one or more numbers and other classes, visit every data member </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">in order:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.382.1">
// Example 08
void Point::accept(Visitor&amp; v) {
  v.visit(x_); // double
  v.visit(y_); // double
}
void Circle::accept(Visitor&amp; v) {
  v.visit(c_); // Point
  v.visit(r_); // double
}
void Point::accept(Visitor&amp; v) {
  v.visit(p1_); // Point
  v.visit(p2_); // Point
}</span></pre>
<p><span class="koboSpan" id="kobo.383.1">The concrete</span><a id="_idIndexMarker1030"/><span class="koboSpan" id="kobo.384.1"> Visitor</span><a id="_idIndexMarker1031"/><span class="koboSpan" id="kobo.385.1"> classes, all </span><a id="_idIndexMarker1032"/><span class="koboSpan" id="kobo.386.1">derived from the base </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">Visitor</span></strong><span class="koboSpan" id="kobo.388.1"> class, are responsible for the specific mechanisms of serialization and deserialization. </span><span class="koboSpan" id="kobo.388.2">The order in which the objects are broken down into their parts, all the way down to the numbers, is controlled by each object, but the visitors determine what is done with these numbers. </span><span class="koboSpan" id="kobo.388.3">For example, we can serialize all objects into a string using the formatted I/O (similar to what we get if we print the numbers </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">into </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">cout</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.392.1">
// Example 08
class StringSerializeVisitor : public Visitor {
public:
  void visit(double&amp; x) override { S &lt;&lt; x &lt;&lt; " "; }
  void visit(Point&amp; p) override { p.accept(*this); }
  void visit(Circle&amp; c) override { c.accept(*this); }
  void visit(Line&amp; l) override { l.accept(*this); }
  std::string str() const { return S.str(); }
  private:
  std::stringstream S;
};</span></pre>
<p><span class="koboSpan" id="kobo.393.1">The string is accumulated in </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">stringstream</span></strong><span class="koboSpan" id="kobo.395.1"> until all the necessary objects </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">are serialized:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.397.1">
// Example 08
Line l(...);
Circle c(...);
StringSerializeVisitor serializer;
serializer.visit(l);
serializer.visit(c);
std::string s(serializer.str());</span></pre>
<p><span class="koboSpan" id="kobo.398.1">Now that we have the </span><a id="_idIndexMarker1033"/><span class="koboSpan" id="kobo.399.1">objects </span><a id="_idIndexMarker1034"/><span class="koboSpan" id="kobo.400.1">printed </span><a id="_idIndexMarker1035"/><span class="koboSpan" id="kobo.401.1">into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">s</span></strong><span class="koboSpan" id="kobo.403.1"> string, we can restore them from this string, perhaps on a different machine (if we arranged for the string to be sent there). </span><span class="koboSpan" id="kobo.403.2">First, we need the </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">deserializing Visitor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.405.1">
// Example 08
class StringDeserializeVisitor : public Visitor {
  public:
  StringDeserializeVisitor(const std::string&amp; s) {
    S.str(s);
  }
  void visit(double&amp; x) override { S &gt;&gt; x; }
  void visit(Point&amp; p) override { p.accept(*this); }
  void visit(Circle&amp; c) override { c.accept(*this); }
  void visit(Line&amp; l) override { l.accept(*this); }
  private:
  std::stringstream S;
};</span></pre>
<p><span class="koboSpan" id="kobo.406.1">This Visitor reads the numbers from the string and saves them in the variables given to it by the object that is visited. </span><span class="koboSpan" id="kobo.406.2">The key to successful deserialization is to read the numbers in the same order as they were saved - for example, if we started by writing </span><em class="italic"><span class="koboSpan" id="kobo.407.1">X</span></em><span class="koboSpan" id="kobo.408.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.409.1">Y</span></em><span class="koboSpan" id="kobo.410.1"> coordinates of a point, we should construct a point from the first two numbers we read and use them as </span><em class="italic"><span class="koboSpan" id="kobo.411.1">X</span></em><span class="koboSpan" id="kobo.412.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.413.1">Y</span></em><span class="koboSpan" id="kobo.414.1"> coordinates. </span><span class="koboSpan" id="kobo.414.2">If the first point we wrote was the endpoint of a line, we should use the point we constructed as the endpoint of the new line. </span><span class="koboSpan" id="kobo.414.3">The beauty of the Visitor pattern is that the functions that do the actual reading and writing don’t need to do anything special to preserve this order - the order is determined by each object and is guaranteed to be the same for all visitors (the object makes no distinction between the specific</span><a id="_idIndexMarker1036"/><span class="koboSpan" id="kobo.415.1"> visitors </span><a id="_idIndexMarker1037"/><span class="koboSpan" id="kobo.416.1">and</span><a id="_idIndexMarker1038"/><span class="koboSpan" id="kobo.417.1"> doesn’t even know what kind of visitor is it). </span><span class="koboSpan" id="kobo.417.2">All we need to do is to visit the objects in the same order they were </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">serialized in:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.419.1">
// Example 08
Line l1;
Circle c1;
// s is the string from a serializer
StringDeserializeVisitor deserializer(s);
deserializer.visit(l1); // Restored Line l
deserializer.visit(c1); // Restored Circle c</span></pre>
<p><span class="koboSpan" id="kobo.420.1">So far, we have known which objects are serialized and in what order. </span><span class="koboSpan" id="kobo.420.2">Therefore, we can deserialize the same objects in the same order. </span><span class="koboSpan" id="kobo.420.3">A more general case is when we don’t know what objects to expect during deserialization - the objects are stored in a visitable container, similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">Shelter</span></strong><span class="koboSpan" id="kobo.422.1"> in the earlier example, which has to ensure that the objects are serialized and deserialized in the same order. </span><span class="koboSpan" id="kobo.422.2">For example, consider this class, which stores a geometry represented as an intersection of two </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">other geometries:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.424.1">
// Example 09
class Intersection : public Geometry {
  public:
  Intersection() = default;
  Intersection(Geometry* g1, Geometry* g2) :
    g1_(g1), g2_(g2) {}
  void accept(Visitor&amp; v) override {
    g1_-&gt;accept(v);
    g2_-&gt;accept(v);
  }
  private:
  std::unique_ptr&lt;Geometry&gt; g1_;
  std::unique_ptr&lt;Geometry&gt; g2_;
};</span></pre>
<p><span class="koboSpan" id="kobo.425.1">Serialization of this object is straightforward - we serialize both geometries, in order, by delegating the details to these objects. </span><span class="koboSpan" id="kobo.425.2">We cannot call </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">v.visit()</span></strong><span class="koboSpan" id="kobo.427.1"> directly because we do not know the types of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">*g1_</span></strong><span class="koboSpan" id="kobo.429.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">*g2_</span></strong><span class="koboSpan" id="kobo.431.1"> geometries, but we can let these objects dispatch the call as appropriate. </span><span class="koboSpan" id="kobo.431.2">But deserialization, as written, will fail - the geometry pointers are </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">null</span></strong><span class="koboSpan" id="kobo.433.1">, there are no objects allocated yet, and we do not know what type of objects should be allocated. </span><span class="koboSpan" id="kobo.433.2">Somehow, we need to encode the types of objects in the serialized stream first, then construct them based on these encoded types. </span><span class="koboSpan" id="kobo.433.3">There</span><a id="_idIndexMarker1039"/><span class="koboSpan" id="kobo.434.1"> is </span><a id="_idIndexMarker1040"/><span class="koboSpan" id="kobo.435.1">another </span><a id="_idIndexMarker1041"/><span class="koboSpan" id="kobo.436.1">pattern that offers the standard solution for this problem, and that is the Factory pattern (it is quite common to have to use more than one design pattern when building a </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">complex system).</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">There are several ways in which this can be done, but they all boil down to converting types to numbers and serializing those numbers. </span><span class="koboSpan" id="kobo.438.2">In our case, we have to know the complete list of geometry types when we declare the base </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">Visitor</span></strong><span class="koboSpan" id="kobo.440.1"> class, so that we can also define an enumeration for all these types at the </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">same time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.442.1">
// Example 09
class Geometry {
  public:
  enum type_tag {POINT = 100, CIRCLE, LINE, INTERSECTION};
  virtual type_tag tag() const = 0;
};
class Visitor {
  public:
  static Geometry* make_geometry(Geometry::type_tag tag);
  virtual void visit(Geometry::type_tag&amp; tag) = 0;
  ...
</span><span class="koboSpan" id="kobo.442.2">};</span></pre>
<p><span class="koboSpan" id="kobo.443.1">It is not essential that </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">enum type_tag</span></strong><span class="koboSpan" id="kobo.445.1"> be defined inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">Geometry</span></strong><span class="koboSpan" id="kobo.447.1"> class, or that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">make_geometry</span></strong><span class="koboSpan" id="kobo.449.1"> factory constructor be a static member function of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">Visitor</span></strong><span class="koboSpan" id="kobo.451.1"> class. </span><span class="koboSpan" id="kobo.451.2">They can </span><a id="_idIndexMarker1042"/><span class="koboSpan" id="kobo.452.1">be </span><a id="_idIndexMarker1043"/><span class="koboSpan" id="kobo.453.1">declared </span><a id="_idIndexMarker1044"/><span class="koboSpan" id="kobo.454.1">outside of any class as well, but the virtual </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">tag()</span></strong><span class="koboSpan" id="kobo.456.1"> method that will return the correct tag for every derived geometry type needs to be declared exactly as shown. </span><span class="koboSpan" id="kobo.456.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">tag()</span></strong><span class="koboSpan" id="kobo.458.1"> overrides must be defined in every derived </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">Geometry</span></strong><span class="koboSpan" id="kobo.460.1"> class, for example, the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">Point</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.462.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.463.1">
// Example 09
class Point : public Geometry {
  public:
  ...
</span><span class="koboSpan" id="kobo.463.2">  type_tag tag() const override { return POINT; }
};</span></pre>
<p><span class="koboSpan" id="kobo.464.1">Other derived classes have to be </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">similarly modified.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">Then we need to define the </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">factory constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.468.1">
// Example 09
Geometry* Visitor::make_geometry(Geometry::type_tag tag) {
  switch (tag) {
    case Geometry::POINT: return new Point;
    case Geometry::CIRCLE: return new Circle;
    case Geometry::LINE: return new Line;
    case Geometry::INTERSECTION: return new Intersection;
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.469.1">This factory function constructs the right derived object depending on the specified type tag. </span><span class="koboSpan" id="kobo.469.2">All that is left is for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">Intersection</span></strong><span class="koboSpan" id="kobo.471.1"> object to serialize and deserialize the tags of the two</span><a id="_idIndexMarker1045"/><span class="koboSpan" id="kobo.472.1"> geometries</span><a id="_idIndexMarker1046"/><span class="koboSpan" id="kobo.473.1"> that </span><a id="_idIndexMarker1047"/><span class="koboSpan" id="kobo.474.1">form </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">the intersection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.476.1">
// Example 09
class Intersection : public Geometry {
  public:
  void accept(Visitor&amp; v) override {
    Geometry::type_tag tag;
    if (g1_) tag = g1_-&gt;tag();
    v.visit(tag);
    if (!g1_) g1_.reset(Visitor::make_geometry(tag));
    g1_-&gt;accept(v);
    if (g2_) tag = g2_-&gt;tag();
    v.visit(tag);
    if (!g2_) g2_.reset(Visitor::make_geometry(tag));
    g2_-&gt;accept(v);
  }
  ...
</span><span class="koboSpan" id="kobo.476.2">};</span></pre>
<p><span class="koboSpan" id="kobo.477.1">First, the tags are sent to the visitor. </span><span class="koboSpan" id="kobo.477.2">The serializing visitor should write the tags along with the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">the data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.479.1">
// Example 09
class StringSerializeVisitor : public Visitor {
  public:
  void visit(Geometry::type_tag&amp; tag) override {
    S &lt;&lt; size_t(tag) &lt;&lt; " ";
  }
  ...
</span><span class="koboSpan" id="kobo.479.2">};</span></pre>
<p><span class="koboSpan" id="kobo.480.1">The deserializing visitor </span><a id="_idIndexMarker1048"/><span class="koboSpan" id="kobo.481.1">has </span><a id="_idIndexMarker1049"/><span class="koboSpan" id="kobo.482.1">to </span><a id="_idIndexMarker1050"/><span class="koboSpan" id="kobo.483.1">read the tag (actually, it reads a </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">size_t</span></strong><span class="koboSpan" id="kobo.485.1"> number and converts it to </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">the tag):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.487.1">
// Example 09
class StringDeserializeVisitor : public Visitor {
  public:
  void visit(Geometry::type_tag&amp; tag) override {
    size_t t;
    S &gt;&gt; t;
    tag = Geometry::type_tag(t);
  }
  ...
</span><span class="koboSpan" id="kobo.487.2">};</span></pre>
<p><span class="koboSpan" id="kobo.488.1">Once the tag is restored by the deserializing visitor, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">Intersection</span></strong><span class="koboSpan" id="kobo.490.1"> object can invoke the factory constructor to construct the right geometry object. </span><span class="koboSpan" id="kobo.490.2">Now we can deserialize this object from the stream, and our </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">Intersection</span></strong><span class="koboSpan" id="kobo.492.1"> is restored as an exact copy of the one we serialized. </span><span class="koboSpan" id="kobo.492.2">Note that there are other ways to package visiting the tags and the calls to the factory constructor; the optimal solution depends on the roles of different objects in the system - for example, the deserializing visitor may construct the objects based on the tag instead of the composite object that owns these geometries. </span><span class="koboSpan" id="kobo.492.3">The sequence of events that need to take place, however, remains </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.494.1">So far, we have been learning about the classic object-oriented Visitor pattern. </span><span class="koboSpan" id="kobo.494.2">Before we see what the C++-specific</span><a id="_idIndexMarker1051"/><span class="koboSpan" id="kobo.495.1"> twists </span><a id="_idIndexMarker1052"/><span class="koboSpan" id="kobo.496.1">on the classic pattern are, we should </span><a id="_idIndexMarker1053"/><span class="koboSpan" id="kobo.497.1">learn about another type of visitor t</span><a id="_idTextAnchor807"/><span class="koboSpan" id="kobo.498.1">h</span><a id="_idTextAnchor808"/><span class="koboSpan" id="kobo.499.1">at addresses some of the inconveniences in the </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">Visitor pattern.</span></span></p>
<h1 id="_idParaDest-310"><a id="_idTextAnchor809"/><span class="koboSpan" id="kobo.501.1">Acyclic Visitor</span></h1>
<p><span class="koboSpan" id="kobo.502.1">The Visitor pattern, as </span><a id="_idIndexMarker1054"/><span class="koboSpan" id="kobo.503.1">we have seen it so far, does what we wanted it to do. </span><span class="koboSpan" id="kobo.503.2">It separates the implementation of the algorithm from the object that is the data for the algorithm, and it allows us to select the correct implementation based on two run-time factors - the specific object type and the concrete operation we want to perform, both of which are selected from their corresponding class hierarchies. </span><span class="koboSpan" id="kobo.503.3">There is, however, a fly in the ointment - we wanted to reduce complexity and simplified the code maintenance, and we did, but now we have to maintain two parallel class hierarchies, the visitable objects and the visitors, and the dependencies between the two are non-trivial. </span><span class="koboSpan" id="kobo.503.4">The worst part of these dependencies is that they form a cycle - the Visitor object depends on the types of the visitable objects (there is an overload of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">visit()</span></strong><span class="koboSpan" id="kobo.505.1"> methods for every visitable type), and the base visitable type depends on the base visitor type. </span><span class="koboSpan" id="kobo.505.2">The first half of this dependency is the worst. </span><span class="koboSpan" id="kobo.505.3">Every time a new object is added to the hierarchy, every visitor must be updated. </span><span class="koboSpan" id="kobo.505.4">The second half does not take much work from the programmer as new visitors can be added at any time and without any other changes - this is the whole point of the Visitor pattern. </span><span class="koboSpan" id="kobo.505.5">But there is still the compile-time dependency of the base visitable class, and, perforce, all derived classes, on the base Visitor class. </span><span class="koboSpan" id="kobo.505.6">Were the Visitor class to change, every file that uses one of the visitable classes would need to be recompiled. </span><span class="koboSpan" id="kobo.505.7">The visitors are, for the most part, stable in their interface and implementation, except for one case - adding a new visitable class. </span><span class="koboSpan" id="kobo.505.8">Thus, the cycle in action looks like this - a new class is added to the hierarchy of the visitable objects. </span><span class="koboSpan" id="kobo.505.9">The Visitor classes need to be updated with the new type. </span><span class="koboSpan" id="kobo.505.10">Since the base Visitor class was changed, the base visitable class and every line of code that depends on it must be recompiled, including the code that does not use the new visitable class, only the old ones. </span><span class="koboSpan" id="kobo.505.11">Even using forward declarations whenever possible does not help - if a new visitable class is added, all the old ones must </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">be recompiled.</span></span></p>
<p><span class="koboSpan" id="kobo.507.1">The additional problem of the traditional Visitor pattern is that every possible combination of the object type and the visitor type must be handled. </span><span class="koboSpan" id="kobo.507.2">Often there are cases when some combinations do not make sense, and certain objects will never be visited by some types of visitors. </span><span class="koboSpan" id="kobo.507.3">But we cannot take advantage of this as every combination must have a defined action (the action could be very simple, but still, every Visitor class must have the full set of </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">visit()</span></strong><span class="koboSpan" id="kobo.509.1"> member </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">functions defined).</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">The Acyclic Visitor pattern is a variant of the Visitor pattern that is specifically designed to break the dependency cycle and allow partial visitation. </span><span class="koboSpan" id="kobo.511.2">The base visitable class for the Acyclic Visitor</span><a id="_idIndexMarker1055"/><span class="koboSpan" id="kobo.512.1"> pattern is the same as for the regular </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">Visitor pattern:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.514.1">
// Example 10
class Pet {
  public:
  virtual ~Pet() {}
  virtual void accept(PetVisitor&amp; v) = 0;
  ...
</span><span class="koboSpan" id="kobo.514.2">};</span></pre>
<p><span class="koboSpan" id="kobo.515.1">However, that is where the similarity ends. </span><span class="koboSpan" id="kobo.515.2">The base Visitor class does not have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">visit()</span></strong><span class="koboSpan" id="kobo.517.1"> overloads for every visitable. </span><span class="koboSpan" id="kobo.517.2">In fact, it has no </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">visit()</span></strong><span class="koboSpan" id="kobo.519.1"> member function </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">at all:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.521.1">
// Example 10
class PetVisitor {
  public:
  virtual ~PetVisitor() {}
};</span></pre>
<p><span class="koboSpan" id="kobo.522.1">So, who does the visiting then? </span><span class="koboSpan" id="kobo.522.2">For every derived class in the original hierarchy, we also declare the corresponding Visitor class, and that is where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">visit()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.524.1">function is:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.525.1">
// Example 10
class Cat;
class CatVisitor {
  public:
  virtual void visit(Cat* c) = 0;
};
class Cat : public Pet {
  public:
  Cat(std::string_view color) : Pet(color) {}
  void accept(PetVisitor&amp; v) override {
    if (CatVisitor* cv = dynamic_cast&lt;CatVisitor*&gt;(&amp;v)) {
      cv-&gt;visit(this);
    } else { // Handle error
      assert(false);
    }
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.526.1">Note that each visitor</span><a id="_idIndexMarker1056"/><span class="koboSpan" id="kobo.527.1"> can visit only the class it was designed for - the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">CatVisitor</span></strong><span class="koboSpan" id="kobo.529.1"> visits only </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">Cat</span></strong><span class="koboSpan" id="kobo.531.1"> objects, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">DogVisitor</span></strong><span class="koboSpan" id="kobo.533.1"> visits only </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">Dog</span></strong><span class="koboSpan" id="kobo.535.1"> objects, and so on. </span><span class="koboSpan" id="kobo.535.2">The magic is in the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">accept()</span></strong><span class="koboSpan" id="kobo.537.1"> function - when a class is asked to accept a visitor, it first uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">dynamic_cast</span></strong><span class="koboSpan" id="kobo.539.1"> to check whether this is the right type of visitor. </span><span class="koboSpan" id="kobo.539.2">If it is, all is well, and the visitor is accepted. </span><span class="koboSpan" id="kobo.539.3">If it isn’t, we have a problem and must handle the error (the exact mechanism of error handling depends on the application; for example, an exception can be thrown). </span><span class="koboSpan" id="kobo.539.4">The concrete Visitor classes, therefore, must be derived from both the common </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">PetVisitor</span></strong><span class="koboSpan" id="kobo.541.1"> base class and the class-specific base class such </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">CatVisitor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.545.1">
// Example 10
class FeedingVisitor : public PetVisitor,
                       public CatVisitor,
                       public DogVisitor {
  public:
  void visit(Cat* c) override {
    std::cout &lt;&lt; "Feed tuna to the " &lt;&lt; c-&gt;color()
              &lt;&lt; " cat" &lt;&lt; std::endl;
  }
  void visit(Dog* d) override {
    std::cout &lt;&lt; "Feed steak to the " &lt;&lt; d-&gt;color()
              &lt;&lt; " dog" &lt;&lt; std::endl;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.546.1">Each concrete visitor </span><a id="_idIndexMarker1057"/><span class="koboSpan" id="kobo.547.1">class is derived from the common visitor base and from every per-type visitor base (</span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">CatVisitor</span></strong><span class="koboSpan" id="kobo.549.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">DogVisitor</span></strong><span class="koboSpan" id="kobo.551.1">, and so on) for every type that must be handled by this visitor. </span><span class="koboSpan" id="kobo.551.2">On the other hand, if this visitor is not designed to visit some of the classes in the hierarchy, we can simply omit the corresponding visitor base, and then we won’t need to implement the virtual function </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">override either:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.553.1">
// Example 10
class BathingVisitor : public PetVisitor,
                       public DogVisitor
                       { // But no CatVisitor
  public:
  void visit(Dog* d) override {
    std::cout &lt;&lt; "Wash the " &lt;&lt; d-&gt;color()
              &lt;&lt; " dog" &lt;&lt; std::endl;
  }
  // No visit(Cat*) here!
</span><span class="koboSpan" id="kobo.553.2">};</span></pre>
<p><span class="koboSpan" id="kobo.554.1">The invocation of the Acyclic Visitor pattern is done in exactly the same way as with the regular </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">Visitor pattern:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.556.1">
// Example 10
std::unique_ptr&lt;Pet&gt; c(new Cat("orange"));
std::unique_ptr&lt;Pet&gt; d(new Dog("brown"));
FeedingVisitor fv;
c-&gt;accept(fv);
d-&gt;accept(fv);
BathingVisitor bv;
//c-&gt;accept(bv); // Error
d-&gt;accept(bv);</span></pre>
<p><span class="koboSpan" id="kobo.557.1">If we try to visit an </span><a id="_idIndexMarker1058"/><span class="koboSpan" id="kobo.558.1">object that is not supported by the particular Visitor, the error is detected. </span><span class="koboSpan" id="kobo.558.2">Therefore, we have solved the problem of partial visitation. </span><span class="koboSpan" id="kobo.558.3">What about the dependency cycle? </span><span class="koboSpan" id="kobo.558.4">That is taken care of as well - the common </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">PetVisitor</span></strong><span class="koboSpan" id="kobo.560.1"> base class does not need to list the complete hierarchy of visitable objects, and the concrete visitable classes depend only on their per-class visitors, but not on any visitors for other types. </span><span class="koboSpan" id="kobo.560.2">Therefore, when another visitable object is added to the hierarchy, the existing ones do not need to </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">be recompiled.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">The Acyclic Visitor pattern looks so good that one has to wonder, </span><em class="italic"><span class="koboSpan" id="kobo.563.1">why not use it all the time instead of the regular Visitor pattern?</span></em><span class="koboSpan" id="kobo.564.1"> There are a few reasons. </span><span class="koboSpan" id="kobo.564.2">First of all, the Acyclic Visitor pattern uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">dynamic_cast</span></strong><span class="koboSpan" id="kobo.566.1"> to cast from one base class to another (sometimes called cross-cast). </span><span class="koboSpan" id="kobo.566.2">This operation is typically more expensive than the virtual function call, so the Acyclic Visitor pattern is slower than the alternative. </span><span class="koboSpan" id="kobo.566.3">Also, the Acyclic Visitor pattern requires a Visitor class for every visitable class, so twice as many classes, and it uses multiple inheritance with a lot of base classes. </span><span class="koboSpan" id="kobo.566.4">That second issue is not much of a problem for most modern compilers, but many programmers find it difficult to deal with multiple inheritance. </span><span class="koboSpan" id="kobo.566.5">Whether the first issue - the runtime cost of the dynamic cast - is a problem depends on the application, but it is something you need to be aware of. </span><span class="koboSpan" id="kobo.566.6">On the other hand, the Acyclic Visitor pattern really shines when the visitable object hierarchy changes frequently or when the cost of recompiling the entire code base </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">is significant.</span></span></p>
<p><span class="koboSpan" id="kobo.568.1">You may have noticed one more issue with the Acyclic Visitor pattern  - it has a lot of boilerplate code. </span><span class="koboSpan" id="kobo.568.2">Several lines of code have to be copied for every visitable class. </span><span class="koboSpan" id="kobo.568.3">In fact, the regular Visitor pattern suffers from the same problem in that implementing either kind of visitor involves </span><a id="_idIndexMarker1059"/><span class="koboSpan" id="kobo.569.1">a lot of repetitive typing. </span><span class="koboSpan" id="kobo.569.2">But C++ has a special set of tools to replace code repetition with code reuse: that is exactly what generic programming is fo</span><a id="_idTextAnchor810"/><span class="koboSpan" id="kobo.570.1">r</span><a id="_idTextAnchor811"/><span class="koboSpan" id="kobo.571.1">. </span><span class="koboSpan" id="kobo.571.2">We shall see next how the Visitor pattern is adapted to </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">modern C++.</span></span></p>
<h1 id="_idParaDest-311"><a id="_idTextAnchor812"/><span class="koboSpan" id="kobo.573.1">Visitors in modern C++</span></h1>
<p><span class="koboSpan" id="kobo.574.1">As we have just seen, the </span><a id="_idIndexMarker1060"/><span class="koboSpan" id="kobo.575.1">Visitor pattern promotes the separation of </span><a id="_idIndexMarker1061"/><span class="koboSpan" id="kobo.576.1">concerns; for example, the order of serialization and the mechanism of serialization are made independent, and a separate class is responsible for each. </span><span class="koboSpan" id="kobo.576.2">The pattern also simplifies code maintenance by collecting all code that performs a given task in one place. </span><span class="koboSpan" id="kobo.576.3">What the Visitor pattern does not promote is code reuse with no duplication. </span><span class="koboSpan" id="kobo.576.4">But that’s the object-oriented Visitor pattern, before modern C++. </span><span class="koboSpan" id="kobo.576.5">Let’s see what we can do with the</span><a id="_idTextAnchor813"/> <a id="_idTextAnchor814"/><span class="koboSpan" id="kobo.577.1">generic capabilities of C++, starting from the regular </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">Visitor pattern.</span></span></p>
<h2 id="_idParaDest-312"><a id="_idTextAnchor815"/><span class="koboSpan" id="kobo.579.1">Generic Visitor</span></h2>
<p><span class="koboSpan" id="kobo.580.1">We are going to</span><a id="_idIndexMarker1062"/><span class="koboSpan" id="kobo.581.1"> try to reduce the boilerplate code in the</span><a id="_idIndexMarker1063"/><span class="koboSpan" id="kobo.582.1"> implementation of the Visitor pattern. </span><span class="koboSpan" id="kobo.582.2">Let’s start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">accept()</span></strong><span class="koboSpan" id="kobo.584.1"> member function, which must be copied into every visitable class; it always looks </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">the same:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.586.1">
class Cat : public Pet {
  void accept(PetVisitor&amp; v) override { v.visit(this); }
};</span></pre>
<p><span class="koboSpan" id="kobo.587.1">This function cannot be moved to the base class because we need to call the visitor with the actual type, not the base type - </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">visit()</span></strong><span class="koboSpan" id="kobo.589.1"> accepts </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">Cat*</span></strong><span class="koboSpan" id="kobo.591.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">Dog*</span></strong><span class="koboSpan" id="kobo.593.1">, and so on, but not </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">Pet*</span></strong><span class="koboSpan" id="kobo.595.1">. </span><span class="koboSpan" id="kobo.595.2">We can get a template to generate this function for us if we introduce an intermediate</span><a id="_idIndexMarker1064"/><span class="koboSpan" id="kobo.596.1"> templated </span><a id="_idIndexMarker1065"/><span class="No-Break"><span class="koboSpan" id="kobo.597.1">base class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.598.1">
// Example 11
class Pet { // Same as before
  public:
  virtual ~Pet() {}
  Pet(std::string_view color) : color_(color) {}
  const std::string&amp; color() const { return color_; }
  virtual void accept(PetVisitor&amp; v) = 0;
  private:
  std::string color_;
};
template &lt;typename Derived&gt;
class Visitable : public Pet {
  public:
  using Pet::Pet;
  void accept(PetVisitor&amp; v) override {
    v.visit(static_cast&lt;Derived*&gt;(this));
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.599.1">The template is parameterized by the derived class. </span><span class="koboSpan" id="kobo.599.2">In this regard, it is similar to the </span><strong class="bold"><span class="koboSpan" id="kobo.600.1">Curiously Recurring Template Pattern</span></strong><span class="koboSpan" id="kobo.601.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.602.1">CRTP</span></strong><span class="koboSpan" id="kobo.603.1">), but here we do not inherit from the template</span><a id="_idIndexMarker1066"/><span class="koboSpan" id="kobo.604.1"> parameter - we use it to cast the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">this</span></strong><span class="koboSpan" id="kobo.606.1"> pointer to the correct derived class pointer. </span><span class="koboSpan" id="kobo.606.2">Now we just need to derive each pet class from the right instantiation of the template, and we get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">accept()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.608.1">function automatically:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.609.1">
// Example 11
class Cat : public Visitable&lt;Cat&gt; {
  using Visitable&lt;Cat&gt;::Visitable;
};
class Dog : public Visitable&lt;Dog&gt; {
  using Visitable&lt;Dog&gt;::Visitable;
};</span></pre>
<p><span class="koboSpan" id="kobo.610.1">That takes care of half of the boilerplate code - the code inside the derived visitable objects. </span><span class="koboSpan" id="kobo.610.2">Now there is only the other half left: the code inside the Visitor classes, where we have to type the same declaration over and over again for every visitable class. </span><span class="koboSpan" id="kobo.610.3">We can’t do much about the specific visitors; after all, that’s where the real work is done, and, presumably, we need to do different things for different visitable classes (otherwise why </span><a id="_idIndexMarker1067"/><span class="koboSpan" id="kobo.611.1">use double dispatch </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">at </span></span><span class="No-Break"><a id="_idIndexMarker1068"/></span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">all?)</span></span></p>
<p><span class="koboSpan" id="kobo.614.1">However, we can simplify the declaration of the base Visitor class if we introduce this generic </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">Visitor template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.616.1">
// Example 12
template &lt;typename ... </span><span class="koboSpan" id="kobo.616.2">Types&gt; class Visitor;
template &lt;typename T&gt; class Visitor&lt;T&gt; {
  public:
  virtual void visit(T* t) = 0;
};
template &lt;typename T, typename ... </span><span class="koboSpan" id="kobo.616.3">Types&gt;
class Visitor&lt;T, Types ...&gt; : public Visitor&lt;Types ...&gt; {
  public:
  using Visitor&lt;Types ...&gt;::visit;
  virtual void visit(T* t) = 0;
};</span></pre>
<p><span class="koboSpan" id="kobo.617.1">Note that we have to implement this template only once: not once for each class hierarchy, but once forever (or at least until we need to change the signature of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">visit()</span></strong><span class="koboSpan" id="kobo.619.1"> function, for example, to add arguments). </span><span class="koboSpan" id="kobo.619.2">This is a good generic library class. </span><span class="koboSpan" id="kobo.619.3">Once we have it, declaring a visitor base for a particular class hierarchy becomes so trivial that it </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">feels anticlimactic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.621.1">
// Example 12</span></pre>
<p><span class="koboSpan" id="kobo.622.1">Notice the somewhat unusual syntax with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">class</span></strong><span class="koboSpan" id="kobo.624.1"> keyword - it combines the template argument list with a forward declaration and is equivalent to </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.626.1">
class Cat;
class Dog;
using PetVisitor = Visitor&lt;Cat, Dog&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.627.1">How does the Generic Visitor base work? </span><span class="koboSpan" id="kobo.627.2">It uses the variadic template to capture an arbitrary number of type arguments, but the primary template is only declared, not defined. </span><span class="koboSpan" id="kobo.627.3">The rest are specializations. </span><span class="koboSpan" id="kobo.627.4">First, we have the special case of one type argument. </span><span class="koboSpan" id="kobo.627.5">We declare the pure </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">visit()</span></strong><span class="koboSpan" id="kobo.629.1"> virtual member function for that type. </span><span class="koboSpan" id="kobo.629.2">Then we have a specialization for more than one type argument, where the first argument is explicit, and </span><a id="_idIndexMarker1069"/><span class="koboSpan" id="kobo.630.1">the </span><a id="_idIndexMarker1070"/><span class="koboSpan" id="kobo.631.1">rest are in the parameter pack. </span><span class="koboSpan" id="kobo.631.2">We generate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">visit()</span></strong><span class="koboSpan" id="kobo.633.1"> function for the explicitly specified type and inherit the rest of them from an instantiation of the same variadic template but with one less argument. </span><span class="koboSpan" id="kobo.633.2">The instantiation is recursive until we are down to only one type argument, and then the first specialization </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">is used.</span></span></p>
<p><span class="koboSpan" id="kobo.635.1">This generic and reusable code has one restriction: it does not handle deep hierarchies. </span><span class="koboSpan" id="kobo.635.2">Recall that each visitable class is derived from a </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">common base:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.637.1">
template &lt;typename Derived&gt;
class Visitable : public Pet {...};
class Cat : public Visitable&lt;Cat&gt; {...};</span></pre>
<p><span class="koboSpan" id="kobo.638.1">If we were to derive another class from </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">Cat</span></strong><span class="koboSpan" id="kobo.640.1">, it would have to be derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">Visitable</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.642.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.643.1">
class SiameseCat : public Cat,
                   public Visitable&lt;SiameseCat&gt; {...};</span></pre>
<p><span class="koboSpan" id="kobo.644.1">We cannot just derive </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">SiameseCat</span></strong><span class="koboSpan" id="kobo.646.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">Cat</span></strong><span class="koboSpan" id="kobo.648.1"> because it is the Visitable template that provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">accept()</span></strong><span class="koboSpan" id="kobo.650.1"> method for each derived class. </span><span class="koboSpan" id="kobo.650.2">But we can’t use the double inheritance as we just tried either, because now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">SiameseCat</span></strong><span class="koboSpan" id="kobo.652.1"> class inherits from Pet twice: once through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">Cat</span></strong><span class="koboSpan" id="kobo.654.1"> base and once through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">Visitable</span></strong><span class="koboSpan" id="kobo.656.1"> base. </span><span class="koboSpan" id="kobo.656.2">The only solution to this, if you still want to use the templates to generate </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">accept()</span></strong><span class="koboSpan" id="kobo.658.1"> methods, is to separate the hierarchy so each visitable class such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">Cat</span></strong><span class="koboSpan" id="kobo.660.1"> inherits from </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">Visitable</span></strong><span class="koboSpan" id="kobo.662.1"> and from a corresponding base class </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">CatBase</span></strong><span class="koboSpan" id="kobo.664.1"> that has all the “cat-specific” functionality except for the visitation support. </span><span class="koboSpan" id="kobo.664.2">This doubles the number of classes</span><a id="_idIndexMarker1071"/><span class="koboSpan" id="kobo.665.1"> in the hierarchy and is a </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">major </span></span><span class="No-Break"><a id="_idIndexMarker1072"/></span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">drawback.</span></span></p>
<p><span class="koboSpan" id="kobo.668.1">Now that we have the boilerplate visitor co</span><a id="_idTextAnchor816"/><span class="koboSpan" id="kobo.669.1">d</span><a id="_idTextAnchor817"/><span class="koboSpan" id="kobo.670.1">e generated by templates, we can also make it simpler to define </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">concrete visitors.</span></span></p>
<h2 id="_idParaDest-313"><a id="_idTextAnchor818"/><span class="koboSpan" id="kobo.672.1">Lambda Visitor</span></h2>
<p><span class="koboSpan" id="kobo.673.1">Most of the work</span><a id="_idIndexMarker1073"/><span class="koboSpan" id="kobo.674.1"> in defining a concrete visitor is </span><a id="_idIndexMarker1074"/><span class="koboSpan" id="kobo.675.1">writing code for the actual work that has to happen for every visitable object. </span><span class="koboSpan" id="kobo.675.2">There is not a lot of boilerplate code in a specific visitor class. </span><span class="koboSpan" id="kobo.675.3">But sometimes we may not want to declare the class itself. </span><span class="koboSpan" id="kobo.675.4">Think about lambda expressions - anything that can be done with a lambda expression can also be done with an explicitly declared callable class because lambdas are (anonymous) callable classes. </span><span class="koboSpan" id="kobo.675.5">Nonetheless, we find lambda expressions very useful for writing one-off callable objects. </span><span class="koboSpan" id="kobo.675.6">Similarly, we may want to write a visitor without explicitly naming it - a lambda Visitor. </span><span class="koboSpan" id="kobo.675.7">We would want it to look something </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.677.1">
auto v(lambda_visitor&lt;PetVisitor&gt;(
  [](Cat* c) { std::cout &lt;&lt; "Let the " &lt;&lt; c-&gt;color()
                         &lt;&lt; " cat out" &lt;&lt; std::endl;
  },
  [](Dog* d) { std::cout &lt;&lt; "Take the " &lt;&lt; d-&gt;color()
                         &lt;&lt; " dog for a walk" &lt;&lt; std::endl;
  }
));
pet-&gt;accept(v);</span></pre>
<p><span class="koboSpan" id="kobo.678.1">There are two problems to be solved - how to create a class that handles a list of types and corresponding objects (in our case, the visitable types and the corresponding lambdas), and how to generate a set of overloaded functions using </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">lambda expressions.</span></span></p>
<p><span class="koboSpan" id="kobo.680.1">The former problem will require us to recursively instantiate a template on the parameter pack, peeling off one argument at a time. </span><span class="koboSpan" id="kobo.680.2">The solution to the latter problem is similar to the overload set of the lambda expression, which was described in the chapter on class templates. </span><span class="koboSpan" id="kobo.680.3">We could use the overload set from that chapter, but we can use the recursive template instantiation that we need anyway, to build the overloaded set of </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">functions directly.</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">There is going to be one new challenge in this implementation - we have to process not one but two lists of types. </span><span class="koboSpan" id="kobo.682.2">The first list has all visitable types in it; in our case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">Cat</span></strong><span class="koboSpan" id="kobo.684.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">Dog</span></strong><span class="koboSpan" id="kobo.686.1">. </span><span class="koboSpan" id="kobo.686.2">The second list has the types of lambda expressions, one for each visitable type. </span><span class="koboSpan" id="kobo.686.3">We have not seen a variadic template with two parameter packs yet, and for a good reason - it is not possible to simply declare </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">template&lt;typename... </span><span class="koboSpan" id="kobo.687.2">A, typename... </span><span class="koboSpan" id="kobo.687.3">B&gt;</span></strong><span class="koboSpan" id="kobo.688.1"> as the compiler would not know where the first list ends and the second begins. </span><span class="koboSpan" id="kobo.688.2">The trick is to hide one or both lists of types inside other templates. </span><span class="koboSpan" id="kobo.688.3">In our case, we already have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">Visitor</span></strong><span class="koboSpan" id="kobo.690.1"> template that is instantiated on the list of </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">visitable types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.692.1">
using PetVisitor = Visitor&lt;class Cat, class Dog&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.693.1">We can extract</span><a id="_idIndexMarker1075"/><span class="koboSpan" id="kobo.694.1"> this list from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">Visitor</span></strong><span class="koboSpan" id="kobo.696.1"> template </span><a id="_idIndexMarker1076"/><span class="koboSpan" id="kobo.697.1">and match each type with its lambda expression. </span><span class="koboSpan" id="kobo.697.2">The partial specialization syntax used to process two parameter packs in sync is tricky, so we will work through it in steps. </span><span class="koboSpan" id="kobo.697.3">First of all, we need to declare the general template for our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">LambdaVisitor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.699.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.700.1">
// Example 13
template &lt;typename Base, typename...&gt;
class LambdaVisitor;</span></pre>
<p><span class="koboSpan" id="kobo.701.1">Note that there is only one general parameter pack here, plus the base class for the visitor (in our case, it will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">PetVisitor</span></strong><span class="koboSpan" id="kobo.703.1">). </span><span class="koboSpan" id="kobo.703.2">This template must be declared, but it is never going to be used - we will provide a specialization for every case that needs to be handled. </span><span class="koboSpan" id="kobo.703.3">The first specialization is used when there is only one visitable type and one corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">lambda expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.705.1">
// Example 13
template &lt;typename Base, typename T1, typename F1&gt;
class LambdaVisitor&lt;Base, Visitor&lt;T1&gt;, F1&gt; :
  private F1, public Base
{
  public:
  LambdaVisitor(F1&amp;&amp; f1) : F1(std::move(f1)) {}
  LambdaVisitor(const F1&amp; f1) : F1(f1) {}
  using Base::visit;
  void visit(T1* t) override { return F1::operator()(t); }
};</span></pre>
<p><span class="koboSpan" id="kobo.706.1">This specialization, in addition to handling the case where we have only one visitable type, is used as the last instantiation in every chain of recursive template instantiations. </span><span class="koboSpan" id="kobo.706.2">Since it is always the first base class in the recursive hierarchy of </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">LambdaVisitor</span></strong><span class="koboSpan" id="kobo.708.1"> instantiations, it is the only one that directly inherits from the base Visitor class such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">PetVisitor</span></strong><span class="koboSpan" id="kobo.710.1">. </span><span class="koboSpan" id="kobo.710.2">Note that, even with a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">T1</span></strong><span class="koboSpan" id="kobo.712.1"> visitable type, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">Visitor</span></strong><span class="koboSpan" id="kobo.714.1"> template as a wrapper for it. </span><span class="koboSpan" id="kobo.714.2">This is done in preparation for the general case where we will have a list of types whose length is unknown. </span><span class="koboSpan" id="kobo.714.3">The two constructors store the </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">f1</span></strong><span class="koboSpan" id="kobo.716.1"> lambda expression</span><a id="_idIndexMarker1077"/><span class="koboSpan" id="kobo.717.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">LambdaVisitor</span></strong><span class="koboSpan" id="kobo.719.1"> class, using </span><a id="_idIndexMarker1078"/><span class="koboSpan" id="kobo.720.1">move instead of copy if possible. </span><span class="koboSpan" id="kobo.720.2">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">visit(T1*)</span></strong><span class="koboSpan" id="kobo.722.1"> virtual function override simply forwards the call to the lambda expression. </span><span class="koboSpan" id="kobo.722.2">It may appear simpler, at first glance, to inherit publicly from </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">F1</span></strong><span class="koboSpan" id="kobo.724.1"> and just agree to use the functional calling syntax (in other words, to rename all calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">visit()</span></strong><span class="koboSpan" id="kobo.726.1"> to calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">operator()</span></strong><span class="koboSpan" id="kobo.728.1"> everywhere). </span><span class="koboSpan" id="kobo.728.2">This is not going to work; we need the indirection because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">operator()</span></strong><span class="koboSpan" id="kobo.730.1"> instance of the lambda expression itself cannot be a virtual function override. </span><span class="koboSpan" id="kobo.730.2">By the way, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">override</span></strong><span class="koboSpan" id="kobo.732.1"> keyword here is invaluable in detecting bugs in code where the template is not inherited from the right base class or the virtual function declarations do not </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">match exactly.</span></span></p>
<p><span class="koboSpan" id="kobo.734.1">The general case of any number of visitable types and lambda expressions is handled by this partial specialization, which explicitly deals with the first types in both lists, then recursively instantiates itself to process the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">the lists:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.736.1">
// Example 13
template &lt;typename Base,
          typename T1, typename... </span><span class="koboSpan" id="kobo.736.2">T,
          typename F1, typename... </span><span class="koboSpan" id="kobo.736.3">F&gt;
class LambdaVisitor&lt;Base, Visitor&lt;T1, T...&gt;, F1, F...&gt; :
  private F1,
  public LambdaVisitor&lt;Base, Visitor&lt;T ...&gt;, F ...&gt;
{
  public:
  LambdaVisitor(F1&amp;&amp; f1, F&amp;&amp; ... </span><span class="koboSpan" id="kobo.736.4">f) :
    F1(std::move(f1)),
    LambdaVisitor&lt;Base, Visitor&lt;T...&gt;, F...&gt;(
      std::forward&lt;F&gt;(f)...)
  {}
  LambdaVisitor(const F1&amp; f1, F&amp;&amp; ... </span><span class="koboSpan" id="kobo.736.5">f) :
    F1(f1),
    LambdaVisitor&lt;Base, Visitor&lt;T...&gt;, F...&gt;(
      std::forward&lt;F&gt;(f) ...)
  {}
  using LambdaVisitor&lt;Base, Visitor&lt;T ...&gt;, F ...&gt;::visit;
  void visit(T1* t) override { return F1::operator()(t); }
};</span></pre>
<p><span class="koboSpan" id="kobo.737.1">Again, we have </span><a id="_idIndexMarker1079"/><span class="koboSpan" id="kobo.738.1">two</span><a id="_idIndexMarker1080"/><span class="koboSpan" id="kobo.739.1"> constructors that store the first lambda expression in the class and forward the rest to the next instantiation. </span><span class="koboSpan" id="kobo.739.2">One virtual function override is generated on each step of the recursion, always for the first type in the remaining list of the visitable classes. </span><span class="koboSpan" id="kobo.739.3">That type is then removed from the list, and the processing continues in the same manner until we reach the last instantiation, the one for a single </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">visitable type.</span></span></p>
<p><span class="koboSpan" id="kobo.741.1">Since it is not possible to explicitly name the types of lambda expressions, we also cannot explicitly declare the type of the lambda visitor. </span><span class="koboSpan" id="kobo.741.2">Instead, the lambda expression types must be deduced by the template argument deduction, so we need a </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">lambda_visitor()</span></strong><span class="koboSpan" id="kobo.743.1"> template function that accepts multiple lambda expression arguments and constructs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">LambdaVisitor</span></strong><span class="koboSpan" id="kobo.745.1"> object from all </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">of them:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.747.1">
// Example 13
template &lt;typename Base, typename ... </span><span class="koboSpan" id="kobo.747.2">F&gt;
auto lambda_visitor(F&amp;&amp; ... </span><span class="koboSpan" id="kobo.747.3">f) {
  return LambdaVisitor&lt;Base, Base, F...&gt;(
    std::forward&lt;F&gt;(f) ...);
}</span></pre>
<p><span class="koboSpan" id="kobo.748.1">In C++17, the same can be accomplished with a deduction guide. </span><span class="koboSpan" id="kobo.748.2">Now that we have a class that stores any number of lambda expressions and binds each one to the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">visit()</span></strong><span class="koboSpan" id="kobo.750.1"> override, we can write lambda visitors just as easily as we write</span><a id="_idIndexMarker1081"/> <span class="No-Break"><span class="koboSpan" id="kobo.751.1">lambda </span></span><span class="No-Break"><a id="_idIndexMarker1082"/></span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">expressions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.753.1">
// Example 13
void walk(Pet&amp; p) {
  auto v(lambda_visitor&lt;PetVisitor&gt;(
  [](Cat* c){std::cout &lt;&lt; "Let the " &lt;&lt; c-&gt;color()
                         &lt;&lt; " cat out" &lt;&lt; std::endl;},
  [](Dog* d){std::cout &lt;&lt; "Take the " &lt;&lt; d-&gt;color()
                       &lt;&lt; " dog for a walk" &lt;&lt; std::endl;}
  ));
  p.accept(v);
}</span></pre>
<p><span class="koboSpan" id="kobo.754.1">Note that, because of the way we declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">visit()</span></strong><span class="koboSpan" id="kobo.756.1"> function in the same class that inherits from the corresponding lambda expression, the order of the lambda expression in the argument list of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">lambda_visitor()</span></strong><span class="koboSpan" id="kobo.758.1"> function must match the order of classes in the list of types in </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">PetVisitor</span></strong><span class="koboSpan" id="kobo.760.1"> definition. </span><span class="koboSpan" id="kobo.760.2">This restriction can be removed, if desired, at the cost of some additional complexity of </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">the implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.762.1">Another common way of dealing with type lists in C++ is to store them in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">std::tuple</span></strong><span class="koboSpan" id="kobo.764.1">: for example, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">std::tuple&lt;Cat, Dog&gt;</span></strong><span class="koboSpan" id="kobo.766.1"> to represent a list consisting of the two types. </span><span class="koboSpan" id="kobo.766.2">Similarly, an entire parameter pack can be stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">a tuple:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.768.1">
// Example 14
template &lt;typename Base, typename F1, typename... </span><span class="koboSpan" id="kobo.768.2">F&gt;
class LambdaVisitor&lt;Base, std::tuple&lt;F1, F...&gt;&gt; :
  public F1, public LambdaVisitor&lt;Base, std::tuple&lt;F...&gt;&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.769.1">You can compare examples 13 and 14 to see how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">std::tuple</span></strong><span class="koboSpan" id="kobo.771.1"> to store a </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">type list.</span></span></p>
<p><span class="koboSpan" id="kobo.773.1">We have now seen how the common fragments of the visitor code can be turned into reusable templates, and how this, in turn, lets us create a lambda visitor. </span><span class="koboSpan" id="kobo.773.2">But we have not forgotten the </span><a id="_idIndexMarker1083"/><span class="koboSpan" id="kobo.774.1">other visitor implementation we</span><a id="_idIndexMarker1084"/><span class="koboSpan" id="kobo.775.1"> learned in this chapter, the Acy</span><a id="_idTextAnchor819"/><span class="koboSpan" id="kobo.776.1">c</span><a id="_idTextAnchor820"/><span class="koboSpan" id="kobo.777.1">lic Visitor pattern. </span><span class="koboSpan" id="kobo.777.2">Let’s see how it, too, can benefit from the modern C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">language features.</span></span></p>
<h2 id="_idParaDest-314"><a id="_idTextAnchor821"/><span class="koboSpan" id="kobo.779.1">Generic Acyclic Visitor</span></h2>
<p><span class="koboSpan" id="kobo.780.1">The Acyclic Visitor pattern </span><a id="_idIndexMarker1085"/><span class="koboSpan" id="kobo.781.1">does not need a </span><a id="_idIndexMarker1086"/><span class="koboSpan" id="kobo.782.1">base class with a list of all visitable types. </span><span class="koboSpan" id="kobo.782.2">However, it has its own share of boilerplate code. </span><span class="koboSpan" id="kobo.782.3">First of all, each visitable type needs the </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">accept()</span></strong><span class="koboSpan" id="kobo.784.1"> member function, and it has more code than the similar function in the original </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">Visitor pattern:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.786.1">
// Example 10
class Cat : public Pet {
  public:
  void accept(PetVisitor&amp; v) override {
    if (CatVisitor* cv = dynamic_cast&lt;CatVisitor*&gt;(&amp;v)) {
      cv-&gt;visit(this);
    } else { // Handle error
      assert(false);
    }
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.787.1">Assuming that the error handling is uniform, this function is repeated over and over for different types of visitors, each corresponding to its visitable type (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">CatVisitor</span></strong><span class="koboSpan" id="kobo.789.1"> here). </span><span class="koboSpan" id="kobo.789.2">Then there is the per-type Visitor class itself, </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.791.1">
class CatVisitor {
  public:
  virtual void visit(Cat* c) = 0;
};</span></pre>
<p><span class="koboSpan" id="kobo.792.1">Again, this code is pasted all over the program, with slight modifications. </span><span class="koboSpan" id="kobo.792.2">Let’s convert this error-prone code duplication into easy-to-maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">reusable code.</span></span></p>
<p><span class="koboSpan" id="kobo.794.1">We will need to create some infrastructure first. </span><span class="koboSpan" id="kobo.794.2">The Acyclic Visitor pattern bases its hierarchy on a</span><a id="_idIndexMarker1087"/><span class="koboSpan" id="kobo.795.1"> common base class for all </span><a id="_idIndexMarker1088"/><span class="koboSpan" id="kobo.796.1">visitors, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.798.1">
class PetVisitor {
  public:
  virtual ~PetVisitor() {}
};</span></pre>
<p><span class="koboSpan" id="kobo.799.1">Note that there is nothing specific to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">Pet</span></strong><span class="koboSpan" id="kobo.801.1"> hierarchy here. </span><span class="koboSpan" id="kobo.801.2">With a better name, this class can serve as a base class for any </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">visitor hierarchy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.803.1">
// Example 15
class VisitorBase {
  public:
  virtual ~VisitorBase() {}
};</span></pre>
<p><span class="koboSpan" id="kobo.804.1">We also need a template to generate all these Visitor base classes specific to visitable types, to replace the near-identical </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">CatVisitor</span></strong><span class="koboSpan" id="kobo.806.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">DogVisitor</span></strong><span class="koboSpan" id="kobo.808.1">, and so on. </span><span class="koboSpan" id="kobo.808.2">Since all that is needed from these classes is the declaration of the pure virtual </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">visit()</span></strong><span class="koboSpan" id="kobo.810.1"> method, we can parameterize the template by the </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">visitable type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.812.1">
// Example 15
template &lt;typename Visitable&gt; class Visitor {
  public:
  virtual void visit(Visitable* p) = 0;
};</span></pre>
<p><span class="koboSpan" id="kobo.813.1">The base visitable class for any class hierarchy now accepts visitors using the common </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">VisitorBase</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.815.1">base class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.816.1">
// Example 15
class Pet {
  ...
</span><span class="koboSpan" id="kobo.816.2">  virtual void accept(VisitorBase&amp; v) = 0;
};</span></pre>
<p><span class="koboSpan" id="kobo.817.1">Instead of deriving each visitable class directly from </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">Pet</span></strong><span class="koboSpan" id="kobo.819.1"> and pasting a copy of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">accept()</span></strong><span class="koboSpan" id="kobo.821.1"> method, we introduce an intermediate template base class that can generate this </span><a id="_idIndexMarker1089"/><span class="koboSpan" id="kobo.822.1">method </span><a id="_idIndexMarker1090"/><span class="koboSpan" id="kobo.823.1">with the </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">correct types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.825.1">
// Example 15
template &lt;typename Visitable&gt;
class PetVisitable : public Pet {
  public:
  using Pet::Pet;
  void accept(VisitorBase&amp; v) override {
    if (Visitor&lt;Visitable&gt;* pv =
        dynamic_cast&lt;Visitor&lt;Visitable&gt;*&gt;(&amp;v)) {
      pv-&gt;visit(static_cast&lt;Visitable*&gt;(this));
    } else { // Handle error
      assert(false);
    }
 }
};</span></pre>
<p><span class="koboSpan" id="kobo.826.1">This is the only copy of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">accept()</span></strong><span class="koboSpan" id="kobo.828.1"> function we need to write, and it contains the preferred error handling implementation for our application to deal with cases when the visitor is not accepted by the base class (recall that Acyclic Visitor allows partial visitation, where some combinations of the visitor and visitable are not supported). </span><span class="koboSpan" id="kobo.828.2">Just like for the regular Visitor, the intermediate CRTP base class makes it hard to use deep hierarchies with </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">this approach.</span></span></p>
<p><span class="koboSpan" id="kobo.830.1">The concrete visitable classes inherit from the common </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">Pet</span></strong><span class="koboSpan" id="kobo.832.1"> base class indirectly, through the intermediate </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">PetVisitable</span></strong><span class="koboSpan" id="kobo.834.1"> base class, which also provides them with the visitable interface. </span><span class="koboSpan" id="kobo.834.2">The argument to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">PetVisitable</span></strong><span class="koboSpan" id="kobo.836.1"> template is the derived class </span><a id="_idIndexMarker1091"/><span class="koboSpan" id="kobo.837.1">itself (again, we</span><a id="_idIndexMarker1092"/><span class="koboSpan" id="kobo.838.1"> see the CRTP </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">in action):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.840.1">
// Example 15
class Cat : public PetVisitable&lt;Cat&gt; {
  using PetVisitable&lt;Cat&gt;::PetVisitable;
};
class Dog : public PetVisitable&lt;Dog&gt; {
  using PetVisitable&lt;Dog&gt;::PetVisitable;
};</span></pre>
<p><span class="koboSpan" id="kobo.841.1">It is, of course, not mandatory to use the same base class constructors for all derived classes, as custom constructors can be defined in every class </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">as needed.</span></span></p>
<p><span class="koboSpan" id="kobo.843.1">The only thing left is to implement the Visitor class. </span><span class="koboSpan" id="kobo.843.2">Recall that the specific visitor in the Acyclic Visitor pattern inherits from the common visitor base and each of the visitor classes that represent the supported visitable types. </span><span class="koboSpan" id="kobo.843.3">That is not going to change, but we now have a way to generate these visitor classes </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">on demand:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.845.1">
// Example 15
class FeedingVisitor : public VisitorBase,
                       public Visitor&lt;Cat&gt;,
                       public Visitor&lt;Dog&gt;
{
  public:
  void visit(Cat* c) override {
    std::cout &lt;&lt; "Feed tuna to the " &lt;&lt; c-&gt;color()
              &lt;&lt; " cat" &lt;&lt; std::endl;
  }
  void visit(Dog* d) override {
    std::cout &lt;&lt; "Feed steak to the " &lt;&lt; d-&gt;color()
              &lt;&lt; " dog" &lt;&lt; std::endl;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.846.1">Let’s look back at the work we have done - the parallel hierarchy of visitor classes no longer needs to be typed explicitly; instead, they are generated as needed. </span><span class="koboSpan" id="kobo.846.2">The repetitive </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">accept()</span></strong><span class="koboSpan" id="kobo.848.1"> functions are reduced to the single </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">PetVisitable</span></strong><span class="koboSpan" id="kobo.850.1"> class template. </span><span class="koboSpan" id="kobo.850.2">Still, we have to write this template for every new visitable class hierarchy. </span><span class="koboSpan" id="kobo.850.3">We can generalize </span><a id="_idIndexMarker1093"/><span class="koboSpan" id="kobo.851.1">this too, and create a single</span><a id="_idIndexMarker1094"/><span class="koboSpan" id="kobo.852.1"> reusable template for all hierarchies, parameterized by the base </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">visitable class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.854.1">
// Example 16
template &lt;typename Base, typename Visitable&gt;
class VisitableBase : public Base {
  public:
  using Base::Base;
  void accept(VisitorBase&amp; vb) override {
    if (Visitor&lt;Visitable&gt;* v = 
        dynamic_cast&lt;Visitor&lt;Visitable&gt;*&gt;(&amp;vb)) {
      v-&gt;visit(static_cast&lt;Visitable*&gt;(this));
    } else { // Handle error
      assert(false);
    }
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.855.1">Now, for every visitable class hierarchy, we just need to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">template alias:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.857.1">
// Example 16
template &lt;typename Visitable&gt;
using PetVisitable = VisitableBase&lt;Pet, Visitable&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.858.1">We can make one more simplification and allow the programmer to specify the list of visitable classes as a list of types, instead of inheriting from </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">Visitor&lt;Cat&gt;</span></strong><span class="koboSpan" id="kobo.860.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">Visitor&lt;Dog&gt;</span></strong><span class="koboSpan" id="kobo.862.1">, and so on, as we have done previously. </span><span class="koboSpan" id="kobo.862.2">This requires a variadic template to store the list of types. </span><span class="koboSpan" id="kobo.862.3">The </span><a id="_idIndexMarker1095"/><span class="koboSpan" id="kobo.863.1">implementation is</span><a id="_idIndexMarker1096"/><span class="koboSpan" id="kobo.864.1"> similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">LambdaVisitor</span></strong><span class="koboSpan" id="kobo.866.1"> instance we </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">saw earlier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.868.1">
// Example 17
template &lt;typename ... </span><span class="koboSpan" id="kobo.868.2">V&gt; struct Visitors;
template &lt;typename V1&gt;
struct Visitors&lt;V1&gt; : public Visitor&lt;V1&gt; {};
template &lt;typename V1, typename ... </span><span class="koboSpan" id="kobo.868.3">V&gt;
struct Visitors&lt;V1, V ...&gt; : public Visitor&lt;V1&gt;,
                             public Visitors&lt;V ...&gt; {};</span></pre>
<p><span class="koboSpan" id="kobo.869.1">We can use this wrapper template to shorten the declarations of the </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">specific visitors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.871.1">
// Example 17
class FeedingVisitor :
  public VisitorBase, public Visitors&lt;Cat, Dog&gt;
{
  ...
</span><span class="koboSpan" id="kobo.871.2">};</span></pre>
<p><span class="koboSpan" id="kobo.872.1">If desired, we can even hide </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">VisitorBase</span></strong><span class="koboSpan" id="kobo.874.1"> in the definition of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">Visitors</span></strong><span class="koboSpan" id="kobo.876.1"> template for the single </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">type argument.</span></span></p>
<p><span class="koboSpan" id="kobo.878.1">We have now seen both the classic object-oriented Visitor pattern and its reusable implementations, made </span><a id="_idIndexMarker1097"/><span class="koboSpan" id="kobo.879.1">possible by the generic</span><a id="_idIndexMarker1098"/><span class="koboSpan" id="kobo.880.1"> programming tools of C++. </span><span class="koboSpan" id="kobo.880.2">In the earlier chapters, we have seen how some patterns can b</span><a id="_idTextAnchor822"/><span class="koboSpan" id="kobo.881.1">e</span><a id="_idTextAnchor823"/><span class="koboSpan" id="kobo.882.1"> applied entirely at compile time. </span><span class="koboSpan" id="kobo.882.2">Let’s now consider whether the same can be done with the </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">Visitor pattern.</span></span></p>
<h1 id="_idParaDest-315"><a id="_idTextAnchor824"/><span class="koboSpan" id="kobo.884.1">Compile-time Visitor</span></h1>
<p><span class="koboSpan" id="kobo.885.1">In this section, we will</span><a id="_idIndexMarker1099"/><span class="koboSpan" id="kobo.886.1"> analyze the possibility of using the Visitor pattern at compile time, in a similar fashion to, say, the application of the Strategy pattern that leads to </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">policy-based design.</span></span></p>
<p><span class="koboSpan" id="kobo.888.1">First of all, the multiple dispatch aspect of the Visitor pattern becomes trivial when used in the </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">template context:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.890.1">
template &lt;typename T1, typename T2&gt; auto f(T1 t1, T2 t2);</span></pre>
<p><span class="koboSpan" id="kobo.891.1">A template function can easily run a different algorithm for any combination of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">T1</span></strong><span class="koboSpan" id="kobo.893.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">T2</span></strong><span class="koboSpan" id="kobo.895.1"> types. </span><span class="koboSpan" id="kobo.895.2">Unlike the run-time polymorphism implemented with virtual functions, dispatching the call differently based on two or more types comes at no extra cost (other than writing code for all the combinations we need to handle, of course). </span><span class="koboSpan" id="kobo.895.3">Based on this observation, we can easily mimic the classic Visitor pattern at </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">compile time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.897.1">
// Example 18
class Pet {
  std::string color_;
  public:
  Pet(std::string_view color) : color_(color) {}
  const std::string&amp; color() const { return color_; }
  template &lt;typename Visitable, typename Visitor&gt;
  static void accept(Visitable&amp; p, Visitor&amp; v) {
    v.visit(p);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.898.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">accept()</span></strong><span class="koboSpan" id="kobo.900.1"> function is now a template and a static member function - the actual type of the first argument, the visitable object derived from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">Pet</span></strong><span class="koboSpan" id="kobo.902.1"> class, will be deduced at compile </span><a id="_idIndexMarker1100"/><span class="koboSpan" id="kobo.903.1">time. </span><span class="koboSpan" id="kobo.903.2">The concrete visitable classes are derived from the base class in the </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">usual way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.905.1">
// Example 18
class Cat : public Pet {
  public:
  using Pet::Pet;
};
class Dog : public Pet {
  public:
  using Pet::Pet;
};</span></pre>
<p><span class="koboSpan" id="kobo.906.1">The visitors do not need to be derived from a common base since we now resolve the types at </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">compile time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.908.1">
// Example 18
class FeedingVisitor {
  public:
  void visit(Cat&amp; c) {
    std::cout &lt;&lt; "Feed tuna to the " &lt;&lt; c.color()
              &lt;&lt; " cat" &lt;&lt; std::endl;
  }
  void visit(Dog&amp; d) {
    std::cout &lt;&lt; "Feed steak to the " &lt;&lt; d.color()
              &lt;&lt; " dog" &lt;&lt; std::endl;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.909.1">The visitable classes can accept any visitor that has the correct interface, that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">visit()</span></strong><span class="koboSpan" id="kobo.911.1"> overloads for all classes in </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">the hierarchy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.913.1">
// Example 18
Cat c("orange");
Dog d("brown");
FeedingVisitor fv;
Pet::accept(c, fv);
Pet::accept(d, fv);</span></pre>
<p><span class="koboSpan" id="kobo.914.1">Of course, any function</span><a id="_idIndexMarker1101"/><span class="koboSpan" id="kobo.915.1"> that accepts the visitor arguments and needs to support multiple visitors would have to be made a template as well (it is no longer sufficient to have a common base class, which only helps to determine the actual object type at </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">run time).</span></span></p>
<p><span class="koboSpan" id="kobo.917.1">The compile-time visitor solves the same problem as the classic visitor, it allows us to effectively add new member functions to a class without editing the class definition. </span><span class="koboSpan" id="kobo.917.2">It does, however, look much less exciting than the </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">run-time version.</span></span></p>
<p><span class="koboSpan" id="kobo.919.1">More interesting possibilities arise when we combine the Visitor pattern with the Composition pattern. </span><span class="koboSpan" id="kobo.919.2">We have done this once already when we discussed the visitation of complex objects, especially in the context of the serialization problem. </span><span class="koboSpan" id="kobo.919.3">The reason this is particularly interesting is that it relates to the connection with one of the few </span><em class="italic"><span class="koboSpan" id="kobo.920.1">big-ticket</span></em><span class="koboSpan" id="kobo.921.1"> features missing in C++; namely, the reflection. </span><span class="koboSpan" id="kobo.921.2">Reflection in programming is the ability of a program to examine and introspect its own source and then generate new behavior based on this introspection. </span><span class="koboSpan" id="kobo.921.3">Some programming languages, such as Delphi or Python, have native reflection capability, but C++ does not. </span><span class="koboSpan" id="kobo.921.4">Reflection is useful for solving many problems: for example, the serialization problem could be easily solved if we could make the compiler iterate over all data members of the object and serialize each one, recursively, until we reach the built-in types. </span><span class="koboSpan" id="kobo.921.5">We can implement something similar using a compile-time Visitor pattern. </span></p>
<p><span class="koboSpan" id="kobo.922.1">Again, we will consider the hierarchy of geometric objects. </span><span class="koboSpan" id="kobo.922.2">Since everything is now happening at compile time, we are not interested in the polymorphic nature of the classes (they could still use virtual functions if needed for runtime operations; we just won’t be writing them or looking</span><a id="_idIndexMarker1102"/><span class="koboSpan" id="kobo.923.1"> at them in this section). </span><span class="koboSpan" id="kobo.923.2">For example, here is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">Point</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.925.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.926.1">
// Example 19
class Point {
  public:
  Point() = default;
  Point(double x, double y) : x_(x), y_(y) {}
  template &lt;typename This, typename Visitor&gt;
  static void accept(This&amp; t, Visitor&amp; v) {
    v.visit(t.x_);
    v.visit(t.y_);
  }
  private:
  double x_ {};
  double y_ {};
};</span></pre>
<p><span class="koboSpan" id="kobo.927.1">The visitation is provided via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">accept()</span></strong><span class="koboSpan" id="kobo.929.1"> function, as before, but it is class-specific now. </span><span class="koboSpan" id="kobo.929.2">The only reason we have the first template parameter, </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">This</span></strong><span class="koboSpan" id="kobo.931.1">, is to support both const and non-const operations easily: </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">This</span></strong><span class="koboSpan" id="kobo.933.1"> can be </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">Point</span></strong><span class="koboSpan" id="kobo.935.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">const Point</span></strong><span class="koboSpan" id="kobo.937.1">. </span><span class="koboSpan" id="kobo.937.2">Any visitor to this class is sent to visit the two values that define the point, </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">x_</span></strong><span class="koboSpan" id="kobo.939.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">y_</span></strong><span class="koboSpan" id="kobo.941.1">. </span><span class="koboSpan" id="kobo.941.2">The visitor must have the appropriate interface, specifically, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">visit()</span></strong><span class="koboSpan" id="kobo.943.1"> member function that accepts </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">double</span></strong><span class="koboSpan" id="kobo.945.1"> arguments. </span><span class="koboSpan" id="kobo.945.2">Like most C++ template libraries, including the </span><strong class="bold"><span class="koboSpan" id="kobo.946.1">Standard Template Library</span></strong><span class="koboSpan" id="kobo.947.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.948.1">STL</span></strong><span class="koboSpan" id="kobo.949.1">), this </span><a id="_idIndexMarker1103"/><span class="koboSpan" id="kobo.950.1">code is held together by conventions - there are no virtual functions to override or base classes to derive from, only the requirements on the interface of each class involved in the system. </span><span class="koboSpan" id="kobo.950.2">The more complex classes are composed of the simpler ones; for example, here is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">Line</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.952.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.953.1">
// Example 19
class Line {
  public:
  Line() = default;
  Line(Point p1, Point p2) : p1_(p1), p2_(p2) {}
  template &lt;typename This, typename Visitor&gt;
  static void accept(This&amp; t, Visitor&amp; v) {
    v.visit(t.p1_);
    v.visit(t.p2_);
  }
  private:
  Point p1_;
  Point p2_;
};</span></pre>
<p><span class="koboSpan" id="kobo.954.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">Line</span></strong><span class="koboSpan" id="kobo.956.1"> class is composed of two points. </span><span class="koboSpan" id="kobo.956.2">At compile time, the visitor is directed to visit each point. </span><span class="koboSpan" id="kobo.956.3">That is </span><a id="_idIndexMarker1104"/><span class="koboSpan" id="kobo.957.1">the end of the involvement of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">Line</span></strong><span class="koboSpan" id="kobo.959.1"> class; the </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">Point</span></strong><span class="koboSpan" id="kobo.961.1"> class gets to determine how it is visited (as we have just seen, it also delegates the work to another visitor). </span><span class="koboSpan" id="kobo.961.2">Since we are not using runtime polymorphism anymore, the container classes that can hold geometries of different types now have to </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">be templates:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.963.1">
// Example 19
template &lt;typename G1, typename G2&gt;
class Intersection {
  public:
  Intersection() = default;
  Intersection(G1 g1, G2 g2) : g1_(g1), g2_(g2) {}
  template &lt;typename This, typename Visitor&gt;
  static void accept(This&amp; t, Visitor&amp; v) {
    v.visit(t.g1_);
    v.visit(t.g2_);
  }
  private:
  G1 g1_;
  G2 g2_;
};</span></pre>
<p><span class="koboSpan" id="kobo.964.1">We now have visitable types. </span><span class="koboSpan" id="kobo.964.2">We can use different kinds of visitors with this interface, not just serialization visitors. </span><span class="koboSpan" id="kobo.964.3">However, we are focused on serialization now. </span><span class="koboSpan" id="kobo.964.4">Previously, we have seen a visitor that converts objects into ASCII strings. </span><span class="koboSpan" id="kobo.964.5">Now let’s serialize our objects as binary data, continuous streams of bits. </span><span class="koboSpan" id="kobo.964.6">The serialization visitor has access to a buffer of a certain size</span><a id="_idIndexMarker1105"/><span class="koboSpan" id="kobo.965.1"> and writes the objects into that buffer, one </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">double</span></strong><span class="koboSpan" id="kobo.967.1"> at </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">a time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.969.1">
// Example 19
class BinarySerializeVisitor {
  public:
  BinarySerializeVisitor(char* buffer, size_t size) :
    buf_(buffer), size_(size) {}
  void visit(double x) {
    if (size_ &lt; sizeof(x))
      throw std::runtime_error("Buffer overflow");
    memcpy(buf_, &amp;x, sizeof(x));
    buf_ += sizeof(x);
    size_ -= sizeof(x);
  }
  template &lt;typename T&gt; void visit(const T&amp; t) {
    T::accept(t, *this);
  }
  private:
  char* buf_;
  size_t size_;
};</span></pre>
<p><span class="koboSpan" id="kobo.970.1">The deserialization visitor reads memory from the buffer and copies it into the data members of the </span><a id="_idIndexMarker1106"/><span class="koboSpan" id="kobo.971.1">objects </span><span class="No-Break"><span class="koboSpan" id="kobo.972.1">it restores:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.973.1">
// Example 19
class BinaryDeserializeVisitor {
  public:
  BinaryDeserializeVisitor(const char* buffer, size_t size)
    : buf_(buffer), size_(size) {}
  void visit(double&amp; x) {
    if (size_ &lt; sizeof(x))
      throw std::runtime_error("Buffer overflow");
    memcpy(&amp;x, buf_, sizeof(x));
    buf_ += sizeof(x);
    size_ -= sizeof(x);
  }
  template &lt;typename T&gt; void visit(T&amp; t) {
    T::accept(t, *this);
  }
  private:
  const char* buf_;
  size_t size_;
};</span></pre>
<p><span class="koboSpan" id="kobo.974.1">Both visitors process built-in types directly by copying them to and from the buffer while letting the more complex types decide how the objects should be processed. </span><span class="koboSpan" id="kobo.974.2">In both cases, the visitors throw an exception if the size of the buffer is exceeded. </span><span class="koboSpan" id="kobo.974.3">Now we can use our visitors to, for example, send objects through a socket to </span><span class="No-Break"><span class="koboSpan" id="kobo.975.1">another machine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.976.1">
// Example 19
// On the sender machine:
Line l = ...;
Circle c = ...;
Intersection&lt;Circle, Circle&gt; x = ...;
char buffer[1024];
BinarySerializeVisitor serializer(buffer, sizeof(buffer));
serializer.visit(l);
serializer.visit(c);
serializer.visit(x);
... </span><span class="koboSpan" id="kobo.976.2">send the buffer to the receiver ...
</span><span class="koboSpan" id="kobo.976.3">// On the receiver machine:
Line l;
Circle c;
Intersection&lt;Circle, Circle&gt; x;
BinaryDeserializeVisitor deserializer(buffer, 
  sizeof(buffer));
deserializer.visit(l);
deserializer.visit(c);
deserializer.visit(x);</span></pre>
<p><span class="koboSpan" id="kobo.977.1">While we cannot</span><a id="_idIndexMarker1107"/><span class="koboSpan" id="kobo.978.1"> implement universal reflection without language support, we can have classes reflect on their content in limited ways, such as this composite visitation pattern. </span><span class="koboSpan" id="kobo.978.2">There are also a few variations on the theme that we </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">can consider.</span></span></p>
<p><span class="koboSpan" id="kobo.980.1">First of all, it is conventional to make the objects that have only one </span><em class="italic"><span class="koboSpan" id="kobo.981.1">important</span></em><span class="koboSpan" id="kobo.982.1"> member function callable; in other words, instead of calling the member function, we invoke the object itself using the function call syntax. </span><span class="koboSpan" id="kobo.982.2">This convention dictates that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">visit()</span></strong><span class="koboSpan" id="kobo.984.1"> member function should be called </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">operator()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.986.1"> instead:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.987.1">
// Example 20
class BinarySerializeVisitor {
  public:
  void operator()(double x);
  template &lt;typename T&gt; void operator()(const T&amp; t);
  ...
</span><span class="koboSpan" id="kobo.987.2">};</span></pre>
<p><span class="koboSpan" id="kobo.988.1">The visitable classes </span><a id="_idIndexMarker1108"/><span class="koboSpan" id="kobo.989.1">now call the visitors </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">like functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.991.1">
// Example 20
class Point {
  public:
  static void accept(This&amp; t, Visitor&amp; v) {
    v(t.x_);
    v(t.y_);
  }
  ...
</span><span class="koboSpan" id="kobo.991.2">};</span></pre>
<p><span class="koboSpan" id="kobo.992.1">It may also be convenient to implement wrapper functions to invoke visitors on more than </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">one object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.994.1">
// Example 20
SomeVisitor v;
Object1 x; Object2 y; ...
</span><span class="koboSpan" id="kobo.994.2">visitation(v, x, y, z);</span></pre>
<p><span class="koboSpan" id="kobo.995.1">This is easy to implement using a </span><span class="No-Break"><span class="koboSpan" id="kobo.996.1">variadic template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.997.1">
// Example 20
template &lt;typename V, typename T&gt;
void visitation(V&amp; v, T&amp; t) {
  v(t);
}
template &lt;typename V, typename T, typename... </span><span class="koboSpan" id="kobo.997.2">U&gt;
void visitation(V&amp; v, T&amp; t, U&amp;... </span><span class="koboSpan" id="kobo.997.3">u) {
  v(t);
  visitation(v, u ...);
}</span></pre>
<p><span class="koboSpan" id="kobo.998.1">In C++17, we have fold </span><a id="_idIndexMarker1109"/><span class="koboSpan" id="kobo.999.1">expressions and do not need a </span><span class="No-Break"><span class="koboSpan" id="kobo.1000.1">recursive template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1001.1">
// Example 20
template &lt;typename V, typename T, typename... </span><span class="koboSpan" id="kobo.1001.2">U&gt;
void visitation(V&amp; v, U&amp;... </span><span class="koboSpan" id="kobo.1001.3">u) {
  (v(u), ...);
}</span></pre>
<p><span class="koboSpan" id="kobo.1002.1">In C++14 we can mimic fold expressions using a hack based </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">std::initializer_list</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1006.1">
template &lt;typename V, typename T, typename... </span><span class="koboSpan" id="kobo.1006.2">U&gt;
void visitation(V&amp; v, U&amp;... </span><span class="koboSpan" id="kobo.1006.3">u) {
  using fold = int[];
  (void)fold { 0, (v(u), 0)... </span><span class="koboSpan" id="kobo.1006.4">};
}</span></pre>
<p><span class="koboSpan" id="kobo.1007.1">This works, but it is not going to win any prizes for clarity </span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">or maintainability.</span></span></p>
<p><span class="koboSpan" id="kobo.1009.1">The compile-time visitors are, in general, easier to implement because we don’t have to do anything clever to get multiple dispatch, as the templates provide it out of the box. </span><span class="koboSpan" id="kobo.1009.2">We just need to c</span><a id="_idTextAnchor825"/><span class="koboSpan" id="kobo.1010.1">o</span><a id="_idTextAnchor826"/><span class="koboSpan" id="kobo.1011.1">me </span><a id="_idIndexMarker1110"/><span class="koboSpan" id="kobo.1012.1">up with interesting applications of the pattern, such as the serialization/deserialization problem we </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">just explored.</span></span></p>
<h1 id="_idParaDest-316"><a id="_idTextAnchor827"/><span class="koboSpan" id="kobo.1014.1">Visitor in C++17</span></h1>
<p><span class="koboSpan" id="kobo.1015.1">C++17 introduced</span><a id="_idIndexMarker1111"/><span class="koboSpan" id="kobo.1016.1"> a major change in the way we use the Visitor pattern with the </span><a id="_idIndexMarker1112"/><span class="koboSpan" id="kobo.1017.1">addition of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">std::variant</span></strong><span class="koboSpan" id="kobo.1019.1"> to the standard library. </span><span class="koboSpan" id="kobo.1019.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">std::variant</span></strong><span class="koboSpan" id="kobo.1021.1"> template is essentially a “smart union:” </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">std::variant&lt;T1, T2, T3&gt;</span></strong><span class="koboSpan" id="kobo.1023.1"> is similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">union { T1 v1; T2 v2; T3 v3; }</span></strong><span class="koboSpan" id="kobo.1025.1"> in that both can store a value of one of the specified types and only one value can be stored at a time. </span><span class="koboSpan" id="kobo.1025.2">The key difference is that a variant object knows which type it contains, while with a union the programmer is wholly responsible for reading the same type as what was written earlier. </span><span class="koboSpan" id="kobo.1025.3">It is undefined behavior to access a union as a type that differs from the one used to </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">initialize it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1027.1">
union { int i; double d; std::string s; } u;
u.i = 0;
++u.i;               // OK
std::cout &lt;&lt; u.d;     // Undefined behavior</span></pre>
<p><span class="koboSpan" id="kobo.1028.1">In contrast, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">std::variant</span></strong><span class="koboSpan" id="kobo.1030.1"> offers a safe way to store values of different types in the same memory. </span><span class="koboSpan" id="kobo.1030.2">It is easy to check at runtime which alternative type is currently stored in the variant, and accessing a variant as the wrong type throws </span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1">an exception:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1032.1">
std::variant&lt;int, double, std::string&gt; v;
std::get&lt;int&gt;(v) = 0;     // Initialized as int
std::cout &lt;&lt; v.index();     // 0 is the index of int
++std::get&lt;0&gt;(v);     // OK, int is 0th type
std::get&lt;1&gt;(v);          // throws std::bad_variant_access</span></pre>
<p><span class="koboSpan" id="kobo.1033.1">In many ways, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">std::variant</span></strong><span class="koboSpan" id="kobo.1035.1"> offers capabilities similar to inheritance-based run-time polymorphism: both let us write code where the same variable name can refer to objects of different types at run time. </span><span class="koboSpan" id="kobo.1035.2">The two major differences are: first, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">std::variant</span></strong><span class="koboSpan" id="kobo.1037.1"> does not require that all its types come from the same hierarchy (they need not be classes at all), and second, a variant object can store only one of the types listed in its declaration, while a base class pointer can point to any derived class. </span><span class="koboSpan" id="kobo.1037.2">In other words, adding a new type to the hierarchy generally does not require recompilation of the code that uses the base class, while adding a new type to the variant requires changing the type of the variant object, so all code that refers to this object must </span><span class="No-Break"><span class="koboSpan" id="kobo.1038.1">be recompiled.</span></span></p>
<p><span class="koboSpan" id="kobo.1039.1">In this section, we will focus on the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">std::variant</span></strong><span class="koboSpan" id="kobo.1041.1"> for visitation. </span><span class="koboSpan" id="kobo.1041.2">This capability is provided by the aptly named function </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">std::visit</span></strong><span class="koboSpan" id="kobo.1043.1"> that takes a callable and </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">a variant:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1045.1">
std::variant&lt;int, double, std::string&gt; v;
struct Print {
  void operator()(int i) { std::cout &lt;&lt; i; }
  void operator()(double d) { std::cout &lt;&lt; d; }
  void operator()(const std::string&amp; s) { std::cout &lt;&lt; s; }
} print;
std::visit(print, v);</span></pre>
<p><span class="koboSpan" id="kobo.1046.1">To use with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">std::visit</span></strong><span class="koboSpan" id="kobo.1048.1">, the </span><a id="_idIndexMarker1113"/><span class="koboSpan" id="kobo.1049.1">callable </span><a id="_idIndexMarker1114"/><span class="koboSpan" id="kobo.1050.1">must have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">operator()</span></strong><span class="koboSpan" id="kobo.1052.1"> declared for every type that can be stored in the variant (otherwise the call will not compile). </span><span class="koboSpan" id="kobo.1052.2">Of course, if the implementation is similar, we can use a template </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">operator()</span></strong><span class="koboSpan" id="kobo.1054.1">, either in a function object or in </span><span class="No-Break"><span class="koboSpan" id="kobo.1055.1">a lambda:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1056.1">
std::variant&lt;int, double, std::string&gt; v;
std::visit([](const auto&amp; x) { std::cout &lt;&lt; x;}, v);</span></pre>
<p><span class="koboSpan" id="kobo.1057.1">We will now reimplement our pet visitors using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">std::variant</span></strong><span class="koboSpan" id="kobo.1059.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">std::visit</span></strong><span class="koboSpan" id="kobo.1061.1">. </span><span class="koboSpan" id="kobo.1061.2">First of all, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">Pet</span></strong><span class="koboSpan" id="kobo.1063.1"> type is no longer the base class of the hierarchy but the variant, containing all possible </span><span class="No-Break"><span class="koboSpan" id="kobo.1064.1">type alternatives:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1065.1">
// Example 21
using Pet = 
  std::variant&lt;class Cat, class Dog, class Lorikeet&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.1066.1">The types themselves do not need any visitation machinery. </span><span class="koboSpan" id="kobo.1066.2">We may still use inheritance to reuse common</span><a id="_idIndexMarker1115"/><span class="koboSpan" id="kobo.1067.1"> implementation </span><a id="_idIndexMarker1116"/><span class="koboSpan" id="kobo.1068.1">code, but there is no need for the types to belong to a </span><span class="No-Break"><span class="koboSpan" id="kobo.1069.1">single hierarchy:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1070.1">
// Example 21
class PetBase {
  public:
  PetBase(std::string_view color) : color_(color) {}
  const std::string&amp; color() const { return color_; }
  private:
  const std::string color_;
};
class Cat : private PetBase {
  public:
  using PetBase::PetBase;
  using PetBase::color;
};
class Dog : private PetBase {
  ... </span><span class="koboSpan" id="kobo.1070.2">similar to Cat ...
</span><span class="koboSpan" id="kobo.1070.3">};
class Lorikeet {
  public:
  Lorikeet(std::string_view body, std::string_view head) :
    body_(body), head_(head) {}
  std::string color() const {
    return body_ + " and " + head_;
  }
  private:
  const std::string body_;
  const std::string head_;
};</span></pre>
<p><span class="koboSpan" id="kobo.1071.1">Now we need to implement some visitors. </span><span class="koboSpan" id="kobo.1071.2">The visitors are just callable objects that can be invoked with every</span><a id="_idIndexMarker1117"/><span class="koboSpan" id="kobo.1072.1"> alternative</span><a id="_idIndexMarker1118"/><span class="koboSpan" id="kobo.1073.1"> type that might be stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">the variant:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1075.1">
// Example 21
class FeedingVisitor {
  public:
  void operator()(const Cat&amp; c) {
    std::cout &lt;&lt; "Feed tuna to the " &lt;&lt; c.color()
              &lt;&lt; " cat" &lt;&lt; std::endl;
  }
  void operator()(const Dog&amp; d) {
    std::cout &lt;&lt; "Feed steak to the " &lt;&lt; d.color()
              &lt;&lt; " dog" &lt;&lt; std::endl;
  }
  void operator()(const Lorikeet&amp; l) {
    std::cout &lt;&lt; "Feed grain to the " &lt;&lt; l.color()
              &lt;&lt; " bird" &lt;&lt; std::endl;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.1076.1">To apply a visitor to a variant, we </span><span class="No-Break"><span class="koboSpan" id="kobo.1077.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">std::visit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1079.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1080.1">
// Example 21
Pet p = Cat("orange");
FeedingVisitor v;
std::visit(v, p);</span></pre>
<p><span class="koboSpan" id="kobo.1081.1">The variant </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">p</span></strong><span class="koboSpan" id="kobo.1083.1"> can contain any of the types we listed when we defined the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">Pet</span></strong><span class="koboSpan" id="kobo.1085.1"> (in this example, it’s a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">Cat</span></strong><span class="koboSpan" id="kobo.1087.1">). </span><span class="koboSpan" id="kobo.1087.2">We then invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">std::visit</span></strong><span class="koboSpan" id="kobo.1089.1"> and the resulting action depends both on the visitor itself and on the type currently stored in the variant. </span><span class="koboSpan" id="kobo.1089.2">The result looks a lot like a virtual function call, so we can say that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1090.1">std::visit</span></strong><span class="koboSpan" id="kobo.1091.1"> allows us to add new polymorphic functions to a set of types (it would be misleading to call them “virtual functions” since the types do not have to even </span><span class="No-Break"><span class="koboSpan" id="kobo.1092.1">be classes).</span></span></p>
<p><span class="koboSpan" id="kobo.1093.1">Whenever we see a callable object with the user-defined </span><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">operator()</span></strong><span class="koboSpan" id="kobo.1095.1">, we must be thinking about lambdas. </span><span class="koboSpan" id="kobo.1095.2">However, the use of lambdas with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">std::visit</span></strong><span class="koboSpan" id="kobo.1097.1"> is not straightforward: we need the object to be callable with every type that can be stored in the variant, while a lambda has only one </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">operator()</span></strong><span class="koboSpan" id="kobo.1099.1">. </span><span class="koboSpan" id="kobo.1099.2">The first option is to make that operator a template (polymorphic</span><a id="_idIndexMarker1119"/><span class="koboSpan" id="kobo.1100.1"> lambdas) and handle all the possible</span><a id="_idIndexMarker1120"/> <span class="No-Break"><span class="koboSpan" id="kobo.1101.1">types inside:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1102.1">
// Example 22
#define SAME(v, T) \
  std::is_same_v&lt;std::decay_t&lt;decltype(v)&gt;, T&gt;
auto fv = [](const auto&amp; p) {
  if constexpr (SAME(p, Cat)) {
    std::cout &lt;&lt; "Feed tuna to the " &lt;&lt; p.color()
              &lt;&lt; " cat" &lt;&lt; std::endl; }
  else if constexpr (SAME(p, Dog)) {
    std::cout &lt;&lt; "Feed steak to the " &lt;&lt; p.color()
              &lt;&lt; " dog" &lt;&lt; std::endl; }
  else if constexpr (SAME(p, Lorikeet)) {
    std::cout &lt;&lt; "Feed grain to the " &lt;&lt; p.color()
              &lt;&lt; " bird" &lt;&lt; std::endl; }
  else abort();
};</span></pre>
<p><span class="koboSpan" id="kobo.1103.1">Here the lambda can be invoked with an argument of any type, and inside the body of the lambda, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">if constexpr</span></strong><span class="koboSpan" id="kobo.1105.1"> to handle all types that can be stored in the variant. </span><span class="koboSpan" id="kobo.1105.2">The disadvantage of this approach is that we no longer have compile-time validation that all possible types are handled by the visitor. </span><span class="koboSpan" id="kobo.1105.3">The flip side of this is, however, that the code will now compile even if not all types are handled, and, as long as the visitor is not called with a type for which we have no action defined, the program will work fine. </span><span class="koboSpan" id="kobo.1105.4">In this way, this version is similar to the acyclic visitor, while the previous implementation was similar to the regular visitor. </span></p>
<p><span class="koboSpan" id="kobo.1106.1">It is also possible to </span><a id="_idIndexMarker1121"/><span class="koboSpan" id="kobo.1107.1">implement</span><a id="_idIndexMarker1122"/><span class="koboSpan" id="kobo.1108.1"> the familiar set of overloaded </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">operator()</span></strong><span class="koboSpan" id="kobo.1110.1"> using lambdas and the technique for creating overload sets we have seen in </span><a href="B19262_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1111.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.1112.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1113.1">An Introduction to Inheritance and Polymorphism</span></em><span class="koboSpan" id="kobo.1114.1">: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1115.1">
// Example 22
template &lt;typename... </span><span class="koboSpan" id="kobo.1115.2">T&gt; struct overloaded : T... </span><span class="koboSpan" id="kobo.1115.3">{
  using T::operator()...;
};
template &lt;typename... </span><span class="koboSpan" id="kobo.1115.4">T&gt;
overloaded( T...)-&gt;overloaded&lt;T...&gt;;
auto pv = overloaded {
  [](const Cat&amp; c) {
    std::cout &lt;&lt; "Play with feather with the " &lt;&lt; c.color()
              &lt;&lt; " cat" &lt;&lt; std::endl; },
  [](const Dog&amp; d) {
    std::cout &lt;&lt; "Play fetch with the " &lt;&lt; d.color()
              &lt;&lt; " dog" &lt;&lt; std::endl; },
  [](const Lorikeet&amp; l) {
    std::cout &lt;&lt; "Teach words to the " &lt;&lt; l.color()
              &lt;&lt; " bird" &lt;&lt; std::endl; }
};</span></pre>
<p><span class="koboSpan" id="kobo.1116.1">This visitor is a class that inherits from all the lambdas and exposes their </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">operator()</span></strong><span class="koboSpan" id="kobo.1118.1">, thus creating a set of overloads. </span><span class="koboSpan" id="kobo.1118.2">It is used just like the visitor where we explicitly wrote </span><span class="No-Break"><span class="koboSpan" id="kobo.1119.1">each </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">operator()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1122.1">
// Example 22
Pet l = Lorikeet("yellow", "green");
std::visit(pv, l);</span></pre>
<p><span class="koboSpan" id="kobo.1123.1">So far, we have not used the full potential of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">std::visit</span></strong><span class="koboSpan" id="kobo.1125.1">: it can be called with any number of variant arguments. </span><span class="koboSpan" id="kobo.1125.2">This allows us to perform an action that depends on more than two </span><span class="No-Break"><span class="koboSpan" id="kobo.1126.1">run-time conditions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1127.1">
// Example 23
using Pet = std::variant&lt;class Cat, class Dog&gt;;
Pet c1 = Cat("orange");
Pet c2 = Cat("black");
Pet d = Dog("brown");
CareVisitor cv;
std::visit(cv, c1, c2);      // Two cats
std::visit(cv, c1, d);     // Cat and dog</span></pre>
<p><span class="koboSpan" id="kobo.1128.1">The visitor has to be</span><a id="_idIndexMarker1123"/><span class="koboSpan" id="kobo.1129.1"> written</span><a id="_idIndexMarker1124"/><span class="koboSpan" id="kobo.1130.1"> in a way that handles all possible combinations of the types that can be stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.1131.1">each variant:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1132.1">
class CareVisitor {
  public:
  void operator()(const Cat&amp; c1, const Cat&amp; c2) {
    std::cout &lt;&lt; "Let the " &lt;&lt; c1.color() &lt;&lt; " and the "
              &lt;&lt; c2.color() &lt;&lt; " cats play" &lt;&lt; std::endl; }
  void operator()(const Dog&amp; d, const Cat&amp; c) {
    std::cout &lt;&lt; "Keep the " &lt;&lt; d.color()
              &lt;&lt; " dog safe from the vicious " &lt;&lt; c.color()
              &lt;&lt; " cat" &lt;&lt; std::endl; }
  void operator()(const Cat&amp; c, const Dog&amp; d) {
    (*this)(d, c);
  }
  void operator()(const Dog&amp; d1, const Dog&amp; d2) {
    std::cout &lt;&lt; "Take the " &lt;&lt; d1.color() &lt;&lt; " and the "
              &lt;&lt; d2.color() &lt;&lt; " dogs for a walk"
              &lt;&lt; std::endl; }
};</span></pre>
<p><span class="koboSpan" id="kobo.1133.1">In practice, the only way it is feasible to write a callable for all possible type combinations is by</span><a id="_idIndexMarker1125"/><span class="koboSpan" id="kobo.1134.1"> using </span><a id="_idIndexMarker1126"/><span class="koboSpan" id="kobo.1135.1">a template </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">operator()</span></strong><span class="koboSpan" id="kobo.1137.1">, which works only if the visitor actions can be written in a generic way. </span><span class="koboSpan" id="kobo.1137.2">Still, the ability to do multiple dispatch is a potentially useful feature of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">std::visit</span></strong><span class="koboSpan" id="kobo.1139.1"> that goes beyond the double dispatch capability of the regular </span><span class="No-Break"><span class="koboSpan" id="kobo.1140.1">Visitor pattern.</span></span></p>
<h1 id="_idParaDest-317"><a id="_idTextAnchor828"/><span class="koboSpan" id="kobo.1141.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1142.1">In this chapter, we learned about the Visitor pattern and the different ways it can be implemented in C++. </span><span class="koboSpan" id="kobo.1142.2">The classic object-oriented Visitor pattern allows us to effectively add a new virtual function to the entire class hierarchy without changing the source code of the classes. </span><span class="koboSpan" id="kobo.1142.3">The hierarchy must be made visitable, but after that, any number of operations can be added, and their implementation is kept separate from the objects themselves. </span><span class="koboSpan" id="kobo.1142.4">In the classic Visitor pattern implementation, the source code containing the visited hierarchy does not need to be changed, but it does need to be recompiled when a new class is added to the hierarchy. </span><span class="koboSpan" id="kobo.1142.5">The Acyclic Visitor pattern solves this problem but at the cost of the additional dynamic cast. </span><span class="koboSpan" id="kobo.1142.6">On the other hand, the Acyclic Visitor pattern also supports partial visitation - ignoring some visitor/visitable combinations - while the classic Visitor pattern requires that all combinations must at least </span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1">be declared.</span></span></p>
<p><span class="koboSpan" id="kobo.1144.1">For all visitor variants, the tradeoff for extensibility is the need to weaken the encapsulation and, frequently, grant external visitor classes access to what should be private </span><span class="No-Break"><span class="koboSpan" id="kobo.1145.1">data members.</span></span></p>
<p><span class="koboSpan" id="kobo.1146.1">The Visitor pattern is often combined with other design patterns, in particular, the Composition pattern, to create complex visitable objects. </span><span class="koboSpan" id="kobo.1146.2">The composite object delegates the visitation to its contained objects. </span><span class="koboSpan" id="kobo.1146.3">This combined pattern is particularly useful when an object must be decomposed into its smallest building blocks; for example, </span><span class="No-Break"><span class="koboSpan" id="kobo.1147.1">for serialization.</span></span></p>
<p><span class="koboSpan" id="kobo.1148.1">The classic Visitor pattern implements the double dispatch at run-time - during execution, the program selects which code to run based on two factors, the types of the visitor and the visitable objects. </span><span class="koboSpan" id="kobo.1148.2">The pattern can be similarly used at compile time, where it provides a limited reflection capability. </span></p>
<p><span class="koboSpan" id="kobo.1149.1">In C++17, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">std::visit</span></strong><span class="koboSpan" id="kobo.1151.1"> can be used to extend the Visitor pattern to types not bound into a common hierarchy, and even to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">multiple dispatch.</span></span></p>
<p><span class="koboSpan" id="kobo.1153.1">This chapter on the Visitor pattern used to conclude this book dedicated to C++ idioms and design patterns. </span><span class="koboSpan" id="kobo.1153.2">But, like new stars, the birth of new patterns never stops – new frontiers and new ideas bring with them new challenges to be solved and new solutions to be invented, and they evolve and develop until the programming community collectively arrives at something we can point to and say, with confidence, </span><em class="italic"><span class="koboSpan" id="kobo.1154.1">this is usually a good way to handle that problem</span></em><span class="koboSpan" id="kobo.1155.1">. </span><span class="koboSpan" id="kobo.1155.2">We will elaborate on the strengths of each new approach, consider its drawbacks, and give it a name so we can concisely refer to the entire set of knowle</span><a id="_idTextAnchor829"/><span class="koboSpan" id="kobo.1156.1">dge about the problem, its solutions, and its caveats. </span><span class="koboSpan" id="kobo.1156.2">With that, a new pattern enters our design toolset and our programming vocabulary. </span><span class="koboSpan" id="kobo.1156.3">To illustrate this process, </span><a id="_idTextAnchor830"/><span class="koboSpan" id="kobo.1157.1">in the next and final chapter, we have collected some of the patterns that emerged to address problems specific to concurrent programs. </span></p>
<h1 id="_idParaDest-318"><a id="_idTextAnchor831"/><span class="koboSpan" id="kobo.1158.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1159.1">What is the </span><span class="No-Break"><span class="koboSpan" id="kobo.1160.1">Visitor pattern?</span></span></li>
<li><span class="koboSpan" id="kobo.1161.1">What problem does the Visitor </span><span class="No-Break"><span class="koboSpan" id="kobo.1162.1">pattern solve?</span></span></li>
<li><span class="koboSpan" id="kobo.1163.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.1164.1">double dispatch?</span></span></li>
<li><span class="koboSpan" id="kobo.1165.1">What are the advantages of the Acyclic </span><span class="No-Break"><span class="koboSpan" id="kobo.1166.1">Visitor pattern?</span></span></li>
<li><span class="koboSpan" id="kobo.1167.1">How does the Visitor pattern help </span><span class="No-Break"><span class="koboSpan" id="kobo.1168.1">implement serialization?</span></span></li>
</ol>
</div>
</body></html>