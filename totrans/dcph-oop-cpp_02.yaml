- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Adding Language Necessities
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加语言必要性
- en: This chapter will introduce necessary non-OO features of C++ that are critical
    building blocks for C++’s object-oriented features. The features presented in
    this chapter represent topics that you will see matter-of-factly used from this
    point onward in the book. C++ is a language shrouded in areas of gray; from this
    chapter forward, you will become versed in not only language features, but in
    language nuances. The goal of this chapter will be to begin enhancing your skills
    from those of an average C++ programmer to one who is capable of operating among
    language subtleties successfully while creating maintainable code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍C++中必要的非面向对象特性，这些特性是C++面向对象特性的关键构建块。本章中介绍的特性代表了从这一点开始在书中将直接使用的主题。C++是一种充满灰色地带的语言；从本章开始，你将不仅熟悉语言特性，还将熟悉语言的细微差别。本章的目标将是开始提升你的技能，从一名普通C++程序员转变为能够在创建可维护代码的同时成功操作语言细微差别的人。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The `const` qualifier
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const`限定符'
- en: Function prototyping
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数原型
- en: Function overloading
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数重载
- en: By the end of this chapter, you will understand non-OO features such as the
    `const` qualifier, function prototyping (including using default values), and
    function overloading (including how standard type conversion affects overloaded
    function choices and may create potential ambiguities). Many of these seemingly
    straightforward topics include an assortment of interesting details and nuances.
    These skills will be necessary in order to move forward with the next chapters
    in the book successfully.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将理解非面向对象特性，如`const`限定符、函数原型（包括使用默认值）和函数重载（包括标准类型转换如何影响重载函数的选择以及可能产生的潜在歧义）。许多这些看似简单的话题都包含了一系列有趣的细节和细微差别。这些技能对于成功进行本书的下一章至关重要。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter02](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter02).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in [*Chapter 2*](B19087_02.xhtml#_idTextAnchor072), *Adding
    Language Necessities*, can be found in the subdirectory `Chapter02` in a file
    named `Chp2-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL中找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter02](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter02)。每个完整程序示例都可以在GitHub的相应章节标题（子目录）下找到，对应章节的文件名，后面跟着一个连字符，然后是当前章节中的示例编号。例如，[*第二章*](B19087_02.xhtml#_idTextAnchor072)中的第一个完整程序，*添加语言必要性*，可以在上述GitHub目录下的`Chapter02`子目录中的`Chp2-Ex1.cpp`文件中找到。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3CM65dF](https://bit.ly/3CM65dF).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在以下链接查看：[https://bit.ly/3CM65dF](https://bit.ly/3CM65dF)。
- en: Using the const and constexpr qualifiers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`const`和`constexpr`限定符
- en: In this section, we will add the `const` and `constexpr` qualifiers to variables,
    and discuss how they can be added to functions in both their input parameters
    and as return values. These qualifiers will be used quite liberally as we move
    forward in the C++ language. The use of `const` and `constexpr` can enable values
    to be initialized, yet never again modified. Functions can advertise that they
    will not modify their input parameters, or that their return value may only be
    captured (but not modified) by using `const` or `constexpr`. These qualifiers
    help make C++ a more secure language. Let’s take a look at `const` and `constexpr`
    in action.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向变量添加`const`和`constexpr`限定符，并讨论它们如何添加到函数的输入参数和返回值中。随着我们在C++语言中的前进，这些限定符将被广泛使用。使用`const`和`constexpr`可以使值被初始化，但之后不再修改。函数可以通过使用`const`或`constexpr`来声明它们不会修改其输入参数，或者它们的返回值可能只能被捕获（但不能修改）。这些限定符有助于使C++成为一种更安全的语言。让我们看看`const`和`constexpr`的实际应用。
- en: const and constexpr variables
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`const`和`constexpr`变量'
- en: A `const` qualified variable is a variable that must be initialized, and may
    never be assigned a new value. It is seemingly a paradox to pair the usage of
    `const` and a variable together – `const` implies not to change, yet the concept
    of a variable is to inherently hold different values. Nonetheless, it is useful
    to have a strongly type-checked variable whose one and only value can be determined
    at run time. The keyword `const` is added to the variable declaration.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有资格的 `const` 变量是一个必须初始化且永远不会被赋予新值的变量。将 `const` 和变量的使用放在一起似乎是一个悖论——`const`
    意味着不要改变，而变量的概念是天生可以持有不同的值。尽管如此，拥有一个强类型检查的变量，其唯一值可以在运行时确定，是非常有用的。关键字 `const` 被添加到变量声明中。
- en: Similarly, a variable declared using `constexpr` is a constant qualified variable
    – one that may be initialized and never assigned a new value. The usage of `constexpr`
    is becoming preferred whenever its use is possible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用 `constexpr` 声明的变量是一个有资格的常量变量——它可以被初始化，但永远不会被赋予新的值。只要可能，`constexpr` 的使用正在变得越来越受欢迎。
- en: In some situations, the value of a constant is not known at compile time. An
    example might be if user input or the return value of a function is used to initialize
    a constant. A `const` variable may be easily initialized at runtime. A `constexpr`
    can often, but not always be initialized at runtime. We will consider various
    scenarios in our example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，常量的值在编译时是未知的。一个例子可能是如果使用用户输入或函数的返回值来初始化一个常量。一个 `const` 变量可以在运行时轻松初始化。`constexpr`
    变量通常可以在运行时初始化，但并不总是如此。在我们的例子中，我们将考虑各种情况。
- en: 'Let’s consider a few examples in the following program. We will break this
    program into two segments for a more targeted explanation, however, the full program
    example can be found in its entirety at the following link:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下面的程序中考虑几个例子。我们将把这个程序分成两个部分进行更具体的解释，然而，完整的程序示例可以在以下链接中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex1.cpp)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous program segment, notice how we declare a variable with the `const`
    qualifier preceding the data type. Here, `const int MAX = 50;` simply initializes
    `MAX` to 50\. `MAX` may not be modified via assignment later in the code. Out
    of convention, simple `const` and `constexpr` qualified variables (taking the
    place of once used `#define` macros) are often capitalized, whereas values that
    are calculated (or might be calculated) are declared using typical naming conventions.
    Next, we introduce a constant variable using `constexpr int LARGEST = 50;` to
    declare a variable that likewise cannot be modified. This option is becoming the
    preferred usage but is not always possible to utilize.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序段中，注意我们如何使用 `const` 修饰符在数据类型之前声明一个变量。这里，`const int MAX = 50;` 简单地将 `MAX`
    初始化为 50。`MAX` 在代码的后续部分不能通过赋值来修改。出于惯例，简单的 `const` 和 `constexpr` 资格变量（取代了曾经使用的 `#define`
    宏）通常使用大写字母，而计算（或可能计算）的值则使用典型的命名约定。接下来，我们使用 `constexpr int LARGEST = 50;` 引入一个常量变量，同样不能被修改。这个选项正在成为首选用法，但并不总是可以使用的。
- en: 'Next, we have the definition for function `Minimum()`; notice the use of the
    ternary conditional operator `?:` in this function body. Also notice that this
    function’s return value is qualified with `constexpr` (we will examine this shortly).
    Next, let’s examine the body of the `main()` function as we continue with the
    remainder of this program:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有函数 `Minimum()` 的定义；注意在这个函数体中使用了三元条件运算符 `?:`。同时注意，这个函数的返回值被 `constexpr`
    赋予了资格（我们很快就会检查这一点）。接下来，让我们在继续这个程序的其余部分时检查 `main()` 函数的主体：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In `main()`, let’s consider the sequence of code in which we prompt the user
    to `"Enter two values: "` into variables `x` and `y`, respectively. Here, we call
    a function `Minimum(x,y)` and pass as actual parameters our two values `x` and
    `y`, which were just read in using `cin` and the extraction operator `>>`. Notice
    that alongside the `const` variable declaration of `min`, we initialize `min`
    with the return value of the function call `Minimum()`. It is important to note
    that setting `min` is bundled as a single declaration and initialization. Had
    this been broken into two lines of code – a variable declaration followed by an
    assignment – the compiler would have flagged an error. Variables qualified with
    `const` may only be initialized with a value, and never assigned a value after
    declaration.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `main()` 函数中，让我们考虑以下代码序列：我们提示用户输入 `"Enter two values: "` 并分别将它们存储在变量 `x`
    和 `y` 中。在这里，我们调用函数 `Minimum(x,y)` 并将刚刚使用 `cin` 和提取操作符 `>>` 读取的两个值 `x` 和 `y` 作为实际参数传递。请注意，在
    `min` 的 `const` 变量声明旁边，我们使用函数调用 `Minimum()` 的返回值初始化 `min`。重要的是要注意，设置 `min` 是作为一个单独的声明和初始化捆绑在一起的。如果将此拆分为两行代码——变量声明后跟赋值——编译器将会报错。标记为
    `const` 的变量只能初始化为一个值，并且在声明后不能赋值。'
- en: Next, we initialize `smallest` with the return value of function `Minimum(a,
    b);`. Notice that the parameters `a` and `b` are literal values that can be determined
    at compile time. Also notice the return value of the `Minimum()` function has
    been qualified with `constexpr`. This qualification is necessary in order for
    `constexpr smallest` to be initialized with the function’s return value. Note
    that had we tried to pass `x` and `y` to `Minimum()` to set `smallest`, we would
    get an error, as the values of `x` and `y` are not literal values.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将函数 `Minimum(a, b)` 的返回值初始化给 `smallest`。请注意，参数 `a` 和 `b` 是可以在编译时确定的字面量值。同时请注意，`Minimum()`
    函数的返回值已经被 `constexpr` 标记。这种标记是必要的，以便 `constexpr smallest` 能够使用函数的返回值进行初始化。注意，如果我们尝试将
    `x` 和 `y` 传递给 `Minimum()` 来设置 `smallest`，将会得到一个错误，因为 `x` 和 `y` 的值不是字面量值。
- en: In the last sequence of code in the previous example, notice that we use `MAX`
    (defined in the earlier segment of this full program example) to define a size
    for the fixed-sized array `bigName` in the declaration `char bigName[MAX];`. We
    similarly use `LARGEST` to define a size for the fixed-size array `largeName`.
    Here we see that either the `const` or `constexpr` can be used to size an array
    in this manner. We then further use `MAX` in `setw(MAX)` and `LARGEST` in `setw(LARGEST)`
    to ensure that we do not overflow `bigName` or `largeName`, while reading keyboard
    input with `cin` using the extraction operator `>>`. Finally, we initialize variable
    `const int namelen` with the return value of function `strlen(bigname)` and print
    this value out using `cout`. Note that because `strlen()` is not a function whose
    value is qualified with `constexpr`, we cannot use this return value to initialize
    a `constexpr`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例的最后一段代码中，请注意我们使用 `MAX`（在程序示例的早期部分定义）来在声明 `char bigName[MAX];` 中为固定大小数组
    `bigName` 定义一个大小。我们同样使用 `LARGEST` 来为固定大小数组 `largeName` 定义一个大小。在这里，我们看到可以使用 `const`
    或 `constexpr` 来以这种方式定义数组的大小。然后我们进一步在 `setw(MAX)` 中使用 `MAX`，在 `setw(LARGEST)` 中使用
    `LARGEST`，以确保在读取键盘输入时使用 `cin` 和提取操作符 `>>` 不溢出 `bigName` 或 `largeName`。最后，我们使用函数
    `strlen(bigname)` 的返回值初始化变量 `const int namelen` 并使用 `cout` 打印这个值。请注意，因为 `strlen()`
    不是一个其值被 `constexpr` 标记的函数，所以我们不能使用这个返回值来初始化一个 `constexpr`。
- en: 'The output to accompany the aforementioned full program example is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随上述完整程序示例的输出如下：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have seen how to `const` and `constexpr` qualify variables, let’s
    consider constant qualification with functions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用 `const` 和 `constexpr` 标记变量，让我们考虑函数的常量标记。
- en: const qualification with functions
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的 `const` 标记
- en: The keywords `const` and `constexpr` can also be used in conjunction with functions.
    These qualifiers can be used among parameters to indicate that the parameters
    themselves will not be modified. This is a useful feature—the caller of the function
    will understand that the function will not modify input parameters qualified in
    these manners. However, because non-pointer (and non-reference) variables are
    passed *by value* to functions as copies of the actual parameters on the stack,
    `const` or `constexpr` qualifying these inherent copies of parameters does not
    serve a purpose. Hence, `const` or `constexpr` qualifying parameters that are
    of standard data types is not necessary.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`const`和`constexpr`也可以与函数一起使用。这些修饰符可以在参数之间使用，以指示参数本身不会被修改。这是一个有用的特性——函数的调用者将理解该函数不会修改以这种方式修饰的输入参数。然而，由于非指针（和非引用）变量作为栈上实际参数的副本以值传递的方式传递给函数，因此`const`或`constexpr`修饰这些参数的内在副本并不起作用。因此，不需要对标准数据类型的参数进行`const`或`constexpr`修饰。
- en: 'The same principle applies to return values from functions. A return value
    from a function can be `const` or `constexpr` qualified; however, unless a pointer
    (or reference) is returned, the item passed back on the stack as the return value
    is a copy. For this reason, `const` qualified return values are more meaningful
    when the return type is a pointer to a constant object (which we will cover in
    [*Chapter 3*](B19087_03.xhtml#_idTextAnchor118), *Indirect Addressing: Pointers*,
    and beyond). Note that a `constexpr` qualified return value is required of a function
    whose return value will be used to initialize a `constexpr` variable, as we have
    seen in our previous example. As one final use of `const`, we can utilize this
    keyword when we move onto OO details for a class to specify that a particular
    member function will not modify any data members of that class. We will look at
    this scenario in [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222), *Exploring Classes
    in Detail*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则也适用于函数的返回值。函数的返回值可以是`const`或`constexpr`修饰的；然而，除非返回的是一个指针（或引用），否则作为返回值传递回栈上的项是一个副本。因此，当返回类型是指向常量对象的指针（我们将在[*第3章*](B19087_03.xhtml#_idTextAnchor118)，*间接寻址：指针*，以及更后面讨论）时，`const`修饰的返回值更有意义。注意，如果一个函数的返回值将被用来初始化一个`constexpr`变量，那么需要这个函数有一个`constexpr`修饰的返回值，正如我们在之前的例子中所看到的。作为`const`的最后一次使用，当我们转向类的OO细节时，我们可以使用这个关键字来指定特定的成员函数将不会修改该类的任何数据成员。我们将在[*第5章*](B19087_05.xhtml#_idTextAnchor222)，*详细探索类*中探讨这种情况。
- en: 'Now that we understand the use of the `const` and `constexpr` qualifiers for
    variables and have seen potential uses of `const` and `constexpr` in conjunction
    with functions, let us move onward to the next language feature in this chapter:
    function prototypes.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`const`和`constexpr`修饰符在变量中的用法，并看到了`const`和`constexpr`与函数结合使用的潜在用途，让我们继续本章的下一个语言特性：函数原型。
- en: Working with function prototypes
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与函数原型一起工作
- en: In this section, we will examine the mechanics of function prototyping, such
    as necessary placement in files and across multiple files for greater program
    flexibility. We will also add optional names to prototype arguments, as well as
    understand how and why we may choose to add default values to C++ prototypes.
    Function prototypes ensure C++ code is strongly type-checked.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查函数原型的机制，例如在文件中以及跨多个文件放置的必要性，以增加程序灵活性。我们还将为原型参数添加可选名称，并理解我们为什么可能选择在C++原型中添加默认值。函数原型确保C++代码进行强类型检查。
- en: Prior to proceeding to function prototypes, let’s take a moment to review some
    necessary programming terms. A **function definition** refers to the body of code
    comprising a function, whereas a declaration of a function (also known as a **forward
    declaration**) merely introduces a function name with its return type and argument
    types. Forward declarations allow the compiler to perform strong type checking
    between the function call and its definition by instead comparing the call with
    the forward declaration. Forward declarations are useful because function definitions
    do not always appear in a file prior to a function call; sometimes, function definitions
    appear in a separate file from their calls.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入函数原型之前，让我们花一点时间回顾一些必要的编程术语。**函数定义**指的是一个函数的代码主体，而函数的声明（也称为**前向声明**）只是引入一个函数名及其返回类型和参数类型。前向声明允许编译器通过比较调用与前向声明来执行函数调用和定义之间的强类型检查。前向声明是有用的，因为函数定义并不总是出现在函数调用之前的文件中；有时，函数定义出现在与它们的调用不同的文件中。
- en: Defining function prototypes
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义函数原型
- en: 'A **function prototype** is a forward declaration of a function that describes
    how a function should be correctly invoked. A prototype ensures strong type checking
    between a function call and its definition. A simple function prototype consists
    of the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数原型**是函数的前向声明，它描述了函数应该如何正确调用。原型确保了函数调用和其定义之间的强类型检查。一个简单的函数原型包括以下内容：'
- en: Function’s return type
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的返回类型
- en: Function’s name
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的名称
- en: Function’s type and number of arguments
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的类型和参数数量
- en: 'A function prototype allows a function call to precede the function’s definition
    or allows for calls to functions that exist in separate files. As we learn about
    more C++ language features, such as exceptions, we will see that additional elements
    contribute to a function’s extended prototype (and extended signature). For now,
    let’s examine a simple example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 函数原型允许函数调用先于函数的定义，或者允许调用存在于单独文件中的函数。随着我们学习更多C++语言特性，例如异常，我们将看到更多元素有助于函数的扩展原型（和扩展签名）。现在，让我们看看一个简单的例子：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex2.cpp)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex2.cpp)'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that we prototype `int Minimum(int, int);` near the beginning of the
    aforementioned example. This prototype lets the compiler know that any calls to
    `Minimum()` should take two integer arguments and should return an integer value
    (we’ll discuss type conversions later in this section).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，我们在上述示例的早期原型化了`int Minimum(int, int);`。这个原型让编译器知道任何对`Minimum()`的调用都应该接受两个整数参数，并返回一个整数值（我们将在本节稍后讨论类型转换）。 '
- en: Also notice the use of `[[nodiscard]]` preceding the return type of the function.
    This indicates that the programmer should store the return value or otherwise
    utilize the return value (such as in an expression). The compiler will issue a
    warning if the return value of this function is ignored.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意在函数返回类型之前使用`[[nodiscard]]`。这表示程序员应该存储返回值或以其他方式使用返回值（例如在表达式中）。如果忽略此函数的返回值，编译器将发出警告。
- en: Next, in the `main()` function, we call the function `Minimum(x, y)`. At this
    point, the compiler checks that the function call matches the aforementioned prototype
    with respect to type and number of arguments, and return type. Namely, that the
    two arguments are integers (or could easily be converted to integers) and that
    the return type is an integer (or could easily be converted to an integer). The
    return value will be utilized as a value to print using `cout`. Lastly, the function
    `Minimum()` is defined in the file. Should the function definition not match the
    prototype, the compiler will raise an error.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`main()`函数中，我们调用函数`Minimum(x, y)`。此时，编译器检查函数调用是否与上述原型在类型和参数数量以及返回类型上匹配。也就是说，两个参数都是整数（或者可以轻松转换为整数），返回类型是整数（或者可以轻松转换为整数）。返回值将被用作`cout`打印的值。最后，在文件中定义了`Minimum()`函数。如果函数定义与原型不匹配，编译器将引发错误。
- en: The existence of the prototype allows the call of a given function to be fully
    type-checked prior to the function’s definition being seen by the compiler. The
    current example is of course contrived to demonstrate this point; we could have
    instead switched the order in which `Minimum()` and `main()` appear in the file.
    However, imagine that the definition of `Minimum()` was contained in a separate
    file (the more typical scenario). In this case, the prototype will appear at the
    top of the file that will call this function (along with header file inclusions)
    so that the function call can be fully type-checked against the prototype.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 原型的存在使得在编译器看到函数定义之前，可以完全对给定函数的调用进行类型检查。当前的例子当然是人为设计的，以说明这一点；我们本可以交换文件中`Minimum()`和`main()`出现的顺序。然而，想象一下`Minimum()`的定义包含在一个单独的文件中（这是更典型的情况）。在这种情况下，原型将出现在调用此函数的文件顶部（以及头文件包含），以便可以对原型进行完全的类型检查。
- en: In the aforementioned multiple file scenario, the file containing the function
    definition will be separately compiled. It will then be the linker’s job to ensure
    that when multiple files are linked together, the function definition and all
    prototypes match so that the linker can resolve any references to such function
    calls. Should the prototypes not match the function definition, the linker will
    not be able to link the various sections of code together into one compiled unit.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述多文件场景中，包含函数定义的文件将单独编译。然后，链接器的任务将确保当多个文件链接在一起时，函数定义和所有原型匹配，以便链接器可以解决对这种函数调用的任何引用。如果原型与函数定义不匹配，链接器将无法将代码的不同部分链接成一个编译单元。
- en: 'Let’s take a look at this example’s output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个例子的输出：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we understand function prototype basics, let’s see how we can add optional
    argument names to function prototypes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了函数原型的基础知识，让我们看看我们如何可以向函数原型添加可选的参数名称。
- en: Naming arguments in function prototypes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在函数原型中命名参数
- en: 'Function prototypes may optionally contain names that may differ from those
    in either the formal or actual parameter lists. Argument names are ignored by
    the compiler, yet can often enhance readability. Let’s revisit our previous example,
    adding optional argument names in the function prototype:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 函数原型可以可选地包含与形式参数列表或实际参数列表中不同的名称。参数名称被编译器忽略，但通常可以增强可读性。让我们回顾一下我们之前的例子，在函数原型中添加可选的参数名称：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex3.cpp)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex3.cpp)'
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example is nearly identical to the one preceding it. However, notice that
    the function prototype contains named arguments `arg1` and `arg2`. These identifiers
    are immediately ignored by the compiler. As such, these named arguments do not
    need to match either the formal or actual parameters of the function and are optionally
    present merely to enhance readability.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子几乎与前面的例子相同。然而，请注意，函数原型包含命名参数`arg1`和`arg2`。这些标识符立即被编译器忽略。因此，这些命名参数不需要与函数的形式参数或实际参数匹配，并且只是可选的，仅为了提高可读性。
- en: 'The output to accompany this example is the same as the previous example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随这个例子的输出与前面的例子相同：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, let’s move forward with our discussion by adding a useful feature to
    function prototypes: default values.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过向函数原型添加一个有用的功能来继续我们的讨论：默认值。
- en: Adding default values to function prototypes
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在函数原型中添加默认值
- en: '**Default values** may be specified in function prototypes. These values will
    be used in the absence of actual parameters in the function call and will serve
    as the actual parameters themselves. Default values adhere to the following criteria:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认值**可以在函数原型中指定。这些值将在函数调用中缺少实际参数时使用，并作为实际参数本身。默认值遵循以下标准：'
- en: Default values must be specified from right to left in the function prototype,
    without omitting any values.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认值必须在函数原型中从右到左指定，不能省略任何值。
- en: Actual parameters are substituted from left to right in the function call; hence
    the right to left order for default value specification in the prototype is significant.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际参数在函数调用中从左到右进行替换；因此，在原型中指定默认值的顺序是重要的。
- en: A function prototype may have all, some, or none of its values filled with default
    values, as long as the default values adhere to the aforementioned specifications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 函数原型可以全部、部分或没有任何值被默认值填充，只要默认值符合上述规范。
- en: 'Let’s see an example using default values:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个使用默认值的示例来了解一下：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex4.cpp)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex4.cpp)'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, notice that a default value is added to the rightmost argument
    in the function prototype for `int Minimum(int arg1, int arg2 = 100000);`. This
    means that when `Minimum()` is called from `main()`, it may be called with either
    one argument, `Minimum(x)`, or with two arguments, `Minimum(x, y)`. When `Minimum()`
    is called with a single argument, the single argument is bound to the leftmost
    argument in the formal parameters of the function, and the default value is bound
    to the next sequential argument in the formal parameter list. However, when `Minimum()`
    is called with two arguments, both of the actual parameters are bound to the formal
    parameters in the function; the default value is not used.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，请注意，在 `int Minimum(int arg1, int arg2 = 100000);` 的函数原型中添加了一个默认值到最右边的参数。这意味着当从
    `main()` 调用 `Minimum()` 时，它可以带有一个参数调用 `Minimum(x)`，或者带有两个参数调用 `Minimum(x, y)`。当
    `Minimum()` 带有一个参数被调用时，单个参数绑定到函数形式参数列表中的最左边参数，默认值绑定到下一个顺序参数。然而，当 `Minimum()` 带有两个参数被调用时，两个实际参数都绑定到函数的形式参数；默认值不会被使用。
- en: 'Here is the output for this example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个示例的输出：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have a handle on default values within a function prototype, let’s
    expand on this idea by using different default values with prototypes in various
    program scopes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了函数原型中的默认值，让我们通过在程序的不同作用域中使用不同的默认值来扩展这个想法。
- en: Prototyping with different default values in different scopes
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不同作用域中使用不同的默认值进行原型设计
- en: Functions may be prototyped in different scopes with different default values.
    This allows functions to be built generically and customized through prototypes
    within multiple applications or for use in multiple sections of code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以在不同的作用域中使用不同的默认值进行原型设计。这允许函数以通用方式构建，并通过原型在多个应用程序或代码的多个部分中进行定制。
- en: 'Here is an example illustrating multiple prototypes for the same function (in
    different scopes) using different default values:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了同一函数（在不同作用域）使用不同默认值的多重原型：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex5.cpp)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex5.cpp)'
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, notice that `int Minimum(int, int);` is prototyped near the
    top of the file. Then notice that `Minimum()` is re-prototyped in the more local
    scope of `Function1()` as `int Minimum(int arg1, int arg2 = 500);`, specifying
    a default value of `500` for its rightmost argument. Likewise, in the scope of
    `Function2()`, function `Minimum()` is re-prototyped as `int Minimum(int arg1,
    int arg2 = 90);`, specifying a default value of `90` in the rightmost argument.
    When `Minimum()` is called from within `Function1()` or `Function2()`, the local
    prototypes in each of these function scopes, respectively, will be used – each
    with their own default values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，请注意，`int Minimum(int, int);` 的原型在文件顶部附近被定义。然后请注意，在 `Function1()` 的更局部作用域中，函数
    `Minimum()` 被重新原型化为 `int Minimum(int arg1, int arg2 = 500);`，为最右边的参数指定了默认值 `500`。同样，在
    `Function2()` 的作用域中，函数 `Minimum()` 被重新原型化为 `int Minimum(int arg1, int arg2 = 90);`，在右边的参数中指定了默认值
    `90`。当在 `Function1()` 或 `Function2()` 内部调用 `Minimum()` 时，每个函数作用域中的局部原型分别会被使用——每个都有自己的默认值。
- en: In this fashion, specific areas of a program may be easily customized with default
    values that may be meaningful within a specific portion of an application. However,
    be sure to *only* employ re-prototyping of a function with individualized default
    values within the scope of a calling function to ensure that this customization
    can be easily contained within the safety of a very limited scope. Never re-prototype
    a function in global scope with differing default values – this could lead to
    unexpected and error-prone results.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，程序的具体区域可以很容易地通过具有特定应用部分中具有意义的默认值进行定制。然而，请确保**仅**在调用函数的作用域内使用具有个性化默认值的函数重原型，以确保这种定制可以轻松地包含在非常有限的范围内。永远不要在全局作用域中用不同的默认值重原型化函数——这可能导致意外和错误的结果。
- en: 'The output for the example is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对该例子的输出：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Having now explored function prototypes with respect to default usage in single
    and multiple files, using default values in prototypes, and re-prototyping functions
    in different scopes with individual default values, we are now able to move forward
    with the last major topic in this chapter: function overloading.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了与单文件和多文件中的默认使用、原型中的默认值以及在不同作用域中用个性化默认值重原型化函数相关的函数原型，我们现在可以继续本章的最后一个重要主题：函数重载。
- en: Understanding function overloading
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解函数重载
- en: C++ allows for two or more functions that share a similar purpose, yet differ
    in the types or number of arguments they take, to co-exist with the same function
    name. This is known as **function overloading**. This allows more generic function
    calls to be made, leaving the compiler to choose the correct version of the function
    based on the type of the variable (object) using the function. In this section,
    we will add default values to the basics of function overloading to provide flexibility
    and customization. We will also learn how standard type conversions may impact
    function overloading, and potential ambiguities that may arise (as well as how
    to resolve those types of uncertainties).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 允许存在两个或多个具有相似目的但参数类型或数量不同的函数，它们可以与相同的函数名称共存，这被称为**函数重载**。这允许进行更通用的函数调用，让编译器根据使用函数的变量（对象）的类型选择正确的函数版本。在本节中，我们将向函数重载的基本知识中添加默认值，以提供灵活性和定制。我们还将了解标准类型转换可能如何影响函数重载，以及可能出现的潜在歧义（以及如何解决这些类型的疑问）。
- en: Learning the basics of function overloading
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习函数重载的基本知识
- en: 'When two or more functions with the same name exist, the differentiating factor
    between these similar functions will be their signature. By varying a function’s
    signature, two or more functions with otherwise identical names may exist in the
    same namespace. Function overloading depends on the signature of a function as
    follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在两个或多个具有相同名称的函数时，这些类似函数之间的区别因素将是它们的签名。通过改变函数的签名，可以在同一个命名空间中存在两个或多个具有其他名称相同的函数。函数重载依赖于函数的签名如下：
- en: The **signature of a function** refers to a function’s name, plus its type and
    number of arguments.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数的签名**指的是函数的名称，加上它的类型和参数数量。'
- en: A function’s return type is not included as part of its signature.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的返回类型不包括在其签名部分。
- en: Two or more functions with the same purpose may share the same name, provided
    that their signatures differ.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有相同目的的两个或多个函数可以共享相同的名称，前提是它们的签名不同。
- en: A function’s signature helps provide an internal, “mangled” name for each function.
    This encoding scheme guarantees that each function is uniquely represented internally
    to the compiler.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的签名有助于为每个函数提供一个内部，“混淆”的名称。这种编码方案保证了每个函数在编译器内部都有唯一的表示。
- en: 'Let’s take a few minutes to understand a slightly larger example that will
    incorporate function overloading. To simplify the explanation, this example is
    broken into three segments; nonetheless, the full program can be found in its
    entirety at the following link:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花几分钟时间理解一个稍微大一点的例子，这个例子将包含函数重载。为了简化解释，这个例子被分为三个部分；尽管如此，完整的程序可以在以下链接中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex6.cpp)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex6.cpp)'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At the beginning of this example, notice that we include the math library with
    `#include <cmath>`, to provide access to basic math functions, such as `pow()`.
    Next, notice the class definitions for `Circle` and `Rectangle`, each with relevant
    data members (`radius` and `area` for `Circle`; `length`, `width`, and `area`
    for `Rectangle`). Once these types have been defined, prototypes for two overloaded
    `Display()` functions are shown. Since the prototypes for the two display functions
    utilize user defined types `Circle` and `Rectangle`, it is important that `Circle`
    and `Rectangle` have both previously been defined. Now, let’s examine the body
    of the `main()` function as we continue with the next segment of this program:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例的开始，注意我们使用`#include <cmath>`包含数学库，以提供对基本数学函数，如`pow()`的访问。接下来，注意`Circle`和`Rectangle`的类定义，每个类都有相关的数据成员（`Circle`的`radius`和`area`；`Rectangle`的`length`、`width`和`area`）。一旦定义了这些类型，就显示了两个重载的`Display()`函数的原型。由于两个显示函数的原型使用了用户定义的类型`Circle`和`Rectangle`，因此重要的是`Circle`和`Rectangle`之前已经被定义。现在，让我们在继续程序的下一个部分时检查`main()`函数的主体：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, in the `main()` function, we declare a variable of type `Circle` and two
    variables of type `Rectangle`. We then proceed to load the data members for each
    of these variables in `main()` using the dot operator (`.`) with appropriate values.
    Next in `main()`, there are three calls to `Display()`. The first function call,
    `Display(myCircle)`, will call the version of `Display()` that takes a `Circle`
    as a formal parameter because the actual parameter passed to this function is
    in fact of user defined type `Circle`. The next two function calls, `Display(myRect)`
    and `Display(mySquare)`, will call the overloaded version of `Display()` that
    takes a `Rectangle` as a formal parameter because the actual parameters passed
    in each of these two calls are of type `Rectangle` themselves. Let’s complete
    this program by examining both function definitions for `Display()`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`main()`函数中，我们声明了一个`Circle`类型的变量和两个`Rectangle`类型的变量。然后我们使用点操作符（`.`）和适当的值，在`main()`函数中为这些变量的数据成员加载。接下来在`main()`函数中，有三次对`Display()`的调用。第一次函数调用`Display(myCircle)`将调用接受一个`Circle`作为形式参数的`Display()`版本，因为传递给这个函数的实际参数实际上是用户定义的类型`Circle`。接下来的两个函数调用`Display(myRect)`和`Display(mySquare)`将调用接受一个`Rectangle`作为形式参数的重载版本，因为在这两个调用中传递的实际参数本身就是`Rectangle`类型。让我们通过检查`Display()`的两个函数定义来完成这个程序：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice in the final segment of this example that both versions of `Display()`
    are defined. One of the functions takes a `Circle` as the formal parameter, and
    the overloaded version takes a `Rectangle` as its formal parameter. Each function
    body accesses data members specific to each of its formal parameter types, yet
    the overall functionality of each function is similar in that, in each case, a
    specific shape (`Circle` or `Rectangle`) is displayed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在这个示例的最后部分，定义了`Display()`的两个版本。其中一个函数接受一个`Circle`作为形式参数，而重载版本接受一个`Rectangle`作为其形式参数。每个函数体访问特定于其形式参数类型的成员数据，然而每个函数的整体功能相似，因为在每种情况下，都显示了一个特定的形状（`Circle`或`Rectangle`）。
- en: 'Let’s take a look at the output for this full program example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个完整程序示例的输出：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, let’s add to our discussion of function overloading by understanding how
    standard type conversion allows for one function to be used by multiple data types.
    This can allow function overloading to be used more selectively.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过了解标准类型转换如何允许一个函数被多个数据类型使用来扩展我们对函数重载的讨论。这可以使函数重载的使用更加选择性地进行。
- en: Eliminating excessive overloading with standard type conversion
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标准类型转换消除过度重载
- en: Basic language types can be converted from one type to another automatically
    by the compiler. This allows the language to supply a smaller set of operators
    to manipulate standard types than would otherwise be necessary. Standard type
    conversion can also eliminate the need for function overloading when preserving
    the exact data type of the function parameters is not crucial. Promotion and demotion
    between standard types are often handled transparently, without explicit casting,
    in expressions including assignments and operations.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 基本语言类型可以由编译器自动从一种类型转换为另一种类型。这允许语言提供比其他情况下所需更少的操作符来操作标准类型。标准类型转换还可以在保持函数参数的精确数据类型不是至关重要的情况下消除函数重载的需要。在包括赋值和操作的表达式中，标准类型之间的提升和降级通常被透明地处理，无需显式类型转换。
- en: 'Here is an example illustrating simple standard type conversions. This example
    does not include function overloading:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，说明了简单的标准类型转换。此示例不包括函数重载：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex7.cpp)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex7.cpp)'
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, the `Maximum()` function takes two double precision floating-point
    numbers as parameters, and the function returns the result as an `int`. First,
    notice that `int Maximum(double, double);` is prototyped near the top of the program
    and is defined at the bottom of this same file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`Maximum()`函数接受两个双精度浮点数作为参数，并将结果作为`int`类型返回。首先请注意，`int Maximum(double,
    double);`在程序顶部附近进行了原型声明，并在同一文件的底部进行了定义。
- en: 'Now, in the `main()` function, notice that we have three `int` variables defined:
    `result`, `a`, and `x`. The latter two are initialized with values of `6` and
    `10`, respectively. We also have two floats defined and initialized: `float x
    = 5.7, y = 9.89;`. In the first call to function `Maximum()`, we use `x` and `y`
    as actual parameters. These two floating-point numbers are promoted to double
    precision floating-point numbers, and the function is called as expected.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`main()`函数中，请注意我们定义了三个`int`类型的变量：`result`、`a`和`x`。后两个变量分别初始化为`6`和`10`。我们还定义了两个浮点数并初始化：`float
    x = 5.7, y = 9.89;`。在第一次调用`Maximum()`函数时，我们使用`x`和`y`作为实际参数。这两个浮点数被提升为双精度浮点数，并且函数按预期被调用。
- en: This is an example of standard type conversion. Let’s notice that the return
    value of `int Maximum(double, double)` is an integer – not a double. This means
    that the value returned from this function (either formal parameter `a` or `b`)
    will be a copy of `a` or `b`, first truncated to an integer before being used
    as a return value. This return value is neatly assigned to `result`, which has
    been declared an `int` in `main()`. These are all examples of standard type conversion.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准类型转换的示例。让我们注意到`int Maximum(double, double)`的返回值是一个整数——不是一个双精度数。这意味着从这个函数返回的值（无论是形式参数`a`还是`b`）将是一个`a`或`b`的副本，首先将其截断为整数，然后用作返回值。这个返回值被整洁地分配给在`main()`中声明的`int`类型的`result`。这些都是标准类型转换的例子。
- en: Next, `Maximum()` is called with actual parameters `m` and `n`. Similar to the
    previous function call, the integers `m` and `n` are promoted to doubles and the
    function is called as expected. The return value will also be truncated back to
    an `int`, and this value will be passed to `cout` for printing as an integer.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用实际参数`m`和`n`调用`Maximum()`函数。与之前的函数调用类似，整数`m`和`n`被提升为双精度，函数按预期被调用。返回值也将被截断回`int`类型，并将此值传递给`cout`以打印为整数。
- en: 'The output for this example is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的输出如下：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we understand how function overloading and standard type conversions
    work, let’s examine a situation where the two combined could create an ambiguous
    function call.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了函数重载和标准类型转换的工作原理，让我们考察一个两种情况结合可能会产生模糊函数调用的场景。
- en: Ambiguities arising from function overloading and type conversion
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数重载和类型转换引起的歧义
- en: When a function is invoked and the formal and actual parameters match exactly
    in type, no ambiguities arise with respect to which of a selection of overloaded
    functions should be called – the function with the exact match is the obvious
    choice. However, when a function is called and the formal and actual parameters
    differ in type, standard type conversion may be performed on the actual parameters,
    as necessary. There are situations, however, when the formal and actual parameter
    types do not match, and overloaded functions exist. In these cases, it may be
    difficult for the compiler to select which function should be selected as the
    best match. In these cases, a compiler error is generated indicating that the
    available choices paired with the function call itself are ambiguous. Explicit
    type casting or re-prototyping the desired choice in a more local scope can help
    correct these otherwise ambiguous situations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数被调用，其形式参数和实际参数在类型上完全匹配时，关于应该调用选择中的哪个重载函数不会产生歧义——与完全匹配的函数是明显的选择。然而，当一个函数被调用且其形式参数和实际参数在类型上不同时，可能需要对实际参数执行标准类型转换。然而，存在形式参数和实际参数类型不匹配的情况，并且存在重载函数。在这些情况下，编译器可能难以选择哪个函数应该被选为最佳匹配。在这些情况下，编译器会生成一个错误，表明与函数调用本身配对的可用选择是不确定的。显式类型转换或在更局部的作用域中重新原型化所需的选择可以帮助纠正这些其他情况下可能的不确定性。
- en: 'Let’s review a simple function illustrating the function overloading, standard
    type conversion, and potential ambiguity:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个简单的函数，它展示了函数重载、标准类型转换以及潜在的不确定性：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex8.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex8.cpp)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex8.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex8.cpp)'
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this preceding simple example, two versions of `Maximum()` are both prototyped
    and defined. These functions are overloaded; notice that their names are the same,
    but they differ in the types of arguments that they utilize. Also note that their
    return types differ; however, since return type is not part of a function’s signature,
    the return types need not match.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个先前的简单示例中，`Maximum()` 的两个版本都被原型化和定义了。这些函数是重载的；注意，它们的名称相同，但它们使用的参数类型不同。还要注意，它们的返回类型不同；然而，由于返回类型不是函数签名的一部分，因此返回类型不需要匹配。
- en: 'Next, in `main()`, two variables each of type `char`, `int`, and `float` are
    declared and initialized. Next, `Maximum(a, b)` is called and the two `char` actual
    parameters are converted to integers (using their ASCII equivalents) to match
    the `Maximum(int, int)` version of this function. This is the match closest to
    the `char` argument types of `a` and `b`: `Maximum(int, int)` versus `Maximum(float,
    float)`. Then, `Maximum(x, y)` is called with two floats, and this call will exactly
    match the `Maximum(float, float)` version of this function. Similarly, `Maximum(m,
    n)` will be called and will perfectly match the `Maximum(int, int)` version of
    this function.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `main()` 中，声明并初始化了两个类型为 `char`、`int` 和 `float` 的变量。接下来，调用 `Maximum(a,
    b)` 并将两个 `char` 实际参数转换为整数（使用它们的 ASCII 等价物）以匹配此函数的 `Maximum(int, int)` 版本。这是与 `a`
    和 `b` 的 `char` 参数类型最接近的匹配：`Maximum(int, int)` 与 `Maximum(float, float)`。然后，调用
    `Maximum(x, y)` 并使用两个浮点数，这个调用将正好匹配此函数的 `Maximum(float, float)` 版本。同样，`Maximum(m,
    n)` 将被调用，并将完美匹配此函数的 `Maximum(int, int)` 版本。
- en: 'Now, notice the next function call (which, not coincidentally, is commented
    out): `Maximum(a, y)`. Here, the first actual parameter perfectly matches the
    first argument in `Maximum(int, int)`, yet the second actual parameter perfectly
    matches the second argument in `Maximum(float, float)`. And for the non-matching
    parameter, a type conversion *could* be applied – but it is not! Instead, this
    function call is flagged by the compiler as an ambiguous function call since either
    of the overloaded functions could be an appropriate match.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，注意下一个函数调用（这并非巧合，它是被注释掉的）：`Maximum(a, y)`。在这里，第一个实际参数完美匹配 `Maximum(int, int)`
    中的第一个参数，而第二个实际参数完美匹配 `Maximum(float, float)` 中的第二个参数。对于不匹配的参数，可以应用类型转换——但并没有！相反，这个函数调用被编译器标记为歧义函数调用，因为任一重载函数都可能是一个合适的匹配。
- en: On the line of code `Maximum((float) a, y)`, notice that the function call to
    `Maximum((float) a, y)` forces an explicit typecast to the first actual parameter
    `a`, resolving any potential ambiguity of which overloaded function to call. With
    parameter `a` now cast to be a `float`, this function call easily matches `Maximum(float,
    float)`, and is no longer considered ambiguous. Type casting can be a tool to
    disambiguate crazy situations such as these.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行`Maximum((float) a, y)`中，注意函数调用`Maximum((float) a, y)`强制对第一个实际参数`a`进行显式类型转换，解决了调用哪个重载函数的潜在歧义。现在参数`a`被转换成`float`类型，这个函数调用很容易匹配`Maximum(float,
    float)`，不再被认为是歧义的。类型转换可以是一种解决这类疯狂情况的工具。
- en: 'Here is the output to accompany our example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是伴随我们示例的输出：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about additional non-OO C++ features that are essential
    building blocks needed to base C++’s object-oriented features. These language
    necessities include using the `const` qualifier, understanding function prototypes,
    using default values in prototypes, function overloading, how standard type conversion
    affects overloaded function choices, and how possible ambiguities may arise (and
    be resolved).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了C++中一些额外的非面向对象特性，这些特性是构建C++面向对象特性的必要基石。这些语言需求包括使用`const`限定符、理解函数原型、在原型中使用默认值、函数重载、标准类型转换如何影响重载函数的选择，以及可能出现的歧义（以及如何解决）。
- en: Very importantly, you are now ready to move forward to the next chapter in which
    we will explore indirect addressing using pointers in reasonable detail. The matter-of-fact
    skills that you have accumulated in this chapter will help you more easily navigate
    each progressively more detailed chapter to ensure you are ready to easily tackle
    the OO concepts starting in [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222), *Exploring
    Classes in Detail*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，你现在可以向前推进到下一章，我们将详细探讨使用指针进行间接寻址。你在本章积累的事实技能将帮助你更容易地导航每一章，确保你准备好轻松应对从[*第5章*](B19087_05.xhtml#_idTextAnchor222)开始的OO概念，即*探索类的细节*。
- en: Remember, C++ is a language filled with more gray areas than most other languages.
    The subtle nuances you are accumulating with your skill set will enhance your
    value as a C++ developer – one who can not only navigate and understand existing
    nuanced code but one who can create easily maintainable code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，C++是一种比大多数其他语言都有更多灰色区域的语言。你通过技能集积累的微妙差异将提高你作为C++开发者的价值——不仅能导航和理解现有的微妙代码，而且能创建易于维护的代码。
- en: Questions
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the signature of a function and how is a function’s signature related
    to name mangling in C++? How do you think this facilitates how overloaded functions
    are handled internally by the compiler?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的签名是什么，函数的签名在C++中与名称修饰有何关系？你认为这如何帮助编译器内部处理重载函数？
- en: 'Write a small C++ program to prompt a user to enter information regarding a
    `Student`, and print out the data. Use the following steps to write your code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个小型的C++程序，提示用户输入有关`Student`的信息，并打印出这些数据。使用以下步骤编写你的代码：
- en: Create a data type for `Student` using a `class` or `struct`. `Student` information
    should minimally include `firstName`, `lastName`, `gpa`, and the `currentCourse`
    in which the `Student` is registered. This information may be stored in a simple
    class. You may utilize either `char` arrays to represent the string fields since
    we have not yet covered pointers, or you may (preferably) utilize the `string`
    type. Also, you may read in this information in the `main()` function rather than
    creating a separate function to read in the data (since the latter will require
    knowledge of pointers or references). Please do not use global (that is, external
    variables).
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`class`或`struct`创建一个`Student`数据类型。`Student`信息至少应包括`firstName`、`lastName`、`gpa`以及`Student`注册的`currentCourse`。这些信息可以存储在一个简单的类中。你可以使用`char`数组来表示字符串字段，因为我们还没有介绍指针，或者你可以（更推荐）使用`string`类型。此外，你可以在`main()`函数中读取这些信息，而不是创建一个单独的函数来读取数据（因为后者将需要了解指针或引用）。请勿使用全局变量（即外部变量）。
- en: 'Create a function to print out all the data for the `Student`. Remember to
    prototype this function. Use a default value of `4.0` for `gpa` in the prototype
    of this function. Call this function two ways: once passing in each argument explicitly,
    and once using the default `gpa`.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来打印出`Student`的所有数据。记住要为这个函数原型。在函数原型中使用`gpa`的默认值`4.0`。以两种方式调用这个函数：一次显式传递每个参数，一次使用默认的`gpa`。
- en: Now, overload the print function with one that either prints out selected data
    (for example, `lastName` and `gpa`) or with a version of this function that takes
    a `Student` as an argument (but not a pointer or reference to a `Student` – we’ll
    do that later). Remember to prototype this function.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重载print函数，使其能够打印出选定的数据（例如，`lastName`和`gpa`），或者使用这个函数的版本，它接受一个`Student`作为参数（但不能是`Student`的指针或引用——我们稍后会这样做）。记得要为这个函数编写原型。
- en: Use iostreams for I/O.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用iostreams进行输入输出。
