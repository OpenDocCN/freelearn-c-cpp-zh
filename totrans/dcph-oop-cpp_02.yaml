- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding Language Necessities
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce necessary non-OO features of C++ that are critical
    building blocks for C++’s object-oriented features. The features presented in
    this chapter represent topics that you will see matter-of-factly used from this
    point onward in the book. C++ is a language shrouded in areas of gray; from this
    chapter forward, you will become versed in not only language features, but in
    language nuances. The goal of this chapter will be to begin enhancing your skills
    from those of an average C++ programmer to one who is capable of operating among
    language subtleties successfully while creating maintainable code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The `const` qualifier
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function prototyping
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function overloading
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand non-OO features such as the
    `const` qualifier, function prototyping (including using default values), and
    function overloading (including how standard type conversion affects overloaded
    function choices and may create potential ambiguities). Many of these seemingly
    straightforward topics include an assortment of interesting details and nuances.
    These skills will be necessary in order to move forward with the next chapters
    in the book successfully.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter02](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter02).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in [*Chapter 2*](B19087_02.xhtml#_idTextAnchor072), *Adding
    Language Necessities*, can be found in the subdirectory `Chapter02` in a file
    named `Chp2-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3CM65dF](https://bit.ly/3CM65dF).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Using the const and constexpr qualifiers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add the `const` and `constexpr` qualifiers to variables,
    and discuss how they can be added to functions in both their input parameters
    and as return values. These qualifiers will be used quite liberally as we move
    forward in the C++ language. The use of `const` and `constexpr` can enable values
    to be initialized, yet never again modified. Functions can advertise that they
    will not modify their input parameters, or that their return value may only be
    captured (but not modified) by using `const` or `constexpr`. These qualifiers
    help make C++ a more secure language. Let’s take a look at `const` and `constexpr`
    in action.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: const and constexpr variables
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `const` qualified variable is a variable that must be initialized, and may
    never be assigned a new value. It is seemingly a paradox to pair the usage of
    `const` and a variable together – `const` implies not to change, yet the concept
    of a variable is to inherently hold different values. Nonetheless, it is useful
    to have a strongly type-checked variable whose one and only value can be determined
    at run time. The keyword `const` is added to the variable declaration.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a variable declared using `constexpr` is a constant qualified variable
    – one that may be initialized and never assigned a new value. The usage of `constexpr`
    is becoming preferred whenever its use is possible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, the value of a constant is not known at compile time. An
    example might be if user input or the return value of a function is used to initialize
    a constant. A `const` variable may be easily initialized at runtime. A `constexpr`
    can often, but not always be initialized at runtime. We will consider various
    scenarios in our example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a few examples in the following program. We will break this
    program into two segments for a more targeted explanation, however, the full program
    example can be found in its entirety at the following link:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex1.cpp)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous program segment, notice how we declare a variable with the `const`
    qualifier preceding the data type. Here, `const int MAX = 50;` simply initializes
    `MAX` to 50\. `MAX` may not be modified via assignment later in the code. Out
    of convention, simple `const` and `constexpr` qualified variables (taking the
    place of once used `#define` macros) are often capitalized, whereas values that
    are calculated (or might be calculated) are declared using typical naming conventions.
    Next, we introduce a constant variable using `constexpr int LARGEST = 50;` to
    declare a variable that likewise cannot be modified. This option is becoming the
    preferred usage but is not always possible to utilize.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the definition for function `Minimum()`; notice the use of the
    ternary conditional operator `?:` in this function body. Also notice that this
    function’s return value is qualified with `constexpr` (we will examine this shortly).
    Next, let’s examine the body of the `main()` function as we continue with the
    remainder of this program:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In `main()`, let’s consider the sequence of code in which we prompt the user
    to `"Enter two values: "` into variables `x` and `y`, respectively. Here, we call
    a function `Minimum(x,y)` and pass as actual parameters our two values `x` and
    `y`, which were just read in using `cin` and the extraction operator `>>`. Notice
    that alongside the `const` variable declaration of `min`, we initialize `min`
    with the return value of the function call `Minimum()`. It is important to note
    that setting `min` is bundled as a single declaration and initialization. Had
    this been broken into two lines of code – a variable declaration followed by an
    assignment – the compiler would have flagged an error. Variables qualified with
    `const` may only be initialized with a value, and never assigned a value after
    declaration.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Next, we initialize `smallest` with the return value of function `Minimum(a,
    b);`. Notice that the parameters `a` and `b` are literal values that can be determined
    at compile time. Also notice the return value of the `Minimum()` function has
    been qualified with `constexpr`. This qualification is necessary in order for
    `constexpr smallest` to be initialized with the function’s return value. Note
    that had we tried to pass `x` and `y` to `Minimum()` to set `smallest`, we would
    get an error, as the values of `x` and `y` are not literal values.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: In the last sequence of code in the previous example, notice that we use `MAX`
    (defined in the earlier segment of this full program example) to define a size
    for the fixed-sized array `bigName` in the declaration `char bigName[MAX];`. We
    similarly use `LARGEST` to define a size for the fixed-size array `largeName`.
    Here we see that either the `const` or `constexpr` can be used to size an array
    in this manner. We then further use `MAX` in `setw(MAX)` and `LARGEST` in `setw(LARGEST)`
    to ensure that we do not overflow `bigName` or `largeName`, while reading keyboard
    input with `cin` using the extraction operator `>>`. Finally, we initialize variable
    `const int namelen` with the return value of function `strlen(bigname)` and print
    this value out using `cout`. Note that because `strlen()` is not a function whose
    value is qualified with `constexpr`, we cannot use this return value to initialize
    a `constexpr`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'The output to accompany the aforementioned full program example is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have seen how to `const` and `constexpr` qualify variables, let’s
    consider constant qualification with functions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: const qualification with functions
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The keywords `const` and `constexpr` can also be used in conjunction with functions.
    These qualifiers can be used among parameters to indicate that the parameters
    themselves will not be modified. This is a useful feature—the caller of the function
    will understand that the function will not modify input parameters qualified in
    these manners. However, because non-pointer (and non-reference) variables are
    passed *by value* to functions as copies of the actual parameters on the stack,
    `const` or `constexpr` qualifying these inherent copies of parameters does not
    serve a purpose. Hence, `const` or `constexpr` qualifying parameters that are
    of standard data types is not necessary.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'The same principle applies to return values from functions. A return value
    from a function can be `const` or `constexpr` qualified; however, unless a pointer
    (or reference) is returned, the item passed back on the stack as the return value
    is a copy. For this reason, `const` qualified return values are more meaningful
    when the return type is a pointer to a constant object (which we will cover in
    [*Chapter 3*](B19087_03.xhtml#_idTextAnchor118), *Indirect Addressing: Pointers*,
    and beyond). Note that a `constexpr` qualified return value is required of a function
    whose return value will be used to initialize a `constexpr` variable, as we have
    seen in our previous example. As one final use of `const`, we can utilize this
    keyword when we move onto OO details for a class to specify that a particular
    member function will not modify any data members of that class. We will look at
    this scenario in [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222), *Exploring Classes
    in Detail*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand the use of the `const` and `constexpr` qualifiers for
    variables and have seen potential uses of `const` and `constexpr` in conjunction
    with functions, let us move onward to the next language feature in this chapter:
    function prototypes.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Working with function prototypes
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will examine the mechanics of function prototyping, such
    as necessary placement in files and across multiple files for greater program
    flexibility. We will also add optional names to prototype arguments, as well as
    understand how and why we may choose to add default values to C++ prototypes.
    Function prototypes ensure C++ code is strongly type-checked.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Prior to proceeding to function prototypes, let’s take a moment to review some
    necessary programming terms. A **function definition** refers to the body of code
    comprising a function, whereas a declaration of a function (also known as a **forward
    declaration**) merely introduces a function name with its return type and argument
    types. Forward declarations allow the compiler to perform strong type checking
    between the function call and its definition by instead comparing the call with
    the forward declaration. Forward declarations are useful because function definitions
    do not always appear in a file prior to a function call; sometimes, function definitions
    appear in a separate file from their calls.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Defining function prototypes
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **function prototype** is a forward declaration of a function that describes
    how a function should be correctly invoked. A prototype ensures strong type checking
    between a function call and its definition. A simple function prototype consists
    of the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Function’s return type
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function’s name
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function’s type and number of arguments
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function prototype allows a function call to precede the function’s definition
    or allows for calls to functions that exist in separate files. As we learn about
    more C++ language features, such as exceptions, we will see that additional elements
    contribute to a function’s extended prototype (and extended signature). For now,
    let’s examine a simple example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex2.cpp)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that we prototype `int Minimum(int, int);` near the beginning of the
    aforementioned example. This prototype lets the compiler know that any calls to
    `Minimum()` should take two integer arguments and should return an integer value
    (we’ll discuss type conversions later in this section).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Also notice the use of `[[nodiscard]]` preceding the return type of the function.
    This indicates that the programmer should store the return value or otherwise
    utilize the return value (such as in an expression). The compiler will issue a
    warning if the return value of this function is ignored.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the `main()` function, we call the function `Minimum(x, y)`. At this
    point, the compiler checks that the function call matches the aforementioned prototype
    with respect to type and number of arguments, and return type. Namely, that the
    two arguments are integers (or could easily be converted to integers) and that
    the return type is an integer (or could easily be converted to an integer). The
    return value will be utilized as a value to print using `cout`. Lastly, the function
    `Minimum()` is defined in the file. Should the function definition not match the
    prototype, the compiler will raise an error.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The existence of the prototype allows the call of a given function to be fully
    type-checked prior to the function’s definition being seen by the compiler. The
    current example is of course contrived to demonstrate this point; we could have
    instead switched the order in which `Minimum()` and `main()` appear in the file.
    However, imagine that the definition of `Minimum()` was contained in a separate
    file (the more typical scenario). In this case, the prototype will appear at the
    top of the file that will call this function (along with header file inclusions)
    so that the function call can be fully type-checked against the prototype.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: In the aforementioned multiple file scenario, the file containing the function
    definition will be separately compiled. It will then be the linker’s job to ensure
    that when multiple files are linked together, the function definition and all
    prototypes match so that the linker can resolve any references to such function
    calls. Should the prototypes not match the function definition, the linker will
    not be able to link the various sections of code together into one compiled unit.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at this example’s output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we understand function prototype basics, let’s see how we can add optional
    argument names to function prototypes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Naming arguments in function prototypes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Function prototypes may optionally contain names that may differ from those
    in either the formal or actual parameter lists. Argument names are ignored by
    the compiler, yet can often enhance readability. Let’s revisit our previous example,
    adding optional argument names in the function prototype:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex3.cpp)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example is nearly identical to the one preceding it. However, notice that
    the function prototype contains named arguments `arg1` and `arg2`. These identifiers
    are immediately ignored by the compiler. As such, these named arguments do not
    need to match either the formal or actual parameters of the function and are optionally
    present merely to enhance readability.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The output to accompany this example is the same as the previous example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, let’s move forward with our discussion by adding a useful feature to
    function prototypes: default values.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Adding default values to function prototypes
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Default values** may be specified in function prototypes. These values will
    be used in the absence of actual parameters in the function call and will serve
    as the actual parameters themselves. Default values adhere to the following criteria:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Default values must be specified from right to left in the function prototype,
    without omitting any values.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actual parameters are substituted from left to right in the function call; hence
    the right to left order for default value specification in the prototype is significant.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function prototype may have all, some, or none of its values filled with default
    values, as long as the default values adhere to the aforementioned specifications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example using default values:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex4.cpp)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, notice that a default value is added to the rightmost argument
    in the function prototype for `int Minimum(int arg1, int arg2 = 100000);`. This
    means that when `Minimum()` is called from `main()`, it may be called with either
    one argument, `Minimum(x)`, or with two arguments, `Minimum(x, y)`. When `Minimum()`
    is called with a single argument, the single argument is bound to the leftmost
    argument in the formal parameters of the function, and the default value is bound
    to the next sequential argument in the formal parameter list. However, when `Minimum()`
    is called with two arguments, both of the actual parameters are bound to the formal
    parameters in the function; the default value is not used.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for this example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have a handle on default values within a function prototype, let’s
    expand on this idea by using different default values with prototypes in various
    program scopes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Prototyping with different default values in different scopes
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions may be prototyped in different scopes with different default values.
    This allows functions to be built generically and customized through prototypes
    within multiple applications or for use in multiple sections of code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example illustrating multiple prototypes for the same function (in
    different scopes) using different default values:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex5.cpp)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, notice that `int Minimum(int, int);` is prototyped near the
    top of the file. Then notice that `Minimum()` is re-prototyped in the more local
    scope of `Function1()` as `int Minimum(int arg1, int arg2 = 500);`, specifying
    a default value of `500` for its rightmost argument. Likewise, in the scope of
    `Function2()`, function `Minimum()` is re-prototyped as `int Minimum(int arg1,
    int arg2 = 90);`, specifying a default value of `90` in the rightmost argument.
    When `Minimum()` is called from within `Function1()` or `Function2()`, the local
    prototypes in each of these function scopes, respectively, will be used – each
    with their own default values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: In this fashion, specific areas of a program may be easily customized with default
    values that may be meaningful within a specific portion of an application. However,
    be sure to *only* employ re-prototyping of a function with individualized default
    values within the scope of a calling function to ensure that this customization
    can be easily contained within the safety of a very limited scope. Never re-prototype
    a function in global scope with differing default values – this could lead to
    unexpected and error-prone results.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for the example is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Having now explored function prototypes with respect to default usage in single
    and multiple files, using default values in prototypes, and re-prototyping functions
    in different scopes with individual default values, we are now able to move forward
    with the last major topic in this chapter: function overloading.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Understanding function overloading
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ allows for two or more functions that share a similar purpose, yet differ
    in the types or number of arguments they take, to co-exist with the same function
    name. This is known as **function overloading**. This allows more generic function
    calls to be made, leaving the compiler to choose the correct version of the function
    based on the type of the variable (object) using the function. In this section,
    we will add default values to the basics of function overloading to provide flexibility
    and customization. We will also learn how standard type conversions may impact
    function overloading, and potential ambiguities that may arise (as well as how
    to resolve those types of uncertainties).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Learning the basics of function overloading
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When two or more functions with the same name exist, the differentiating factor
    between these similar functions will be their signature. By varying a function’s
    signature, two or more functions with otherwise identical names may exist in the
    same namespace. Function overloading depends on the signature of a function as
    follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The **signature of a function** refers to a function’s name, plus its type and
    number of arguments.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function’s return type is not included as part of its signature.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two or more functions with the same purpose may share the same name, provided
    that their signatures differ.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function’s signature helps provide an internal, “mangled” name for each function.
    This encoding scheme guarantees that each function is uniquely represented internally
    to the compiler.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a few minutes to understand a slightly larger example that will
    incorporate function overloading. To simplify the explanation, this example is
    broken into three segments; nonetheless, the full program can be found in its
    entirety at the following link:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex6.cpp)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At the beginning of this example, notice that we include the math library with
    `#include <cmath>`, to provide access to basic math functions, such as `pow()`.
    Next, notice the class definitions for `Circle` and `Rectangle`, each with relevant
    data members (`radius` and `area` for `Circle`; `length`, `width`, and `area`
    for `Rectangle`). Once these types have been defined, prototypes for two overloaded
    `Display()` functions are shown. Since the prototypes for the two display functions
    utilize user defined types `Circle` and `Rectangle`, it is important that `Circle`
    and `Rectangle` have both previously been defined. Now, let’s examine the body
    of the `main()` function as we continue with the next segment of this program:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, in the `main()` function, we declare a variable of type `Circle` and two
    variables of type `Rectangle`. We then proceed to load the data members for each
    of these variables in `main()` using the dot operator (`.`) with appropriate values.
    Next in `main()`, there are three calls to `Display()`. The first function call,
    `Display(myCircle)`, will call the version of `Display()` that takes a `Circle`
    as a formal parameter because the actual parameter passed to this function is
    in fact of user defined type `Circle`. The next two function calls, `Display(myRect)`
    and `Display(mySquare)`, will call the overloaded version of `Display()` that
    takes a `Rectangle` as a formal parameter because the actual parameters passed
    in each of these two calls are of type `Rectangle` themselves. Let’s complete
    this program by examining both function definitions for `Display()`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice in the final segment of this example that both versions of `Display()`
    are defined. One of the functions takes a `Circle` as the formal parameter, and
    the overloaded version takes a `Rectangle` as its formal parameter. Each function
    body accesses data members specific to each of its formal parameter types, yet
    the overall functionality of each function is similar in that, in each case, a
    specific shape (`Circle` or `Rectangle`) is displayed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this full program example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, let’s add to our discussion of function overloading by understanding how
    standard type conversion allows for one function to be used by multiple data types.
    This can allow function overloading to be used more selectively.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Eliminating excessive overloading with standard type conversion
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic language types can be converted from one type to another automatically
    by the compiler. This allows the language to supply a smaller set of operators
    to manipulate standard types than would otherwise be necessary. Standard type
    conversion can also eliminate the need for function overloading when preserving
    the exact data type of the function parameters is not crucial. Promotion and demotion
    between standard types are often handled transparently, without explicit casting,
    in expressions including assignments and operations.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example illustrating simple standard type conversions. This example
    does not include function overloading:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex7.cpp)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, the `Maximum()` function takes two double precision floating-point
    numbers as parameters, and the function returns the result as an `int`. First,
    notice that `int Maximum(double, double);` is prototyped near the top of the program
    and is defined at the bottom of this same file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `main()` function, notice that we have three `int` variables defined:
    `result`, `a`, and `x`. The latter two are initialized with values of `6` and
    `10`, respectively. We also have two floats defined and initialized: `float x
    = 5.7, y = 9.89;`. In the first call to function `Maximum()`, we use `x` and `y`
    as actual parameters. These two floating-point numbers are promoted to double
    precision floating-point numbers, and the function is called as expected.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of standard type conversion. Let’s notice that the return
    value of `int Maximum(double, double)` is an integer – not a double. This means
    that the value returned from this function (either formal parameter `a` or `b`)
    will be a copy of `a` or `b`, first truncated to an integer before being used
    as a return value. This return value is neatly assigned to `result`, which has
    been declared an `int` in `main()`. These are all examples of standard type conversion.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Next, `Maximum()` is called with actual parameters `m` and `n`. Similar to the
    previous function call, the integers `m` and `n` are promoted to doubles and the
    function is called as expected. The return value will also be truncated back to
    an `int`, and this value will be passed to `cout` for printing as an integer.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this example is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we understand how function overloading and standard type conversions
    work, let’s examine a situation where the two combined could create an ambiguous
    function call.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Ambiguities arising from function overloading and type conversion
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a function is invoked and the formal and actual parameters match exactly
    in type, no ambiguities arise with respect to which of a selection of overloaded
    functions should be called – the function with the exact match is the obvious
    choice. However, when a function is called and the formal and actual parameters
    differ in type, standard type conversion may be performed on the actual parameters,
    as necessary. There are situations, however, when the formal and actual parameter
    types do not match, and overloaded functions exist. In these cases, it may be
    difficult for the compiler to select which function should be selected as the
    best match. In these cases, a compiler error is generated indicating that the
    available choices paired with the function call itself are ambiguous. Explicit
    type casting or re-prototyping the desired choice in a more local scope can help
    correct these otherwise ambiguous situations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review a simple function illustrating the function overloading, standard
    type conversion, and potential ambiguity:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex8.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter02/Chp2-Ex8.cpp)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this preceding simple example, two versions of `Maximum()` are both prototyped
    and defined. These functions are overloaded; notice that their names are the same,
    but they differ in the types of arguments that they utilize. Also note that their
    return types differ; however, since return type is not part of a function’s signature,
    the return types need not match.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in `main()`, two variables each of type `char`, `int`, and `float` are
    declared and initialized. Next, `Maximum(a, b)` is called and the two `char` actual
    parameters are converted to integers (using their ASCII equivalents) to match
    the `Maximum(int, int)` version of this function. This is the match closest to
    the `char` argument types of `a` and `b`: `Maximum(int, int)` versus `Maximum(float,
    float)`. Then, `Maximum(x, y)` is called with two floats, and this call will exactly
    match the `Maximum(float, float)` version of this function. Similarly, `Maximum(m,
    n)` will be called and will perfectly match the `Maximum(int, int)` version of
    this function.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, notice the next function call (which, not coincidentally, is commented
    out): `Maximum(a, y)`. Here, the first actual parameter perfectly matches the
    first argument in `Maximum(int, int)`, yet the second actual parameter perfectly
    matches the second argument in `Maximum(float, float)`. And for the non-matching
    parameter, a type conversion *could* be applied – but it is not! Instead, this
    function call is flagged by the compiler as an ambiguous function call since either
    of the overloaded functions could be an appropriate match.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: On the line of code `Maximum((float) a, y)`, notice that the function call to
    `Maximum((float) a, y)` forces an explicit typecast to the first actual parameter
    `a`, resolving any potential ambiguity of which overloaded function to call. With
    parameter `a` now cast to be a `float`, this function call easily matches `Maximum(float,
    float)`, and is no longer considered ambiguous. Type casting can be a tool to
    disambiguate crazy situations such as these.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about additional non-OO C++ features that are essential
    building blocks needed to base C++’s object-oriented features. These language
    necessities include using the `const` qualifier, understanding function prototypes,
    using default values in prototypes, function overloading, how standard type conversion
    affects overloaded function choices, and how possible ambiguities may arise (and
    be resolved).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Very importantly, you are now ready to move forward to the next chapter in which
    we will explore indirect addressing using pointers in reasonable detail. The matter-of-fact
    skills that you have accumulated in this chapter will help you more easily navigate
    each progressively more detailed chapter to ensure you are ready to easily tackle
    the OO concepts starting in [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222), *Exploring
    Classes in Detail*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Remember, C++ is a language filled with more gray areas than most other languages.
    The subtle nuances you are accumulating with your skill set will enhance your
    value as a C++ developer – one who can not only navigate and understand existing
    nuanced code but one who can create easily maintainable code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the signature of a function and how is a function’s signature related
    to name mangling in C++? How do you think this facilitates how overloaded functions
    are handled internally by the compiler?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a small C++ program to prompt a user to enter information regarding a
    `Student`, and print out the data. Use the following steps to write your code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a data type for `Student` using a `class` or `struct`. `Student` information
    should minimally include `firstName`, `lastName`, `gpa`, and the `currentCourse`
    in which the `Student` is registered. This information may be stored in a simple
    class. You may utilize either `char` arrays to represent the string fields since
    we have not yet covered pointers, or you may (preferably) utilize the `string`
    type. Also, you may read in this information in the `main()` function rather than
    creating a separate function to read in the data (since the latter will require
    knowledge of pointers or references). Please do not use global (that is, external
    variables).
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a function to print out all the data for the `Student`. Remember to
    prototype this function. Use a default value of `4.0` for `gpa` in the prototype
    of this function. Call this function two ways: once passing in each argument explicitly,
    and once using the default `gpa`.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, overload the print function with one that either prints out selected data
    (for example, `lastName` and `gpa`) or with a version of this function that takes
    a `Student` as an argument (but not a pointer or reference to a `Student` – we’ll
    do that later). Remember to prototype this function.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重载print函数，使其能够打印出选定的数据（例如，`lastName`和`gpa`），或者使用这个函数的版本，它接受一个`Student`作为参数（但不能是`Student`的指针或引用——我们稍后会这样做）。记得要为这个函数编写原型。
- en: Use iostreams for I/O.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用iostreams进行输入输出。
