<html><head></head><body>
<div epub:type="chapter" id="_idContainer013">
<h1 class="chapter-number" id="_idParaDest-27"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-28"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.2.1">Things to Be Careful With</span></h1>
<p><span class="koboSpan" id="kobo.3.1">So, you decided to read a book about memory management in C++ and are as ready to look at the high-level approaches and techniques as you are willing to “get your hands dirty”, so to speak, in order to get fine-grained control over the memory management process. </span><span class="koboSpan" id="kobo.3.2">What an </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">excellent plan!</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Since you know that you are going to be writing very high-level code, but also very low-level code, there are a few things we need to make sure you are aware of such that you do not get in trouble or write code that seems to work but does not, at least </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">not portably.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will point out some aspects of C++ programming that will come into play throughout this book, but that you should be careful with. </span><span class="koboSpan" id="kobo.7.2">This might look like a (very) small compendium of bad practices or an encouragement to get in trouble, but please consider what follows as ways to use somewhat dangerous or tricky features well. </span><span class="koboSpan" id="kobo.7.3">You’re using C++, you have significant freedom of expression, and you get access to features that are useful if you know and understand </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">them well.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">We want code that’s clean and efficient, and we want responsible programmers. </span><span class="koboSpan" id="kobo.9.2">Let’s try to get </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">there together.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we will learn about </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">We will cover some of the ways in which one can get into trouble with C++ code. </span><span class="koboSpan" id="kobo.13.2">Indeed, there are things a compiler cannot reliably diagnose, just as there are things for which the C++ standard does not say what will happen, and writing code that does such things is a recipe for disaster – or at the very least surprising or </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">non-portable behavior.</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">In particular, we will explore how one can get in trouble with pointers. </span><span class="koboSpan" id="kobo.15.2">Since this book discusses memory management, we will use pointers and pointer arithmetic quite often, and being able to distinguish appropriate uses thereof from inappropriate ones will </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">be valuable.</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Finally, we will discuss what kinds of type conversions we can do without resorting to type casts (the main subject of </span><a href="B21071_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.19.1">), and how rarely that’s a good idea, contrary to </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">popular belief.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">Our overall goal will be to learn things we should not do (even though we will do some maneuvers that resemble them, on occasion), and avoid them thereafter, hopefully understanding why we do so. </span><span class="koboSpan" id="kobo.21.2">With that out of the way, we’ll have many chapters to look at things we </span><em class="italic"><span class="koboSpan" id="kobo.22.1">should</span></em><span class="koboSpan" id="kobo.23.1"> do, and how to do </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">them well!</span></span></p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.25.1">Different kinds of evil</span></h1>
<p><span class="koboSpan" id="kobo.26.1">Before delving into some actual practices that require care, it’s interesting to look at the main categories of risks we could run into if our code does not respect the rules of the language. </span><span class="koboSpan" id="kobo.26.2">With each such category comes a form of unpleasantness we should strive </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">to avoid.</span></span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.28.1">Ill-formed, no diagnostic required</span></h2>
<p><span class="koboSpan" id="kobo.29.1">Some constructs </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.30.1">in C++ are said to be </span><strong class="bold"><span class="koboSpan" id="kobo.31.1">Ill-Formed, No Diagnostic Required</span></strong><span class="koboSpan" id="kobo.32.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.33.1">IFNDR</span></strong><span class="koboSpan" id="kobo.34.1">). </span><span class="koboSpan" id="kobo.34.2">Indeed, you will find quite a few occurrences in the standard of </span><em class="italic"><span class="koboSpan" id="kobo.35.1">“if […], the program is ill-formed, with no diagnostic required.”</span></em><span class="koboSpan" id="kobo.36.1"> When something is IFNDR, it means your program is broken. </span><span class="koboSpan" id="kobo.36.2">Bad things could happen, but the compiler is not required to tell you about them (indeed, sometimes, the compiler does not have sufficient information to diagnose the </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">problematic situation).</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.38.1">One Definition Rule</span></strong><span class="koboSpan" id="kobo.39.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.40.1">ODR</span></strong><span class="koboSpan" id="kobo.41.1">) violations, to</span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.42.1"> which we will return in the </span><em class="italic"><span class="koboSpan" id="kobo.43.1">The ODR </span></em><span class="koboSpan" id="kobo.44.1">section later in this chapter, fall under IFNDR. </span><span class="koboSpan" id="kobo.44.2">However, there are other such cases, such as having a global object that has different alignment requirements (through </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">alignas</span></strong><span class="koboSpan" id="kobo.46.1">) in different translation units (different source files, essentially), or having a constructor that delegates to itself either directly or indirectly. </span><span class="koboSpan" id="kobo.46.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.48.1">
class X {
public:
</span><strong class="bold"><span class="koboSpan" id="kobo.49.1">    // #0 delegates to #1 which delegates to #0 which...</span></strong><span class="koboSpan" id="kobo.50.1">
    X(float x) : X{ static_cast&lt;int&gt;(x) } { </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">// #0</span></strong><span class="koboSpan" id="kobo.52.1">
    }
    X(int n) : X{ n + 0.5f } { </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">// #1</span></strong><span class="koboSpan" id="kobo.54.1">
    }
};
int main() {}</span></pre> <p><span class="koboSpan" id="kobo.55.1">Note that your compiler might give a diagnostic; it’s just not required to do so. </span><span class="koboSpan" id="kobo.55.2">It’s not that compilers are lazy – they might even be unable to provide a diagnostic in some cases! </span><span class="koboSpan" id="kobo.55.3">So, be</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.56.1"> careful not to write code that leads to </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">IFNDR situations.</span></span></p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.58.1">Undefined behavior</span></h2>
<p><span class="koboSpan" id="kobo.59.1">We mentioned </span><strong class="bold"><span class="koboSpan" id="kobo.60.1">Undefined Behavior</span></strong><span class="koboSpan" id="kobo.61.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.62.1">UB</span></strong><span class="koboSpan" id="kobo.63.1">) in </span><a href="B21071_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.64.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.65.1">. </span><span class="koboSpan" id="kobo.65.2">UB is often seen as a source of headaches </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.66.1">and pain for C++ programmers but it refers to any behavior for which the C++ standard imposes no requirement. </span><span class="koboSpan" id="kobo.66.2">In practice, this means that if you write code that contains UB, you have no idea what’s going to happen at runtime (at least if you’re aiming for somewhat portable code). </span><span class="koboSpan" id="kobo.66.3">Canonical examples of UB include dereferencing a null pointer or an uninitialized pointer: do that and you’ll be in </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">serious trouble.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">To compilers, UB is not supposed to happen (code that respects the rules of the language does not contain UB, after all). </span><span class="koboSpan" id="kobo.68.2">For that reason, compilers “optimize around” code that contains UB, to sometimes surprising effect: they might begin removing tests and branches, optimizing loops away, and </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">The effects of UB tend to be local. </span><span class="koboSpan" id="kobo.70.2">For instance, in the following example, there is a test that ensures that </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">p</span></strong><span class="koboSpan" id="kobo.72.1"> is not null before using </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">*p</span></strong><span class="koboSpan" id="kobo.74.1"> in one case, but there is at least one access to </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">*p</span></strong><span class="koboSpan" id="kobo.76.1"> that is unchecked. </span><span class="koboSpan" id="kobo.76.2">This code is broken (the unchecked access to </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">*p</span></strong><span class="koboSpan" id="kobo.78.1"> is UB), so the compiler is allowed to rewrite it in such a way that all tests to verify that </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">p</span></strong><span class="koboSpan" id="kobo.80.1"> is not null are effectively removed. </span><span class="koboSpan" id="kobo.80.2">After all, the damage would be done if </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">p</span></strong><span class="koboSpan" id="kobo.82.1"> were </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">nullptr</span></strong><span class="koboSpan" id="kobo.84.1">, so the compiler is entitled to assume that the programmer passed a non-null pointer to </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">the function!</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.86.1">
int g(int);
int f(int *p) {
    if(p != nullptr)
        return g(*p); // Ok, we know p is not null
    return *p; // oops, if p == nullptr this is UB
}</span></pre> <p><span class="koboSpan" id="kobo.87.1">The whole body of </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">f()</span></strong><span class="koboSpan" id="kobo.89.1"> could legitimately be rewritten by your compiler as </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">return g(*p)</span></strong><span class="koboSpan" id="kobo.91.1"> in this case, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">return *p</span></strong><span class="koboSpan" id="kobo.93.1"> statement being turned into </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">unreachable code.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">The potential for UB hides in various places in the language, including signed integer overflow, accessing an array out of bounds, data races, and so on. </span><span class="koboSpan" id="kobo.95.2">There are ongoing efforts to reduce the </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.96.1">number of potential UB cases (there’s even a study group, </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">SG12</span></strong><span class="koboSpan" id="kobo.98.1">, dedicated</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.99.1"> to this effort), but UB will likely remain part of the language for the foreseeable future, and we need to be aware </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">of it.</span></span></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.101.1">Implementation-defined behavior</span></h2>
<p><span class="koboSpan" id="kobo.102.1">Some parts of the </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.103.1">standard fall under the umbrella of </span><strong class="bold"><span class="koboSpan" id="kobo.104.1">implementation-defined behavior</span></strong><span class="koboSpan" id="kobo.105.1">, or behavior that you can count on with a specific platform. </span><span class="koboSpan" id="kobo.105.2">This is behavior that your platform of choice is supposed to document, but that is not guaranteed to be portable to </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">other platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">Implementation-defined behavior occurs in many situations and includes such things as implementation-defined limits: the maximum number of nested parentheses; the maximum number of case labels in a switch statement; the actual size of an object; the maximum number of recursive calls in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">constexpr</span></strong><span class="koboSpan" id="kobo.109.1"> function; the number of bits in a byte; and so on. </span><span class="koboSpan" id="kobo.109.2">Other well-known cases of implementation-defined behavior include the number of bytes in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">int</span></strong><span class="koboSpan" id="kobo.111.1"> object or whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">char</span></strong><span class="koboSpan" id="kobo.113.1"> type is a signed or an unsigned </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">integral type.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">Implementation-defined behavior is not really a source of evil, but it can be problematic if one strives for portable code but depends on some non-portable assumptions. </span><span class="koboSpan" id="kobo.115.2">It is sometimes useful to spell one’s assumptions in code through </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">static_assert</span></strong><span class="koboSpan" id="kobo.117.1"> when the assumption can be validated at compile-time or some similar, potentially runtime mechanisms in order to realize—before it’s too late—that these assumptions are broken for a given target platform. </span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.118.1">For example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.119.1">
int main() {
    // our code supposes int is four bytes wide, a non-
    // portable assumption
    static_assert(sizeof(int)==4);
    // only compiles if condition is true...
</span><span class="koboSpan" id="kobo.119.2">}</span></pre> <p><span class="koboSpan" id="kobo.120.1">Unless you are convinced that your code will never need to be ported to another platform, strive to rely as little as possible on implementation-defined behavior, and if you do, make sure that you validate (through </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">static_assert</span></strong><span class="koboSpan" id="kobo.122.1"> if possible, at runtime if there’s no other </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.123.1">choice) and document this situation. </span><span class="koboSpan" id="kobo.123.2">It might help you avoid some nasty surprises in </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">the future.</span></span></p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.125.1">Unspecified behavior (not documented)</span></h2>
<p><span class="koboSpan" id="kobo.126.1">Where implementation-defined behavior is non-portable but documented for a given platform, unspecified behavior is a behavior that, even for a well-formed program given correct data, behaves in a way that depends on the implementation but does not need to </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">be documented.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">Some cases of unspecified behavior include the state of a moved-from object (said to be </span><strong class="bold"><span class="koboSpan" id="kobo.129.1">valid but unspecified</span></strong><span class="koboSpan" id="kobo.130.1">, thus </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.131.1">more of an unspecified state than an unspecified behavior), the order of evaluation of subexpressions in a function call, that is, whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">f(g(),h())</span></strong><span class="koboSpan" id="kobo.133.1"> will evaluate </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">g()</span></strong><span class="koboSpan" id="kobo.135.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">h()</span></strong><span class="koboSpan" id="kobo.137.1"> first, the values in a newly allocated chunk of memory, and so on. </span><span class="koboSpan" id="kobo.137.2">This latter example is interesting to our study; a debug build might fill newly allocated chunks of memory with a recognizable bit pattern to help in the debugging process, and an optimized build with the same toolset could leave the initial bits of a newly allocated chunk of memory “uninitialized”, with the bits it held at the time when the allocation was performed, to get </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">speed improvements.</span></span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.139.1">The ODR</span></h2>
<p><span class="koboSpan" id="kobo.140.1">The ODR, simply </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.141.1">summarized, states that there shall be only one definition of each “thing” (function, object in a scope, enumeration, template, and so on) in a translation unit, although there can be multiple declarations of that thing. </span><span class="koboSpan" id="kobo.141.2">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.143.1">
int f(int); // declaration
int f(int n); // Ok, declaration again
int f(int m) { return m; } // Ok, definition
// int f(int) { return 3; } // not Ok (ODR violation)</span></pre> <p><span class="koboSpan" id="kobo.144.1">In C++, avoiding ODR violations is important, as these “evils” can escape the compiler’s scrutiny and fall into the realm of IFNDR situations. </span><span class="koboSpan" id="kobo.144.2">For example, due to the separate compilation of source files, a header file containing the definition of a non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">inline</span></strong><span class="koboSpan" id="kobo.146.1"> function will lead to that definition being replicated in each source file that includes that same header. </span><span class="koboSpan" id="kobo.146.2">Then, each compilation might succeed, and the fact that there are multiple definitions </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.147.1">of that function in the same build might be detected later (at link time) or just left undetected and </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">cause havoc.</span></span></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.149.1">Erroneous behavior</span></h2>
<p><span class="koboSpan" id="kobo.150.1">Ongoing security-related efforts in C++ have led to discussions on a new kind of “evil” tentatively </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.151.1">named </span><em class="italic"><span class="koboSpan" id="kobo.152.1">erroneous behavior</span></em><span class="koboSpan" id="kobo.153.1">. </span><span class="koboSpan" id="kobo.153.2">This new category is meant to cover situations that could have been UB in the past, but for which we could issue diagnostics and provide well-defined behavior. </span><span class="koboSpan" id="kobo.153.3">The behavior would still be incorrect, but erroneous behavior would, in a way, provide boundaries to the consequences. </span><span class="koboSpan" id="kobo.153.4">Note that work on erroneous behavior is ongoing as of this writing, and this new wording feature might </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">target C++26.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">One use case envisioned for erroneous behavior is reading from an uninitialized variable, where the implementation could (for safety reasons) provide a fixed value for the bits read, and the conceptual error that stems from reading that variable would be something that implementations are encouraged to diagnose. </span><span class="koboSpan" id="kobo.155.2">Another use case would be forgetting to return a value from a non-void </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">assignment operator.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">Now that we’ve looked at the large “families” of unpleasantness that might hit our programs if we don’t behave, let’s delve into some of the main facilities that could get us in trouble and see what we should </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">avoid doing.</span></span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.159.1">Pointers</span></h1>
<p><a href="B21071_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.160.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.161.1"> looked at</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.162.1"> pointers in C++ in the sense of what they represent and what they mean. </span><span class="koboSpan" id="kobo.162.2">It described what pointer arithmetic is, and what it allows us to do. </span><span class="koboSpan" id="kobo.162.3">We will now examine practical uses of pointer arithmetic, with both proper and improper uses of this low-level (but sometimes </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">precious) tool.</span></span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.164.1">Uses of pointer arithmetic within an array</span></h2>
<p><span class="koboSpan" id="kobo.165.1">Pointer </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.166.1">arithmetic is a nice and useful tool, but it’s a sharp</span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.167.1"> one that tends to be misused. </span><span class="koboSpan" id="kobo.167.2">With raw arrays, the following two loops, labeled </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">A</span></strong><span class="koboSpan" id="kobo.169.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">B</span></strong><span class="koboSpan" id="kobo.171.1">, behave in exactly the </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">same way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.173.1">
void f(int);
int main() {
    int vals[]{ 2,3,5,7,11 };
    enum { N = sizeof vals / sizeof vals[0] };
    for(int i = 0; i != N; ++i) // A
      f(vals[i]);
    for(int *p = vals; p != vals + N; ++p) // B
      f(*p);
}</span></pre> <p><span class="koboSpan" id="kobo.174.1">You might wonder about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">vals + N</span></strong><span class="koboSpan" id="kobo.176.1"> part in loop </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">B</span></strong><span class="koboSpan" id="kobo.178.1">, but it’s valid (and idiomatic) C++ code. </span><span class="koboSpan" id="kobo.178.2">You can observe the pointer just past the end of an array, even though you’re not allowed to observe what it points to; the standard guarantees that this specific one-past-the-end address is accessible to your program. </span><span class="koboSpan" id="kobo.178.3">However, no such guarantee is provided for the following address, so </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">be careful!</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">As long as you respect the rules, you can use pointers to jump back and forth within an array. </span><span class="koboSpan" id="kobo.180.2">If you overreach and use a pointer to go further than one past-the-end, you will end up in UB </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.181.1">territory; that is, you might be trying to access </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.182.1">an address that’s not in your process’ </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">address space:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.184.1">
int arr[10]{ }; // all elements initialized to zero
int *p = &amp;arr[3];
p += 4; assert(p == &amp;arr[7]);
--p;    assert(p == &amp;arr[6]);
p += 4; // still Ok as long as you don't try to access *p
++p; // UB, not guaranteed to be valid</span></pre> <h2 id="_idParaDest-38"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.185.1">Pointer interconvertibility</span></h2>
<p><span class="koboSpan" id="kobo.186.1">The C++ standard </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.187.1">defines what it means for an object to be </span><strong class="bold"><span class="koboSpan" id="kobo.188.1">pointer-interconvertible</span></strong><span class="koboSpan" id="kobo.189.1"> with another. </span><span class="koboSpan" id="kobo.189.2">Pointer-interconvertibility means that one can use a pointer to one as a pointer to the other, normally through </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">reinterpret_cast</span></strong><span class="koboSpan" id="kobo.191.1"> (we will expand on this in </span><a href="B21071_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.192.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.193.1">), as they have the same address. </span><span class="koboSpan" id="kobo.193.2">Broadly speaking, the following points </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">hold true:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.195.1">An object is pointer-interconvertible </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">with itself</span></span></li>
<li><span class="koboSpan" id="kobo.197.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">union</span></strong><span class="koboSpan" id="kobo.199.1"> is pointer-interconvertible with its data members, as well as their first data member if they are </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">compound types</span></span></li>
<li><span class="koboSpan" id="kobo.201.1">With some restrictions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">x</span></strong><span class="koboSpan" id="kobo.203.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">y</span></strong><span class="koboSpan" id="kobo.205.1"> are pointer-interconvertible with one another if one is an object and the other one is of the same type as the first non-static data member of </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">that object</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.207.1">Some examples are </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">included here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.209.1">
struct X { int n; };
struct Y : X {};
union U { X x; short s; };
int main() {
    X x;
    Y y;
    U u;
    // x is pointer-interconvertible with x
    // u is pointer-interconvertible with u.x
    // u is pointer-interconvertible with u.s
    // y is pointer-interconvertible with y.x
}</span></pre> <p><span class="koboSpan" id="kobo.210.1">If you try to apply </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">reinterpret_cast</span></strong><span class="koboSpan" id="kobo.212.1"> in a way that does not respect pointer-interconvertibility rules, your code is technically incorrect and is not guaranteed to work in practice. </span><span class="koboSpan" id="kobo.212.2">Don’t </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">do that.</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">We will occasionally</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.215.1"> use the pointer-interconvertibility property in our code examples, including in the </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">next section.</span></span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.217.1">Uses of pointer arithmetic within an object</span></h2>
<p><span class="koboSpan" id="kobo.218.1">Pointer arithmetic </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.219.1">within an object is also allowed in C++, although</span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.220.1"> one should be careful about how this is handled (using the appropriate casts, which we will explore in </span><a href="B21071_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.221.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.222.1">, and ensuring that one performs pointer </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">arithmetic appropriately).</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">For example, the following code is correct, albeit not something one should seek to do (it makes no sense, and it does things in unnecessarily complicated ways, but it’s legal and does </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">no harm):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.226.1">
struct A {
    int a;
    short s;
};
short * f(A &amp;a) {
    // pointer interconvertibility in action!
</span><span class="koboSpan" id="kobo.226.2">    int *p = reinterpret_cast&lt;int*&gt;(&amp;a);
    p++;
    return reinterpret_cast&lt;short*&gt;(p); // Ok, within the
                                       // same object
}
int main() {
    A a;
    short *p = f(a);
    *p = 3; // fine, technically
}</span></pre> <p><span class="koboSpan" id="kobo.227.1">We will not abuse this aspect of the C++ language in this book, but we do need to be aware of it in order to write correct, </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">low-level code.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.229.1">About the difference between pointer and address</span></p>
<p class="callout"><span class="koboSpan" id="kobo.230.1">In order to strengthen hardware and software security, there has been work on hardware architectures that can provide a form of “pointer tagging”, which allows the hardware tracking of pointer provenance, among other things. </span><span class="koboSpan" id="kobo.230.2">Two well-known examples</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.231.1"> are </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.232.1">the CHERI</span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.233.1"> architecture (</span><a href="https://packt.link/cJeLo"><span class="koboSpan" id="kobo.234.1">https://packt.link/cJeLo</span></a><span class="koboSpan" id="kobo.235.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">Memory Tagging Extensions</span></strong><span class="koboSpan" id="kobo.237.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.238.1">MTEs</span></strong><span class="koboSpan" id="kobo.239.1">) (Linux: </span><a href="https://packt.link/KXeRn"><span class="koboSpan" id="kobo.240.1">https://packt.link/KXeRn</span></a><span class="koboSpan" id="kobo.241.1"> | Android: </span><a href="https://packt.link/JDfEo"><span class="koboSpan" id="kobo.242.1">https://packt.link/JDfEo</span></a><span class="koboSpan" id="kobo.243.1">, and </span><a href="https://packt.link/fQM2T"><span class="koboSpan" id="kobo.244.1">https://packt.link/fQM2T</span></a><span class="koboSpan" id="kobo.245.1">| </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">Windows: </span></span><a href="https://packt.link/DgSaH"><span class="No-Break"><span class="koboSpan" id="kobo.247.1">https://packt.link/DgSaH</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.248.1">).</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.249.1">To benefit from such hardware, the language needs to distinguish between the low-level idea of addresses and the high-level idea of pointers, as the latter could take into account the fact that a pointer is more than just a memory location. </span><span class="koboSpan" id="kobo.249.2">If your code absolutely needs to compare unrelated pointers for ordering, one thing you can do is cast the pointers to </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">std::intprt_t</span></strong><span class="koboSpan" id="kobo.251.1"> or to </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">std::uintptr_t</span></strong><span class="koboSpan" id="kobo.253.1"> and compare the (numeric) results instead of comparing the actual pointers. </span><span class="koboSpan" id="kobo.253.2">Note that compiler support for those two</span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.254.1"> types is optional, although all major compiler</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.255.1"> vendors </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">offer it.</span></span></p>
<h3><span class="koboSpan" id="kobo.257.1">The null pointer</span></h3>
<p><span class="koboSpan" id="kobo.258.1">The idea of a </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.259.1">null pointer as a recognizable value for pointers that lead to nowhere valid can be traced back</span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.260.1"> to C.A.R. </span><span class="koboSpan" id="kobo.260.2">Hoare (</span><a href="https://packt.link/ByfeX"><span class="koboSpan" id="kobo.261.1">https://packt.link/ByfeX</span></a><span class="koboSpan" id="kobo.262.1">). </span><span class="koboSpan" id="kobo.262.2">In the C language, through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">NULL</span></strong><span class="koboSpan" id="kobo.264.1"> macro, it has been represented first as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">char*</span></strong><span class="koboSpan" id="kobo.266.1"> of value </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">0</span></strong><span class="koboSpan" id="kobo.268.1">, then as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">void*</span></strong><span class="koboSpan" id="kobo.270.1"> of value </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">0</span></strong><span class="koboSpan" id="kobo.272.1">, then in C++ as value </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">0</span></strong><span class="koboSpan" id="kobo.274.1"> simply since such things as </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">int *p = NULL;</span></strong><span class="koboSpan" id="kobo.276.1"> with a typed </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">NULL</span></strong><span class="koboSpan" id="kobo.278.1"> were legal C but not legal C++. </span><span class="koboSpan" id="kobo.278.2">This is because the type system is stricter in C++. </span><span class="koboSpan" id="kobo.278.3">Note that a pointer with value </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">0</span></strong><span class="koboSpan" id="kobo.280.1"> does not mean “point to address zero” as this address is in itself perfectly valid and is used as such on </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">many platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">In C++, the preferred way of expressing a null pointer is </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">nullptr</span></strong><span class="koboSpan" id="kobo.284.1">, an object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">std::nullptr_t</span></strong><span class="koboSpan" id="kobo.286.1"> type that converts to pointers of any type and behaves as expected. </span><span class="koboSpan" id="kobo.286.2">This solves some longstanding issues with literal </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">0</span></strong><span class="koboSpan" id="kobo.288.1"> in C++, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.290.1">
int f(int); //#0
int f(char*); // #1
int main() {
    int n = 3;
    char c;
    f(n); // calls #0
    f(&amp;c); // calls #1
    </span><strong class="bold"><span class="koboSpan" id="kobo.291.1">f(0); // ambiguous before C++11, calls #0 since</span></strong><span class="koboSpan" id="kobo.292.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.293.1">f(nullptr); // only since C++11; unambiguously calls #1</span></strong><span class="koboSpan" id="kobo.294.1">
}</span></pre> <p><span class="koboSpan" id="kobo.295.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">nullptr</span></strong><span class="koboSpan" id="kobo.297.1"> is not a pointer; it’s an object that implicitly converts to a pointer. </span><span class="koboSpan" id="kobo.297.2">For that reason, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">std::is_pointer_v&lt;nullptr&gt;</span></strong><span class="koboSpan" id="kobo.299.1"> trait is false, and C++ offers a distinct trait named </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">std::is_null_pointer&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.301.1"> to statically test whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">T</span></strong><span class="koboSpan" id="kobo.303.1"> is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">std::nullptr_t</span></strong><span class="koboSpan" id="kobo.305.1"> or not (taking </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">const</span></strong><span class="koboSpan" id="kobo.307.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">volatile</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.309.1">into account).</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">Dereferencing a null pointer is UB, just as dereferencing an uninitialized pointer is. </span><span class="koboSpan" id="kobo.310.2">The point of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">nullptr</span></strong><span class="koboSpan" id="kobo.312.1"> in your code is to make that state recognizable: </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">nullptr</span></strong><span class="koboSpan" id="kobo.314.1"> is a distinguishable value, whereas an uninitialized pointer could </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">be anything.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">In C++ (contrary to C), arithmetic </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.317.1">on a null pointer is well-defined… as long as you add zero to the null pointer. </span><span class="koboSpan" id="kobo.317.2">Or, to put it differently: if you add zero to a null pointer, the code remains well-defined, but if you add anything else, you’re on your own. </span><span class="koboSpan" id="kobo.317.3">There’s an explicit provision to that effect in wg21.link/c++draft/expr.add#4.1. </span><span class="koboSpan" id="kobo.317.4">This means that the following is correct as in the case of an empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">Array</span></strong><span class="koboSpan" id="kobo.319.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">begin()</span></strong><span class="koboSpan" id="kobo.321.1"> yields </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">nullptr</span></strong><span class="koboSpan" id="kobo.323.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">size()</span></strong><span class="koboSpan" id="kobo.325.1"> yields zero, so </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">end()</span></strong><span class="koboSpan" id="kobo.327.1"> effectively computes </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">nullptr+0</span></strong><span class="koboSpan" id="kobo.329.1">, which respects </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">the rules:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">
template &lt;class T&gt; class Array {
    T *elems = nullptr; // pointer to the beginning
    std::size_t nelems = 0; // number of elements
public:
    Array() = default; // =empty array
    // ...
</span><span class="koboSpan" id="kobo.331.2">    auto size() const noexcept { return nelems; }
    // note: could return nullptr
    auto begin() noexcept { return elems; }
    auto end() noexcept { return begin() + size(); }
};</span></pre> <p><span class="koboSpan" id="kobo.332.1">We will return to this </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">Array</span></strong><span class="koboSpan" id="kobo.334.1"> example in more detail in </span><em class="italic"><span class="koboSpan" id="kobo.335.1">Chapters 12</span></em><span class="koboSpan" id="kobo.336.1">, </span><em class="italic"><span class="koboSpan" id="kobo.337.1">13</span></em><span class="koboSpan" id="kobo.338.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.339.1">14</span></em><span class="koboSpan" id="kobo.340.1">; it will help us discuss</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.341.1"> several important aspects of efficient memory management techniques. </span><span class="koboSpan" id="kobo.341.2">For now, let’s look at another source of risky </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">programming maneuvers.</span></span></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.343.1">Type punning</span></h1>
<p><span class="koboSpan" id="kobo.344.1">Another area where a C++ programmer can get</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.345.1"> into trouble is </span><strong class="bold"><span class="koboSpan" id="kobo.346.1">type punning</span></strong><span class="koboSpan" id="kobo.347.1">. </span><span class="koboSpan" id="kobo.347.2">By type punning, we mean techniques that subvert the language’s type system somewhat. </span><span class="koboSpan" id="kobo.347.3">The consecrated tool to perform type conversions is casts, as they are explicit in source code text and (apart from C-style casts) express the intent for the conversion, but that topic deserves its own chapter (</span><a href="B21071_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.348.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.349.1">, if </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">you’re wondering).</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">In this section, we will examine other ways to achieve type punning, including both recommendable ones and others that you should seek </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">to avoid.</span></span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.353.1">Type punning through members of a union</span></h2>
<p><span class="koboSpan" id="kobo.354.1">A union is a</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.355.1"> type for which the members are all at the same address. </span><span class="koboSpan" id="kobo.355.2">The size of a union is the size of its largest member, and the alignment of a union is the strictest alignment of its members. </span></p>
<p><span class="koboSpan" id="kobo.356.1">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.358.1">
struct X {
    char c[5]; short s;
} x;
// one byte of padding between x.c and x.s
static_assert(sizeof x.s == 2 &amp;&amp; sizeof x == 8);
static_assert(alignof(x) == alignof(short));
union U {
    int n; X x;
} u;
static_assert(sizeof u == sizeof u.x);
static_assert(alignof(u) == alignof(u.n));
int main() {}</span></pre> <p><span class="koboSpan" id="kobo.359.1">It’s tempting to think that one can use a union to implicitly convert such things as a four-byte floating point number into a four-byte integral number, and in the C language (not C++), that is </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">indeed possible.</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">Even though there is a widespread belief that this practice is legal in C++, the reality is that it is not (with one special caveat, which we will explore shortly). </span><span class="koboSpan" id="kobo.361.2">Indeed, in C++, the last member of a union one has written to is called</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.362.1"> the union’s </span><strong class="bold"><span class="koboSpan" id="kobo.363.1">active member</span></strong><span class="koboSpan" id="kobo.364.1">, and that member is the only one your code is allowed to read from. </span><span class="koboSpan" id="kobo.364.2">Thus, the following code is illegal since reading</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.365.1"> from a non-active member of a union is UB, and UB is not allowed in a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">constexpr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.367.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.368.1">
union U {
    float f;
    int n;
};
constexpr int f() {
    U u{ 1.5f };
    return u.n; // UB (u.f is the active member)
}
int main() {
    // constexpr auto r0 = f(); // would not compile
    auto r1 = f(); // compiles, as not a constexpr
                  // context, but still UB
}</span></pre> <p><span class="koboSpan" id="kobo.369.1">As you might know, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">constexpr</span></strong><span class="koboSpan" id="kobo.371.1"> function such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">f()</span></strong><span class="koboSpan" id="kobo.373.1"> in the preceding example cannot contain code that is UB if it is called in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">constexpr</span></strong><span class="koboSpan" id="kobo.375.1"> context. </span><span class="koboSpan" id="kobo.375.2">This sometimes makes it an interesting tool to make </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">a point.</span></span></p>
<p><span class="koboSpan" id="kobo.377.1">There is a caveat</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.378.1"> with respect to conversions between </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">union</span></strong><span class="koboSpan" id="kobo.380.1"> members, and that caveat is associated with the common </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">initial sequence.</span></span></p>
<h3><span class="koboSpan" id="kobo.382.1">Common initial sequence</span></h3>
<p><span class="koboSpan" id="kobo.383.1">As explained at wg21.link/class.mem.general#23, the </span><strong class="bold"><span class="koboSpan" id="kobo.384.1">common initial sequence</span></strong><span class="koboSpan" id="kobo.385.1"> of two</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.386.1"> structs is </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.387.1">made of the initial members of these two structs that have corresponding layout-compatible types. </span><span class="koboSpan" id="kobo.387.2">For example, the common initial sequence of </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">A</span></strong><span class="koboSpan" id="kobo.389.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">B</span></strong><span class="koboSpan" id="kobo.391.1"> is made of their first two members (</span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">int</span></strong><span class="koboSpan" id="kobo.393.1"> is layout-compatible with </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">const int</span></strong><span class="koboSpan" id="kobo.395.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">float</span></strong><span class="koboSpan" id="kobo.397.1"> is layout-compatible with </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">volatile float</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.400.1">
struct A { int n; float f; char c; };
struct B{ const int b0; volatile float x; };</span></pre> <p><span class="koboSpan" id="kobo.401.1">With a union, it is possible to read from a non-active member if the value read is part of both the common initial sequence of that member and of the active member. </span><span class="koboSpan" id="kobo.401.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.403.1">
struct A { int n0; char c0; };
struct B { int n1; char c1; float x; };
union U {
    A a;
    B b;
};
int f() {
    U u{ { 1, '2' } }; // initializes u.a
    return u.b.n1; // not UB
}
int main() {
    return f(); // Ok
}</span></pre> <p><span class="koboSpan" id="kobo.404.1">Note that such type punning should be kept to a minimum, as it can make it harder to reason about source code, but it can be quite useful. </span><span class="koboSpan" id="kobo.404.2">For example, it can be used to implement some interesting underlying representations for classes that can have two distinct </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.405.1">representations (classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">optional</span></strong><span class="koboSpan" id="kobo.407.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">string</span></strong><span class="koboSpan" id="kobo.409.1">), making it easier to switch from one to the other. </span><span class="koboSpan" id="kobo.409.2">Some useful optimizations can be built </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">on this.</span></span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.411.1">The intptr_t and uintptr_t types</span></h2>
<p><span class="koboSpan" id="kobo.412.1">As mentioned earlier in </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.413.1">this chapter, one cannot </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.414.1">directly</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.415.1"> compare pointers to arbitrary locations in memory in a well-defined manner in C++. </span><span class="koboSpan" id="kobo.415.2">One can, however, compare the integral values associated with pointers in a well-defined manner, such </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">as here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.417.1">
#include &lt;iostream&gt;
#include &lt;cstdint&gt;
int main() {
    using namespace std;
    int m,
       n;
    // simply comparing &amp;m with &amp;n is not allowed
    if(reinterpret_cast&lt;intptr_t&gt;(&amp;m) &lt;
      reinterpret_cast&lt;intptr_t&gt;(&amp;n))
      cout &lt;&lt; "m precedes n in address order\n";
    else
      cout &lt;&lt; "n precedes m in address order\n";
}</span></pre> <p><span class="koboSpan" id="kobo.418.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">std::intptr_t</span></strong><span class="koboSpan" id="kobo.420.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">std::uintptr_t</span></strong><span class="koboSpan" id="kobo.422.1"> types are aliases for integral types that are large enough to hold an address. </span><span class="koboSpan" id="kobo.422.2">Use the signed type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">intptr_t</span></strong><span class="koboSpan" id="kobo.424.1">, for operations that could </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.425.1">lead</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.426.1"> to</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.427.1"> negative values (for </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">example, subtraction).</span></span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.429.1">The std::memcpy() function</span></h2>
<p><span class="koboSpan" id="kobo.430.1">For historical (and C compatibility) reasons, </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">std::memcpy()</span></strong><span class="koboSpan" id="kobo.432.1"> is </span><em class="italic"><span class="koboSpan" id="kobo.433.1">special</span></em><span class="koboSpan" id="kobo.434.1"> as it can start the </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.435.1">lifetime of </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.436.1">an object if used appropriately. </span><span class="koboSpan" id="kobo.436.2">An incorrect use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">std::memcpy()</span></strong><span class="koboSpan" id="kobo.438.1"> for type punning would be </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.440.1">
// suppose this holds for this example
static_assert(sizeof(int) == sizeof(float));
#include &lt;cassert&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
int main() {
    float f = 1.5f;
    void *p = malloc(sizeof f);
    assert(p);
    int *q = std::memcpy(p, &amp;f, sizeof f);
    int value = *q; // UB
    //
}</span></pre> <p><span class="koboSpan" id="kobo.441.1">The reason why this is illegal is that the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">std::memcpy()</span></strong><span class="koboSpan" id="kobo.443.1"> copies a </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">float</span></strong><span class="koboSpan" id="kobo.445.1"> object into the storage pointed to by </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">p</span></strong><span class="koboSpan" id="kobo.447.1">, effectively starting the lifetime of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">float</span></strong><span class="koboSpan" id="kobo.449.1"> object in that storage. </span><span class="koboSpan" id="kobo.449.2">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">q</span></strong><span class="koboSpan" id="kobo.451.1"> is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">int*</span></strong><span class="koboSpan" id="kobo.453.1">, dereferencing it </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">is UB.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">On the other hand, the following is legal and shows how </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">std::memcpy()</span></strong><span class="koboSpan" id="kobo.457.1"> can be used for </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">type punning:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.459.1">
// suppose this holds for this example
static_assert(sizeof(int) == sizeof(float));
#include &lt;cassert&gt;
#include &lt;cstring&gt;
int main() {
    float f = 1.5f;
    int value;
    std::memcpy(&amp;value, &amp;f, sizeof f); // Ok
    // ...
</span><span class="koboSpan" id="kobo.459.2">}</span></pre> <p><span class="koboSpan" id="kobo.460.1">Indeed, in this second example, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">std::memcpy()</span></strong><span class="koboSpan" id="kobo.462.1"> to copy the bits from </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">f</span></strong><span class="koboSpan" id="kobo.464.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">value</span></strong><span class="koboSpan" id="kobo.466.1"> starts the</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.467.1"> lifetime of </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">value</span></strong><span class="koboSpan" id="kobo.469.1">. </span><span class="koboSpan" id="kobo.469.2">That object can be </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.470.1">used as any other </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">int</span></strong><span class="koboSpan" id="kobo.472.1"> from that </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">point on.</span></span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.474.1">The special cases of char*, unsigned char*, and std::byte*</span></h2>
<p><span class="koboSpan" id="kobo.475.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">char*</span></strong><span class="koboSpan" id="kobo.477.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">unsigned char*</span></strong><span class="koboSpan" id="kobo.479.1"> (not </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">signed char*</span></strong><span class="koboSpan" id="kobo.481.1">), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">std::byte*</span></strong><span class="koboSpan" id="kobo.483.1"> types have</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.484.1"> special </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.485.1">status</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.486.1"> in C++ as they can </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.487.1">literally point </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.488.1">anywhere and alias </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.489.1">anything (</span><a href="http://wg21.link/basic.lval#11"><span class="koboSpan" id="kobo.490.1">wg21.link/basic.lval#11</span></a><span class="koboSpan" id="kobo.491.1">). </span><span class="koboSpan" id="kobo.491.2">For that reason, if you need to access the underlying bytes of the value representation of an object, these types are an important tool in </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">your toolbox.</span></span></p>
<p><span class="koboSpan" id="kobo.493.1">We will, later in this book, occasionally resort to these types to perform low-level byte manipulation. </span><span class="koboSpan" id="kobo.493.2">Note that such maneuvers are inherently fragile and non-portable, as such details as the order of bytes in an integer can vary from platform to platform. </span><span class="koboSpan" id="kobo.493.3">Use such low-level facilities </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">with care.</span></span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.495.1">The std::start_lifetime_as&lt;T&gt;() function</span></h2>
<p><span class="koboSpan" id="kobo.496.1">One last </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.497.1">set of </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.498.1">facilities for this chapter is </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">std::start_lifetime_as&lt;T&gt;()</span></strong><span class="koboSpan" id="kobo.500.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">std::start_lifetime_as_array&lt;T&gt;()</span></strong><span class="koboSpan" id="kobo.502.1">. </span><span class="koboSpan" id="kobo.502.2">These functions have been discussed for years but came into their own with C++23. </span><span class="koboSpan" id="kobo.502.3">Their role is to take as arguments something such as a buffer of raw memory bytes and return a pointer to some </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">T</span></strong><span class="koboSpan" id="kobo.504.1"> (pointing to that buffer) whose lifetime has started, such that the pointee can be used as such from that </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">point on:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.506.1">
static_assert(sizeof(short) == 2);
#include &lt;memory&gt;
int main() {
    char buf[]{ 0x00, 0x01, 0x02, 0x03 };
    short* p = std::start_lifetime_as&lt;short&gt;(buf);
    // use *p as a short
}</span></pre> <p><span class="koboSpan" id="kobo.507.1">This is, again, a low-level feature to be used with care. </span><span class="koboSpan" id="kobo.507.2">The intent here is to be able to implement such things as low-level file I/O and networking code (for example, receiving a UDP packet and</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.508.1"> treating its value representation</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.509.1"> as if it were an existing object) in pure C++ without falling into a UB trap. </span><span class="koboSpan" id="kobo.509.2">We will discuss these functions in more detail in </span><a href="B21071_15.xhtml#_idTextAnchor213"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.510.1">Chapter 15</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.511.1">.</span></span></p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.512.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.513.1">This chapter explored some low-level and sometimes unpleasant facilities that we will sometimes use, in order to put up the proper “warning signs” and remind us that we have to be responsible and write sensible and correct code even though our language of choice gives </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">significant freedom.</span></span></p>
<p><span class="koboSpan" id="kobo.515.1">When writing advanced memory management facilities in the later chapters of this book, these dangerous facilities will sometimes be useful to us. </span><span class="koboSpan" id="kobo.515.2">Inspired by the contents of this chapter on things to be careful with, we will resort to these facilities sparingly, carefully, and in ways that make them hard </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">to misuse.</span></span></p>
<p><span class="koboSpan" id="kobo.517.1">In our next chapter, we will examine the key C++ casts put at our disposal; the intent is to make us aware of what each cast does, as well as when (and to what end) it should be used, such that we can thereafter build the powerful memory management abstractions we want </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">to use.</span></span></p>
</div>
</body></html>