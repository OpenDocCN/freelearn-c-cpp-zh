<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-27"><a id="_idTextAnchor027"/>2</h1>
<h1 id="_idParaDest-28"><a id="_idTextAnchor028"/>Things to Be Careful With</h1>
<p>So, you decided to read a book about memory management in C++ and are as ready to look at the high-level approaches and techniques as you are willing to “get your hands dirty”, so to speak, in order to get fine-grained control over the memory management process. What an excellent plan!</p>
<p>Since you know that you are going to be writing very high-level code, but also very low-level code, there are a few things we need to make sure you are aware of such that you do not get in trouble or write code that seems to work but does not, at least not portably.</p>
<p>In this chapter, we will point out some aspects of C++ programming that will come into play throughout this book, but that you should be careful with. This might look like a (very) small compendium of bad practices or an encouragement to get in trouble, but please consider what follows as ways to use somewhat dangerous or tricky features well. You’re using C++, you have significant freedom of expression, and you get access to features that are useful if you know and understand them well.</p>
<p>We want code that’s clean and efficient, and we want responsible programmers. Let’s try to get there together.</p>
<p>In this chapter, we will learn about the following:</p>
<ul>
<li>We will cover some of the ways in which one can get into trouble with C++ code. Indeed, there are things a compiler cannot reliably diagnose, just as there are things for which the C++ standard does not say what will happen, and writing code that does such things is a recipe for disaster – or at the very least surprising or non-portable behavior.</li>
<li>In particular, we will explore how one can get in trouble with pointers. Since this book discusses memory management, we will use pointers and pointer arithmetic quite often, and being able to distinguish appropriate uses thereof from inappropriate ones will be valuable.</li>
<li>Finally, we will discuss what kinds of type conversions we can do without resorting to type casts (the main subject of <a href="B21071_03.xhtml#_idTextAnchor047"><em class="italic">Chapter 3</em></a>), and how rarely that’s a good idea, contrary to popular belief.</li>
</ul>
<p>Our overall goal will be to learn things we should not do (even though we will do some maneuvers that resemble them, on occasion), and avoid them thereafter, hopefully understanding why we do so. With that out of the way, we’ll have many chapters to look at things we <em class="italic">should</em> do, and how to do them well!</p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor029"/>Different kinds of evil</h1>
<p>Before delving into some actual practices that require care, it’s interesting to look at the main categories of risks we could run into if our code does not respect the rules of the language. With each such category comes a form of unpleasantness we should strive to avoid.</p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor030"/>Ill-formed, no diagnostic required</h2>
<p>Some constructs <a id="_idIndexMarker095"/>in C++ are said to be <strong class="bold">Ill-Formed, No Diagnostic Required</strong> (<strong class="bold">IFNDR</strong>). Indeed, you will find quite a few occurrences in the standard of <em class="italic">“if […], the program is ill-formed, with no diagnostic required.”</em> When something is IFNDR, it means your program is broken. Bad things could happen, but the compiler is not required to tell you about them (indeed, sometimes, the compiler does not have sufficient information to diagnose the problematic situation).</p>
<p><code>alignas</code>) in different translation units (different source files, essentially), or having a constructor that delegates to itself either directly or indirectly. Here is an example:</p>
<pre class="source-code">
class X {
public:
<strong class="bold">    // #0 delegates to #1 which delegates to #0 which...</strong>
    X(float x) : X{ static_cast&lt;int&gt;(x) } { <strong class="bold">// #0</strong>
    }
    X(int n) : X{ n + 0.5f } { <strong class="bold">// #1</strong>
    }
};
int main() {}</pre> <p>Note that your compiler might give a diagnostic; it’s just not required to do so. It’s not that compilers are lazy – they might even be unable to provide a diagnostic in some cases! So, be<a id="_idIndexMarker097"/> careful not to write code that leads to IFNDR situations.</p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/>Undefined behavior</h2>
<p>We mentioned <strong class="bold">Undefined Behavior</strong> (<strong class="bold">UB</strong>) in <a href="B21071_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>. UB is often seen as a source of headaches <a id="_idIndexMarker098"/>and pain for C++ programmers but it refers to any behavior for which the C++ standard imposes no requirement. In practice, this means that if you write code that contains UB, you have no idea what’s going to happen at runtime (at least if you’re aiming for somewhat portable code). Canonical examples of UB include dereferencing a null pointer or an uninitialized pointer: do that and you’ll be in serious trouble.</p>
<p>To compilers, UB is not supposed to happen (code that respects the rules of the language does not contain UB, after all). For that reason, compilers “optimize around” code that contains UB, to sometimes surprising effect: they might begin removing tests and branches, optimizing loops away, and so on.</p>
<p>The effects of UB tend to be local. For instance, in the following example, there is a test that ensures that <code>p</code> is not null before using <code>*p</code> in one case, but there is at least one access to <code>*p</code> that is unchecked. This code is broken (the unchecked access to <code>*p</code> is UB), so the compiler is allowed to rewrite it in such a way that all tests to verify that <code>p</code> is not null are effectively removed. After all, the damage would be done if <code>p</code> were <code>nullptr</code>, so the compiler is entitled to assume that the programmer passed a non-null pointer to the function!</p>
<pre class="source-code">
int g(int);
int f(int *p) {
    if(p != nullptr)
        return g(*p); // Ok, we know p is not null
    return *p; // oops, if p == nullptr this is UB
}</pre> <p>The whole body of <code>f()</code> could legitimately be rewritten by your compiler as <code>return g(*p)</code> in this case, with the <code>return *p</code> statement being turned into unreachable code.</p>
<p>The potential for UB hides in various places in the language, including signed integer overflow, accessing an array out of bounds, data races, and so on. There are ongoing efforts to reduce the <a id="_idIndexMarker099"/>number of potential UB cases (there’s even a study group, <strong class="bold">SG12</strong>, dedicated<a id="_idIndexMarker100"/> to this effort), but UB will likely remain part of the language for the foreseeable future, and we need to be aware of it.</p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/>Implementation-defined behavior</h2>
<p>Some parts of the <a id="_idIndexMarker101"/>standard fall under the umbrella of <strong class="bold">implementation-defined behavior</strong>, or behavior that you can count on with a specific platform. This is behavior that your platform of choice is supposed to document, but that is not guaranteed to be portable to other platforms.</p>
<p>Implementation-defined behavior occurs in many situations and includes such things as implementation-defined limits: the maximum number of nested parentheses; the maximum number of case labels in a switch statement; the actual size of an object; the maximum number of recursive calls in a <code>constexpr</code> function; the number of bits in a byte; and so on. Other well-known cases of implementation-defined behavior include the number of bytes in an <code>int</code> object or whether the <code>char</code> type is a signed or an unsigned integral type.</p>
<p>Implementation-defined behavior is not really a source of evil, but it can be problematic if one strives for portable code but depends on some non-portable assumptions. It is sometimes useful to spell one’s assumptions in code through <code>static_assert</code> when the assumption can be validated at compile-time or some similar, potentially runtime mechanisms in order to realize—before it’s too late—that these assumptions are broken for a given target platform. </p>
<p>For example:</p>
<pre class="source-code">
int main() {
    // our code supposes int is four bytes wide, a non-
    // portable assumption
    static_assert(sizeof(int)==4);
    // only compiles if condition is true...
}</pre> <p>Unless you are convinced that your code will never need to be ported to another platform, strive to rely as little as possible on implementation-defined behavior, and if you do, make sure that you validate (through <code>static_assert</code> if possible, at runtime if there’s no other <a id="_idIndexMarker102"/>choice) and document this situation. It might help you avoid some nasty surprises in the future.</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor033"/>Unspecified behavior (not documented)</h2>
<p>Where implementation-defined behavior is non-portable but documented for a given platform, unspecified behavior is a behavior that, even for a well-formed program given correct data, behaves in a way that depends on the implementation but does not need to be documented.</p>
<p>Some cases of unspecified behavior include the state of a moved-from object (said to be <code>f(g(),h())</code> will evaluate <code>g()</code> or <code>h()</code> first, the values in a newly allocated chunk of memory, and so on. This latter example is interesting to our study; a debug build might fill newly allocated chunks of memory with a recognizable bit pattern to help in the debugging process, and an optimized build with the same toolset could leave the initial bits of a newly allocated chunk of memory “uninitialized”, with the bits it held at the time when the allocation was performed, to get speed improvements.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor034"/>The ODR</h2>
<p>The ODR, simply <a id="_idIndexMarker104"/>summarized, states that there shall be only one definition of each “thing” (function, object in a scope, enumeration, template, and so on) in a translation unit, although there can be multiple declarations of that thing. Consider the following example:</p>
<pre class="source-code">
int f(int); // declaration
int f(int n); // Ok, declaration again
int f(int m) { return m; } // Ok, definition
// int f(int) { return 3; } // not Ok (ODR violation)</pre> <p>In C++, avoiding ODR violations is important, as these “evils” can escape the compiler’s scrutiny and fall into the realm of IFNDR situations. For example, due to the separate compilation of source files, a header file containing the definition of a non-<code>inline</code> function will lead to that definition being replicated in each source file that includes that same header. Then, each compilation might succeed, and the fact that there are multiple definitions <a id="_idIndexMarker105"/>of that function in the same build might be detected later (at link time) or just left undetected and cause havoc.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor035"/>Erroneous behavior</h2>
<p>Ongoing security-related efforts in C++ have led to discussions on a new kind of “evil” tentatively <a id="_idIndexMarker106"/>named <em class="italic">erroneous behavior</em>. This new category is meant to cover situations that could have been UB in the past, but for which we could issue diagnostics and provide well-defined behavior. The behavior would still be incorrect, but erroneous behavior would, in a way, provide boundaries to the consequences. Note that work on erroneous behavior is ongoing as of this writing, and this new wording feature might target C++26.</p>
<p>One use case envisioned for erroneous behavior is reading from an uninitialized variable, where the implementation could (for safety reasons) provide a fixed value for the bits read, and the conceptual error that stems from reading that variable would be something that implementations are encouraged to diagnose. Another use case would be forgetting to return a value from a non-void assignment operator.</p>
<p>Now that we’ve looked at the large “families” of unpleasantness that might hit our programs if we don’t behave, let’s delve into some of the main facilities that could get us in trouble and see what we should avoid doing.</p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor036"/>Pointers</h1>
<p><a href="B21071_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a> looked at<a id="_idIndexMarker107"/> pointers in C++ in the sense of what they represent and what they mean. It described what pointer arithmetic is, and what it allows us to do. We will now examine practical uses of pointer arithmetic, with both proper and improper uses of this low-level (but sometimes precious) tool.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/>Uses of pointer arithmetic within an array</h2>
<p>Pointer <a id="_idIndexMarker108"/>arithmetic is a nice and useful tool, but it’s a sharp<a id="_idIndexMarker109"/> one that tends to be misused. With raw arrays, the following two loops, labeled <code>A</code> and <code>B</code>, behave in exactly the same way:</p>
<pre class="source-code">
void f(int);
int main() {
    int vals[]{ 2,3,5,7,11 };
    enum { N = sizeof vals / sizeof vals[0] };
    for(int i = 0; i != N; ++i) // A
      f(vals[i]);
    for(int *p = vals; p != vals + N; ++p) // B
      f(*p);
}</pre> <p>You might wonder about the <code>vals + N</code> part in loop <code>B</code>, but it’s valid (and idiomatic) C++ code. You can observe the pointer just past the end of an array, even though you’re not allowed to observe what it points to; the standard guarantees that this specific one-past-the-end address is accessible to your program. However, no such guarantee is provided for the following address, so be careful!</p>
<p>As long as you respect the rules, you can use pointers to jump back and forth within an array. If you overreach and use a pointer to go further than one past-the-end, you will end up in UB <a id="_idIndexMarker110"/>territory; that is, you might be trying to access <a id="_idIndexMarker111"/>an address that’s not in your process’ address space:</p>
<pre class="source-code">
int arr[10]{ }; // all elements initialized to zero
int *p = &amp;arr[3];
p += 4; assert(p == &amp;arr[7]);
--p;    assert(p == &amp;arr[6]);
p += 4; // still Ok as long as you don't try to access *p
++p; // UB, not guaranteed to be valid</pre> <h2 id="_idParaDest-38"><a id="_idTextAnchor038"/>Pointer interconvertibility</h2>
<p>The C++ standard <a id="_idIndexMarker112"/>defines what it means for an object to be <code>reinterpret_cast</code> (we will expand on this in <a href="B21071_03.xhtml#_idTextAnchor047"><em class="italic">Chapter 3</em></a>), as they have the same address. Broadly speaking, the following points hold true:</p>
<ul>
<li>An object is pointer-interconvertible with itself</li>
<li>A <code>union</code> is pointer-interconvertible with its data members, as well as their first data member if they are compound types</li>
<li>With some restrictions, <code>x</code> and <code>y</code> are pointer-interconvertible with one another if one is an object and the other one is of the same type as the first non-static data member of that object</li>
</ul>
<p>Some examples are included here:</p>
<pre class="source-code">
struct X { int n; };
struct Y : X {};
union U { X x; short s; };
int main() {
    X x;
    Y y;
    U u;
    // x is pointer-interconvertible with x
    // u is pointer-interconvertible with u.x
    // u is pointer-interconvertible with u.s
    // y is pointer-interconvertible with y.x
}</pre> <p>If you try to apply <code>reinterpret_cast</code> in a way that does not respect pointer-interconvertibility rules, your code is technically incorrect and is not guaranteed to work in practice. Don’t do that.</p>
<p>We will occasionally<a id="_idIndexMarker113"/> use the pointer-interconvertibility property in our code examples, including in the next section.</p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/>Uses of pointer arithmetic within an object</h2>
<p>Pointer arithmetic <a id="_idIndexMarker114"/>within an object is also allowed in C++, although<a id="_idIndexMarker115"/> one should be careful about how this is handled (using the appropriate casts, which we will explore in <a href="B21071_03.xhtml#_idTextAnchor047"><em class="italic">Chapter 3</em></a>, and ensuring that one performs pointer arithmetic appropriately).</p>
<p>For example, the following code is correct, albeit not something one should seek to do (it makes no sense, and it does things in unnecessarily complicated ways, but it’s legal and does no harm):</p>
<pre class="source-code">
struct A {
    int a;
    short s;
};
short * f(A &amp;a) {
    // pointer interconvertibility in action!
    int *p = reinterpret_cast&lt;int*&gt;(&amp;a);
    p++;
    return reinterpret_cast&lt;short*&gt;(p); // Ok, within the
                                       // same object
}
int main() {
    A a;
    short *p = f(a);
    *p = 3; // fine, technically
}</pre> <p>We will not abuse this aspect of the C++ language in this book, but we do need to be aware of it in order to write correct, low-level code.</p>
<p class="callout-heading">About the difference between pointer and address</p>
<p class="callout">In order to strengthen hardware and software security, there has been work on hardware architectures that can provide a form of “pointer tagging”, which allows the hardware tracking of pointer provenance, among other things. Two well-known examples<a id="_idIndexMarker116"/> are <a id="_idIndexMarker117"/>the CHERI<a id="_idIndexMarker118"/> architecture (<a href="https://packt.link/cJeLo">https://packt.link/cJeLo</a>) and <strong class="bold">Memory Tagging Extensions</strong> (<strong class="bold">MTEs</strong>) (Linux: <a href="https://packt.link/KXeRn">https://packt.link/KXeRn</a> | Android: <a href="https://packt.link/JDfEo">https://packt.link/JDfEo</a>, and <a href="https://packt.link/fQM2T">https://packt.link/fQM2T</a>| Windows: <a href="https://packt.link/DgSaH">https://packt.link/DgSaH</a>).</p>
<p class="callout">To benefit from such hardware, the language needs to distinguish between the low-level idea of addresses and the high-level idea of pointers, as the latter could take into account the fact that a pointer is more than just a memory location. If your code absolutely needs to compare unrelated pointers for ordering, one thing you can do is cast the pointers to <code>std::intprt_t</code> or to <code>std::uintptr_t</code> and compare the (numeric) results instead of comparing the actual pointers. Note that compiler support for those two<a id="_idIndexMarker119"/> types is optional, although all major compiler<a id="_idIndexMarker120"/> vendors offer it.</p>
<h3>The null pointer</h3>
<p>The idea of a <a id="_idIndexMarker121"/>null pointer as a recognizable value for pointers that lead to nowhere valid can be traced back<a id="_idIndexMarker122"/> to C.A.R. Hoare (<a href="https://packt.link/ByfeX">https://packt.link/ByfeX</a>). In the C language, through the <code>NULL</code> macro, it has been represented first as a <code>char*</code> of value <code>0</code>, then as a <code>void*</code> of value <code>0</code>, then in C++ as value <code>0</code> simply since such things as <code>int *p = NULL;</code> with a typed <code>NULL</code> were legal C but not legal C++. This is because the type system is stricter in C++. Note that a pointer with value <code>0</code> does not mean “point to address zero” as this address is in itself perfectly valid and is used as such on many platforms.</p>
<p>In C++, the preferred way of expressing a null pointer is <code>nullptr</code>, an object of the <code>std::nullptr_t</code> type that converts to pointers of any type and behaves as expected. This solves some longstanding issues with literal <code>0</code> in C++, such as the following:</p>
<pre class="source-code">
int f(int); //#0
int f(char*); // #1
int main() {
    int n = 3;
    char c;
    f(n); // calls #0
    f(&amp;c); // calls #1
    <strong class="bold">f(0); // ambiguous before C++11, calls #0 since</strong>
    <strong class="bold">f(nullptr); // only since C++11; unambiguously calls #1</strong>
}</pre> <p>Note that <code>nullptr</code> is not a pointer; it’s an object that implicitly converts to a pointer. For that reason, the <code>std::is_pointer_v&lt;nullptr&gt;</code> trait is false, and C++ offers a distinct trait named <code>std::is_null_pointer&lt;T&gt;</code> to statically test whether <code>T</code> is a <code>std::nullptr_t</code> or not (taking <code>const</code> and <code>volatile</code> into account).</p>
<p>Dereferencing a null pointer is UB, just as dereferencing an uninitialized pointer is. The point of using <code>nullptr</code> in your code is to make that state recognizable: <code>nullptr</code> is a distinguishable value, whereas an uninitialized pointer could be anything.</p>
<p>In C++ (contrary to C), arithmetic <a id="_idIndexMarker123"/>on a null pointer is well-defined… as long as you add zero to the null pointer. Or, to put it differently: if you add zero to a null pointer, the code remains well-defined, but if you add anything else, you’re on your own. There’s an explicit provision to that effect in wg21.link/c++draft/expr.add#4.1. This means that the following is correct as in the case of an empty <code>Array</code>, <code>begin()</code> yields <code>nullptr</code> and <code>size()</code> yields zero, so <code>end()</code> effectively computes <code>nullptr+0</code>, which respects the rules:</p>
<pre class="source-code">
template &lt;class T&gt; class Array {
    T *elems = nullptr; // pointer to the beginning
    std::size_t nelems = 0; // number of elements
public:
    Array() = default; // =empty array
    // ...
    auto size() const noexcept { return nelems; }
    // note: could return nullptr
    auto begin() noexcept { return elems; }
    auto end() noexcept { return begin() + size(); }
};</pre> <p>We will return to this <code>Array</code> example in more detail in <em class="italic">Chapters 12</em>, <em class="italic">13</em>, and <em class="italic">14</em>; it will help us discuss<a id="_idIndexMarker124"/> several important aspects of efficient memory management techniques. For now, let’s look at another source of risky programming maneuvers.</p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor040"/>Type punning</h1>
<p>Another area where a C++ programmer can get<a id="_idIndexMarker125"/> into trouble is <strong class="bold">type punning</strong>. By type punning, we mean techniques that subvert the language’s type system somewhat. The consecrated tool to perform type conversions is casts, as they are explicit in source code text and (apart from C-style casts) express the intent for the conversion, but that topic deserves its own chapter (<a href="B21071_03.xhtml#_idTextAnchor047"><em class="italic">Chapter 3</em></a>, if you’re wondering).</p>
<p>In this section, we will examine other ways to achieve type punning, including both recommendable ones and others that you should seek to avoid.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/>Type punning through members of a union</h2>
<p>A union is a<a id="_idIndexMarker126"/> type for which the members are all at the same address. The size of a union is the size of its largest member, and the alignment of a union is the strictest alignment of its members. </p>
<p>Consider the following example:</p>
<pre class="source-code">
struct X {
    char c[5]; short s;
} x;
// one byte of padding between x.c and x.s
static_assert(sizeof x.s == 2 &amp;&amp; sizeof x == 8);
static_assert(alignof(x) == alignof(short));
union U {
    int n; X x;
} u;
static_assert(sizeof u == sizeof u.x);
static_assert(alignof(u) == alignof(u.n));
int main() {}</pre> <p>It’s tempting to think that one can use a union to implicitly convert such things as a four-byte floating point number into a four-byte integral number, and in the C language (not C++), that is indeed possible.</p>
<p>Even though there is a widespread belief that this practice is legal in C++, the reality is that it is not (with one special caveat, which we will explore shortly). Indeed, in C++, the last member of a union one has written to is called<a id="_idIndexMarker127"/> the union’s <code>constexpr</code> function:</p>
<pre class="source-code">
union U {
    float f;
    int n;
};
constexpr int f() {
    U u{ 1.5f };
    return u.n; // UB (u.f is the active member)
}
int main() {
    // constexpr auto r0 = f(); // would not compile
    auto r1 = f(); // compiles, as not a constexpr
                  // context, but still UB
}</pre> <p>As you might know, a <code>constexpr</code> function such as <code>f()</code> in the preceding example cannot contain code that is UB if it is called in a <code>constexpr</code> context. This sometimes makes it an interesting tool to make a point.</p>
<p>There is a caveat<a id="_idIndexMarker129"/> with respect to conversions between <code>union</code> members, and that caveat is associated with the common initial sequence.</p>
<h3>Common initial sequence</h3>
<p>As explained at wg21.link/class.mem.general#23, the <code>A</code> and <code>B</code> is made of their first two members (<code>int</code> is layout-compatible with <code>const int</code> and <code>float</code> is layout-compatible with <code>volatile float</code>):</p>
<pre class="source-code">
struct A { int n; float f; char c; };
struct B{ const int b0; volatile float x; };</pre> <p>With a union, it is possible to read from a non-active member if the value read is part of both the common initial sequence of that member and of the active member. Here’s an example:</p>
<pre class="source-code">
struct A { int n0; char c0; };
struct B { int n1; char c1; float x; };
union U {
    A a;
    B b;
};
int f() {
    U u{ { 1, '2' } }; // initializes u.a
    return u.b.n1; // not UB
}
int main() {
    return f(); // Ok
}</pre> <p>Note that such type punning should be kept to a minimum, as it can make it harder to reason about source code, but it can be quite useful. For example, it can be used to implement some interesting underlying representations for classes that can have two distinct <a id="_idIndexMarker132"/>representations (classes such as <code>optional</code> or <code>string</code>), making it easier to switch from one to the other. Some useful optimizations can be built on this.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor042"/>The intptr_t and uintptr_t types</h2>
<p>As mentioned earlier in <a id="_idIndexMarker133"/>this chapter, one cannot <a id="_idIndexMarker134"/>directly<a id="_idIndexMarker135"/> compare pointers to arbitrary locations in memory in a well-defined manner in C++. One can, however, compare the integral values associated with pointers in a well-defined manner, such as here:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;cstdint&gt;
int main() {
    using namespace std;
    int m,
       n;
    // simply comparing &amp;m with &amp;n is not allowed
    if(reinterpret_cast&lt;intptr_t&gt;(&amp;m) &lt;
      reinterpret_cast&lt;intptr_t&gt;(&amp;n))
      cout &lt;&lt; "m precedes n in address order\n";
    else
      cout &lt;&lt; "n precedes m in address order\n";
}</pre> <p>The <code>std::intptr_t</code> and <code>std::uintptr_t</code> types are aliases for integral types that are large enough to hold an address. Use the signed type, <code>intptr_t</code>, for operations that could <a id="_idIndexMarker136"/>lead<a id="_idIndexMarker137"/> to<a id="_idIndexMarker138"/> negative values (for example, subtraction).</p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor043"/>The std::memcpy() function</h2>
<p>For historical (and C compatibility) reasons, <code>std::memcpy()</code> is <em class="italic">special</em> as it can start the <a id="_idIndexMarker139"/>lifetime of <a id="_idIndexMarker140"/>an object if used appropriately. An incorrect use of <code>std::memcpy()</code> for type punning would be as follows:</p>
<pre class="source-code">
// suppose this holds for this example
static_assert(sizeof(int) == sizeof(float));
#include &lt;cassert&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
int main() {
    float f = 1.5f;
    void *p = malloc(sizeof f);
    assert(p);
    int *q = std::memcpy(p, &amp;f, sizeof f);
    int value = *q; // UB
    //
}</pre> <p>The reason why this is illegal is that the call to <code>std::memcpy()</code> copies a <code>float</code> object into the storage pointed to by <code>p</code>, effectively starting the lifetime of a <code>float</code> object in that storage. Since <code>q</code> is an <code>int*</code>, dereferencing it is UB.</p>
<p>On the other hand, the following is legal and shows how <code>std::memcpy()</code> can be used for type punning:</p>
<pre class="source-code">
// suppose this holds for this example
static_assert(sizeof(int) == sizeof(float));
#include &lt;cassert&gt;
#include &lt;cstring&gt;
int main() {
    float f = 1.5f;
    int value;
    std::memcpy(&amp;value, &amp;f, sizeof f); // Ok
    // ...
}</pre> <p>Indeed, in this second example, using <code>std::memcpy()</code> to copy the bits from <code>f</code> to <code>value</code> starts the<a id="_idIndexMarker141"/> lifetime of <code>value</code>. That object can be <a id="_idIndexMarker142"/>used as any other <code>int</code> from that point on.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/>The special cases of char*, unsigned char*, and std::byte*</h2>
<p>The <code>char*</code>, <code>unsigned char*</code> (not <code>signed char*</code>), and <code>std::byte*</code> types have<a id="_idIndexMarker143"/> special <a id="_idIndexMarker144"/>status<a id="_idIndexMarker145"/> in C++ as they can <a id="_idIndexMarker146"/>literally point <a id="_idIndexMarker147"/>anywhere and alias <a id="_idIndexMarker148"/>anything (<a href="http://wg21.link/basic.lval#11">wg21.link/basic.lval#11</a>). For that reason, if you need to access the underlying bytes of the value representation of an object, these types are an important tool in your toolbox.</p>
<p>We will, later in this book, occasionally resort to these types to perform low-level byte manipulation. Note that such maneuvers are inherently fragile and non-portable, as such details as the order of bytes in an integer can vary from platform to platform. Use such low-level facilities with care.</p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/>The std::start_lifetime_as&lt;T&gt;() function</h2>
<p>One last <a id="_idIndexMarker149"/>set of <a id="_idIndexMarker150"/>facilities for this chapter is <code>std::start_lifetime_as&lt;T&gt;()</code> and <code>std::start_lifetime_as_array&lt;T&gt;()</code>. These functions have been discussed for years but came into their own with C++23. Their role is to take as arguments something such as a buffer of raw memory bytes and return a pointer to some <code>T</code> (pointing to that buffer) whose lifetime has started, such that the pointee can be used as such from that point on:</p>
<pre class="source-code">
static_assert(sizeof(short) == 2);
#include &lt;memory&gt;
int main() {
    char buf[]{ 0x00, 0x01, 0x02, 0x03 };
    short* p = std::start_lifetime_as&lt;short&gt;(buf);
    // use *p as a short
}</pre> <p>This is, again, a low-level feature to be used with care. The intent here is to be able to implement such things as low-level file I/O and networking code (for example, receiving a UDP packet and<a id="_idIndexMarker151"/> treating its value representation<a id="_idIndexMarker152"/> as if it were an existing object) in pure C++ without falling into a UB trap. We will discuss these functions in more detail in <a href="B21071_15.xhtml#_idTextAnchor213"><em class="italic">Chapter 15</em></a>.</p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor046"/>Summary</h1>
<p>This chapter explored some low-level and sometimes unpleasant facilities that we will sometimes use, in order to put up the proper “warning signs” and remind us that we have to be responsible and write sensible and correct code even though our language of choice gives significant freedom.</p>
<p>When writing advanced memory management facilities in the later chapters of this book, these dangerous facilities will sometimes be useful to us. Inspired by the contents of this chapter on things to be careful with, we will resort to these facilities sparingly, carefully, and in ways that make them hard to misuse.</p>
<p>In our next chapter, we will examine the key C++ casts put at our disposal; the intent is to make us aware of what each cast does, as well as when (and to what end) it should be used, such that we can thereafter build the powerful memory management abstractions we want to use.</p>
</div>
</body></html>