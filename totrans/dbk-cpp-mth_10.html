<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-105">
    <a id="_idTextAnchor104">
    </a>
    
     10
    
   </h1>
   <h1 id="_idParaDest-106">
    <a id="_idTextAnchor105">
    </a>
    
     There Are No Libraries For Modern Programming in C++
    
   </h1>
   <p class="italic-heading">
    <em class="italic">
     
      Or maybe there are too many and they are not
     
    </em>
    
     <em class="italic">
      
       easily available?
      
     </em>
    
   </p>
   <p>
    
     C++ is the oldest language used in modern software development.
    
    
     Despite many attempts to replace it, it stayed up in both preference and usefulness.
    
    
     However, this legacy comes with its own challenges.
    
    
     The development style has evolved over time to include constructs that are easier to understand by developers, that solve problems with less code, or that sometimes just
    
    
     
      look nicer.
     
    
   </p>
   <p>
    
     A big part of the ecosystem of any technology is the list of libraries available to it, including and complementing the standard library.
    
    
     Since C++ has been around for a long time, it has libraries.
    
    
     However, how do they compare with the experience of developers using other technologies?
    
    
     Do they match the needs and expectations of a modern developer, who is perhaps looking at the alternative solutions available in the marketplace
    
    
     
      of ideas?
     
    
   </p>
   <p>
    
     These are a few of the questions we will
    
    
     
      examine next.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      A modern
     
     
      
       developer experience
      
     
    </li>
    <li>
     
      
       Common needs
      
     
    </li>
    <li>
     
      
       Compatibility
      
     
    </li>
    <li>
     
      Supply
     
     
      
       chain security
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-107">
    <a id="_idTextAnchor106">
    </a>
    
     How can we tell?
    
   </h1>
   <p>
    
     When pondering a question such as the title of this chapter, we are faced with the big challenge of selection.
    
    
     The choice of libraries for any project is completely contextual, and it fully depends on what the project is trying to solve.
    
    
     Of course, there are some features that are needed no matter what the project does, such as logging or unit testing, but what should we pick
    
    
     
      beyond these?
     
    
   </p>
   <p>
    
     After all, it seems deeply unfair to compare web development in C++ with web development in Java, as it is to compare systems programming in C++ with systems programming in Java.
    
    
     Neither is C++ used for web development extensively, nor is Java for systems programming.
    
    
     In fact, C++ has had its own niche for a long time, and while it has been slowly eroded by Java, C#, Rust, and Python, it still holds the fort for use cases such as game development, firmware, high-frequency trading, engineering applications, automotive, systems programming, and probably others.
    
    
     The other languages have little traction in these domains, for very good reasons related to C++’s flexibility, performance,
    
    
     
      and control.
     
    
   </p>
   <p>
    
     Another problem is the sheer number of libraries that exist for the aforementioned languages, particularly C++.
    
    
     An advantage of the venerable C++ is that programmers have had time to develop behemoth libraries
    
    <a id="_idIndexMarker339">
    </a>
    
     such as Boost, which has no equal in the worlds of Java or C# (excluding the standard libraries), and absolutely no contender in the world of Python.
    
    
     We could argue that JavaScript has something similar to React and its surrounding ecosystem.
    
    
     However, in terms of the volume of available libraries, C++
    
    
     
      looks dominant.
     
    
   </p>
   <p>
    
     These observations leave us with one characteristic that we need to account for: how modern is the set of libraries?
    
    
     What would we want from a modern programming language and its ecosystem?
    
    
     Where does C++ stand from this perspective?
    
    
     Let’s examine
    
    
     
      these questions.
     
    
   </p>
   <h1 id="_idParaDest-108">
    <a id="_idTextAnchor107">
    </a>
    
     A modern developer’s experience
    
   </h1>
   <p>
    
     Let’s
    
    <a id="_idIndexMarker340">
    </a>
    
     step, for a moment, outside the C++ world and turn into a fly on the wall that looks at the experience of a developer using another technology.
    
    
     We will be with them as they are starting a new project, and later when they add new people to the team.
    
    
     The likely first step is that they will launch an IDE and create a new project or a project structure.
    
    
     The IDE is likely to be from Microsoft, such as Visual Studio .NET or Visual Studio Code, or from JetBrains, such as IntelliJ IDEA for Java, PyCharm for Python, or Rider for C#/.NET.
    
    
     A small set of strange programmers, such as myself, will use the command line and neovim.
    
    
     Even stranger programmers will use Emacs.
    
    
     I kid, of course; we all know that real programmers use changes in atmospheric electricity to manipulate the bits directly, as shown by a famous xkcd comic called
    
    <em class="italic">
     
      Real Programmers
     
    </em>
    
     (
    
    <a href="https://xkcd.com/378/">
     
      https://xkcd.com/378/
     
    </a>
    
     ).
    
    
     However, let’s go back to
    
    
     
      our story.
     
    
   </p>
   <p>
    
     Upon creating a new project, the IDE will suggest a few integrations and libraries to install.
    
    
     Once created, the project is ready to run, although it won’t do a lot of useful things.
    
    
     During the creation, a source control repository will be selected, likely an existing one based on git.
    
    
     The project can then be committed locally and pushed to the
    
    
     
      shared repository.
     
    
   </p>
   <p>
    
     After these steps, any member of the team will have a few things to do: fire up the IDE, clone the repository locally, and let the IDE do its thing to get the necessary dependencies, as specified in the
    
    
     
      project configuration.
     
    
   </p>
   <p>
    
     It’s likely that, at this point, the project will already include a logging and unit testing library.
    
    
     Let’s pause for a moment to examine the
    
    
     
      libraries used.
     
    
   </p>
   <p>
    
     Python has logging in its standard library, while Java has the open source Log4J and .NET uses either the Microsoft-built Microsoft.Extensions.Logging or the open source Log4Net.
    
    
     For unit testing, Python offers a standard implementation for both unit testing and mocking, but programmers tend to prefer open-source extensions
    
    <a id="_idIndexMarker341">
    </a>
    
     such as pytest (
    
    <a href="https://docs.pytest.org/en/stable/">
     
      https://docs.pytest.org/en/stable/
     
    </a>
    
     ).
    
    
     Java requires a unit testing library, usually JUnit or TestNG, and a mocking library, usually Mockito or JMock.
    
    
     Finally, .NET provides a standard framework for testing but knowledgeable tech leads will most likely select NUnit or xUnit instead, along
    
    
     
      with Moq.
     
    
   </p>
   <p>
    
     Where does
    
    <a id="_idIndexMarker342">
    </a>
    
     C++ stand here?
    
    
     Well, there’s no shortage of logging libraries in C++, which shouldn’t be a surprise since logging systems have matured at the same time as C++.
    
    
     We can say that logging libraries are quasi-standardized, having very similar behavior and features with small variations in the API.
    
    
     It’s almost too difficult to choose a logging library for C++ unless you are using a technology that already comes with logging.
    
    
     I imagine that many projects use Boost and the logging that comes with it.
    
    
     A quick glance at GitHub shows that
    
    <a id="_idIndexMarker343">
    </a>
    
     the
    
    <strong class="source-inline">
     
      spdlog
     
    </strong>
    
     library (
    
    <a href="https://github.com/gabime/spdlog">
     
      https://github.com/gabime/spdlog
     
    </a>
    
     ) has 24k stars, although it only supports
    
    
     
      C++ 11.
     
    
   </p>
   <p>
    
     What about unit testing?
    
    
     This is an interesting topic.
    
    
     Unit testing libraries exist for C++ in many forms.
    
    
     There’s GTest and GMock, the two libraries started by Google, with the usual feature set.
    
    
     Similarly, CppTest follows the standard xUnit structure for unit tests.
    
    
     Then there’s
    
    <strong class="source-inline">
     
      doctest
     
    </strong>
    
     (
    
    <a href="https://github.com/doctest/doctest">
     
      https://github.com/doctest/doctest
     
    </a>
    
     ), a single header library with no dependencies, which is
    
    <a id="_idIndexMarker344">
    </a>
    
     why I prefer it for examples and the code accompanying this book.
    
    
     Finally, it’s worth
    
    <a id="_idIndexMarker345">
    </a>
    
     mentioning
    
    <strong class="source-inline">
     
      Cpputest
     
    </strong>
    
     (
    
    <a href="http://cpputest.github.io">
     
      http://cpputest.github.io
     
    </a>
    
     ) because it allows embedded development, due to its small footprint and its features for identifying memory management problems.
    
    
     For mocking,
    
    <strong class="source-inline">
     
      FakeIt
     
    </strong>
    
     (
    
    <a href="https://github.com/eranpeer/FakeIt">
     
      https://github.com/eranpeer/FakeIt
     
    </a>
    
     ) is another
    
    <a id="_idIndexMarker346">
    </a>
    
     single header framework that is very easy
    
    
     
      to integrate.
     
    
   </p>
   <p>
    
     All these libraries would likely be set up through a package manager that stores the list of dependencies in a text file that’s either plain text, a markup format, or a script.
    
    
     This file gets pushed to the central repository and can be used to recreate the dependencies, including the dependencies required by the
    
    
     
      installed libraries.
     
    
   </p>
   <p>
    
     If, during the
    
    <a id="_idIndexMarker347">
    </a>
    
     development, the team needs an additional library, they can simply add it to the dependencies.
    
    
     This process is a bit more restricted for enterprise environments due to security concerns: perhaps a pre-approved list of packages is available and provided from an internal source, perhaps each package requires approval, or perhaps only specific people can add
    
    
     
      a dependency.
     
    
   </p>
   <p>
    
     Either way, when a new developer comes in, they will clone the central repository and run the installation commands, usually by just loading the project in the IDE and letting it do its thing, and everything should work fine.
    
    
     That’s the end of our
    
    
     
      fly story.
     
    
   </p>
   <p>
    
     Let’s dive into more details about what happens behind the scenes if you use a package manager.
    
    
     Since I often use the command line in combination with neovim to program in Ubuntu Linux, I know a little bit more about the process in each of these technologies.
    
    
     For Python, a virtual environment is recommended so that the OS is not polluted with all the libraries required.
    
    
     A tool
    
    <a id="_idIndexMarker348">
    </a>
    
     called
    
    <strong class="source-inline">
     
      pipenv
     
    </strong>
    
     combines the
    
    <strong class="source-inline">
     
      pip
     
    </strong>
    
     package manager and the
    
    <strong class="source-inline">
     
      venv
     
    </strong>
    
     virtual environment, both provided by the standard library, to allow for easy setup.
    
    
     The command line steps would be
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
pipenv init
pipenv install [library name]</pre>
   <p>
    
     In a new environment, you can simply run the following to install all
    
    
     
      the dependencies:
     
    
   </p>
   <pre class="source-code">
pipenv install</pre>
   <p>
    
     Java and .NET have similar workflows, minus the virtual environment.
    
    
     They both use open source package managers; for Java, Maven or Gradle are used, and for .NET,
    
    
     
      it’s NuGet.
     
    
   </p>
   <p>
    
     For all these three technologies, a central
    
    <a id="_idIndexMarker349">
    </a>
    
     place for all the libraries
    
    <a id="_idIndexMarker350">
    </a>
    
     exists: Pypi (
    
    <a href="https://pypi.org/">
     
      https://pypi.org/
     
    </a>
    
     ) for Python, Maven
    
    <a id="_idIndexMarker351">
    </a>
    
     Central (
    
    <a href="https://www.mvnrepository.com/repos/central">
     
      https://mvnrepository.com/repos/central
     
    </a>
    
     ) for Maven and the NuGet
    
    <a id="_idIndexMarker352">
    </a>
    
     site (
    
    <a href="https://www.nuget.org/">
     
      https://www.nuget.org/
     
    </a>
    
     ) for NuGet.
    
    
     As mentioned earlier, it’s likely that large companies will pay more attention to the libraries used, and require more thorough security checks before using third-party code in their systems.
    
    
     These companies tend to provide their own repositories, for example, using
    
    <a id="_idIndexMarker353">
    </a>
    
     Artifactory in
    
    
     
      Java (
     
    
    <a href="https://jfrog.com/artifactory/">
     
      
       https://jfrog.com/artifactory/
      
     
    </a>
    
     
      ).
     
    
   </p>
   <p>
    
     It is therefore very easy to search for libraries, update them, and install them in a new environment, with de facto standard tools available to any developer using
    
    
     
      that technology.
     
    
   </p>
   <p>
    
     C++ has gone a long way since I was a junior C++ programmer in the 2000s.
    
    
     Back then, adding a new library required either downloading the binaries for the required targets or, more likely, compiling it yourself, which posed its own set of challenges.
    
    
     Nowadays, C++ is closing the gap through Conan and vcpkg, and it’s likely that many programmers have a similar experience in C++ to the one I’ve described above for Java, Python, and .NET.
    
    
     Programmers in large companies are most likely to recognize it, since the organization provides a Conan or vspkg repository with approved libraries that can be found and installed easily.
    
    
     Adding a new library to the whitelist can be a bit of a pain and can take a long time, but
    
    
     
      that’s understandable.
     
    
   </p>
   <p>
    
     It’s not as easy without that piece of infrastructure.
    
    
     The libraries are not available in a single location, and the tools don’t seem to work as well.
    
    
     At least this was my experience: Conan gave me a bunch of errors when I tried to use it on a simple project and I had no idea how to fix them.
    
    
     While I dislike Maven because it inexplicably downloads a lot of packages even for the simplest of setups, it works consistently and reliably, which is what we need from package managers.
    
    
     So, I’m afraid I will have to say this: while there are attempts to bring C++ package management on par with other technologies, it doesn’t feel
    
    
     
      mature yet.
     
    
   </p>
   <p>
    
     With this being said, I’m sure many developers working in large companies won’t feel any of these issues.
    
    
     So, we’ll assume that the package manager works fine.
    
    
     What will we do next?
    
    
     Depending on the project and the technology, we will need more libraries to help us.
    
    
     Let’s look next at a
    
    
     
      few categories.
     
    
   </p>
   <h1 id="_idParaDest-109">
    <a id="_idTextAnchor108">
    </a>
    
     Common needs
    
   </h1>
   <p>
    
     Here are
    
    <a id="_idIndexMarker354">
    </a>
    
     some needs that many developers have, in no
    
    
     
      particular order:
     
    
   </p>
   <ul>
    <li>
     
      Database connection, reading,
     
     
      
       and writing
      
     
    </li>
    <li>
     
      CSV
     
     
      
       file processing
      
     
    </li>
    <li>
     
      Compression, for
     
     
      
       example,
      
     
     
      <strong class="source-inline">
       
        gzip
       
      </strong>
     
    </li>
    <li>
     
      
       Date/time enhancements
      
     
    </li>
    <li>
     
      Various computations, for example: matrices, imaginary numbers, math equation solving, and
     
     
      
       so on
      
     
    </li>
    <li>
     
      UI, for desktop and
     
     
      
       mobile applications
      
     
    </li>
    <li>
     
      
       HTTP client
      
     
    </li>
    <li>
     
      
       HTTP server
      
     
    </li>
    <li>
     
      
       Asynchronous programming
      
     
    </li>
    <li>
     
      
       Image processing
      
     
    </li>
    <li>
     
      
       PDF processing
      
     
    </li>
    <li>
     
      
       Background jobs
      
     
    </li>
    <li>
     
      
       Cryptography
      
     
    </li>
    <li>
     
      
       Networking
      
     
    </li>
    <li>
     
      
       Serialization
      
     
    </li>
    <li>
     
      
       Email sending
      
     
    </li>
    <li>
     
      
       JSON processing
      
     
    </li>
    <li>
     
      Configuration file
     
     <a id="_idIndexMarker355">
     </a>
     
      read and write:
     
     <strong class="source-inline">
      
       ini
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       yaml
      
     </strong>
     
      , and
     
     
      
       so on
      
     
    </li>
   </ul>
   <p>
    
     It’s safe to say that there are C++ libraries for all of these.
    
    
     Let’s pick just a few
    
    
     
      random ones:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       zlib
      
     </strong>
     
      for
     
     <strong class="source-inline">
      
       zip
      
     </strong>
     
      and
     
     
      <strong class="source-inline">
       
        gzip
       
      </strong>
     
     
      
       compression
      
     
    </li>
    <li>
     
      Rapidcsv (
     
     <a href="https://github.com/d99kris/rapidcsv">
      
       https://github.com/d99kris/rapidcsv
      
     </a>
     
      ) for
     
     <a id="_idIndexMarker356">
     </a>
     
      
       CSV processing
      
     
    </li>
    <li>
     
      For database access, an ORM
     
     <a id="_idIndexMarker357">
     </a>
     
      such as TinyORM (
     
     <a href="https://www.tinyorm.org/">
      
       https://www.tinyorm.org/
      
     </a>
     
      ) or
     
     <a id="_idIndexMarker358">
     </a>
     
      SQLPP1 (
     
     <a href="https://github.com/rbock/sqlpp11">
      
       https://github.com/rbock/sqlpp11
      
     </a>
     
      ) for type-safe DSL queries
     
     
      
       and results
      
     
    </li>
    <li>
     
      Poco libraries (
     
     <a href="https://pocoproject.org/">
      
       https://pocoproject.org/
      
     </a>
     
      ) contain
     
     <a id="_idIndexMarker359">
     </a>
     
      a lot of utilities for networking, sending emails, database access, JSON, OpenSSL, and
     
     
      
       so on
      
     
    </li>
    <li>
     
      UI libraries include Qt, GTK, wxWidgets, or
     
     
      
       Dear ImGui
      
     
    </li>
    <li>
     
      HTTP clients are implemented in Boost, Curl++,
     
     
      
       or cpp-netlib
      
     
    </li>
    <li>
     
      To implement a web
     
     <a id="_idIndexMarker360">
     </a>
     
      application, Crow (
     
     <a href="https://crowcpp.org/master/">
      
       https://crowcpp.org/master/
      
     </a>
     
      ) is inspired by Python’s Flask, while
     
     <a id="_idIndexMarker361">
     </a>
     
      Oat++ (
     
     <a href="https://oatpp.io/">
      
       https://oatpp.io/
      
     </a>
     
      ) and
     
     <a id="_idIndexMarker362">
     </a>
     
      Drogon (
     
     <a href="https://drogon.org/">
      
       https://drogon.org/
      
     </a>
     
      ) offer fast solutions for web APIs
     
     
      
       and microservices
      
     
    </li>
   </ul>
   <p>
    
     We could go on, but I think we’ve made our point:
    
    <em class="italic">
     
      C++ has libraries
     
    </em>
    
     .
    
    
     It has
    
    <em class="italic">
     
      a lot of libraries
     
    </em>
    
     .
    
    
     Some of them have inspired the implementations of other technologies, while others took inspiration from the best solutions used by the alternatives.
    
    
     The advantages of the C++ implementations are obvious in terms of speed and low memory footprint.
    
    
     Some of these libraries pack many features into a few hundred kBs.
    
    
     It’s also impressive how many header-only implementations exist, allowing for portability
    
    
     
      and simplicity.
     
    
   </p>
   <p>
    
     C++ also has frameworks.
    
    
     We already mentioned a few and we can add others: GTK, QT, Boost, POCO, WxWidgets, and Unreal Engine, for example.
    
    
     Lists of libraries and frameworks are maintained on the internet, the best one I’ve found
    
    <a id="_idIndexMarker363">
    </a>
    
     being
    
    
     <strong class="bold">
      
       awesome-cpp
      
     </strong>
    
    
     
      (
     
    
    <a href="https://github.com/fffaraz/awesome-cpp">
     
      
       https://github.com/fffaraz/awesome-cpp
      
     
    </a>
    
     
      ).
     
    
   </p>
   <p>
    
     Even niche
    
    <a id="_idIndexMarker364">
    </a>
    
     programming styles and practices have
    
    
     
      their libraries:
     
    
   </p>
   <ul>
    <li>
     
      Immutable collections?
     
     
      Use
     
     <a id="_idIndexMarker365">
     </a>
     
      
       Immer (
      
     
     <a href="https://github.com/arximboldi/immer">
      
       
        https://github.com/arximboldi/immer
       
      
     </a>
     
      
       ).
      
     
    </li>
    <li>
     
      Reactive Programming?
     
     
      Use
     
     <a id="_idIndexMarker366">
     </a>
     
      
       RxCpp (
      
     
     <a href="https://github.com/ReactiveX/RxCpp">
      
       
        https://github.com/ReactiveX/RxCpp
       
      
     </a>
     
      
       ).
      
     
    </li>
    <li>
     
      Microservices?
     
     
      Sure,
     
     <a id="_idIndexMarker367">
     </a>
     
      CppMicroServices (
     
     <a href="https://github.com/CppMicroServices/CppMicroServices">
      
       https://github.com/CppMicroServices/CppMicroServices
      
     </a>
     
      ) can help (no, microservices are not niche, but they’re rarely implemented
     
     
      
       in C++).
      
     
    </li>
    <li>
     
      Web Assembly?
     
     
      Yes, there’s
     
     <a id="_idIndexMarker368">
     </a>
     
      Emscripten (
     
     <a href="https://github.com/emscripten-core/emscripten">
      
       https://github.com/emscripten-core/emscripten
      
     </a>
     
      ) is a
     
     
      
       good
      
     
     
      <a id="_idIndexMarker369">
      </a>
     
     
      
       choice.
      
     
    </li>
    <li>
     
      Serverless?
     
     
      There’s
     
     
      <strong class="source-inline">
       
        aws-lambda-cpp
       
      </strong>
     
     
      
       (
      
     
     <a href="https://github.com/awslabs/aws-lambda-cpp">
      
       
        https://github.com/awslabs/aws-lambda-cpp
       
      
     </a>
     
      
       ).
      
     
    </li>
   </ul>
   <p>
    
     I think it’s obvious by now that we’d be hard-pressed to find any domain in which C++ lacks a library or framework.
    
    
     However, can we
    
    
     
      use them?
     
    
   </p>
   <h1 id="_idParaDest-110">
    <a id="_idTextAnchor109">
    </a>
    
     Compatibility
    
   </h1>
   <p>
    
     Let’s assume that you find a very promising library and decide to add it to your project.
    
    
     Does it work?
    
    
     How
    
    <em class="italic">
     
      well
     
    </em>
    
     will
    
    
     
      it work?
     
    
   </p>
   <p>
    
     Here’s where the
    
    <a id="_idIndexMarker370">
    </a>
    
     fragmentation of C++ shows its ugly side.
    
    
     The chance of any of the following undesirable things to happen
    
    
     
      is non-zero:
     
    
   </p>
   <ul>
    <li>
     
      The library uses a newer C++ version than your code and you can’t
     
     
      
       compile it
      
     
    </li>
    <li>
     
      The library uses an older C++ version than
     
     
      
       your code
      
     
    </li>
    <li>
     
      You get a lot of warnings for
     
     
      
       different reasons
      
     
    </li>
    <li>
     
      The library compiles well with your version of C++, but its interface uses
     
     
      
       older constructs
      
     
    </li>
    <li>
     
      The library doesn’t work on all platforms your
     
     
      
       project targets
      
     
    </li>
    <li>
     
      The library is incompatible with
     
     
      
       your compiler
      
     
    </li>
    <li>
     
      The library is incompatible with your
     
     
      
       compilation process
      
     
    </li>
    <li>
     
      The library is compatible with all platforms your project targets, but it has different
     
     <a id="_idIndexMarker371">
     </a>
     
      behavior or performance issues or bugs on
     
     
      
       specific platforms
      
     
    </li>
   </ul>
   <p>
    
     I hope you never encounter any of the preceding problems.
    
    
     Also, it’s worth saying that you’d be much less likely to have them in the technologies we use as a comparison: Python, Java, and .NET have none of these issues.
    
    
     Well, almost none; it’s possible, for example, to create Python programs that use C++ modules and face the same issues.
    
    
     Or you could create a Java program that uses OS primitives and has different issues on different OSs.
    
    
     In general, though, there’s a continuous effort for consistency in
    
    
     
      these worlds.
     
    
   </p>
   <p>
    
     To be fair, mature C++ frameworks and libraries such as Boost or
    
    <strong class="source-inline">
     
      zlib
     
    </strong>
    
     made the same effort and provided consistent behavior.
    
    
     It’s just easier to create consistent libraries in languages that use
    
    
     
      virtual machines.
     
    
   </p>
   <p>
    
     Let’s say that your library works fine: no warnings, no weird issues, and it plays well with your code and toolkit.
    
    
     There’s one last question: can we
    
    
     
      trust it?
     
    
   </p>
   <h1 id="_idParaDest-111">
    <a id="_idTextAnchor110">
    </a>
    
     Supply chain security
    
   </h1>
   <p>
    
     It should be obvious to
    
    <a id="_idIndexMarker372">
    </a>
    
     anyone paying attention that software has always had a security problem.
    
    
     This problem is getting worse since software usage continues to increase and cover more and more areas of our
    
    
     
      daily lives.
     
    
   </p>
   <p>
    
     There are two parts to improving security: the cybersecurity experts, who can find vulnerabilities and build protection tools, and the software developers, who need to find security issues before release and manage the accompanying risks.
    
    
     We know there’s no perfectly secure software, but we also know that things can get
    
    
     
      much better.
     
    
   </p>
   <p>
    
     A specific area of this increased protection is managing the potential vulnerabilities that come with the libraries we use.
    
    
     There are two situations: either vulnerabilities were introduced unknowingly, or they were injected on purpose by a
    
    
     
      malicious actor.
     
    
   </p>
   <p>
    
     In all
    
    <a id="_idIndexMarker373">
    </a>
    
     fairness, this can happen to any technology, and many of the high-profile C++ libraries are reviewed for security by large companies that use them.
    
    
     Moreover, if you’re working in a large company, you have teams dealing with all these concerns.
    
    
     However, not all development is done in large companies, and not all libraries are treated the same, as we’ll see with
    
    <a id="_idIndexMarker374">
    </a>
    
     the
    
    <strong class="bold">
     
      xz backdoor case
     
    </strong>
    
     .
    
    
     Let’s discuss the second case for a moment.
    
    
     A malicious actor can inject vulnerabilities in
    
    
     
      several ways:
     
    
   </p>
   <ul>
    <li>
     
      They can do this through a contribution to the code of an open
     
     
      
       source project.
      
     
    </li>
    <li>
     
      They can also fork an open source project and add vulnerabilities among
     
     
      
       useful features.
      
     
    </li>
    <li>
     
      They can also sometimes get away with becoming the maintainer of an open source project and then injecting vulnerabilities among useful features.
     
     
      See the story of the xz backdoor, which I
     
     <a id="_idIndexMarker375">
     </a>
     
      commented on at length,
     
     
      
       at
      
     
     <a href="https://mozaicworks.com/blog/xz-backdoor-and-other-news">
      
       
        https://mozaicworks.com/blog/xz-backdoor-and-other-news
       
      
     </a>
     
      
       .
      
     
    </li>
    <li>
     
      They can also replace the binary with a vulnerable version, for example, by offering it on another website than the original or managing to hijack the
     
     
      
       publishing process.
      
     
    </li>
    <li>
     
      They may also attempt hijacking the download, for example, through a DNS attack.
     
     
      Imagine a potential attacker managing to modify your local host’s file to point the URL of your repository to another IP address on
     
     
      
       the internet.
      
     
    </li>
   </ul>
   <p>
    
     All of the items in the preceding list are serious problems.
    
    
     In large companies, the security departments and IT/Ops tend to worry about them, but in smaller companies, it’s likely that you’ll need to pay extra attention.
    
    
     The solution we know is to validate all binaries with their digital signature or hash.
    
    
     While the package managers for programming languages and Linux do this automatically, manually downloading a binary from GitHub requires manual validation of the signature, hopefully provided along with the
    
    
     
      library file.
     
    
   </p>
   <p>
    
     The first situation is even more
    
    <a id="_idIndexMarker376">
    </a>
    
     complicated.
    
    
     How do you know whether a library has vulnerabilities?
    
    
     For open source code, the general belief is that many eyes look at the code and find all issues.
    
    
     However, that’s very dependent on the number of contributors and
    
    
     
      their expertise.
     
    
   </p>
   <p>
    
     The xz backdoor case
    
    <a id="_idIndexMarker377">
    </a>
    
     mentioned is chilling, especially since the issue was found by a developer, Andres Freund, who got suspicious by the fact that
    
    <strong class="source-inline">
     
      sshd
     
    </strong>
    
     was using too much CPU during a micro-benchmark (
    
    <a href="https://mastodon.social/@AndresFreundTec/112180406142695845">
     
      https://mastodon.social/@AndresFreundTec/112180406142695845
     
    </a>
    
     ).
    
    
     This made the issue of overworked maintainers for open source libraries visible, only for it to return to obscurity
    
    
     
      soon after.
     
    
   </p>
   <p>
    
     Let’s assume that most open source libraries are not attacked by a malicious actor who gains maintainer status.
    
    
     It’s still possible for vulnerabilities to escape, and more so in C++ since it has its own challenges in terms of security.
    
    
     A small team will need to stay informed of the reported vulnerabilities for the libraries they use, or license security tools that automatically do it
    
    
     
      for them.
     
    
   </p>
   <p>
    
     Assuming that everything works fine, it’s still best to store the list of libraries used in an application, so that the ops people know to periodically check for vulnerabilities in all the libraries used.
    
    
     The recommended practice in this area is to create what’s called
    
    <a id="_idIndexMarker378">
    </a>
    
     the
    
    <strong class="bold">
     
      Software Bill of Materials
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SBOM
     
    </strong>
    
     ) for your product.
    
    
     An SBOM contains the list of all the libraries and their dependencies.
    
    
     Specific tools are available to create the SBOM and to scan for vulnerabilities based on them; however, most of them work
    
    <a id="_idIndexMarker379">
    </a>
    
     with docker containers.
    
    
     For
    
    <a id="_idIndexMarker380">
    </a>
    
     example, consider Grype (
    
    <a href="https://github.com/anchore/grype">
     
      https://github.com/anchore/grype
     
    </a>
    
     and its companion
    
    <a id="_idIndexMarker381">
    </a>
    
     tool
    
    
     
      Syft
     
    
    <a href="https://github.com/anchore/syft">
     
      
       https://github.com/anchore/syft
      
     
    </a>
    
     
      ).
     
    
   </p>
   <p>
    
     This leads us to the conclusion of
    
    
     
      this chapter.
     
    
   </p>
   <h1 id="_idParaDest-112">
    <a id="_idTextAnchor111">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     We have seen in this chapter that C++ has a lot of libraries and frameworks that cover everything we might need.
    
    
     Compared to other technologies, the process of obtaining them is not as simple.
    
    
     They are not as easily discoverable since they are not in a central place, and they might bring additional issues such as incompatibility with the compiler or older code styles.
    
    
     We learned this in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     Similarly, like other technologies, the C++ libraries are prone to having vulnerabilities and are exposed to supply chain attacks.
    
    
     To protect against them, teams need to stay up to date with the stream of vulnerabilities discovered and authenticate the binaries upon download.
    
    
     Additional audits and scans are always useful, as we learned in this chapter.
    
    
     Thus, larger organizations have a security advantage since they have dedicated teams looking at these issues, at the cost
    
    
     
      of flexibility.
     
    
   </p>
   <p>
    
     So, are there libraries for modern programming in C++?
    
    
     Yes, definitely.
    
    
     They are just harder to find and less compatible than in other widely
    
    
     
      used technologies.
     
    
   </p>
   <p>
    
     In the next chapter, we’ll look at whether C++ is backward compatible...
    
    
     with itself
    
    
     
      and beyond.
     
    
   </p>
  </div>
 </body></html>