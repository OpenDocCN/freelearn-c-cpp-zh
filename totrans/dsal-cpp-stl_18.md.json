["```cpp\n#include <iostream>\n#include <type_traits>\ntemplate <typename T> void processNumericalData(T data) {\n  if constexpr (std::is_integral_v<T>) {\n    std::cout << \"Processing integer: \" << data << \"\\n\";\n  } else if constexpr (std::is_floating_point_v<T>) {\n    std::cout << \"Processing float: \" << data << \"\\n\";\n  } else {\n    static_assert(false, \"Unsupported type.\");\n  }\n}\nint main() {\n  processNumericalData(10);\n  processNumericalData(10.5f);\n  // Error: static_assert failed: 'Unsupported type.':\n  // processNumericalData(10.5);\n}\n```", "```cpp\nProcessing integer: 10\nProcessing float: 10.5\n```", "```cpp\ntemplate <typename T>\nvoid customSort(std::vector<T> &data) {\n  if constexpr (std::is_integral<T>::value) {\n    std::sort(data.begin(), data.end(), std::greater<T>());\n  } else {\n    std::sort(data.begin(), data.end());\n  }\n}\n```", "```cpp\n#include <iostream>\n#include <string>\n#include <type_traits>\n#include <vector>\n// Define a type trait to check for serialize method\ntemplate <typename, typename T>\nstruct has_serialize : std::false_type {};\ntemplate <typename T>\nstruct has_serialize<\n    std::void_t<decltype(std::declval<T>().serialize())>,\n    T> : std::true_type {};\ntemplate <typename T>\ninline constexpr bool has_serialize_v =\n    has_serialize<void, T>::value;\nclass Person {\npublic:\n  std::string name;\n  int age{0};\n  std::string serialize() const {\n    return \"Person{name: \" + name +\n           \", age: \" + std::to_string(age) + \"}\";\n  }\n};\nclass Dog {\npublic:\n  std::string name;\n  std::string breed;\n  // Note: Dog does not have a serialize method\n};\ntemplate <typename T>\nvoid processCollection(const std::vector<T> &collection) {\n  static_assert(has_serialize_v<T>,\n                \"T must have a serialize() method.\");\n  for (const auto &item : collection) {\n    std::cout << item.serialize() << std::endl;\n  }\n}\nint main() {\n  // Valid use, Person has a serialize method\n  std::vector<Person> people = {{\"Alice\", 30},\n                                {\"Bob\", 35}};\n  processCollection(people);\n  // Compile-time error:\n  // std::vector<Dog> dogs = {{\"Buddy\", \"Beagle\"}};\n  // processCollection(dogs);\n}\n```", "```cpp\nPerson{name: Alice, age: 30}\nPerson{name: Bob, age: 35}\n```", "```cpp\n#include <algorithm>\n#include <iostream>\n#include <vector>\n// Define a generic comparison policy for numeric types\ntemplate <typename T> struct NumericComparison {\n  bool operator()(const T &a, const T &b) const {\n    return (a < b);\n  }\n};\n// Define a specific comparison policy for strings\nstruct StringComparison {\n  bool operator()(const std::string &a,\n                  const std::string &b) const {\n    return (a.length() < b.length());\n  }\n};\n// Generic sort function using a policy\ntemplate <typename Iterator, typename ComparePolicy>\nvoid sortWithPolicy(Iterator begin, Iterator end,\n                    ComparePolicy comp) {\n  std::sort(begin, end, comp);\n}\nint main() {\n  // Example with numeric data\n  std::vector<int> numbers = {3, 1, 4, 1, 5, 9,\n                              2, 6, 5, 3, 5};\n  sortWithPolicy(numbers.begin(), numbers.end(),\n                 NumericComparison<int>());\n  for (auto n : numbers) { std::cout << n << \" \"; }\n  std::cout << \"\\n\";\n  // Example with string data\n  std::vector<std::string> strings = {\n      \"starfruit\", \"pear\", \"banana\", \"kumquat\", \"grape\"};\n  sortWithPolicy(strings.begin(), strings.end(),\n                 StringComparison());\n  for (auto &s : strings) { std::cout << s << \" \"; }\n  std::cout << \"\\n\";\n  return 0;\n}\n```", "```cpp\n1 1 2 3 3 4 5 5 5 6 9\npear grape banana kumquat starfruit\n```", "```cpp\ntemplate <typename T,\n          typename AllocatorPolicy = std::allocator<T>>\nclass CustomVector {\n  // Implementation using AllocatorPolicy for memory\n  // allocation\n};\n```", "```cpp\ntemplate <typename T,\n          typename ComparisonPolicy = std::less<T>>\nvoid customSort(std::vector<T> &data) {\n  // Sorting implementation using ComparisonPolicy for\n  // comparisons\n}\n```", "```cpp\n#include <functional>\n#include <list>\n#include <string>\n#include <type_traits>\n#include <vector>\n// Hashing Policy\ntemplate <typename Key> struct DefaultHashPolicy {\n  std::size_t operator()(const Key &key) const {\n    return std::hash<Key>()(key);\n  }\n};\n// Collision Resolution Policy\ntemplate <typename Key, typename Value>\nstruct SeparateChainingPolicy {\n  using BucketType = std::list<std::pair<Key, Value>>;\n};\n// Custom Hash Table\ntemplate <typename Key, typename Value,\n          typename HashPolicy = DefaultHashPolicy<Key>,\n          typename CollisionPolicy =\n              SeparateChainingPolicy<Key, Value>>\nclass CustomHashTable {\nprivate:\n  std::vector<typename CollisionPolicy::BucketType> table;\n  HashPolicy hashPolicy;\n  // ...\npublic:\n  CustomHashTable(size_t size) : table(size) {}\n  // ... Implement methods like insert, find, erase\n};\nint main() {\n  // Instantiate custom hash table with default policies\n  CustomHashTable<int, std::string> hashTable(10);\n  // ... Usage of hashTable\n}\n```"]