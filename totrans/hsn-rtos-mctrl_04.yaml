- en: Task Signaling and Communication Mechanisms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务信号和通信机制
- en: In the previous chapter, the task was introduced. Toward the end, we looked
    at examples of preemptive scheduling for multiple tasks in the system and the
    fact that a task will run whenever it isn't waiting on something (in the blocked
    state) and can do something useful. In this chapter, the core mechanisms for task
    signaling and inter-task communication will be briefly introduced. These primitives
    are fundamental to event-driven parallel programming, which is the foundation
    of a well implemented RTOS-based application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了任务。在结尾处，我们查看了一些关于系统中多个任务的抢占式调度的示例，以及任务将在它不是在等待某事（处于阻塞状态）并且可以执行某些有用操作时运行的事实。在本章中，我们将简要介绍任务信号和任务间通信的核心机制。这些原语对于事件驱动并行编程是基本的，而事件驱动并行编程是良好实现的基于实时操作系统的应用程序的基础。
- en: 'Rather than dive right into the FreeRTOS API, each primitive will be presented
    along with a few graphical examples and some suggestions on when each of the mechanisms
    can be used. Don''t worry: in later chapters, we''ll get into the nitty-gritty
    of working with the API. For now, let''s concentrate on the fundamentals.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会直接深入FreeRTOS API，而是将每个原语与一些图形示例和一些关于何时可以使用每种机制的提示一起展示。不用担心：在后面的章节中，我们将深入了解如何使用API。现在，让我们专注于基础知识。
- en: 'In this chapter, we''ll be introducing the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: RTOS queues
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RTOS队列
- en: RTOS semaphores
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RTOS信号量
- en: RTOS mutexes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RTOS互斥锁
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There are no software or hardware requirements for this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有软件或硬件要求。
- en: RTOS queues
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RTOS队列
- en: Queues are quite simple in concept, but they are also extremely powerful and
    flexible, especially if you've traditionally programmed on bare metal with C.
    At its heart, a queue is simply a circular buffer. However, this buffer contains
    some very special properties, such as native multi-thread safety, the flexibility
    for each queue to hold any type of data, and waking up other tasks that are waiting
    on an item to appear in the queue. By default, data is stored in queues using **First
    In First Out** (**FIFO**) ordering – the first item to be put into the queue is
    the first item to be removed from the queue.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 队列在概念上相当简单，但它们也非常强大和灵活，尤其是如果你传统上使用C语言在裸机上进行编程。在本质上，队列只是一个环形缓冲区。然而，这个缓冲区包含一些非常特殊的属性，例如原生的多线程安全性，每个队列可以持有任何类型的数据的灵活性，以及唤醒等待队列中出现项目的其他任务。默认情况下，数据使用**先进先出**（**FIFO**）顺序存储在队列中——首先放入队列的项目是首先从队列中移除的项目。
- en: We'll start by taking a look at some simple behavior of queues when they are
    in different states and used in different ways (sending versus receiving) and
    then move on to how queues can be used to pass information between tasks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看队列在不同状态和不同使用方式（发送与接收）下的简单行为，然后继续讨论如何使用队列在任务之间传递信息。
- en: Simple queue send
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单队列发送
- en: 'The first queue example is simply adding (also referred to as *sending)* an
    item to a queue that has empty space:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个队列示例仅仅是向队列中添加（也称为*发送)*一个有空间的项目：
- en: '![](img/851688d9-f8de-47c0-8d9c-8754ef87f4ae.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/851688d9-f8de-47c0-8d9c-8754ef87f4ae.png)'
- en: When an item is added to a queue with available space, the addition happens
    immediately. Because space was available in the queue, the task *sending* the
    item to the queue continues running, unless there is another higher priority task
    waiting on an item to appear in the queue.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个项目被添加到有可用空间的队列中时，添加操作会立即发生。因为队列中有可用空间，所以将项目*发送*到队列的任务会继续运行，除非有另一个更高优先级的任务正在等待队列中出现项目。
- en: Although interaction with queues typically happens from within tasks, this isn't *always*
    the case. There are some special cases where queues can also be accessed from
    within ISRs (but that behavior has different rules). For the examples in this
    chapter, we'll assume that tasks are sending and receiving items from the queues.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与队列的交互通常发生在任务内部，但这并不是*总是*如此。有一些特殊情况，队列也可以从ISR内部访问（但该行为有不同的规则）。对于本章的示例，我们将假设任务是向队列发送和接收项目。
- en: Simple queue receive
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单队列接收
- en: 'In the following diagram, a task is shown *receiving* an item from a queue:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，一个任务被显示为从队列中*接收*一个项目：
- en: '![](img/7d18370c-5991-4c5f-a0f8-1324f6460aee.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d18370c-5991-4c5f-a0f8-1324f6460aee.png)'
- en: When a task is ready to receive an item from a queue, by default, it will get
    the oldest item. In this example, since there is at least one item in the queue,
    the *receive *is processed immediately and the task continues to run.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个任务准备从队列中接收一个项目时，默认情况下，它将获取最老的项目。在这个例子中，由于队列中至少有一个项目，所以*接收*操作将立即处理，任务继续运行。
- en: Full queue send
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 满队列发送
- en: 'When a queue is full, no information is thrown away. Instead, the task attempting
    to *send* the item to the queue will wait for up to a predetermined amount of
    time for available space in the queue:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当队列满时，不会丢弃任何信息。相反，试图将项目发送到队列中的任务将等待直到预定的等待时间，以等待队列中有可用空间：
- en: '![](img/deda0050-1e45-4fb6-bdfc-34fd51212d02.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/deda0050-1e45-4fb6-bdfc-34fd51212d02.png)'
- en: When a queue is full, the task that is attempting to send an item to the queue will
    wait until a space in the queue becomes available, but only up to the timeout
    value specified.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当队列满时，试图向队列发送项目的任务将等待直到队列中有空间可用，但只到指定的超时值。
- en: In this example, if a task was attempting to send to a full queue and it has
    a timeout of 10 ms – it would only wait 10 ms for space to become available in
    the queue. After the timeout expires, the call will return and notify the calling
    code that the send has failed. What to do regarding this failure is at the discretion
    of the programmer setting up the calling code and will vary depending on the use
    case. Extremely large timeout values can be used for truly non-critical functions.
    Just be aware that this will cause the sending task to effectively wait forever
    for a slot in the queue to become available (this is obviously no longer real
    time)!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果一项任务试图向一个满队列发送数据，并且它的超时时间是10毫秒——它将只等待10毫秒以等待队列中有空间可用。超时时间过后，调用将返回并通知调用代码发送失败。关于这种失败的处理方式由设置调用代码的程序员决定，并且会根据具体的使用情况而有所不同。对于真正非关键的功能，可以使用非常长的超时值。只是要注意，这会导致发送任务实际上永远等待队列中的空间变得可用（这显然不再是实时了）！
- en: Your code will typically be structured so that attempts to send to a queue won't
    timeout. It is up to you, as the programmer, to determine what an acceptable amount
    of time is on a case-by-case basis. It is also your responsibility to determine
    the severity and corrective actions if a timeout does occur. Potential corrective
    actions could range from nothing (think of a dropped frame in a video call) to
    an emergency shutdown.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码通常会被构建成尝试向队列发送数据不会超时。作为程序员，你需要根据具体情况确定可接受的时间长度。如果发生超时，你也负责确定其严重性和纠正措施。可能的纠正措施可能从什么也不做（比如视频通话中丢失的一帧）到紧急关闭。
- en: Empty queue receive
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空队列接收
- en: 'Another case where accessing a queue can cause a task to block is attempting
    to *receive* from an empty queue:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能导致任务阻塞的情况是尝试从空队列中*接收*：
- en: '![](img/2ebe3c14-9c4d-4212-948e-2a329269f695.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ebe3c14-9c4d-4212-948e-2a329269f695.png)'
- en: Similar to a *Send* waiting on space to become available, a task *receiving*
    from a queue also has the potential to be delayed. In the case of an empty queue,
    the task that is attempting to receive from the queue will be blocked until an
    item appears in the queue. If no item is available before the timeout expires,
    the calling code will be notified of the failure. Again, the exact course of action
    to take varies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与等待空间变得可用的*发送*操作类似，从队列中*接收*的任务也有可能被延迟。在空队列的情况下，试图从队列中接收项目的任务将被阻塞，直到队列中出现项目。如果在超时时间之前没有可用项目，调用代码将被通知失败。再次强调，采取的具体行动会有所不同。
- en: Sometimes, infinite waits are used. You'll often encounter very long wait periods
    for queues that are receiving input from external interfaces, such as serial ports,
    which may not be sending data constantly. There is no issue at all if a human
    user on the other end of a serial port hasn't sent data for an extended period
    of time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，会使用无限等待。你经常会遇到非常长的等待期，对于接收来自外部接口（如串行端口）输入的队列，这些接口可能不会持续发送数据。如果串行端口另一端的人类用户在一段时间内没有发送数据，这根本不会有任何问题。
- en: On the other hand, receive timeouts can also be used to ensure that you have
    a minimum acceptable amount of data to process. Let's use a sensor that is meant
    to provide a new reading at 10 Hz (10 readings per second). If you were implementing
    an algorithm that relies on *fresh* readings from this sensor, a timeout of slightly
    greater than 100 ms could be used to trigger an error. This timeout would guarantee
    that the algorithm is always acting on *fresh* sensor readings. In this case,
    hitting a timeout could be used to trigger some type of corrective action or notification
    that the sensor wasn't performing as expected.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，接收超时也可以用来确保你有足够的数据量来处理。让我们使用一个旨在以10 Hz（每秒10次读取）提供新读数的传感器。如果你正在实现依赖于该传感器**新鲜**读数的算法，可以使用略大于100
    ms的超时来触发错误。这个超时将保证算法始终在**新鲜**的传感器读数上操作。在这种情况下，超时可以用来触发某种纠正行动或通知传感器未按预期工作。
- en: Queues for inter-task communication
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互任务队列
- en: 'Now that the simple behaviors of queues have been covered, we''ll take a look
    at how they can be used to move data between tasks. A very common use case for
    queues is to have one task populate the queue while another is reading from the
    same queue. This is generally straightforward but may have some nuances, depending
    on how the system is set up:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经覆盖了队列的简单行为，我们将看看它们如何用于在任务之间移动数据。队列的一个非常常见的用例是有一个任务填充队列，而另一个任务从同一个队列中读取。这通常很简单，但可能有一些细微差别，具体取决于系统的设置：
- en: '![](img/e055b8d1-e83c-47c0-8c7e-dce58908e629.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e055b8d1-e83c-47c0-8c7e-dce58908e629.png)'
- en: In the preceding example, `Task 1` and `Task 2` are both interacting with the
    same Queue. `Task 1` will *send* an item to the Queue. As long as `Task 2` has
    a higher priority than `Task 1`, it will immediately *receive* the item.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`任务1`和`任务2`都在与同一个队列交互。`任务1`将项目**发送**到队列。只要`任务2`的优先级高于`任务1`，它就会立即**接收**该项目。
- en: 'Let''s consider another instance that often occurs in practice when multiple
    tasks are interacting with queues. Since a preemptive scheduler always runs the
    task with the highest priority, if that task always has data to write to the queue,
    the queue will fill before another task is given a chance to read from the queue.
    Here is an example of how this may play out:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个在实践中经常发生的实例，即多个任务与队列交互。由于抢占式调度器始终运行具有最高优先级的任务，如果该任务始终有数据要写入队列，队列将在另一个任务有机会从队列中读取之前填满。以下是一个可能发生的情况的示例：
- en: '![](img/27e18540-cd90-40d7-b29f-04d827ec5b28.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/27e18540-cd90-40d7-b29f-04d827ec5b28.png)'
- en: 'The following numbers correspond to indexes along the time axis:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下数字对应于时间轴上的索引：
- en: '`Task2` attempts to receive an item from the empty queue. No items are available,
    so `Task2` blocks.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`任务2`试图从空队列中接收一个项目。没有可用项目，因此`任务2`被阻塞。'
- en: '`Task1` adds items to queue. Since it is the highest priority task in the system, `Task1`
    adds items to the queue until it doesn''t have any more items to add, or until
    the queue is full.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`任务1`向队列添加项目。由于它是系统中的最高优先级任务，`任务1`会一直向队列添加项目，直到没有更多项目可添加，或者直到队列已满。'
- en: The queue is filled, so `Task1` is blocked.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 队列已满，因此`任务1`被阻塞。
- en: '`Task2` is given context by the scheduler since it is now the highest priority
    task that may run.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`任务2`由调度器提供上下文，因为它现在是可能运行的最高优先级任务。'
- en: As soon as an item is removed from the Queue, `Task1` is given context again
    (this is the highest priority task in the system and it is now able to run because
    it was blocking while waiting for space to become available in the queue). After
    adding a single item, the queue is full and `Task1` is blocked.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦从队列中移除一个项目，`任务1`再次被提供上下文（这是系统中的最高优先级任务，它现在能够运行，因为它在等待队列中有空间可用时被阻塞）。在添加单个项目后，队列已满，`任务1`被阻塞。
- en: '`Task2` is given context and receives an item from the queue:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`任务2`被提供上下文并从队列中接收一个项目：'
- en: A real-world example of the preceding situation is covered in [Chapter 9](495bdcc0-2a86-4b22-9628-4c347e67e49e.xhtml),* Intertask
    Communication*,in the section *Passing data through queues*.`Chapter_9/src/*mainQueueCom**positePassByValue.c*`illustrates
    the exact setup and a thorough empirical execution analysis is performed using
    `SystemView`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情况的一个现实世界示例在[第9章](495bdcc0-2a86-4b22-9628-4c347e67e49e.xhtml)，“**任务间通信”*部分中的*通过队列传递数据*。`Chapter_9/src/*mainQueueCom**positePassByValue.c*`展示了确切的设置，并使用`SystemView`进行了彻底的经验性执行分析。
- en: '![](img/50f984da-cb2d-43a4-82bc-a20941886c49.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50f984da-cb2d-43a4-82bc-a20941886c49.png)'
- en: Another extremely common use case for queues is to have a single queue accept
    input from many different sources. This is especially useful for something like
    a debug serial port or a log file. Many different tasks can be writing to the
    queue, with a single task responsible for receiving data from the queue and pushing
    it out to the shared resource.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的另一个极其常见的用例是单个队列接受来自许多不同来源的输入。这对于像调试串行端口或日志文件这样的东西特别有用。许多不同的任务可以写入队列，而只有一个任务负责从队列接收数据并将其推送到共享资源。
- en: While queues are generally used for passing data between tasks, semaphores can
    be used for signaling and synchronizing tasks. Let's learn more about this next.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当队列通常用于在任务之间传递数据时，信号量可以用于信号和同步任务。让我们接下来了解更多关于这一点。
- en: RTOS semaphores
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RTOS信号量
- en: 'Semaphores are another very straightforward, but powerful, construct. The word
    *semaphore* has a Greek origin – the approximate English translation is *sign-bearer*,
    which is a wonderfully intuitive way to think about them. Semaphores are used
    to indicate that something has happened; they signal events. Some example use
    cases of semaphores include the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是另一个非常直接但强大的结构。单词*信号量*源自希腊语——其大致的英文翻译是*信号携带者*，这是一个非常直观的方式来思考它们。信号量用于指示发生了某事；它们是事件的信号。信号量的以下是一些示例用例：
- en: An ISR is finished servicing a peripheral. It may *give* a semaphore to provide
    tasks with a signal indicating that data is ready for further processing.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个中断服务例程（ISR）完成了对外围设备的处理。它可能*释放*一个信号量，向任务提供信号，表明数据已准备好进一步处理。
- en: A task has reached a juncture where it needs to wait for other tasks in the
    system to *catch up* before moving on. In this case, a semaphore could be used
    to synchronize the tasks.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个任务达到了一个需要等待系统中的其他任务*赶上*才能继续前进的交叉点。在这种情况下，可以使用信号量来同步任务。
- en: Restricting the number of simultaneous users of a restricted resource.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制对受限资源的同时用户数量。
- en: One of the convenient aspects of using an RTOS is the pre-existence of semaphores.
    They are included in every implementation of an RTOS because of how basic (and
    crucial) their functionality is. There are two different types of semaphores to
    cover – counting semaphores and binary semaphores.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用实时操作系统（RTOS）的一个方便之处在于信号量的预先存在。由于它们的功能基础（且关键），它们被包含在RTOS的每个实现中。有两种不同类型的信号量来覆盖这些需求——计数信号量和二进制信号量。
- en: Counting semaphores
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数信号量
- en: Counting semaphores are most often used to manage a shared resource that has
    limitations on the number of simultaneous users. Upon creation, they can be configured
    to hold a maximum value, called a *ceiling. *The example normally given for counting
    semaphores is readers in a database ... Well, we're talking about an MCU-based
    embedded system here, so let's keep our examples relevant. If you're interested
    in databases, you're probably better off with a general-purpose OS! For our example,
    let's say you're implementing a socket-based communication driver and your system
    only has enough memory for a limited number of simultaneous socket connections.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 计数信号量通常用于管理具有对同时用户数量限制的共享资源。在创建时，它们可以被配置为持有最大值，称为*上限*。计数信号量的例子通常是数据库中的读者...
    好吧，我们在这里讨论的是一个基于MCU的嵌入式系统，所以让我们保持我们的例子相关。如果你对数据库感兴趣，你可能更适合使用通用操作系统！对于我们的例子，让我们假设你正在实现一个基于套接字的通信驱动程序，而你的系统只有足够的内存来支持有限数量的同时套接字连接。
- en: 'In the following diagram, we have a shared network resource that can accommodate
    two simultaneous socket connections. However, there are three tasks that need
    access. A counting semaphore is used to limit the number of simultaneous socket
    connections. Each time a task is finished with the shared resource (that is, its
    socket closes), it must give back its semaphore so another task can gain access
    to the network. If a task happens to *give* a semaphore that is already at its
    maximum count, the count will remain unchanged:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，我们有一个可以容纳两个同时套接字连接的共享网络资源。然而，有三个任务需要访问。计数信号量用于限制同时套接字连接的数量。每次任务完成对共享资源的处理（即其套接字关闭）时，它必须释放其信号量，以便另一个任务可以访问网络。如果一个任务意外地*释放*了一个已经达到最大计数的信号量，计数将保持不变：
- en: '![](img/4fc26255-cb6f-4221-975f-cdceff8b8b3b.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4fc26255-cb6f-4221-975f-cdceff8b8b3b.png)'
- en: 'The preceding diagram plays out the example of a shared resource only capable
    of servicing two simultaneous tasks (although three tasks in the system need to
    use the resource). If a task is going to use a socket, which is protected by the
    counting semaphore, it must first *take* a semaphore from the pool. If no semaphore
    is available, then the task must wait until a semaphore becomes available:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示演示了一个只能同时服务两个任务（尽管系统中有三个任务需要使用该资源）的共享资源示例。如果一个任务要使用受计数信号量保护的套接字，它必须首先从池中获取一个信号量。如果没有可用的信号量，那么该任务必须等待直到信号量变得可用：
- en: Initially, a semaphore is created with a maximum (ceiling) of 2 and an initial
    count of 0.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始时，创建一个最大（上限）为 2 且初始计数为 0 的信号量。
- en: When `TaskA` and `TaskB` attempt to *take* a `semphr`, they're immediately successful. At
    this point, they can each open up a socket and communicate over the network.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `TaskA` 和 `TaskB` 尝试获取 `semphr` 时，它们立即成功。在这个时候，它们可以各自打开一个套接字并在网络上进行通信。
- en: '`TaskC` was a bit later, so it will need to wait until the count of `semphr` is
    less than 2, which is when a network socket will be free to use.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TaskC` 完成得稍晚一些，因此它需要等待 `semphr` 的计数小于 2，这时网络套接字才能被自由使用。'
- en: After `TaskB` is finished communicating over its socket, it returns the semaphore.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TaskB` 通过其套接字完成通信后，它归还信号量。
- en: Now that a semaphore is available, `TaskC` completes its *take* and is allowed
    network access.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在信号量可用后，`TaskC` 完成其获取操作，并被允许访问网络。
- en: Shortly after `TaskC` gets access, `TaskB` has another message to send, so it
    attempts to take a semaphore, but needs to wait for one to become available, so
    it is put to sleep.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TaskC` 获取访问权限不久后，`TaskB` 有另一条消息要发送，因此它尝试获取一个信号量，但需要等待一个信号量变得可用，所以它被置于睡眠状态。
- en: While `TaskC` is communicating over the network, `TaskA` finishes and returns
    its semaphore.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `TaskC` 在网络上进行通信时，`TaskA` 完成，并归还其信号量。
- en: '`TaskB` is woken up and its take completes, which enables it to start communicating
    over the network.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TaskB` 被唤醒并完成其任务，这使得它能够开始通过网络进行通信。'
- en: After `TaskB` is given its semaphore, `TaskC` completes its transaction and
    gives back the semaphore it had.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TaskB` 被赋予其信号量后，`TaskC` 完成其事务并归还它所持有的信号量。
- en: '*Waiting* for semaphores is where an RTOS differs from most other semaphore
    implementations – a task can *timeout* during a semaphore wait. If a task fails
    to acquire the semaphore in time, it must not access the shared resource. Instead,
    it must take an alternative course of action. This alternative could be any number
    of actions that can range from a failure so severe that it triggers an emergency
    shutdown sequence, to something so benign that it is merely mentioned in a log
    file or pushed to a debug serial port for analysis later on. As a programmer,
    it is up to you to determine what the appropriate course of action is, which can
    sometimes prompt some difficult discussions with other disciplines.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在信号量等待中，实时操作系统（RTOS）与大多数其他信号量实现不同——任务在信号量等待期间可能会超时。如果一个任务未能及时获取信号量，它不得访问共享资源。相反，它必须采取替代措施。这种替代措施可以是多种多样的行动，从严重到足以触发紧急关闭序列，到轻微到只需在日志文件中提及或推送到调试串行端口以供以后分析。作为程序员，确定适当的行动方案取决于你，这有时可能会与其他学科进行一些困难的讨论。
- en: Binary semaphores
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制信号量
- en: 'Binary semaphores are really just counting semaphores with a maximum count
    of 1\. They are most often used for synchronization. When a task needs to synchronize
    on an event, it will attempt to *take* a semaphore, blocking until the semaphore
    becomes available or until the specified timeout has elapsed. Another asynchronous
    part of the system (either a task or an ISR) will *give* a semaphore. Binary semaphores
    can be *given* more than once; there is no need for that piece of code to *return*
    them. In the following example, `TaskA` only *gives* a semaphore, while `TaskB` only *takes*
    a semaphore:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制信号量实际上只是最大计数为 1 的计数信号量。它们最常用于同步。当一个任务需要同步于一个事件时，它将尝试获取一个信号量，直到信号量变得可用或直到指定的超时时间已过。系统的另一个异步部分（无论是任务还是中断服务例程）将释放一个信号量。二进制信号量可以多次释放；不需要代码将它们返回。在以下示例中，`TaskA`
    只释放信号量，而 `TaskB` 只获取信号量：
- en: '![](img/02afc9ad-fd70-4699-be36-885fc8545359.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/02afc9ad-fd70-4699-be36-885fc8545359.png)'
- en: '`TaskB` is set up to wait for a signal (semaphore) before proceeding with its
    duties:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskB` 在执行其任务之前被设置为等待一个信号（信号量）：'
- en: Initially, `TaskB` attempts to *take* the semaphore, but it wasn't available,
    so `TaskB` went to sleep.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始时，`任务B`试图*获取*信号量，但它不可用，所以`任务B`进入了睡眠状态。
- en: Sometime later, `TaskA` *gives* the signal.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某个时候之后，`任务A`发出信号。
- en: '`TaskB` is woken up (by the scheduler; this happens in the background) and
    now has the semaphore. It will go about the duties required of it until it is
    finished. Notice, however, that `TaskB` doesn''t need to give back the binary
    semaphore. Instead, it simply waits for it again.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`任务B`被唤醒（由调度器唤醒；这发生在后台），现在拥有了信号量。它将完成其所需的任务，直到完成。然而，请注意，`任务B`不需要归还二进制信号量。相反，它只需再次等待它。'
- en: '`TaskB` is blocked again because the semaphore isn''t available (just like
    the first time), so it goes to sleep until a semaphore is available.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`任务B`再次被阻塞，因为信号量不可用（就像第一次一样），因此它进入睡眠状态，直到信号量可用。'
- en: The cycle repeats.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环重复。
- en: If `TaskB` were to "give back" the binary semaphore, it would immediately run
    again, without receiving the go-ahead from `TaskA`. The result would just be a
    loop running full speed, rather than being signaled on a condition signaled from
    `TaskA`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`任务B`要“归还”二进制信号量，它将立即再次运行，而无需从`任务A`那里获得许可。结果将是一个全速运行的循环，而不是从`任务A`那里接收到信号。
- en: Next, we'll discuss a special type of semaphore with some additional properties
    that make it especially well suited for protecting items that can be accessed
    from different tasks – the mutex.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论一种具有一些额外属性的特殊类型的信号量，这些属性使其特别适合于保护可以从不同任务访问的项目——互斥锁。
- en: RTOS mutexes
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RTOS互斥锁
- en: The term **mutex** is shorthand for **mutual** **exclusion.** In the context
    of shared resources and tasks, mutual exclusion means that, if a task is using
    a shared resource, then that task is the *only* t*ask* that is permitted to use
    the resource – all others will need to wait.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**互斥锁**是**互斥**的缩写。在共享资源和任务的情况下，互斥意味着，如果一个任务正在使用共享资源，那么该任务是*唯一*被允许使用该资源的任务——所有其他任务都需要等待。
- en: If all this sounds a lot like a binary semaphore, that's because it is. However,
    it has an additional feature that we'll cover soon. First, let's take a look at
    the problem with using a binary semaphore to provide mutual exclusion.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切听起来很像二进制信号量，那是因为它就是。然而，它有一个额外的特性，我们很快就会介绍。首先，让我们看看使用二进制信号量提供互斥时的问题。
- en: Priority inversion
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先级反转
- en: Let's look at a common problem that occurs when attempting to use a binary semaphore
    to provide mutual exclusion functionality.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在尝试使用二进制信号量提供互斥功能时出现的一个常见问题。
- en: 'Consider three tasks, A, B, and C, where A has the highest priority, B the
    middle priority, and C the lowest priority. Tasks A and C rely on a semaphore
    to give access to a resource that is shared between them. Since Task A is the
    highest priority task in the system, it should always be running before other
    tasks. However, since Task A and Task C both rely on a resource shared between
    them (guarded by the binary semaphore), there is an unexpected dependency here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑三个任务，A、B和C，其中A具有最高优先级，B具有中等优先级，C具有最低优先级。任务A和C依赖于一个信号量来访问它们之间共享的资源。由于任务A是系统中的最高优先级任务，它应该总是在其他任务之前运行。然而，由于任务A和任务C都依赖于它们之间共享的资源（由二进制信号量保护），这里存在一个意外的依赖关系：
- en: '![](img/b12a6d93-2088-4e62-b827-d7898385ba24.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b12a6d93-2088-4e62-b827-d7898385ba24.png)'
- en: 'Let''s walk step by step through the example to see how this scenario plays
    out:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地通过这个例子来看看这个场景是如何展开的：
- en: '`Task C` (the lowest priority task in the system) acquires a binary semaphore
    and starts to do some work.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`任务C`（系统中的最低优先级任务）获取了一个二进制信号量并开始做一些工作。'
- en: Before `Task C` completes its work, `Task A` (the highest priority task) interrupts
    and attempts to acquire the same semaphore, but is forced to wait because `Task
    C` has already acquired the semaphore.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`任务C`完成其工作之前，`任务A`（最高优先级任务）中断并尝试获取相同的信号量，但被迫等待，因为`任务C`已经获取了信号量。
- en: '`Task B` preempts `Task C` as well, because `Task B` has a higher priority
    than `Task C`. `Task B` performs whatever work it has and then goes to sleep.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`任务B`也抢占`任务C`，因为`任务B`的优先级高于`任务C`。`任务B`执行其所有工作然后进入睡眠状态。'
- en: '`Task C` runs through the remainder of its work with the shared resource, at
    which point it gives the semaphore back.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`任务C`使用共享资源完成剩余的工作，此时它将信号量归还。'
- en: '`Task A` is *finally* able to run.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`任务A`最终能够运行。'
- en: '`Task A` was able to run, eventually, but not until TWO lower priority tasks
    had run. `Task C` finishing its work with the shared resource was unavoidable
    (unless a design change could have been made to prevent it from accessing the
    same shared resource as `Task A`). However, `Task B` also had an opportunity to
    run to completion, even though `Task A` was waiting around and had a higher priority!
    This is priority inversion – a higher priority task in the system is waiting to
    run, but it is forced to wait while a lower priority task is running instead –
    the priorities of the two tasks are effectively *inverted* in this case.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task A`最终能够运行，但不是直到两个低优先级任务都运行过。`Task C`完成其使用共享资源的工作是不可避免的（除非可以进行设计更改以防止它访问与`Task
    A`相同的共享资源）。然而，尽管`Task A`在等待并且具有更高的优先级，`Task B`也有机会运行完成！这是优先级反转——系统中一个高优先级任务正在等待运行，但它被迫等待一个低优先级任务运行——在这种情况下，两个任务的优先级实际上是*反转*的。'
- en: Mutexes minimize priority inversion
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁最小化优先级反转
- en: 'Earlier, we had said that, in FreeRTOS, mutexes were binary semaphores with
    one important additional feature. That important feature is priority inheritance –
    mutexes have the ability to temporarily change the priority of a task to avoid
    causing major delays in the system. This plays out when the scheduler finds that
    a high priority task is attempting to acquire a mutex already held by a lower
    priority task. In this specific case, the scheduler will temporarily increase
    the priority of the lower task until it releases the mutex. At this point, the
    priority of the lower task will be set back to what it was prior to the priority
    inheritance. Let''s take a look at the exact same example from the preceding diagram
    implemented using a mutex (instead of a binary semaphore):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到，在FreeRTOS中，互斥锁是二进制信号量，但有一个重要的附加功能。这个重要的功能是优先级继承——互斥锁具有暂时改变任务优先级的能力，以避免在系统中造成重大延迟。这发生在调度器发现一个高优先级任务试图获取一个由低优先级任务持有的互斥锁时。在这种情况下，调度器将暂时提高低优先级任务的优先级，直到它释放互斥锁。此时，低优先级任务的优先级将恢复到优先级继承之前的优先级。让我们看看前一个图中使用互斥锁（而不是二进制信号量）实现的完全相同的例子：
- en: '![](img/5543d397-b1a5-4986-8c80-0eda35913a16.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5543d397-b1a5-4986-8c80-0eda35913a16.png)'
- en: 'Let''s walk step by step through the example to see how this scenario plays
    out:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地通过这个例子来看这个场景是如何展开的：
- en: '`Task A` is still waiting for `Task C` to return the mutex.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task A`仍在等待`Task C`返回互斥锁。'
- en: The priority of `Task C` is brought up to be the same as that of the higher
    priority `Task A`. `Task C` runs to completion since it holds the mutex and is
    a high priority task.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Task C`的优先级提高到与高优先级`Task A`相同。由于`Task C`持有互斥锁并且是高优先级任务，它将运行完成。
- en: '`Task C` returns the mutex and its priority is demoted to whatever it was before
    it was holding a mutex that was delaying the high priority task.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task C`返回互斥锁，其优先级降低到它持有互斥锁之前的状态，从而延迟了高优先级任务。'
- en: '`Task A` takes the mutex and completes its work.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Task A`获取互斥锁并完成其工作。'
- en: '`Task B` is allowed to run.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许`Task B`运行。
- en: Depending on how long `Task C` is taking with the shared resource and how time
    sensitive `Task A` is, this could either be a major source of concern or no big
    deal. Timing analysis can be performed to ensure that `Task A` is still meeting
    deadlines, but tracking all possible causes of priority inversion and other high
    priority asynchronous events could prove to be challenging. At a minimum, the
    user should make use of the built-in timeouts provided for taking mutexes and
    perform a suitable alternative action if a mutex has failed to be taken in a timely
    manner. More details on exactly how to accomplish this can be found in [Chapter
    9](495bdcc0-2a86-4b22-9628-4c347e67e49e.xhtml), *Intertask Communication*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`Task C`使用共享资源所需的时间以及`Task A`的时间敏感性，这可能是引起严重关注的主要来源，也可能不是什么大问题。可以通过时间分析来确保`Task
    A`仍然能够按时完成任务，但跟踪所有可能导致优先级反转和其他高优先级异步事件的可能原因可能会很具挑战性。至少，用户应该利用为获取互斥锁提供的内置超时，并在互斥锁未能及时获取的情况下执行适当的替代操作。关于如何具体实现这一点的更多细节可以在[第9章](495bdcc0-2a86-4b22-9628-4c347e67e49e.xhtml)《任务间通信》中找到。
- en: Mutexes and semaphores are fairly standard mechanisms for signaling between
    tasks. They are very standard between different RTOSes and provide excellent flexibility.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁和信号量是任务间信号的标准机制。它们在不同的实时操作系统（RTOSes）之间非常标准，提供了出色的灵活性。
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced queues, semaphores, and mutexes. A few common use cases
    of each of these core building blocks for RTOS applications were also discussed
    at a high level and some of the more subtle behaviors of each were highlighted.
    The diagrams presented in this chapter should serve as a reference point to return
    to as we move on to more complex real-world examples in later chapters.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了队列、信号量和互斥锁。还从高层次讨论了这些RTOS应用核心构建块的一些常见用例，并突出了每个的微妙行为。本章中展示的图表应作为我们在后续章节中转向更复杂的真实世界示例时的参考点。
- en: We've now covered some of the core RTOS concepts. In the next chapter, we'll
    turn our attention to another very important step of developing a solid real-time
    system. This step affects how efficiently firmware can be run and has a major
    impact on system performance – MCU selection.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了RTOS的一些核心概念。在下一章中，我们将把注意力转向开发一个坚实的实时系统的另一个非常重要的步骤。这一步骤会影响固件运行的效率，并对系统性能产生重大影响——MCU选择。
- en: Questions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the Appendix:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结之际，这里有一份问题清单，供您测试对本章材料的理解。您将在附录的*评估*部分找到答案：
- en: Which RTOS primitive is most commonly used for sending and receiving data between
    tasks?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个RTOS原语最常用于在任务之间发送和接收数据？
- en: Is it possible for a queue to interact with more than two tasks?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 队列是否可以与超过两个任务进行交互？
- en: Which RTOS primitive is commonly used for signaling and synchronizing tasks?
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个实时操作系统（RTOS）原语通常用于任务之间的信号和同步？
- en: What is an example of when a counting semaphore could be used?
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种情况下可以使用计数信号量作为例子？
- en: Name one major difference between binary semaphores and mutexes.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请列举二进制信号量和互斥锁之间的一项主要区别。
- en: When protecting a resource shared between tasks, should a binary semaphore or
    a mutex be used?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在保护任务间共享的资源时，应该使用二进制信号量还是互斥锁？
- en: What is priority inversion and why is it dangerous for a real-time system?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优先级反转是什么，为什么它对实时系统来说很危险？
