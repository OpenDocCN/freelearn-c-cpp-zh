<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Sorting and Searching</h1>
                </header>
            
            <article>
                
<p>Searching, as the name suggests, is the process of locating a specific element in a group of elements. Searching can be broadly classified as one of the following two types:</p>
<ul>
<li><strong>Linear searching</strong>: Where each element in the list is sequentially searched to find the desired item.</li>
<li><strong>Binary search</strong>: Where the list is assumed to already <span>be </span>sorted, and the middle value of the list is compared with the item to be searched to determine which half of the list needs to be considered for searching the item. The process of dividing the list continues until the item is found.</li>
</ul>
<p><span>Sorting, on the other hand, is the procedure of a</span><span>rranging certain elements in a certain order. The order can be ascending, descending, or in another specific order. Not only can the individual numerals and strings be sorted, but even records can be sorted. Records are sorted on the basis of some key that is unique to every record. These</span> are the two main categories of sorting:</p>
<ul>
<li><strong>Internal sorting</strong>: Where all the elements that are being sorted are uploaded together in the primary memory</li>
<li><strong>External sorting</strong>: Where some elements to be sorted are uploaded to the primary memory, and the rest are kept in auxiliary memory, such as on a hard disk or pen drive</li>
</ul>
<p><span>To be able to conduct effective searches, we need to know how to sort data. Sorting is essential because it makes the task of searching quite easy and fast.</span></p>
<p><span>In this chapter, you will learn the following recipes:</span></p>
<ul>
<li>Searching for an item using binary search </li>
<li>Arranging numbers in ascending order using bubble sort</li>
<li>Arranging numbers in ascending order using insertion sort</li>
<li>Arranging numbers in ascending order using quick sort</li>
<li>Arranging numbers in descending order using heap sort</li>
</ul>
<p>Let's begin with the first recipe!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Searching for an item using binary search </h1>
                </header>
            
            <article>
                
<p>Binary search uses the <em>divide and conquer</em> approach. The item to be searched for is compared with the middle item in an array or file. This helps in determining which half of the array or file might contain the item being searched for. After that, the middle value of the half that was considered is compared with the item being searched for to determine which quarter part of the array or file might contain the item being searched for. The process continues until either the item being searched for is found, or no more divisions of the array or file are possible, in which case, it is understood that the item being searched for is not present in the file or array.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Consider an array is <kbd>arr</kbd> of size <kbd>len</kbd> elements. We want to search for a number, <kbd>numb</kbd>, in this <span>array, </span><kbd>arr</kbd><span>.</span> Here are the steps to search for <kbd>numb</kbd> in the <kbd>arr</kbd> array using binary search:</p>
<ol>
<li>Initialize two variables, <kbd>lower</kbd> and <kbd>upper</kbd>.</li>
<li>Calculate the middle location of the array.</li>
<li>If the value to search, <kbd>numb</kbd><span>, is found at location</span> <kbd>arr[mid]</kbd> <span>then display <kbd>Value found</kbd> and exit (that is, jump to <em>step 8</em>).</span></li>
<li>If your search value is larger than the array's middle value, confine the search to the lower half of the array. So, set the lower limit of the array to the array's middle value.</li>
<li>If your search value is smaller than the array's middle value, confine the search to the upper half of the array. So, set the upper limit of the array to the array's <span>middle </span><span>value.</span></li>
<li>Repeat <em>steps 3</em> through <em>5</em> as long as <kbd>upper&gt;=lower</kbd>.</li>
</ol>
<ol start="7">
<li><span>The execution will proceed with this step only if the value is not found. Then display <kbd>Value not found</kbd> and exit.</span></li>
<li>Exit.</li>
</ol>
<p>The program for searching for an element in a sorted array using the binary search technique is as follows:</p>
<pre>//<strong>binarysearch.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/><br/>#define max 20<br/>int binary_search(int[], int, int);<br/><br/>int main() {<br/>  int len, found, numb, arr[max], i;<br/>  printf("Enter the length of an array: ");<br/>  scanf("%d", &amp; len);<br/>  printf("Enter %d values in sorted order \n", len);<br/>  for (i = 0; i &lt; len; i++)<br/>    scanf("%d", &amp; arr[i]);<br/>  printf("Enter the value to search ");<br/>  scanf("%d", &amp; numb);<br/>  found = binary_search(arr, numb, len);<br/>  if (found == numb)<br/>    printf("Value %d is found in the list\n", numb);<br/>  else<br/>    printf("Value %d is not found in the list \n", numb);<br/>  return 0;<br/>}<br/><br/>int binary_search(int arr[], int pnumb, int plen) {<br/>  int lindex = 0, mid, uindex = plen - 1, nfound;<br/>  while (uindex &gt;= lindex) {<br/>    mid = (uindex + lindex) / 2;<br/>    if (pnumb == arr[mid]) {<br/>      nfound = arr[mid];<br/>      break;<br/>    } else {<br/>      if (pnumb &gt; arr[mid])<br/>        lindex = mid + 1;<br/>      else<br/>        uindex = mid - 1;<br/>    }<br/>  }<br/>  return (nfound);<br/>}</pre>
<p>Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's define a macro called <kbd>max</kbd> of size 20 and an array, <kbd>arr</kbd>, of size <kbd>max</kbd>, that is, 20 elements (you can increase the value of the <kbd>max</kbd> macro to any larger value as desired). Next, we will specify the length of the array. Let's say that the length you entered is 8, which is then assigned to the <kbd>len</kbd> variable. When prompted, enter the specified number of sorted elements. The sorted elements you enter will be assigned to the <kbd>arr</kbd> array, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/604e1956-f828-45c2-b3b5-bdb2d59af980.png" style="width:6.42em;height:13.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 9.1</div>
<p>Then, you will be prompted to enter the number you want to search for in the sorted array. Let's say you picked 45; this number will be assigned to the <kbd>numb</kbd> variable. We will invoke the <kbd>binary_search</kbd> function and all three items – the <kbd>arr</kbd> <span>array, </span>the <span><kbd>numb</kbd> variable containing the </span>number to search for, and the length of the array in <kbd>len</kbd> – are passed to the function. The <kbd>arr</kbd>, <kbd>numb</kbd>, and <kbd>len</kbd> <span>arguments </span>will be assigned to the <kbd>arr</kbd>, <kbd>pnumb</kbd>, and <kbd>plen</kbd> <span>parameters </span>respectively.</p>
<p>In the <kbd>binary_search</kbd> function, we will initialize two variables: <kbd>lindex</kbd> to <kbd>0</kbd> and <kbd>uindex</kbd> to <kbd>7</kbd>, that is, <span>equal to the length of the array</span>; these two indexes represent the lower and upper index locations of the array respectively. Because arrays are zero-based, the eighth element of the array will be found at index location 7. We'll set a <kbd>while</kbd> loop to execute for as long as the value of <kbd>uindex</kbd> is greater than or equal to the value of <kbd>lindex</kbd>.</p>
<p>To compare the search value with the middle value of the array, we will first compute the middle value; sum the values of <kbd>lindex</kbd> and <kbd>uindex</kbd>, and divide the result by 2. The output of (0+7)/2 is 3. Then, compare the value of the <kbd>numb</kbd> variable, that is, 45, with the value at <span>location</span> <kbd>arr[3]</kbd>, derived from your computation, that is, with 34 (see <em>Figure 9.2</em>):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c26702a9-b1d5-4cc9-94f7-1207bf5ebbfc.png" style="width:18.75em;height:14.25em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.2</div>
<p><span>Because 45 is greater than 34, we will have to continue our search in the lower half of the array. However, since our list is sorted in ascending order, we can now concentrate our search in the lower half of the array.</span></p>
<p>Now, the value of <kbd>lindex</kbd> is set equal to <kbd>mid+1</kbd>, that is, 4. Again, execute the <kbd>while</kbd> loop because <kbd>uindex</kbd>, that is, 7, is still greater than <kbd>lindex</kbd>. We will now compute the middle value of the upper half of the array: (4+7)/2 = 5. The search value 45 will be compared with <kbd>arr[5]</kbd>, that is, with 80. Because 45 is smaller than 80, we will continue our search in the lower half of the array, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a65e061e-bb41-48f0-8581-08c737362a8f.png" style="width:24.58em;height:12.00em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.3</div>
<p class="mce-root"/>
<p>Next, the value of <kbd>uindex</kbd> is set equal to <kbd>mid-1</kbd>, that is, equal to 4. And the value of <kbd>lindex</kbd> from our previous computation is also 4. We will again execute the <kbd>while</kbd> loop because 4=4. The middle value of the array will be computed as (4+4)/2, that is, the search value 45 will be compared with <kbd>arr[4]</kbd>, which is 60.</p>
<p>Because 45 &lt; 60, the value of <kbd>uindex</kbd> will be set to <kbd>mid-1</kbd>, that is, equal to 3. The <kbd>while</kbd> loop will exit because our <kbd>uindex (3)</kbd> is not greater than our <kbd>lindex (4)</kbd> any more. The <kbd>binary_search</kbd> function will return the <kbd>nfound</kbd> variable to the <kbd>main</kbd> function. The <kbd>nfound</kbd> variable contains some garbage value, which is then assigned to the <kbd>found</kbd> variable in the <kbd>main</kbd> function. In the <kbd>main</kbd> function, the values in the <kbd>found</kbd> and <kbd>numb</kbd> variables are compared. Because the garbage value is not equal to the value in the <kbd>numb</kbd> variable, 45, a message, <kbd>Value 45 is not found in the list</kbd> will be displayed on the screen.</p>
<p>Suppose you want to search for the value 15 now. The values of <kbd>lindex</kbd> and <kbd>uindex</kbd> will <span>again </span>be 0 and 7 initially. The <kbd>while</kbd> loop will execute and the middle value will be computed as <span>(0+7)/2</span>, which will be 3. The value of 15 will be compared with the corresponding location, <kbd>arr[3]</kbd>, that is, with 34. The value of 15 is smaller than 34, so the upper half of the array will be considered to continue the binary search, as shown in the following figure:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d08a84d2-5560-45b2-aa60-11594e9e73cc.png" style="width:19.17em;height:14.08em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.4</div>
<p>The value of the <kbd>uindex</kbd> variable is set equal to <kbd>mid-1</kbd>, that is, 2. Because <kbd>uindex</kbd> is still greater than <kbd>lindex</kbd>, that is, 2 &gt;=0, the <kbd>while</kbd> loop will execute again. Again, the middle value is computed as (0+2)/2, which is 1. This means that 15 is compared with the <kbd>arr[1]</kbd> element.</p>
<p>The value at the <kbd>arr[1]</kbd> location is 15 only; hence, the <kbd>nfound</kbd> variable is set to 15 in the <kbd>binary_search</kbd> function and the <kbd>nfound</kbd> variable is returned to the <kbd>main</kbd> function. In the <kbd>main</kbd> function, the value of the <kbd>nfound</kbd> variable will be assigned to the <kbd>found</kbd> variable. Because the value in the <kbd>found</kbd> and <kbd>numb</kbd> variables are the same, the message <kbd>Value 15 is found in the list</kbd> will be displayed onscreen.</p>
<p>The program is compiled using GCC, as shown in the following screenshot. Because no error appears on compilation, that means the <kbd>binarysearch.c</kbd> <span>program </span>has successfully been compiled into an EXE file, that is, to the <kbd>binarysearch.exe</kbd> file. On executing the executable file, if we try searching for a value that is not found in the list, we get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6226a1e8-49aa-46e0-8ecb-5517477411cb.png" style="width:29.58em;height:21.25em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.5</div>
<p class="mce-root"/>
<p>If we run the executable file again and enter a number that exists in the array, we may get the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1e5e64bd-0eb0-425b-b4b8-31ef42248e3c.png" style="width:18.83em;height:16.58em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.6</div>
<p>Voilà! We've successfully used binary search to locate an item in a sorted array. Now let's move on to the next recipe!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Arranging numbers in ascending order using bubble sort</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will learn how to arrange some integers in ascending order using the bubble sort technique. In this technique, the first element is compared with the second, the second is compared with the third, the third with the fourth, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Consider an array, <kbd>arr</kbd>, of size <kbd>len</kbd> elements. We want to arrange elements of the <kbd>arr</kbd> array in ascending order. Here are the steps to do so:</p>
<ol>
<li>Initialize a variable, say <kbd>i</kbd>, to <kbd>len -2</kbd>.</li>
<li>Follow and repeat <em>steps 3</em> through <em>5</em> as long as <kbd>i &gt;=1</kbd>.  The value of <kbd>i</kbd> will be decremented by 1 after every iteration, that is, <kbd>i=len-2</kbd>, <kbd>len-3</kbd>, <kbd>len-4</kbd>, <kbd>....1</kbd>.</li>
</ol>
<ol start="3">
<li>Initialize another variable, <kbd>j</kbd>, to <kbd>0</kbd>.</li>
<li>Repeat <em>step 5</em> to <kbd>j&lt;=i</kbd>. The value of <kbd>j</kbd> will increase after every iteration, that is,  <kbd>j=1</kbd>, <kbd>2... i</kbd>.</li>
<li>If <kbd>arr[j] &gt; arr[j+1]</kbd>, then interchange the two values.</li>
<li>Exit the search.</li>
</ol>
<p>The program for sorting elements of an integer array using the bubble sort technique is as follows:</p>
<pre class="mce-root">//<strong>bubblesort.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/><br/>#define max 20<br/>int main() {<br/>  int arr[max], temp, len, i, j;<br/>  printf("How many values are there? ");<br/>  scanf("%d", &amp; len);<br/>  printf("Enter %d values to sort\n", len);<br/>  for (i = 0; i &lt; len; i++)<br/>    scanf("%d", &amp; arr[i]);<br/>  for (i = len - 2; i &gt;= 1; i--) {<br/>    for (j = 0; j &lt;= i; j++) {<br/>      if (arr[j] &gt; arr[j + 1]) {<br/>        temp = arr[j];<br/>        arr[j] = arr[j + 1];<br/>        arr[j + 1] = temp;<br/>      }<br/>    }<br/>  }<br/>  printf("The sorted array is:\n");<br/>  for (i = 0; i &lt; len; i++)<br/>    printf("%d\n", arr[i]);<br/>  return 0;<br/>}</pre>
<p class="mce-root"><span>Now, let's go behind the scenes to understand the code better.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We will start by defining a macro, <kbd>max</kbd>, of value 20. You can always increase the value of <kbd>max</kbd> as required. Then, we will define an array, <kbd>arr</kbd>, of size <kbd>max</kbd>, that is, of size 20. You will be asked how many values you want to sort. Assuming that you want to sort seven elements, the value you entered will be assigned to the <kbd>len</kbd> <span>variable</span>. You will be prompted to enter the values to be sorted, which will then be assigned to the <kbd>arr</kbd> <span>array.</span> The seven values to be sorted in the <kbd>arr</kbd> <span>array </span>might appear as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/de0e68f8-499b-445a-8ca8-b1b614368e38.png" style="width:6.75em;height:12.25em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.7</div>
<p>Now, we will run two nested <kbd>for</kbd> loops: the outer <kbd>for</kbd> loop will execute from <kbd>len-2</kbd>, that is, from value 5 to 1 in descending order, and the inner <kbd>for</kbd> loop will execute for the value from 0 to <kbd>i</kbd>. That means, in the first iteration, the value of <kbd>i</kbd> will be 5, so the inner <kbd>for</kbd> <kbd>j</kbd> loop will execute from 0 to 5. Within the inner <kbd>for</kbd> loop, the first value of <kbd>arr</kbd> will be compared with the second, the second value with the third, and so on:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/09a44130-05b3-4c2d-90ea-30bc3bd454ce.png" style="width:18.50em;height:13.00em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.8</div>
<p>The tendency is to keep the value at the lower index smaller than the value at the higher index. If the first value is larger than the second, they will change places; and if the first value is already smaller than the second value, then the next two values in line, that is, the second and third values, are taken for consideration. Similarly, if the second value is larger than the third, they too will swap places; if not, then the next set of values, that is, the third and fourth values, will be compared. The process will continue until the last pair, that is, the sixth and seventh values in our case, are compared.</p>
<p>The entire first iteration of comparisons is illustrated as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3e5c9d5f-d2a1-4148-9778-e05077f1b7bc.png" style="width:46.17em;height:25.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Figure 9.9</span></div>
<p>You can see that after the first iteration, the largest value has bubbled down to the bottom of the list. Now, the value of the outer loop, that is, the value of <kbd>i</kbd> will be decremented by 1, making it 4. Consequently, the value of <kbd>j</kbd> in the inner loop will make the <kbd>for</kbd> loop run from value 0 to 4. It also means that now, the first value will be compared with the second, the second with the third, and so on. Finally, the fifth value (that is, the value at index location 4) will be compared with the sixth value (that is, the value at index location 5). The last element at index location 6 will not be compared as it is already at its correct destination:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/21954200-2d6c-445d-8fc6-b91aa6f851d5.png" style="width:46.58em;height:25.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.10</div>
<p>Again, after the second iteration, the value of the outer loop will be decremented by 1, making it 3. As a result, the value of <kbd>j</kbd> in the inner loop will make the <kbd>for</kbd> loop run from value 0 to 3. In the last, the fourth value, that is, the value at index location 3, will be compared with the fifth value. The last two elements at index location 5 and 6 are not compared as both are at their correct destination:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/643fb9eb-beb2-4646-b5e1-22768ada794d.png" style="width:45.92em;height:26.50em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.11</div>
<p>After the third iteration, the value of <kbd>i</kbd> will be decremented by 1, making it 2. Hence, the value of <kbd>j</kbd> will make the <kbd>for</kbd> loop run from value 0 to 2. The last three elements at index location 4, 5, and 6 are not compared as they already are at their correct destination:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d0b5615f-1fe5-42b7-9beb-bdadd83d7853.png" style="width:26.17em;height:15.00em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.12</div>
<p>After the fourth iteration, the value of <kbd>i</kbd> will be decremented again, making it 1. So, the value of <kbd>j</kbd> in the inner loop will make the <kbd>for</kbd> loop run from value 0 to 1. The last four elements are not compared as they already are at their final destination:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/14eae109-5066-420b-8a9c-b6bc6cb4f7f7.png" style="width:20.75em;height:11.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.13</div>
<p>So, after five iterations, we have successfully arranged the numbers in our array in ascending order. The program is compiled using GCC with the following statement:</p>
<pre><strong>gcc bubblesort.c -o bubblesort</strong></pre>
<p>Because no error appears on compilation, that means the <kbd>bubblesort.c</kbd> <span>program </span>has successfully been compiled into the <kbd>bubblesort.exe</kbd> file. On executing this file, it will ask us to specify how many numbers there are to be sorted.  Then the program will prompt us to enter the numbers to be sorted. After entering the numbers, they will appear sorted in ascending order, as shown in the following <span>screenshot</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c0402903-a353-43ca-b18a-0bfc1feae139.png" style="width:19.42em;height:19.58em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.14</div>
<p class="mce-root"/>
<p class="mce-root"><span>Voilà! We've successfully used the bubble sort technique to arrange numbers in ascending order.</span></p>
<div>
<p>Now let's move on to the next recipe!</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Arranging numbers in ascending order using insertion sort</h1>
                </header>
            
            <article>
                
<p>In this sorting technique, a region of the array, which might be the lower or upper part, is considered as sorted. An element outside the sorted region is picked up and its appropriate place is searched for in the sorted region (so that even after the insertion of this element, the region remains sorted) and the element is inserted there, hence the name insertion sort.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will create a function for insertion sort called <kbd>InsertionSort</kbd>, which we will invoke as follows, where <kbd>arr</kbd> is the array to be sorted and consists of <kbd>n</kbd> number of elements.</p>
<p>Here are the steps that are followed in the <kbd>InsertionSort</kbd> method:</p>
<ol>
<li>Initialize a variable, say <kbd>i</kbd>, to <kbd>1</kbd>.</li>
<li>Repeat steps 2 to 5 <kbd>n-1</kbd> times, that is, while <kbd>i &gt;= n-1</kbd>. The value of <kbd>i</kbd> is incremented by 1 after every iteration, <kbd>i=1,2,3 .... n-1</kbd>.</li>
<li>Initialize a <span>variable, </span><kbd>j</kbd>, to the value of <kbd>i</kbd>.</li>
<li>Repeat the following step 5  for <kbd>j=i</kbd> to <kbd>j &gt;=0</kbd>. The value of <kbd>j</kbd> is decremented by 1 after every iteration, that is, <kbd>j=i, i-1, i-2, ....0</kbd>.</li>
<li>If <kbd>arr[j] &lt;arr[j-1]</kbd>, then interchange the values.</li>
</ol>
<p>The program for sorting the elements of an integer array using the insertion sort technique is as follows:</p>
<pre>//<strong>insertionsort.c</strong><br/><br/>#include &lt;stdio.h&gt;<br/><br/>#define max 20<br/><br/>int main() {<br/>  int arr[max], i, j, temp, len;<br/>  printf("How many numbers are there ? ");<br/>  scanf("%d", &amp; len);<br/>  printf("Enter %d values to sort\n", len);<br/>  for (i = 0; i &lt; len; i++)<br/>    scanf("%d", &amp; arr[i]);<br/>  for (i = 1; i &lt; len; i++) {<br/>    for (j = i; j &gt; 0; j--) {<br/>      if (arr[j] &lt; arr[j - 1]) {<br/>        temp = arr[j];<br/>        arr[j] = arr[j - 1];<br/>        arr[j - 1] = temp;<br/>      }<br/>    }<br/>  }<br/>  printf("\nThe ascending order of the values entered is:\n");<br/>  for (i = 0; i &lt; len; i++)<br/>    printf("%d\n", arr[i]);<br/>  return 0;<br/>}</pre>
<p><span>Now, let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's assume that the numbers that we need to sort are not greater than 20; so we will define a macro of size <kbd>20</kbd>. You can always assign any value to this macro. Next, we will define an integer array, <kbd>arr</kbd>, of size <kbd>max</kbd>. You will be prompted to enter how many numbers you wanted to sort. Let's say we want to sort eight values; so the value <kbd>8</kbd> entered by us will be assigned to a variable, <kbd>len</kbd>. Thereafter, you will be asked to enter the <span>eight</span> values that need to be sorted. So, let's say we entered the following values, which were assigned to the <kbd>arr</kbd> <span>array:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a86bec8f-48b0-479d-96f1-05df34a7301c.png" style="width:5.92em;height:11.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.15</div>
<p>In this sorting method, we will take the help of a nested loop, where the outer loop, <kbd>i</kbd>, runs from 1 to 7 and the inner loop, <kbd>j</kbd>, runs from the value beginning from <kbd>i</kbd> to its value is more than 0. So, in the first iteration of the nested loop, the inner loop will execute only once where the value of i will be 1. The value at the <kbd>arr[1]</kbd> <span>index location </span>is compared with that at <kbd>arr[0]</kbd>. The tendency is to keep the lower value at the top, so if the value at <kbd>arr[1]</kbd> is greater than that at <kbd>arr[0]</kbd>, the place of the two values will be interchanged. Because 15 is greater than 9 (on the left side of <em>Figure 9.16</em>), the values in the two index locations will be interchanged <span>(on the right side of <em>Figure 9.16</em>) </span>as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d5191979-73c5-4453-9559-f762fec22845.png" style="width:25.50em;height:13.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.16</div>
<p>After the first iteration, the value of <kbd>i</kbd> will be incremented to 2 and the inner loop, <kbd>j</kbd>, will run from the value of 2 to 1, that is, the inner loop will execute twice: once with the value of <kbd>j</kbd> equal to 2 and then when the value of <kbd>j</kbd> is decremented to 1. Within the inner loop, the value at <kbd>arr[2]</kbd> will be compared with that at <kbd>arr[1]</kbd>. In addition, the value at <kbd>arr[1]</kbd> will be compared with that at <kbd>arr[0]</kbd>. If <kbd>arr[2] &lt; arr[1]</kbd>, then interchanging of the values will take place. Similarly, if <kbd>arr[1] &lt; arr[0]</kbd>, interchanging of their values will take place.</p>
<p>The value at <kbd>arr[2]</kbd> that is 10 is less than the value at <kbd>arr[1]</kbd>, that is, 15; so these values will interchange places (see <em>Figure 9.17</em>). After interchanging the values, we find that the value at <kbd>arr[1]</kbd> is greater than the value at <kbd>arr[0]</kbd>. So, no interchanging will take place now. <em>Figure 9.17</em> shows the procedure of the second iteration:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e70e5208-1fa6-4987-a754-2bfddf215e47.png" style="width:26.00em;height:11.50em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.17</div>
<p>After the second iteration, the value of <kbd>i</kbd> will be incremented to 3 and the value of <kbd>j</kbd> will run from the values of 3 to 1. Hence, the <span>interchanging of values will take place if the following conditions are met:</span></p>
<ul>
<li>If <kbd>arr[3] &lt; arr[2]</kbd></li>
<li>If <kbd>arr[2] &lt; arr[1]</kbd> </li>
<li>If <kbd>arr[1] &lt; arr[0]</kbd></li>
</ul>
<p>You can see in <em>Figure 9.18(a)</em> that <kbd>arr[3]</kbd>, that is, 5, is smaller than <kbd>arr[2]</kbd>, that is, 15, so their values will be interchanged. Similarly, the values at <kbd>arr[2]</kbd> and <kbd>arr[1]</kbd>, and then <span><kbd>arr[1]</kbd> and <kbd>arr[0]</kbd>, </span>will also be interchanged (see <em>Figure 9.18(b)</em> and <em>(c)</em>, respectively). <em>Figure 9.18(d)</em> shows the array after all the interchanges have been performed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e2aa3af3-9f83-454d-9b44-53603ff62a2b.png" style="width:44.33em;height:11.92em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.18</div>
<p>After the third iteration, the value of <kbd>i</kbd> will be incremented to 4 and the value of <kbd>j</kbd> will run from the values of 4 to 1. So <span>interchanging of values will take place if the following conditions are met</span>:</p>
<ul>
<li>If <kbd>arr[4] &lt; arr[3]</kbd></li>
<li>If <kbd>arr[3] &lt; arr[2]</kbd></li>
<li>If <kbd>arr[2] &lt; arr[1]</kbd></li>
<li>If <kbd>arr[1] &lt; arr[0]</kbd></li>
</ul>
<p>You can see in <em>Figure 9.19</em> that the main tendency of all these comparisons is to bring the lower values above the larger values in the array:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5c103079-3748-40b2-9037-2aa67993adae.png" style="width:43.08em;height:28.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.19</div>
<p>The same procedure will be followed for the rest of the elements in the array.</p>
<p>The program is compiled using GCC with the following statement:</p>
<pre><strong>gcc insertionsort.c -o insertionsort</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Because no error appears on compilation, that means the <kbd>insertionsort.c</kbd> <span>program </span>has successfully been compiled into the <kbd>insertionsort.exe</kbd> file. On execution, it will ask you to specify how many numbers have to be sorted. Following this, the program will prompt us to enter the numbers to be sorted. After entering the numbers, they will appear sorted in ascending order, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/69789e87-788c-480c-968b-70fa81397958.png" style="width:29.50em;height:29.17em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.20</div>
<p class="mce-root"><span>Voilà! We've successfully used insertion sort to arrange numbers in ascending order.</span></p>
<div>
<div>
<p>Now let's move on to the next recipe!</p>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Arranging numbers in ascending order using quick sort</h1>
                </header>
            
            <article>
                
<p>Quick sort is a divide-and-conquer algorithm. It divides an array on the basis of a pivot, where the pivot is an element in the array, in order that all the elements smaller than the pivot are placed before the pivot and all the larger ones are placed after it.</p>
<p>So, at the location of the pivot, the array is divided into two subarrays. The process of finding the pivot is repeated on both the arrays. The two arrays are further subdivided on the basis of the pivot.</p>
<p>Hence, quick sort is a recursive procedure and the procedure of dividing the arrays into subarrays continues recursively until the subarray has only one element.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The quick sort process comprises the following important tasks:</p>
<ul>
<li>Finding the pivot </li>
<li>Splitting the array at the location of the pivot</li>
</ul>
<p> We will be using two methods: <span><kbd>QuickSort</kbd> and <kbd>FindingPivot</kbd>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Quick sort</h1>
                </header>
            
            <article>
                
<p>This method takes an array or subarray into consideration. It invokes the method to find the pivot of the array or subarray and splits the array or subarray on the basis of the pivot. Here is its syntax:</p>
<pre>Quick Sort (arr,n)</pre>
<p>Here, <kbd>arr</kbd> is the array consisting of <kbd>n</kbd> elements.</p>
<p>This is how we use this method:</p>
<ol>
<li>Let <kbd>l=1</kbd> and <kbd>u=n</kbd>, where <kbd>l</kbd> and <kbd>u</kbd> represent the lower and upper index location, respectively, of the array.</li>
<li>Push <kbd>l</kbd> into <kbd>stack1</kbd>.</li>
<li>Push <kbd>u</kbd> into <kbd>stack2</kbd>.</li>
</ol>
<ol start="4">
<li>While <kbd>stack1</kbd> or <kbd>stack2</kbd> is not empty, repeat steps 5 through 10.</li>
<li>Pop the lower index location of the array from <kbd>stack1</kbd> into variable <kbd>s</kbd>, that is, <kbd>s</kbd> becomes the lower index location of the array to be sorted.</li>
<li>Pop the upper index location from <kbd>stack2</kbd> into the variable <kbd>e</kbd>, that is, the <kbd>e</kbd> variable will get the upper index location of the array.</li>
<li>Find out the pivot by invoking the <kbd>FindingPivot</kbd> method as follows:</li>
</ol>
<pre style="padding-left: 60px">pivot=FindingPivot(arr,s,e)</pre>
<p style="padding-left: 60px">Recall that a pivot point is an index location in the array where the elements smaller than the pivot are before it and elements larger than the pivot are after it. The array is split at the pivot point and the quick sort method is recursively applied on the two halves individually.</p>
<ol start="8">
<li>Once the pivot is known, divide the array into two halves. One array will have values from <kbd>s</kbd> (the lower index location) to <kbd>pivot-1</kbd>, and another array with the elements ranges from <kbd>pivot+1</kbd> to <kbd>e</kbd> (the upper index location).</li>
<li>For the first half of the array, push <kbd>s</kbd> into <kbd>stack1</kbd> and <kbd>pivot-1</kbd> into <kbd>stack2</kbd>.</li>
<li>For the second half of the array, push <kbd>pivot+1</kbd> into <kbd>stack1</kbd> and <kbd>e</kbd> into <kbd>stack2</kbd>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">FindingPivot</h1>
                </header>
            
            <article>
                
<p>This method finds the pivot of the array or subarray. <span>Here is its syntax:</span></p>
<pre>FindingPivot (arr,start,end)</pre>
<p>Here, <kbd>arr</kbd> represents the array of <kbd>n</kbd> elements, <kbd>start</kbd> represents the starting index location of the array, and <kbd>end</kbd> represents the ending index location of the array.</p>
<p>This is how we use this method:</p>
<ol>
<li>Repeat <em>steps 2</em> through <em>8</em> of the <kbd>QuickSort</kbd> method.</li>
<li>Store the value of the <kbd>start</kbd> <span>variable </span>in another variable, say, <kbd>lower</kbd>.</li>
<li>Start from the right index location and move to the left. Initially, the first element is the pivot. The tendency is to keep the elements larger than the pivot on the right-hand side <span>of the pivot </span><span>and the elements smaller than the pivot on the left-hand side.</span></li>
</ol>
<ol start="4">
<li>If <kbd>lower=end</kbd>, that means, we found the pivot. The pivot is equal to the value of lower. Return <kbd>lower</kbd> as the location of the pivot element.</li>
<li>If <kbd>arr[lower] &gt; arr[end]</kbd>, then interchange the values' places.<span> Now, move from left to right comparing each value with the pivot, and move up until we get the value lower than the value of pivot.</span></li>
<li>While <kbd>arr[start] &lt;= arr[lower]</kbd> and <kbd>lower != start</kbd>, repeat:</li>
</ol>
<pre style="padding-left: 60px">start=start+1</pre>
<ol start="7">
<li>If <kbd>lower=start</kbd> then pivot is lower. Return <kbd>lower</kbd> as the location of the pivot element.</li>
<li>If <kbd>arr[start] &gt; arr[lower]</kbd>, then interchange the values' places.</li>
</ol>
<p>The program for sorting elements of an integer array using the quick sort technique is as follows:</p>
<pre>//<strong>quick sort.c</strong><br/><br/># include&lt;stdio.h&gt;<br/># define stacksize 10<br/>#define arrsize 20<br/>int top1 = -1, top2 = -1;<br/>int stack1[stacksize];<br/>int stack2[stacksize];<br/>int arr[arrsize];<br/><br/>int quick(int, int);<br/>void pushstk1(int);<br/>void pushstk2(int);<br/>int popstk1();<br/>int popstk2();<br/><br/>int main() {<br/>  int sindex, eindex, lindex, uindex, k, pivot, i, len;<br/>  printf("How many numerical to sort? ");<br/>  scanf("%d", &amp; len);<br/>  printf("Enter %d numerical:\n", len);<br/>  for (i = 0; i &lt;= len - 1; i++)<br/>    scanf("%d", &amp; arr[i]);<br/>  lindex = 0;<br/>  uindex = len - 1;<br/>  pushstk1(lindex);<br/>  pushstk2(uindex);<br/>  while (top1 != -1) {<br/>    sindex = popstk1();<br/>    eindex = popstk2();<br/>    pivot = quick(sindex, eindex);<br/>    if (sindex &lt; pivot - 1) {<br/>      pushstk1(sindex);<br/>      pushstk2(pivot - 1);<br/>    }<br/>    if (pivot + 1 &lt; eindex) {<br/>      pushstk1(pivot + 1);<br/>      pushstk2(eindex);<br/>    }<br/>  }<br/>  printf("\nAscending order using Quick Sort is:\n");<br/>  for (i = 0; i &lt;= len - 1; i++)<br/>    printf("%d\n", arr[i]);<br/>  return 0;<br/>}<br/><br/>int quick(int si, int ei) {<br/>  int li, temp;<br/>  li = si;<br/>  while (1) {<br/>    while (arr[ei] &gt;= arr[li] &amp;&amp; li != ei)<br/>      ei--;<br/>    if (li == ei) return (li);<br/>    if (arr[li] &gt; arr[ei]) {<br/>      temp = arr[li];<br/>      arr[li] = arr[ei];<br/>      arr[ei] = temp;<br/>      li = ei;<br/>    }<br/>    while (arr[si] &lt;= arr[li] &amp;&amp; li != si)<br/>      si++;<br/>    if (li == si) return (li);<br/>    if (arr[si] &gt; arr[li]) {<br/>      temp = arr[si];<br/>      arr[si] = arr[li];<br/>      arr[li] = temp;<br/>      li = si;<br/>    }<br/>  }<br/>  return 0;<br/>}<br/>void pushstk1(int s) {<br/>  top1++;<br/>  stack1[top1] = s;<br/>}<br/>void pushstk2(int e) {<br/>  top2++;<br/>  stack2[top2] = e;<br/>}<br/>int popstk1() {<br/>  return (stack1[top1--]);<br/>}<br/>int popstk2() {<br/>  return (stack2[top2--]);<br/>}</pre>
<p class="mce-root"><span>Now, let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You will be asked to specify how many numbers you require to be sorted. Suppose we want to sort 8 numbers; the value 8 entered by the user will be assigned to the <kbd>len</kbd> <span>variable.</span> A <kbd>for</kbd> loop is executed enabling us to enter the number to be sorted. The values we enter will be assigned to the <kbd>arr</kbd> <span>array </span>as shown in <em>Figure 9.21</em>.</p>
<p>Two variables, <kbd>lindex</kbd> and <kbd>uindex</kbd>, are initialized to represent the desired first and last index of the array, that is 0 and 7, respectively. The <kbd>lindex</kbd> and <kbd>uindex</kbd> locations are supposed to keep the smallest and largest values in the array. The values of <kbd>lindex</kbd> and <kbd>uindex</kbd>, that is, 0 and 7, will be pushed to the stack. In the <kbd>pushstk1</kbd> function, the value of the top index, whose default value is -1, is incremented to 0 and the value of <kbd>lindex</kbd> is assigned to the <kbd>stack1</kbd> <span>array </span>at the <kbd>[0]</kbd> index location. Similarly, in the  <kbd>pushstk2</kbd> function, the value of the <kbd>top2</kbd> index is also incremented to 0, and the value of <kbd>uindex</kbd> is assigned to the <kbd>stack2</kbd> <span>array </span>at the <kbd>[0]</kbd> location.</p>
<p>A while loop is set to execute for as long as the value of <kbd>top1</kbd> is not equal to 1. That means, until <kbd>stack1</kbd> is empty, the program will keep executing. Within the while loop, the values pushed in <kbd>stack1</kbd> and <kbd>stack2</kbd> are popped and assigned to the two variables of <kbd>sindex</kbd> and <kbd>eindex</kbd>, respectively. These variables represent the starting and ending index locations of the array or the part of the array that we want to sort using <kbd>quick sort</kbd>.</p>
<p><kbd>stack1</kbd> and <kbd>stack2</kbd> contain the values of 0 and 7, respectively, which are popped and assigned to <kbd>sindex</kbd> and <kbd>eindex</kbd>, respectively. The quick function is invoked and the values in <kbd>sindex</kbd> and <kbd>eindex</kbd> are passed to an argument. In the quick functions, the values of <kbd>sindex</kbd> and <kbd>eindex</kbd> arguments are assigned to the two parameters of <kbd>si</kbd> and <kbd>ei</kbd>, respectively.</p>
<p>Within the quick function, the value of <kbd>si</kbd>, that is 0, is assigned to another variable, <kbd>li</kbd>. A while loop is executed in an infinite loop. Within the while loop, another while loop is set to execute that will make <kbd>ei</kbd> move toward the left, that is, it will make the value of <kbd>ei</kbd> decrement until the element at <span>the </span><kbd>arr[ei]</kbd> location is greater than the <kbd>arr[li]</kbd> location:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e627ced9-1f08-4264-853c-2d5b850186ab.png" style="width:21.75em;height:7.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.21</div>
<p>Because <kbd>arr[ei] &lt; arr[si]</kbd>, interchanging of their values will take place (see <em>Figure 9.22(a)</em>). After interchanging the values at <kbd>arr[ei]</kbd> and <kbd>arr[si]</kbd>, the <kbd>arr</kbd> <span>array </span>will appear as shown in <em>Figure 9.22(b)</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1088c771-3bba-4f76-aea6-20574c843f42.png" style="width:21.83em;height:19.58em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.22</div>
<p>After interchanging of values, the index location number of <kbd>ei</kbd><span>, that is 7,</span> will be assigned to <kbd>li</kbd>. Another while loop is set to execute while <kbd>arr[si]</kbd> is smaller than <kbd>arr[li]</kbd>, where <kbd>li</kbd> represents the <kbd>ei</kbd> index currently; and within the <kbd>while</kbd> loop, the location of the <kbd>si</kbd> index pointer is incremented.  That is, the <kbd>si</kbd> index pointer is moved right to <kbd>arr[si] &lt; arr[li]</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/89babd95-8687-4e6c-a655-51b466712c3a.png" style="width:25.25em;height:8.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.23</div>
<p>Now, the following things will happen:</p>
<ul>
<li>Because <kbd>arr[si] &lt; arr[ei]</kbd> (<span>that is, 4 &lt;</span> 6), <kbd>si</kbd> will move right by one location to <kbd>arr[1]</kbd></li>
<li>Because <kbd>arr[si] &lt; arr[ei]</kbd> (<span>that is, now 3 &lt;</span> 6), <kbd>si</kbd> <span>will again move right by one location to</span> <kbd>arr[2]</kbd></li>
<li>Because <kbd>arr[si] &lt; arr[ei]</kbd> (<span>that is, now 0 &lt;</span> 6), <kbd>si</kbd> will <span>again move right by one location to <kbd>arr[3]</kbd></span></li>
<li>Because <kbd>arr[si]  &lt; arr[ei]</kbd> (<span>that is, now 2 &lt;</span> 6), <kbd>si</kbd> <span>will </span><span>again move right by one location to</span> <span><kbd>arr[</kbd></span><kbd>4]</kbd></li>
<li>Because <kbd>arr[si]  &gt; arr[ei]</kbd> (<span>that is, now 7 &gt; </span>6), interchanging of their values will take place (see <em>Figure 9.24</em>):</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e80eeb8c-8814-4b76-a4b2-7d9eb2db7bd4.png" style="width:24.58em;height:20.50em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.24</div>
<p>After interchanging of values at <kbd>arr[ei]</kbd> and <kbd>arr[si]</kbd>, the location number of <kbd>arr[si]</kbd>, that is, 4, will be assigned to <kbd>li</kbd>. The process is repeated; that is, again a while loop is set to execute while <kbd>arr[ei] &gt; arr[si]</kbd>. Within the while loop, the location of <kbd>ei</kbd> is decremented, or it moves to the left:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0d9f4606-4863-48dd-a7fa-f6c6df23254a.png" style="width:25.92em;height:9.25em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.25</div>
<p>While comparing <kbd>arr[ei]</kbd> and <kbd>arr[si]</kbd>, we will find that <kbd>arr[ei] &gt; arr[si]</kbd> (7 &gt; 6), so <kbd>ei</kbd> will be decremented to value 6 (see <em>Figure 9.26(a)</em>). Again, because <kbd>arr[ei] &lt; arr[si]</kbd> (1 &lt; 6), interchanging of values of these index locations will take place (see <em>Figure 9.26(b)</em>). The location number of <kbd>ei</kbd>, 6 now, will be assigned to <span>variable</span> <kbd>li</kbd>.</p>
<p>Another while loop is set to execute while <kbd>arr[si] &lt; arr[ei]</kbd> (remember the location number of ei is assigned to li). The following things will happen in this while loop:</p>
<ul>
<li>Because <kbd>arr[si] &lt; arr[ei]</kbd> (that is, 1 &lt; 6), <kbd>si</kbd> will move right to <kbd>arr[5]</kbd></li>
<li>Because still <kbd>arr[si] &lt; arr[ei]</kbd> (that is, 5 &lt; 6), <span><kbd>si</kbd> will move right to</span> <kbd>arr[6]</kbd></li>
<li>Because now the location of <kbd>ei</kbd> and <kbd>si</kbd> are the same, the quick function will terminate returning the number 6 to the <kbd>main</kbd> function (see <em>Figure 9.26(c)</em>). So, the number 6 will become the pivot of the <kbd>arr</kbd> array.</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7e20269a-2da5-4c6a-bc04-00f9ec8a9f96.png" style="width:22.67em;height:26.33em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.26</div>
<p>Two <kbd>if</kbd> statements are executed and the array is split into two parts: the first part ranges from <kbd>arr[0]</kbd> to <kbd>arr[5]</kbd> and the other part from <kbd>arr[7]</kbd> to <kbd>arr[7]</kbd>, that is, of a single element. The first and last index values of the two parts of the array are pushed to the stack.</p>
<p>The first and last index locations of the second part of the array, that is, 7, will be pushed to both <kbd>stack1</kbd> and <kbd>stack2</kbd>. The first and last index locations of the first part of array, that is, 0 and 5, will also be pushed to <kbd>stack1</kbd> and <kbd>stack2</kbd>, respectively (see <em>Figure 9.27</em>).</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e8953bcd-c548-4235-8612-40cee58289f8.png" style="width:19.83em;height:9.67em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.27</div>
<p>The complete quick sort technique is applied on both halves of the array. Again, the two halves will be partitioned into two more parts and again the quick sort technique is applied on those two parts, and so on.</p>
<p>The outer while loop repeats and the <kbd>popstk1()</kbd> and <kbd>popstk2()</kbd> functions will be invoked to pop off the values in the <kbd>stack1</kbd> and <kbd>stack2</kbd> arrays. The values of the <kbd>top1</kbd> and <kbd>top2</kbd> indices are 1, so the values at the <kbd>stack1[1]</kbd> and <kbd>stack2[1]</kbd> index locations are picked up and assigned to the two variables, <kbd>sindex</kbd> and <kbd>eindex</kbd>, respectively. Again, the <kbd>quick()</kbd> function is invoked and the two variables, <kbd>sindex</kbd> and <kbd>eindex</kbd>, are passed to it. In the quick function, the values of the <kbd>sindex</kbd> and <kbd>eindex</kbd> arguments are assigned to the <kbd>si</kbd> and <kbd>ei</kbd> parameters respectively</p>
<p>Within the <kbd>quick()</kbd> function, the value of the <kbd>si</kbd> variable, that is, 0, is assigned to another variable, <kbd>li</kbd>. A while loop is executed in an infinite loop. Within the while loop, another while loop is set to execute that will make the <kbd>ei</kbd> index location to move toward the left, that is, it will make the value of the <kbd>ei</kbd> index variable decrement for the time the element at the <kbd>arr[ei]</kbd> location is greater than the <kbd>arr[si]</kbd> location (see <em>Figure 9.28(a)</em>). Because <kbd>arr[ei] &gt; arr[si]</kbd>, the value of the <kbd>ei</kbd> variable will be decremented to 4 (see <em>Figure 9.28(b)</em>). Now, we find that <kbd>arr[ei]</kbd>, that is, 1 is less than <kbd>arr[si]</kbd>, that is, 4, so interchanging of their values will take place. After interchanging the values at that <kbd>arr[ei]</kbd> and <kbd>arr[si]</kbd> index locations, the <kbd>arr</kbd> <span>array </span>will appear as shown in <em>Figure 9.28(c)</em>.</p>
<p>After interchanging the values, the value of the <kbd>ei</kbd> variable is assigned to the <kbd>li</kbd> variable, that is, 4, is assigned to the <kbd>li</kbd> variable. Another while loop is set to execute while the <kbd>arr[si]</kbd> element is smaller than <kbd>arr[li]</kbd>, where <kbd>li</kbd> represents the <kbd>si</kbd> index currently; and within the while loop, the value of the <kbd>si</kbd> index pointer is incremented. The following things will happen:</p>
<ul>
<li>Because <kbd>arr[si]</kbd>, that is, 1, <span>is less than</span> <kbd>arr[ei]</kbd>, that is, 4, <kbd>si</kbd> will be incremented to a value <span>of</span> 1.</li>
<li>Because <kbd>arr[si]</kbd>, that is, 3, <span>is less than</span> <kbd>arr[ei]</kbd>, that is, 4, <kbd>si</kbd> will be incremented to a value <span>of </span>2.</li>
<li>Because <kbd>arr[si]</kbd>, that is, 0, <span>is less than</span> <kbd>arr[ei]</kbd>, that is, 4, <kbd>si</kbd> will be incremented to a value <span>of </span>3.</li>
<li>Because <kbd>arr[si]</kbd>, that is, 2, is less than <kbd>arr[ei]</kbd>, that is, 6, <kbd>si</kbd> will be incremented to a value <span>of </span>4.</li>
</ul>
<p>Because the values of the <kbd>ei</kbd> and <kbd>si</kbd> variables have become the same, the <kbd>quick()</kbd> function will terminate, returning the value <kbd>4</kbd> to the <kbd>main</kbd> function (see <em>Figure 9.28(d )</em>):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/072b772e-ffa9-4f1b-9f87-5dfc45027f75.png" style="width:26.92em;height:38.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 9.28</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>On returning to the <kbd>main</kbd> function, two <kbd>if</kbd> statements are executed and the array is split into two parts: the first part ranges from the <kbd>arr[0]</kbd> to<span> the</span> <kbd>arr[3]</kbd> index locations, and the other part will range from the <kbd>arr[5]</kbd> to the <kbd>arr[5]</kbd> index locations, that is, of a single element. The starting and ending index values of the two parts of the array are pushed to the stack. The starting and ending index locations of the second part of the array (that is, 5 and 5) will be pushed to <kbd>stack1</kbd> and <kbd>stack2</kbd>, respectively. Similarly, the starting and ending index locations of the first part of the array (that is, 0 and 3) are pushed to <kbd>stack1</kbd> and <kbd>stack2</kbd>, respectively (see <em>Figure 9.29</em>).</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b09305c2-b399-4692-b702-80b1576dd369.png" style="width:21.50em;height:10.50em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 9.29</div>
<p>The whole quick sort technique is applied on all the partitions of the array until the stacks are empty. That is, the outer while loop repeats and the <kbd>popstk1()</kbd> and <kbd>popstk2()</kbd> functions will be invoked to pop off the values in the <kbd>stack1</kbd> and <kbd>stack2</kbd> arrays. Again, the <kbd>quick()</kbd> function is invoked and the two variables, <kbd>sindex</kbd> and <kbd>eindex</kbd>, that are popped from the stack are passed to it. The procedure continues until the whole array is sorted.</p>
<p>The program is compiled using GCC using the following statement:</p>
<pre>gcc quick sort.c -o quick sort</pre>
<p>Because no error appears on compilation, that means the <kbd>quick sort.c</kbd> <span>program </span>has successfully been compiled into the <kbd>quick sort.exe</kbd> file. On executing the file, it will ask you to specify how many numbers there are to be sorted. Following this, the program will prompt you to enter the numbers to be sorted. After entering the numbers, they will appear sorted in ascending order, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c9792887-0876-48b9-8964-6d652097e9e9.png" style="width:27.17em;height:31.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 9.30</div>
<p>Voilà! We have successfully arranged the numbers in our array using quick sort. Now let's move on to the next recipe!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Arranging numbers in descending order using heap sort</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will learn to arrange some integers in descending order using the heap sort technique.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The heap sort method is divided into the following two tasks:</p>
<ol>
<li>Creating a max-heap</li>
<li>Deleting the max-heap</li>
</ol>
<p>Let's start with creating a max-heap.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a max-heap</h1>
                </header>
            
            <article>
                
<p>The following steps are followed for creating a max-heap:</p>
<ol>
<li>The user is asked to enter a number. The number is used to create a heap. The number entered by the user is assigned to an array heap at index location <kbd>x</kbd>, where <kbd>x</kbd> begins with a value of 0 and increments after every insertion.</li>
<li>The newly inserted number is compared with the element of its parent node. Because we are making use of a max-heap, we need to maintain a rule: the value of the parent node should be always larger than its child node. The location of the parent node is computed using the formula <kbd>parent=(x-1)/2</kbd>, <span>where <kbd>x</kbd> represents the index location where the new node is inserted.</span></li>
<li>Check if the value of the new node is greater than the value of its parent. Interchange the values of <kbd>heap[parent]</kbd> and <kbd>heap[x]</kbd> with the help of an extra variable.</li>
<li>Recursively check the value of the parent of the parent node to see whether the property of the max-heap is maintained or not.</li>
</ol>
<p>Once the heap is made, the second task of deleting the max-heap will begin. Every time a node is deleted from a max-heap, the deleted node is kept in another array, say <kbd>arr</kbd>, that will contain the sorted elements. The task of deleting the max-heap is repeated as many times as the number of elements present in the max-heap.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting the max-heap</h1>
                </header>
            
            <article>
                
<p>Three variables, <kbd>leftchild</kbd>, <kbd>rightchild</kbd>, and <kbd>root</kbd>, are initialized as follows:</p>
<pre>leftchild=0<br/>rightchild=0<br/>root=1</pre>
<p class="mce-root"/>
<p>The following steps are performed to delete a max-heap:</p>
<ol>
<li>The element at the root node is temporarily assigned to the <kbd>n</kbd> variable.</li>
<li>The last element of the heap is placed at the root node.</li>
<li>If the value of the last index location is 1 or 2, that is, if the heap has only  1 or 2 elements left, then return to the caller with the <kbd>n</kbd> <span>variable</span>.</li>
<li>Since the last element is placed at the root node, reduce the size of the heap by 1.</li>
<li>To maintain the max-heap property, repeat <em>steps 6</em> through <em>9</em> while <kbd>rightchild &lt;=last</kbd>. Recall, the property of the max-heap is that the value of the parent node should be always larger than its children node.</li>
<li>Calculate the <kbd>leftchild</kbd> and <kbd>rightchild</kbd> locations.</li>
<li>If <kbd>heap[root] &gt; heap[leftchild] &amp;&amp; heap[root] &gt; heap[rightchild]</kbd>, return <kbd>n</kbd> and exit.</li>
<li>If the value of the left child is greater than the value of the right child, then interchange the value of the root and that of the left child.<span> The root will come down at the left child to check whether the max-heap property is maintained or not.</span></li>
<li>If the value of the right child is greater than the value of the left child, then interchange the value of the root and that of the right child. The root will come down at the right child to check whether the max-heap property is maintained or not.</li>
<li>When all the elements of the max-heap are over, that means the <kbd>arr</kbd> array will have all the sorted elements. So, the final step is to print the <kbd>arr</kbd> <span>array, </span>which contains the sorted elements.</li>
</ol>
<p>The program for sorting elements of an integer array using the heap sort technique is as follows:</p>
<pre>//<strong>heapsort.c</strong><br/><br/># include &lt;stdio.h&gt;<br/>#define max 20<br/>int heap[max], len;<br/><br/>void insheap(int h);<br/>int delsheap(int j);<br/><br/>int main() {<br/>  int arr[max], numb, i, j;<br/>  printf("How many elements to sort? ");<br/>  scanf("%d", &amp; len);<br/>  printf("Enter %d values \n", len);<br/>  for (i = 0; i &lt; len; i++) {<br/>    scanf("%d", &amp; numb);<br/>    insheap(numb);<br/>  }<br/>  j = len - 1;<br/>  for (i = 0; i &lt; len; i++) {<br/>    arr[i] = delsheap(j);<br/>    j--;<br/>  }<br/>  printf("\nThe Descending order is: \n");<br/>  for (i = 0; i &lt; len; i++)<br/>    printf("%d\n", arr[i]);<br/>  return 0;<br/>}<br/><br/>void insheap(int value) {<br/>  static int x;<br/>  int par, cur, temp;<br/>  if (x == 0) {<br/>    heap[x] = value;\<br/>    x++;<br/>  } else {<br/>    heap[x] = value;<br/>    par = (x - 1) / 2;<br/>    cur = x;<br/>    do {<br/>      if (heap[cur] &gt; heap[par]) {<br/>        temp = heap[cur];<br/>        heap[cur] = heap[par];<br/>        heap[par] = temp;<br/>        cur = par;<br/>        par = (cur - 1) / 2;<br/>      } else break;<br/>    } while (cur != 0);<br/>    x++;<br/>  }<br/>}<br/><br/>int delsheap(int j) {<br/>  int loc, n = 0, pos, lc = 0, rc = 0, temp = 0;<br/>  loc = j;<br/>  pos = 0;<br/>  n = heap[pos];<br/>  heap[pos] = heap[loc];<br/>  if (loc == 0 || loc == 1) return (n);<br/>  loc--;<br/>  lc = 2 * pos + 1;<br/>  rc = 2 * pos + 2;<br/>  while (rc &lt;= loc) {<br/>    if ((heap[pos] &gt; heap[lc] &amp;&amp; heap[pos] &gt; heap[rc]))<br/>      return (n);<br/>    else {<br/>      if (heap[lc] &gt; heap[rc]) {<br/>        temp = heap[lc];<br/>        heap[lc] = heap[pos];<br/>        heap[pos] = temp;<br/>        pos = lc;<br/>      } else {<br/>        temp = heap[rc];<br/>        heap[rc] = heap[pos];<br/>        heap[pos] = temp;<br/>        pos = rc;<br/>      }<br/>      lc = 2 * pos + 1;<br/>      rc = 2 * pos + 2;<br/>    }<br/>  }<br/>  if (lc == loc) {<br/>    if (heap[pos] &lt; heap[lc]) {<br/>      temp = heap[pos];<br/>      heap[pos] = heap[lc];<br/>      heap[lc] = temp;<br/>      pos = lc;<br/>    }<br/>  }<br/>  return (n);<br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>A heap is a complete binary tree that can be either a max-heap or a min-heap. The max-heap has the property that the key value of any node must be greater than or equal to the key values of its children. In the min-heap, the key value of any node must be lower than or equal to the values of its children.</p>
<p>In this recipe, we will learn to create a max-heap of the following list of integers:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td>5</td>
<td>2</td>
<td>9</td>
<td>3</td>
<td>1</td>
<td>4</td>
<td>6</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p class="CDPAlignLeft CDPAlign">In this heap sort method, the binary tree is constructed in the form of an array. In heap sort, the values in the array are added one by one, keeping the max-heap property true (that is, the key value of any node should be larger than or equal to its children). While adding the elements of the array, we keep track of the key value of the parent node with <kbd>(x-1)/2</kbd>, where <kbd>x</kbd> is the element whose parent is to be found. If the element inserted in the heap is larger than the key value of its parent, then interchanging takes place. For example, suppose the first key value entered is <kbd>5</kbd> (it is considered as the root); it is stored as the first element of the array, that is, <kbd>heap[0]</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/69ee9c11-e051-4096-90a4-99d3e54ec928.png" style="width:47.67em;height:4.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 9.31</div>
<p>Then 2 is added to it as a left child. The first child will always be added to the left. When another value is entered, it is entered at the location of <kbd>heap[1]</kbd>. After insertion, its parent node location is computed with <kbd>(x-1)/2</kbd>, where <kbd>x</kbd> is 1. So, the parent comes out to be location 0. So, <kbd>heap[1]</kbd> is compared with its parent element, <kbd>heap[0]</kbd>. If the key element of the parent element, <kbd>heap[0]</kbd>, is larger than <kbd>heap[1]</kbd>, then we move further; else, we interchange their key values. In our example, the second element is 2, so no interchanging is required:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fc9cd259-968f-459e-a7fd-f08fd05312d1.png" style="width:49.08em;height:8.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 9.32</div>
<p>Now, we move to enter the third element. The third element is 9, and it is added as a right child of node 5 (see <em>Figure 9.33 (a)</em>). In the array, it is stored at the location of <kbd>heap[2]</kbd>. Again, its parent element location is computed by <kbd>(x-1)/2</kbd>, which again comes out to be 0. In keeping the property of max-heap (that the value of the parent node should be larger than or equal to its children), we compare the key values of the <kbd>heap[0]</kbd> and <kbd>heap[2]</kbd> elements. Because <kbd>heap[0]</kbd> is less than <kbd>heap[2]</kbd>, it is violating the max-heap property. Thus, the key values of <kbd>heap[0]</kbd> and <kbd>heap[2]</kbd> will be interchanged, as shown in <em>Figure 9.33(b)</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2e51762b-43ab-457f-96d9-d548cc542d72.png" style="width:51.58em;height:18.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 9.33</div>
<p>Then 3 is added as a left child of node 2, as shown in <em>Figure 9.34(a)</em>. In the array, the new value is inserted at the index location of <kbd>heap[3]</kbd>. Again, its parent element location is computed using the formula <kbd>(x-1)/2</kbd>, where <kbd>x</kbd> represents the index location where new value is inserted, that is, 3. The parent element location is computed as 1. In keeping with the property of max-heap, <kbd>heap[1]</kbd> must be larger than or equal to <kbd>heap[3]</kbd>.  But because <kbd>heap[1]</kbd> is less than <kbd>heap[3]</kbd>, it is violating the max-heap property. Thus, the key values of <kbd>heap[1]</kbd> and <kbd>heap[3]</kbd> will be interchanged, as shown in <em>Figure 9.34(b)</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c166c522-7cb4-4d22-97d8-e891bf871a2b.png" style="width:51.50em;height:26.00em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 9.34</div>
<p class="mce-root"/>
<p>Now, 1 is added as the right child of node 3. In the array, the new value is inserted at the index location of <kbd>heap[4]</kbd>. Because the property of max-heap is still maintained, no interchanging is required:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4a0b1159-5f92-4079-9fc8-6c1c3c1437d3.png" style="width:51.00em;height:14.17em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.35</div>
<p>The next value is 4, which is added as the left child of node 5. In the array, the new value is inserted at the index location of <span><kbd>heap[5]</kbd></span>. Again, the property of max-heap is maintained, so no interchanging is required:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a6a6fcc9-92d7-4aa1-a716-8ee75eca2a48.png" style="width:51.42em;height:13.25em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Figure 9.36</div>
<p>Next, 6 is added as the right child of node 5 (see <em>Figure 9.37 (a)</em>). In the array, it is inserted at the index location of <kbd><span>heap[6]</span></kbd>. Again, its parent element location is computed using the formula <kbd>(x-1)/2</kbd>. The parent element location is computed as 2. In keeping with the property of max-heap, <kbd>heap[2]</kbd> must be larger than or equal to <kbd>heap[6]</kbd>. But because <kbd>heap[2]</kbd> is less than <kbd>heap[6]</kbd>, it is violating the max-heap property; so the key values of <kbd>heap[2]</kbd> and <kbd>heap[6]</kbd> will be interchanged, as shown in <em>Figure 9.37(b)</em>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7bf8345c-b7ea-4eea-8af7-e25f26064948.png" style="width:50.50em;height:23.17em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.37</div>
<p>Once the max-heap is made, we perform heap sort by repeating the following three steps:</p>
<ol>
<li>Removing its root element (and storing it in the sorted array) </li>
<li>Replacing the root element of the tree (array) by the last node value and removing the last node (decrementing the size of the array) </li>
<li>Reshuffling the key values to maintain the heap property</li>
</ol>
<p class="mce-root"/>
<p>In the following <em>Figure 9.38(a)</em>, you can see that the root element, that is, 9, is deleted and is stored in another array called <kbd>arr</kbd>. The <kbd>arr</kbd> array will contain the sorted elements. The root element is replaced by the last element of the tree. The last element of the tree is 5, so it is removed from the <kbd>heap[6]</kbd> <span>index location </span>and is assigned to the root, that is, at <kbd>heap[0]</kbd>. Now, the property of heap is no longer true. So, the values of node elements  5  and 6 are interchanged (see <em>Figure 9.38(b)</em>):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/15867e24-2047-4b90-9f90-bf75253904b4.png" style="width:49.50em;height:25.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.38</div>
<p>Now the process is repeated again, removing the key element of the root node and replacing its value with the last node and reshuffling the heap. That is, the root node element 6 is removed and is assigned to the sorted array, <kbd>arr</kbd>. And the root node is replaced by the last element of the tree that is by 4 (see <em>Figure 9.39(a)</em>). By putting the value 4 at the root, the property of heap is no longer true. So  to maintain the property of heap, the value 4 is brought down that is the values of node elements 4 and 5 are interchanged, as shown in <em>Figure 9.39(b)</em>):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ff7795a5-45d4-45b6-b804-87b70c96c25c.png" style="width:52.92em;height:25.50em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.39</div>
<p>The steps are repeated to get the array sorted in descending order, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4a503124-9549-4214-b3da-66f621191962.png" style="width:25.58em;height:4.92em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.40</div>
<p>The program is compiled using GCC using the following statement:</p>
<pre><strong>gcc heapsort.c -o heapsort</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Because no error appears on compilation, this means the <kbd>heapsort.c</kbd> <span>program </span>has successfully been compiled into the <kbd>heapsort.exe</kbd> file. On executing the file, it will ask us to specify how many numbers there are to be sorted. Following this, the program will prompt us to enter the numbers to be sorted. After entering the numbers, they will appear sorted in descending order, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/629e44a5-848b-4668-882e-d5763c804ee4.png" style="width:24.58em;height:27.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 9.41</div>
<p>Voilà! We have successfully arranged numbers in descending order using heap sort.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p><span>To learn more sorting methods like selection, merge, shell and radix sort visit <em>Appendix A</em> found on this link: <a href="https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20A.pdf">https://github.com/PacktPublishing/Practical-C-Programming/blob/master/Appendix%20A.pdf</a>.</span></p>


            </article>

            
        </section>
    </body></html>