- en: Working with GLSL Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending data to a shader using vertex attributes and vertex buffer objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a list of active vertex input attributes and locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending data to a shader using uniform variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a list of active uniform variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using uniform blocks and uniform buffer objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using program pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting debug messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a C++ shader program class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml), *Getting Started
    with GLSL*, we covered the basics of compiling, linking, and exporting shader
    programs. In this chapter, we'll cover techniques for communication between shader
    programs and the host OpenGL program. To be more specific, we'll focus primarily
    on input. The input to shader programs is generally accomplished via attributes
    and uniform variables. In this chapter, we'll see several examples of the use
    of these types of variables. We'll also cover a recipe for mixing and matching
    shader program stages, and a recipe for creating a C++ shader program object.
  prefs: []
  type: TYPE_NORMAL
- en: We won't cover shader output in this chapter. Obviously, shader programs send
    their output to the default framebuffer, but there are several other techniques
    for receiving shader output. For example, the use of custom framebuffer objects
    allow us to store shader output to a texture or other buffer. A technique called
    transform feedback allows for the storage of vertex shader output into arbitrary
    buffers. You'll see many examples of these output techniques later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Sending data to a shader using vertex attributes and vertex buffer objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vertex shader is invoked once per vertex. Its main job is to process the
    data associated with the vertex, and pass it (and possibly other information)
    along to the next stage of the pipeline. In order to give our vertex shader something
    to work with, we must have some way of providing (per-vertex) input to the shader.
    Typically, this includes the vertex position, normal vector, and texture coordinates
    (among other things). In earlier versions of OpenGL (prior to 3.0), each piece
    of vertex information had a specific *channel* in the pipeline. It was provided
    to the shaders using functions such as `glVertex`, `glTexCoord`, and `glNormal` (or
    within client vertex arrays using `glVertexPointer`, `glTexCoordPointer`, or `glNormalPointer`).
    The shader would then access these values via built-in variables such as `gl_Vertex` and `gl_Normal`.
    This functionality was deprecated in OpenGL 3.0 and later removed. Instead, vertex
    information must now be provided using *generic vertex attributes*, usually in
    conjunction with (vertex) *buffer objects*. The programmer is now free to define
    an arbitrary set of per-vertex attributes to provide as input to the vertex shader.
    For example, in order to implement normal mapping, the programmer might decide
    that the position, normal vector, and tangent vector should be provided along
    with each vertex. With OpenGL 4, it's easy to define this as the set of input
    attributes. This gives us a great deal of flexibility to define our vertex information
    in any way that is appropriate for our application, but may require a bit of getting
    used to for those of us who are accustomed to the old way of doing things.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the vertex shader, the per-vertex input attributes are defined by using
    the `in` GLSL qualifier. For example, to define a three-component vector input
    attribute named `VertexColor`, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the data for this attribute must be supplied by the OpenGL program.
    To do so, we make use of vertex buffer objects. The buffer object contains the
    values for the input attribute. In the main OpenGL program, we make the connection
    between the buffer and the input attribute and define how to *step through* the
    data. Then, when rendering, OpenGL pulls data for the input attribute from the
    buffer for each invocation of the vertex shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we''ll draw a single triangle. Our vertex attributes will
    be position and color. We''ll use a fragment shader to blend the colors of each
    vertex across the triangle to produce an image similar to the one shown as follows.
    The vertices of the triangle are red, green, and blue, and the interior of the
    triangle has those three colors blended together. The colors may not be visible
    in the printed text, but the variation in the shade should indicate the blending:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1865a799-6e7e-4491-a832-cd10c8898d37.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start with an empty OpenGL program, and the following shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertex shader (`basic.vert.glsl`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Attributes are the input variables to a vertex shader. In the previous code,
    there are two input attributes: `VertexPosition` and `VertexColor`. They are specified
    using the `in` GLSL keyword. Don't worry about the `layout` prefix, as we'll discuss
    that later. Our main OpenGL program needs to supply the data for these two attributes
    for each vertex. We will do so by mapping our polygon data to these variables.
  prefs: []
  type: TYPE_NORMAL
- en: It also has one output variable, named `Color`, which is sent to the fragment
    shader. In this case, `Color` is just an unchanged copy of `VertexColor`. Also,
    note that the `VertexPosition` attribute is simply expanded and passed along to
    the built-in `gl_Position` output variable for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fragment shader (`basic.frag.glsl`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There is just one input variable for this shader, `Color`. This links to the
    corresponding output variable in the vertex shader, and will contain a value that
    has been interpolated across the triangle based on the values at the vertices.
    We simply expand and copy this color to the `FragColor` output variable (more
    about fragment shader output variables in later recipes).
  prefs: []
  type: TYPE_NORMAL
- en: Write code to compile and link these shaders into a shader program (see the *Compiling
    a shader* and *Linking a shader program* recipes). In the following code, I'll
    assume that the handle to the shader program is `programHandle`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following steps to set up your buffer objects and render the triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a global (or private instance) variable to hold our handle to the vertex
    array object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the initialization function, we create and populate the vertex buffer
    objects for each attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and define a vertex array object, which defines the relationship between
    the buffers and the input attributes (see *There''s more...* for an alternate
    way to do this that is valid for OpenGL 4.3 and later):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the render function, bind to the vertex array object and call `glDrawArrays` to
    initiate the rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vertex attributes are the input variables to our vertex shader. In the given
    vertex shader, our two attributes are `VertexPosition` and `VertexColor`. The
    main OpenGL program refers to vertex attributes by associating each (active) input
    variable with a generic attribute index. These generic indices are simply integers
    between `0` and `GL_MAX_VERTEX_ATTRIBS - 1`. We can specify the relationship between
    these indices and the attributes using the `layout` qualifier. For example, in
    our vertex shader, we use the layout qualifier to assign `VertexPosition` to attribute
    index `0` and `VertexColor` to attribute index `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We refer to the vertex attributes in our OpenGL code by referring to the corresponding
    generic vertex attribute index.
  prefs: []
  type: TYPE_NORMAL
- en: It is not strictly necessary to explicitly specify the mappings between attribute
    variables and generic attribute indexes, because OpenGL will automatically map
    active vertex attributes to generic indexes when the program is linked. We could
    then query for the mappings and determine the indexes that correspond to the shader's
    input variables. It may be somewhat clearer, however, to explicitly specify the
    mapping, as we do in this example.
  prefs: []
  type: TYPE_NORMAL
- en: The first step involves setting up a pair of buffer objects to store our position
    and color data. As with most OpenGL objects, we start by creating the objects
    and acquiring handles to the two buffers by calling `glGenBuffers`. We then assign
    each handle to a separate descriptive variable to make the following code more
    clear.
  prefs: []
  type: TYPE_NORMAL
- en: For each buffer object, we first bind the buffer to the `GL_ARRAY_BUFFER` binding
    point by calling `glBindBuffer`. The first argument to `glBindBuffer` is the target
    binding point. In this case, since the data is essentially a generic array, we
    use `GL_ARRAY_BUFFER`. Examples of other kinds of targets (such as `GL_UNIFORM_BUFFER` or `GL_ELEMENT_ARRAY_BUFFER`)
    will be seen in later examples.
  prefs: []
  type: TYPE_NORMAL
- en: Once our buffer object is bound, we can populate the buffer with our vertex/color
    data by calling `glBufferData`. The second and third arguments to this function
    are the size of the array and a pointer to the array containing the data. Let's
    focus on the first and last arguments. The first argument indicates the target
    buffer object. The data provided in the third argument is copied into the buffer
    that is bound to this binding point. The last argument is one that gives OpenGL
    a hint about how the data will be used so that it can determine how best to manage
    the buffer internally. For full details about this argument, take a look into
    the OpenGL documentation. In our case, the data is specified once, will not be
    modified, and will be used many times for drawing operations, so this usage pattern
    best corresponds to the  `GL_STATIC_DRAW` value.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have set up our buffer objects, we tie them together into a **Vertex
    Array Object** (**VAO**). The VAO contains information about the connections between
    the data in our buffers and the input vertex attributes. We create a VAO using
    the `glGenVertexArrays` function. This gives us a handle to our new object, which
    we store in the `vaoHandle` (global) variable. Then, we enable the generic vertex
    attribute indexes `0` and `1` by calling `glEnableVertexAttribArray`. Doing so
    indicates that that the values for the attributes will be accessed and used for
    rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step makes the connection between the buffer objects and the generic
    vertex attribute indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we bind the buffer object to the `GL_ARRAY_BUFFER` binding point, then
    we call `glVertexAttribPointer`, which tells OpenGL which generic index the data
    should be used with, the format of the data stored in the buffer object, and where
    it is located within the buffer object that is bound to the `GL_ARRAY_BUFFER` binding
    point.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is the generic attribute index. The second is the number
    of components per vertex attribute (1, 2, 3, or 4). In this case, we are providing
    three-dimensional data, so we want three components per vertex. The third argument
    is the data type of each component in the buffer. The fourth is a Boolean that
    specifies whether the data should be automatically normalized (mapped to a range
    of [-1, 1] for signed integral values or [0, 1] for unsigned integral values).
    The fifth argument is the stride, which indicates the byte offset between consecutive
    attributes. Since our data is tightly packed, we can use a value of zero. The
    last argument is a pointer, which is not treated as a pointer! Instead, its value
    is interpreted as a byte offset from the beginning of the buffer to the first
    attribute in the buffer. In this case, there is no additional data in either buffer
    before the first element, so we use a value of zero.
  prefs: []
  type: TYPE_NORMAL
- en: The `glVertexAttribPointer` function stores (in the VAO's state) a pointer to
    the buffer currently bound to the `GL_ARRAY_BUFFER` binding point. When another
    buffer is bound to that binding point, it does not change the value of the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: The VAO stores all of the OpenGL states related to the relationship between
    buffer objects and the generic vertex attributes, as well as the information about
    the format of the data in the buffer objects. This allows us to quickly return
    all of this state when rendering.
  prefs: []
  type: TYPE_NORMAL
- en: The VAO is an extremely important concept, but can be tricky to understand.
    It's important to remember that the VAO's state is primarily associated with the
    enabled attributes and their connection to buffer objects. It doesn't necessarily
    keep track of buffer bindings. For example, it doesn't remember what is bound
    to the `GL_ARRAY_BUFFER` binding point. We only bind to this point in order to
    set up the pointers via `glVertexAttribPointer`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the VAO set up (a one-time operation), we can issue a draw command
    to render our object. In our render function, we clear the color buffer using `glClear`,
    bind to the vertex array object, and call `glDrawArrays` to draw our triangle.
    The `glDrawArrays` function initiates rendering of primitives by stepping through
    the buffers for each enabled attribute array, and passing the data down the pipeline
    to our vertex shader. The first argument is the render mode (in this case, we
    are drawing triangles), the second is the starting index in the enabled arrays,
    and the third argument is the number of indices to be rendered (three vertices
    for a single triangle).
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, we followed these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to specify the generic vertex attribute indexes for each attribute
    in the vertex shader using the `layout` qualifier
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and populate the buffer objects for each attribute
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and define the vertex array object by calling `glVertexAttribPointer` while
    the appropriate buffer is bound
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When rendering, bind to the vertex array object and call `glDrawArrays`, or
    an other appropriate rendering function (for example, `glDrawElements`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following section, we'll discuss some details, extensions, and alternatives
    to the previous technique.
  prefs: []
  type: TYPE_NORMAL
- en: Separate attribute format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With OpenGL 4.3, we have an alternate (arguably better) way of specifying the
    vertex array object state (attribute format, enabled attributes, and buffers).
    In the previous example, the `glVertexAttribPointer` function does two important
    things. First, it indirectly specifies which buffer contains the data for the
    attribute which is the buffer currently bound (at the time of the call) to `GL_ARRAY_BUFFER`.
    Secondly, it specifies the format of that data (type, offset, stride, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is arguably clearer to separate these two concerns into their own functions.
    This is exactly what has been implemented in OpenGL 4.3\. For example, to implement
    the same functionality as in step 3 of the previous *How to do it...* section,
    we would use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first four lines of the previous code are exactly the same as in the first
    example. We create and bind to the VAO, then enable attributes `0` and `1`. Next,
    we bind our two buffers to two different indexes within the vertex buffer binding
    point using `glBindVertexBuffer`. Note that we're no longer using the `GL_ARRAY_BUFFER` binding
    point. Instead, we now have a new binding point specifically for vertex buffers.
    This binding point has several indexes (usually from 0 - 15), so we can bind multiple
    buffers to this point. The first argument to `glBindVertexBuffer` specifies the
    index within the vertex buffer binding point. Here, we bind our position buffer
    to index `0` and our color buffer to index `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The indexes within the vertex buffer binding point need not be the same as the
    attribute locations.
  prefs: []
  type: TYPE_NORMAL
- en: The other arguments to `glBindVertexBuffer` are as follows. The second argument
    is the buffer to be bound, the third is the offset from the beginning of the buffer
    to where the data begins, and the fourth is the stride, which is the distance
    between successive elements within the buffer. Unlike `glVertexAttribPointer`,
    we can't use a `0` value here for tightly packed data, because OpenGL can't determine
    the size of the data without more information, so we need to specify it explicitly
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call `glVertexAttribFormat` to specify the format of the data for the
    attribute. Note that this time, this is decoupled from the buffer that stores
    the data. Instead, we're just specifying the format to expect for this attribute.
    The arguments are the same as the first four arguments to `glVertexAttribPointer`.
  prefs: []
  type: TYPE_NORMAL
- en: The `glVertexAttribBinding` function specifies the relationship between buffers
    that are bound to the vertex buffer binding point and attributes. The first argument
    is the attribute location, and the second is the index within the vertex buffer
    binding point. In this example, they are the same, but they don't need to be.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the buffer bindings of the vertex buffer binding point (specified
    by `glBindVertexBuffer`) are part of the VAO state, unlike the binding to `GL_ARRAY_BUFFER`.
  prefs: []
  type: TYPE_NORMAL
- en: This version is arguably clearer and easier to understand. It removes the confusing
    aspects of the *invisible* pointers that are managed in the VAO, and makes the
    relationship between attributes and buffers much clearer with `glVertexAttribBinding`.
    Additionally, it separates concerns that really don't need to be combined.
  prefs: []
  type: TYPE_NORMAL
- en: Fragment shader output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have noticed that I''ve neglected to say anything about the  `FragColor` output
    variable in the fragment shader. This variable receives the final output color
    for each fragment (pixel). Like vertex input variables, this variable needs to
    be associated with a proper location. Of course, we would typically like this
    to be linked to the back color buffer, which by default (in double buffered systems)
    is "color number" zero. (The relationship of the color numbers to render buffers
    can be changed by using `glDrawBuffers`). In this program, we are relying on the
    fact that the linker will automatically link our only fragment output variable
    to color number zero. To explicitly do so, we could (and probably should) have
    used a layout qualifier in the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are free to define multiple output variables for a fragment shader, thereby
    enabling us to render to multiple output buffers. This can be quite useful for
    specialized algorithms such as deferred rendering (see [Chapter 6](827d2689-d7e7-4188-a7bc-2eb4d813e88d.xhtml), *Image
    Processing and Screen Space Techniques*).
  prefs: []
  type: TYPE_NORMAL
- en: Specifying attribute indexes without using layout qualifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''d rather not clutter up your vertex shader code with the `layout` qualifiers
    (or you''re using a version of OpenGL that doesn''t support them), you can define
    the attribute indexes within the OpenGL program. We can do so by calling `glBindAttribLocation` just
    prior to linking the shader program. For example, we''d add the following code
    to the main OpenGL program just before the link step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This would indicate to the linker that `VertexPosition` should correspond to
    generic attribute index `0` and `VertexColor` to index `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can specify the color number for the fragment shader output variables
    without using the layout qualifier. We do so by calling `glBindFragDataLocation` prior
    to linking the shader program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This would tell the linker to bind the `FragColor` output variable to color
    number `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Using element arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often the case that we need to step through our vertex arrays in a non-linear
    fashion. In other words, we may want to *jump around* the data rather than just
    move through it from beginning to end. For example, we might want to draw a cube
    where the vertex data consists of only eight positions (the corners of the cube).
    In order to draw the cube, we would need to draw 12 triangles (two for each face),
    each of which consists of three vertices. All of the needed position data is in
    the original eight positions, but to draw all the triangles, we'll need to jump
    around and use each position for at least three different triangles.
  prefs: []
  type: TYPE_NORMAL
- en: To jump around in our vertex arrays, we can make use of element arrays. The
    element array is another buffer that defines the indices used when stepping through
    the vertex arrays. For details on using element arrays, take a look at the `glDrawElements` function in
    the OpenGL documentation ([http://www.opengl.org/sdk/docs/man](http://www.opengl.org/sdk/docs/man)).
  prefs: []
  type: TYPE_NORMAL
- en: Interleaved arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we used two buffers (one for color and one for position). Instead,
    we could have used just a single buffer and combined all of the data. In general,
    it is possible to combine the data for multiple attributes into a single buffer.
    The data for multiple attributes can be interleaved within an array, so that all
    of the data for a given vertex is grouped together within the buffer. Doing so
    just requires careful use of the stride argument to `glVertexAttribPointer` or `glBindVertexBuffer`.
    Take a look at the documentation for full details ([http://www.opengl.org/sdk/docs/man](http://www.opengl.org/sdk/docs/man)).
  prefs: []
  type: TYPE_NORMAL
- en: The decision about when to use interleaved arrays and when to use separate arrays
    is highly dependent on the situation. Interleaved arrays may bring better results
    due to the fact that data is accessed together and resides closer in memory (so-called
    **locality of reference**), resulting in better caching performance.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter02/scenebasic_attrib.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a list of active vertex input attributes and locations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As covered in the previous recipe, the input variables within a vertex shader
    are linked to generic vertex attribute indices at the time the program is linked.
    If we need to specify the relationship, we can either use layout qualifiers within
    the shader, or we could call `glBindAttribLocation` before linking.
  prefs: []
  type: TYPE_NORMAL
- en: However, it may be preferable to let the linker create the mappings automatically
    and query for them after program linking is complete. In this recipe, we'll see
    a simple example that prints all the active attributes and their indices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start with an OpenGL program that compiles and links a shader pair. You could
    use the shaders from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: As in previous recipes, we'll assume that the handle to the shader program is
    stored in a variable named `programHandle`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After linking and enabling the shader program, use the following code to display
    the list of active attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by querying for the number of active attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Loop through each attribute, query for the length of the name, the type, and
    the attribute location, and print the results to standard out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In step 1, we query for the number of active attributes by calling `glGetProgramInterfaceiv`.
    The first argument is the handle to the program object, and the second (`GL_PROGRAM_INPUT`)
    indicates that we are querying for information about the program input variables
    (the vertex attributes). The third argument (`GL_ACTIVE_RESOURCES`) indicates
    that we want the number of active resources. The result is stored in the location
    pointed to by the last argument, `numAttribs`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the number of attributes, we query for information about each
    one. The indices of the attributes run from `0` to `numAttribs-1`. We loop over
    those indices and for each we call `glGetProgramResourceiv` to get the length
    of the name, the type, and the location. We specify what information we would
    like to receive by means of an array of `GLenum` values called `properties`. The
    first argument is the handle to the program object, the second is the resource
    that we are querying (`GL_PROGRAM_INPUT`). The third is the index of the attribute
    and the fourth is the number of values in the `properties` array, which is the
    fifth argument. The `properties` array contains `GLenum` values, which specify
    the specific properties we would like to receive. In this example, the array contains  `GL_NAME_LENGTH`, `GL_TYPE`,
    and `GL_LOCATION`, which indicates that we want the length of the attribute's
    name, the data type of the attribute, and its location. The sixth argument is
    the size of the buffer that will receive the results; the seventh argument is
    a pointer to an integer that would receive the number of results that were written.
    If that argument is `NULL`, then no information is provided. Finally, the last
    argument is a pointer to a `GLint` array that will receive the results. Each item
    in the `properties` array corresponds to the same index in the `results` array.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we retrieve the name of the attribute by allocating a buffer to store
    the name and calling `glGetProgramResourceName`. The `results` array contains
    the length of the name in the first element, so we allocate an array of that size
    with an extra character just for good measure. The OpenGL documentation says that
    the size returned from `glGetProgramResourceiv` includes the null terminator,
    but it doesn't hurt to make sure by making a bit of additional space. In my tests,
    I've found this to be necessary on the latest NVIDIA drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we get the name by calling `glGetProgramResourceName`, and then print
    the information to the screen. We print the attribute's location, name, and type.
    The location is available in the third element of the `results` array, and the
    type is in the second. Note the use of the `getTypeString` function. This is a
    simple custom function that just returns a string representation of the data type.
    The data type is represented by one of the OpenGL defined constants, such as `GL_FLOAT`, `GL_FLOAT_VEC2`,
    or `GL_FLOAT_VEC3`. The `getTypeString` function consists of just one big `switch`
    statement returning a human-readable string corresponding to the value of the
    parameter (see the source code for `glslprogram.cpp` in the example code for this
    book).
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the previous code looks like this when it is run on the shaders
    from the previous recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should be noted that in order for a vertex shader input variable to be considered
    active, it must be used within the vertex shader. In other words, a variable is
    considered active if it is determined by the GLSL linker that it may be accessed
    during program execution. If a variable is declared within a shader, but not used,
    the previous code will not display the variable because it is not considered active
    and is effectively ignored by OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code is only valid for OpenGL 4.3 and later. Alternatively, you
    can achieve similar results with the `glGetProgramiv`, `glGetActiveAttrib`, and `glGetAttribLocation` functions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter02/scenebasic_attrib.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Compiling a shader* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Linking a shader program* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sending data to a shader using vertex attributes and vertex buffer objects* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending data to a shader using uniform variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vertex attributes offer one avenue for providing input to shaders; a second
    technique is uniform variables. Uniform variables are intended to be used for
    data that may change relatively infrequently compared to per-vertex attributes.
    In fact, it is simply not possible to set per-vertex attributes with uniform variables.
    For example, uniform variables are well-suited to the matrices used for modeling,
    viewing, and projective transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Within a shader, uniform variables are read-only. Their values can only be changed
    from outside the shader, via the OpenGL API. However, they can be initialized
    within the shader by assigning them to a constant value along with the declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Uniform variables can appear in any shader within a shader program, and are
    always used as input variables. They can be declared in one or more shaders within
    a program, but if a variable with a given name is declared in more than one shader,
    its type must be the same in all shaders. In other words, the uniform variables
    are held in a shared uniform namespace for the entire shader program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll draw the same triangle as in previous recipes in this
    chapter; however, this time, we''ll rotate the triangle using a uniform matrix
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63ba2410-bddf-4413-86b5-636e56c72d83.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the following vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `RotationMatrix` variable is declared using the uniform qualifier.
    We'll provide the data for this variable via the OpenGL program. The `RotationMatrix` variable is
    also used to transform `VertexPosition` before assigning it to the default output
    position variable, `gl_Position`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the same fragment shader as in the previous recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the main OpenGL code, we determine the rotation matrix and send it to
    the shader''s uniform variable. To create our rotation matrix, we''ll use the
    GLM library (see the *Using the GLM for mathematics* recipe). Within the main
    OpenGL code, add the following include statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We'll also assume that code has been written to compile and link the shaders,
    and to create the vertex array object for the color triangle. We'll assume that
    the handle to the vertex array object is `vaoHandle`, and the handle to the program
    object is `programHandle`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within the render method, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The steps involved in setting the value of a uniform variable include finding
    the location of the variable, and assigning a value to that location using one
    of the `glUniform` functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we start by clearing the color buffer, then creating a rotation
    matrix using GLM. Next, we query for the location of the uniform variable by calling `glGetUniformLocation`.
    This function takes the handle to the shader program object and the name of the
    uniform variable, and returns its location. If the uniform variable is not an
    active uniform variable, the function returns `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: It is inefficient to query the location of a uniform variable in each frame.
    A more efficient approach would be to cache the location during the shader compilation
    stage, and use it here.
  prefs: []
  type: TYPE_NORMAL
- en: We then assign a value to the uniform variable's location using `glUniformMatrix4fv`.
    The first argument is the uniform variable's location. The second is the number
    of matrices that are being assigned (note that the uniform variable could be an
    array). The third is a Boolean value indicating whether the matrix should be transposed
    when loaded into the uniform variable. With GLM matrices, a transpose is not required,
    so we use `GL_FALSE` here. If you were implementing the matrix using an array,
    and the data was in row-major order, you might need to use `GL_TRUE` for this
    argument. The last argument is a pointer to the data for the uniform variable.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, uniform variables can be any valid GLSL type, including complex types
    such as arrays or structures. OpenGL provides a `glUniform` function with the
    usual suffixes, appropriate for each type. For example, to assign to a variable
    of the `vec3` type, one would use `glUniform3f` or `glUniform3fv`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For arrays, one can use the functions ending in `v` to initialize multiple
    values within the array. Note that if it is desired, one can query for the location
    of a particular element of the uniform array using the `[]` operator. For example,
    to query for the location of the second element of `MyArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For structures, the members of the structure must be initialized individually.
    As with arrays, one can query for the location of a member of a structure using
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Where the structure variable is `MyMatrices` and the member of the structure
    is `Rotation`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter02/scenebasic_uniform.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Compiling a shader* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Linking a shader program* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sending data to a shader using vertex attributes and vertex buffer objects* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a list of active uniform variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it is a simple process to query for the location of an individual uniform
    variable, there may be instances where it can be useful to generate a list of
    all active uniform variables. For example, one might choose to create a set of
    variables to store the location of each uniform and assign their values after
    the program is linked. This would avoid the need to query for uniform locations
    when setting the value of the uniform variables, creating slightly more efficient
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The process for listing uniform variables is very similar to the process for
    listing attributes (see the *Getting a list of active vertex input attributes
    and locations* recipe), so this recipe will refer the reader back to the previous
    recipe for a detailed explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start with a basic OpenGL program that compiles and links a shader program.
    In the following recipes, we'll assume that the handle to the program is in a
    variable named `programHandle`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After linking and enabling the shader program, use the following code to display
    the list of active uniforms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by querying for the number of active uniform variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Loop through each uniform index and query for the length of the name, the type,
    the location, and the block index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process is very similar to the process shown in the *Getting a list of active
    vertex input attributes and locations* recipe. I will focus on the main differences.
  prefs: []
  type: TYPE_NORMAL
- en: The first and most obvious is that we use `GL_UNIFORM` instead of `GL_PROGRAM_INPUT` as
    the interface that we are querying in `glGetProgramResourceiv` and `glGetProgramInterfaceiv`.
    Second, we query for the block index (using `GL_BLOCK_INDEX` in the `properties` array).
    The reason for this is that some uniform variables are contained within a uniform
    block (see the *Using uniform blocks and uniform buffer objects* recipe). For
    this example, we only want information about uniforms that are not within blocks.
    The block index will be `-1` if the uniform variable is not within a block, so
    we skip any uniform variables that do not have a block index of `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we use the `getTypeString` function to convert the type value into a
    human-readable string (see the example code).
  prefs: []
  type: TYPE_NORMAL
- en: 'When this is run on the shader program from the previous recipe, we see the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with vertex attributes, a uniform variable is not considered active unless
    it is determined by the GLSL linker that it will be used within the shader.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code is only valid for OpenGL 4.3 and later. Alternatively, you
    can achieve similar results using the `glGetProgramiv`, `glGetActiveUniform`, `glGetUniformLocation`,
    and `glGetActiveUniformName` functions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter02/scenebasic_uniform.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sending data to a shader using uniform variables* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using uniform blocks and uniform buffer objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your program involves multiple shader programs that use the same uniform
    variables, one has to manage the variables separately for each program. Uniform
    locations are generated when a program is linked, so the locations of the uniforms
    may change from one program to the next. The data for those uniforms may have
    to be regenerated and applied to the new locations.
  prefs: []
  type: TYPE_NORMAL
- en: Uniform blocks were designed to ease the sharing of uniform data between programs.
    With uniform blocks, one can create a buffer object for storing the values of
    all the uniform variables, and bind the buffer to the uniform block. When changing
    programs, the same buffer object need only be rebound to the corresponding block
    in the new program.
  prefs: []
  type: TYPE_NORMAL
- en: 'A uniform block is simply a group of uniform variables defined within a syntactical
    structure known as a uniform block. For example, in this recipe, we''ll use the
    following uniform block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This defines a block with the name `BlobSettings` that contains four uniform
    variables. With this type of block definition, the variables within the block
    are still part of the global scope and do not need to be qualified with the block
    name.
  prefs: []
  type: TYPE_NORMAL
- en: The buffer object used to store the data for the uniforms is often referred
    to as a **uniform buffer object**. We'll see that a uniform buffer object is simply
    a buffer object that is bound to a certain location.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we''ll use a simple example to demonstrate the use of uniform
    buffer objects and uniform blocks. We''ll draw a quad (two triangles) with texture
    coordinates, and use our fragment shader to fill the quad with a fuzzy circle.
    The circle is a solid color in the center, but at its edge, it gradually fades
    to the background color, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e480890-1446-4636-90e1-48aeb854b174.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start with an OpenGL program that draws two triangles to form a quad. Provide
    the position at vertex attribute location `0`, and the texture coordinate (0 to
    1 in each direction) at vertex attribute location `1` (see the *Sending data to
    a shader using vertex attributes and vertex buffer objects* recipe).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the following vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The fragment shader contains the uniform block, and is responsible for drawing
    our
  prefs: []
  type: TYPE_NORMAL
- en: 'fuzzy circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note the uniform block named `BlobSettings`. The variables within this block
    define the parameters of our fuzzy circle. The `OuterColor` variable defines the
    color outside of the circle. `InnerColor` is the color inside of the circle. `RadiusInner` is
    the radius that defines the part of the circle that is a solid color (inside the
    fuzzy edge), and the distance from the center of the circle to the inner edge
    of the fuzzy boundary. `RadiusOuter` is the outer edge of the fuzzy boundary of
    the circle (when the color is equal to `OuterColor`).
  prefs: []
  type: TYPE_NORMAL
- en: The code within the main function computes the distance of the texture coordinate
    to the center of the quad located at (`0.5`, `0.5`). It then uses that distance
    to compute the color by using the `smoothstep` function. This function provides
    a value that smoothly varies between 0.0 and 1.0 when the value of the third argument
    is between the values of the first two arguments. Otherwise, it returns `0.0`
    or `1.0`, depending on whether `dist` is less than the first or greater than the
    second, respectively. The `mix` function is then used to linearly interpolate
    between `InnerColor` and `OuterColor` based on the value returned by the `smoothstep` function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the OpenGL program, after linking the shader program, use the following
    steps to assign data to the uniform block in the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the index of the uniform block using `glGetUniformBlockIndex`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Allocate space for the buffer to contain the data for the uniform block. We
    get the size using `glGetActiveUniformBlockiv`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Query for the offset of each variable within the block. To do so, we first
    find the index of each variable within the block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Place the data into the buffer at the appropriate offsets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the buffer object and copy the data into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Bind the buffer object to the uniform buffer-binding point at the index specified
    by the binding-layout qualifier in the fragment shader (`0`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phew! This seems like a lot of work! However, the real advantage comes when
    using multiple programs where the same buffer object can be used for each program.
    Let's take a look at each step individually.
  prefs: []
  type: TYPE_NORMAL
- en: First, we get the index of the uniform block by calling `glGetUniformBlockIndex`,
    then we query for the size of the block by calling `glGetActiveUniformBlockiv`.
    After getting the size, we allocate a temporary buffer named `blockBuffer` to
    hold the data for our block.
  prefs: []
  type: TYPE_NORMAL
- en: The layout of data within a uniform block is implementation-dependent, and implementations
    may use different padding and/or byte alignment. So in order to accurately lay
    out our data, we need to query for the offset of each variable within the block.
    This is done in two steps. First, we query for the index of each variable within
    the block by calling `glGetUniformIndices`. This accepts an array of the `names` variable
    (third argument) and returns the indices of the variables in the `indices` array (fourth
    argument). Then, we use the indices to query for the offsets by calling `glGetActiveUniformsiv`.
    When the fourth argument is `GL_UNIFORM_OFFSET`, this returns the offset of each
    variable in the array pointed to by the fifth argument. This function can also
    be used to query for the size and type, however, in this case we choose not to
    do so in order to keep the code simple (albeit less general).
  prefs: []
  type: TYPE_NORMAL
- en: The next step involves filling our temporary buffer, `blockBuffer`, with the
    data for the uniforms at the appropriate offsets. Here, we use the standard library
    function, `memcpy`, to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the temporary buffer is populated with the data with the appropriate
    layout, we can create our buffer object and copy the data into the buffer object.
    We call `glGenBuffers` to generate a buffer handle, and then bind that buffer
    to the `GL_UNIFORM_BUFFER` binding point by calling `glBindBuffer`. The space
    is allocated within the buffer object and the data is copied when `glBufferData` is
    called. We use `GL_DYNAMIC_DRAW` as the usage hint here because uniform data may
    be changed somewhat often during rendering. Of course, this is entirely dependent
    on the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we associate the buffer object with the uniform block by calling `glBindBufferBase`.
    This function binds to an index within a buffer binding point. Certain binding
    points are also called **indexed buffer targets**. This means that the target
    is actually an array of targets, and `glBindBufferBase` allows us to bind to one
    index within the array. In this case, we bind it to the index that we specified
    in the layout qualifier in the fragment shader: `layout (binding = 0)` (see *Getting
    ready*). These two indices must match.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why we use `glBindBuffer` and `glBindBufferBase` with `GL_UNIFORM_BUFFER`.
    Aren't these the same binding points used in two different contexts? The answer
    is that the `GL_UNIFORM_BUFFER` point can be used in each function with a slightly
    different meaning. With `glBindBuffer`, we bind to a point that can be used for
    filling or modifying a buffer, but can't be used as a source of data for the shader.
    When we use `glBindBufferBase`, we are binding to an index within a location that
    can be directly sourced by the shader. Granted, that's a bit confusing.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the data for a uniform block needs to be changed at some later time, one
    can call `glBufferSubData` to replace all or part of the data within the buffer.
    If you do so, don't forget to first bind the buffer to the generic binding point, `GL_UNIFORM_BUFFER`.
  prefs: []
  type: TYPE_NORMAL
- en: Using an instance name with a uniform block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A uniform block can have an optional instance name. For example, with our `BlobSettings` block,
    we could have used the instance name `Blob`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the variables within the block are placed within a namespace
    qualified by the instance name. Therefore, our shader code needs to refer to them
    prefixed with the instance name. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we need to qualify the variable names (with the `BlobSettings` block
    name) within the OpenGL code when querying for variable indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Using layout qualifiers with uniform blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the layout of the data within a uniform buffer object is implementation-dependent,
    it required us to query for the variable offsets. However, one can avoid this
    by asking OpenGL to use the standard layout, `std140`. This is accomplished by
    using a layout qualifier when declaring the uniform block. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `std140` layout is described in detail within the OpenGL specification document
    (available at [http://www.opengl.org](http://www.opengl.org)).
  prefs: []
  type: TYPE_NORMAL
- en: Other options for the layout qualifier that apply to uniform block layouts include `packed` and `shared`.
    The `packed` qualifier simply states that the implementation is free to optimize
    memory in whatever way it finds necessary (based on variable usage or other criteria).
    With the `packed` qualifier, we still need to query for the offsets of each variable.
    The `shared` qualifier guarantees that the layout will be consistent between multiple
    programs and program stages provided that the uniform block declaration does not
    change. If you are planning to use the same buffer object between multiple programs
    and/or program stages, it is a good idea to use the `shared` option.
  prefs: []
  type: TYPE_NORMAL
- en: There are two other layout qualifiers that are worth mentioning: `row_major` and `column_major`.
    These define the ordering of data within the matrix type variables within the
    uniform block.
  prefs: []
  type: TYPE_NORMAL
- en: 'One can use multiple (non-conflicting) qualifiers for a block. For example,
    to define a block with both the `row_major` and `shared` qualifiers, we would
    use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter02/scenebasic_uniformblock.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Sending data to a shader using uniform variables* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using program pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Program pipeline objects were introduced as part of the **separable shader objects **extension,
    and moved into core OpenGL with version 4.1\. They allow programmers to mix and
    match shader stages from multiple **separable** shader programs. To understand
    how this works and why it may be useful, let's go through a hypothetical example.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have one vertex shader and two fragment shaders. Suppose that the
    code in the vertex shader will function correctly with both fragment shaders.
    I could simply create two different shader programs, reusing the OpenGL shader
    object containing the vertex shader. However, if the vertex shader has a lot of
    uniform variables, then every time that I switch between the two shader programs,
    I would (potentially) need to reset some or all of those uniform variables. This
    is because the uniform variables are part of the *shader program's* state, so
    changes to the uniforms in one program would not carry over to the other program,
    even when the two share a shader object. The uniform information is stored in
    the shader program object, not the shader object.
  prefs: []
  type: TYPE_NORMAL
- en: Shader program objects include the values of active uniform variables; this
    information is not stored within a shader object.
  prefs: []
  type: TYPE_NORMAL
- en: With separable shader objects, we can create shader programs that include one
    or more shader stages. Prior to this extension, we were required to include at
    least a vertex and fragment shader. Such programs are called separable because
    they are not necessarily linked to specific other stages. They can be separated
    and linked to different stages at different times. Separable programs can contain
    just a single stage (or more if desired).
  prefs: []
  type: TYPE_NORMAL
- en: With **program pipelines**, we can create pipelines that mix and match the stages
    of separable programs. This enables us to avoid losing the state of uniform variables
    in a given shader stage when switching other stages. For example, in the preceding
    scenario, where we have one vertex shader (shader A) and two fragment shaders
    (B and C), we could create three shader programs, each containing a single stage.
    Then, we could create two pipelines. The first pipeline would use the vertex shader
    from program A and the fragment shader from program B, and the second would use
    the vertex shader from program A and the fragment shader from program C. We could
    switch between the two pipelines without losing any of the uniform variable state
    in shader stage A, because we haven't actually switched shader programs—we're
    using the same shader program (containing stage A) in both pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll follow through with the earlier example. We'll need a
    single vertex shader and two compatible fragment shaders. Let's assume that the
    file names are `separable.vert.glsl`, `separable1.frag.glsl`, and `separable2.frag.glsl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Separable shaders require you to re-declare the built-in `gl_PerVertex` output
    block if you use any of its members. Since you will nearly always use one of its
    members (`gl_Position`), you''ll very likely need to add the following to your
    vertex shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by loading the shader files into `std::string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create one shader program for each using `glCreateShaderProgramv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create two program pipelines. The first will use the vertex shader
    and the first fragment shader, and the second will use the vertex shader and the
    second fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To set uniform variables in separable shaders, the recommended technique is
    to use `glProgramUniform` rather than `glUniform`. With separable shaders and
    program pipelines, it can be a bit tedious and tricky to determine which shader
    stage is affected by the `glUniform` functions. The `glProgramUniform` functions
    allow us to specify the target program directly. For example, here, we''ll set
    a uniform in the vertex shader program (shared by the two pipelines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To render, we first need to make sure that no programs are currently bound.
    If there is a program bound via `glUseProgram`, it will ignore any program pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the pipelines that we set up earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `glCreateShaderProgramv` function provides a simple way to create a separable
    shader program consisting of a single stage. We pass the shader stage and the
    code string to function which creates a shader object, compiles it, creates a
    separable program, attaches the shader, and links the program, and returns the
    name of the new shader program. We should check for errors immediately after each
    call. All errors will be in the program info log. The *Linking a shader program* recipe
    details how to check for errors.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the shader programs, we create the pipelines. We create two pipeline
    objects using `glCreateProgramPipelines`. Then, we set the stages for each pipeline
    using `glUseProgramStages`. The first argument to `glUseProgramStages` is the
    pipeline name, the second is a bit string indicating the stages that are to be
    used from the program, and the last argument is the program name. The bit string
    for the second argument can be composed of some combination of `GL_VERTEX_SHADER_BIT`, `GL_FRAGMENT_SHADER_BIT`,
    and so on. Use the bitwise OR operator (`|`) to combine bits.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, when using program pipelines, it is a good idea to use `glProgramUniform` rather
    than `glUniform` to set uniform variables. It can be difficult to determine the
    program that is being affected when using `glUniform` due to the fact that a pipeline
    can and usually does involve multiple programs. There is a function called `glActiveShaderProgram` that
    can be used to specify the program affected by `glUniform` calls, or you can simply
    use `glUseProgram`. However, there's no need to bother with any of that, because `glProgramUniform` makes
    it clear and simple. With `glProgramUniform`, we specify the target program directly
    as the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: Before rendering with pipelines, it is important to make sure that there is
    no program that is currently bound to the GL context via `glUseProgram`. If there
    is, it will be used instead of the pipeline. Therefore, you might want to call `glUseProgram(0)` before
    rendering, just to be sure.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use `glBindProgramPipeline` to enable one of our pipelines before
    rendering. In this example, the first draw will use the vertex shader and the
    first fragment shader. The second draw will use the vertex shader and the second
    fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding example, we used `glCreateShaderProgramv` to create each single-stage
    program. However, you can also use the more familiar `glCreateProgram` to do the
    same thing. In fact, if you want to create a program with more than one stage
    (say, a vertex shader and a geometry shader), you need to use `glCreateProgram`.
    However, since we want to use it with shader pipelines, it is important to use `glProgramParameteri` to
    designate it as a separable program. Here''s an example of creating a single stage
    program using `glCreateProgram`, assuming that `vertShader` is the name of a previously-compiled
    vertex shader object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You could attach more than one shader before linking.
  prefs: []
  type: TYPE_NORMAL
- en: Program pipelines make it easy to mix and match shader stages, while maintaining
    uniform state. However, the added complexity may not be worth it for many situations.
    If your shaders are complex, with lots of uniform states, and you need to switch
    portions of the pipeline often, it might be a good alternative.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chapter02/sceneseparable.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Linking a shader program* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting debug messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to recent versions of OpenGL, the traditional way to get debug information
    was to call `glGetError`. Unfortunately, that is an exceedingly tedious method
    to debug a program. The `glGetError` function returns an error code if an error
    has occurred at some point before the function was called.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if we're chasing down a bug, we essentially need to call `glGetError` after
    every function call to an OpenGL function, or do a binary search-like process
    where we call it before and after a block of code, and then move the two calls
    closer to each other until we determine the source of the error. What a pain!
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, as of OpenGL 4.3, we now have support for a more modern method for
    debugging. Now, we can register a debug callback function that will be executed
    whenever an error occurs, or other informational message is generated. Not only
    that, but we can send our own custom messages to be handled by the same callback,
    and we can filter the messages using a variety of criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an OpenGL program with a debug context. While it is not strictly necessary
    to acquire a debug context, we might not get messages that are as informative
    as when we are using a debug context. To create an OpenGL context using GLFW with
    debugging enabled, use the following function call prior to creating the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'An OpenGL debug context will have debug messages enabled by default. If, however,
    you need to enable debug messages explicitly, use the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a callback function to receive the debug messages. The function must
    conform to a specific prototype described in the OpenGL documentation. For this
    example, we''ll use the following one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Register our callback with OpenGL using `glDebugMessageCallback`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable all messages, all sources, all levels, and all IDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `debugCallback` callback function has several parameters, the most important
    of which is the debug message itself (the sixth parameter, `message`). For this
    example, we simply print the message to the standard output, but we could send
    it to a log file or some other destination.
  prefs: []
  type: TYPE_NORMAL
- en: The first four parameters to `debugCallback` describe the source, type, ID number,
    and severity of the message. The ID number is an unsigned integer specific to
    the message. The possible values for the source, type, and severity parameters
    are described in the following tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source parameter can have any of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Source** | **Generated by** |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_SOURCE_API` | Calls to the OpenGL API |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_SOURCE_WINDOW_SYSTEM` | Calls to a Windows system API |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_SOURCE_THIRD_PARTY` | An application associated with OpenGL |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_SOURCE_APPLICATION` | The application itself |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_SOURCE_OTHER` | Some other source |'
  prefs: []
  type: TYPE_TB
- en: 'The type parameter can have any of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_TYPE_ERROR` | An error from the OpenGL API |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR` | Behavior that has been deprecated |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR` | Undefined behavior |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_TYPE_PORTABILITY` | Some functionality is not portable |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_TYPE_PERFORMANCE` | Possible performance issues |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_TYPE_MARKER` | An annotation |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_TYPE_PUSH_GROUP` | Messages related to debug group push |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_TYPE_POP_GROUP` | Messages related to debug group pop |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_TYPE_OTHER` | Other messages |'
  prefs: []
  type: TYPE_TB
- en: 'The severity parameter can have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Severity** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_SEVERITY_HIGH` | Errors or dangerous behavior |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_SEVERITY_MEDIUM` | Major performance warnings, other warnings,
    or use of deprecated functionality |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_SEVERITY_LOW` | Redundant state changes, unimportant undefined
    behavior |'
  prefs: []
  type: TYPE_TB
- en: '| `GL_DEBUG_SEVERITY_NOTIFICATION` | A notification, not an error, or performance
    issue |'
  prefs: []
  type: TYPE_TB
- en: The `length` parameter is the length of the message string, excluding the null
    terminator. The last parameter, `param`, is a user-defined pointer. We can use
    this to point to some custom objects that might be helpful to the callback function.
    This parameter can be set using the second parameter to `glDebugMessageCallback`.
  prefs: []
  type: TYPE_NORMAL
- en: Within `debugCallback`, we convert each `GLenum` parameter into a string. Due
    to space constraints, I don't show all of that code here, but it can be found
    in the example code for this book. We then print all of the information to the
    standard output.
  prefs: []
  type: TYPE_NORMAL
- en: The call to `glDebugMessageCallback` registers our callback function with the
    OpenGL debug system. The first parameter is a pointer to our callback function,
    and the second parameter (`nullptr`, in this example) can be a pointer to any
    object that we would like to pass into the callback. This pointer is passed as
    the last parameter with every call to `debugCallback`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the call to `glDebugMessageControl` determines our message filters.
    This function can be used to selectively turn on or off any combination of message
    source, type, ID, or severity. In this example, we turn everything on.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL also provides support for stacks of named debug groups. This means that
    we can remember all of our debug message filter settings on a stack and return
    to them after some changes have been made. This might be useful, for example,
    if there are sections of code where we need to filter some kinds of messages and
    other sections where we want a different set of messages.
  prefs: []
  type: TYPE_NORMAL
- en: The functions involved are `glPushDebugGroup` and `glPopDebugGroup`. A call
    to `glPushDebugGroup` generates a debug message with the `GL_DEBUG_TYPE_PUSH_GROUP` type,
    and retains the current state of our debug filters on a stack. We can then change
    our filters using `glDebugMessageControl`, and later return to the original state
    using `glPopDebugGroup`. Similarly, the `glPopDebugGroup` function generates a
    debug message with the `GL_DEBUG_TYPE_POP_GROUP` type.
  prefs: []
  type: TYPE_NORMAL
- en: Building a C++ shader program class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are using C++, it can be very convenient to create classes to encapsulate
    some of the OpenGL objects. A prime example is the shader program object. In this
    recipe, we'll look at a design for a C++ class that can be used to manage a shader
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's not much to prepare for with this one; you just need a build environment
    that supports C++. Also, I'll assume that you are using GLM for matrix and vector
    support; if not, just leave out the functions involving the GLM classes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll use a custom exception class for errors that might occur during
    compilation or linking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use `enum` for the various shader types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The program class itself has the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Code download tip
  prefs: []
  type: TYPE_NORMAL
- en: The full source code for all of the recipes in this text is available on GitHub
    at [https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition](https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: You can also download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support) and
    register to have the files emailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: The techniques involved in the implementation of these functions are covered
    in previous recipes in this chapter. Due to space limitations, I won't include
    the code here (it's available from this book's GitHub repository), but we'll discuss
    some of the design decisions in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The state stored within a `GLSLProgram` object includes the handle to the OpenGL
    shader program object (`handle`), a `bool` variable indicating whether or not
    the program has been successfully linked (`linked`), and `map`, which is used
    to store `uniform` locations as they are discovered (`uniformLocations`).
  prefs: []
  type: TYPE_NORMAL
- en: The `compileShader` overloads will throw `GLSLProgramException` if the compilation
    fails. The first version determines the type of shader based on the filename extension.
    In the second version, the caller provides the shader type, and the third version
    is used to compile a shader, taking the shader's source code from a string. The
    filename can be provided as a third argument if the string was taken from a file,
    which is helpful for providing better error messages.
  prefs: []
  type: TYPE_NORMAL
- en: The `GLSLProgramException` error message will contain the contents of the shader
    log or program log when an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The `getUniformLocation` private function is used by the `setUniform` functions
    to find the location of a uniform variable. It checks the `uniformLocations` map first,
    and if the location is not found, queries OpenGL for the location, and stores
    the result in the map before returning. The `fileExists` function is used by `compileShaderFromFile` to
    check for file existence.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor simply initializes `linked` to `false` and `handle` to `0`.
    The `handle` variable will be initialized by calling `glCreateProgram` when the
    first shader is compiled.
  prefs: []
  type: TYPE_NORMAL
- en: The `link` function simply attempts to link the program by calling `glLinkProgram`.
    It then checks the link status, and if successful, sets the `linked` variable to `true` and
    returns `true`. Otherwise, it gets the program log (by calling `glGetProgramInfoLog`),
    stores the result in `GLSLProgramException`, and throws it. If the link is successful,
    it calls `findUniformLocations`, which gets a list of all active uniform variables
    and stores their locations in the map named `uniformLocations`, keyed by their
    names. Regardless of whether the link is successful, it detaches and deletes all
    shader objects before returning or throwing an exception.  After all of this,
    it detaches and deletes the shader objects, because they are no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: The `use` function simply calls `glUseProgram` if the program has already been
    successfully linked, otherwise it does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: The `getHandle` and `isLinked` functions are simply *getter* functions that
    return `handle` to the OpenGL program object and the value of the `linked` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `bindAttribLocation` and `bindFragDataLocation` functions are wrappers around `glBindAttribLocation` and `glBindFragDataLocation`.
    Note that these functions should only be called prior to linking the program.
  prefs: []
  type: TYPE_NORMAL
- en: The `setUniform` overloaded functions are straightforward wrappers around the
    appropriate `glUniform` functions. As mentioned previously, the uniform locations
    are queried and stored when the program is linked, so each `setUniform` function
    checks the map to get the cached uniform location.
  prefs: []
  type: TYPE_NORMAL
- en: The destructor takes care of deleting the program object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `printActiveUniforms`, `printActiveUniformBlocks`, and `printActiveAttribs` functions
    are useful for debugging purposes. They simply display a list of the active `uniforms/attributes` to
    the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple example of the use of the `GLSLProgram` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ingredients/glslprogram.cpp` file in the example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the full source code, check out the GitHub site for this book at [https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition](https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the recipes in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
