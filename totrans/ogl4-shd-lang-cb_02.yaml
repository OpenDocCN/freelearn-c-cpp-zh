- en: Working with GLSL Programs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与GLSL程序一起工作
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Sending data to a shader using vertex attributes and vertex buffer objects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用顶点属性和顶点缓冲区对象向着色器发送数据
- en: Getting a list of active vertex input attributes and locations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取活动顶点输入属性和位置的列表
- en: Sending data to a shader using uniform variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用统一变量向着色器发送数据
- en: Getting a list of active uniform variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取活动统一变量的列表
- en: Using uniform blocks and uniform buffer objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用统一块和统一缓冲区对象
- en: Using program pipelines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用程序管线
- en: Getting debug messages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取调试信息
- en: Building a C++ shader program class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个C++着色器程序类
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In [Chapter 1](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml), *Getting Started
    with GLSL*, we covered the basics of compiling, linking, and exporting shader
    programs. In this chapter, we'll cover techniques for communication between shader
    programs and the host OpenGL program. To be more specific, we'll focus primarily
    on input. The input to shader programs is generally accomplished via attributes
    and uniform variables. In this chapter, we'll see several examples of the use
    of these types of variables. We'll also cover a recipe for mixing and matching
    shader program stages, and a recipe for creating a C++ shader program object.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml)“GLSL入门”中，我们介绍了编译、链接和导出着色器程序的基础知识。在本章中，我们将介绍着色器程序与主机OpenGL程序之间通信的技术。更具体地说，我们将主要关注输入。着色器程序的输入通常通过属性和统一变量来实现。在本章中，我们将看到这些类型变量使用的几个示例。我们还将介绍混合和匹配着色器程序阶段的食谱，以及创建C++着色器程序对象的食谱。
- en: We won't cover shader output in this chapter. Obviously, shader programs send
    their output to the default framebuffer, but there are several other techniques
    for receiving shader output. For example, the use of custom framebuffer objects
    allow us to store shader output to a texture or other buffer. A technique called
    transform feedback allows for the storage of vertex shader output into arbitrary
    buffers. You'll see many examples of these output techniques later in this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不会涉及着色器输出。显然，着色器程序将它们的输出发送到默认帧缓冲区，但还有几种其他技术可以接收着色器输出。例如，使用自定义帧缓冲区对象允许我们将着色器输出存储到纹理或其他缓冲区。一种称为变换反馈的技术允许将顶点着色器输出存储到任意缓冲区。你将在本书后面的部分看到这些输出技术的许多示例。
- en: Sending data to a shader using vertex attributes and vertex buffer objects
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用顶点属性和顶点缓冲区对象向着色器发送数据
- en: The vertex shader is invoked once per vertex. Its main job is to process the
    data associated with the vertex, and pass it (and possibly other information)
    along to the next stage of the pipeline. In order to give our vertex shader something
    to work with, we must have some way of providing (per-vertex) input to the shader.
    Typically, this includes the vertex position, normal vector, and texture coordinates
    (among other things). In earlier versions of OpenGL (prior to 3.0), each piece
    of vertex information had a specific *channel* in the pipeline. It was provided
    to the shaders using functions such as `glVertex`, `glTexCoord`, and `glNormal` (or
    within client vertex arrays using `glVertexPointer`, `glTexCoordPointer`, or `glNormalPointer`).
    The shader would then access these values via built-in variables such as `gl_Vertex` and `gl_Normal`.
    This functionality was deprecated in OpenGL 3.0 and later removed. Instead, vertex
    information must now be provided using *generic vertex attributes*, usually in
    conjunction with (vertex) *buffer objects*. The programmer is now free to define
    an arbitrary set of per-vertex attributes to provide as input to the vertex shader.
    For example, in order to implement normal mapping, the programmer might decide
    that the position, normal vector, and tangent vector should be provided along
    with each vertex. With OpenGL 4, it's easy to define this as the set of input
    attributes. This gives us a great deal of flexibility to define our vertex information
    in any way that is appropriate for our application, but may require a bit of getting
    used to for those of us who are accustomed to the old way of doing things.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器对每个顶点调用一次。其主要任务是处理与顶点相关的数据，并将其（以及可能的其他信息）传递到管道的下一阶段。为了给我们的顶点着色器提供一些可以操作的数据，我们必须有一种方式向着色器提供（每个顶点的）输入。通常，这包括顶点位置、法向量以及纹理坐标（以及其他内容）。在OpenGL的早期版本（3.0之前），每个顶点信息在管道中都有一个特定的*通道*。它通过`glVertex`、`glTexCoord`和`glNormal`等函数提供给着色器（或者使用客户端顶点数组中的`glVertexPointer`、`glTexCoordPointer`或`glNormalPointer`）。然后着色器通过内置变量如`gl_Vertex`和`gl_Normal`访问这些值。这种功能在OpenGL
    3.0中被弃用，并在之后的版本中删除。相反，现在必须使用*通用顶点属性*来提供顶点信息，通常与（顶点）*缓冲对象*一起使用。程序员现在可以自由定义一组任意的顶点属性，将其作为输入提供给顶点着色器。例如，为了实现法线贴图，程序员可能会决定应该提供位置、法向量和切向量作为每个顶点的附加信息。在OpenGL
    4中，很容易将这些定义为输入属性集。这为我们提供了很大的灵活性，可以以任何适合我们应用的方式定义顶点信息，但对于习惯于旧方法的人来说可能需要一些适应。
- en: 'In the vertex shader, the per-vertex input attributes are defined by using
    the `in` GLSL qualifier. For example, to define a three-component vector input
    attribute named `VertexColor`, we use the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中，使用`in` GLSL限定符定义了每个顶点的输入属性。例如，为了定义一个名为`VertexColor`的三分量向量输入属性，我们使用以下代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of course, the data for this attribute must be supplied by the OpenGL program.
    To do so, we make use of vertex buffer objects. The buffer object contains the
    values for the input attribute. In the main OpenGL program, we make the connection
    between the buffer and the input attribute and define how to *step through* the
    data. Then, when rendering, OpenGL pulls data for the input attribute from the
    buffer for each invocation of the vertex shader.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个属性的数据必须由OpenGL程序提供。为此，我们使用顶点缓冲对象。缓冲对象包含输入属性的值。在主要的OpenGL程序中，我们建立缓冲区和输入属性之间的连接，并定义如何*遍历*数据。然后，在渲染时，OpenGL从缓冲区中为每个顶点着色器的调用提取输入属性的数据。
- en: 'For this recipe, we''ll draw a single triangle. Our vertex attributes will
    be position and color. We''ll use a fragment shader to blend the colors of each
    vertex across the triangle to produce an image similar to the one shown as follows.
    The vertices of the triangle are red, green, and blue, and the interior of the
    triangle has those three colors blended together. The colors may not be visible
    in the printed text, but the variation in the shade should indicate the blending:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将绘制一个三角形。我们的顶点属性将是位置和颜色。我们将使用片段着色器将每个顶点的颜色在三角形上混合，以产生一个类似于以下所示图像的效果。三角形的顶点是红色、绿色和蓝色，三角形的内部是这三种颜色的混合。这些颜色可能在打印的文本中不可见，但阴影的变化应该表明了混合：
- en: '![](img/1865a799-6e7e-4491-a832-cd10c8898d37.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1865a799-6e7e-4491-a832-cd10c8898d37.png)'
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll start with an empty OpenGL program, and the following shaders:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个空的OpenGL程序开始，并使用以下着色器：
- en: 'The vertex shader (`basic.vert.glsl`):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '顶点着色器（`basic.vert.glsl`）:'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Attributes are the input variables to a vertex shader. In the previous code,
    there are two input attributes: `VertexPosition` and `VertexColor`. They are specified
    using the `in` GLSL keyword. Don't worry about the `layout` prefix, as we'll discuss
    that later. Our main OpenGL program needs to supply the data for these two attributes
    for each vertex. We will do so by mapping our polygon data to these variables.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是顶点着色器的输入变量。在前面的代码中，有两个输入属性：`VertexPosition`和`VertexColor`。它们使用`in` GLSL关键字指定。不用担心`layout`前缀，我们稍后会讨论这一点。我们的主OpenGL程序需要为每个顶点提供这两个属性的数据。我们将通过将我们的多边形数据映射到这些变量来实现这一点。
- en: It also has one output variable, named `Color`, which is sent to the fragment
    shader. In this case, `Color` is just an unchanged copy of `VertexColor`. Also,
    note that the `VertexPosition` attribute is simply expanded and passed along to
    the built-in `gl_Position` output variable for further processing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有一个输出变量，名为`Color`，该变量被发送到片段着色器。在这种情况下，`Color`只是`VertexColor`的一个未更改的副本。此外，请注意，`VertexPosition`属性只是简单地扩展并传递给内置的`gl_Position`输出变量以进行进一步处理。
- en: 'The fragment shader (`basic.frag.glsl`):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器（`basic.frag.glsl`）：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There is just one input variable for this shader, `Color`. This links to the
    corresponding output variable in the vertex shader, and will contain a value that
    has been interpolated across the triangle based on the values at the vertices.
    We simply expand and copy this color to the `FragColor` output variable (more
    about fragment shader output variables in later recipes).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 该着色器只有一个输入变量，即`Color`。它链接到顶点着色器中的相应输出变量，并将包含一个基于顶点值的插值值。我们只需简单地扩展并复制此颜色到`FragColor`输出变量（有关片段着色器输出变量的更多信息，请参阅后续配方）。
- en: Write code to compile and link these shaders into a shader program (see the *Compiling
    a shader* and *Linking a shader program* recipes). In the following code, I'll
    assume that the handle to the shader program is `programHandle`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码来编译和链接这些着色器到着色器程序中（请参阅*编译着色器*和*链接着色器程序*配方）。在以下代码中，我将假设着色器程序的句柄为`programHandle`。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use the following steps to set up your buffer objects and render the triangle:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤设置缓冲区对象并渲染三角形：
- en: 'Create a global (or private instance) variable to hold our handle to the vertex
    array object:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个全局（或私有实例）变量来保存我们的顶点数组对象句柄：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Within the initialization function, we create and populate the vertex buffer
    objects for each attribute:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化函数中，我们为每个属性创建并填充顶点缓冲区对象：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create and define a vertex array object, which defines the relationship between
    the buffers and the input attributes (see *There''s more...* for an alternate
    way to do this that is valid for OpenGL 4.3 and later):'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并定义一个顶点数组对象，该对象定义了缓冲区与输入属性之间的关系（有关另一种有效于OpenGL 4.3及以后版本的方法，请参阅*更多内容...*）：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the render function, bind to the vertex array object and call `glDrawArrays` to
    initiate the rendering:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染函数中，绑定到顶点数组对象并调用`glDrawArrays`以启动渲染：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Vertex attributes are the input variables to our vertex shader. In the given
    vertex shader, our two attributes are `VertexPosition` and `VertexColor`. The
    main OpenGL program refers to vertex attributes by associating each (active) input
    variable with a generic attribute index. These generic indices are simply integers
    between `0` and `GL_MAX_VERTEX_ATTRIBS - 1`. We can specify the relationship between
    these indices and the attributes using the `layout` qualifier. For example, in
    our vertex shader, we use the layout qualifier to assign `VertexPosition` to attribute
    index `0` and `VertexColor` to attribute index `1`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点属性是我们顶点着色器的输入变量。在给定的顶点着色器中，我们的两个属性是`VertexPosition`和`VertexColor`。主OpenGL程序通过将每个（活动）输入变量与一个通用属性索引关联来引用顶点属性。这些通用索引是介于`0`和`GL_MAX_VERTEX_ATTRIBS
    - 1`之间的简单整数。我们可以使用`layout`限定符来指定这些索引与属性之间的关系。例如，在我们的顶点着色器中，我们使用`layout`限定符将`VertexPosition`分配给属性索引`0`，将`VertexColor`分配给属性索引`1`：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We refer to the vertex attributes in our OpenGL code by referring to the corresponding
    generic vertex attribute index.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过引用相应的通用顶点属性索引来在我们的OpenGL代码中引用顶点属性。
- en: It is not strictly necessary to explicitly specify the mappings between attribute
    variables and generic attribute indexes, because OpenGL will automatically map
    active vertex attributes to generic indexes when the program is linked. We could
    then query for the mappings and determine the indexes that correspond to the shader's
    input variables. It may be somewhat clearer, however, to explicitly specify the
    mapping, as we do in this example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 并非严格必要显式指定属性变量和通用属性索引之间的映射，因为OpenGL在程序链接时会自动将活动顶点属性映射到通用索引。然后我们可以查询这些映射并确定与着色器输入变量对应的索引。然而，显式指定映射可能更清晰，正如我们在本例中所做的那样。
- en: The first step involves setting up a pair of buffer objects to store our position
    and color data. As with most OpenGL objects, we start by creating the objects
    and acquiring handles to the two buffers by calling `glGenBuffers`. We then assign
    each handle to a separate descriptive variable to make the following code more
    clear.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步涉及设置一对缓冲区对象以存储我们的位置和颜色数据。与大多数OpenGL对象一样，我们首先创建对象，并通过调用`glGenBuffers`获取两个缓冲区的句柄。然后，我们将每个句柄分配给单独的描述性变量，以使以下代码更清晰。
- en: For each buffer object, we first bind the buffer to the `GL_ARRAY_BUFFER` binding
    point by calling `glBindBuffer`. The first argument to `glBindBuffer` is the target
    binding point. In this case, since the data is essentially a generic array, we
    use `GL_ARRAY_BUFFER`. Examples of other kinds of targets (such as `GL_UNIFORM_BUFFER` or `GL_ELEMENT_ARRAY_BUFFER`)
    will be seen in later examples.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个缓冲区对象，我们首先通过调用`glBindBuffer`将缓冲区绑定到`GL_ARRAY_BUFFER`绑定点。`glBindBuffer`的第一个参数是目标绑定点。在这种情况下，由于数据本质上是一个通用数组，我们使用`GL_ARRAY_BUFFER`。其他类型的目标（如`GL_UNIFORM_BUFFER`或`GL_ELEMENT_ARRAY_BUFFER`）的示例将在后续示例中看到。
- en: Once our buffer object is bound, we can populate the buffer with our vertex/color
    data by calling `glBufferData`. The second and third arguments to this function
    are the size of the array and a pointer to the array containing the data. Let's
    focus on the first and last arguments. The first argument indicates the target
    buffer object. The data provided in the third argument is copied into the buffer
    that is bound to this binding point. The last argument is one that gives OpenGL
    a hint about how the data will be used so that it can determine how best to manage
    the buffer internally. For full details about this argument, take a look into
    the OpenGL documentation. In our case, the data is specified once, will not be
    modified, and will be used many times for drawing operations, so this usage pattern
    best corresponds to the  `GL_STATIC_DRAW` value.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的缓冲区对象被绑定，我们可以通过调用`glBufferData`来填充缓冲区，其中包含我们的顶点/颜色数据。此函数的第二个和第三个参数是数组的尺寸以及包含数据的数组的指针。让我们关注第一个和最后一个参数。第一个参数指示目标缓冲区对象。第三个参数提供的数据被复制到绑定到此绑定点的缓冲区中。最后一个参数提供了一个OpenGL如何使用数据的提示，以便它可以确定如何最好地在内部管理缓冲区。有关此参数的完整详细信息，请参阅OpenGL文档。在我们的情况下，数据只指定一次，不会修改，并且将被多次用于绘图操作，因此这种使用模式最适合`GL_STATIC_DRAW`值。
- en: Now that we have set up our buffer objects, we tie them together into a **Vertex
    Array Object** (**VAO**). The VAO contains information about the connections between
    the data in our buffers and the input vertex attributes. We create a VAO using
    the `glGenVertexArrays` function. This gives us a handle to our new object, which
    we store in the `vaoHandle` (global) variable. Then, we enable the generic vertex
    attribute indexes `0` and `1` by calling `glEnableVertexAttribArray`. Doing so
    indicates that that the values for the attributes will be accessed and used for
    rendering.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了缓冲区对象，我们将它们绑定在一起形成一个**顶点数组对象**（**VAO**）。VAO包含关于我们缓冲区中的数据与输入顶点属性之间连接的信息。我们使用`glGenVertexArrays`函数创建一个VAO。这为我们提供了对新对象的句柄，我们将其存储在`vaoHandle`（全局）变量中。然后，通过调用`glEnableVertexAttribArray`启用通用顶点属性索引`0`和`1`。这样做表示将访问和使用属性值进行渲染。
- en: 'The next step makes the connection between the buffer objects and the generic
    vertex attribute indexes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是建立缓冲区对象和通用顶点属性索引之间的连接：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, we bind the buffer object to the `GL_ARRAY_BUFFER` binding point, then
    we call `glVertexAttribPointer`, which tells OpenGL which generic index the data
    should be used with, the format of the data stored in the buffer object, and where
    it is located within the buffer object that is bound to the `GL_ARRAY_BUFFER` binding
    point.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将缓冲对象绑定到`GL_ARRAY_BUFFER`绑定点，然后调用`glVertexAttribPointer`，这告诉OpenGL数据应该使用哪个通用索引，缓冲对象中存储的数据格式，以及它在绑定到`GL_ARRAY_BUFFER`绑定点的缓冲对象中的位置。
- en: The first argument is the generic attribute index. The second is the number
    of components per vertex attribute (1, 2, 3, or 4). In this case, we are providing
    three-dimensional data, so we want three components per vertex. The third argument
    is the data type of each component in the buffer. The fourth is a Boolean that
    specifies whether the data should be automatically normalized (mapped to a range
    of [-1, 1] for signed integral values or [0, 1] for unsigned integral values).
    The fifth argument is the stride, which indicates the byte offset between consecutive
    attributes. Since our data is tightly packed, we can use a value of zero. The
    last argument is a pointer, which is not treated as a pointer! Instead, its value
    is interpreted as a byte offset from the beginning of the buffer to the first
    attribute in the buffer. In this case, there is no additional data in either buffer
    before the first element, so we use a value of zero.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是通用属性索引。第二个参数是每个顶点属性组件的数量（1、2、3或4）。在这种情况下，我们提供三维数据，因此我们希望每个顶点有三个组件。第三个参数是缓冲区中每个组件的数据类型。第四个是一个布尔值，指定数据是否应该自动归一化（对于有符号整数值映射到[-1,
    1]或对于无符号整数值映射到[0, 1]）。第五个参数是步长，表示连续属性之间的字节偏移量。由于我们的数据是紧密打包的，我们可以使用零值。最后一个参数是一个指针，它不被视为指针！相反，其值被解释为从缓冲区开始到缓冲区中第一个属性的字节偏移量。在这种情况下，在第一个元素之前，两个缓冲区中都没有额外的数据，所以我们使用零值。
- en: The `glVertexAttribPointer` function stores (in the VAO's state) a pointer to
    the buffer currently bound to the `GL_ARRAY_BUFFER` binding point. When another
    buffer is bound to that binding point, it does not change the value of the pointer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`glVertexAttribPointer`函数将（在VAO的状态中）存储当前绑定到`GL_ARRAY_BUFFER`绑定点的缓冲区的指针。当另一个缓冲区绑定到该绑定点时，它不会改变指针的值。'
- en: The VAO stores all of the OpenGL states related to the relationship between
    buffer objects and the generic vertex attributes, as well as the information about
    the format of the data in the buffer objects. This allows us to quickly return
    all of this state when rendering.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: VAO存储了与缓冲对象和通用顶点属性之间的关系相关的所有OpenGL状态，以及缓冲对象中数据格式的信息。这使得我们可以在渲染时快速返回所有这些状态。
- en: The VAO is an extremely important concept, but can be tricky to understand.
    It's important to remember that the VAO's state is primarily associated with the
    enabled attributes and their connection to buffer objects. It doesn't necessarily
    keep track of buffer bindings. For example, it doesn't remember what is bound
    to the `GL_ARRAY_BUFFER` binding point. We only bind to this point in order to
    set up the pointers via `glVertexAttribPointer`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: VAO（顶点数组对象）是一个极其重要的概念，但理解起来可能有些棘手。重要的是要记住，VAO的状态主要与启用的属性及其与缓冲对象的关系相关联。它不一定跟踪缓冲区绑定。例如，它不会记住绑定到`GL_ARRAY_BUFFER`绑定点的具体内容。我们只绑定到这个点是为了通过`glVertexAttribPointer`设置指针。
- en: Once we have the VAO set up (a one-time operation), we can issue a draw command
    to render our object. In our render function, we clear the color buffer using `glClear`,
    bind to the vertex array object, and call `glDrawArrays` to draw our triangle.
    The `glDrawArrays` function initiates rendering of primitives by stepping through
    the buffers for each enabled attribute array, and passing the data down the pipeline
    to our vertex shader. The first argument is the render mode (in this case, we
    are drawing triangles), the second is the starting index in the enabled arrays,
    and the third argument is the number of indices to be rendered (three vertices
    for a single triangle).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了VAO（这是一个一次性操作），我们就可以发出绘制命令来渲染我们的对象。在我们的渲染函数中，我们使用`glClear`清除颜色缓冲区，绑定到顶点数组对象，并调用`glDrawArrays`来绘制我们的三角形。`glDrawArrays`函数通过遍历每个启用的属性数组缓冲区来初始化原语渲染，并将数据传递到我们的顶点着色器。第一个参数是渲染模式（在这种情况下，我们正在绘制三角形），第二个参数是启用数组中的起始索引，第三个参数是要渲染的索引数（对于单个三角形是三个顶点）。
- en: 'To summarize, we followed these steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们遵循了以下步骤：
- en: Make sure to specify the generic vertex attribute indexes for each attribute
    in the vertex shader using the `layout` qualifier
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在顶点着色器中使用 `layout` 限定符指定每个属性的通用顶点属性索引。
- en: Create and populate the buffer objects for each attribute
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个属性创建和填充缓冲区对象。
- en: Create and define the vertex array object by calling `glVertexAttribPointer` while
    the appropriate buffer is bound
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在适当的缓冲区绑定时调用 `glVertexAttribPointer` 来创建和定义顶点数组对象。
- en: When rendering, bind to the vertex array object and call `glDrawArrays`, or
    an other appropriate rendering function (for example, `glDrawElements`)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染时，绑定到顶点数组对象并调用 `glDrawArrays` 或其他适当的渲染函数（例如，`glDrawElements`）。
- en: There's more...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the following section, we'll discuss some details, extensions, and alternatives
    to the previous technique.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一些关于先前技术的细节、扩展和替代方案。
- en: Separate attribute format
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离属性格式。
- en: With OpenGL 4.3, we have an alternate (arguably better) way of specifying the
    vertex array object state (attribute format, enabled attributes, and buffers).
    In the previous example, the `glVertexAttribPointer` function does two important
    things. First, it indirectly specifies which buffer contains the data for the
    attribute which is the buffer currently bound (at the time of the call) to `GL_ARRAY_BUFFER`.
    Secondly, it specifies the format of that data (type, offset, stride, and so on).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenGL 4.3，我们有另一种（可以说是更好的）指定顶点数组对象状态（属性格式、启用的属性和缓冲区）的方法。在先前的例子中，`glVertexAttribPointer`
    函数做了两件重要的事情。首先，它间接指定了包含属性数据的缓冲区是当前绑定到 `GL_ARRAY_BUFFER` 的缓冲区。其次，它指定了该数据的格式（类型、偏移量、步长等）。
- en: 'It is arguably clearer to separate these two concerns into their own functions.
    This is exactly what has been implemented in OpenGL 4.3\. For example, to implement
    the same functionality as in step 3 of the previous *How to do it...* section,
    we would use the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个关注点分别放入它们自己的函数中可能更清晰。这正是OpenGL 4.3中实现的方式。例如，为了实现先前 *如何做...* 部分的第3步相同的功能，我们会使用以下代码：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first four lines of the previous code are exactly the same as in the first
    example. We create and bind to the VAO, then enable attributes `0` and `1`. Next,
    we bind our two buffers to two different indexes within the vertex buffer binding
    point using `glBindVertexBuffer`. Note that we're no longer using the `GL_ARRAY_BUFFER` binding
    point. Instead, we now have a new binding point specifically for vertex buffers.
    This binding point has several indexes (usually from 0 - 15), so we can bind multiple
    buffers to this point. The first argument to `glBindVertexBuffer` specifies the
    index within the vertex buffer binding point. Here, we bind our position buffer
    to index `0` and our color buffer to index `1`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的前四行与第一个例子中的完全相同。我们创建并绑定到VAO，然后启用属性 `0` 和 `1`。接下来，我们使用 `glBindVertexBuffer`
    将我们的两个缓冲区绑定到顶点缓冲区绑定点内的两个不同索引。注意，我们不再使用 `GL_ARRAY_BUFFER` 绑定点。相反，我们现在有一个专门用于顶点缓冲区的新绑定点。这个绑定点有几个索引（通常从0到15），因此我们可以将多个缓冲区绑定到这个点。`glBindVertexBuffer`
    的第一个参数指定了顶点缓冲区绑定点内的索引。在这里，我们将位置缓冲区绑定到索引 `0`，将颜色缓冲区绑定到索引 `1`。
- en: The indexes within the vertex buffer binding point need not be the same as the
    attribute locations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点缓冲区绑定点内的索引不必与属性位置相同。
- en: The other arguments to `glBindVertexBuffer` are as follows. The second argument
    is the buffer to be bound, the third is the offset from the beginning of the buffer
    to where the data begins, and the fourth is the stride, which is the distance
    between successive elements within the buffer. Unlike `glVertexAttribPointer`,
    we can't use a `0` value here for tightly packed data, because OpenGL can't determine
    the size of the data without more information, so we need to specify it explicitly
    here.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`glBindVertexBuffer` 的其他参数如下。第二个参数是要绑定的缓冲区，第三个参数是从缓冲区开始到数据开始的偏移量，第四个参数是步长，即缓冲区内连续元素之间的距离。与
    `glVertexAttribPointer` 不同，我们在这里不能使用 `0` 值来表示紧密打包的数据，因为OpenGL没有更多信息无法确定数据的大小，因此我们需要在这里明确指定它。'
- en: Next, we call `glVertexAttribFormat` to specify the format of the data for the
    attribute. Note that this time, this is decoupled from the buffer that stores
    the data. Instead, we're just specifying the format to expect for this attribute.
    The arguments are the same as the first four arguments to `glVertexAttribPointer`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用 `glVertexAttribFormat` 来指定属性数据的格式。注意，这次，这已经与存储数据的缓冲区解耦。我们只是指定了期望此属性应具有的格式。参数与
    `glVertexAttribPointer` 的前四个参数相同。
- en: The `glVertexAttribBinding` function specifies the relationship between buffers
    that are bound to the vertex buffer binding point and attributes. The first argument
    is the attribute location, and the second is the index within the vertex buffer
    binding point. In this example, they are the same, but they don't need to be.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`glVertexAttribBinding`函数指定了绑定到顶点缓冲区绑定点的缓冲区与属性之间的关系。第一个参数是属性位置，第二个参数是顶点缓冲区绑定点内的索引。在这个例子中，它们是相同的，但它们不需要是相同的。'
- en: Also note that the buffer bindings of the vertex buffer binding point (specified
    by `glBindVertexBuffer`) are part of the VAO state, unlike the binding to `GL_ARRAY_BUFFER`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，顶点缓冲区绑定点的缓冲区绑定（由`glBindVertexBuffer`指定）是VAO状态的一部分，与绑定到`GL_ARRAY_BUFFER`不同。
- en: This version is arguably clearer and easier to understand. It removes the confusing
    aspects of the *invisible* pointers that are managed in the VAO, and makes the
    relationship between attributes and buffers much clearer with `glVertexAttribBinding`.
    Additionally, it separates concerns that really don't need to be combined.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本可以说是更清晰、更容易理解。它去除了VAO中管理的*不可见*指针的混淆之处，并通过`glVertexAttribBinding`使属性与缓冲区之间的关系更加清晰。此外，它还分离了实际上不需要组合的关心点。
- en: Fragment shader output
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段着色器输出
- en: 'You may have noticed that I''ve neglected to say anything about the  `FragColor` output
    variable in the fragment shader. This variable receives the final output color
    for each fragment (pixel). Like vertex input variables, this variable needs to
    be associated with a proper location. Of course, we would typically like this
    to be linked to the back color buffer, which by default (in double buffered systems)
    is "color number" zero. (The relationship of the color numbers to render buffers
    can be changed by using `glDrawBuffers`). In this program, we are relying on the
    fact that the linker will automatically link our only fragment output variable
    to color number zero. To explicitly do so, we could (and probably should) have
    used a layout qualifier in the fragment shader:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我在片段着色器中忽略了关于`FragColor`输出变量的任何说明。这个变量接收每个片段（像素）的最终输出颜色。像顶点输入变量一样，这个变量需要与一个适当的位置关联。当然，我们通常希望它与后台颜色缓冲区链接，默认情况下（在双缓冲系统中）是“颜色编号”零。（可以通过使用`glDrawBuffers`来改变颜色编号与渲染缓冲区之间的关系。）在这个程序中，我们依赖于链接器会自动将我们的唯一片段输出变量链接到颜色编号零。为了明确这样做，我们可以在片段着色器中使用布局限定符：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are free to define multiple output variables for a fragment shader, thereby
    enabling us to render to multiple output buffers. This can be quite useful for
    specialized algorithms such as deferred rendering (see [Chapter 6](827d2689-d7e7-4188-a7bc-2eb4d813e88d.xhtml), *Image
    Processing and Screen Space Techniques*).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为片段着色器定义多个输出变量，从而使我们能够渲染到多个输出缓冲区。这对于像延迟渲染（见第6章，*图像处理和屏幕空间技术*）这样的专用算法非常有用。
- en: Specifying attribute indexes without using layout qualifiers
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不使用布局限定符指定属性索引
- en: 'If you''d rather not clutter up your vertex shader code with the `layout` qualifiers
    (or you''re using a version of OpenGL that doesn''t support them), you can define
    the attribute indexes within the OpenGL program. We can do so by calling `glBindAttribLocation` just
    prior to linking the shader program. For example, we''d add the following code
    to the main OpenGL program just before the link step:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在顶点着色器代码中添加`layout`限定符（或者你使用的是不支持它们的OpenGL版本），你可以在OpenGL程序中定义属性索引。我们可以通过在链接着色器程序之前调用`glBindAttribLocation`来实现这一点。例如，我们会在链接步骤之前向主OpenGL程序添加以下代码：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This would indicate to the linker that `VertexPosition` should correspond to
    generic attribute index `0` and `VertexColor` to index `1`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示链接器，`VertexPosition`应对应于通用属性索引`0`，而`VertexColor`对应于索引`1`。
- en: 'Similarly, we can specify the color number for the fragment shader output variables
    without using the layout qualifier. We do so by calling `glBindFragDataLocation` prior
    to linking the shader program:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以在不使用布局限定符的情况下指定片段着色器输出变量的颜色编号。我们通过在链接着色器程序之前调用`glBindFragDataLocation`来实现这一点：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This would tell the linker to bind the `FragColor` output variable to color
    number `0`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉链接器将`FragColor`输出变量绑定到颜色编号`0`。
- en: Using element arrays
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用元素数组
- en: It is often the case that we need to step through our vertex arrays in a non-linear
    fashion. In other words, we may want to *jump around* the data rather than just
    move through it from beginning to end. For example, we might want to draw a cube
    where the vertex data consists of only eight positions (the corners of the cube).
    In order to draw the cube, we would need to draw 12 triangles (two for each face),
    each of which consists of three vertices. All of the needed position data is in
    the original eight positions, but to draw all the triangles, we'll need to jump
    around and use each position for at least three different triangles.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们需要以非线性方式遍历我们的顶点数组。换句话说，我们可能想要在数据中“跳转”而不是仅仅从开始到结束移动。例如，我们可能想要绘制一个立方体，其中顶点数据仅由八个位置组成（立方体的角）。为了绘制立方体，我们需要绘制12个三角形（每个面两个），每个三角形由三个顶点组成。所有所需的位置数据都在原始的八个位置中，但为了绘制所有三角形，我们需要跳转并至少使用每个位置三次。
- en: To jump around in our vertex arrays, we can make use of element arrays. The
    element array is another buffer that defines the indices used when stepping through
    the vertex arrays. For details on using element arrays, take a look at the `glDrawElements` function in
    the OpenGL documentation ([http://www.opengl.org/sdk/docs/man](http://www.opengl.org/sdk/docs/man)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在顶点数组中跳转，我们可以利用元素数组。元素数组是另一个缓冲区，它定义了遍历顶点数组时使用的索引。有关使用元素数组的详细信息，请参阅OpenGL文档中的`glDrawElements`函数（[http://www.opengl.org/sdk/docs/man](http://www.opengl.org/sdk/docs/man)）。
- en: Interleaved arrays
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交错数组
- en: In this example, we used two buffers (one for color and one for position). Instead,
    we could have used just a single buffer and combined all of the data. In general,
    it is possible to combine the data for multiple attributes into a single buffer.
    The data for multiple attributes can be interleaved within an array, so that all
    of the data for a given vertex is grouped together within the buffer. Doing so
    just requires careful use of the stride argument to `glVertexAttribPointer` or `glBindVertexBuffer`.
    Take a look at the documentation for full details ([http://www.opengl.org/sdk/docs/man](http://www.opengl.org/sdk/docs/man)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了两个缓冲区（一个用于颜色，一个用于位置）。相反，我们也可以只使用一个缓冲区并将所有数据合并。一般来说，可以将多个属性的数据合并到一个缓冲区中。多个属性的数据可以在数组中交错，这样给定顶点的所有数据都将在缓冲区中分组在一起。这样做只需要仔细使用`glVertexAttribPointer`或`glBindVertexBuffer`的`stride`参数。请参阅完整文档以获取详细信息（[http://www.opengl.org/sdk/docs/man](http://www.opengl.org/sdk/docs/man)）。
- en: The decision about when to use interleaved arrays and when to use separate arrays
    is highly dependent on the situation. Interleaved arrays may bring better results
    due to the fact that data is accessed together and resides closer in memory (so-called
    **locality of reference**), resulting in better caching performance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 关于何时使用交错数组以及何时使用单独数组的决定高度依赖于具体情况。由于数据是同时访问且在内存中更接近（所谓的**引用局部性**），交错数组可能会带来更好的结果，从而实现更好的缓存性能。
- en: See also
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter02/scenebasic_attrib.cpp` file in the example code
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter02/scenebasic_attrib.cpp`文件
- en: Getting a list of active vertex input attributes and locations
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取活动顶点输入属性和位置的列表
- en: As covered in the previous recipe, the input variables within a vertex shader
    are linked to generic vertex attribute indices at the time the program is linked.
    If we need to specify the relationship, we can either use layout qualifiers within
    the shader, or we could call `glBindAttribLocation` before linking.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，顶点着色器中的输入变量在程序链接时与通用的顶点属性索引相链接。如果我们需要指定关系，我们可以在着色器中使用布局限定符，或者在链接之前调用`glBindAttribLocation`。
- en: However, it may be preferable to let the linker create the mappings automatically
    and query for them after program linking is complete. In this recipe, we'll see
    a simple example that prints all the active attributes and their indices.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能更倾向于让链接器自动创建映射，并在程序链接完成后查询它们。在这个例子中，我们将看到一个简单的示例，该示例打印出所有活动属性及其索引。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start with an OpenGL program that compiles and links a shader pair. You could
    use the shaders from the previous recipe.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个编译并链接了着色器对的OpenGL程序开始。您可以使用前一个示例中的着色器。
- en: As in previous recipes, we'll assume that the handle to the shader program is
    stored in a variable named `programHandle`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将假设着色器程序的句柄存储在一个名为`programHandle`的变量中。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'After linking and enabling the shader program, use the following code to display
    the list of active attributes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接和启用着色器程序后，使用以下代码来显示活动属性列表：
- en: 'Start by querying for the number of active attributes:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先查询活动属性的数目：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Loop through each attribute, query for the length of the name, the type, and
    the attribute location, and print the results to standard out:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历每个属性，查询名称长度、类型和属性位置，并将结果打印到标准输出：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In step 1, we query for the number of active attributes by calling `glGetProgramInterfaceiv`.
    The first argument is the handle to the program object, and the second (`GL_PROGRAM_INPUT`)
    indicates that we are querying for information about the program input variables
    (the vertex attributes). The third argument (`GL_ACTIVE_RESOURCES`) indicates
    that we want the number of active resources. The result is stored in the location
    pointed to by the last argument, `numAttribs`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们通过调用`glGetProgramInterfaceiv`来查询活动属性的数目。第一个参数是程序对象的句柄，第二个参数（`GL_PROGRAM_INPUT`）表示我们正在查询程序输入变量（顶点属性）的信息。第三个参数（`GL_ACTIVE_RESOURCES`）表示我们想要得到活动资源的数目。结果存储在最后一个参数`numAttribs`指向的位置。
- en: Now that we have the number of attributes, we query for information about each
    one. The indices of the attributes run from `0` to `numAttribs-1`. We loop over
    those indices and for each we call `glGetProgramResourceiv` to get the length
    of the name, the type, and the location. We specify what information we would
    like to receive by means of an array of `GLenum` values called `properties`. The
    first argument is the handle to the program object, the second is the resource
    that we are querying (`GL_PROGRAM_INPUT`). The third is the index of the attribute
    and the fourth is the number of values in the `properties` array, which is the
    fifth argument. The `properties` array contains `GLenum` values, which specify
    the specific properties we would like to receive. In this example, the array contains  `GL_NAME_LENGTH`, `GL_TYPE`,
    and `GL_LOCATION`, which indicates that we want the length of the attribute's
    name, the data type of the attribute, and its location. The sixth argument is
    the size of the buffer that will receive the results; the seventh argument is
    a pointer to an integer that would receive the number of results that were written.
    If that argument is `NULL`, then no information is provided. Finally, the last
    argument is a pointer to a `GLint` array that will receive the results. Each item
    in the `properties` array corresponds to the same index in the `results` array.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了属性的数目，接下来我们查询每个属性的信息。属性的索引从`0`到`numAttribs-1`。我们遍历这些索引，并对每个索引调用`glGetProgramResourceiv`来获取名称长度、类型和位置。我们通过一个名为`properties`的`GLenum`值数组来指定我们想要接收的信息。第一个参数是程序对象的句柄，第二个是我们要查询的资源（`GL_PROGRAM_INPUT`）。第三个是属性的索引，第四个是`properties`数组中的值数，这是第五个参数。`properties`数组包含`GLenum`值，这些值指定了我们想要接收的具体属性。在这个例子中，数组包含`GL_NAME_LENGTH`、`GL_TYPE`和`GL_LOCATION`，这表示我们想要得到属性名称的长度、属性的数据类型以及它的位置。第六个参数是接收结果的缓冲区的大小；第七个参数是一个指向整数的指针，该整数将接收写入的结果数目。如果该参数是`NULL`，则不提供任何信息。最后，最后一个参数是一个指向`GLint`数组的指针，该数组将接收结果。`properties`数组中的每个项对应于`results`数组中的相同索引。
- en: Next, we retrieve the name of the attribute by allocating a buffer to store
    the name and calling `glGetProgramResourceName`. The `results` array contains
    the length of the name in the first element, so we allocate an array of that size
    with an extra character just for good measure. The OpenGL documentation says that
    the size returned from `glGetProgramResourceiv` includes the null terminator,
    but it doesn't hurt to make sure by making a bit of additional space. In my tests,
    I've found this to be necessary on the latest NVIDIA drivers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过分配一个缓冲区来存储名称并调用`glGetProgramResourceName`来检索属性名称。`results`数组的第一元素包含名称的长度，因此我们分配一个大小为该数组的数组，并额外分配一个字符以确保安全。OpenGL文档说明，从`glGetProgramResourceiv`返回的大小包括空终止符，但为了确保这一点，我们留出一些额外的空间。在我的测试中，我发现这对于最新的NVIDIA驱动程序是必要的。
- en: Finally, we get the name by calling `glGetProgramResourceName`, and then print
    the information to the screen. We print the attribute's location, name, and type.
    The location is available in the third element of the `results` array, and the
    type is in the second. Note the use of the `getTypeString` function. This is a
    simple custom function that just returns a string representation of the data type.
    The data type is represented by one of the OpenGL defined constants, such as `GL_FLOAT`, `GL_FLOAT_VEC2`,
    or `GL_FLOAT_VEC3`. The `getTypeString` function consists of just one big `switch`
    statement returning a human-readable string corresponding to the value of the
    parameter (see the source code for `glslprogram.cpp` in the example code for this
    book).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过调用`glGetProgramResourceName`获取名称，然后将信息打印到屏幕上。我们打印属性的位置、名称和类型。位置在`results`数组的第三个元素中，类型在第二个元素中。注意`getTypeString`函数的使用。这是一个简单的自定义函数，它只返回数据类型的字符串表示。数据类型由OpenGL定义的常量表示，例如`GL_FLOAT`、`GL_FLOAT_VEC2`或`GL_FLOAT_VEC3`。`getTypeString`函数仅包含一个大的`switch`语句，返回与参数值对应的人类可读字符串（请参阅本书示例代码中`glslprogram.cpp`的源代码）。
- en: 'The output of the previous code looks like this when it is run on the shaders
    from the previous recipes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当在先前的配方中的着色器上运行先前代码的输出如下所示：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: It should be noted that in order for a vertex shader input variable to be considered
    active, it must be used within the vertex shader. In other words, a variable is
    considered active if it is determined by the GLSL linker that it may be accessed
    during program execution. If a variable is declared within a shader, but not used,
    the previous code will not display the variable because it is not considered active
    and is effectively ignored by OpenGL.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，为了使顶点着色器输入变量被视为活动状态，它必须在顶点着色器中使用。换句话说，如果GLSL链接器确定变量在程序执行期间可能被访问，则该变量被视为活动状态。如果一个变量在着色器中声明但未使用，则前述代码不会显示该变量，因为它不被视为活动状态，并且实际上被OpenGL忽略。
- en: The previous code is only valid for OpenGL 4.3 and later. Alternatively, you
    can achieve similar results with the `glGetProgramiv`, `glGetActiveAttrib`, and `glGetAttribLocation` functions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码仅适用于OpenGL 4.3及更高版本。或者，您可以使用`glGetProgramiv`、`glGetActiveAttrib`和`glGetAttribLocation`函数实现类似的结果。
- en: See also
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter02/scenebasic_attrib.cpp` file in the example code
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter02/scenebasic_attrib.cpp`文件
- en: The *Compiling a shader* recipe
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编译着色器*的配方'
- en: The *Linking a shader program* recipe
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*链接着色器程序*的配方'
- en: The *Sending data to a shader using vertex attributes and vertex buffer objects* recipe
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用顶点属性和顶点缓冲对象向着色器发送数据*的配方'
- en: Sending data to a shader using uniform variables
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用统一变量向着色器发送数据
- en: Vertex attributes offer one avenue for providing input to shaders; a second
    technique is uniform variables. Uniform variables are intended to be used for
    data that may change relatively infrequently compared to per-vertex attributes.
    In fact, it is simply not possible to set per-vertex attributes with uniform variables.
    For example, uniform variables are well-suited to the matrices used for modeling,
    viewing, and projective transformations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点属性提供了一种向着色器提供输入的方法；第二种技术是统一变量。统一变量旨在用于与每个顶点属性相比相对不经常变化的数据。实际上，使用统一变量设置每个顶点的属性是不可能的。例如，统一变量非常适合用于建模、视图和投影变换的矩阵。
- en: Within a shader, uniform variables are read-only. Their values can only be changed
    from outside the shader, via the OpenGL API. However, they can be initialized
    within the shader by assigning them to a constant value along with the declaration.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器内部，统一变量是只读的。它们的值只能通过OpenGL API从外部更改。然而，它们可以在声明时在着色器内部初始化，通过将它们分配给一个常量值。
- en: Uniform variables can appear in any shader within a shader program, and are
    always used as input variables. They can be declared in one or more shaders within
    a program, but if a variable with a given name is declared in more than one shader,
    its type must be the same in all shaders. In other words, the uniform variables
    are held in a shared uniform namespace for the entire shader program.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 统一变量可以出现在着色器程序中的任何着色器中，并且始终用作输入变量。它们可以在程序中的一个或多个着色器中声明，但如果一个变量在多个着色器中声明，其类型必须在所有着色器中相同。换句话说，统一变量在整个着色器程序中保存在一个共享的统一命名空间中。
- en: 'In this recipe, we''ll draw the same triangle as in previous recipes in this
    chapter; however, this time, we''ll rotate the triangle using a uniform matrix
    variable:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将绘制本章之前食谱中相同的三角形；然而，这次，我们将使用统一矩阵变量旋转三角形：
- en: '![](img/63ba2410-bddf-4413-86b5-636e56c72d83.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/63ba2410-bddf-4413-86b5-636e56c72d83.png)'
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll use the following vertex shader:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下顶点着色器：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the `RotationMatrix` variable is declared using the uniform qualifier.
    We'll provide the data for this variable via the OpenGL program. The `RotationMatrix` variable is
    also used to transform `VertexPosition` before assigning it to the default output
    position variable, `gl_Position`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`RotationMatrix`变量是使用统一限定符声明的。我们将通过OpenGL程序提供这个变量的数据。`RotationMatrix`变量也用于在将`VertexPosition`分配给默认输出位置变量`gl_Position`之前对其进行变换。
- en: 'We''ll use the same fragment shader as in the previous recipes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与之前食谱相同的片段着色器：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Within the main OpenGL code, we determine the rotation matrix and send it to
    the shader''s uniform variable. To create our rotation matrix, we''ll use the
    GLM library (see the *Using the GLM for mathematics* recipe). Within the main
    OpenGL code, add the following include statements:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在主OpenGL代码中，我们确定旋转矩阵并将其发送到着色器的统一变量。为了创建我们的旋转矩阵，我们将使用GLM库（参见*使用GLM进行数学*食谱）。在主OpenGL代码中，添加以下包含语句：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We'll also assume that code has been written to compile and link the shaders,
    and to create the vertex array object for the color triangle. We'll assume that
    the handle to the vertex array object is `vaoHandle`, and the handle to the program
    object is `programHandle`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设已经编写了编译和链接着色器以及创建颜色三角形顶点数组对象的代码。我们假设顶点数组对象的句柄是`vaoHandle`，程序对象的句柄是`programHandle`。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Within the render method, use the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染方法中，使用以下代码：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The steps involved in setting the value of a uniform variable include finding
    the location of the variable, and assigning a value to that location using one
    of the `glUniform` functions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 设置统一变量值的步骤包括找到变量的位置，并使用`glUniform`函数之一将该值分配到该位置。
- en: In this example, we start by clearing the color buffer, then creating a rotation
    matrix using GLM. Next, we query for the location of the uniform variable by calling `glGetUniformLocation`.
    This function takes the handle to the shader program object and the name of the
    uniform variable, and returns its location. If the uniform variable is not an
    active uniform variable, the function returns `-1`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先清除颜色缓冲区，然后使用GLM创建一个旋转矩阵。接下来，通过调用`glGetUniformLocation`查询统一变量的位置。这个函数接收着色程序对象的句柄和统一变量的名称，并返回其位置。如果统一变量不是一个活动的统一变量，该函数返回`-1`。
- en: It is inefficient to query the location of a uniform variable in each frame.
    A more efficient approach would be to cache the location during the shader compilation
    stage, and use it here.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧中查询统一变量的位置是不高效的。一个更高效的方法是在着色器编译阶段缓存位置，并在这里使用它。
- en: We then assign a value to the uniform variable's location using `glUniformMatrix4fv`.
    The first argument is the uniform variable's location. The second is the number
    of matrices that are being assigned (note that the uniform variable could be an
    array). The third is a Boolean value indicating whether the matrix should be transposed
    when loaded into the uniform variable. With GLM matrices, a transpose is not required,
    so we use `GL_FALSE` here. If you were implementing the matrix using an array,
    and the data was in row-major order, you might need to use `GL_TRUE` for this
    argument. The last argument is a pointer to the data for the uniform variable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`glUniformMatrix4fv`将值分配给统一变量的位置。第一个参数是统一变量的位置。第二个是正在分配的矩阵数量（注意，统一变量可能是一个数组）。第三个是一个布尔值，指示在加载到统一变量时矩阵是否应该被转置。对于GLM矩阵，不需要转置，所以我们在这里使用`GL_FALSE`。如果您使用数组实现矩阵，并且数据是按行主序排列的，您可能需要为这个参数使用`GL_TRUE`。最后一个参数是指向统一变量数据的指针。
- en: There's more...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Of course, uniform variables can be any valid GLSL type, including complex types
    such as arrays or structures. OpenGL provides a `glUniform` function with the
    usual suffixes, appropriate for each type. For example, to assign to a variable
    of the `vec3` type, one would use `glUniform3f` or `glUniform3fv`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，统一变量可以是任何有效的GLSL类型，包括数组或结构体等复杂类型。OpenGL提供了一个带有常用后缀的 `glUniform` 函数，适用于每种类型。例如，要将值分配给
    `vec3` 类型的变量，可以使用 `glUniform3f` 或 `glUniform3fv`。
- en: 'For arrays, one can use the functions ending in `v` to initialize multiple
    values within the array. Note that if it is desired, one can query for the location
    of a particular element of the uniform array using the `[]` operator. For example,
    to query for the location of the second element of `MyArray`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组，可以使用以 `v` 结尾的函数在数组内部初始化多个值。请注意，如果需要，可以使用 `[]` 操作符查询统一数组的特定元素的位置。例如，要查询
    `MyArray` 的第二个元素的位置：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For structures, the members of the structure must be initialized individually.
    As with arrays, one can query for the location of a member of a structure using
    something like the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构体，结构体的成员必须单独初始化。与数组一样，可以使用类似以下方式查询结构体成员的位置：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Where the structure variable is `MyMatrices` and the member of the structure
    is `Rotation`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当结构变量是 `MyMatrices` 且结构体成员是 `Rotation` 时。
- en: See also
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见：
- en: The `chapter02/scenebasic_uniform.cpp` file in the example code
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter02/scenebasic_uniform.cpp` 文件
- en: The *Compiling a shader* recipe
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编译着色器* 配方'
- en: The *Linking a shader program* recipe
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*链接着色器程序* 配方'
- en: The *Sending data to a shader using vertex attributes and vertex buffer objects* recipe
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用顶点属性和顶点缓冲对象发送数据到着色器* 的配方'
- en: Getting a list of active uniform variables
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取活动统一变量列表
- en: While it is a simple process to query for the location of an individual uniform
    variable, there may be instances where it can be useful to generate a list of
    all active uniform variables. For example, one might choose to create a set of
    variables to store the location of each uniform and assign their values after
    the program is linked. This would avoid the need to query for uniform locations
    when setting the value of the uniform variables, creating slightly more efficient
    code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然查询单个统一变量位置的过程很简单，但可能存在一些情况下生成所有活动统一变量的列表是有用的。例如，有人可能会选择创建一组变量来存储每个统一变量的位置，并在程序链接后分配它们的值。这将避免在设置统一变量值时查询统一变量位置的需要，从而创建略微更高效的代码。
- en: The process for listing uniform variables is very similar to the process for
    listing attributes (see the *Getting a list of active vertex input attributes
    and locations* recipe), so this recipe will refer the reader back to the previous
    recipe for a detailed explanation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列出统一变量的过程与列出属性的过程非常相似（参见 *获取活动顶点输入属性和位置列表* 配方），因此本配方将引导读者回顾先前的配方以获取详细解释。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start with a basic OpenGL program that compiles and links a shader program.
    In the following recipes, we'll assume that the handle to the program is in a
    variable named `programHandle`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个基本的OpenGL程序开始，该程序编译并链接一个着色器程序。在接下来的配方中，我们将假设程序句柄存储在一个名为 `programHandle` 的变量中。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'After linking and enabling the shader program, use the following code to display
    the list of active uniforms:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接并启用着色器程序后，使用以下代码来显示活动统一变量的列表：
- en: 'Start by querying for the number of active uniform variables:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先查询活动统一变量的数量：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Loop through each uniform index and query for the length of the name, the type,
    the location, and the block index:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历每个统一索引并查询名称长度、类型、位置和块索引：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The process is very similar to the process shown in the *Getting a list of active
    vertex input attributes and locations* recipe. I will focus on the main differences.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程与 *获取活动顶点输入属性和位置列表* 配方中显示的过程非常相似。我将专注于主要差异。
- en: The first and most obvious is that we use `GL_UNIFORM` instead of `GL_PROGRAM_INPUT` as
    the interface that we are querying in `glGetProgramResourceiv` and `glGetProgramInterfaceiv`.
    Second, we query for the block index (using `GL_BLOCK_INDEX` in the `properties` array).
    The reason for this is that some uniform variables are contained within a uniform
    block (see the *Using uniform blocks and uniform buffer objects* recipe). For
    this example, we only want information about uniforms that are not within blocks.
    The block index will be `-1` if the uniform variable is not within a block, so
    we skip any uniform variables that do not have a block index of `-1`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一也是最明显的是，我们在`glGetProgramResourceiv`和`glGetProgramInterfaceiv`中查询的接口使用`GL_UNIFORM`而不是`GL_PROGRAM_INPUT`。其次，我们查询块索引（在`properties`数组中使用`GL_BLOCK_INDEX`）。这样做的原因是某些统一变量包含在统一块中（见*使用统一块和统一缓冲对象*配方）。对于这个例子，我们只想了解不在块中的统一变量的信息。如果统一变量不在块中，块索引将是`-1`，所以我们跳过任何没有块索引为`-1`的统一变量。
- en: Again, we use the `getTypeString` function to convert the type value into a
    human-readable string (see the example code).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用`getTypeString`函数将类型值转换为人类可读的字符串（见示例代码）。
- en: 'When this is run on the shader program from the previous recipe, we see the
    following output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当从这个先前的配方中的着色器程序运行时，我们看到了以下输出：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There's more...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As with vertex attributes, a uniform variable is not considered active unless
    it is determined by the GLSL linker that it will be used within the shader.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与顶点属性一样，除非GLSL链接器确定它将在着色器中使用，否则统一变量不被视为活动状态。
- en: The previous code is only valid for OpenGL 4.3 and later. Alternatively, you
    can achieve similar results using the `glGetProgramiv`, `glGetActiveUniform`, `glGetUniformLocation`,
    and `glGetActiveUniformName` functions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码仅适用于OpenGL 4.3及以后版本。或者，您可以使用`glGetProgramiv`、`glGetActiveUniform`、`glGetUniformLocation`和`glGetActiveUniformName`函数实现类似的结果。
- en: See also
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter02/scenebasic_uniform.cpp` file in the example code
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter02/scenebasic_uniform.cpp`文件
- en: The *Sending data to a shader using uniform variables* recipe
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用统一变量将数据发送到着色器*配方'
- en: Using uniform blocks and uniform buffer objects
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用统一块和统一缓冲对象
- en: If your program involves multiple shader programs that use the same uniform
    variables, one has to manage the variables separately for each program. Uniform
    locations are generated when a program is linked, so the locations of the uniforms
    may change from one program to the next. The data for those uniforms may have
    to be regenerated and applied to the new locations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序涉及多个使用相同统一变量的着色器程序，必须为每个程序分别管理变量。统一位置在程序链接时生成，因此统一位置可能会从一个程序变化到下一个程序。这些统一变量的数据可能需要重新生成并应用到新的位置。
- en: Uniform blocks were designed to ease the sharing of uniform data between programs.
    With uniform blocks, one can create a buffer object for storing the values of
    all the uniform variables, and bind the buffer to the uniform block. When changing
    programs, the same buffer object need only be rebound to the corresponding block
    in the new program.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 统一块被设计用来简化程序间统一数据的共享。使用统一块，可以创建一个缓冲对象来存储所有统一变量的值，并将缓冲绑定到统一块上。当改变程序时，只需将相同的缓冲对象重新绑定到新程序中相应的块。
- en: 'A uniform block is simply a group of uniform variables defined within a syntactical
    structure known as a uniform block. For example, in this recipe, we''ll use the
    following uniform block:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 统一块简单地说是在称为统一块的语法结构内定义的一组统一变量。例如，在这个配方中，我们将使用以下统一块：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This defines a block with the name `BlobSettings` that contains four uniform
    variables. With this type of block definition, the variables within the block
    are still part of the global scope and do not need to be qualified with the block
    name.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个名为`BlobSettings`的块，其中包含四个统一变量。使用这种类型的块定义，块内的变量仍然是全局作用域的一部分，不需要用块名称限定。
- en: The buffer object used to store the data for the uniforms is often referred
    to as a **uniform buffer object**. We'll see that a uniform buffer object is simply
    a buffer object that is bound to a certain location.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 用于存储统一变量数据的缓冲对象通常被称为**统一缓冲对象**。我们将看到统一缓冲对象只是一个绑定到特定位置的缓冲对象。
- en: 'For this recipe, we''ll use a simple example to demonstrate the use of uniform
    buffer objects and uniform blocks. We''ll draw a quad (two triangles) with texture
    coordinates, and use our fragment shader to fill the quad with a fuzzy circle.
    The circle is a solid color in the center, but at its edge, it gradually fades
    to the background color, as shown in the following image:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用一个简单的示例来演示统一缓冲对象和统一块的使用。我们将绘制一个带有纹理坐标的四边形（两个三角形），并使用我们的片段着色器用模糊圆圈填充四边形。圆圈在中心是实色，但在边缘逐渐过渡到背景色，如图所示：
- en: '![](img/6e480890-1446-4636-90e1-48aeb854b174.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6e480890-1446-4636-90e1-48aeb854b174.png)'
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start with an OpenGL program that draws two triangles to form a quad. Provide
    the position at vertex attribute location `0`, and the texture coordinate (0 to
    1 in each direction) at vertex attribute location `1` (see the *Sending data to
    a shader using vertex attributes and vertex buffer objects* recipe).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个绘制两个三角形以形成一个四边形的 OpenGL 程序开始。在顶点属性位置 `0` 提供位置，在顶点属性位置 `1` 提供纹理坐标（每个方向从 0
    到 1）（参见 *使用顶点属性和顶点缓冲对象向着色器发送数据* 菜谱）。
- en: 'We''ll use the following vertex shader:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下顶点着色器：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The fragment shader contains the uniform block, and is responsible for drawing
    our
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器包含统一块，并负责绘制我们的
- en: 'fuzzy circle:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊圆圈：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note the uniform block named `BlobSettings`. The variables within this block
    define the parameters of our fuzzy circle. The `OuterColor` variable defines the
    color outside of the circle. `InnerColor` is the color inside of the circle. `RadiusInner` is
    the radius that defines the part of the circle that is a solid color (inside the
    fuzzy edge), and the distance from the center of the circle to the inner edge
    of the fuzzy boundary. `RadiusOuter` is the outer edge of the fuzzy boundary of
    the circle (when the color is equal to `OuterColor`).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意名为 `BlobSettings` 的统一块。该块内的变量定义了模糊圆圈的参数。`OuterColor` 变量定义了圆圈外的颜色。`InnerColor`
    是圆圈内的颜色。`RadiusInner` 是定义圆圈中实色部分（模糊边缘内部）的半径，以及圆心到模糊边界内边缘的距离。`RadiusOuter` 是圆的模糊边界的边缘（当颜色等于
    `OuterColor` 时）。
- en: The code within the main function computes the distance of the texture coordinate
    to the center of the quad located at (`0.5`, `0.5`). It then uses that distance
    to compute the color by using the `smoothstep` function. This function provides
    a value that smoothly varies between 0.0 and 1.0 when the value of the third argument
    is between the values of the first two arguments. Otherwise, it returns `0.0`
    or `1.0`, depending on whether `dist` is less than the first or greater than the
    second, respectively. The `mix` function is then used to linearly interpolate
    between `InnerColor` and `OuterColor` based on the value returned by the `smoothstep` function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 主函数内的代码计算纹理坐标到位于 (`0.5`, `0.5`) 的四边形中心的距离。然后使用该距离通过 `smoothstep` 函数计算颜色。当第三个参数的值位于前两个参数的值之间时，该函数提供一个在
    0.0 和 1.0 之间平滑变化的值。否则，它返回 `0.0` 或 `1.0`，具体取决于 `dist` 是否小于第一个或大于第二个。然后使用 `mix`
    函数根据 `smoothstep` 函数返回的值在 `InnerColor` 和 `OuterColor` 之间进行线性插值。
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the OpenGL program, after linking the shader program, use the following
    steps to assign data to the uniform block in the fragment shader:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenGL 程序中，在链接着色器程序后，使用以下步骤将数据分配给片段着色器中的统一块：
- en: 'Get the index of the uniform block using `glGetUniformBlockIndex`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glGetUniformBlockIndex` 获取统一块的索引：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Allocate space for the buffer to contain the data for the uniform block. We
    get the size using `glGetActiveUniformBlockiv`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为缓冲区分配空间以包含统一块的数据。我们使用 `glGetActiveUniformBlockiv` 获取大小：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Query for the offset of each variable within the block. To do so, we first
    find the index of each variable within the block:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询块中每个变量的偏移量。为此，我们首先找到块中每个变量的索引：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Place the data into the buffer at the appropriate offsets:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据放置在缓冲区中适当的偏移量：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create the buffer object and copy the data into it:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建缓冲对象并将数据复制到其中：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Bind the buffer object to the uniform buffer-binding point at the index specified
    by the binding-layout qualifier in the fragment shader (`0`):'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将缓冲对象绑定到由片段着色器中的绑定布局限定符指定的索引处的统一缓冲区绑定点（`0`）：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Phew! This seems like a lot of work! However, the real advantage comes when
    using multiple programs where the same buffer object can be used for each program.
    Let's take a look at each step individually.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这似乎是很多工作！然而，真正的优势在于使用多个程序时，相同的缓冲区对象可以用于每个程序。让我们逐个步骤地看一下。
- en: First, we get the index of the uniform block by calling `glGetUniformBlockIndex`,
    then we query for the size of the block by calling `glGetActiveUniformBlockiv`.
    After getting the size, we allocate a temporary buffer named `blockBuffer` to
    hold the data for our block.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过调用`glGetUniformBlockIndex`来获取均匀块的索引，然后通过调用`glGetActiveUniformBlockiv`来查询块的大小。在获取大小之后，我们分配一个名为`blockBuffer`的临时缓冲区来存储我们块的数据。
- en: The layout of data within a uniform block is implementation-dependent, and implementations
    may use different padding and/or byte alignment. So in order to accurately lay
    out our data, we need to query for the offset of each variable within the block.
    This is done in two steps. First, we query for the index of each variable within
    the block by calling `glGetUniformIndices`. This accepts an array of the `names` variable
    (third argument) and returns the indices of the variables in the `indices` array (fourth
    argument). Then, we use the indices to query for the offsets by calling `glGetActiveUniformsiv`.
    When the fourth argument is `GL_UNIFORM_OFFSET`, this returns the offset of each
    variable in the array pointed to by the fifth argument. This function can also
    be used to query for the size and type, however, in this case we choose not to
    do so in order to keep the code simple (albeit less general).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 均匀块内数据布局是实现的依赖，实现可能使用不同的填充和/或字节对齐。因此，为了准确地布局我们的数据，我们需要查询块中每个变量的偏移量。这是通过两个步骤完成的。首先，我们通过调用`glGetUniformIndices`查询块中每个变量的索引。这个函数接受一个`names`变量数组（第三个参数）并返回变量在`indices`数组（第四个参数）中的索引。然后，我们使用这些索引通过调用`glGetActiveUniformsiv`查询偏移量。当第四个参数是`GL_UNIFORM_OFFSET`时，这个函数返回指向第五个参数所指向的数组的每个变量的偏移量。这个函数也可以用来查询大小和类型，然而，在这种情况下我们选择不这样做，以保持代码简单（尽管不那么通用）。
- en: The next step involves filling our temporary buffer, `blockBuffer`, with the
    data for the uniforms at the appropriate offsets. Here, we use the standard library
    function, `memcpy`, to accomplish this.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是填充我们的临时缓冲区`blockBuffer`，以包含均匀数据的适当偏移量。在这里，我们使用标准库函数`memcpy`来完成这个任务。
- en: Now that the temporary buffer is populated with the data with the appropriate
    layout, we can create our buffer object and copy the data into the buffer object.
    We call `glGenBuffers` to generate a buffer handle, and then bind that buffer
    to the `GL_UNIFORM_BUFFER` binding point by calling `glBindBuffer`. The space
    is allocated within the buffer object and the data is copied when `glBufferData` is
    called. We use `GL_DYNAMIC_DRAW` as the usage hint here because uniform data may
    be changed somewhat often during rendering. Of course, this is entirely dependent
    on the situation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在临时缓冲区已经填充了具有适当布局的数据，我们可以创建我们的缓冲区对象并将数据复制到缓冲区对象中。我们调用`glGenBuffers`来生成缓冲区句柄，然后通过调用`glBindBuffer`将缓冲区绑定到`GL_UNIFORM_BUFFER`绑定点。在调用`glBufferData`时，在缓冲区对象内分配空间并复制数据。我们在这里使用`GL_DYNAMIC_DRAW`作为使用提示，因为均匀数据在渲染过程中可能会被频繁更改。当然，这完全取决于具体情况。
- en: Finally, we associate the buffer object with the uniform block by calling `glBindBufferBase`.
    This function binds to an index within a buffer binding point. Certain binding
    points are also called **indexed buffer targets**. This means that the target
    is actually an array of targets, and `glBindBufferBase` allows us to bind to one
    index within the array. In this case, we bind it to the index that we specified
    in the layout qualifier in the fragment shader: `layout (binding = 0)` (see *Getting
    ready*). These two indices must match.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用`glBindBufferBase`将缓冲区对象与均匀块关联起来。这个函数绑定到缓冲区绑定点内的一个索引。某些绑定点也被称为**索引缓冲区目标**。这意味着目标实际上是一个目标数组，而`glBindBufferBase`允许我们在数组中绑定到一个索引。在这种情况下，我们将其绑定到片段着色器中布局限定符中指定的索引：`layout
    (binding = 0)`（见*准备就绪*）。这两个索引必须匹配。
- en: You might be wondering why we use `glBindBuffer` and `glBindBufferBase` with `GL_UNIFORM_BUFFER`.
    Aren't these the same binding points used in two different contexts? The answer
    is that the `GL_UNIFORM_BUFFER` point can be used in each function with a slightly
    different meaning. With `glBindBuffer`, we bind to a point that can be used for
    filling or modifying a buffer, but can't be used as a source of data for the shader.
    When we use `glBindBufferBase`, we are binding to an index within a location that
    can be directly sourced by the shader. Granted, that's a bit confusing.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们使用 `glBindBuffer` 和 `glBindBufferBase` 与 `GL_UNIFORM_BUFFER`。这些不是在两个不同上下文中使用的相同绑定点吗？答案是
    `GL_UNIFORM_BUFFER` 点可以在每个函数中使用，但含义略有不同。使用 `glBindBuffer` 时，我们绑定到一个可以用于填充或修改缓冲区的点，但不能用作着色器的数据源。当我们使用
    `glBindBufferBase` 时，我们绑定到一个位置索引，该索引可以直接由着色器使用。当然，这有点令人困惑。
- en: There's more...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If the data for a uniform block needs to be changed at some later time, one
    can call `glBufferSubData` to replace all or part of the data within the buffer.
    If you do so, don't forget to first bind the buffer to the generic binding point, `GL_UNIFORM_BUFFER`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在稍后的某个时间改变统一块的数据，可以使用 `glBufferSubData` 调用来替换缓冲区内的全部或部分数据。如果你这样做，别忘了首先将缓冲区绑定到通用绑定点
    `GL_UNIFORM_BUFFER`。
- en: Using an instance name with a uniform block
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用统一块实例名称
- en: 'A uniform block can have an optional instance name. For example, with our `BlobSettings` block,
    we could have used the instance name `Blob`, as shown here:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 统一块可以有一个可选的实例名称。例如，对于我们的 `BlobSettings` 块，我们可能使用了实例名称 `Blob`，如下所示：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this case, the variables within the block are placed within a namespace
    qualified by the instance name. Therefore, our shader code needs to refer to them
    prefixed with the instance name. For example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，块内的变量被放置在一个由实例名称限定的命名空间中。因此，我们的着色器代码需要使用实例名称作为前缀来引用它们。例如：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Additionally, we need to qualify the variable names (with the `BlobSettings` block
    name) within the OpenGL code when querying for variable indices:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当查询变量索引时，我们还需要在 OpenGL 代码中对变量名称（使用 `BlobSettings` 块名称）进行限定：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using layout qualifiers with uniform blocks
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用统一块布局限定符
- en: 'Since the layout of the data within a uniform buffer object is implementation-dependent,
    it required us to query for the variable offsets. However, one can avoid this
    by asking OpenGL to use the standard layout, `std140`. This is accomplished by
    using a layout qualifier when declaring the uniform block. For example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于统一缓冲区对象内部的数据布局是依赖于实现的，这要求我们查询变量偏移量。然而，可以通过请求 OpenGL 使用标准布局 `std140` 来避免这种情况。这是通过在声明统一块时使用布局限定符来实现的。例如：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `std140` layout is described in detail within the OpenGL specification document
    (available at [http://www.opengl.org](http://www.opengl.org)).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`std140` 布局在 OpenGL 规范文档中有详细描述（可在 [http://www.opengl.org](http://www.opengl.org)
    获取）。'
- en: Other options for the layout qualifier that apply to uniform block layouts include `packed` and `shared`.
    The `packed` qualifier simply states that the implementation is free to optimize
    memory in whatever way it finds necessary (based on variable usage or other criteria).
    With the `packed` qualifier, we still need to query for the offsets of each variable.
    The `shared` qualifier guarantees that the layout will be consistent between multiple
    programs and program stages provided that the uniform block declaration does not
    change. If you are planning to use the same buffer object between multiple programs
    and/or program stages, it is a good idea to use the `shared` option.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 布局限定符的其他选项，适用于统一块布局，包括 `packed` 和 `shared`。`packed` 限定符简单地表示实现可以自由优化内存，以任何它认为必要的方式（基于变量使用或其他标准）。使用
    `packed` 限定符时，我们仍然需要查询每个变量的偏移量。`shared` 限定符保证在多个程序和程序阶段之间，只要统一块声明没有改变，布局将保持一致。如果你计划在多个程序和/或程序阶段之间使用相同的缓冲区对象，使用
    `shared` 选项是一个好主意。
- en: There are two other layout qualifiers that are worth mentioning: `row_major` and `column_major`.
    These define the ordering of data within the matrix type variables within the
    uniform block.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的还有另外两个布局限定符：`row_major` 和 `column_major`。这些限定符定义了在统一块中的矩阵类型变量内部数据排序。
- en: 'One can use multiple (non-conflicting) qualifiers for a block. For example,
    to define a block with both the `row_major` and `shared` qualifiers, we would
    use the following syntax:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一个块可以使用多个（非冲突的）限定符。例如，为了定义一个同时具有 `row_major` 和 `shared` 限定符的块，我们会使用以下语法：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See also
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter02/scenebasic_uniformblock.cpp` file in the example code
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter02/scenebasic_uniformblock.cpp`文件
- en: The *Sending data to a shader using uniform variables* recipe
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用统一变量将数据发送到着色器的配方
- en: Using program pipelines
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用程序管线
- en: Program pipeline objects were introduced as part of the **separable shader objects **extension,
    and moved into core OpenGL with version 4.1\. They allow programmers to mix and
    match shader stages from multiple **separable** shader programs. To understand
    how this works and why it may be useful, let's go through a hypothetical example.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 程序管线对象作为**可分离着色器对象**扩展的一部分被引入，并在OpenGL 4.1版本中成为核心功能。它们允许程序员混合和匹配来自多个**可分离**着色器程序的着色器阶段。为了了解这是如何工作的以及为什么它可能有用，让我们通过一个假设的例子来探讨。
- en: Suppose we have one vertex shader and two fragment shaders. Suppose that the
    code in the vertex shader will function correctly with both fragment shaders.
    I could simply create two different shader programs, reusing the OpenGL shader
    object containing the vertex shader. However, if the vertex shader has a lot of
    uniform variables, then every time that I switch between the two shader programs,
    I would (potentially) need to reset some or all of those uniform variables. This
    is because the uniform variables are part of the *shader program's* state, so
    changes to the uniforms in one program would not carry over to the other program,
    even when the two share a shader object. The uniform information is stored in
    the shader program object, not the shader object.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个顶点着色器和两个片段着色器。假设顶点着色器中的代码将能够与两个片段着色器正确地工作。我可以简单地创建两个不同的着色器程序，重用包含顶点着色器的OpenGL着色器对象。然而，如果顶点着色器有很多统一变量，那么每次我在两个着色器程序之间切换时，我可能需要重置一些或所有这些统一变量。这是因为统一变量是着色器程序状态的一部分，所以在一个程序中对统一变量的更改不会传递到另一个程序，即使两个程序共享同一个着色器对象。统一信息存储在着色器程序对象中，而不是着色器对象中。
- en: Shader program objects include the values of active uniform variables; this
    information is not stored within a shader object.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器程序对象包括活动统一变量的值；这些信息不会存储在着色器对象中。
- en: With separable shader objects, we can create shader programs that include one
    or more shader stages. Prior to this extension, we were required to include at
    least a vertex and fragment shader. Such programs are called separable because
    they are not necessarily linked to specific other stages. They can be separated
    and linked to different stages at different times. Separable programs can contain
    just a single stage (or more if desired).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可分离的着色器对象，我们可以创建包含一个或多个着色器阶段的着色器程序。在扩展之前，我们被要求至少包含一个顶点着色器和片段着色器。这样的程序被称为可分离的，因为它们不一定与特定的其他阶段链接。它们可以在不同时间分离并链接到不同的阶段。可分离程序可以只包含一个阶段（或根据需要包含更多）。
- en: With **program pipelines**, we can create pipelines that mix and match the stages
    of separable programs. This enables us to avoid losing the state of uniform variables
    in a given shader stage when switching other stages. For example, in the preceding
    scenario, where we have one vertex shader (shader A) and two fragment shaders
    (B and C), we could create three shader programs, each containing a single stage.
    Then, we could create two pipelines. The first pipeline would use the vertex shader
    from program A and the fragment shader from program B, and the second would use
    the vertex shader from program A and the fragment shader from program C. We could
    switch between the two pipelines without losing any of the uniform variable state
    in shader stage A, because we haven't actually switched shader programs—we're
    using the same shader program (containing stage A) in both pipelines.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**程序管线**，我们可以创建混合和匹配可分离程序阶段的管线。这使我们能够在切换其他阶段时避免丢失给定着色器阶段的统一变量状态。例如，在前面的场景中，我们有一个顶点着色器（着色器A）和两个片段着色器（B和C），我们可以创建三个着色器程序，每个程序包含一个单一阶段。然后，我们可以创建两个管线。第一个管线将使用程序A中的顶点着色器和程序B中的片段着色器，第二个管线将使用程序A中的顶点着色器和程序C中的片段着色器。我们可以在两个管线之间切换，而不会丢失着色器阶段A中的任何统一变量状态，因为我们实际上并没有切换着色器程序——我们在两个管线中使用了同一个着色器程序（包含阶段A）。
- en: Getting ready
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll follow through with the earlier example. We'll need a
    single vertex shader and two compatible fragment shaders. Let's assume that the
    file names are `separable.vert.glsl`, `separable1.frag.glsl`, and `separable2.frag.glsl`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将继续使用前面的例子。我们需要一个单一的顶点着色器和两个兼容的片段着色器。让我们假设文件名是`separable.vert.glsl`、`separable1.frag.glsl`和`separable2.frag.glsl`。
- en: 'Separable shaders require you to re-declare the built-in `gl_PerVertex` output
    block if you use any of its members. Since you will nearly always use one of its
    members (`gl_Position`), you''ll very likely need to add the following to your
    vertex shader:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 可分离的着色器要求你在使用其任何成员（例如`gl_Position`）时重新声明内置的`gl_PerVertex`输出块。由于你几乎总是需要使用其成员之一，你很可能需要将以下内容添加到你的顶点着色器中：
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Start by loading the shader files into `std::string`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先通过将着色器文件加载到`std::string`中开始：
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we''ll create one shader program for each using `glCreateShaderProgramv`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`glCreateShaderProgramv`为每个创建一个着色器程序：
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we''ll create two program pipelines. The first will use the vertex shader
    and the first fragment shader, and the second will use the vertex shader and the
    second fragment shader:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建两个程序管线。第一个将使用顶点着色器和第一个片段着色器，第二个将使用顶点着色器和第二个片段着色器：
- en: '[PRE42]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To set uniform variables in separable shaders, the recommended technique is
    to use `glProgramUniform` rather than `glUniform`. With separable shaders and
    program pipelines, it can be a bit tedious and tricky to determine which shader
    stage is affected by the `glUniform` functions. The `glProgramUniform` functions
    allow us to specify the target program directly. For example, here, we''ll set
    a uniform in the vertex shader program (shared by the two pipelines):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在可分离的着色器中设置统一变量时，建议使用`glProgramUniform`而不是`glUniform`。在使用可分离的着色器和程序管线时，确定哪个着色器阶段受`glUniform`函数的影响可能有点繁琐和棘手。`glProgramUniform`函数允许我们直接指定目标程序。例如，在这里，我们将设置顶点着色器程序（由两个管线共享）中的统一变量：
- en: '[PRE43]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To render, we first need to make sure that no programs are currently bound.
    If there is a program bound via `glUseProgram`, it will ignore any program pipelines:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渲染，我们首先需要确保当前没有绑定任何程序。如果有程序通过`glUseProgram`绑定，它将忽略任何程序管线：
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we can use the pipelines that we set up earlier:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们之前设置的管线：
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `glCreateShaderProgramv` function provides a simple way to create a separable
    shader program consisting of a single stage. We pass the shader stage and the
    code string to function which creates a shader object, compiles it, creates a
    separable program, attaches the shader, and links the program, and returns the
    name of the new shader program. We should check for errors immediately after each
    call. All errors will be in the program info log. The *Linking a shader program* recipe
    details how to check for errors.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`glCreateShaderProgramv`函数提供了一个简单的方法来创建一个由单个阶段组成的可分离着色器程序。我们传递着色器阶段和代码字符串到创建着色器对象的函数，编译它，创建一个可分离的程序，附加着色器，并链接程序，然后返回新着色器程序的名字。我们应在每次调用后立即检查错误。所有错误都会在程序信息日志中。*链接着色器程序*配方详细说明了如何检查错误。'
- en: Once we have the shader programs, we create the pipelines. We create two pipeline
    objects using `glCreateProgramPipelines`. Then, we set the stages for each pipeline
    using `glUseProgramStages`. The first argument to `glUseProgramStages` is the
    pipeline name, the second is a bit string indicating the stages that are to be
    used from the program, and the last argument is the program name. The bit string
    for the second argument can be composed of some combination of `GL_VERTEX_SHADER_BIT`, `GL_FRAGMENT_SHADER_BIT`,
    and so on. Use the bitwise OR operator (`|`) to combine bits.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了着色器程序，我们就创建管线。我们使用`glCreateProgramPipelines`创建了两个管线对象。然后，我们使用`glUseProgramStages`为每个管线设置阶段。`glUseProgramStages`的第一个参数是管线名称，第二个参数是一个位字符串，指示要使用的程序阶段，最后一个参数是程序名称。第二个参数的位字符串可以由`GL_VERTEX_SHADER_BIT`、`GL_FRAGMENT_SHADER_BIT`等组合而成。使用按位或运算符（`|`）组合位。
- en: As mentioned earlier, when using program pipelines, it is a good idea to use `glProgramUniform` rather
    than `glUniform` to set uniform variables. It can be difficult to determine the
    program that is being affected when using `glUniform` due to the fact that a pipeline
    can and usually does involve multiple programs. There is a function called `glActiveShaderProgram` that
    can be used to specify the program affected by `glUniform` calls, or you can simply
    use `glUseProgram`. However, there's no need to bother with any of that, because `glProgramUniform` makes
    it clear and simple. With `glProgramUniform`, we specify the target program directly
    as the first argument.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当使用程序管线时，使用`glProgramUniform`而不是`glUniform`来设置统一变量是一个好主意。由于管线可能并且通常涉及多个程序，使用`glUniform`时很难确定受影响的程序。有一个名为`glActiveShaderProgram`的函数可以用来指定受`glUniform`调用影响的程序，或者你可以简单地使用`glUseProgram`。然而，没有必要为此烦恼，因为`glProgramUniform`使得它清晰简单。使用`glProgramUniform`，我们直接将目标程序作为第一个参数指定。
- en: Before rendering with pipelines, it is important to make sure that there is
    no program that is currently bound to the GL context via `glUseProgram`. If there
    is, it will be used instead of the pipeline. Therefore, you might want to call `glUseProgram(0)` before
    rendering, just to be sure.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用管线渲染之前，确保没有程序当前通过`glUseProgram`绑定到GL上下文是很重要的。如果有，它将代替管线使用。因此，在渲染之前，你可能想要调用`glUseProgram(0)`以确保。
- en: Finally, we use `glBindProgramPipeline` to enable one of our pipelines before
    rendering. In this example, the first draw will use the vertex shader and the
    first fragment shader. The second draw will use the vertex shader and the second
    fragment shader.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`glBindProgramPipeline`在渲染之前启用我们的管线之一。在这个例子中，第一次绘制将使用顶点着色器和第一个片段着色器。第二次绘制将使用顶点着色器和第二个片段着色器。
- en: There's more...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'In the preceding example, we used `glCreateShaderProgramv` to create each single-stage
    program. However, you can also use the more familiar `glCreateProgram` to do the
    same thing. In fact, if you want to create a program with more than one stage
    (say, a vertex shader and a geometry shader), you need to use `glCreateProgram`.
    However, since we want to use it with shader pipelines, it is important to use `glProgramParameteri` to
    designate it as a separable program. Here''s an example of creating a single stage
    program using `glCreateProgram`, assuming that `vertShader` is the name of a previously-compiled
    vertex shader object:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`glCreateShaderProgramv`来创建每个单阶段程序。然而，你也可以使用更熟悉的`glCreateProgram`来做同样的事情。实际上，如果你想创建一个包含多个阶段（比如，顶点着色器和几何着色器）的程序，你需要使用`glCreateProgram`。然而，由于我们想要与着色器管线一起使用它，因此使用`glProgramParameteri`将其指定为可分离程序是很重要的。以下是一个使用`glCreateProgram`创建单阶段程序的示例，假设`vertShader`是之前编译的顶点着色器对象的名称：
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You could attach more than one shader before linking.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接之前，你可以附加多个着色器。
- en: Program pipelines make it easy to mix and match shader stages, while maintaining
    uniform state. However, the added complexity may not be worth it for many situations.
    If your shaders are complex, with lots of uniform states, and you need to switch
    portions of the pipeline often, it might be a good alternative.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 程序管线使得混合和匹配着色器阶段变得容易，同时保持统一状态。然而，增加的复杂性可能对于许多情况来说并不值得。如果你的着色器很复杂，有很多统一状态，并且你需要经常切换管线的一部分，这可能是一个好的替代方案。
- en: See also
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter02/sceneseparable.cpp` file in the example code
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter02/sceneseparable.cpp`文件
- en: The *Linking a shader program* recipe
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*链接着色器程序*菜谱'
- en: Getting debug messages
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取调试信息
- en: Prior to recent versions of OpenGL, the traditional way to get debug information
    was to call `glGetError`. Unfortunately, that is an exceedingly tedious method
    to debug a program. The `glGetError` function returns an error code if an error
    has occurred at some point before the function was called.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL的最近版本之前，获取调试信息传统的方式是调用`glGetError`。不幸的是，这是一个极其繁琐的方法来调试程序。如果函数被调用之前某个时刻发生了错误，`glGetError`函数会返回一个错误代码。
- en: This means that if we're chasing down a bug, we essentially need to call `glGetError` after
    every function call to an OpenGL function, or do a binary search-like process
    where we call it before and after a block of code, and then move the two calls
    closer to each other until we determine the source of the error. What a pain!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们正在追踪一个错误，我们本质上需要在调用OpenGL函数的每个函数调用后调用`glGetError`，或者进行类似于二分查找的过程，在代码块前后调用它，然后将两个调用逐渐靠近，直到我们确定错误的来源。多么痛苦啊！
- en: Thankfully, as of OpenGL 4.3, we now have support for a more modern method for
    debugging. Now, we can register a debug callback function that will be executed
    whenever an error occurs, or other informational message is generated. Not only
    that, but we can send our own custom messages to be handled by the same callback,
    and we can filter the messages using a variety of criteria.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，从OpenGL 4.3开始，我们现在支持一种更现代的调试方法。现在，我们可以注册一个调试回调函数，该函数将在发生错误或生成其他信息性消息时执行。不仅如此，我们还可以发送自己的自定义消息，由相同的回调函数处理，并且我们可以使用各种标准来过滤消息。
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create an OpenGL program with a debug context. While it is not strictly necessary
    to acquire a debug context, we might not get messages that are as informative
    as when we are using a debug context. To create an OpenGL context using GLFW with
    debugging enabled, use the following function call prior to creating the window:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个具有调试上下文的OpenGL程序。虽然获取调试上下文不是强制性的，但我们可能无法获得像使用调试上下文时那样有信息性的消息。要使用GLFW创建启用调试的OpenGL上下文，请在创建窗口之前使用以下函数调用：
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'An OpenGL debug context will have debug messages enabled by default. If, however,
    you need to enable debug messages explicitly, use the following call:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，OpenGL调试上下文将启用调试消息。然而，如果您需要显式启用调试消息，请使用以下调用：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use the following steps:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤：
- en: 'Create a callback function to receive the debug messages. The function must
    conform to a specific prototype described in the OpenGL documentation. For this
    example, we''ll use the following one:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个回调函数以接收调试消息。该函数必须符合OpenGL文档中描述的特定原型。在这个例子中，我们将使用以下原型：
- en: '[PRE49]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Register our callback with OpenGL using `glDebugMessageCallback`:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glDebugMessageCallback` 将我们的回调注册到OpenGL：
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Enable all messages, all sources, all levels, and all IDs:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用所有消息、所有来源、所有级别和所有ID：
- en: '[PRE51]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works...
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `debugCallback` callback function has several parameters, the most important
    of which is the debug message itself (the sixth parameter, `message`). For this
    example, we simply print the message to the standard output, but we could send
    it to a log file or some other destination.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`debugCallback` 回调函数有几个参数，其中最重要的是调试消息本身（第六个参数，`message`）。在这个例子中，我们只是将消息打印到标准输出，但我们可以将其发送到日志文件或其他目的地。'
- en: The first four parameters to `debugCallback` describe the source, type, ID number,
    and severity of the message. The ID number is an unsigned integer specific to
    the message. The possible values for the source, type, and severity parameters
    are described in the following tables.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`debugCallback` 的前四个参数描述了消息的来源、类型、ID号和严重性。ID号是针对消息的特定无符号整数。源、类型和严重性参数的可能值在以下表中描述。'
- en: 'The source parameter can have any of the following values:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 源参数可以具有以下任何值：
- en: '| **Source** | **Generated by** |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| **来源** | **由谁生成** |'
- en: '| `GL_DEBUG_SOURCE_API` | Calls to the OpenGL API |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_SOURCE_API` | 调用OpenGL API |'
- en: '| `GL_DEBUG_SOURCE_WINDOW_SYSTEM` | Calls to a Windows system API |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_SOURCE_WINDOW_SYSTEM` | 调用Windows系统API |'
- en: '| `GL_DEBUG_SOURCE_THIRD_PARTY` | An application associated with OpenGL |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_SOURCE_THIRD_PARTY` | 与OpenGL相关联的应用程序 |'
- en: '| `GL_DEBUG_SOURCE_APPLICATION` | The application itself |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_SOURCE_APPLICATION` | 应用程序本身 |'
- en: '| `GL_DEBUG_SOURCE_OTHER` | Some other source |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_SOURCE_OTHER` | 其他来源 |'
- en: 'The type parameter can have any of the following values:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数可以具有以下任何值：
- en: '| **Type** | **Description** |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **描述** |'
- en: '| `GL_DEBUG_TYPE_ERROR` | An error from the OpenGL API |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_TYPE_ERROR` | OpenGL API的错误 |'
- en: '| `GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR` | Behavior that has been deprecated |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR` | 已弃用的行为 |'
- en: '| `GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR` | Undefined behavior |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR` | 未定义的行为 |'
- en: '| `GL_DEBUG_TYPE_PORTABILITY` | Some functionality is not portable |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_TYPE_PORTABILITY` | 一些功能不可移植 |'
- en: '| `GL_DEBUG_TYPE_PERFORMANCE` | Possible performance issues |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_TYPE_PERFORMANCE` | 可能的性能问题 |'
- en: '| `GL_DEBUG_TYPE_MARKER` | An annotation |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_TYPE_MARKER` | 一个注释 |'
- en: '| `GL_DEBUG_TYPE_PUSH_GROUP` | Messages related to debug group push |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_TYPE_PUSH_GROUP` | 与调试组推送相关的消息 |'
- en: '| `GL_DEBUG_TYPE_POP_GROUP` | Messages related to debug group pop |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_TYPE_POP_GROUP` | 与调试组弹出相关的消息 |'
- en: '| `GL_DEBUG_TYPE_OTHER` | Other messages |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_TYPE_OTHER` | 其他消息 |'
- en: 'The severity parameter can have the following values:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 严重性参数可以具有以下值：
- en: '| **Severity** | **Meaning** |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **严重性** | **含义** |'
- en: '| `GL_DEBUG_SEVERITY_HIGH` | Errors or dangerous behavior |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_SEVERITY_HIGH` | 错误或危险行为 |'
- en: '| `GL_DEBUG_SEVERITY_MEDIUM` | Major performance warnings, other warnings,
    or use of deprecated functionality |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_SEVERITY_MEDIUM` | 主要性能警告、其他警告或使用已弃用功能 |'
- en: '| `GL_DEBUG_SEVERITY_LOW` | Redundant state changes, unimportant undefined
    behavior |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_SEVERITY_LOW` | 冗余状态更改，不重要的未定义行为 |'
- en: '| `GL_DEBUG_SEVERITY_NOTIFICATION` | A notification, not an error, or performance
    issue |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `GL_DEBUG_SEVERITY_NOTIFICATION` | 这是一个通知，而不是错误或性能问题 |'
- en: The `length` parameter is the length of the message string, excluding the null
    terminator. The last parameter, `param`, is a user-defined pointer. We can use
    this to point to some custom objects that might be helpful to the callback function.
    This parameter can be set using the second parameter to `glDebugMessageCallback`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` 参数是消息字符串的长度，不包括空终止符。最后一个参数 `param` 是用户定义的指针。我们可以使用它来指向可能对回调函数有帮助的一些自定义对象。此参数可以使用
    `glDebugMessageCallback` 的第二个参数设置。'
- en: Within `debugCallback`, we convert each `GLenum` parameter into a string. Due
    to space constraints, I don't show all of that code here, but it can be found
    in the example code for this book. We then print all of the information to the
    standard output.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `debugCallback` 中，我们将每个 `GLenum` 参数转换为字符串。由于空间限制，我这里没有展示所有代码，但可以在本书的示例代码中找到。然后我们将所有信息打印到标准输出。
- en: The call to `glDebugMessageCallback` registers our callback function with the
    OpenGL debug system. The first parameter is a pointer to our callback function,
    and the second parameter (`nullptr`, in this example) can be a pointer to any
    object that we would like to pass into the callback. This pointer is passed as
    the last parameter with every call to `debugCallback`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `glDebugMessageCallback` 的调用将我们的回调函数注册到 OpenGL 调试系统中。第一个参数是我们回调函数的指针，第二个参数（在这个例子中为
    `nullptr`）可以是我们想要传递到回调中的任何对象的指针。此指针作为每个对 `debugCallback` 的调用中的最后一个参数传递。
- en: Finally, the call to `glDebugMessageControl` determines our message filters.
    This function can be used to selectively turn on or off any combination of message
    source, type, ID, or severity. In this example, we turn everything on.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对 `glDebugMessageControl` 的调用确定我们的消息过滤器。此函数可以用来选择性地打开或关闭任何组合的消息源、类型、ID 或严重性。在这个例子中，我们打开了所有内容。
- en: There's more...
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: OpenGL also provides support for stacks of named debug groups. This means that
    we can remember all of our debug message filter settings on a stack and return
    to them after some changes have been made. This might be useful, for example,
    if there are sections of code where we need to filter some kinds of messages and
    other sections where we want a different set of messages.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 还提供了对命名调试组栈的支持。这意味着我们可以记住所有调试消息过滤器设置在栈上，并在一些更改后返回。这可能很有用，例如，如果我们需要在某些代码部分过滤某些类型的消息，而在其他部分我们想要不同的消息集。
- en: The functions involved are `glPushDebugGroup` and `glPopDebugGroup`. A call
    to `glPushDebugGroup` generates a debug message with the `GL_DEBUG_TYPE_PUSH_GROUP` type,
    and retains the current state of our debug filters on a stack. We can then change
    our filters using `glDebugMessageControl`, and later return to the original state
    using `glPopDebugGroup`. Similarly, the `glPopDebugGroup` function generates a
    debug message with the `GL_DEBUG_TYPE_POP_GROUP` type.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的函数是 `glPushDebugGroup` 和 `glPopDebugGroup`。对 `glPushDebugGroup` 的调用会生成一个类型为
    `GL_DEBUG_TYPE_PUSH_GROUP` 的调试消息，并保留我们的调试过滤器在栈上的当前状态。然后我们可以使用 `glDebugMessageControl`
    来更改我们的过滤器，并使用 `glPopDebugGroup` 返回到原始状态。同样，`glPopDebugGroup` 函数会生成一个类型为 `GL_DEBUG_TYPE_POP_GROUP`
    的调试消息。
- en: Building a C++ shader program class
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个 C++ 着色器程序类
- en: If you are using C++, it can be very convenient to create classes to encapsulate
    some of the OpenGL objects. A prime example is the shader program object. In this
    recipe, we'll look at a design for a C++ class that can be used to manage a shader
    program.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 C++，创建类来封装一些 OpenGL 对象可以非常方便。一个主要的例子是着色器程序对象。在这个菜谱中，我们将探讨一个 C++ 类的设计，该类可以用来管理着色器程序。
- en: Getting ready
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: There's not much to prepare for with this one; you just need a build environment
    that supports C++. Also, I'll assume that you are using GLM for matrix and vector
    support; if not, just leave out the functions involving the GLM classes.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个，没有太多要准备的；你只需要一个支持 C++ 的构建环境。此外，我将假设你正在使用 GLM 来支持矩阵和向量；如果不是，只需省略涉及 GLM 类的函数。
- en: How to do it...
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we''ll use a custom exception class for errors that might occur during
    compilation or linking:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用自定义异常类来处理编译或链接过程中可能发生的错误：
- en: '[PRE52]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We''ll use `enum` for the various shader types:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `enum` 来表示各种着色器类型：
- en: '[PRE53]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The program class itself has the following interface:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序类本身具有以下接口：
- en: '[PRE54]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Code download tip
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 代码下载提示
- en: The full source code for all of the recipes in this text is available on GitHub
    at [https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition](https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 本文本中所有菜谱的完整源代码可在GitHub上找到，地址为 [https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition](https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition)。
- en: You can also download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support) and
    register to have the files emailed directly to you.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户中下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册以将文件直接通过电子邮件发送给您。
- en: The techniques involved in the implementation of these functions are covered
    in previous recipes in this chapter. Due to space limitations, I won't include
    the code here (it's available from this book's GitHub repository), but we'll discuss
    some of the design decisions in the next section.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的实现中涉及的技术在本章前面的菜谱中有详细说明。由于篇幅限制，这里不包括代码（可在本书的GitHub仓库中找到），但下一节我们将讨论一些设计决策。
- en: How it works...
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The state stored within a `GLSLProgram` object includes the handle to the OpenGL
    shader program object (`handle`), a `bool` variable indicating whether or not
    the program has been successfully linked (`linked`), and `map`, which is used
    to store `uniform` locations as they are discovered (`uniformLocations`).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 `GLSLProgram` 对象中的状态包括OpenGL着色器程序对象的句柄 (`handle`)，一个表示程序是否成功链接的 `bool` 变量
    (`linked`)，以及 `map`，用于存储在发现时存储的 `uniform` 位置 (`uniformLocations`)。
- en: The `compileShader` overloads will throw `GLSLProgramException` if the compilation
    fails. The first version determines the type of shader based on the filename extension.
    In the second version, the caller provides the shader type, and the third version
    is used to compile a shader, taking the shader's source code from a string. The
    filename can be provided as a third argument if the string was taken from a file,
    which is helpful for providing better error messages.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译失败，`compileShader` 重载将抛出 `GLSLProgramException`。第一个版本根据文件扩展名确定着色器的类型。在第二个版本中，调用者提供着色器类型，第三个版本用于编译着色器，从字符串中获取着色器的源代码。如果字符串是从文件中获取的，可以提供文件名作为第三个参数，这有助于提供更好的错误消息。
- en: The `GLSLProgramException` error message will contain the contents of the shader
    log or program log when an error occurs.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时，`GLSLProgramException` 错误消息将包含着色器日志或程序日志的内容。
- en: The `getUniformLocation` private function is used by the `setUniform` functions
    to find the location of a uniform variable. It checks the `uniformLocations` map first,
    and if the location is not found, queries OpenGL for the location, and stores
    the result in the map before returning. The `fileExists` function is used by `compileShaderFromFile` to
    check for file existence.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`getUniformLocation` 私有函数被 `setUniform` 函数用来查找统一变量的位置。它首先检查 `uniformLocations`
    映射，如果找不到位置，则查询OpenGL以获取位置，并在返回之前将结果存储在映射中。`fileExists` 函数被 `compileShaderFromFile`
    用来检查文件是否存在。'
- en: The constructor simply initializes `linked` to `false` and `handle` to `0`.
    The `handle` variable will be initialized by calling `glCreateProgram` when the
    first shader is compiled.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数简单地初始化 `linked` 为 `false` 和 `handle` 为 `0`。当第一个着色器被编译时，将通过调用 `glCreateProgram`
    来初始化 `handle` 变量。
- en: The `link` function simply attempts to link the program by calling `glLinkProgram`.
    It then checks the link status, and if successful, sets the `linked` variable to `true` and
    returns `true`. Otherwise, it gets the program log (by calling `glGetProgramInfoLog`),
    stores the result in `GLSLProgramException`, and throws it. If the link is successful,
    it calls `findUniformLocations`, which gets a list of all active uniform variables
    and stores their locations in the map named `uniformLocations`, keyed by their
    names. Regardless of whether the link is successful, it detaches and deletes all
    shader objects before returning or throwing an exception.  After all of this,
    it detaches and deletes the shader objects, because they are no longer needed.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`link` 函数简单地尝试通过调用 `glLinkProgram` 链接程序。然后它检查链接状态，如果成功，将 `linked` 变量设置为 `true`
    并返回 `true`。否则，它获取程序日志（通过调用 `glGetProgramInfoLog`），将结果存储在 `GLSLProgramException`
    中，并抛出异常。如果链接成功，它调用 `findUniformLocations`，获取所有活动统一变量的列表并将它们的地址存储在名为 `uniformLocations`
    的映射表中，以它们的名称作为键。无论链接是否成功，它都会在返回或抛出异常之前断开并删除所有着色器对象。在这之后，它还会断开并删除着色器对象，因为它们不再需要。'
- en: The `use` function simply calls `glUseProgram` if the program has already been
    successfully linked, otherwise it does nothing.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`use` 函数如果程序已经成功链接，则简单地调用 `glUseProgram`，否则不执行任何操作。'
- en: The `getHandle` and `isLinked` functions are simply *getter* functions that
    return `handle` to the OpenGL program object and the value of the `linked` variable.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`getHandle` 和 `isLinked` 函数是简单的 *getter* 函数，它们返回 OpenGL 程序对象的 `handle` 和 `linked`
    变量的值。'
- en: The `bindAttribLocation` and `bindFragDataLocation` functions are wrappers around `glBindAttribLocation` and `glBindFragDataLocation`.
    Note that these functions should only be called prior to linking the program.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`bindAttribLocation` 和 `bindFragDataLocation` 函数是 `glBindAttribLocation` 和
    `glBindFragDataLocation` 的包装器。请注意，这些函数应该在程序链接之前调用。'
- en: The `setUniform` overloaded functions are straightforward wrappers around the
    appropriate `glUniform` functions. As mentioned previously, the uniform locations
    are queried and stored when the program is linked, so each `setUniform` function
    checks the map to get the cached uniform location.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUniform` 重载函数是围绕适当的 `glUniform` 函数的简单包装器。如前所述，当程序链接时，统一位置会被查询并存储，因此每个 `setUniform`
    函数都会检查映射表以获取缓存的统一位置。'
- en: The destructor takes care of deleting the program object.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数负责删除程序对象。
- en: Finally, the `printActiveUniforms`, `printActiveUniformBlocks`, and `printActiveAttribs` functions
    are useful for debugging purposes. They simply display a list of the active `uniforms/attributes` to
    the standard output.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`printActiveUniforms`、`printActiveUniformBlocks` 和 `printActiveAttribs` 函数对于调试目的很有用。它们只是简单地显示活动
    `uniforms/attributes` 列表到标准输出。
- en: 'The following is a simple example of the use of the `GLSLProgram` class:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 `GLSLProgram` 类的简单示例：
- en: '[PRE55]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: See also
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `ingredients/glslprogram.cpp` file in the example code
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `ingredients/glslprogram.cpp` 文件
- en: For the full source code, check out the GitHub site for this book at [https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition](https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition)
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看完整的源代码，请访问本书的 GitHub 网站：[https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition](https://github.com/PacktPublishing/OpenGL-4-Shading-Language-Cookbook-Third-Edition)
- en: All of the recipes in this chapter
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中所有的配方
