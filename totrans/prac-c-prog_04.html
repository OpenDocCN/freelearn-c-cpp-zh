<html><head></head><body>
        

                            
                    <h1 class="header-title">Preprocessing and Compilation</h1>
                
            
            
                
<p>There are several preprocessor statements that can help you determine which source code needs to be compiled and which needs to be excluded from being compiled. That is, a condition can be applied and the desired statements will be compiled only if the specified condition is true. These directives can be nested for more precise branching. There are numerous preprocessor statements, such as <kbd>#if</kbd>, <kbd>#ifdef</kbd>, <kbd>#ifndef</kbd>, <kbd>#else</kbd>, <kbd>#elif</kbd>, and <kbd>#endif</kbd>, that can be used to collect statements into blocks that we want to be compiled when the specified condition is true.</p>
<p>Some of the advantages of using macros are as follows:</p>
<ul>
<li>The execution speed of the program increases as the value or code of the macro is substituted by the name of the macro. So, the time involved in invoking or calling the functions by the compiler is saved.</li>
<li>Macros reduce the length of the program.</li>
</ul>
<p>The main disadvantage of using a macro is that the size of the program increases prior to the compilation of the program, as all the macros are substituted by their code. In this chapter, we will learn how to apply conditional compilation using preprocessor directives.</p>
<p>We will also learn how to implement validation in the program by making use of assertions. Assertions are a sort of validation check for different critical statements of the program. If those assertions or expressions don't validate or return false, then an error is displayed and the program is aborted. The main difference between this and usual error handling is that assertions can be disabled at runtime.</p>
<p>If the <kbd>#define NDEBUG</kbd> macro is defined near the <kbd>#include &lt;assert.h&gt;</kbd> directive, it will disable the assert function.</p>
<p class="mce-root"/>
<p>Besides the normal asserts, there are also asserts that are referred to as static or compile-time asserts, which are used to catch errors at the time of compilation. Such asserts can be used to do compile-time validations. </p>
<p>In addition to this, we will learn how to use stringize and token-pasting operators using the example of a pizza parlor.</p>
<p>In this chapter, we will learn how to make the following recipes:</p>
<ul>
<li>Performing conditional compilation with directives</li>
<li>Applying assertions for validation</li>
<li>Using assertions to ensure a pointer is not pointing to <kbd>NULL</kbd></li>
<li>Catching errors early with compile-time assertions</li>
<li>Applying stringize and token-pasting operators</li>
</ul>
<p>Let's start with the first recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Performing conditional compilation with directives</h1>
                
            
            
                
<p>In this recipe, we will learn how to apply conditional compilation. We will define certain macros, and then, by applying the <kbd>#if</kbd>, <kbd>#ifdef</kbd>, <kbd>#ifndef</kbd>, <kbd>#else</kbd>, <kbd>#elif</kbd>, <kbd>#endif</kbd>, and <kbd>#undef</kbd> preprocessor directives, we will direct the compiler to compile the desired code. Considering the example of a bookstore, let's assume that a user is asked to enter the price of the book. The program will apply different discounts, festival offers, a discount coupon, and Kindle options on the basis of the <kbd>Qty</kbd> macro, which represents the quantity or number of books purchased by the user. The program also defines other macros that determine different offers that are applicable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these steps to perform conditional compilation with preprocessor directives:</p>
<ol>
<li>Define a <kbd>Qty</kbd> macro and assign it an initial value:</li>
</ol>
<pre style="padding-left: 60px">#define Qty 10</pre>
<p class="mce-root"/>
<ol start="2">
<li>The user will be prompted to enter the price of a book:</li>
</ol>
<pre style="padding-left: 60px">printf("Enter price of a book ");<br/>scanf("%f", &amp;price);</pre>
<ol start="3">
<li>The total number of books is computed using the <kbd>Qty*price</kbd> formula: </li>
</ol>
<pre style="padding-left: 60px">totalAmount=Qty*price; </pre>
<ol start="4">
<li>On the basis of the <kbd>Qty</kbd> macro, the <kbd>#if</kbd>, <kbd>#elif</kbd>, <kbd>#else</kbd>, and <kbd>#endif</kbd> directives are used to determine the discount on the total number.</li>
<li>Once the discount percentage is determined, the amount after deducting the discount is computed and is assigned to the <kbd>afterDisc</kbd> variable:</li>
</ol>
<pre style="padding-left: 60px">afterDisc=totalAmount - (totalAmount*discount)/100; </pre>
<ol start="6">
<li>The festival discount is also computed on the basis of the <kbd>FestivalOffer</kbd> macro. That is, the <kbd>#ifdef</kbd>, <kbd>#else</kbd>, and <kbd>#endif</kbd> directives are used to confirm whether the <kbd>FestivalOffer</kbd> macro is defined and, accordingly, the amount that the customer has to pay after deducting the festival discount is computed:</li>
</ol>
<pre style="padding-left: 60px">#ifdef FestivalOffer<br/> afterFDisc=afterDisc-(totalAmount*FestivalOffer)/100;<br/> #else<br/> afterFDisc=afterDisc;<br/> #endif</pre>
<ol start="7">
<li>The <kbd>#if defined</kbd> directive is used to confirm whether the <kbd>DiscountCoupon</kbd> macro is defined in the program or not. And, accordingly, the user is informed whether they are eligible for the discount coupon:</li>
</ol>
<pre style="padding-left: 60px">#if defined (DiscountCoupon)<br/> printf("You are also eligible for a discount coupon of $ %d\n", DiscountCoupon);<br/> #endif</pre>
<p class="mce-root"/>
<ol start="8">
<li>The preprocessor directives, <kbd>#ifndef</kbd> and <kbd>#endif</kbd>, are used to determine whether the <kbd>Kindle</kbd> macro is defined or not. If the <kbd>Kindle</kbd> macro is not yet defined, it is defined and its value is set. Accordingly, the user is informed of how many months they will be eligible for the <kbd>Kindle</kbd> version of the book:</li>
</ol>
<pre style="padding-left: 60px">#ifndef Kindle<br/> #define Kindle 1<br/> #endif<br/> printf("You can use the Kindle version of the book for %d <br/>         month(s)\n", Kindle);</pre>
<p>The program for performing conditional compilation with preprocessor directives is shown in the following code snippet:</p>
<pre><strong>// condcompile.c</strong><br/>#include &lt;stdio.h&gt;<br/>#define Qty 10<br/>#define FestivalOffer 2<br/>#define DiscountCoupon 5<br/>#define Kindle 2<br/><br/>int main() <br/>{ <br/>    int discount;<br/>    float price, totalAmount, afterDisc, afterFDisc; <br/>    printf("Enter price of a book "); <br/>    scanf("%f", &amp;price); <br/>    #if Qty &gt;= 10 <br/>        discount=15; <br/>    #elif Qty &gt;=5 <br/>        discount=10; <br/>    #else <br/>        discount=5; <br/>    #endif <br/>    totalAmount=Qty*price; <br/>    afterDisc=totalAmount - (totalAmount*discount)/100; <br/>    #ifdef FestivalOffer <br/>        afterFDisc=afterDisc-(totalAmount*FestivalOffer)/100; <br/>    #else <br/>        afterFDisc=afterDisc; <br/>    #endif <br/>    printf("Quantity = %d, Price is $ %.2f, total amount for the <br/>            books is $ %.2f\n", Qty, price, totalAmount); <br/>    printf("Discount is %d%% and the total amount after <br/>            discount is $ %.2f\n", discount, afterDisc); <br/>    #ifdef FestivalOffer <br/>        printf("Festival discount is %d%%, the total amount <br/>                after festival discount is $ %.2f\n", <br/>                FestivalOffer, afterFDisc); <br/>    #endif <br/>    #if defined (DiscountCoupon) <br/>        printf("You are also eligible for a discount <br/>                coupon of $ %d\n", DiscountCoupon); <br/>    #endif <br/>    #ifndef Kindle <br/>        #define Kindle 1 <br/>    #endif <br/>    printf("You can use the Kindle version of the book <br/>           for %d month(s)\n", Kindle); <br/>    return 0; <br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Four macros, called <kbd>Qty</kbd>, <kbd>FestivalOffer</kbd>, <kbd>DiscountCoupon</kbd>, and <kbd>Kindle</kbd>, are defined with the values of <kbd>10</kbd>, <kbd>2</kbd>, <kbd>5</kbd>, and <kbd>2</kbd>, respectively. The user is prompted to enter the price of a book. The value entered by the user is assigned to the variable price. The <kbd>#if</kbd>, <kbd>#elif</kbd>, <kbd>#else</kbd>, and <kbd>#endif</kbd> conditional directives are then used to determine the amount of discount to be applied to the books depending on the value of the <kbd>Qty</kbd> macro. Because, the current value of the <kbd>Qty</kbd> macro is <kbd>10</kbd>, the value of the discount variable will be set to <kbd>15</kbd> through the preprocessor directives. The value of the <kbd>discount</kbd> variable can be changed at any time simply by changing the value of the <kbd>Qty</kbd> macro. The total number of the books is computed by multiplying the values of <kbd>Qty</kbd> by the price, and the resultant value is assigned to the <kbd>totalAmount</kbd> variable. Because the user is given some kind of discount on the basis of the <kbd>Qty</kbd> value, the amount that the user has to pay after deducting the discount is computed and the resulting amount is assigned to the <kbd>afterDisc</kbd> variable.</p>
<p>Again, because the <kbd>FestivalOffer</kbd> macro is defined, the <kbd>#ifdef</kbd>, <kbd>#else</kbd>, and <kbd>#endif</kbd> preprocessor directives are used to compute the amount that the customer has to pay after deducting a festival discount of 2%. We can always comment out the <kbd>#define FestivalOffer</kbd> statement to undefine the macro; in this case, no festival discount will be given to the customer.</p>
<p>The total amount is displayed on the screen as well as the amount after deducting the discount. And if the festival offer is applied, the amount after deducting the festival offer is also displayed on the screen.</p>
<p>The <kbd>#if defined</kbd> directive is used to confirm whether the <kbd>DiscountCoupon</kbd> macro is defined or not. Because currently in the program the <kbd>DiscountCoupon</kbd> macro is defined and is assigned the value of <kbd>5</kbd>, a message is displayed informing that they are eligible for an additional discount coupon of $5 too. You can always comment out the <kbd>DiscountCoupon</kbd> macro if you want to avoid giving any discount coupons. The Kindle version of the book has to be given to the customer for at least a month. Because the <kbd>Kindle</kbd> macro is defined in the program and is assigned the value of <kbd>2</kbd>, a message is displayed on the screen informing the user that they are allowed to use the Kindle version of the book for 2 months. However, if you comment out the <kbd>Kindle</kbd> macro, the <kbd>#ifndef</kbd> and <kbd>#endif</kbd> preprocessor directives are used to set the value of the <kbd>Kindle</kbd> macro to <kbd>1</kbd> if the <kbd>Kindle</kbd> macro is not defined in the program. Therefore, if the <kbd>Kindle</kbd> macro is not defined in the program, a message will be displayed informing the user that they are allowed to use the Kindle version of the book for 1 month.</p>
<p>The program is compiled using GCC, as shown in the following screenshot. Because no error appears during compilation, this means that the <kbd>condcompile.c</kbd> program is successfully compiled into a <kbd>.exe</kbd> file: <kbd>condcompile.exe</kbd>. On executing the file, the user will be prompted to enter the price of the book and, according to the defined macros, the total amount and the discounted amount will be displayed, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/28aac8ff-2af0-4b37-a5e7-c5d4819acca5.png" style="width:54.25em;height:14.58em;"/></p>
<p>Figure 4.1</p>
<p>Next, keeping the value of the <kbd>Qty</kbd> macro to <kbd>10</kbd> and try commenting out the following two macros:</p>
<pre>#define FestivalOffer 2 <br/>#define Kindle 2</pre>
<p>The preceding program will show the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/834f3be7-668d-4eed-a126-08433a8f22dd.png" style="width:44.00em;height:11.17em;"/></p>
<p>Figure 4.2</p>
<p>You can see in the output that because the value of the <kbd>Qty</kbd> macro is still   <kbd>10</kbd>, the customer will continue to get a discount of 15% as shown in the preceding screenshot. Additionally, the festival discount is not given to the customer at all. Because <kbd>DiscountCoupon</kbd> macro is still defined, the customer will continue to get discount coupon of $5  and the Kindle version is reduced to 1 month.</p>
<p>As we mentioned earlier, the <kbd>#undef</kbd> directive removes the current definition of the macro. The following code snippet uses the defined macro and then undefines it after using it:</p>
<pre class="mce-root">#include &lt;stdio.h&gt;<br/>#define qty 10 <br/> <br/>int main()<br/>{<br/>     #ifdef qty<br/>         amount =qty * rate; <br/>         #undef qty<br/>     #endif <br/> return 0;<br/>}</pre>
<p>You can see that the <kbd>qty</kbd> macro is used and then undefined after usage. Now, let's move on to the next recipe!</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying assertions for validation</h1>
                
            
            
                
<p>In this recipe, we will learn how to implement validation using assertion. The program will ask the user to enter the information of the passengers that are flying from one place to another. Using assertions, we can ensure that the number of passengers entered is a positive number. If the number of passengers entered is zero or a negative value, the program will abort.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these steps to create a validation check using assertion. The recipe will not allow the program to run if the value of the number of passengers is zero or negative:</p>
<ol>
<li>The user is prompted to enter how many passengers are flying:</li>
</ol>
<pre style="padding-left: 60px">printf("How many passengers ? ");<br/>scanf("%d",&amp;noOfPassengers);</pre>
<ol start="2">
<li>An <kbd>assert</kbd> instance is defined to ensure that the value of the number of passengers should not be <kbd>0</kbd> or negative. If the user enters a value of <kbd>0</kbd> or negative for the number of passengers, an error message will be displayed showing the line number, and the program will abort:</li>
</ol>
<pre style="padding-left: 60px">assert(noOfPassengers &gt; 0 &amp;&amp; "Number of passengers should <br/>           be a positive integer"); </pre>
<ol start="3">
<li>If the value for the number of passengers entered is a positive value, the user is asked to supply other information such as where the flight is going from, where the flight is going to, and the date of the journey:</li>
</ol>
<pre style="padding-left: 60px"> printf("Flight from: ");<br/> while((c= getchar()) != '\n' &amp;&amp; c != EOF);<br/> gets(fl_from);<br/> printf("Flight to: ");<br/> gets(fl_to);<br/> printf("Date of journey ");<br/> scanf("%s", dateofJourney);</pre>
<ol start="4">
<li>The entered information of the passengers is then displayed on the screen:</li>
</ol>
<pre style="padding-left: 60px"> printf("Number of passengers %d\n", noOfPassengers);<br/> printf("Flight from: %s\n", fl_from);<br/> printf("Flight to: %s\n", fl_to);<br/> printf("Date of journey: %s\n", dateofJourney);</pre>
<p class="mce-root"/>
<p>The program for implementing a validation check using assertions is shown in the following code snippet:</p>
<pre><strong>// assertdemoprog.c</strong><br/>#include &lt;stdio.h&gt; <br/>#include &lt;assert.h&gt; <br/><br/>int main(void) <br/>{ <br/>    int c, noOfPassengers; <br/>    char fl_from[30], fl_to[30], dateofJourney[12]; <br/>    printf("How many passengers ? "); <br/>    scanf("%d",&amp;noOfPassengers); <br/>    assert(noOfPassengers &gt; 0 &amp;&amp; "Number of passengers should <br/>                                  be a positive integer"); <br/>    printf("Flight from: "); <br/>    while((c= getchar()) != '\n' &amp;&amp; c != EOF); <br/>        gets(fl_from); <br/>        printf("Flight to: "); <br/>        gets(fl_to); <br/>        printf("Date of journey "); <br/>        scanf("%s", dateofJourney); <br/>        printf("The information entered is:\n"); <br/>        printf("Number of passengers %d\n", noOfPassengers); <br/>        printf("Flight from: %s\n", fl_from); <br/>        printf("Flight to: %s\n", fl_to);<br/>        printf("Date of journey: %s\n", dateofJourney); <br/>        return 0; <br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The program prompts the user to enter the information of the passengers that are flying from one place to another on a specific date. In order to ensure that the value of the number of passengers is not zero or negative, an assertion is used. The <kbd>assert</kbd> expression validates the value assigned to the <kbd>noOfPassengers</kbd> variable. It checks whether the value of the <kbd>noOfPassengers</kbd> variable is greater than <kbd>0</kbd> or not. If it is, the program will continue to execute the rest of the statements; otherwise, the filename and the line number are sent to the standard error and the program is aborted.</p>
<p>If the assert statement is validated, that is, if the value assigned to <kbd>noOfPassengers</kbd> is more than 0, then the user is asked to enter the other details of the passengers such as where the flight is going from, where the flight is going to, and the date of the journey. The entered information is then displayed on the screen.</p>
<p>The program is compiled using GCC, as shown in the following screenshot. Because no error appears during compilation, this means the <kbd>assertdemoprog.c</kbd> program is successfully compiled into a <kbd>.exe</kbd> file: <kbd>assertdemoprog.exe</kbd>. On executing the file, the user is prompted to enter the number of passengers flying. If the number of passengers entered is a positive value, the program will run perfectly, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a8ed6c5c-aec4-48ea-ad7a-2ad23728242f.png" style="width:27.75em;height:14.58em;"/></p>
<p>Figure 4.3</p>
<p>While executing the program for the second time, if the value entered is negative or zero for the <kbd>noOfPassengers</kbd> variable, an error will be displayed showing the program name and line number, and the program is aborted. The specified error message, <kbd>"Number of passengers should be a positive integer"</kbd>, will be displayed:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2564dea6-39f1-4278-907f-968da70c2525.png" style="width:39.33em;height:7.75em;"/></p>
<p>Figure 4.4</p>
<p>Voilà! We have successfully applied assertions to validate our data.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Using assertions to ensure a pointer is not pointing to NULL</h1>
                
            
            
                
<p>Let's perform one more recipe on assertions. Let's apply assertions to ensure that a pointer is not pointing to <kbd>NULL</kbd> and is instead pointing to a memory address that is to be accessed. Essentially, in this recipe, we will learn to compute the average of a few numbers, where the numbers are stored in an array, and the array elements are accessed through a pointer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Follow these steps to ensure that the pointer is not <kbd>NULL</kbd> and is pointing to a memory address by making use of assertions:</p>
<ol>
<li>Define an array containing a number of integers whose average is to be computed:</li>
</ol>
<pre style="padding-left: 60px">int arr[]={3,9,1,6,2};</pre>
<ol start="2">
<li>Set a pointer to point to the array:</li>
</ol>
<pre style="padding-left: 60px">ptr=arr; </pre>
<ol start="3">
<li>Define a function for calculating the average of the array elements. A pointer to an array and the count of the number of values in the array are both passed to this function:</li>
</ol>
<pre style="padding-left: 60px">average=findaverage(ptr, count); </pre>
<ol start="4">
<li>In the function, define an <kbd>assert</kbd> expression that ensures that the pointer is not <kbd>NULL</kbd>. If the pointer is <kbd>NULL</kbd>, the program will display an error and will be aborted:</li>
</ol>
<pre style="padding-left: 60px">assert(Ptr != NULL &amp;&amp; "Pointer is not pointing to any array"); </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="5">
<li>If the pointer is not <kbd>NULL</kbd>, the array elements will be accessed through the pointer and their average will be computed and displayed on the screen:</li>
</ol>
<pre style="padding-left: 60px">for(i=0;i&lt;Count;i++)<br/> {<br/>   sum+=*Ptr;<br/>   Ptr++;<br/> }<br/>Average=(float)sum/Count;</pre>
<p>The program for implementing a validation that ensures the pointer is not <kbd>NULL</kbd> and is pointing to a memory address is shown as follows:</p>
<pre><strong>// assertprog.c</strong><br/>#include &lt;stdio.h&gt; <br/>#include &lt;assert.h&gt; <br/><br/>float findaverage(int *Ptr, int Count); <br/><br/>int main() <br/>{ <br/>    int arr[]={3,9,1,6,2};<br/>    float average; <br/>    int *ptr=NULL,count; <br/>    ptr=arr; <br/>    count=5; <br/>    average=findaverage(ptr, count); <br/>    printf("Average of values is %f\n", average); <br/>    return(0); <br/>} <br/><br/>float findaverage(int *Ptr, int Count)<br/>{<br/>    int sum,i;<br/>    float Average; <br/>    assert(Ptr != NULL &amp;&amp; "Pointer is not pointing to any array"); <br/>    sum=0; <br/>    for(i=0;i&lt;Count;i++) <br/>    { <br/>        sum+=*Ptr; <br/>        Ptr++; <br/>    } <br/>    Average=(float)sum/Count; <br/>    return(Average); <br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In this program, the average of several integers is computed via an array. That is, a number of integers whose average is supposed to be computed are assigned to an array and an integer pointer is used to access the array elements. A function named <kbd>findaverage</kbd> is defined, to which the integer pointer and the count of the numbers are passed. In the function, an assert is used that ensures that the pointer is not <kbd>NULL</kbd>. If the pointer is not <kbd>NULL</kbd>, the array elements are accessed through the pointer and their addition is done. After the addition of the numbers, their average is computed. The computed average is then returned to the <kbd>main</kbd> function where the average is displayed on the screen. If the pointer is not pointing to the array and is instead pointing to <kbd>NULL</kbd>, the program will display an error and will be aborted.</p>
<p>The program is compiled using GCC, as shown in the following screenshot. Because no error appears during compilation, this means the <kbd>assertprog.c</kbd> program is successfully compiled into a <kbd>.exe</kbd> file: <kbd>assertprog.exe</kbd>. Because the pointer is pointing to the array while executing the file, we get the average of the numerical values specified in the array, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/eff14225-a107-4587-b190-6064448afbc4.png" style="width:25.83em;height:6.08em;"/></p>
<p>Figure 4.5</p>
<p>Next, comment out the following line in which the pointer is pointing to the array:</p>
<pre>ptr=arr;</pre>
<p>The <kbd>ptr</kbd> pointer now is pointing to <kbd>NULL</kbd>. Hence, on running the program, it will display an error, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/624d22ac-a2ce-443c-b887-c8c630b8c7cf.png" style="width:38.42em;height:9.17em;"/></p>
<p>Figure 4.6</p>
<p class="mce-root"/>
<p>Voilà! We have successfully used assertions to ensure that our pointer is not pointing to <kbd>NULL</kbd>.</p>
<p>Now, let's move on to the next recipe!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Catching errors early with compile-time assertions</h1>
                
            
            
                
<p>In this recipe, we will make use of assertions to detect errors at the time of compilation. Essentially, we will create a structure and will make a compile-time assertion that ensures the size of the structure is of some specific bytes. The program will abort if the size of the structure is not equal to the specified value. This constraint will help in determining the capacity of storage and also in the easy maintenance of records, that is, for deletes and updates.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Follow these steps to create a compile-time <kbd>assert</kbd> expression that ensures that the user-defined structure is a specified number of bytes:</p>
<ol>
<li>Define a structure with a few members:</li>
</ol>
<pre style="padding-left: 60px">struct customers<br/> {<br/> int orderid;<br/> char customer_name[20];<br/> float amount;<br/> };</pre>
<ol start="2">
<li>Define a compile-time assert that puts a constraint on the size of the structure. The program will compile only when the assert is validated, that is, the size of the structure is exactly equal to the bytes mentioned in the <kbd>assert</kbd> expression:</li>
</ol>
<pre style="padding-left: 60px">static_assert(sizeof(struct customers) == 28, "The structure is consuming unexpected number of bytes"); </pre>
<ol start="3">
<li>In the main body of the program, you can write any executable code. This code will compile and execute only when the <kbd>assert</kbd> expression is validated:</li>
</ol>
<pre style="padding-left: 60px">static_assert(sizeof(struct customers) == 28, "The structure is consuming unexpected number of bytes"); </pre>
<p>The program for implementing compile-time validation to ensure that the size of a structure is exactly equal to a specific number of bytes is shown in the following code snippet:</p>
<pre><strong>// compileassert.c</strong><br/>#include &lt;stdio.h&gt; <br/>#include &lt;assert.h&gt; <br/><br/>struct customers <br/>{ <br/>    int orderid;<br/>    char customer_name[20]; <br/>    float amount; <br/>}; <br/><br/>static_assert(sizeof(struct customers) == 28, "The structure is consuming unexpected number of bytes"); <br/><br/>int main(void) <br/>{ <br/>    printf("sizeof(int) %d\n",sizeof(int)); <br/>    printf("sizeof(float) %d\n",sizeof(float)); <br/>    printf("sizeof(char) %d\n",sizeof(char)); <br/>    printf("sizeof(struct customers) %d\n",sizeof(struct customers)); <br/>    return 0; <br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>A structure is defined by the name <kbd>customers</kbd>, which consists of a few members. The members of the structure are of different data types. A compile-time assert is defined that places a constraint on the size of the <kbd>customers</kbd> structure to be of 28 bytes exactly. That means the program will not be compiled if the size of the structure is less than or greater than 28 bytes. The <kbd>main</kbd> function simply displays the size of different data types such as <kbd>int</kbd>, <kbd>float</kbd>, and <kbd>char</kbd>. The program also displays the size of the complete <kbd>customers</kbd> structure.</p>
<p>The program is compiled using GCC, as shown in the following screenshot. Because the size of the <kbd>customers</kbd> structure is exactly the same as that specified in the compile-time assert, the program compiles perfectly and the <kbd>compileassert.c</kbd> program is successfully compiled into a <kbd>.exe</kbd> file: <kbd>compileassert.exe</kbd>. On executing the file, we get the output showing the size of different data types and that of the <kbd>customers</kbd> structure, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7cbaed44-eb2f-4a71-b992-a6a0f7873255.png" style="width:31.33em;height:10.58em;"/></p>
<p>Figure 4.7</p>
<p>After changing the value in the <kbd>assert</kbd> function, that is, if the size of the structure does not match the value mentioned in the compile-time assert, we get a compilation error as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/52d6a4b4-f1df-48bb-abe4-2f2b92be8de6.png" style="width:41.67em;height:8.83em;"/></p>
<p>Figure 4.8</p>
<p class="mce-root"/>
<p>Voilà! We have successfully implemented compile-time assertions to be able to catch errors early in the system. Now, let's move on to the next recipe!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying stringize and token-pasting operators</h1>
                
            
            
                
<p>The stringize or hash symbol (<kbd>#</kbd>) can be used in a macro definition to convert the macro parameter into a string constant. You can imagine that the parameter is enclosed in double quotes and returned. It is also known as a token-concatenation operator.</p>
<p>The token-pasting operator (<kbd>##</kbd>) combines two parameters when used in a macro definition. That is, the two parameters on either side of each <kbd>##</kbd> operator are joined into a single string. More precisely, it performs string concatenation on the two parameters to form a new string.</p>
<p>In this recipe, we will learn how to apply stringize and token-pasting operators in computing. The user is asked to specify a certain pizza size and their desired toppings and, accordingly, the price of the pizza is displayed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Following these steps to create a recipe that uses stringize and token-pasting operators:</p>
<ol>
<li>Define a macro with the name <kbd>pizzaprice</kbd> using a token-pasting operator:</li>
</ol>
<pre style="padding-left: 60px">#define pizzaprice(a, b) a##b </pre>
<ol start="2">
<li>Define one more macro with the name <kbd>convertIntoStr</kbd> using a stringize operator:</li>
</ol>
<pre style="padding-left: 60px">#define convertIntoStr(str) #str </pre>
<ol start="3">
<li>Define a few variables such as <kbd>smallnormal</kbd>, <kbd>mediumnormal</kbd>, <kbd>largenormal</kbd>, and <kbd>smallextra</kbd> that represent the price for a pizza of different pizza sizes and toppings:</li>
</ol>
<pre style="padding-left: 60px">float smallnormal=5;<br/> float mediumnormal=7;<br/> float largenormal=10;<br/> float smallextra=7;<br/> float mediumextra=9;<br/> float largeextra=12;<br/> char pizzasize[30];<br/> char topping[20];</pre>
<ol start="4">
<li>The user is asked to enter the pizza size desired by the customer and the size entered is assigned to the <kbd>pizzasize</kbd> variable: </li>
</ol>
<pre style="padding-left: 60px">printf("What size pizza you want? small/medium/large: ");<br/>scanf("%s", pizzasize);</pre>
<ol start="5">
<li>Then, the user is asked to specify whether the pizza is desired with normal cheese or extra cheese, and the choice entered by the user is assigned to the <kbd>topping</kbd> variable: </li>
</ol>
<pre style="padding-left: 60px">printf("Normal or with extra cheese? normal/extra: ");<br/> scanf("%s",topping);</pre>
<ol start="6">
<li>Next, branching is done on the basis of the value of the <kbd>topping</kbd> variable:</li>
</ol>
<pre style="padding-left: 60px">if(strcmp(topping, "normal")==0)<br/> {...........<br/>}<br/> if(strcmp(topping, "extra")==0)<br/> {......................<br/>}</pre>
<ol start="7">
<li>Additionally, the size entered in the <kbd>pizzasize</kbd> variable is compared to check whether the pizza size is small, medium, or large and, accordingly, the arguments are passed to the <kbd>pizzaprice</kbd> macro:</li>
</ol>
<pre style="padding-left: 60px">if(strcmp(pizzasize, "small")==0)<br/> .........<br/> else<br/> if(strcmp(pizzasize, "medium")==0)<br/>..............<br/>else<br/>.....................</pre>
<ol start="8">
<li>The <kbd>pizzaprice</kbd> macro joins the <kbd>pizzasize</kbd> and <kbd>topping</kbd> arguments together and expands them into a concatenated variable:</li>
</ol>
<pre style="padding-left: 60px">pizzaprice(small, extra));</pre>
<p class="mce-root"/>
<p style="padding-left: 60px">Here, <kbd>small</kbd> can be replaced by <kbd>medium</kbd> or <kbd>large</kbd> depending on the size chosen by the user. Additionally, <kbd>extra</kbd> can be replaced by <kbd>normal</kbd> if the user wants a pizza with normal cheese.</p>
<ol start="9">
<li>The value of the concatenated variable is displayed as the price of the specified pizza with the desired toppings:</li>
</ol>
<pre style="padding-left: 60px">printf("The prize for %s size pizza with %s toppings is $%.2f \n", pizzasize, topping, pizzaprice(small, extra));</pre>
<p>The program for applying stringize and token-pasting operators is shown in the following code:</p>
<pre><strong>// preconcat.c</strong><br/>#include &lt;stdio.h&gt; <br/>#include &lt;string.h&gt; <br/><br/>#define pizzaprice(a, b) a##b <br/>#define convertIntoStr(str) #str <br/><br/>int main() <br/>{ <br/>    float smallnormal=5; <br/>    float mediumnormal=7; <br/>    float largenormal=10; <br/>    float smallextra=7; <br/>    float mediumextra=9; <br/>    float largeextra=12; <br/>    char pizzasize[30]; <br/>    char topping[20]; <br/><br/>    printf("What size pizza you want? small/medium/large: "); <br/>    scanf("%s", pizzasize); <br/>    printf("Normal or with extra cheese? normal/extra: "); <br/>    scanf("%s",topping); <br/>    if(strcmp(topping, "normal")==0) <br/>    { <br/>        if(strcmp(pizzasize, "small")==0)<br/>            printf("The prize for %s size pizza with %s toppings is <br/>                    $%.2f \n", pizzasize, topping, <br/>                    pizzaprice(small, normal));<br/>         else <br/>             if(strcmp(pizzasize, "medium")==0)<br/>                  printf("The prize for %s size pizza with %s <br/>                          toppings is $%.2f \n", pizzasize, topping, <br/>                          pizzaprice(medium, normal)); <br/>              else<br/>                  printf("The prize for %s size pizza with %s <br/>                          toppings is $%.2f \n", pizzasize, topping, <br/>                          pizzaprice(large, normal)); <br/>    }<br/>    if(strcmp(topping, "extra")==0) <br/>    { <br/>        if(strcmp(pizzasize, "small")==0)<br/>            printf("The prize for %s size pizza with %s toppings <br/>                    is $%.2f \n", pizzasize, topping, <br/>                    pizzaprice(small, extra)); <br/>        else <br/>            if(strcmp(pizzasize, "medium")==0) <br/>                printf("The prize for %s size pizza with %s toppings <br/>                        is $%.2f \n", pizzasize, topping, <br/>                        pizzaprice(medium, extra));<br/>            else <br/>                printf("The prize for %s size pizza with %s toppings <br/>                        is $%.2f \n", pizzasize, topping, <br/>                        pizzaprice(large, extra)); <br/>    }<br/>    printf(convertIntoStr(Thanks for visiting us)); <br/>    return 0; <br/>}</pre>
<p class="mce-root">Now, let's go behind the scenes to understand the code better.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>A token-pasting operator is used to define a macro with the name <kbd>pizzaprice</kbd>. This macro concatenates the two <kbd>a</kbd> and <kbd>b</kbd> parameters into a single string. In addition to this, a stringize operator is used to define a macro with the name <kbd>convertIntoStr</kbd>, which converts the <kbd>str</kbd> parameter into a string. A number of variables are defined, such as <kbd>smallnormal</kbd>, <kbd>mediumnormal</kbd>, <kbd>largenormal</kbd>, and <kbd>smallextra</kbd>. These variables represent the price of a small-sized normal pizza, a medium-sized normal pizza, a large-sized normal pizza, and a small-sized pizza with extra cheese, respectively. The <kbd>normal</kbd> suffix declares that this is the price of a pizza with a regular amount of cheese. The <kbd>extra</kbd> suffix indicates that this variable represents the price of a pizza with extra cheese.</p>
<p>The user is prompted to enter what pizza size the customer is ordering. The size entered is assigned to the <kbd>pizzasize</kbd> variable. After that, the user is asked whether the pizza is desired with normal cheese or extra cheese and the choice that is entered is assigned to the <kbd>topping</kbd> variable. </p>
<p>Next, branching is done on the basis of the value in the <kbd>topping</kbd> variable. If the topping is normal, the string in <kbd>pizzasize</kbd> is compared to check whether the pizza size is small, medium, or large and, accordingly, the arguments are passed to the <kbd>pizzaprice</kbd> macro. For example, if the user has entered small as the pizza size and the topping as extra, the <kbd>pizzaprice</kbd> macro is invoked with two parameters (small and extra). The <kbd>pizzaprice</kbd> macro, being a token-pasting operator, will concatenate the small and extra strings into <kbd>smallextra</kbd>, and hence the value of the <kbd>smallextra</kbd> variable will be displayed as the price of the small-sized pizza with extra cheese as a topping.</p>
<p>The <kbd>pizzasize</kbd> and <kbd>topping</kbd> variables are combined into a concatenated string, and hence will access the value in the respective variable. Finally, the <kbd>convertIntoStr</kbd> macro is invoked, which includes a stringize operator to display a <kbd>Thanks for visiting us</kbd> string at the end of the bill.</p>
<p>The program is compiled using GCC, as shown in the following screenshot. Because no error appears during compilation, the <kbd>preconcat.c</kbd> program is successfully compiled into a <kbd>.exe</kbd> file: <kbd>preconcat.exe</kbd>. On executing the file, the user will be asked to enter the desired pizza size and toppings and, accordingly, the program will display the price of the pizza, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/823df427-5c4a-4fd6-b4fa-9e6fb64c8007.png" style="width:34.42em;height:16.17em;"/></p>
<p>Figure 4.9</p>
<p>Voilà! We have successfully applied the stringize and token-pasting operators and created custom pizza orders.</p>


            

            
        
    </body></html>