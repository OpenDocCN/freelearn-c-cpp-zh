- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enhancing the Player Experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best ways to improve a video game is to add a good look and feel
    to it. A great-looking game will create an immersive experience that will engage
    players and make them want to keep coming back for more.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it’s important for developers to focus on tweaking visual and
    audio feedback until everything looks just right! It might take some time, but
    getting these last touches right will make sure your video game has an awesome
    look and feel – something that players won’t forget anytime soon!
  prefs: []
  type: TYPE_NORMAL
- en: Keeping this in mind, the following chapter will concentrate on improving certain
    aspects, such as using different animations together and synchronizing them over
    the network, or adding **non-player characters** (**NPCs**) to interact with –
    features that your protagonist has longed for a considerable amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you’ll be providing a purpose for your players to fight for:
    the daring rescue of some imprisoned comrades!'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I’ll share some additional ideas to help guide you in completing your
    multiplayer game. This book may not have enough pages to cover every detail, but
    that shouldn’t stop your creativity and imagination from taking flight!
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will possess a sleek and robust prototype for
    your multiplayer game and be well equipped and prepared to embark on the next
    phase – learning how to optimize it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will guide you through the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Animating the character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding NPC Actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making further improvements to the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the `.zip` project files provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5)'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the files that are up to date with the end of the last chapter
    by clicking the `Unreal Shadows –` `Chapter 09``End` link.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, your hero has been exploring the dungeon and searching for hidden treasures
    while avoiding enemies, but there’s something missing that will really bring it
    to life – a proper animation system.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll guide you through the creation of simple animations that
    will work on the networked environment of your project. This will involve creating
    Blueprints specifically designed for the animation system and establishing their
    connection to your character class – you will be creating the needed animation
    assets and then adding the needed code to make everything work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the animation assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Animating characters in Unreal Engine involves creating **Animation Blueprints**
    that handle the motion and logic of character movement and actions. This book
    doesn’t prioritize this topic – in fact, it’s not usually the main focus for game
    programmers! However, having some basic knowledge of how things work under the
    hood will be a good addition to your game development arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a simple but fully functional animation system for the player character,
    we will need three assets:'
  prefs: []
  type: TYPE_NORMAL
- en: An asset to control the movement transitions from idle to walk to run, and vice
    versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An asset used to play the throw animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Blueprint to control the two aforementioned assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get started, we first need a folder to put all the assets in. So, open the
    Unreal Editor and, in `Animations`. Once it is created, you will be ready to add
    the first asset.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the movement Blend Space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Unreal Engine, a **Blend Space** is a special asset that allows for the blending
    of animations based on the values of two inputs. It allows multiple animations
    to be blended by plotting them onto a one- or two-dimensional graph. Animators
    and game developers often use blend spaces to create smooth and realistic transitions
    between different animations for characters in games.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we will need to blend three animations – the idle, walk, and sprint
    ones – that will be managed depending on the character’s speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this Blend Space, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Animations` folder, right-click and select **Animation | Blend
    Space**. Then, from the **Pick Skeleton** window that will pop up, select **rogue_Skeleton**,
    as depicted in *Figure 10**.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Blend Space creation](img/Figure_10_01_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Blend Space creation
  prefs: []
  type: TYPE_NORMAL
- en: Name the newly-created asset `BS_WalkRun` and double-click it to open the **Blend
    Space** **Editor** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Speed`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `500`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the **Vertical Axis** section as it is (i.e., set to **None**), as we
    won’t use it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we have done here is initialize the main setting values for the animation
    blend, exposing the **Speed** property that will be used by the controlling Blueprint
    we will be adding later.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you will be adding the animation assets that will be blended together.
  prefs: []
  type: TYPE_NORMAL
- en: Locate the **rogue_Idle** animation in the **Asset Browser** and drag it into
    the graph at the center of the editor. This will create a point in the coordinate
    system of the diagram.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the point and set its `0` and its `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get a graph that looks like the one depicted in *Figure 10**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Idle animation settings](img/Figure_10_02_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Idle animation settings
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will add two more assets to the graph – one for the walk animation and
    one for the run animation.
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `45` and its `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, drag the `100` and its `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `500` and its `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The complete Blend Space asset can be seen in *Figure 10**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Complete blend space](img/Figure_10_03_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Complete blend space
  prefs: []
  type: TYPE_NORMAL
- en: To test the animation blends on the character, you can simply press the *Ctrl*
    key and hover the mouse on the zone of the graph you want to check – you will
    see the character start a walk-and-move cycle, the animation assets blending seamlessly.
    The Blend Space is complete, so we can now start creating the asset that will
    handle the throw animation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the throw Animation Montage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An **Animation Montage** is a type of asset that enables the combination of
    multiple animations and their selective play from a Blueprint. Animation Montages
    are commonly used for creating complex animation sequences such as attack combos,
    cutscenes, and other interactive gameplay elements. In our project, we will use
    one to play the single-throw animation from the controlling Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the Animation Montage, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Animations` folder, right-click and select **Animation | Animation
    Montage**. Then, from the **Pick Skeleton** window that will pop up, select **rogue_Skeleton**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the newly created asset `AM_Throw` and double-click it to open the **Animation
    Montage** **Editor** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Asset Browser**, drag the **rogue_Throw** asset – in the **DefaultGroup.DefaultSlot**
    line – onto the timeline at the center of the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result for the Animation Montage is shown in *Figure 10**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Throw Animation Montage](img/Figure_10_04_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Throw Animation Montage
  prefs: []
  type: TYPE_NORMAL
- en: This Montage and the previous **Blend Space** asset will be controlled by a
    dedicated Blueprint that we are going to add to the project in the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the character Animation Blueprint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An **Animation Blueprint** is a specialized type of Blueprint that is used to
    create and control complex animation behaviors for Actors in the game. It defines
    how animations should be processed and blended together, as well as how animation
    inputs should be mapped.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we need to control the Blend Space **Speed** parameter in order
    to let the character walk and run when needed, and start the throw Animation Montage
    when the character is attacking.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the Animation Blueprint, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Animations` folder, right-click and select **Animation | Animation
    Blueprint**. Then, from the **Create Animation Blueprint** window that will pop
    up, select **rogue_Skeleton**, as depicted in *Figure 10**.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Animation Blueprint creation](img/Figure_10_05_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Animation Blueprint creation
  prefs: []
  type: TYPE_NORMAL
- en: Name the newly-created asset `AB_Character` and double-click it to open the
    editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are not already familiar with Animation Blueprints, you will notice some
    similarities to a regular Blueprint class, such as the **My Blueprints** and **Event
    Graph** tabs. If it is not already selected, open **Event Graph** to start some
    Visual Scripting code and then continue with the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Add an **Event Blueprint Initialize** **Animation** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag from the **Return Value** outgoing pin of **Try Get Pawn Owner**
    (which will already be present in the graph) and add a **Cast To** **US_Character**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the event execution pin to the cast node incoming execution pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Character`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the outgoing pin of the **Set Character** node, click and drag to add a
    **Character Movement** getter node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From this getter node outgoing pin, click and drag and select `Movement Component`
    and connect the **Set Movement Component** node that will be automatically added
    to the graph to the execution pin of the **Set** **Character** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final graph is shown in *Figure 10**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Event Blueprint Initialize Animation graph](img/Figure_10_06_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Event Blueprint Initialize Animation graph
  prefs: []
  type: TYPE_NORMAL
- en: This visual script is executed when the Blueprint is initialized and basically
    sets the variables you will need later on, during gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Now, locate the **Event Blueprint Update** animation node that should be already
    present in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: From the **Variables** section, drag a getter node for the **Character** property.
    Right-click it and select the **Convert to Validated Get** option; this will change
    the node into an executable one that will check whether the **Character** variable
    is valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Event Blueprint Update Animation** execution pin to the incoming
    execution pin of the **Get Validated** **Character** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `CharacterSpeed`. Drag a **Set** node for this variable into the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Variables** section, drag a **Get** node for the **Movement** **Component**
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag from the outgoing pin of the **Movement Component** node and
    create a **Get Velocity** property node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag from the outgoing pin of the **Get Velocity** node and create
    a **Vector Length** **XY** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing pin of the **Vector Length XY** node to the incoming pin
    of the **Set Character** **Speed** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result of the graph is shown in *Figure 10**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Event Blueprint Update graph](img/Figure_10_07_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Event Blueprint Update graph
  prefs: []
  type: TYPE_NORMAL
- en: This Visual Scripting code basically tracks the velocity magnitude of the character
    and stores it in the **Character Speed** variable, which will be used in the following
    steps to blend the movement animation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, select the **AnimGraph** tab of the editor, which will display a single
    **Output Pose** – this node represents the final animation pose of the character.
    We now need to tell the graph how to animate the character.
  prefs: []
  type: TYPE_NORMAL
- en: Drag the **Character Speed** property from the **Variables** section to create
    a getter node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag from the **Character Speed** outgoing pin and create a **Blendspace
    Player ‘****BS_WalkRun’** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag the outgoing pin of the **Blendspace Player ‘BS_WalkRun’** node
    and create a **Slot ‘Default Slot’** node – we will use this node from the C++
    code to execute the throw Animation Montage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the outgoing pin of **Slot ‘Default Slot’** to the incoming pin of the
    **Output** **Pose** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result of the AnimGraph is depicted in *Figure 10**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – AnimGraph](img/Figure_10_08_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – AnimGraph
  prefs: []
  type: TYPE_NORMAL
- en: With this final step, the Animation Blueprint is complete; now, you just need
    to connect it to the character Blueprint to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Animation System to the character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add the animation system to the character, you just have to declare the
    Animation Blueprint inside the Blueprint class. To do so, open the **BP_Character**
    Blueprint and select the **Mesh** property. Then, in the **Details** panel, locate
    the **Anim Class** property. From the drop-down menu next to it, select **AB_Character**
    as shown in *Figure 10**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Animation Blueprint assigned to the Blueprint class](img/Figure_10_09_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Animation Blueprint assigned to the Blueprint class
  prefs: []
  type: TYPE_NORMAL
- en: If you test the game right now, you should see the character starting the animation
    loop and reacting to the player input when walking and running. However, the run
    animation will be weirdly jumpy and buggy – this is happening because these animations
    are not replicated and are just checking the character speed to update.
  prefs: []
  type: TYPE_NORMAL
- en: From a technical point of view, the speed value (i.e., `MaxWalkSpeed`) is just
    stored in the server instance of the character, but the client will have its own
    `MaxWalkSpeed` value. While this may be acceptable if you are just moving an Actor
    around, as the server will be constantly updating the Actor position, animating
    a Skeletal Mesh component based on its speed is a totally different beast. In
    fact, the Animation System is using the local value (i.e., the client one) and
    the system will continuously conflict between server and client data, resulting
    in a broken animation.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why we need to move the start-and-stop sprint logic we implemented in
    [*Chapter 7*](B18203_07.xhtml#_idTextAnchor147)*, Using Remote Procedure Calls
    (RPCs),* from the server to the client and call the corresponding methods as multicast
    ones so that all the clients will be aware of this change.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, open the `US_Character.h` header file and add the following client
    declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we used the `NetMulticast` specifier in order to let all the
    clients know that the character has started sprinting. Additionally, this call
    needs to be a `Reliable` one so you are guaranteed to send all the data to the
    recipients without any packet loss.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For a refresher on RPCs and the `NetMulticast` specifier, please refer to [*Chapter
    7*](B18203_07.xhtml#_idTextAnchor147)*, Using Remote Procedure* *Calls (RPCs)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `US_Character.cpp` file and locate `SprintStart_Server_Implementation()`
    and `SprintEnd_Server_Implementation()`. You are going to move all the content
    of both methods to the corresponding client-side calls. To do so, remove all the
    content (i.e., the code in between the brackets) and, in `SprintStart_Server_Implementation()`,
    add the client-side call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `SprintEnd_Server_Implementation()` method, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, move the previously removed code to the client-side implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The overall behavior will then be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The client controlled by the player receives the movement inputs and sends this
    data to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server handles this input and sends the update request to all clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the clients update the `MaxWalkSpeed` value accordingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have compiled the project, try testing the game – our character can
    now move and sprint like a pro, and you’ll get to see their animations shine in
    all their glory!
  prefs: []
  type: TYPE_NORMAL
- en: For some extra practice, try working on the minion character and implementing
    the same animation logic. This is the true meaning of summoning a bunch of bones
    to a fully-fledged, reanimated minion, and who knows? The Lichlord might just
    reward you with a surprise or two for a job well done!
  prefs: []
  type: TYPE_NORMAL
- en: Adding the throw animation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What’s missing at the moment is the throw animation and, in this case, network
    synchronization is something we really want – every connected player in the game
    will need to see the character animation whenever it is throwing the dagger in
    the dungeon, and this animation should be played at the same time for all clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to ensure that the WeaponProjectile component will
    be properly replicated. To do so, open the `US_Character.cpp` file. Then, in the
    constructor, locate the `Weapon` component initialization, and add the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open `US_WeaponProjectileComponent.h` and, in the `private` section,
    add the following Animation Montage reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, in the `protected` section, add the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is the throw method that will be executed from the client side. Notice
    that we are RPC multicasting to all clients with the `Unreliable` property specifier
    – even though we want this animation synchronized over the network, it is just
    an aesthetic add-on, so we can afford to lose the data over the network. The other
    clients won’t see the animation, but the dagger will be spawned anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the header declarations complete, open the `US_WeaponProjectileComponent.cpp`
    file and add the client-side throw method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code will get the owner of this component and, if it is
    of the `US_Character` type, will play the Animation Montage.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method will be called from its server-side counterpart, so locate the
    `Throw_Server_Implementation()` method. We could just execute the method call,
    but we need to give a slight delay to the spawn logic because the throw animation
    will take some time to complete, and spawning the dagger ahead of time would return
    ugly visual feedback to the player. To do so, remove all the content of the function
    and replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have just moved the spawn logic inside a timer handle to delay the
    spawn process while calling the client-side throw logic, in order to start the
    animation immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Unreal Engine provides more advanced methods for synchronizing animations beyond
    simply delaying method calls, such as **Animation Notifies** ([https://docs.unrealengine.com/5.1/en-US/animation-notifies-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/animation-notifies-in-unreal-engine/)).
    However, for the purpose of this book, the delay method is a quick and dirty solution
    that will suffice for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: As the last step, open the **BP_Character** Blueprint, select the **Weapon**
    component and, in the **Details** panel, look for the **Throw Animation** property
    and assign the **AM_Throw** montage you have already created.
  prefs: []
  type: TYPE_NORMAL
- en: You can now test the game and the character should throw the dagger and synchronize
    correctly with the throw animation.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have dipped your toes into the mystical realm of animation
    (although you’re not quite ready to battle the Lichlord just yet) and conjured
    up a basic animation system that networked players will appreciate. In the next
    section, you’re about to bring some friendly characters to life and add even more
    fun to your game by giving players someone to rescue.
  prefs: []
  type: TYPE_NORMAL
- en: Adding NPC Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While taking a leisurely stroll in the underground and dodging or stabbing zombies
    can be amusing, let’s not forget the big bucks the king’s shelling out for us.
    We’ve got a rescue mission on our hands – liberate his knights from the Lichlord’s
    dungeons before they’re turned into undead abominations. Time to get down to business,
    my fearless developer!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll create an Actor Blueprint that will serve as a prisoner
    your beloved thief needs to rescue (in order to get more experience points). To
    implement such a system, you will make good use of the `Interactable` interface
    you implemented in [*Chapter 7*](B18203_07.xhtml#_idTextAnchor147)*, Using Remote
    Procedure* *Calls (RPCs)*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the NPC character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The NPCyou will be creating is a simple, replicated Actor that will cheer when
    the player has interacted with it and will grant some experience points. The first
    things we need are the Animation Montages that will play the idle and cheer animations.
    To do so, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Animations` folder, add a new `AM_KnightIdle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **knight_Idle** animation to the **DefaultGroup.DefaultSlot** section
    of the montage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another `AM_KnightCheer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **knight_cheer** animation to the montage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these two animation assets ready, you can start creating the prisoner Blueprint.
    Open the `Blueprints` folder and complete the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Blueprint based on the `BP_KnightPrisoner`. Double-click it to
    open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Components** panel, add a **Skeletal** **Mesh** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Details** panel, tick the **Replicates** property in order to replicate
    the Actor over the network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `EarnedXp`. Set its `20`. Tick the **Instance Editable** property
    to make the variable public.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `MontageIdle`. Set its **Default Value** to **AM_KnightIdle**. Tick
    the **Instance** **Editable** property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another `MontageCheer`. Set its default value to **AM_KnightCheer**.
    Tick the **Instance** **Editable** property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With these base settings available, you can start adding some Visual Scripting
    to the Event Graph in order to make the Actor fully functional. You will start
    from the **Begin Play** event to start the idle animation. To do so, complete
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an **Event BeginPlay** node to the graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Components** panel, drag into the graph a reference of the **Skeletal**
    **Mesh** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Variables** panel, drag a getter node for the **MontageIdle** variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Event BeginPlay** execution pin, create a **Play** **Animation**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Skeletal Mesh** pin to the **Target** pin of the **Play** **Animation**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Montage Idle** pin to the **New Anim to Play** pin of the **Play**
    **Animation** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tick the **Looping** property of the **Play** **Animation** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result for this part of the graph is shown in *Figure 10**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Event BeginPlay graph](img/Figure_10_10_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Event BeginPlay graph
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create a custom event that will start the cheer animation when the prisoner
    is rescued by the player character. This event needs to be executed as a **Multicast**
    event in order to start the animation on all clients. To do so, complete the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the graph and create a `CharacterCheer`. With the event selected,
    locate the **Replicates** property in the **Details** panel and, from its drop-down
    menu, select **Multicast**, leaving the **Reliable** checkmark unticked, as shown
    in *Figure 10**.11*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Custom Event replication](img/Figure_10_11_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Custom Event replication
  prefs: []
  type: TYPE_NORMAL
- en: From the **Components** panel, drag into the graph a reference to the **Skeletal**
    **Mesh** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Variables** panel, drag a getter node for the **MontageCheer** variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Event BeginPlay** execution pin, create a **Play** **Animation**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Skeletal Mesh** pin to the **Target** pin of the **Play** **Animation**
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Montage Idle** pin to the **New Anim to Play** pin of the **Play**
    **Animation** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tick the **Looping** property of the **Play** **Animation** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final result for this part of the graph is shown in *Figure 10**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – CharacterCheer Custom Event](img/Figure_10_12_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – CharacterCheer Custom Event
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step needed to make the Actor work properly is to make it interactable
    with the player character by implementing the `US_Interactable` interface. To
    do so, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Class Settings** panel and locate the **Interfaces** category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Implemented Interfaces**, add the **US_Interactable** interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **My Blueprint** panel, locate the **Interfaces** category and right-click
    the **Interact** method, selecting **Implement event**. An **Event Interact**
    node will be added to the Event Graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag from the event **Character Instigator** pin to add a **PlayerState**
    node and connect its **Target** pin to the **Character Instigator** pin of the
    **Event** **Interact** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag from the outgoing pin of the **PlayerState** node and create
    a **Cast To US_PlayerState** node. Connect its incoming execution pin to the outgoing
    execution pin of the **Event** **Interact** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag from the **As US PlayerState** of the cast node and create an
    **Add Xp** node. Connect its incoming execution pin to the **Success** execution
    pin of the cast node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Variables** panel, drag a getter node for the **EarnedXp** variable.
    Connect its outgoing pin to the **Value** pin of the **Add** **Xp** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click and drag from the outgoing pin of the **Add Xp** node and create a **Character
    Cheer** node to complete the graph, as shown in *Figure 10**.13*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Interaction graph](img/Figure_10_13_B18203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Interaction graph
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we didn’t use any authority checks in the previous
    graph; this is because we know that this event will only be called on the server.
  prefs: []
  type: TYPE_NORMAL
- en: The Blueprint is now complete, so it’s time to do some testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the NPC Actor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test the Blueprint, you can drag an instance of it into the level and start
    a gameplay session. The thief character should be able to reach the NPC and, if
    we use the interaction button, the animation should show them cheering. The hero
    who liberates the NPC characters will receive a well-deserved pool of experience
    points as a reward. Time to level up and become an even greater hero!
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10**.14* shows the final result of the NPC Actor, once it has been
    liberated by the thief hero:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 10.14 – A \uFEFFliberated Actor during gameplay](img/Figure_10_14_B18203.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – A liberated Actor during gameplay
  prefs: []
  type: TYPE_NORMAL
- en: Well, it seems we now have a new prisoner to play with! But why settle for one
    when we can have variations? Feel free to get creative and give our captive some
    fresh looks to keep things interesting. By creating child Blueprints and changing
    the Actor’s Skeletal Mesh component and Animation Montages, you will be able to
    make good use of the barbarian and mage models available in the project. You may
    even create a rogue prisoner variation – who says we can’t go off-script a little?
    The king may have paid us to rescue his knights and warriors, but hey, a skilled
    hero or two in the Thief Guild never hurt anyone!
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations – you’ve completed this part of the adventure. Now it’s time
    to let your imagination run wild and add your own game logic! In the next section,
    I won’t be teaching you any new techniques, but I’ll provide you with some fresh
    ideas to enhance the gameplay and make it more exciting.
  prefs: []
  type: TYPE_NORMAL
- en: Making further improvements to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have solid knowledge of how the Unreal multiplayer system works,
    it’s time to unleash your creativity and bring your own ideas to life, making
    your game truly unique and personalized. In this section, I will give you some
    hints on how to spice up your project, but don’t hesitate to add your own twist
    to make it uniquely yours.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make some noise!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, the minions’ hearing senses are only utilized to detect when a character
    is running. Why not tweak the system and let other elements in the game alert
    the Lichlord’s minions?
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, `PawnNoiseEmitterComponent` can only be used on, well... pawns,
    so you cannot attach it to other Actors (it simply won’t work); however, in [*Chapter
    9*](B18203_09.xhtml#_idTextAnchor174)*, Extending AI Behaviors*, you built a strong
    system to alert enemy minions that makes use of the Game Mode. As the Game Mode
    can be reached by any Actor in the level, you can exploit the `AlertMinions()`
    function and send messages that will call for help when activated.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the best ways to use this method is through traps – whenever the player
    character steps into one such device, all the minions around will be alerted.
    Some examples of this kind of game feature include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creaking doors*: Whenever the character opens a door, it will make a creaking
    or squeaking sound that will alert the Lichlord’s servants to the intruders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Traps*: Some dungeon areas will be more protected than others – set some mechanical
    devices that will rally all nearby enemies. After all, this is just a matter of
    creating a collision area and calling a method in the Game Mode!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Magical items*: Create some magical artifact that can be interacted with by
    the player. The Lichlord is a sneaky one: he cast an alert spell, which condemned
    the hapless thief hero to their inevitable fate. Whenever the character tries
    to use that juicy item, an alarm will be sent to nearby minions, alerting them.
    Think of the possibilities! You can even use the floating book we created at the
    beginning of the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I need a key!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Opening doors in a dungeon can be a fun game, but things can get even more interesting
    when you come across a locked door. Why not give it a try and see what other surprises
    lie in wait?
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B18203_07.xhtml#_idTextAnchor147)*, Using Remote Procedure
    Calls (RPCs)*, you created the `US_Interactable` interface and made use of the
    `Interact()` method. However, the interface also exposes the `CanInteract()` method,
    which can be used to check whether the Actor can be interacted with.
  prefs: []
  type: TYPE_NORMAL
- en: A door may implement a system that will only return `true` to the `CanInteract()`
    method if the player character has a key – this means creating a key pickup item
    and adding the `US_Character` system to track whether they have one or more keys
    to use. These locked doors can be used to keep the NPCs locked in some cellars
    and only able to be freed if the corresponding key is found somewhere in the level.
  prefs: []
  type: TYPE_NORMAL
- en: Watch out for the Lichlord! His prisoners are double-locked up tighter than
    a merchant’s coin purse in the deepest and most heavily guarded cells of his dungeon!
  prefs: []
  type: TYPE_NORMAL
- en: Improve your arsenal, my hero!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it’s nice to have a pointy dagger to throw at your hated opponents, it’s
    even nicer to have a magical one that will inflict more damage, or even defeat
    enemies with a single hit. You can implement a pickup Blueprint that will make
    good use of the `SetProjectileClass()` function you implemented in the `US_WeaponProjectileComponent`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Upon picking up the item, the character will be granted a variant of the `US_BaseWeaponProjectile`
    class with augmented damage. You can even think about letting defeated enemies
    drop weapon pickups instead of coins!
  prefs: []
  type: TYPE_NORMAL
- en: As an additional feature, you may even think to create throwing rocks that will
    send alert messages upon hitting the ground – just remember to enable gravity
    for the projectile. Having items that can be thrown and that will make noise to
    alert minions and direct them far away from the player characters will add some
    fresh gameplay logic that will improve the overall game experience.
  prefs: []
  type: TYPE_NORMAL
- en: Get ready for a wickedly clever twist, and use your quick wit to dazzle the
    Lichlord’s mindless servants! With brains like yours, who needs brawn?
  prefs: []
  type: TYPE_NORMAL
- en: You are not a machine gun
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, players have the ability to throw an unlimited number of daggers
    during gameplay. While this may be enjoyable initially, it will ultimately disrupt
    the balance of the game and result in a monotonous experience over time.
  prefs: []
  type: TYPE_NORMAL
- en: To make things more interesting (and in favor of the Lichlord’s shadowy plans),
    limit the players to just one throwing dagger projectile at a time. Once the character
    has thrown the weapon, it won’t be able to throw it again until the dagger has
    been recovered.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing this feature is quite straightforward – once the character throws
    the projectile, set the `ProjectileClass` weapon component to a `null` value so
    that the character won’t be able to spawn any more objects. Upon hitting something,
    the thrown weapon will spawn a dagger pickup (see the previous subsection) before
    destroying itself. This will force the character to get to the dropped weapon
    and pick it up in order to attack again.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative feature, you may give your character a limited number of knives
    and use a count variable to check whether the character has any knives available
    every time the player tries to throw one.
  prefs: []
  type: TYPE_NORMAL
- en: Whoever said life in the dungeon would be a walk in the park obviously never
    encountered a horde of undead monsters while armed with a simple (and single!)
    weapon.
  prefs: []
  type: TYPE_NORMAL
- en: No time to waste
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the moment, your characters can walk around calmly and take their time in
    rescuing the prisoners. Why not spice things up by adding a time counter? The
    Lichlord is hosting a grand celebration with the intention of transforming the
    king’s knight into a loyal member of his undead army! Your hero must hurry up
    before it is too late!
  prefs: []
  type: TYPE_NORMAL
- en: You can make good use of the `US_GameMode` class and create a time manager that
    will start as soon as the first player enters the dungeon – if the players can’t
    free every captive from the dungeon, they’ll be royally out of luck and the game
    will be a total flop. It looks like it’s all or nothing for this quest!
  prefs: []
  type: TYPE_NORMAL
- en: Tables, tables everywhere!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As your project progresses, it will become increasingly difficult to keep track
    of all the variations in enemies and weapons. To ease the pain, you can use the
    struct and data table system introduced in [*Chapter 6*](B18203_06.xhtml#_idTextAnchor125)*,
    Replicating Properties* *Over* *the Network,* to create dedicated structures for
    the throwing weapons and AI opponents.
  prefs: []
  type: TYPE_NORMAL
- en: Let your creative side run wild and come up with a ton of amazing Blueprint
    options based on the stats you like best – get ready for your hero adventurers
    to embark on thrilling journeys full of surprises in your game!
  prefs: []
  type: TYPE_NORMAL
- en: Need some help?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have noticed from the previous subsections, once you become familiar
    with your game, the potential outcomes become limitless. You can add any new gameplay
    logic and test it until you are happy.
  prefs: []
  type: TYPE_NORMAL
- en: On my end, I’ll be working on creating exciting new features for the game and
    storing them in my own GitHub repository. Feel free to check in from time to time
    to see what wild and crazy ideas I’ve come up with! The link to the repository
    is [https://github.com/marcosecchi/unrealshadows-ltol](https://github.com/marcosecchi/unrealshadows-ltol).
  prefs: []
  type: TYPE_NORMAL
- en: And if you come up with a clever idea, feel free to contact me and tell me about
    it – if time permits, I will try to implement it and upload it to the repository
    in order to make this project grow!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, you fine-tuned the gameplay logic and added the finishing
    touches. You began by incorporating some nice animations for character movements
    and attacks, elevating the game’s overall appeal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you created someone for the players to rescue: a prisoner Actor
    that can be interacted with and that will grant the thief hero some well-deserved
    experience points.'
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, I shared a few fresh ideas to take your gameplay to the
    next level. By incorporating these ideas, you can make the game truly your own
    and one of a kind. So, get creative and have fun!
  prefs: []
  type: TYPE_NORMAL
- en: Get ready for the next chapter, where you’ll dive into debugging and testing
    a networked game. This will take your development skills to the next level, something
    that’s necessary if you want to become a top-notch multiplayer programmer!
  prefs: []
  type: TYPE_NORMAL
