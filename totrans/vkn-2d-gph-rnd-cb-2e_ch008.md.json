["```cpp\nstruct GLTFContext {\n  explicit GLTFContext(VulkanApp& app_)\n  : app(app_)\n  , samplers(app_.ctx_)\n  , envMapTextures(app_.ctx_) {}\n  GLTFDataHolder glTFDataholder;\n  MaterialsPerFrame matPerFrame;\n  GLTFGlobalSamplers samplers;\n  EnvironmentMapTextures envMapTextures;\n  GLTFFrameData frameData;\n  std::vector<GLTFTransforms> transforms;\n  std::vector<GLTFNode> nodesStorage;\n  std::vector<GLTFMesh> meshesStorage;\n  std::vector<uint32_t> opaqueNodes;\n  std::vector<uint32_t> transmissionNodes;\n  std::vector<uint32_t> transparentNodes;\n  lvk::Holder<lvk::BufferHandle> envBuffer;\n  lvk::Holder<lvk::BufferHandle> perFrameBuffer;\n  lvk::Holder<lvk::BufferHandle> transformBuffer;\n  lvk::Holder<lvk::RenderPipelineHandle> pipelineSolid;\n  lvk::Holder<lvk::RenderPipelineHandle> pipelineTransparent;\n  lvk::Holder<lvk::ShaderModuleHandle> vert;\n  lvk::Holder<lvk::ShaderModuleHandle> frag;\n  lvk::Holder<lvk::BufferHandle> vertexBuffer;\n  lvk::Holder<lvk::BufferHandle> indexBuffer;\n  lvk::Holder<lvk::BufferHandle> matBuffer;\n  lvk::Holder<lvk::TextureHandle> offscreenTex[3] = {};\n  uint32_t currentOffscreenTex = 0;\n  GLTFNodeRef root;\n  VulkanApp& app;\n  bool volumetricMaterial = false;\n  bool isScreenCopyRequired() const {\n    return volumetricMaterial;\n  }\n};\n```", "```cpp\nvoid loadglTF(GLTFContext& context,\n  const char* gltfName, const char* glTFDataPath);\nvoid renderglTF(GLTFContext& context,\n  const mat4& model, const mat4& view, const mat4& proj,\n  bool rebuildRenderList = false);\n```", "```cpp\nenum MaterialType : uint32_t {\n  MaterialType_Invalid            = 0,\n  MaterialType_Unlit              = 0xF,\n  MaterialType_MetallicRoughness  = 0x1,\n  MaterialType_SpecularGlossiness = 0x2,\n  MaterialType_Sheen              = 0x4,\n  MaterialType_ClearCoat          = 0x8,\n  MaterialType_Specular           = 0x10,\n  MaterialType_Transmission       = 0x20,\n  MaterialType_Volume             = 0x40,\n};\n```", "```cpp\nvoid buildTransformsList(GLTFContext& gltf) {\n  gltf.transforms.clear();\n  gltf.opaqueNodes.clear();\n  gltf.transmissionNodes.clear();\n  gltf.transparentNodes.clear();\n```", "```cpp\n std::function<void(GLTFNodeRef gltfNode)> traverseTree =\n    [&]([&](GLTFNodeRef nodeRef) {\n      const GLTFNode& node = gltf.nodesStorage[nodeRef];\n      for (GLTFNodeRef meshId : node.meshes) {\n        const GLTFMesh& mesh = gltf.meshesStorage[meshId];\n        gltf.transforms.push_back({\n          .model = node.transform,\n          .matId = mesh.matIdx,\n          .nodeRef = nodeRef,\n          .meshRef = meshId,\n          .sortingType = mesh.sortingType });\n```", "```cpp\n uint32_t lastTransformIndex = gltf.transforms.size() – 1;\n        if (mesh.sortingType == SortingType_Transparent) {\n          gltf.transparentNodes.push_back(lastTransformIndex);\n        } else if (mesh.sortingType==SortingType_Transmission) {\n          gltf.transmissionNodes.push_back(lastTransformIndex);\n        } else {\n          gltf.opaqueNodes.push_back(lastTransformIndex );\n        }\n      }\n      for (GLTFNodeRef child : node.children)\n        traverseTree(child);\n    };\n```", "```cpp\n traverseTree(gltf.root);\n  gltf.transformBuffer = gltf.app.ctx_->createBuffer({\n    .usage     = lvk::BufferUsageBits_Uniform,\n    .storage   = lvk::StorageType_HostVisible,\n    .size      = gltf.transforms.size() * sizeof(GLTFTransforms),\n    .data      = &gltf.transforms[0],\n    .debugName = “Per Frame data” });\n};\n```", "```cpp\nvoid sortTransparentNodes(\n  GLTFContext& gltf, const vec3& cameraPos) {\n  std::sort(\n    gltf.transparentNodes.begin(),\n    gltf.transparentNodes.end(),\n    [&](uint32_t a, uint32_t b) {\n      float sqrDistA = glm::length2(\n        cameraPos-vec3(gltf.transforms[a].model[3]));\n      float sqrDistB = glm::length2(\n        cameraPos-vec3(gltf.transforms[b].model[3]));\n      return sqrDistA < sqrDistB;\n  });\n}\n```", "```cpp\nvoid renderGLTF(GLTFContext& gltf,\n  const mat4& model, const mat4& view, const mat4& proj,\n  bool rebuildRenderList)\n{\n  auto& ctx = gltf.app.ctx_;\n  const vec4 camPos = glm::inverse(view)[3];\n  if (rebuildRenderList || gltf.transforms.empty()) {\n    buildTransformsList(gltf);\n  }\n  sortTransparentNodes(gltf, camPos);\n```", "```cpp\n gltf.frameData = {\n    .model     = model,\n    .view      = view,\n    .proj      = proj,\n    .cameraPos = camPos,\n  };\n  struct PushConstants {\n    uint64_t draw;\n    uint64_t materials;\n    uint64_t environments;\n    uint64_t transforms;\n    uint32_t envId;\n    uint32_t transmissionFramebuffer;\n    uint32_t transmissionFramebufferSampler;\n  } pushConstants = {\n    .draw         = ctx->gpuAddress(gltf.perFrameBuffer),\n    .materials    = ctx->gpuAddress(gltf.matBuffer),\n    .environments = ctx->gpuAddress(gltf.envBuffer),\n    .transforms   = ctx->gpuAddress(gltf.transformBuffer),\n    .envId        = 0,\n    .transmissionFramebuffer = 0,\n    .transmissionFramebufferSampler =\n      gltf.samplers.clamp.index(),\n  };\n  ctx->upload(\n    gltf.perFrameBuffer, &gltf.frameData, sizeof(GLTFFrameData));\n  …\n```", "```cpp\n const lvk::RenderPass renderPass = {\n    .color = { { .loadOp = lvk::LoadOp_Clear,\n                 .clearColor = { 1.0f, 1.0f, 1.0f, 1.0f } } },\n    .depth = { .loadOp = lvk::LoadOp_Clear, .clearDepth = 1.0f },\n  };\n  const lvk::Framebuffer framebuffer = {\n    .color        = { {\n     .texture = screenCopy ?\n       gltf.offscreenTex[gltf.currentOffscreenTex] : \n       ctx->getCurrentSwapchainTexture() } },\n    .depthStencil = { .texture = gltf.app.getDepthTexture() },\n  };\n  buf.cmdBeginRendering(renderPass, framebuffer);\n  buf.cmdBindVertexBuffer(0, gltf.vertexBuffer, 0);\n  buf.cmdBindIndexBuffer(\n    gltf.indexBuffer, lvk::IndexFormat_UI32);\n  buf.cmdBindDepthState({ .compareOp = lvk::CompareOp_Less,\n                          .isDepthWriteEnabled = true });\n  buf.cmdBindRenderPipeline(gltf.pipelineSolid);\n  buf.cmdPushConstants(pushConstants);\n  for (uint32_t transformId : gltf.opaqueNodes) {\n    GLTFTransforms transform = gltf.transforms[transformId];\n    buf.cmdPushDebugGroupLabel(\n      gltf.nodesStorage[transform.nodeRef].name.c_str(),\n      0xff0000ff);\n    const GLTFMesh submesh =\n      gltf.meshesStorage[transform.meshRef];\n```", "```cpp\n    vkCmdDrawIndexed(VkCommandBuffer commandBuffer,\n                     uint32_t        indexCount,    \n                     uint32_t        instanceCount, \n                     uint32_t        firstIndex,\n                     int32_t         vertexOffset,\n                     uint32_t        firstInstance);\n    ```", "```cpp\n buf.cmdDrawIndexed(submesh.indexCount, 1,\n      submesh.indexOffset, submesh.vertexOffset, transformId);\n    buf.cmdPopDebugGroupLabel();\n  }\n  buf.cmdEndRendering();\n  …\n```", "```cpp\n if (screenCopy) {\n    buf.cmdCopyImage(\n      gltf.offscreenTex[gltf.currentOffscreenTex],\n      ctx->getCurrentSwapchainTexture(),\n      ctx->getDimensions(ctx->getCurrentSwapchainTexture()));\n    buf.cmdGenerateMipmap(\n      gltf.offscreenTex[gltf.currentOffscreenTex]);\n    pushConstants.transmissionFramebuffer =\n      gltf.offscreenTex[gltf.currentOffscreenTex].index();\n    buf.cmdPushConstants(pushConstants);\n  }\n```", "```cpp\n buf.cmdBeginRendering(renderPass, framebuffer, {\n    .textures = { lvk::TextureHandle(\n      gltf.offscreenTex[gltf.currentOffscreenTex]) } });\n  buf.cmdBindVertexBuffer(0, gltf.vertexBuffer, 0);\n  buf.cmdBindIndexBuffer(\n    gltf.indexBuffer, lvk::IndexFormat_UI32);\n  buf.cmdBindDepthState({ .compareOp = lvk::CompareOp_Less,\n                          .isDepthWriteEnabled = true });\n```", "```cpp\n buf.cmdBindRenderPipeline(gltf.pipelineSolid);\n  for (uint32_t transformId : gltf.transmissionNodes) {\n    const GLTFTransforms transform =\n      gltf.transforms[transformId];\n    buf.cmdPushDebugGroupLabel(\n      gltf.nodesStorage[transform.nodeRef].name.c_str(),\n      0x00FF00ff);\n    const GLTFMesh submesh =\n      gltf.meshesStorage[transform.meshRef];\n    buf.cmdDrawIndexed(submesh.indexCount, 1,\n      submesh.indexOffset, submesh.vertexOffset, transformId);\n    buf.cmdPopDebugGroupLabel();\n  }\n```", "```cpp\n buf.cmdBindRenderPipeline(gltf.pipelineTransparent);\n  for (uint32_t transformId : gltf.transparentNodes) {\n    const GLTFTransforms transform =\n      gltf.transforms[transformId];\n    buf.cmdPushDebugGroupLabel(\n      gltf.nodesStorage[transform.nodeRef].name.c_str(),\n      0x00FF00ff);\n    const GLTFMesh submesh =\n      gltf.meshesStorage[transform.meshRef];\n    buf.cmdDrawIndexed(submesh.indexCount, 1,\n      submesh.indexOffset, submesh.vertexOffset, transformId);\n    buf.cmdPopDebugGroupLabel();\n  }\n```", "```cpp\n buf.cmdEndRendering();\n  ctx->submit(buf, ctx->getCurrentSwapchainTexture());\n  gltf.currentOffscreenTex = (gltf.currentOffscreenTex + 1) %\n    LVK_ARRAY_NUM_ELEMENTS(gltf.offscreenTex);\n```", "```cpp\n VulkanApp app({\n      .initialCameraPos    = vec3(0.0f, -0.2f, -1.5f),\n      .initialCameraTarget = vec3(0.0f, -0.5f, 0.0f),\n  });\n  GLTFContext gltf(app);\n  loadGLTF(gltf,\n    “deps/src/glTF-Sample-Assets/Models/ClearcoatWicker/\n      glTF/ClearcoatWicker.gltf”,\n    “deps/src/glTF-Sample-Assets/Models/ClearcoatWicker/glTF/”);\n```", "```cpp\n const mat4 t = glm::translate(mat4(1.0f), vec3(0, -1, 0));\n  app.run([&](uint32_t width, uint32_t height,\n              float aspectRatio, float deltaSeconds) {\n    const mat4 m = t * glm::rotate(\n      mat4(1.0f),  (float)glfwGetTime(), vec3(0.0f, 1.0f, 0.0f));\n    const mat4 v = app.camera_.getViewMatrix();\n    const mat4 p = glm::perspective(\n      45.0f, aspectRatio, 0.01f, 100.0f);\n    renderGLTF(gltf, m, v, p);\n  });\n```", "```cpp\nstruct GLTFMaterialDataGPU {\n  …\n  vec4 clearcoatTransmissionThickness = vec4(1, 1, 1, 1);\n  uint32_t clearCoatTexture                 = 0;\n  uint32_t clearCoatTextureSampler          = 0;\n  uint32_t clearCoatTextureUV               = 0;\n  uint32_t clearCoatRoughnessTexture        = 0;\n  uint32_t clearCoatRoughnessTextureSampler = 0;\n  uint32_t clearCoatRoughnessTextureUV      = 0;\n  uint32_t clearCoatNormalTexture           = 0;\n  uint32_t clearCoatNormalTextureSampler    = 0;\n  uint32_t clearCoatNormalTextureUV         = 0;\n  …\n}\n```", "```cpp\nGLTFMaterialDataGPU setupglTFMaterialData(\n  const std::unique_ptr<lvk::IContext>& ctx,\n  const GLTFGlobalSamplers& samplers,\n  const aiMaterial* mtlDescriptor,\n  const char* assetFolder,\n  GLTFDataHolder& glTFDataholder,\n  bool& useVolumetric)\n{\n  …\n  // clearcoat\n  loadMaterialTexture(mtlDescriptor, aiTextureType_CLEARCOAT,\n    assetFolder, mat.clearCoatTexture, ctx, true, 0);\n  loadMaterialTexture(mtlDescriptor, aiTextureType_CLEARCOAT,\n    assetFolder, mat.clearCoatRoughnessTexture, ctx, false, 1);\n  loadMaterialTexture(mtlDescriptor, aiTextureType_CLEARCOAT,\n    assetFolder, mat.clearCoatNormalTexture, ctx, false, 2);\n  …\n  bool useClearCoat = !mat.clearCoatTexture.empty() ||\n                      !mat.clearCoatRoughnessTexture.empty() ||\n                      !mat.clearCoatNormalTexture.empty();\n  ai_real clearcoatFactor;\n  if (mtlDescriptor->Get(AI_MATKEY_CLEARCOAT_FACTOR,\n    clearcoatFactor) == AI_SUCCESS) {\n    res.clearcoatTransmissionThickness.x = clearcoatFactor;\n    useClearCoat = true;\n  }\n  ai_real clearcoatRoughnessFactor;\n  if (mtlDescriptor->Get(AI_MATKEY_CLEARCOAT_ROUGHNESS_FACTOR,\n    clearcoatRoughnessFactor) == AI_SUCCESS) {\n    res.clearcoatTransmissionThickness.y =\n      clearcoatRoughnessFactor;\n    useClearCoat = true;\n  }\n  if (assignUVandSampler(\n        samplers, mtlDescriptor, aiTextureType_CLEARCOAT,\n        res.clearCoatTextureUV,\n        res.clearCoatNormalTextureSampler, 0)) {\n    useClearCoat = true;\n  }\n  if (assignUVandSampler(\n        samplers, mtlDescriptor, aiTextureType_CLEARCOAT,\n        res.clearCoatRoughnessTextureUV, \n        res.clearCoatRoughnessTextureSampler, 1)) {\n    useClearCoat = true;\n  }\n  if (assignUVandSampler(\n        samplers, mtlDescriptor, aiTextureType_CLEARCOAT,\n        res.clearCoatNormalTextureUV,\n        res.clearCoatNormalTextureSampler, 2)) {\n    useClearCoat = true;\n  }\n  if (useClearCoat) \n    res.materialTypeFlags |= MaterialType_ClearCoat;\n```", "```cpp\nfloat getClearcoatFactor(InputAttributes tc,\n                         MetallicRoughnessDataGPU mat)\n{\n  return textureBindless2D(mat.clearCoatTexture,\n    mat.clearCoatTextureSampler,\n    tc.uv[mat.clearCoatTextureUV]\n  ).r * mat.clearcoatTransmissionThickness.x;\n}\nfloat getClearcoatRoughnessFactor(InputAttributes tc,\n                                  MetallicRoughnessDataGPU mat)\n{\n  return textureBindless2D(mat.clearCoatRoughnessTexture,\n    mat.clearCoatRoughnessTextureSampler,\n    tc.uv[mat.clearCoatRoughnessTextureUV]\n  ).g * mat.clearcoatTransmissionThickness.y;\n}\n```", "```cpp\n vec3 clearCoatContrib = vec3(0);\n  if (isClearCoat) {\n    pbrInputs.clearcoatFactor = getClearcoatFactor(tc, mat);\n    pbrInputs.clearcoatRoughness =\n      clamp(getClearcoatRoughnessFactor(tc, mat), 0.0, 1.0);\n    pbrInputs.clearcoatF0 = vec3(pow((pbrInputs.ior - 1.0) /\n                            (pbrInputs.ior + 1.0), 2.0));\n    pbrInputs.clearcoatF90 = vec3(1.0);\n    if (mat.clearCoatNormalTextureUV > -1) {\n      pbrInputs.clearcoatNormal = mat3(\n        pbrInputs.t, pbrInputs.b, pbrInputs.ng) *\n        sampleClearcoatNormal(tc, mat).rgb;\n    } else {\n      pbrInputs.clearcoatNormal = pbrInputs.ng;\n    }\n    clearCoatContrib = getIBLRadianceGGX(\n      pbrInputs.clearcoatNormal, pbrInputs.v,\n      pbrInputs.clearcoatRoughness,\n      pbrInputs.clearcoatF0, 1.0, envMap);\n  }\n```", "```cpp\n vec3 clearcoatFresnel = vec3(0);\n  if (isClearCoat) {\n    clearcoatFresnel = F_Schlick(\n      pbrInputs.clearcoatF0,\n      pbrInputs.clearcoatF90,\n      clampedDot(pbrInputs.clearcoatNormal, pbrInputs.v));\n  }\n```", "```cpp\n vec3 color =\n    specularColor + diffuseColor + emissiveColor + sheenColor;\n  color = color *\n    (1.0 - pbrInputs.clearcoatFactor * clearcoatFresnel) +\n    clearCoatContrib;\n```", "```cpp\n GLTFContext gltf(app);\n  loadGLTF(gltf,\n    “deps/src/glTF-Sample-Assets/Models/\n      SheenChair/glTF/SheenChair.gltf”,\n    “deps/src/glTF-Sample-Assets/Models/SheenChair/glTF/”);\n```", "```cpp\nstruct GLTFMaterialDataGPU {\n  …\n  vec4 sheenFactors       = vec4(1.0f, 1.0f, 1.0f, 1.0f);\n  uint32_t sheenColorTexture            = 0;\n  uint32_t sheenColorTextureSampler     = 0;\n  uint32_t sheenColorTextureUV          = 0;\n  uint32_t sheenRoughnessTexture        = 0;\n  uint32_t sheenRoughnessTextureSampler = 0;\n  uint32_t sheenRoughnessTextureUV      = 0;\n```", "```cpp\n loadMaterialTexture(mtlDescriptor, aiTextureType_SHEEN,\n    assetFolder, mat.sheenColorTexture, ctx, true, 0);\n  loadMaterialTexture(mtlDescriptor, aiTextureType_SHEEN,\n    assetFolder, mat.sheenRoughnessTexture, ctx, false, 1);\n  bool useSheen = !mat.sheenColorTexture.empty() ||\n                  !mat.sheenRoughnessTexture.empty();\n  aiColor4D sheenColorFactor;\n  if (mtlDescriptor->Get(AI_MATKEY_SHEEN_COLOR_FACTOR,\n      sheenColorFactor) == AI_SUCCESS) {\n    res.sheenFactors = vec4(sheenColorFactor.r,\n                            sheenColorFactor.g,\n                            sheenColorFactor.b,\n                            sheenColorFactor.a);\n    useSheen      = true;\n  }\n  ai_real sheenRoughnessFactor;\n  if (mtlDescriptor->Get(AI_MATKEY_SHEEN_ROUGHNESS_FACTOR,\n      sheenRoughnessFactor) == AI_SUCCESS) {\n    res.sheenFactors.w = sheenRoughnessFactor;\n    useSheen = true;\n  }\n  if (assignUVandSampler(samplers, mtlDescriptor,\n      aiTextureType_SHEEN, res.sheenColorTextureUV,\n      res.sheenColorTextureSampler, 0)) {\n    useSheen = true;\n  }\n  if (assignUVandSampler(samplers, mtlDescriptor,\n      aiTextureType_SHEEN, res.sheenRoughnessTextureUV,\n      res.sheenRoughnessTextureSampler, 1)) {\n    useSheen = true;\n  }\n  if (useSheen) res.materialTypeFlags |= MaterialType_Sheen;\n  …\n```", "```cpp\nvec4 getSheenColorFactor(InputAttributes tc,\n  MetallicRoughnessDataGPU mat) {\n  return vec4(mat.sheenFactors.xyz, 1.0f) *\n    textureBindless2D(mat.sheenColorTexture,\n                      mat.sheenColorTextureSampler,\n                      tc.uv[mat.sheenColorTextureUV]);\n}\nfloat getSheenRoughnessFactor(InputAttributes tc,\n  MetallicRoughnessDataGPU mat) {\n  return mat.sheenFactors.a * textureBindless2D(\n    mat.sheenRoughnessTexture,\n    mat.sheenRoughnessTextureSampler,\n    tc.uv[mat.sheenRoughnessTextureUV]).a;\n}\n```", "```cpp\n …\n  if (isSheen) {\n    pbrInputs.sheenColorFactor =\n      getSheenColorFactor(tc, mat).rgb;\n    pbrInputs.sheenRoughnessFactor =\n      getSheenRoughnessFactor(tc, mat);\n  }\n  …\n```", "```cpp\n vec3 sheenColor = vec3(0);\n  if (isSheen) {\n    sheenColor += getIBLRadianceCharlie(pbrInputs, envMap);\n  }\n```", "```cpp\nvec3 getIBLRadianceCharlie(PBRInfo pbrInputs,\n  EnvironmentMapDataGPU envMap) {\n  float sheenRoughness = pbrInputs.sheenRoughnessFactor;\n  vec3 sheenColor = pbrInputs.sheenColorFactor;\n  float mipCount = float(sampleEnvMapQueryLevels(envMap));\n  float lod = sheenRoughness * float(mipCount - 1);\n  vec3 reflection =\n    normalize(reflect(-pbrInputs.v, pbrInputs.n));\n  vec2 brdfSamplePoint = clamp(vec2(pbrInputs.NdotV,\n    sheenRoughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n  float brdf = sampleBRDF_LUT(brdfSamplePoint, envMap).b;\n  vec3 sheenSample = sampleCharlieEnvMapLod(\n    reflection.xyz, lod, envMap).rgb;\n  return sheenSample * sheenColor * brdf;\n}\n```", "```cpp\n vec3 lights_sheen = vec3(0);\n  sheenColor = lights_sheen +\n    mix(sheenColor, sheenColor * occlusion, occlusionStrength);\n```", "```cpp\n GLTFContext gltf(app);\n  loadGLTF(gltf, “deps/src/glTF-Sample-Assets/Models/\n      TransmissionRoughnessTest/glTF/\n      TransmissionRoughnessTest.gltf”,\n    “deps/src/glTF-Sample-Assets/Models/\n      TransmissionRoughnessTest/glTF/”);\n```", "```cpp\n loadMaterialTexture(mtlDescriptor, aiTextureType_TRANSMISSION,\n    assetFolder, mat.transmissionTexture, ctx, true, 0);\n  …\n  bool useTransmission = !mat.transmissionTexture.empty();\n  ai_real transmissionFactor = 0.0f;\n  if (mtlDescriptor->Get(AI_MATKEY_TRANSMISSION_FACTOR,\n      transmissionFactor) == AI_SUCCESS) {\n    res.clearcoatTransmissionThickness.z = transmissionFactor;\n    useTransmission = true;\n  }\n  if (useTransmission) {\n    res.materialTypeFlags |= MaterialType_Transmission;\n    useVolumetric = true;\n  }\n  assignUVandSampler(samplers, mtlDescriptor,\n    aiTextureType_TRANSMISSION, res.transmissionTextureUV,\n    res.transmissionTextureSampler, 0);\n```", "```cpp\n if (gltf.offscreenTex[0].empty() || isSizeChanged) {\n    const lvk::Dimensions res =\n      ctx->getDimensions(ctx->getCurrentSwapchainTexture());\n    for (Holder<TextureHandle>& holder : gltf.offscreenTex) {\n      holder = ctx->createTexture({\n          .type         = lvk::TextureType_2D,\n          .format       = ctx->getSwapchainFormat(),\n          .dimensions   = {res.width, res.height},\n          .usage        = lvk::TextureUsageBits_Attachment |\n                          lvk::TextureUsageBits_Sampled,\n          .numMipLevels = lvk::calcNumMipLevels(res.width,\n                                                res.height),\n          .debugName    = “offscreenTex” });\n    }\n  }\n```", "```cpp\n const bool screenCopy = gltf.isScreenCopyRequired();\n  if (screenCopy) {\n    buf.cmdCopyImage(\n      gltf.offscreenTex[gltf.currentOffscreenTex],],\n      ctx->getCurrentSwapchainTexture(),\n      ctx->getDimensions(ctx->getCurrentSwapchainTexture()));\n    buf.cmdGenerateMipmap(\n      gltf.offscreenTex[gltf.currentOffscreenTex]);\n    pushConstants.transmissionFramebuffer =\n      gltf.offscreenTex[gltf.currentOffscreenTex].index();\n    buf.cmdPushConstants(pushConstants);\n  }\n```", "```cpp\n buf.cmdBeginRendering(renderPass, framebuffer, { .textures = {\n      lvk::TextureHandle(\n        gltf.offscreenTex[gltf.currentOffscreenTex]) } });\n  buf.cmdBindVertexBuffer(0, gltf.vertexBuffer, 0);\n  buf.cmdBindIndexBuffer(\n    gltf.indexBuffer, lvk::IndexFormat_UI32);\n  buf.cmdBindDepthState({ .compareOp = lvk::CompareOp_Less,\n                          .isDepthWriteEnabled = true });\n  buf.cmdBindRenderPipeline(gltf.pipelineSolid);\n  for (uint32_t transformId : gltf.transmissionNodes) {\n    const GLTFTransforms transform =\n      gltf.transforms[transformId];\n    const GLTFMesh submesh =\n      gltf.meshesStorage[transform.meshRef];\n    buf.cmdDrawIndexed(submesh.indexCount, 1,\n      submesh.indexOffset, submesh.vertexOffset, transformId);\n  }\n```", "```cpp\n buf.cmdBindRenderPipeline(gltf.pipelineTransparent);\n  for (uint32_t transformId : gltf.transparentNodes) {\n    const GLTFTransforms transform =\n      gltf.transforms[transformId];\n\n    const GLTFMesh submesh =\n      gltf.meshesStorage[transform.meshRef];\n    buf.cmdDrawIndexed(submesh.indexCount, 1,\n      submesh.indexOffset, submesh.vertexOffset, transformId);\n  }}\n```", "```cpp\nfloat getTransmissionFactor(InputAttributes tc,\n  MetallicRoughnessDataGPU mat) {\n  return mat.clearcoatTransmissionThickness.z\n         textureBindless2D(mat.transmissionTexture,\n           mat.transmissionTextureSampler,\n           tc.uv[mat.transmissionTextureUV]\n         ).r;\n}\n```", "```cpp\n if (isTransmission) {\n    pbrInputs.transmissionFactor =\n      getTransmissionFactor(tc, mat);\n  }\n```", "```cpp\n vec3 transmission = vec3(0,0,0);\n  if (isTransmission) {\n    transmission += getIBLVolumeRefraction(\n      pbrInputs.n,\n      pbrInputs.v,\n      pbrInputs.perceptualRoughness,\n      pbrInputs.diffuseColor,\n      pbrInputs.reflectance0,\n      pbrInputs.reflectance90,\n      worldPos, getModel(), getViewProjection(),\n      pbrInputs.ior,\n      pbrInputs.thickness,\n      pbrInputs.attenuation.rgb,\n      pbrInputs.attenuation.a);\n  }\n```", "```cpp\n if (isTransmission) {\n    diffuseColor = mix(diffuseColor, transmission,\n                       pbrInputs.transmissionFactor);\n  }\n```", "```cpp\n GLTFContext gltf(app);\n  loadGLTF(gltf, “deps/src/glTF-Sample-Assets/Models/\n    DragonAttenuation/glTF/DragonAttenuation.gltf”,\n   “deps/src/glTF-Sample-Assets/Models/DragonAttenuation/glTF/”);\n```", "```cpp\n …\n  loadMaterialTexture(mtlDescriptor, aiTextureType_TRANSMISSION,\n    assetFolder, mat.thicknessTexture, ctx, true, 1);\n  bool useVolume = !mat.thicknessTexture.empty();\n  ai_real thicknessFactor = 0.0f;\n  if (mtlDescriptor->Get(AI_MATKEY_VOLUME_THICKNESS_FACTOR,\n      thicknessFactor) == AI_SUCCESS) {\n    res.clearcoatTransmissionThickness.w = thicknessFactor;\n    useVolume = true;\n  }\n  ai_real attenuationDistance = 0.0f;\n  if (mtlDescriptor->Get(AI_MATKEY_VOLUME_ATTENUATION_DISTANCE,\n      attenuationDistance) == AI_SUCCESS) {\n    res.attenuation.w = attenuationDistance;\n    useVolume =      true;\n  }\n  aiColor4D volumeAttnuationColorvolumeAttnuationColore;\n  if (mtlDescriptor->Get(AI_MATKEY_VOLUME_ATTENUATION_COLOR,\n      volumeAttnuationColorvolumeAttnuationColore)==AI_SUCCESS) {\n    res.attenuation.x =\n      volumeAttnuationColorvolumeAttnuationColore.r;\n    res.attenuation.y =\n      volumeAttnuationColorvolumeAttnuationColore.g;\n    res.attenuation.z =\n      volumeAttnuationColorvolumeAttnuationColore.b;\n    useVolume = true;\n  }\n  if (useVolume) {\n    res.materialTypeFlags |= MaterialType_Transmission |\n                             MaterialType_Volume;\n    useVolumetric = true;\n  }\n  assignUVandSampler(samplers, mtlDescriptor,\n    aiTextureType_TRANSMISSION, res.thicknessTextureUV,\n    res.thicknessTextureSampler, 1);\n  …\n```", "```cpp\nvec3 getVolumeTransmissionRay(\n  vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix)\n{\n  vec3 refractionVector = refract(-v, n, 1.0 / ior);\n```", "```cpp\n vec3 modelScale = vec3(length(modelMatrix[0].xyz),\n                         length(modelMatrix[1].xyz),\n                         length(modelMatrix[2].xyz));\n  return\n    normalize(refractionVector) * thickness * modelScale.xyz;\n}\n```", "```cpp\nvec3 getIBLVolumeRefraction(vec3 n, vec3 v,\n  float perceptualRoughness, vec3 baseColor, vec3 f0, vec3 f90,\n  vec3 position, mat4 modelMatrix, mat4 viewProjMatrix,\n  float ior, float thickness, vec3 attenuationColor,\n  float attenuationDistance)\n{\n  vec3 transmissionRay =\n    getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n  vec3 refractedRayExit = position + transmissionRay;\n```", "```cpp\n vec4 ndcPos = viewProjMatrix * vec4(refractedRayExit, 1.0);\n  vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n  refractionCoords += 1.0;\n  refractionCoords /= 2.0;\n  refractionCoords.y = 1.0 - refractionCoords.y;\n  vec3 transmittedLight = getTransmissionSample(\n    refractionCoords, perceptualRoughness, ior);\n```", "```cpp\n vec3 attenuatedColor = applyVolumeAttenuation(\n    transmittedLight,\n    length(transmissionRay), attenuationColor,\n    attenuationDistance);\n  float NdotV = clampedDot(n, v);\n  vec2 brdfSamplePoint = clamp(vec2(NdotV, perceptualRoughness),\n    vec2(0.0, 0.0), vec2(1.0, 1.0));\n  vec2 brdf = sampleBRDF_LUT(brdfSamplePoint,\n    getEnvironmentMap(getEnvironmentId())).rg;\n  vec3 specularColor = f0 * brdf.x + f90 * brdf.y;\n  return (1.0 - specularColor) * attenuatedColor * baseColor;\n}\n```", "```cpp\nvec3 getTransmissionSample(\n  vec2 fragCoord, float roughness, float ior)\n{\n  const ivec2 size =\n    textureBindlessSize2D(perFrame.transmissionFramebuffer);\n  const vec2 uv = fragCoord;\n  float framebufferLod =\n    log2(float(size.x)) * applyIorToRoughness(roughness, ior);\n  vec3 transmittedLight = textureBindless2DLod(\n    perFrame.transmissionFramebuffer,\n    perFrame.transmissionFramebufferSampler,\n    uv, framebufferLod).rgb;\n  return transmittedLight;\n}\n```", "```cpp\nvec3 applyVolumeAttenuation(vec3 radiance,\n  float transmissionDistance, vec3 attenuationColor,\n  float attenuationDistance)\n{\n  if (attenuationDistance == 0.0) return radiance;\n  vec3 attenuationCoefficient =\n    -log(attenuationColor) / attenuationDistance;\n  vec3 transmittance =\n    exp(-attenuationCoefficient * transmissionDistance);\n  return transmittance * radiance;\n}\n```", "```cpp\n …\n  vec3 transmission = vec3(0,0,0);\n  if (isTransmission) {\n    transmission += getIBLVolumeRefraction(\n      pbrInputs.n, pbrInputs.v,\n      pbrInputs.perceptualRoughness,\n      pbrInputs.diffuseColor, pbrInputs.reflectance0,\n      pbrInputs.reflectance90,\n      worldPos, getModel(), getViewProjection(),\n      pbrInputs.ior, pbrInputs.thickness,\n      pbrInputs.attenuation.rgb, pbrInputs.attenuation.w);\n  }\n```", "```cpp\n GLTFContext gltf(app);\n  loadGLTF(gltf,\n    “deps/src/glTF-Sample-Assets/Models/\n      MosquitoInAmber/glTF/MosquitoInAmber.gltf”,\n    “deps/src/glTF-Sample-Assets/Models/MosquitoInAmber/glTF/”);\n```", "```cpp\nai_real ior;\nif (mtlDescriptor->Get(AI_MATKEY_REFRACTI, ior) == AI_SUCCESS) {\n  res.ior = ior;\n}\n```", "```cpp\nPBRInfo calculatePBRInputsMetallicRoughness(InputAttributes tc,\n  vec4 albedo, vec4 mrSample, MetallicRoughnessDataGPU mat) {\n  PBRInfo pbrInputs;\n  …\n  vec3 f0 = isSpecularGlossiness ?\n    getSpecularFactor(mat) * mrSample.rgb :\n    vec3(pow((pbrInputs.ior - 1)/( pbrInputs.ior + 1), 2));\n```", "```cpp\n if (isClearCoat) {\n    …\n    pbrInputs.clearcoatF0 = vec3(\n      pow((pbrInputs.ior - 1.0) / (pbrInputs.ior + 1.0), 2.0));\n    …\n  }\n```", "```cpp\n VulkanApp app({\n      .initialCameraPos    = vec3(0.0f, -0.5f, -1.0f),\n      .initialCameraTarget = vec3(0.0f, -1.0f, 0.0f),\n  });\n  GLTFContext gltf(app);\n  loadGLTF(gltf, “deps/src/glTF-Sample-Assets/Models/\n    SpecularSilkPouf/glTF/SpecularSilkPouf.gltf”,\n    “deps/src/glTF-Sample-Assets/Models/SpecularSilkPouf/glTF/”);\n```", "```cpp\n const bool rotateModel = true;\n  const mat4 t = glm::translate(mat4(1.0f), vec3(0, -1, 0));\n  app.run([&](uint32_t width, uint32_t height,\n    float aspectRatio, float deltaSeconds)\n  {\n    const mat4 m = t * glm::rotate(mat4(1.0f),\n      rotateModel ? (float)glfwGetTime() : 0.0f,\n      vec3(0.0f, 1.0f, 0.0f));\n    const mat4 p =\n      glm::perspective(45.0f, aspectRatio, 0.01f, 100.0f);\n    renderGLTF(gltf, m, app.camera_.getViewMatrix(), p);\n  });\n```", "```cpp\n loadMaterialTexture(mtlDescriptor, aiTextureType_SPECULAR,\n    assetFolder, mat.specularTexture, ctx, true, 0);\n  loadMaterialTexture(mtlDescriptor, aiTextureType_SPECULAR,\n    assetFolder, mat.specularColorTexture, ctx, true, 1);…\n  bool useSpecular = !mat.specularColorTexture.empty() ||\n                     !mat.specularTexture.empty();\n  ai_real specularFactor;\n  if (mtlDescriptor->Get(AI_MATKEY_SPECULAR_FACTOR,\n      specularFactor) == AI_SUCCESS) {\n    res.specularFactors.w = specularFactor;\n    useSpecular           = true;\n  }\n  assignUVandSampler(samplers, mtlDescriptor,\n    aiTextureType_SPECULAR, res.specularTextureUV,\n    res.specularTextureSampler, 0);\n  aiColor4D specularColorFactor;\n  if (mtlDescriptor->Get(AI_MATKEY_COLOR_SPECULAR,\n      specularColorFactor) == AI_SUCCESS) {\n    res.specularFactors = vec4(specularColorFactor.r,\n                               specularColorFactor.g,\n                               specularColorFactor.b,\n                               res.specularFactors.w);\n    useSpecular = true;\n  }\n  assignUVandSampler(samplers, mtlDescriptor,\n    aiTextureType_SPECULAR, res.specularColorTextureUV,\n    res.specularColorTextureSampler, 1);\n  if (useSpecular)\n    res.materialTypeFlags |= MaterialType_Specular;\n}\n```", "```cpp\nvec3 getSpecularColorFactor(InputAttributes tc,\n  MetallicRoughnessDataGPU mat) {\n  return mat.specularFactors.rgb *\n    textureBindless2D(mat.specularColorTexture,\n                      mat.specularColorTextureSampler,\n                      tc.uv[mat.specularColorTextureUV]).rgb;\n}\nfloat getSpecularFactor(InputAttributes tc,\n  MetallicRoughnessDataGPU mat) {\n  return mat.specularFactors.a *\n    textureBindless2D(mat.specularTexture,\n                      mat.specularTextureSampler,\n                      tc.uv[mat.specularTextureUV]).a;\n}\n```", "```cpp\nstruct PBRInfo {\n  …\n  float specularWeight;\n};\n```", "```cpp\nPBRInfo calculatePBRInputsMetallicRoughness(InputAttributes tc,\n  vec4 albedo, vec4 mrSample, MetallicRoughnessDataGPU mat) { \n  …\n  if (isSpecular) {\n    vec3 dielectricSpecularF0 =\n      min(f0 *       getSpecularColorFactor(tc, mat), vec3(1.0));\n    f0 = mix(dielectricSpecularF0, pbrInputs.baseColor.rgb,\n             metallic);\n    pbrInputs.specularWeight = getSpecularFactor(tc, mat);\n  }\n  …\n  vec3 specularColor = isSpecularGlossiness ? f0 :\n    mix(f0, pbrInputs.baseColor.rgb, metallic);\n  float reflectance = max(\n    max(specularColor.r, specularColor.g), specularColor.b);\n  …\n```", "```cpp\n vec3 specularColor = getIBLRadianceContributionGGX(\n    pbrInputs, pbrInputs.specularWeight, envMap);\n  vec3 diffuseColor = getIBLRadianceLambertian(pbrInputs.NdotV,\n    n, pbrInputs.perceptualRoughness, pbrInputs.diffuseColor,\n    pbrInputs.reflectance0, pbrInputs.specularWeight, envMap);\n```", "```cpp\nvec3 getIBLRadianceContributionGGX(PBRInfo pbrInputs,\n  float specularWeight, EnvironmentMapDataGPU envMap) {\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 reflection = normalize(reflect(-v, n));\n  float mipCount = float(sampleEnvMapQueryLevels(envMap));\n  float lod = pbrInputs.perceptualRoughness * (mipCount - 1);\n  vec2 brdfSamplePoint = clamp(\n    vec2(pbrInputs.NdotV, pbrInputs.perceptualRoughness),\n    vec2(0.0, 0.0), vec2(1.0, 1.0));\n  vec3 brdf = sampleBRDF_LUT(brdfSamplePoint, envMap).rgb;\n  vec3 specularLight =\n    sampleEnvMapLod(reflection.xyz, lod, envMap).rgb;\n  vec3 Fr = max(vec3(1.0 - pbrInputs.perceptualRoughness),\n                pbrInputs.reflectance0) - pbrInputs.reflectance0;\n  vec3 k_S =\n    pbrInputs.reflectance0 + Fr * pow(1.0-pbrInputs.NdotV, 5.0);\n  vec3 FssEss = k_S * brdf.x + brdf.y;\n  return specularWeight * specularLight * FssEss;\n}\n```", "```cpp\nvec3 getIBLRadianceLambertian(float NdotV, vec3 n,\n  float roughness, vec3 diffuseColor, vec3 F0,\n  float specularWeight, EnvironmentMapDataGPU envMap) {\n  vec2 brdfSamplePoint =\n    clamp(vec2(NdotV, roughness), vec2(0., 0.), vec2(1., 1.));\n  vec2 f_ab = sampleBRDF_LUT(brdfSamplePoint, envMap).rg;\n  vec3 irradiance = sampleEnvMapIrradiance(n.xyz, envMap).rgb;\n  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n  vec3 k_S = F0 + Fr * pow(1.0 - NdotV, 5.0);\n  vec3 FssEss = specularWeight * k_S * f_ab.x + f_ab.y;\n  float Ems = (1.0 - (f_ab.x + f_ab.y));\n  vec3 F_avg = specularWeight * (F0 + (1.0 - F0) / 21.0);\n  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  vec3 k_D = diffuseColor * (1.0 - FssEss + FmsEms);\n  return (FmsEms + k_D) * irradiance;\n}\n```", "```cpp\n VulkanApp app({\n    .initialCameraPos    = vec3(0.0f, 5.0f, -10.0f),\n  });\n  GLTFContext gltf(app);\n  loadGLTF(gltf, “deps/src/glTF-Sample-Assets/Models/\n      EmissiveStrengthTest/glTF/EmissiveStrengthTest.gltf”,\n    “deps/src/glTF-Sample-Assets/Models/\n      EmissiveStrengthTest/glTF/”);\n```", "```cpp\n if (mtlDescriptor->Get(AI_MATKEY_COLOR_EMISSIVE,\n     aiColor) == AI_SUCCESS) {\n    res.emissiveFactorAlphaCutoff = vec4(aiColor.r,\n                                         aiColor.g,\n                                         aiColor.b, 0.5f);\n  }\n  assignUVandSampler(samplers, mtlDescriptor,\n    aiTextureType_EMISSIVE,\n    res.emissiveTextureUV,\n    res.emissiveTextureSampler);\n  ai_real emissiveStrength = 1.0f;\n  if (mtlDescriptor->Get(AI_MATKEY_EMISSIVE_INTENSITY,\n     emissiveStrength) == AI_SUCCESS) {\n    res.emissiveFactorAlphaCutoff *= vec4(\n      emissiveStrength, emissiveStrength, emissiveStrength, 1.0);\n  }\n```", "```cpp\n VulkanApp app({\n    .initialCameraPos    = vec3(0.0f, 3.5f, -5.0f),\n    .initialCameraTarget = vec3(0.0f, 2.0f, 0.0f),\n  });\n  GLTFContext gltf(app);\n  loadGLTF(gltf, “deps/src/glTF-Sample-Assets/Models/\n      LightsPunctualLamp/glTF/LightsPunctualLamp.gltf”,\n    “deps/src/glTF-Sample-Assets/Models/\n      LightsPunctualLamp/glTF/”);\n```", "```cpp\nenum LightType : uint32_t {\n  LightType_Directional = 0,\n  LightType_Point       = 1,\n  LightType_Spot        = 2,\n};\n```", "```cpp\nstruct LightDataGPU {\n  vec3 direction     = vec3(0, 0, 1);\n  float range        = 10000.0;\n  vec3 color         = vec3(1, 1, 1);\n  float intensity    = 1.0;\n  vec3 position      = vec3(0, 0, -5);\n  float innerConeCos = 0.0;\n  float outerConeCos = 0.78;\n  LightType type     = LightType_Directional;\n  int padding[2];\n};\nstruct EnvironmentsPerFrame {\n  EnvironmentMapDataGPU environments[kMaxEnvironments];\n  LightDataGPU lights[kMaxLights];\n  uint32_t lightCount;\n};\n```", "```cpp\nconst EnvironmentsPerFrame envPerFrame = {\n  .environments = { {\n      …\n    } },\n  .lights     = { LightDataGPU() },\n  .lightCount = 1,\n};\n```", "```cpp\nuint getLightsCount() {\n  return perFrame.environments.lightsCount;\n}\nLight getLight(uint i) {\n  return perFrame.environments.lights[i];\n}\n```", "```cpp\n vec3 lights_diffuse      = vec3(0);\n  vec3 lights_specular     = vec3(0);\n  vec3 lights_sheen        = vec3(0);\n  vec3 lights_clearcoat    = vec3(0);\n  vec3 lights_transmission = vec3(0);\n  float albedoSheenScaling = 1.0;\n```", "```cpp\n for (int i = 0; i < getLightsCount(); ++i) {\n    Light light = getLight(i);\n    vec3 l = normalize(pointToLight);\n    vec3 h = normalize(l + v);\n    float NdotL = clampedDot(n, l);\n    float NdotV = clampedDot(n, v);\n    float NdotH = clampedDot(n, h);\n    float LdotH = clampedDot(l, h);\n    float VdotH = clampedDot(v, h);\n    if (NdotL > 0.0 || NdotV > 0.0) {\n      vec3 intensity = getLightIntensity(light, pointToLight);\n```", "```cpp\n lights_diffuse += intensity * NdotL *\n        getBRDFLambertian(pbrInputs.reflectance0,\n          pbrInputs.reflectance90, pbrInputs.diffuseColor,\n          pbrInputs.specularWeight, VdotH);\n      lights_specular += intensity * NdotL *\n        getBRDFSpecularGGX(pbrInputs.reflectance0,\n          pbrInputs.reflectance90, pbrInputs.alphaRoughness,\n          pbrInputs.specularWeight, VdotH, NdotL, NdotV, NdotH);\n```", "```cpp\n if (isSheen) {\n        lights_sheen += intensity *\n          getPunctualRadianceSheen(pbrInputs.sheenColorFactor,\n            pbrInputs.sheenRoughnessFactor, NdotL, NdotV, NdotH);\n        albedoSheenScaling =\n          min(1.0 - max3(pbrInputs.sheenColorFactor) *\n            albedoSheenScalingFactor(NdotV,\n            pbrInputs.sheenRoughnessFactor),\n          1.0 - max3(pbrInputs.sheenColorFactor) *\n          albedoSheenScalingFactor(NdotL,\n            pbrInputs.sheenRoughnessFactor));\n      }\n```", "```cpp\n if (isClearCoat) {\n        lights_clearcoat += intensity *\n          getPunctualRadianceClearCoat(\n            pbrInputs.clearcoatNormal, v, l, h, VdotH,\n        pbrInputs.clearcoatF0, pbrInputs.clearcoatF90,\n          pbrInputs.clearcoatRoughness);\n      }\n      … // transmission & volume effects are skipped for brevity\n    }\n  }\n```", "```cpp\nvec3 getLightIntensity(Light light, vec3 pointToLight) {\n  float rangeAttenuation = 1.0;\n  float spotAttenuation = 1.0;\n  if (light.type != LightType_Directional) {\n    rangeAttenuation =\n      getRangeAttenuation(light.range, length(pointToLight));\n  }\n  if (light.type == LightType_Spot) {\n    spotAttenuation = getSpotAttenuation(pointToLight,\n      light.direction, light.outerConeCos, light.innerConeCos);\n  }\n  return rangeAttenuation * spotAttenuation *\n    light.intensity * light.color;\n}\n```"]