- en: '18'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Power Management and Energy Efficiency in Embedded Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve into power management and energy efficiency in
    embedded systems, a critical aspect in today’s technology-driven world. Efficient
    power management is vital for prolonging battery life and ensuring optimal performance
    in embedded devices. This chapter aims to equip you with the necessary knowledge
    and skills to implement effective power management techniques in your designs.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by exploring various power management techniques, laying the foundation
    to understand how to reduce power consumption in embedded systems. Following this,
    we will examine the different sleep modes and low-power states available in STM32F4
    microcontrollers, providing detailed insights into their configurations and applications.
    Then, we will discuss the wake-up sources and triggers in the STM32F4, which are
    essential to ensure that the microcontroller can respond promptly to external
    events. Finally, we will put theory into practice by developing a driver to enter
    standby mode and wake up the microcontroller, demonstrating how to apply these
    concepts in real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of power management techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low-power modes in STM32F4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wake-up sources and triggers in STM32F4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a driver to enter standby mode and wake up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a thorough understanding of power
    management in embedded systems and be able to implement energy-efficient designs
    using STM32F4 microcontrollers. This knowledge will enable you to create embedded
    systems that optimize power consumption and extend battery life, essential for
    modern applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  prefs: []
  type: TYPE_NORMAL
- en: An overview of power management techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the world of power management techniques, a
    crucial aspect of embedded systems design. As our devices become more advanced
    and our expectations for battery life increase, understanding how to manage power
    effectively is more important than ever. Let’s dive into the various power management
    techniques and how they are implemented, taking a look at some case studies to
    see these techniques in action.
  prefs: []
  type: TYPE_NORMAL
- en: Power management in embedded systems involves a combination of hardware and
    software strategies designed to reduce energy consumption. This is particularly
    important for battery-powered devices, where efficient power usage can significantly
    extend battery life. The main techniques we’ll cover include **Dynamic Voltage
    and Frequency Scaling** (**DVFS**), clock gating, power gating, and utilizing
    low-power modes.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with DVFS.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Voltage and Frequency Scaling (DVFS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DVFS is a method where the voltage and frequency of a microcontroller are adjusted
    based on the workload. By lowering the voltage and frequency during periods of
    low activity, power consumption can be greatly reduced. Conversely, during periods
    of high demand, the voltage and frequency are increased to ensure performance.
  prefs: []
  type: TYPE_NORMAL
- en: How is DVFS implemented?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In STM32 microcontrollers, DVFS can be managed through specific power control
    registers. These registers allow a system to dynamically adjust the operating
    points based on the required performance levels. For example, the STM32F4 series
    has several power modes that can be configured to adjust the system clock and
    core voltage.
  prefs: []
  type: TYPE_NORMAL
- en: An example use case – mobile phones
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mobile phones are a prime example of DVFS in action. When a phone is idle, it
    reduces the CPU frequency and voltage to save the battery. As soon as you start
    using an app or playing a game, the CPU ramps up its frequency and voltage to
    provide the necessary performance. This balance between performance and power
    savings is what makes modern smartphones so efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Another common technique is clock gating.
  prefs: []
  type: TYPE_NORMAL
- en: Clock gating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clock gating is a technique where the clock signal to certain parts of a microcontroller
    is turned off when they are not in use. This prevents unnecessary switching of
    transistors, which in turn saves power.
  prefs: []
  type: TYPE_NORMAL
- en: How is clock gating implemented?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Clock gating is typically controlled through clock control registers. In the
    STM32 series, each peripheral’s clock can be enabled or disabled individually
    using these registers. For instance, if a particular peripheral such as the ADC
    is not needed, its clock can be disabled to save power.
  prefs: []
  type: TYPE_NORMAL
- en: An example use case – smart home devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Smart home devices such as smart thermostats or lights use clock gating to manage
    power efficiently. These devices spend a significant amount of time in a low-power
    state, waking up only to perform specific tasks. By gating the clock to unused
    peripherals, these devices can conserve energy and extend their battery life.
  prefs: []
  type: TYPE_NORMAL
- en: Another technique is power gating.
  prefs: []
  type: TYPE_NORMAL
- en: Power gating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Power gating takes power savings a step further by completely shutting off the
    power to certain parts of a microcontroller. This technique ensures zero power
    consumption for the powered-down sections.
  prefs: []
  type: TYPE_NORMAL
- en: How is power gating implemented?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Power gating is more complex than clock gating and often involves dedicated
    power management units within a microcontroller. These units control the power
    supply to various domains of the microcontroller. In STM32 microcontrollers, power
    gating can be configured using the power control registers to turn off specific
    peripherals, or even entire sections of the microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: An example use case – wearable devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Wearable devices, such as fitness trackers, benefit greatly from power gating.
    These devices need to operate for extended periods on a single charge. By powering
    down sensors and other components when they are not in use, wearables can achieve
    longer battery life without compromising functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s discuss low-power modes.
  prefs: []
  type: TYPE_NORMAL
- en: Low-power modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Low-power modes are predefined states within microcontrollers that significantly
    reduce power consumption by disabling or reducing the functionality of various
    components. These modes range from simple CPU sleep modes to more complex deep
    sleep or standby modes.
  prefs: []
  type: TYPE_NORMAL
- en: How are low-power modes implemented?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Low-power modes are implemented through the power control registers. The STM32F4
    microcontrollers, for example, offer several low-power modes, including **sleep**,
    **stop**, and **standby**. Each mode provides a different balance between power
    savings and wake-up time.
  prefs: []
  type: TYPE_NORMAL
- en: An example use case – remote sensors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remote sensors used in agriculture or environmental monitoring often use low-power
    modes. These sensors might spend the majority of their time in a low-power state,
    waking up periodically to take measurements and transmit data. By leveraging low-power
    modes, these sensors can operate for months or even years on a single battery
    charge.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a closer look at a couple of case studies that illustrate how
    a combination of these power management techniques is used in real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: Case study 1 – an energy-efficient smartwatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Smartwatches are a great example of a device that relies heavily on power management
    techniques. These devices need to balance performance with battery life, as users
    expect them to run for days on a single charge. Let’s break down the roles the
    different techniques play in an energy-efficient smartwatch design:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DVFS**: The smartwatch uses DVFS to adjust the CPU frequency based on the
    current workload. When the user interacts with the watch, the CPU frequency increases
    to provide a smooth experience. When the watch is idle, the frequency is lowered
    to save power.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clock gating**: Peripherals such as the GPS or heart rate monitor are only
    powered when needed. When these features are not in use, their clocks are gated
    to conserve energy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Power gating**: Components like the display driver are powered down completely
    when the display is off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low-power modes**: The watch enters deep sleep mode during periods of inactivity,
    waking up only to check for notifications or user interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By combining these techniques, smartwatches can achieve impressive battery life
    without compromising on functionality. Another excellent example is solar-powered
    environmental monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Case study 2 – a solar-powered environmental monitor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A solar-powered environmental monitor deployed in remote locations must operate
    efficiently to ensure continuous data collection and transmission. The roles are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DVFS**: The monitor adjusts its operating frequency based on the intensity
    of sunlight and battery charge. During peak sunlight hours, it operates at a higher
    frequency to process more data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clock gating**: Sensors such as temperature, humidity, and air quality are
    only active during data collection intervals. The clocks to these sensors are
    gated when not in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Power gating**: Non-essential components are completely powered down during
    nighttime or cloudy periods to conserve energy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low-power modes**: The monitor enters deep sleep mode between data collection
    intervals, waking up periodically to take measurements and transmit data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these power management techniques, the monitor can operate autonomously
    for extended periods, relying solely on solar power.
  prefs: []
  type: TYPE_NORMAL
- en: Power management is a vital aspect of embedded system design, especially as
    devices become more portable and battery-dependent. By understanding and implementing
    techniques such as DVFS, clock gating, power gating, and low-power modes, we can
    design embedded systems that are both powerful and energy-efficient. Whether it’s
    a smartwatch, a remote sensor, or any other battery-powered device, effective
    power management ensures longer battery life and better overall performance. As
    we continue to push the boundaries of what embedded systems can do, mastering
    these power management techniques will be more important than ever.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore the low-power modes in our STM32F4 microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: Low-power modes in STM32F4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn about the low-power modes available in STM32F4
    microcontrollers. We’ll cover the various low-power modes, how to configure them,
    and the practical aspects of using them in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by understanding these low-power modes. Low-power modes in the STM32F4
    microcontrollers are designed to reduce power consumption by disabling or limiting
    the functionality of certain components. The STM32F4 offers several low-power
    states, each providing a different balance between power savings and wake-up latency.
    These modes include sleep, stop, and standby modes.
  prefs: []
  type: TYPE_NORMAL
- en: We can put our system into low-power mode by executing the`SLEEPONEXIT` bit
    in the **Cortex®-M4 with FPU system control register** on return from an ISR.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into the details of each low-power mode, starting with sleep mode.
  prefs: []
  type: TYPE_NORMAL
- en: Sleep mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sleep mode is the most basic low-power mode, where the CPU clock is stopped
    but peripherals continue to operate. This mode offers a **quick wake-up time**,
    making it ideal for applications that require frequent transitions between active
    and low-power states.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enter sleep mode, we need to clear the `SLEEPDEEP` bit in the **System Control
    Register** (**SCR**) and then execute the WFI or WFE instruction, as shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The microcontroller **exits Sleep mode upon any interrupt or event**. Since
    the peripherals remain active, any configured interrupt from a peripheral can
    wake the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: An example use case is **sensor monitoring**.
  prefs: []
  type: TYPE_NORMAL
- en: For applications such as continuous sensor monitoring, sleep mode provides an
    efficient way to reduce power consumption without sacrificing responsiveness.
    The microcontroller can wake up quickly to process sensor data and then return
    to sleep mode.
  prefs: []
  type: TYPE_NORMAL
- en: The next mode is stop mode.
  prefs: []
  type: TYPE_NORMAL
- en: Stop mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Stop mode offers a **deeper power-saving state than sleep mode** by stopping
    the main internal regulator and halting the system clock. Only the low-speed clock
    (LSI or LSE) remains active. This mode provides a **moderate wake-up time** and
    significant power savings.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enter stop mode, set the `SLEEPDEEP` bit in the (`PWR_CR`), and then execute
    the WFI or WFE instruction, as shown in the following snippet. Additional configuration
    can also be applied to further reduce power consumption in stop mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The MCU exits stop mode upon any **external interrupt** or **wake-up event from****configured
    EXTI lines**, **RTC alarms**, or other configured wake-up sources. The wake-up
    time from stop mode is longer than from sleep mode, but it still allows for a
    relatively quick return to full operation.
  prefs: []
  type: TYPE_NORMAL
- en: An example use case is **periodic** **data logging**.
  prefs: []
  type: TYPE_NORMAL
- en: In applications such as data logging, a microcontroller can remain in stop mode
    and wake up periodically, based on RTC alarms, to log data, and then return to
    stop mode. This significantly reduces power consumption while ensuring regular
    data logging.
  prefs: []
  type: TYPE_NORMAL
- en: The final mode is standby mode.
  prefs: []
  type: TYPE_NORMAL
- en: Standby mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Standby mode provides the **highest power savings** by turning off most internal
    circuitry, including the main regulator. Only a small portion of the microcontroller
    remains powered to monitor wake-up sources. This mode has the **longest wake-up
    time** but offers the lowest power consumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enter standby mode, set the `PDDS` and `SLEEPDEEP` bits in the Power Control
    (`PWR_CR`) register, and then configure the wake-up sources. This snippet demonstrates
    how to enter standby mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The microcontroller exits standby mode upon a **wake-up event from an external
    wake-up pin (WKUP)**, an RTC alarm, or a reset event. When the microcontroller
    wakes up from standby mode, it **undergoes a full reset sequence**, and the execution
    starts from the reset vector.
  prefs: []
  type: TYPE_NORMAL
- en: An example use case is **remote** **IoT devices**.
  prefs: []
  type: TYPE_NORMAL
- en: Standby mode is perfect for remote IoT devices that need to operate for extended
    periods on battery power. These devices can remain in standby mode most of the
    time and wake up only for critical events or scheduled tasks, thus maximizing
    battery life.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to enter the various low-power modes, we will look
    at how to wake up from them.
  prefs: []
  type: TYPE_NORMAL
- en: Wake-up sources and triggers from low-power modes in STM32F4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While low-power modes help conserve energy, ensuring that a microcontroller
    can wake up promptly when needed is equally important. The STM32F4 microcontroller
    series provides a variety of wake-up sources and triggers to handle this effectively.
    In this section, we’ll explore these wake-up sources, how they function, and their
    practical applications.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding wake-up sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wake-up sources are mechanisms that bring a microcontroller out of a low-power
    state. The STM32F4 offers several types of wake-up sources, each suited for different
    scenarios. These include external interrupts, RTC alarms, watchdog timers, and
    various internal events. By understanding these triggers, we can design systems
    that balance power efficiency with responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: 'The wake-up sources can be grouped as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: External interrupts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-Time Clock** (**RTC**) alarms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s delve into each of these wake-up sources to understand how they work and
    their typical use cases.
  prefs: []
  type: TYPE_NORMAL
- en: External interrupts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: External interrupts are one of the primary wake-up sources for STM32F4 microcontrollers.
    These interrupts can be triggered by events on specific GPIO pins. When a microcontroller
    is in a low-power mode, an external signal, such as a button press or sensor output,
    can wake it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GPIO configuration**: Configure the GPIO pins to act as interrupt sources.
    This involves setting pin mode and enabling the interrupt on the desired edge
    (rising, falling, or both).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EXTI configuration**: Each GPIO pin can be mapped to an EXTI line, which
    can be configured to generate an interrupt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NVIC configuration**: Enable the EXTI line interrupt in the **Nested Vectored
    Interrupt Controller** (**NVIC**) to ensure that the microcontroller responds
    to the external event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example use cases are a **smart doorbell system and** **smart lighting**.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a smart doorbell system. The microcontroller remains in a low-power
    mode to conserve battery life. When someone presses the doorbell button (connected
    to a GPIO pin), an external interrupt is triggered, waking the microcontroller
    to process the event and send a notification to the homeowner. Another excellent
    example is smart home lighting systems.
  prefs: []
  type: TYPE_NORMAL
- en: A smart home lighting system needs to conserve energy while being responsive
    to user inputs. The microcontroller stays in a low-power mode until an external
    interrupt (e.g., a motion sensor detecting movement) wakes it up. Upon waking,
    the microcontroller processes the event, turns on the lights, and then goes back
    to sleep after a predefined period of inactivity.
  prefs: []
  type: TYPE_NORMAL
- en: The next wake-up source we will examine is the RTC Alarm.
  prefs: []
  type: TYPE_NORMAL
- en: RTC alarms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The RTC is a versatile peripheral that can generate wake-up events at specific
    intervals or predefined times. It is particularly useful for applications requiring
    periodic wake-ups, such as data logging or scheduled tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RTC configuration**: Configure the RTC to generate alarms or periodic wake-up
    events. This involves setting the RTC clock source, enabling the wake-up timer,
    and setting the alarm time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interrupt handling**: Enable the RTC alarm or wake-up interrupt in the NVIC
    to ensure that the microcontroller wakes up when the alarm or timer event occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*An example use case* is an **environmental** **monitoring system**.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider a remote environmental monitoring system that logs temperature and
    humidity data. The microcontroller can be put into low-power mode, waking up at
    regular intervals (e.g., every hour) using RTC alarms to read sensors and log
    data, and then return to the low-power state.
  prefs: []
  type: TYPE_NORMAL
- en: The final wake-up sources we will examine are **internal events**.
  prefs: []
  type: TYPE_NORMAL
- en: Internal events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Apart from external triggers, internal events can also wake up a microcontroller
    from low-power modes. These events include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Peripheral events**: Events generated by internal peripherals, such as ADC
    conversions or communication interface activity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System events**: Internal system events such as power voltage detection or
    clock stability issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Peripheral configuration**: Configure the peripheral to generate interrupts
    upon specific events. For instance, an ADC can generate an interrupt when a conversion
    is complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event handling**: Enable the relevant interrupts in the NVIC to handle these
    internal events and wake the microcontroller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*An example use case* is a **fitness tracker**'
  prefs: []
  type: TYPE_NORMAL
- en: A wearable fitness tracker that monitors heart rate can use the ADC to read
    sensor data. The microcontroller stays in a low-power mode and wakes up when the
    ADC completes a conversion, allowing it to process and store the heart rate data.
  prefs: []
  type: TYPE_NORMAL
- en: Before we conclude this section, let’s summarize some key practical considerations
    to keep in mind when configuring wake-up sources.
  prefs: []
  type: TYPE_NORMAL
- en: Practical considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When configuring wake-up sources, you must consider the following practical
    aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response time**: Ensure the chosen wake-up source can provide the required
    response time for your application. External interrupts typically offer the fastest
    wake-up times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Power consumption**: Balance power consumption with wake-up requirements.
    RTC alarms and watchdog timers can be configured for periodic wake-ups with minimal
    power overhead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reliability**: Choose reliable wake-up sources for critical applications.
    Watchdog timers are essential for safety-critical systems to ensure that a microcontroller
    can recover from faults.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Peripheral configuration**: Ensure that peripherals needed for wake-up are
    properly configured and their clocks remain enabled, even in low-power states.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and properly configuring these wake-up sources ensures that your
    embedded systems are both energy-efficient and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to develop a driver to enter standby
    mode and subsequently wake up the system.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a driver to enter standby mode and wake up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a copy of your previous project in your IDE, following the steps outlined
    in earlier chapters. Rename this copied project `StandByModeWithWakeupPin`. Next,
    create a new file named `standby_mode.c` in the `Src` folder, and then another
    file named `standby_mode.h` in the `Inc` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Populate your `standby_mode.c` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is responsible for configuring `PA0` to be used as a wake-up
    pin for exiting low-power mode. It sets `PA0` as an input pin by clearing the
    corresponding bits in the `GPIOA` mode register, and then it configures the pin
    with no pull-up or pull-down resistors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This function prepares the microcontroller to enter standby mode and ensures
    that it can wake up via the configured wake-up pin. It begins by waiting for the
    wake-up pin to be released, ensuring that the pin is in a stable state before
    proceeding. The function then disables the wake-up pin to clear any residual settings,
    followed by clearing all wake-up flags to reset the wake-up status. After re-enabling
    the wake-up pin, the function sets the power mode to Standby by configuring the
    appropriate power control register. Finally, the function executes the WFI instruction,
    placing the microcontroller into standby mode until an interrupt occurs, triggering
    the wake-up process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This function checks the current state of the wake-up pin (`PA0`). It reads
    the input data register (`IDR`) for `GPIOA` and performs a bitwise `AND` operation
    with the wake-up pin’s bit mask (`WK_PIN`). This operation isolates the state
    of `PA0`. The function then compares this result to the bit mask itself to determine
    whether the pin is high. If `PA0` is high, the function returns `true`; otherwise,
    it returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This function configures the power mode of the STM32F4 microcontroller by modifying
    specific bits in `PWR_CR`. This function takes a parameter, `pwr_mode`, which
    specifies the desired power mode settings. It uses the `MODIFY_REG` macro to update
    the `PWR_CR` register, specifically targeting the bits related to different power
    modes such as **PDDS** (**Power Down Deepsleep**), **LPDS** (**Low-Power Deepsleep**),
    **FPDS** (**Flash Power Down in Stop Mode**), **LPLVDS** (**Low-Power Regulator
    in Low Voltage in Deepsleep**), and **MRLVDS** (**Main Regulator in Low Voltage**
    **in Deepsleep**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will populate the `standby_mode.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '#include <stdio.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <string.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "standby_mode.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "gpio_exti.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "uart.h"'
  prefs: []
  type: TYPE_NORMAL
- en: uint8_t g_btn_press;
  prefs: []
  type: TYPE_NORMAL
- en: static void check_reset_source(void);
  prefs: []
  type: TYPE_NORMAL
- en: int main(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: uart_init();
  prefs: []
  type: TYPE_NORMAL
- en: wakeup_pin_init();
  prefs: []
  type: TYPE_NORMAL
- en: /*Find reset source*/
  prefs: []
  type: TYPE_NORMAL
- en: check_reset_source();
  prefs: []
  type: TYPE_NORMAL
- en: /*Initialize EXTI*/
  prefs: []
  type: TYPE_NORMAL
- en: pc13_exti_init();
  prefs: []
  type: TYPE_NORMAL
- en: while(1)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: static void check_reset_source(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable clock access to PWR*/
  prefs: []
  type: TYPE_NORMAL
- en: RCC->APB1ENR |= RCC_APB1ENR_PWREN;
  prefs: []
  type: TYPE_NORMAL
- en: if ((PWR->CSR & PWR_CSR_SBF) == (PWR_CSR_SBF))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear Standby flag*/
  prefs: []
  type: TYPE_NORMAL
- en: PWR->CR |= PWR_CR_CSBF;
  prefs: []
  type: TYPE_NORMAL
- en: printf("System resume from Standby.....\n\r");
  prefs: []
  type: TYPE_NORMAL
- en: /*Wait for wakeup pin to be released*/
  prefs: []
  type: TYPE_NORMAL
- en: while(get_wakeup_pin_state() == 0){}
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: /*Check and Clear Wakeup flag*/
  prefs: []
  type: TYPE_NORMAL
- en: if((PWR->CSR & PWR_CSR_WUF) == PWR_CSR_WUF )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: PWR->CR |= PWR_CR_CWUF;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: static void exti_callback(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: standby_wakeup_pin_setup();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: void EXTI15_10_IRQHandler(void) {
  prefs: []
  type: TYPE_NORMAL
- en: if((EXTI->PR & LINE13)!=0)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear PR flag*/
  prefs: []
  type: TYPE_NORMAL
- en: EXTI->PR |=LINE13;
  prefs: []
  type: TYPE_NORMAL
- en: //Do something...
  prefs: []
  type: TYPE_NORMAL
- en: exti_callback();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
