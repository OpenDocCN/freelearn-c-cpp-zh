<html><head></head><body><div><h1 class="header-title">3D Graphics with Qt</h1>
                
            
            
                
<p>Many modern games take place in 3D worlds. Graphics processing units are constantly evolving, allowing developers to create more and more visually appealing and detailed worlds. While you can use OpenGL or Vulkan directly to render 3D objects, this can prove to be quite challenging. Luckily, the Qt 3D module provides an implementation of 3D rendering with a high-level API. In this chapter, we'll learn to use its capabilities and see how we can create a 3D game with Qt.</p>
<p>Qt 3D is not limited to rendering. You'll also learn to handle user input and implement game logic in a 3D game. Qt 3D was designed to be highly efficient and fully extensible, so it allows you to implement your own additions to all Qt 3D systems.</p>
<p>Qt 3D offers both C++ and QML API with mostly equivalent functionality. While the C++ API allows you to modify and extend the implementation, we will use the QML approach, that will allow us to write clean and declarative code and use the techniques we've learned in the previous chapters. By combining Qt 3D with the powers of QML, you will be able to make amazing games in no time!</p>
<p>The main topics covered in this chapter are:</p>
<ul>
<li>Rendering 3D objects</li>
<li>Handling user input</li>
<li>Performing animations</li>
<li>Integration with 3D editors </li>
<li>Working with Qt 3D using C++</li>
<li>Integration with Qt Widgets and Qt Quick</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Qt 3D overview</h1>
                
            
            
                
<p>Before we see Qt 3D in action, let's go through the important parts of its architecture. </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Entities and components</h1>
                
            
            
                
<p>Qt 3D is not just a 3D rendering tool. When sufficiently evolved, it can become a full-featured game engine. This is supported by its original architecture. Qt 3D introduces a new set of abstractions that are particularly useful for its task. </p>
<p>You may have noticed that most of the Qt API heavily uses inheritance. For example, each widget type is derived from <kbd>QWidget</kbd>, which in turn is derived from <kbd>QObject</kbd>. Qt forms large family trees of classes to provide common and specialized behavior. In contrast, elements of a Qt 3D scene are constructed using <strong>composition</strong> instead of inheritance. A single part of a Qt 3D scene is called an <strong>entity</strong> and represented by the <kbd>Entity</kbd> type. However, an <kbd>Entity</kbd> object by itself doesn't have any particular effect or behavior. You can add pieces of behavior to an entity in the form of <strong>components</strong>.</p>
<p>Each component controls some part of the entity's behavior. For example, the <kbd>Transform</kbd> component controls the entity's position within the scene, the <kbd>Mesh</kbd> component defines its shape, and the <kbd>Material</kbd> component controls the properties of the surface. This approach allows you to assemble entities from only the components that you need. For example, if you need to add a light source to the scene, you can create an entity with the <kbd>PointLight</kbd> component. You still want to choose a location of the light source, so you'll need the <kbd>Transform</kbd> component as well. However, <kbd>Mesh</kbd> and <kbd>Material</kbd> components do not make sense for a light source, so you don't need to use them. </p>
<p>Entities are arranged in a classic parent–child relationship, like any other QML objects or QObjects. A tree of entities form a Qt 3D scene. The topmost entity is usually responsible for defining scene-wide configuration. These settings are specified by attaching special components (such as <kbd>RenderSettings</kbd> and <kbd>InputSettings</kbd>) to the top level <kbd>Entity</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Qt 3D modules</h1>
                
            
            
                
<p>Qt 3D is split into a number of modules that you can choose to use in your project. It may be hard to see which of them you need, so let's see what each module is made for.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Stable modules</h1>
                
            
            
                
<p>The <kbd>Qt3DCore</kbd> module implements the base structure of Qt 3D. It provides <kbd>Entity</kbd> and <kbd>Component</kbd> types, as well as base classes for other Qt 3D systems. <kbd>Qt3DCore</kbd> itself does not implement any behavior, providing only the framework that's used by other modules.</p>
<p>The <kbd>Qt3DRender</kbd> module implements 3D rendering, so it's one of the most feature-rich modules. Let's list some important pieces of its functionality:</p>
<ul>
<li><kbd>GeometryRenderer</kbd> is the base component type that defines the visible shape of an entity</li>
<li>The <kbd>Mesh</kbd> component allows you to import the entity's geometry from a file</li>
<li>The <kbd>Material</kbd> component is the base component type that defines visible properties of the entity's surface</li>
<li>The <kbd>SceneLoader</kbd> component allows you to import a hierarchy of entities with meshes and materials from a file</li>
<li>Light components (<kbd>DirectionalLight</kbd>, <kbd>EnvironmentLight</kbd>, <kbd>PointLight</kbd>, and <kbd>SpotLight</kbd>) allow you to control the scene's lighting</li>
<li>The <kbd>FrameGraph</kbd> API provides a way of defining how exactly your scene should be rendered. It allows you to set up the camera, implement multiple viewports, shadow mapping, custom shaders, and much more</li>
<li>The <kbd>ObjectPicker</kbd> component allows you to find out which entities are positioned at a particular window point.</li>
</ul>
<p>Next, <kbd>Qt3DLogic</kbd> is a very small module that provides the <kbd>FrameAction</kbd> component. This component allows you to execute an arbitrary action for each frame of your entity.</p>
<p>Finally, the <kbd>Qt3DInput</kbd> module is focused on user input. It provides a few components that allow you to handle keyboard and mouse events in your game. <kbd>Qt3DInput</kbd> also contains types that can be used to configure the input devices.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Experimental modules</h1>
                
            
            
                
<p>At the time of writing, all the other Qt 3D modules are still in <strong>tech preview</strong>, so their API may be incomplete. Future Qt versions may introduce incompatible changes in these modules, so don't be surprised if you need to make a few changes in the provided code to make it work (our code was tested on Qt 5.10). These modules should eventually be stabilized in the future, so you should check the Qt documentation to find out their current status.</p>
<p>The <kbd>Qt3DAnimation</kbd> module, as the name implies, is responsible for animations in the Qt 3D scene. It's able to handle keyframe animations on the entity's <kbd>Transform</kbd> component, as well as blend-shape and vertex-blend animations. However, we won't be using this module in this chapter, as the already familiar animation framework of Qt Quick is more than enough for us.</p>
<p>The <kbd>Qt3DExtras</kbd> module provides components that are not strictly necessary for working with Qt 3D, but are very useful for building first simple projects. They are:</p>
<ul>
<li>Mesh generators for basic geometric shapes (cubes, spheres, and so on) </li>
<li>The <kbd>ExtrudedTextMesh</kbd> component that allows you to show 3D text in the scene </li>
<li>Many standard material components, such as <kbd>DiffuseSpecularMaterial</kbd> and <kbd>GoochMaterial</kbd></li>
</ul>
<p>Additionally, <kbd>Qt3DExtras</kbd> provides two convenience classes that allow the user to control the position of the camera using mouse and keyboard:</p>
<ul>
<li><kbd>OrbitCameraController</kbd> moves the camera along an orbital path</li>
<li><kbd>FirstPersonCameraController</kbd> moves the camera as in a first-person game</li>
</ul>
<p>The <kbd>Qt3DQuickExtras</kbd> module provides the <kbd>Qt3DExtras::Quick::Qt3DQuickWindow</kbd> C++ class. This is a window that displays a QML-based Qt 3D scene. </p>
<p>Finally, the <kbd>Qt3DQuickScene2D</kbd> module provides the ability to embed Qt Quick items into the Qt 3D scene, and the <kbd>QtQuick.Scene3D</kbd> QML module allows you to embed a Qt 3D scene into a Qt Quick application.</p>
<p>As you can see, the capabilities of Qt 3D are not limited by rendering. You can also use it to handle user input and implement the game logic for your entities. Qt 3D is fully extensible, so you can use its C++ API to implement your own components, or modify existing ones. However, we will mainly use the QML-based API in this chapter.</p>
<p>Note that Qt 3D objects are not Qt Quick items, so not all Qt Quick capabilities are open for you when you work with Qt 3D. For example, you can't use <kbd>Repeater</kbd> to instantiate multiple Qt 3D entities. However, you can still use Qt Quick animations because they can handle any QML objects. It's also possible to embed a Qt 3D scene into a Qt Quick interface using the <kbd>Scene3D</kbd> QML type.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Using modules</h1>
                
            
            
                
<p>Before using each of the Qt 3D modules, you have to enable the module separately in the project file. For example, the following line will enable all currently documented modules:</p>
<pre>QT += 3dcore 3drender 3dinput 3dlogic 3danimation \<br/>      qml quick 3dquick 3dquickextras 3dquickscene2d</pre>
<p>When using QML, each module must also be separately imported:</p>
<pre>import Qt3D.Core 2.10<br/>import Qt3D.Render 2.10<br/>import Qt3D.Extras 2.10<br/>import Qt3D.Input 2.0<br/>import Qt3D.Logic 2.0<br/>import QtQuick.Scene2D 2.9<br/>import QtQuick.Scene3D 2.0</pre>
<p>You can see that different Qt 3D modules have different QML module versions. Some modules were updated in Qt 5.10 and have new features that we'd like to use in our code, so you have to specify the last version (2.10) to make new QML types available. On the other hand, some modules weren't updated, so 2.0 is the only available version. The up-to-date versions will change in the future as new Qt releases come out. The Qt documentation should hopefully contain the correct import statements.</p>
<p>All C++ types of a Qt 3D module are placed in a namespace. In other regards, Qt naming conventions apply. For example, the <kbd>Entity</kbd> QML type corresponds to the <kbd>QEntity</kbd> C++ class in the <kbd>Qt3DCore</kbd> namespace. The corresponding include directive is <kbd>#include &lt;QEntity&gt;</kbd>.</p>
<p>Qt 3D also introduces a concept of <strong>aspects</strong>. An aspect is simply a piece of behavior that can be added to the Qt 3D engine. The <kbd>Qt3DQuickWindow</kbd> class contains a built-in aspect engine that automatically enables <kbd>QRenderAspect</kbd>, <kbd>QInputAspect</kbd>, and <kbd>QLogicAspect</kbd> aspects, allowing Qt 3D to render the scene, process user input, and execute frame actions. If you decide to use the <kbd>Qt3DAnimation</kbd> module, you should also enable <kbd>QAnimationAspect</kbd>. You can do that using the <kbd>Qt3DWindow::registerAspect()</kbd> method. Other Qt 3D modules don't require a separate aspect. It's also possible to create a new aspect, but it's usually not necessary.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Rendering 3D objects</h1>
                
            
            
                
<p>Each item of the Qt 3D scene is represented by the <kbd>Entity</kbd> type. However, not all entities are visible 3D objects. In order for an entity to be visible, it has to have a <strong>mesh</strong> component and a <strong>material</strong> component.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Mesh, material, and transform</h1>
                
            
            
                
<p>The mesh defines the geometrical shape of the entity. It contains information about vertices, edges, and faces required to render the object. The base type of all mesh components is <kbd>GeometryRenderer</kbd>. However, you'll usually use one of its descendants:</p>
<ul>
<li><kbd>Mesh</kbd> imports geometry data from a file</li>
<li><kbd>ConeMesh</kbd>, <kbd>CuboidMesh</kbd>, <kbd>CylinderMesh</kbd>, <kbd>PlaneMesh</kbd>, <kbd>SphereMesh</kbd>, and <kbd>TorusMesh</kbd> provide access to primitive geometric shapes</li>
<li><kbd>ExtrudedTextMesh</kbd> defines the entity's shape based on a specified text and font</li>
</ul>
<p>While the mesh defines where the object's surface will be drawn, the material defines how exactly it will be drawn. The most obvious property of a surface is its color, but depending on the reflection model, there can be all sorts of properties, such as coefficients of diffuse and specular reflection. Qt 3D provides a lot of different material types:</p>
<ul>
<li><kbd>PerVertexColorMaterial</kbd> allows you to set color properties for each vertex and renders ambient and diffuse reflections</li>
<li><kbd>TextureMaterial</kbd> renders a texture and ignores lighting</li>
<li><kbd>DiffuseSpecularMaterial</kbd> implements the Phong reflection model and allows you to set ambient, diffuse, and specular components of the reflection</li>
<li><kbd>GoochMaterial</kbd> implements the Gooch shading model</li>
<li><kbd>MetalRoughMaterial</kbd> renders a metal-like surface using PBR (physically based rendering)</li>
<li><kbd>MorphPhongMaterial</kbd> also follows the Phong reflection model but also supports morph animations of the <kbd>Qt3DAnimation</kbd> module</li>
</ul>
<p>The third common component of a visible 3D object is <kbd>Transform</kbd>. While not strictly required, it's usually necessary for setting the position of the object in the scene. You can set the position using the <kbd>translation</kbd> property. It's also possible to scale the object using the <kbd>scale3D</kbd> property that allows you to set different scale coefficients for each <kbd>axis</kbd>, or the <kbd>scale</kbd> property that accepts a single coefficient that applies to all axes. Similarly, you can either set the rotation quaternion using the <kbd>rotation</kbd> property or set individual Euler angles using <kbd>rotationX</kbd>, <kbd>rotationY</kbd>, and <kbd>rotationZ</kbd> properties. Finally, you can set the <kbd>matrix</kbd> property to apply an arbitrary transformation matrix.</p>
<p>Note that transformations apply not only to the current entity, but to all its children as well.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Lighting</h1>
                
            
            
                
<p>Some of the available materials will take the lighting into account. Qt 3D allows you to add different types of lights to the scene and configure them. You can do that by adding a new <kbd>Entity</kbd> to the scene and attaching a <kbd>DirectionalLight</kbd>, <kbd>PointLight</kbd>, or <kbd>SpotLight</kbd> component to it. Each of these components has the <kbd>color</kbd> property that allows you to configure the color of the light and the <kbd>intensity</kbd> property that allows you to choose how bright the light is. The rest of the properties are specific to the light type.</p>
<p><strong>Directional light</strong> (also called "distant light" or "sunlight") casts parallel rays in the direction defined by the <kbd>worldDirection</kbd> property of the <kbd>DirectionalLight</kbd> type. Position and rotation of the entity have no influence on the lighting effect of a directional light, so there is no need for a <kbd>Transform</kbd> component.</p>
<p><strong>Point light</strong> emits light from its position in all directions. The position of the light can be changed via the <kbd>Transform</kbd> component attached to the same entity. The <kbd>PointLight</kbd> component allows you to configure how bright the light will be at a distance by setting the <kbd>constantAttenuation</kbd>, <kbd>linearAttenuation</kbd>, and <kbd>quadraticAttenuation</kbd> properties.</p>
<p>While point light can be interpreted as a sphere of light, <strong>spotlight</strong> is a cone of light. It emits light from its position, but the directions are limited by the <kbd>localDirection</kbd> property that defines where the spotlight is facing and the <kbd>cutOffAngle</kbd> property that configures how wide the light cone is. The position and direction of the spotlight can be influenced by the translation and rotation of the <kbd>Transform</kbd> component attached to the same entity. <kbd>SpotLight</kbd> also has the same attenuation properties as <kbd>PointLight</kbd>.</p>
<p>If no lights are present in the scene, Qt will automatically add an implicit point light so that the scene is somewhat visible.</p>
<p>The fourth type of light is different from the others. It's called <strong>environment light</strong> and can be configured by adding the <kbd>EnvironmentLight</kbd> component to an entity. It defines the surrounding lighting of the scene using two textures assigned to its <kbd>irradiance</kbd> and <kbd>specular</kbd> properties. Unlike other light types, this component does not have <kbd>color</kbd> or <kbd>intensity</kbd> properties. There can only be one environment light in a scene.</p>
<p>Note that light sources themselves are invisible. Their only purpose is to influence the appearance of 3D objects that use certain material types.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – creating a 3D scene</h1>
                
            
            
                
<p>In this chapter, we will create an implementation of the famous Tower of Hanoi game. This puzzle game contains three rods and multiple disks of different sizes. The disks can slide onto the rods, but a disk cannot be placed on top of a smaller disk. At the starting position, all the rods are placed on one of the disks. The goal is to move them all to another rod. The player can only move one disk at a time.</p>
<p>As usual, you will find the complete project in the resources that come with the book.</p>
<p>Create a new Qt Quick Application - Empty project and call it <kbd>hanoi</kbd>. While we will use some Qt Quick utilities, our project will not really be based on Qt Quick. Qt 3D will do most of the work. Nevertheless, the Qt Quick Application - Empty is the most suitable of currently present templates, so we choose to use it. Edit the <kbd>hanoi.pro</kbd> file to enable the Qt modules that we'll need:</p>
<pre>QT += 3dcore 3drender 3dinput quick 3dquickextras</pre>
<p>We will use the <kbd>Qt3DQuickWindow</kbd> class to instantiate our QML objects instead of the <kbd>QQmlApplicationEngine</kbd> class we usually use with Qt Quick. To do that, replace the <kbd>main.cpp</kbd> file with the following code:</p>
<pre>#include &lt;QGuiApplication&gt;<br/>#include &lt;Qt3DQuickWindow&gt;<br/><br/>int main(int argc, char* argv[])<br/>{<br/>    QGuiApplication app(argc, argv);<br/>    Qt3DExtras::Quick::Qt3DQuickWindow window;<br/>    window.setSource(QUrl("qrc:/main.qml"));<br/>    window.show();<br/>    return app.exec();<br/>}</pre>
<p>Next, replace the <kbd>main.qml</kbd> file with the following code:</p>
<pre>import Qt3D.Core 2.10<br/>import Qt3D.Render 2.10<br/>import Qt3D.Input 2.0<br/>import Qt3D.Extras 2.10<br/><br/>Entity {<br/>    components: [<br/>        RenderSettings {<br/>            activeFrameGraph: ForwardRenderer {<br/>                clearColor: "black"<br/>                camera: Camera {<br/>                    id: camera<br/>                    projectionType: CameraLens.PerspectiveProjection<br/>                    fieldOfView: 45<br/>                    nearPlane : 0.1<br/>                    farPlane : 1000.0<br/>                    position: Qt.vector3d(0.0, 40.0, -40.0)<br/>                    upVector: Qt.vector3d(0.0, 1.0, 0.0)<br/>                    viewCenter: Qt.vector3d(0.0, 0.0, 0.0)<br/>                }<br/>            }<br/>        },<br/>        InputSettings {}<br/>    ]<br/>}</pre>
<p>This code declares a single <kbd>Entity</kbd> object that contains two components. The  <kbd>RenderSettings</kbd> component defines how Qt 3D should render the scene. The <kbd>activeFrameGraph</kbd> property of <kbd>RenderSettings</kbd> can hold a tree of render operations, but the simplest possible frame graph is a single <kbd>ForwardRenderer</kbd> object that takes care of all the rendering. <kbd>ForwardRenderer</kbd> renders objects one by one directly to the OpenGL framebuffer. We use the <kbd>clearColor</kbd> property to set the background color of our scene to black. The <kbd>camera</kbd> property of the <kbd>ForwardRenderer</kbd> holds the <kbd>Camera</kbd> object it will use for calculating the transformation matrix. Let's go through the properties of the <kbd>Camera</kbd> object we've used in our code:</p>
<ul>
<li>The <kbd>projectionType</kbd> property defines the type of the projection. Besides the <kbd>PerspectiveProjection</kbd>, you can use <kbd>OrthographicProjection</kbd>,  <kbd>FrustumProjection</kbd>, or  <kbd>CustomProjection</kbd>.</li>
<li>The <kbd>fieldOfView</kbd> property contains the field of view parameter of the perspective projection. You can change it to achieve a zoom in/out effect.</li>
<li>The <kbd>nearPlane</kbd> and <kbd>farPlane</kbd> properties define the positions of the nearest and the furthest planes that will be visible in the camera (they correspond to the visible <em>z</em> axis values in the viewport coordinates).</li>
<li>The <kbd>position</kbd> vector defines the position of the camera in the world coordinates.</li>
<li>The <kbd>upVector</kbd> vector in the world coordinates is the vector that would appear pointing up when viewing it through the camera.</li>
<li>The <kbd>viewCenter</kbd> vector in the world coordinates is the point that will appear in the center of the viewport.</li>
</ul>
<p>When using the perspective projection, you usually need to set the aspect ratio according to the window size. The <kbd>Camera</kbd> object has the <kbd>aspectRatio</kbd> property for that, but we don't need to set it, since the <kbd>Qt3DQuickWindow</kbd> object will update this property automatically.</p>
<p>You can disable this feature by adding  <kbd>window.setCameraAspectRatioMode(Qt3DExtras::Quick::Qt3DQuickWindow::UserAspectRatio)</kbd> to the <kbd>main.cpp</kbd> file.</p>
<p>If you want to use an orthographic projection instead of a perspective one, you can use the <kbd>top</kbd>, <kbd>left</kbd>, <kbd>bottom</kbd>, and <kbd>right</kbd> properties of the <kbd>Camera</kbd> object to set the visible area.</p>
<p>Finally, the second component of our <kbd>Entity</kbd> is the <kbd>InputSettings</kbd> component. Its <kbd>eventSource</kbd> property should point to the object that provides the input events. As with <kbd>aspectRatio</kbd>, we don't need to set this property manually. The <kbd>Qt3DQuickWindow</kbd> will find the <kbd>InputSettings</kbd> object and set itself as the <kbd>eventSource</kbd>.</p>
<p>You can run the project to verify that it compiles successfully and doesn't produce any runtime errors. You should receive an empty black window as a result.</p>
<p>Now let's add something visible to our scene. Edit the <kbd>main.qml</kbd> file to add a few child objects to the root <kbd>Entity</kbd>, as shown:</p>
<pre>Entity {<br/>    components: [<br/>        RenderSettings { /* ... */ },<br/>        InputSettings {}<br/>    ]<br/>    <strong>FirstPersonCameraController {</strong><br/><strong>        camera: camera</strong><br/><strong>    }</strong><br/><strong>    Entity {</strong><br/><strong>        components: [</strong><br/><strong>            DirectionalLight {</strong><br/><strong>                color: Qt.rgba(1, 1, 1)</strong><br/><strong>                intensity: 0.5</strong><br/><strong>                worldDirection: Qt.vector3d(0, -1, 0)</strong><br/><strong>            }</strong><br/><strong>        ]</strong><br/><strong>    }</strong><br/><strong>    Entity {</strong><br/><strong>        components: [</strong><br/><strong>            CuboidMesh {},</strong><br/><strong>            DiffuseSpecularMaterial { ambient: "#aaa"; shininess: 100; },</strong><br/><strong>            Transform { scale: 10 }</strong><br/><strong>        ]</strong><br/><strong>    }</strong><br/>}</pre>
<p>As a result, you should see a cube at the center of the window:</p>
<div><img src="img/c4641a69-bed6-448d-8a8e-5091b7237f54.png" width="1032" height="794"/></div>
<p>More than that, you can use the arrow keys, the <strong>Page Up</strong> and <strong>Page Down</strong> keys, and the left mouse button to move the camera around.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>We added a few objects to our scene graph. First, the <kbd>FirstPersonCameraController</kbd> object allows the user to freely control the camera. This is quite useful for testing the game while you don't have your own camera controlling code yet. Next, an entity with a single <kbd>DirectionalLight</kbd> component works as a light source in the scene. We use the properties of this component to set the color, intensity, and direction of the light. </p>
<p>Finally, we added an entity that represents a regular 3D object. Its shape is provided by the <kbd>CuboidMesh</kbd> component that generates a unit cube. The appearance of its surface is defined by the <kbd>DiffuseSpecularMaterial</kbd> component that conforms to the widely used Phong reflection model. You can use <kbd>ambient</kbd>, <kbd>diffuse</kbd>, and <kbd>specular</kbd> color properties to control different components of the reflected light. The <kbd>shininess</kbd> property defines how smooth the surface is. We use the <kbd>Transform</kbd> component to scale the cube to a larger size.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – constructing the Tower of Hanoi scene</h1>
                
            
            
                
<p>Our next task will be to create a foundation and three rods for our puzzle. We will take advantage of QML's modular system and split our code into multiple components. First, let's leave camera and lighting settings in the <kbd>main.qml</kbd> and put our actual scene content to a new <kbd>Scene</kbd> component. In order to do that, put the text cursor onto the Entity declaration of the cube, press <em>Alt</em> + <em>Enter</em> and select Move Component into Separate File. Input <kbd>Scene</kbd> as the component name and confirm the operation. Qt Creator will create a new <kbd>Scene.qml</kbd> file and add it to the project's resources. The <kbd>main.qml</kbd> now contains just an instantiation of our scene component:</p>
<pre>Entity {<br/>    //...<br/>    Scene { }<br/>}</pre>
<p>The actual properties of the entity are moved to the <kbd>Scene.qml</kbd> file. Let's adjust it to the following form:</p>
<pre>Entity {<br/>    id: sceneRoot<br/>    Entity {<br/>        components: [<br/>            DiffuseSpecularMaterial {<br/>                ambient: "#444"<br/>            },<br/>            CuboidMesh {},<br/>            Transform {<br/>                scale3D: Qt.vector3d(40, 1, 40)<br/>            }<br/>        ]<br/>    }<br/>}</pre>
<p>Our scene will contain multiple items, so we introduced a new <kbd>Entity</kbd> object and called it <kbd>sceneRoot</kbd>. This entity doesn't have any components, so it will not have any visible effect on the scene. This is similar to how an object of <kbd>Item</kbd> type usually serves as a container for Qt Quick items without providing any visual content.</p>
<p>The cube entity is now a child of <kbd>sceneRoot</kbd>. We use the <kbd>scale3D</kbd> property of the <kbd>Transform</kbd> component to change the dimensions of our cube. Now it looks like a tabletop that will serve as a foundation for the rest of the objects.</p>
<p>Now let's work on the rods. Naturally, we want to have a <kbd>Rod</kbd> component because it is a repeating part of our scene. Invoke the context menu of <kbd>qml.qrc</kbd> in the project tree and choose Add New. From the Qt category, choose QML File (Qt Quick 2) and input <kbd>Rod</kbd> as the filename. Let's see how we can implement this component:</p>
<pre>import Qt3D.Core 2.10<br/>import Qt3D.Render 2.10<br/>import Qt3D.Extras 2.10<br/>Entity {<br/>    property int index<br/>    components: [<br/>        CylinderMesh {<br/>            id: mesh<br/>            radius: 0.5<br/>            length: 9<br/>            slices: 30<br/>        },<br/>        DiffuseSpecularMaterial {<br/>            ambient: "#111"<br/>        },<br/>        Transform {<br/>            id: transform<br/>            translation: {<br/>                var radius = 8;<br/>                var step = 2 * Math.PI / 3;<br/>                return Qt.vector3d(radius * Math.cos(index * step),<br/>                                   mesh.length / 2 + 0.5,<br/>                                   radius * Math.sin(index * step));<br/><br/>            }<br/>        }<br/>    ]<br/>}</pre>
<p>Similar to the cube entity, our rod consists of a mesh, a material, and a <kbd>Transform</kbd> component. Instead of the <kbd>CubeMesh</kbd>, we use the <kbd>CylinderMesh</kbd> component that will create a cylinder for us. The <kbd>radius</kbd> and <kbd>length</kbd> properties define the dimensions of the object, and the <kbd>slices</kbd> property impacts the number of generated triangles. We chose to increase the number of slices to make the cylinders look better, but be aware that it has a performance impact that may become noticeable if you have many objects. </p>
<p>Our <kbd>Rod</kbd> component has the index property that contains the positional number of the rod. We use this property to calculate the <em>x</em> and <em>z</em> coordinates of the rod so that all three rods are placed on a circle with an eight radius. The <em>y</em> coordinate is set to ensure that the rod is positioned on top of the foundation. We assign the calculated position vector to the <kbd>translation</kbd> property of the <kbd>Transform</kbd> component. Finally, add three <kbd>Rod</kbd> objects to the <kbd>Scene.qml</kbd> file:</p>
<pre>Entity {<br/>    id: sceneRoot<br/>    //...<br/>    Rod { index: 0 }<br/>    Rod { index: 1 }<br/>    Rod { index: 2 }<br/>}</pre>
<p>When you run the project, you should see the foundation and the rods:</p>
<div><img src="img/d5089464-00d9-4aff-a550-47bd14caa50d.png" width="1032" height="794"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – repeating 3D objects</h1>
                
            
            
                
<p>Our code works, but the way we create the rods is not ideal. First, enumerating rods and their indices in <kbd>Scene.qml</kbd> is inconvenient and error-prone. Second, we'll need to have a way to access a <kbd>Rod</kbd> object by its index, and the current approach doesn't allow that. In the previous chapters, we dealt with repeating Qt Quick objects using the <kbd>Repeater</kbd> QML type. However, <kbd>Repeater</kbd> doesn't work for <kbd>Entity</kbd> objects. It's only able to handle types that inherit from Qt Quick <kbd>Item</kbd>.</p>
<p>The solution to our problem is already familiar to you since <a href="4fdfe294-c35c-476d-9656-0aefd533e491.xhtml">Chapter 12</a><em>, Customization in Qt Quick</em>. We can create QML objects using imperative JavaScript code. Remove <kbd>Rod</kbd> objects from the <kbd>Scene.qml</kbd> file and make the following additions instead:</p>
<pre>Entity {<br/>    id: sceneRoot<br/><strong>    property variant rods: []</strong><br/>    Entity { /* ... */}<br/><strong>    Component.onCompleted: {</strong><br/><strong>        var rodComponent = Qt.createComponent("Rod.qml");</strong><br/><strong>        if(rodComponent.status !== Component.Ready) {</strong><br/><strong>            console.log(rodComponent.errorString());</strong><br/><strong>            return;</strong><br/><strong>        }</strong><br/><strong>        for(var i = 0; i &lt; 3; i++) {</strong><br/><strong>            var rod = rodComponent.createObject(sceneRoot, { index: i });</strong><br/><strong>            rods.push(rod);</strong><br/><strong>        }</strong><br/><strong>    }</strong><br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>First, we created a property called <kbd>rods</kbd> that will hold an array of created <kbd>Rod</kbd> objects. Next, we used the <kbd>Component.onCompleted</kbd> attached property to run some JavaScript code after the QML engine instantiates our root object. Our first action was to load the <kbd>Rod</kbd> component and check whether it was loaded successfully. After obtaining a functioning component object, we used its <kbd>createObject()</kbd> method to create three new rods. We used the arguments of this function to pass the root object and value of the <kbd>index</kbd> property. Finally, we pushed the <kbd>Rod</kbd> object into the array.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – creating disks</h1>
                
            
            
                
<p>Our next task is to create eight disks that will slide onto rods. We'll do it in a similar way to how we handled rods. First, create a new file called <kbd>Disk.qml</kbd> for our new component. Put the following content into the file:</p>
<pre>import Qt3D.Core 2.10<br/>import Qt3D.Render 2.10<br/>import Qt3D.Extras 2.10<br/><br/>Entity {<br/>    property int index<br/>    property alias pos: transform.translation<br/>    components: [<br/>        DiffuseSpecularMaterial {<br/>            ambient: Qt.hsla(index / 8, 1, 0.5)<br/>        },<br/>        TorusMesh {<br/>            minorRadius: 1.1<br/>            radius: 2.5 + 1 * index<br/>            rings: 80<br/>        },<br/>        Transform {<br/>            id: transform<br/>            rotationX: 90<br/>            scale: 0.45<br/>        }<br/>    ]<br/>}</pre>
<p>Like rods, disks are identified by their index. In this case, index influences the color and size of the disk. We calculate the disk's color using the <kbd>Qt.hsla()</kbd> function that takes hue, saturation, and lightness values and returns a <kbd>color</kbd> value that can be assigned to the <kbd>ambient</kbd> property of the material. This formula will give us eight colorful disks of different hues.</p>
<p>The position of the disk is defined by the <kbd>translation</kbd> property of the <kbd>Transform</kbd> component. We want to be able to read and change the position of the disk from the outside, so we set up a property alias called <kbd>pos</kbd> that exposes the <kbd>transform.translation</kbd> property value. </p>
<p>Next, we use the <kbd>TorusMesh</kbd> component to define the shape of our disks. A torus shape is not really suitable for playing the Tower of Hanoi game in reality, but it will have to do for now. Later in this chapter, we'll replace it with a more suitable shape. The properties of the <kbd>TorusMesh</kbd> component allow us to adjust some of its measurements, but we also have to apply rotation and scale to the object to achieve the desired size and position.</p>
<p>Instead of putting all the disk objects into a single array, let's create an array for each rod. When we move a disk from one rod to another one, we'll remove the disk from the first rod's array and add it to the second rod's array. We can do that by adding a property to the <kbd>Rod</kbd> component. While we're at it, we should also expose the rod's position to the outside. We'll need it to position the disks on the rods. Declare the following properties in the top level <kbd>Entity</kbd> in <kbd>Rod.qml</kbd>:</p>
<pre>readonly property alias pos: transform.translation<br/>property var disks: []</pre>
<p>The <kbd>pos</kbd> property will follow the value of the <kbd>translation</kbd> property of the <kbd>Transform</kbd> component. Since this value is calculated based on the <kbd>index</kbd> property, we declare the <kbd>pos</kbd> property as <kbd>readonly</kbd>.</p>
<p>Next, we need to adjust the <kbd>Component.onCompleted</kbd> handler of the <kbd>Scene</kbd> component. Initialize the <kbd>diskComponent</kbd> variable, just like we did with <kbd>rodComponent</kbd>. Then you can create disks using the following code:</p>
<pre>var startingRod = rods[0];<br/>for(i = 0; i &lt; 8; i++) {<br/>    var disk = diskComponent.createObject(sceneRoot, { index: i });<br/>    disk.pos = Qt.vector3d(startingRod.pos.x, 8 - i, startingRod.pos.z);<br/>    startingRod.disks.unshift(disk);<br/>}</pre>
<p>After creating each disk, we set its position based on its index and the position of the chosen rod. We accumulate all disks in the <kbd>disks</kbd> property of the rod. We choose the order of disks in the array so that the bottom disk is at the beginning and the top disk is at the end. The <kbd>unshift()</kbd> function adds the item to the array at the beginning, giving the desired order.</p>
<p>If you run the project, you should see all eight tori on one of the rods:</p>
<div><img src="img/140c44d4-992a-40ee-ae7d-dc71c062cd55.png" width="1032" height="794"/></div>
<p>The next piece of functionality we'll need is the ability to move disks from one rod to another. However, it's the player who makes the decision, so we'll also need some way to receive input from the user. Let's see what options we have for handling user input.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Handling user input</h1>
                
            
            
                
<p>The first way of receiving events in Qt 3D is to use Qt GUI capabilities. The <kbd>Qt3DQuickWindow</kbd> class we use inherits from <kbd>QWindow</kbd>. That allows you to subclass <kbd>Qt3DQuickWindow</kbd> and reimplement some of its virtual functions, such as <kbd>keyPressEvent()</kbd> or <kbd>mouseMoveEvent()</kbd>. You are already familiar with this part of Qt API because it's roughly the same as provided by Qt Widgets and Graphics View. Qt 3D doesn't introduce anything special here, so we won't give this approach much attention.</p>
<p>Similar to Qt Quick, Qt 3D introduces a higher-level API for receiving input events. Let's see how we can use it.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Devices</h1>
                
            
            
                
<p>Qt 3D is focused on providing a good abstraction for every aspect it handles. This applies to input as well. In terms of Qt 3D, an application may have access to an arbitrary number of <strong>physical devices</strong>. They are represented by the <kbd>AbstractPhysicalDevice</kbd> type. At the time of writing, there are two built-in types of physical devices: keyboard and mouse. You can access them by declaring an object of <kbd>KeyboardDevice</kbd> or <kbd>MouseDevice</kbd> type in your QML file.</p>
<p>You can use properties of the device object to configure its behavior. There is currently only one such property: the <kbd>MouseDevice</kbd> type has a <kbd>sensitivity</kbd> property that affects how mouse movement is converted to axis inputs.</p>
<p>It's allowed to create multiple objects of the same device type in a single application. All devices will handle all received inputs, but you can set different values of properties for different device objects.</p>
<p>You typically don't want to handle events directly from the physical devices. Instead, you should set up a <strong>logical device</strong> that receives events from the physical devices and converts them to actions and inputs that make sense for your application. You can specify a set of <strong>actions</strong> and <strong>axes</strong> for your device using the <kbd>actions</kbd> and <kbd>axes</kbd> properties of the <kbd>LogicalDevice</kbd> type, and Qt 3D will recognize the described inputs and notify your objects about them.</p>
<p>We will provide a few code examples to demonstrate how to handle various kinds of input in Qt 3D. You can test the code by putting it into the <kbd>main.qml</kbd> file of the <kbd>hanoi</kbd> project or create a separate project for that. </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Keyboard and mouse buttons</h1>
                
            
            
                
<p>An action is represented by the <kbd>Action</kbd> type. An action can be triggered by pressing a single key, a key combination, or a key sequence. This is defined by the <kbd>inputs</kbd> property of the <kbd>Action</kbd> type. The most simple kind of input is <kbd>ActionInput</kbd> which reacts to a single key.</p>
<p>When the action is triggered, its <kbd>active</kbd> property will change from <kbd>false</kbd> to <kbd>true</kbd>. When the corresponding key or key combination is released, <kbd>active</kbd> changes back to <kbd>false</kbd>. You can use the usual QML features to track changes of the property:</p>
<pre>Entity {<br/>    //...<br/>    KeyboardDevice { id: keyboardDevice }<br/>    MouseDevice { id: mouseDevice }<br/>    LogicalDevice {<br/>        actions: [<br/>            Action {<br/>                inputs: ActionInput {<br/>                    sourceDevice: keyboardDevice<br/>                    buttons: [Qt.Key_A]<br/>                }<br/>                onActiveChanged: {<br/>                    console.log("A changed: ", active);<br/>                }<br/>            },<br/>            Action {<br/>                inputs: ActionInput {<br/>                    sourceDevice: keyboardDevice<br/>                    buttons: [Qt.Key_B]<br/>                }<br/>                onActiveChanged: {<br/>                    console.log("B changed: ", active);<br/>                }<br/>            },<br/>            Action {<br/>                inputs: ActionInput {<br/>                    sourceDevice: mouseDevice<br/>                    buttons: [MouseEvent.RightButton]<br/>                }<br/>                onActiveChanged: {<br/>                    console.log("RMB changed: ", active);<br/>                }<br/>            }<br/>        ]<br/>    }<br/>}</pre>
<p>As you can see, keyboard and mouse button events are handled in the same way. However, they come from different physical devices, so make sure you specify the correct device in the <kbd>sourceDevice</kbd> property of <kbd>ActionInput</kbd>.</p>
<p>You can specify multiple buttons for <kbd>ActionInput</kbd>. In this case, the action will trigger if any of the specified buttons are pressed. For example, use the following code to handle both the main <em>Enter</em> key and the <em>Enter</em> key on the keypad:</p>
<pre>Action {<br/>    inputs: ActionInput {<br/>        sourceDevice: keyboardDevice<br/>        buttons: [Qt.Key_Return, Qt.Key_Enter]<br/>    }<br/>    onActiveChanged: {<br/>        if (active) {<br/>            console.log("enter was pressed");<br/>        } else {<br/>            console.log("enter was released");<br/>        }<br/>    }<br/>}</pre>
<p>Note that it's not required to put the input handling code into the root object of the scene. You can put it into any <kbd>Entity</kbd>. It's also possible to have multiple entities handling input events at the same time.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Input chords</h1>
                
            
            
                
<p>The <kbd>InputChord</kbd> type allows you to trigger an action when multiple keys are pressed at the same time:</p>
<pre>Action {<br/>    inputs: InputChord {<br/>        timeout: 500<br/>        chords: [<br/>            ActionInput {<br/>                sourceDevice: keyboardDevice<br/>                buttons: [Qt.Key_Q]<br/>            },<br/>            ActionInput {<br/>                sourceDevice: keyboardDevice<br/>                buttons: [Qt.Key_W]<br/>            },<br/>            ActionInput {<br/>                sourceDevice: keyboardDevice<br/>                buttons: [Qt.Key_E]<br/>            }<br/>        ]<br/>    }<br/>    onActiveChanged: {<br/>        console.log("changed: ", active);<br/>    }<br/>}</pre>
<p>The <kbd>onActiveChanged</kbd> handler will be called when <em>Q</em>, <em>W</em>, and <em>E</em> keys are pressed within 500 milliseconds and held together.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Analog (axis) input</h1>
                
            
            
                
<p><strong>Axis</strong> in Qt 3D is an abstraction of analog one-dimensional input. A typical source of axis input is an analog stick of a gamepad. As the name implies, <kbd>Axis</kbd> only represents movement along a single axis, so a stick can be represented by two axes—one for vertical movement and one for horizontal movement. A pressure-sensitive button can be represented by a single axis. An axis input produces a <kbd>float</kbd> value ranging from −1 to 1, with zero corresponding to the neutral position.</p>
<p>That being said, there is no gamepad support in Qt 3D at the time of writing. It's possible that it will be added in future versions. You can also use the extensible C++ API of Qt 3D to implement the gamepad device using Qt Gamepad. However, the simplest solution is to use Qt Gamepad directly. Nothing prevents you from using QML or C++ API of Qt Gamepad in an application that uses Qt 3D.</p>
<p>The <kbd>inputs</kbd> property of the <kbd>Axis</kbd> type allows you to specify which input events should be redirected to this axis. You can use the <kbd>AnalogAxisInput</kbd> type to access the axis data provided by a physical device. The <kbd>MouseDevice</kbd> provides four virtual axes that are emulated based on the mouse input. Two of them are based on the vertical and horizontal scroll. Two others are based on vertical and horizontal pointer movement, but they only work while any mouse button is pressed.</p>
<p>The <kbd>ButtonAxisInput</kbd> type allows you to emulate an axis based on the button pressed. You can use the <kbd>scale</kbd> property to set the axis value corresponding to each button. When multiple buttons are pressed together, the mean of their axis values is used.</p>
<p>Both mouse-based and button-based axes are demonstrated in the following example:</p>
<pre>LogicalDevice {<br/>    axes: [<br/>        Axis {<br/>            inputs: [<br/>                AnalogAxisInput {<br/>                    sourceDevice: mouseDevice<br/>                    axis: MouseDevice.X<br/>                }<br/>            ]<br/>            onValueChanged: {<br/>                console.log("mouse axis value", value);<br/>            }<br/>        },<br/>        Axis {<br/>            inputs: [<br/>                ButtonAxisInput {<br/>                    sourceDevice: keyboardDevice<br/>                    buttons: [Qt.Key_Left]<br/>                    scale: -1.0<br/>                },<br/>                ButtonAxisInput {<br/>                    sourceDevice: keyboardDevice<br/>                    buttons: [Qt.Key_Right]<br/>                    scale: 1<br/>                }<br/>            ]<br/>            onValueChanged: {<br/>                console.log("keyboard axis value", value);<br/>            }<br/>        }<br/>    ]<br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Object picker</h1>
                
            
            
                
<p>Object picker is a component that allows an entity to interact with the mouse pointer. This component does not interact with the previously described input API directly. For example, you don't need to provide a mouse device for it. All you need to do is to attach the <kbd>ObjectPicker</kbd> component to an entity that also contains a mesh. The signals from <kbd>ObjectPicker</kbd> will notify you about input events related to this entity:</p>
<table>
<tbody>
<tr>
<td><strong>Signal</strong></td>
<td><strong>Explanation</strong></td>
</tr>
<tr>
<td><kbd>clicked(pick)</kbd></td>
<td>The object was clicked.</td>
</tr>
<tr>
<td><kbd>pressed(pick)</kbd></td>
<td>The mouse button was pressed over the object.</td>
</tr>
<tr>
<td><kbd>released(pick)</kbd></td>
<td>The mouse button was released after <kbd>pressed(pick)</kbd> was triggered.</td>
</tr>
<tr>
<td><kbd>moved(pick)</kbd></td>
<td>The mouse pointer was moved.</td>
</tr>
<tr>
<td><kbd>entered()</kbd></td>
<td>The mouse pointer entered the object's area.</td>
</tr>
<tr>
<td><kbd>exited()</kbd></td>
<td>The mouse pointer exited the object's area.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Additionally, the <kbd>pressed</kbd> property will be set to <kbd>true</kbd> while a mouse button is pressed over the object, and the <kbd>containsMouse</kbd> property will be set to <kbd>true</kbd> while the mouse pointer is over the object's area. You can attach change handlers to these properties or use them in a property binding, as with any other property in QML:</p>
<pre>Entity {<br/>    components: [<br/>        DiffuseSpecularMaterial { /* ... */ },<br/>        TorusMesh { /* ... */ },<br/>        ObjectPicker {<br/>            hoverEnabled: true<br/>            onClicked: {<br/>                console.log("clicked");<br/>            }<br/>            onContainsMouseChanged: {<br/>                console.log("contains mouse?", containsMouse);<br/>            }<br/>        }<br/>    ]<br/>}</pre>
<p>Depending on your scene, picking can be a heavy computational task. By default, the most simple and efficient options are used. The default object picker will only handle mouse press and release events. You can set its <kbd>dragEnabled</kbd> property to <kbd>true</kbd> to handle mouse movements after <kbd>pressed(pick)</kbd> was triggered. You can also set the <kbd>hoverEnabled</kbd> property to <kbd>true</kbd> to handle all mouse movements, even when mouse buttons aren't pressed. There properties belong to the <kbd>ObjectPicker</kbd> component, so you can set them separately for each entity.</p>
<p>There are also global picking settings that affect the whole window. They are stored in the <kbd>pickingSettings</kbd> property of the <kbd>RenderSettings</kbd> component that is normally attached to the root entity. The settings can be changed like this:</p>
<pre>Entity {<br/>    components: [<br/>        RenderSettings {<br/>            activeFrameGraph: ForwardRenderer { /*...*/ }<br/><strong>            pickingSettings.pickMethod: PickingSettings.TrianglePicking</strong><br/>        },<br/>        InputSettings {}<br/>    ]<br/>    //...<br/>}</pre>
<p>Let's go through the possible settings. The <kbd>pickResultMode</kbd> property defines the behavior of overlapping pickers. If it's set to <kbd>PickingSettings.NearestPick</kbd>, only the object nearest to the camera will receive the event. If <kbd>PickingSettings.AllPicks</kbd> is specified, all objects will receive the event.</p>
<p>The <kbd>pickMethod</kbd> property allows you to choose how pickers decide whether the mouse pointer overlaps with the object. The default value is <kbd>PickingSettings.BoundingVolumePicking</kbd>, meaning that only the bounding box of the object is taken into account. This is a fast but inaccurate method. To achieve higher accuracy, you can set the <kbd>PickingSettings.TrianglePicking</kbd> method, which takes all mesh triangles into account.</p>
<p>Finally, the <kbd>faceOrientationPickingMode</kbd> property allows you to choose if the front face, back face, or both faces will be used for the triangle picking.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Frame-based input handling</h1>
                
            
            
                
<p>In all the previous examples, we used property change signal handlers to execute code when the state of the logical device or object picker changes. This allows you, for example, to execute a function at the moment a button is pressed or released. However, sometimes you want to execute a continuous action (for example, accelerate an object) while a button is pressed. This is easy to do with just a few changes to the code.</p>
<p>First, you need to attach an <kbd>id</kbd> to the object with interesting properties (for example <kbd>Action</kbd>, <kbd>Axis</kbd>, or <kbd>ObjectPicker</kbd>):</p>
<pre>LogicalDevice {<br/>    actions: [<br/>        Action {<br/><strong>            id: myAction</strong><br/>            inputs: ActionInput {<br/>                sourceDevice: keyboardDevice<br/>                buttons: [Qt.Key_A]<br/>            }<br/>        }<br/>    ]<br/>}</pre>
<p>This will allow you to refer to its properties. Next, you need to use the <kbd>FrameAction</kbd> component provided by the <kbd>Qt3DLogic</kbd> module. This component will simply emit the <kbd>triggered()</kbd> signal each frame. You can attach it to any entity and use the input data as you want:</p>
<pre>Entity {<br/>    components: [<br/>        //...<br/>        FrameAction {<br/>            onTriggered: {<br/>                console.log("A state: ", myAction.active);<br/>            }<br/>        }        <br/>    ]</pre>
<p>You can use the <kbd>FrameAction</kbd> component to run any code that should be executed once per frame. However, don't forget that QML allows you to use property bindings, so you can set property values based on user input without having to write imperative code at all.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – receiving mouse input</h1>
                
            
            
                
<p>Our game is pretty simple, so the only action the player has to do is pick two rods for a move. Let's use <kbd>ObjectPicker</kbd> to detect when the player clicks on a rod.</p>
<p>First, set the <kbd>pickingSettings.pickMethod</kbd> property of the <kbd>RenderSettings</kbd> object to <kbd>PickingSettings.TrianglePicking</kbd> in the <kbd>main.qml</kbd> file (you can use the code example from the previous section). Our scene is very simple, and triangle picking shouldn't be too slow. This setting will greatly increase the picker's accuracy.</p>
<p>The next set of changes will go to the <kbd>Rod.qml</kbd> file. First, add an ID to the root entity and declare a signal that will notify the outside world that the rod was clicked:</p>
<pre>Entity {<br/>    <strong>id: rod</strong><br/>    property int index<br/>    readonly property alias pos: transform.translation<br/>    property var disks: []<br/>    <strong>signal clicked()</strong><br/>    //...<br/>}</pre>
<p>Next, add an <kbd>ObjectPicker</kbd> to the <kbd>components</kbd> array and emit the public <kbd>clicked()</kbd> signal when the picker reports that it was clicked:</p>
<pre>Entity {<br/>    //...<br/>    components: [<br/>        //...<br/>        ObjectPicker {<br/>            id: picker<br/>            hoverEnabled: true<br/>            onClicked: rod.clicked()<br/>        }<br/>    ]<br/>}</pre>
<p>Finally, let's give the player a hint that the rod is clickable by highlighting it when it intersects with the mouse pointer:</p>
<pre>DiffuseSpecularMaterial {<br/>    ambient: {<br/>        return picker.containsMouse? "#484" : "#111";<br/>    }<br/>},</pre>
<p>When the player puts the mouse pointer over a rod, the <kbd>picker.containsMouse</kbd> property will become <kbd>true</kbd>, and QML will update the material's color automatically. You should see this behavior when running the project. The next task is to access the rod's <kbd>clicked()</kbd> signal from the <kbd>Scene</kbd> component. To do that, you'll need to make the following changes to the code:</p>
<pre>Component.onCompleted: {<br/>    //...<br/>    var setupRod = function(i) {<br/>        var rod = rodComponent.createObject(sceneRoot, { index: i });<br/>        rod.clicked.connect(function() {<br/>            rodClicked(rod);<br/>        });<br/>        return rod;<br/>    }<br/><br/>    for(var i = 0; i &lt; 3; i++) {<br/>        rods.push(setupRod(i));<br/>    }<br/>    //...<br/><br/>}<br/>function rodClicked(rod) {<br/>    console.log("rod clicked: ", rods.indexOf(rod));<br/>}</pre>
<p>As a result of these changes, the game should print a message to the application output, whenever a rod is clicked. </p>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>First, we added a <kbd>setupRod()</kbd> helper function that creates a new rod and connects its signal to the new <kbd>rodClicked()</kbd> function. Then we simply called <kbd>setupRod()</kbd> for each index and accumulated the rod object into the <kbd>rods</kbd> array. The <kbd>rodClicked()</kbd> function will contain the rest of our game logic, but for now it only prints the index of the clicked rod to the application output.</p>
<p>Note that the content of the <kbd>setupRod()</kbd> function cannot be placed directly into the body of the <kbd>for</kbd> loop over <kbd>i</kbd>. The <kbd>clicked()</kbd> signal is connected to a closure that captures the <kbd>rod</kbd> variable. Within the function, each rod will connect to a closure that captures the corresponding <kbd>Rod</kbd> <br/>object. Within the <kbd>for</kbd> loop, all closures would capture the common <br/><kbd>rod</kbd> variable that will hold the last <kbd>Rod</kbd> object for all the closures.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Performing animations</h1>
                
            
            
                
<p>Animations are essential for making a good game. Qt 3D provides a separate module for performing animations, but at the time of writing it's still experimental. Luckily, Qt already provides multiple ways to play animations. When using C++ API, you can use the Animation Framework (we learned about it in <a href="bf16fe2f-f507-4980-96cd-9b53b200522e.xhtml">Chapter 5</a>, <em>Animations in Graphics View</em>). When using QML, you can use the powerful and convenient animation system provided by Qt Quick. We already worked with it a lot in previous chapters, so here we'll see how we can apply our knowledge to Qt 3D.</p>
<p>Qt Quick animations can be applied to almost any property of any QML object (strictly speaking, there are property types it can't handle, but we won't deal with those types here). If you look at the QML files of our project, you'll see that basically everything in our scene is defined by properties. That means that you can animate positions, colors, dimensions of objects and almost everything else.</p>
<p>Our current task will be to create an animation of the disk sliding up from the rod, moving across the table to the other rod, and sliding down that rod. The property we'll animate is <kbd>pos</kbd> which is the property alias for <kbd>transform.translation</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – animating disk movements</h1>
                
            
            
                
<p>Our animation will consist of three parts, so it will require a fair amount of code. Instead of putting all that code directly into the <kbd>Scene</kbd> component, let's put the animation into a separate component. Create a new file called <kbd>DiskAnimation.qml</kbd> and fill it with the following code:</p>
<pre>import QtQuick 2.10<br/><br/>SequentialAnimation {<br/>    id: rootAnimation<br/>    property variant target: null<br/>    property vector3d rod1Pos<br/>    property vector3d rod2Pos<br/>    property int startY<br/>    property int finalY<br/><br/>    property int maxY: 12<br/><br/>    Vector3dAnimation {<br/>        target: rootAnimation.target<br/>        property: "pos"<br/>        to: Qt.vector3d(rod1Pos.x, maxY, rod1Pos.z)<br/>        duration: 30 * (maxY - startY)<br/><br/>    }<br/>    Vector3dAnimation {<br/>        target: rootAnimation.target<br/>        property: "pos"<br/>        to: Qt.vector3d(rod2Pos.x, maxY, rod2Pos.z)<br/>        duration: 400<br/>    }<br/>    Vector3dAnimation {<br/>        target: rootAnimation.target<br/>        property: "pos"<br/>        to: Qt.vector3d(rod2Pos.x, finalY, rod2Pos.z)<br/>        duration: 30 * (maxY - finalY)<br/>    }<br/>}</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">What just happened?</h1>
                
            
            
                
<p>Our animation has a lot of properties because it should be flexible enough to handle all the cases we need. First, it should be able to animate any disk, so we added the <kbd>target</kbd> property that will contain the disk we currently move. Next, the rods that participate in the movement influence the intermediate and final coordinates of the disk (more specifically, its <em>x</em> and <em>z</em> coordinates). The <kbd>rod1Pos</kbd> and <kbd>rod2Pos</kbd> properties will hold the coordinates of the rods in play. The <kbd>startY</kbd> and <kbd>finalY</kbd> properties define the starting and final coordinates of the disk. These coordinates will depend on the current number of disks stored on each rod. Finally, the <kbd>maxY</kbd> property simply defines the maximum height the disk will raise at while moving. </p>
<p>The property we animated is of the <kbd>vector3d</kbd> type, so we needed to use the  <kbd>Vector3dAnimation</kbd> type that is able to correctly interpolate all three components of the vector. We set the same <kbd>target</kbd> and <kbd>property</kbd> for all three parts of the animation. Then, we carefully calculated the final position of the disk after each stage and assigned it to the <kbd>to</kbd> property. There is no need to set the <kbd>from</kbd> property, as the animation will automatically use the current position of the disk as the starting point. Finally, we calculated the <kbd>duration</kbd> of each step to ensure steady movement of the disk.</p>
<p>Of course, we want to test the new animation right away. Add a <kbd>DiskAnimation</kbd> object to the <kbd>Scene</kbd> component and initialize the animation at the end of the  <kbd>Component.onCompleted</kbd> handler:</p>
<pre>DiskAnimation { id: diskAnimation }<br/>Component.onCompleted: {<br/>    //...<br/>    var disk1 = rods[0].disks.pop();<br/>    diskAnimation.rod1Pos = rods[0].pos;<br/>    diskAnimation.rod2Pos = rods[1].pos;<br/>    diskAnimation.startY = disk1.pos.y;<br/>    diskAnimation.finalY = 1;<br/>    diskAnimation.target = disk1;<br/>    diskAnimation.start();<br/><br/>}</pre>
<p>When you run the application, you should see the top disk moving from one rod to another.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – implementing game logic</h1>
                
            
            
                
<p>Most of the required preparations are done, and now it's time to make our game functional. The player should be able to make a move by clicking on a rod and then clicking on another rod. After the first rod is selected, the game should remember it and show it in a different color.</p>
<p>First, let's prepare the <kbd>Rod</kbd> component. We need it to have a new property that indicates that this rod was selected as the first rod for the next move:</p>
<pre>property bool isSourceRod: false</pre>
<p>It's easy to make the rod change color depending on the <kbd>isSourceRod</kbd> value using a property binding:</p>
<pre>DiffuseSpecularMaterial {<br/>    ambient: {<br/>        if (isSourceRod) {<br/>            return picker.containsMouse? "#f44" : "#f11";<br/>        } else {<br/>            return picker.containsMouse? "#484" : "#111";<br/>        }<br/>    }<br/>},</pre>
<p>Now let's turn our attention to the <kbd>Scene</kbd> component. We'll need a property that contains the currently selected first rod:</p>
<pre>Entity {<br/>    id: sceneRoot<br/>    property variant rods: []<br/><strong>    property variant sourceRod</strong><br/>    //...<br/>}</pre>
<p>All that remains is the implementation of the <kbd>rodClicked()</kbd> function. Let's go through it in two steps:</p>
<pre>function rodClicked(rod) {<br/>    if (diskAnimation.running) { return; }<br/>    if (rod.isSourceRod) {<br/>        rod.isSourceRod = false;<br/>        sourceRod = null;<br/>    } else if (!sourceRod) {<br/>        if (rod.disks.length &gt; 0) {<br/>            rod.isSourceRod = true;<br/>            sourceRod = rod;<br/>        } else {<br/>            console.log("no disks on this rod");<br/>        }<br/>    } else {<br/>        //...<br/>    }<br/>}</pre>
<p>First, we check whether the move animation is already running, and ignore the event if it is. Next, we check whether the clicked rod was already selected. In this case, we simply deselect the rod. This allows the player to cancel the move if they accidentally selected an incorrect rod.</p>
<p>If <kbd>sourceRod</kbd> is unset, that means that we're in the first phase of the move. We check that the clicked rod has some disks on it, otherwise a move would not be possible. If everything is all right, we set the <kbd>sourceRod</kbd> property and the rod's <kbd>isSourceRod</kbd> property.</p>
<p>The rest of the function handles the second phase of the move:</p>
<pre>var targetRod = rod;<br/>if (targetRod.disks.length &gt; 0 &amp;&amp;<br/>    targetRod.disks[targetRod.disks.length - 1].index &lt;<br/>    sourceRod.disks[sourceRod.disks.length - 1].index)<br/>{<br/>    console.log("invalid move");<br/>} else {<br/>    var disk = sourceRod.disks.pop();<br/>    targetRod.disks.push(disk);<br/>    diskAnimation.rod1Pos = sourceRod.pos;<br/>    diskAnimation.rod2Pos = targetRod.pos;<br/>    diskAnimation.startY = disk.pos.y;<br/>    diskAnimation.finalY = targetRod.disks.length;<br/>    diskAnimation.target = disk;<br/>    diskAnimation.start();<br/>}<br/>sourceRod.isSourceRod = false;<br/>sourceRod = null;</pre>
<p>In this branch, we already know that we have the first rod object stored in the <kbd>sourceRod</kbd> property. We store the clicked rod object in the <kbd>targetRod</kbd> variable. Next, we check whether the player tries to put a larger disk on top of the smaller one. If that's the case, we refuse to make the invalid move.</p>
<p>If everything is correct, we finally perform the move. We use the <kbd>pop()</kbd> function to remove the disk from the end of the <kbd>sourceRod.disks</kbd> array. This is the disk that will be moved to the other rod. We immediately push the disk object to the <kbd>disks</kbd> array of the other rod. Next, we carefully set up all properties of the animation and start it. At the end of the function, we clear the rod's <kbd>isSourceRod</kbd> property and the scene's <kbd>sourceRod</kbd> property to allow the player to make the next move.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Have a go hero – improving the game</h1>
                
            
            
                
<p>Try to make your own modifications to the game. For example, you can notify the player about an invalid move by flashing the background color or the color of the foundation object. You can even add a 3D text to the scene using the <kbd>ExtrudedTextMesh</kbd> component. Try to play with different easing modes to make the animations look better.</p>
<p>The properties and functions of the <kbd>Scene</kbd> object are visible to the outside world, but they really are implementation details. You can fix that by putting them into an internal <kbd>QtObject</kbd>, as we described in <a href="4fdfe294-c35c-476d-9656-0aefd533e491.xhtml">Chapter 12</a>, <em>Customization in Qt Quick</em>.</p>
<p>Qt 3D is very flexible when it comes to rendering. While it's straightforward to use with the simple <kbd>ForwardRenderer</kbd>, you can create a much more complex render graph if you want. It's possible to render to multiple viewports, use off-screen textures, apply custom shaders, and create your own graphics effects and materials. We can't discuss all these possibilities in this book, but you can look at Qt examples to see how this can be done. Some of the relevant examples are Qt3D: Multi Viewport QML, Qt3D: Shadow Map QML, and Qt3D: Advanced custom material QML. </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Integration with 3D modeling software</h1>
                
            
            
                
<p>Geometric shapes provided by the <kbd>Qt3DExtras</kbd> module are great for prototyping. As we saw, these mesh generators come in handy when you want to create and test a new game quickly. However, a real game usually contains more complex figures than spheres and cubes. The meshes are usually prepared using specialized 3D modelling software. Qt 3D provides wide capabilities for importing 3D data from external files.</p>
<p>The first way of importing such data is the <kbd>Mesh</kbd> component. You only need to attach this component to an entity and specify the path to the file using the <kbd>source</kbd> property. As of Qt 5.10, <kbd>Mesh</kbd> supports OBJ, PLY, STL, and Autodesk FBX file formats.</p>
<p>As always, you can use a real filename or a Qt resource path. However, note that the source property expects an URL, not a path. A correct absolute resource path should start with <kbd>qrc:/</kbd>, and an absolute file path should start with <kbd>file://</kbd>. You can also use relative paths that will be resolved relatively to the current QML file.</p>
<p>If you're using OBJ files, <kbd>Mesh</kbd> provides you with an additional option to only load a sub-mesh from the <kbd>source</kbd> file. You can do it by specifying the name of the sub-mesh in the <kbd>meshName</kbd> property of the <kbd>Mesh</kbd> component. Instead of the exact name, you can also specify a regular expression to load all sub-meshes matching that expression.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – using OBJ files for the disks</h1>
                
            
            
                
<p>Qt 3D doesn't provide a suitable mesh for the disks, but we can use a 3D modelling software to make any shape we want and then use it in our project. You will find the required OBJ files in the resources that come with the book. The files are named from <kbd>disk0.obj</kbd> to <kbd>disk7.obj</kbd>. If you want to practice with a 3D modelling software, you can prepare the files yourself.</p>
<p>Create a subdirectory named <kbd>obj</kbd> in your project directory and put the OBJ files there. Invoke the context menu of <kbd>qml.qrc</kbd> in the Qt Creator's project tree and select Add Existing Files. Add all OBJ files to the project. To put these files to work, we need to edit the <kbd>Disk.qml</kbd> file. Remove scale and rotation from the <kbd>Transform</kbd> component. Replace <kbd>TorusMesh</kbd> with <kbd>Mesh</kbd> and specify the resource path to the OBJ file as the <kbd>source</kbd> property:</p>
<pre>components: [<br/>    DiffuseSpecularMaterial { /*...*/ },<br/>    Mesh {<br/>        source: "qrc:/obj/disk" + index + ".obj"<br/>    },<br/>    Transform {<br/>        id: transform<br/>    }<br/>]</pre>
<p>Qt 3D will now use our new models for the disks:</p>
<div><img src="img/9ac45d17-62bc-4229-bb96-e6204b89cfdb.png" width="1032" height="794"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Loading a 3D scene</h1>
                
            
            
                
<p>The <kbd>Mesh</kbd> component is useful when you want to import a single object's shape from an external file. However, sometimes you want to import multiple objects from a single file. For example, you could prepare some decorations surrounding your game action and then import them all at once. This is where the <kbd>SceneLoader</kbd> component becomes useful.</p>
<p>It can be used similar to the <kbd>Mesh</kbd> component:</p>
<pre>Entity {<br/>    components: [<br/>        SceneLoader {<br/>            source: "path/to/scene/file"<br/>        }<br/>    ]<br/>}</pre>
<p>However, instead of providing shape for its entity, <kbd>SceneLoader</kbd> creates a whole tree of <kbd>Entity</kbd> objects that become children of the <kbd>SceneLoader</kbd>'s entity. Each new entity will be provided with a mesh, a material, and a transform according to the file data. <kbd>SceneLoader</kbd> uses Assimp (Open Asset Import Library) to parse the source files, so it supports many common 3D formats.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Working with Qt 3D using C++</h1>
                
            
            
                
<p>While QML is a powerful and convenient way of using Qt 3D, sometimes you may have reasons to prefer C++ over QML. For example, if your project has a large C++ codebase or your team is not familiar with JavaScript, sticking with C++ might be the right solution. If you want to extend a Qt 3D class with your custom implementation, you'll have to use the C++ approach. Additionally, if you deal with large amounts of objects, processing them in C++ may be noticeably faster than doing that in QML. Qt allows you to choose between C++ and QML freely.</p>
<p>The QML API of Qt 3D for the most part consists of C++ classes exposed without many changes. That means that most of the code you've seen in this chapter so far can be transparently translated to the equivalent C++ code with minimal effort. When you elect not to use QML, you lose its property bindings, syntax sugar, and the ability to declare trees of objects that are automatically instantiated. However, as long as you're familiar with the core of Qt C++ API, you shouldn't have any issues. You'll have to create objects manually and assign parents to them. In place of property bindings, you'll have to connect to property change signals and perform the required updates manually. If you studied the earlier chapters of this book, you should have no problems with doing that.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Time for action – creating a 3D scene using C++</h1>
                
            
            
                
<p>Let's see how we can recreate our first Qt 3D scene using only C++ code. Our scene will contain a light source, a cube, and a first person camera controller. You can use the Qt Console Application template to create the project. Don't forget to enable the Qt 3D modules you want to use in the project file:</p>
<pre>QT += 3dextras<br/>CONFIG += c++11</pre>
<p>The first change compared to the QML approach is that you need to use the <kbd>Qt3DWindow</kbd> class instead of <kbd>Qt3DQuickWindow</kbd>. The <kbd>Qt3DWindow</kbd> class performs a few actions that are typically needed in a Qt 3D application. It sets up a <kbd>QForwardRenderer</kbd>, a camera, and initializes the <kbd>QInputSettings</kbd> object needed for processing events. You can access the default frame graph using the <kbd>defaultFrameGraph()</kbd> method. The default camera is available using the <kbd>camera()</kbd> method. The aspect ratio of the default camera is updated automatically according to the window size. If you want to set up a custom frame graph, use the <kbd>setActiveFrameGraph()</kbd> method.</p>
<p>All the code from our small example will be put into the <kbd>main()</kbd> function. Let's go through it piece by piece. First, we initialize the usual <kbd>QGuiApplication</kbd> object, create a <kbd>Qt3DWindow</kbd> object, and apply our preferred settings to its frame graph and camera:</p>
<pre>int main(int argc, char *argv[]) {<br/>    QGuiApplication app(argc, argv);<br/><br/>    Qt3DExtras::Qt3DWindow window;<br/>    window.defaultFrameGraph()-&gt;setClearColor(Qt::black);<br/><br/>    Qt3DRender::QCamera *camera = window.camera();<br/>    camera-&gt;lens()-&gt;setPerspectiveProjection(45.0f, 16.0f / 9.0f, 0.1f, 1000.0f);<br/>    camera-&gt;setPosition(QVector3D(0, 40.0f, -40.0f));<br/>    camera-&gt;setViewCenter(QVector3D(0, 0, 0));<br/>    //...<br/>}</pre>
<p>Next, we create a root entity object that will hold all our other entities and create a camera controller attached to the camera:</p>
<pre>Qt3DCore::QEntity *rootEntity = new Qt3DCore::QEntity();<br/>Qt3DExtras::QFirstPersonCameraController *cameraController =<br/>    new Qt3DExtras::QFirstPersonCameraController(rootEntity);<br/>cameraController-&gt;setCamera(camera);</pre>
<p>Next, we set up a light entity:</p>
<pre>Qt3DCore::QEntity *lightEntity = new Qt3DCore::QEntity(rootEntity);<br/>Qt3DRender::QDirectionalLight *lightComponent = new Qt3DRender::QDirectionalLight();<br/>lightComponent-&gt;setColor(Qt::white);<br/>lightComponent-&gt;setIntensity(0.5);<br/>lightComponent-&gt;setWorldDirection(QVector3D(0, -1, 0));<br/>lightEntity-&gt;addComponent(lightComponent);</pre>
<p>It's important that we pass the root entity to the <kbd>QEntity</kbd> constructor to ensure that the new entity will be a part of our scene. To add a component to the entity, we use the <kbd>addComponent()</kbd> function. The next step is to set up the cube 3D object:</p>
<pre>Qt3DCore::QEntity *cubeEntity = new Qt3DCore::QEntity(rootEntity);<br/>Qt3DExtras::QCuboidMesh *cubeMesh = new Qt3DExtras::QCuboidMesh();<br/>Qt3DExtras::QDiffuseSpecularMaterial *cubeMaterial =<br/>    new Qt3DExtras::QDiffuseSpecularMaterial();<br/>cubeMaterial-&gt;setAmbient(Qt::white);<br/>Qt3DCore::QTransform *cubeTransform = new Qt3DCore::QTransform();<br/>cubeTransform-&gt;setScale(10);<br/>cubeEntity-&gt;addComponent(cubeMesh);<br/>cubeEntity-&gt;addComponent(cubeMaterial);<br/>cubeEntity-&gt;addComponent(cubeTransform);</pre>
<p>As you can see, this code simply creates a few objects and sets their properties to the same values we used in our QML example. The final lines of code complete our setup:</p>
<pre>window.setRootEntity(rootEntity);<br/>window.show();<br/>return app.exec();</pre>
<p>We pass the root entity to the window and show it on screen. That's all! Qt 3D will render the constructed scene in the same way it worked in our QML project.</p>
<p>All properties of Qt 3D classes are equipped with change notification signals, so you can use connect statements to react to external changes properties. For example, if you use the <kbd>Qt3DInput::QAction</kbd> component to receive keyboard or mouse events, you can use its <kbd>activeChanged(bool isActive)</kbd> signal to get notifications about the event. You can also perform animations in the 3D scene using C++ animation classes such as <kbd>QPropertyAnimation</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Integration with Qt Widgets and Qt Quick</h1>
                
            
            
                
<p>While Qt 3D is a very powerful module, sometimes it's not enough to make a complete game or application. Other Qt modules such as Qt Quick or Qt Widgets can be very helpful, for example, when working on the user interface of your game. Luckily, Qt provides a few ways to use different modules together.</p>
<p>When it comes to Qt Widgets, your best bet is the <kbd>QWidget::createWindowContainer()<br/></kbd>function. It allows you to surround your 3D view with widgets and display them all in a single window. This approach was already discussed in <a href="15aa8ec3-9e80-4f68-8e0e-f365e860f5c5.xhtml" target="_blank">Chapter 9</a>, <em>OpenGL and Vulkan in Qt Applications</em>, and can be applied to Qt 3D without any changes.</p>
<p>However, the capabilities of Qt Widgets are still limited in the world of hardware-accelerated graphics. Qt Quick is much more promising in this area, and the synergy between QML APIs of Qt Quick and Qt 3D can prove to be very strong. Qt provides two ways to combine Qt Quick and Qt 3D in a single application without significant performance costs. Let's take a closer look at them.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Embedding Qt Quick UI into a 3D scene</h1>
                
            
            
                
<p>Qt 3D allows you to embed an arbitrary Qt Quick item into your 3D scene using the <kbd>Scene2D</kbd> type. How does that work? First, you need to put your Qt Quick content into a new <kbd>Scene2D</kbd> object. Next, you need to declare a texture that will be used as a render target for the form. Whenever Qt Quick decides to update its virtual view, the <kbd>Scene2D</kbd> object will render it directly to the specified texture. You only need to display this texture as you want. The most simple way of doing that is to pass it to a <kbd>TextureMaterial</kbd> component attached to one of your 3D objects. </p>
<p>However, this is only one part of the job. It's nice to allow users to see your form, but they should also be able to interact with it. This is also supported by <kbd>Scene2D</kbd>! To make it work, you need to do the following:</p>
<ol>
<li>Set <kbd>pickMethod</kbd> to <kbd>TrianglePicking</kbd> in the <kbd>RenderSettings</kbd>. This will allow object pickers to retrieve more accurate information about mouse events.</li>
<li>Attach an <kbd>ObjectPicker</kbd> component to all entities that use the texture created by <kbd>Scene2D</kbd>. It's a good idea to set the <kbd>hoverEnabled</kbd> and <kbd>dragEnabled</kbd> properties of the object picker to <kbd>true</kbd> to make mouse events work as expected.</li>
<li>Specify all these entities in the <kbd>entities</kbd> property of the <kbd>Scene2D</kbd> object.</li>
</ol>
<p>This will allow <kbd>Scene2D</kbd> to forward mouse events to the Qt Quick content. Unfortunately, forwarding keyboard events is not available yet.</p>
<p>Let's see an example of this approach:</p>
<pre>import Qt3D.Core 2.0<br/>import Qt3D.Render 2.0<br/>import Qt3D.Input 2.0<br/>import Qt3D.Extras 2.10<br/>import QtQuick 2.10<br/>import QtQuick.Scene2D 2.9<br/>import QtQuick.Controls 2.0<br/>import QtQuick.Layouts 1.0<br/>Entity {<br/>    components: [<br/>        RenderSettings {<br/>            activeFrameGraph: ForwardRenderer { /*...*/ }<br/>            pickingSettings.pickMethod: PickingSettings.TrianglePicking<br/>        },<br/>        InputSettings {}<br/>    ]<br/>    Scene2D {<br/>        output: RenderTargetOutput {<br/>            attachmentPoint: RenderTargetOutput.Color0<br/>            texture: Texture2D {<br/>                id: texture<br/>                width: 200<br/>                height: 200<br/>                format: Texture.RGBA8_UNorm<br/>            }<br/>        }<br/>        entities: [cube, plane]<br/>        Rectangle {<br/>            color: checkBox1.checked? "#ffa0a0" : "#a0a0ff"<br/>            width: texture.width<br/>            height: texture.height<br/>            ColumnLayout {<br/>                CheckBox {<br/>                    id: checkBox1<br/>                    text: "Toggle color"<br/>                }<br/>                CheckBox {<br/>                    id: checkBox2<br/>                    text: "Toggle cube"<br/>                }<br/>                CheckBox {<br/>                    id: checkBox3<br/>                    checked: true<br/>                    text: "Toggle plane"<br/>                }<br/>            }<br/>        }<br/>    }<br/>    //...<br/>}</pre>
<p>This code sets up a Qt 3D scene that contains a <kbd>Scene2D</kbd> object. <kbd>Scene2D</kbd> itself is not visible in the 3D scene. We declare a texture that will receive the rendered Qt Quick content. You can choose <kbd>width</kbd> and <kbd>height</kbd> of the texture depending on the size of the displayed content.</p>
<p>Next, we declare that we'll render this texture in two entities (we'll create them in the next piece of code). Finally, we place a Qt Quick item directly into the <kbd>Scene2D</kbd> object. Make sure you set this size for your Qt Quick item according to the size of the texture. In our example, we created a form containing three checkboxes in a layout.</p>
<p>The next part of code creates two items for displaying the Qt Quick-based texture:</p>
<pre>Entity {<br/>    id: cube<br/>    components: [<br/>        CuboidMesh {},<br/>        TextureMaterial {<br/>            texture: texture<br/>        },<br/>        Transform {<br/>            scale: 10<br/>            rotationY: checkBox2.checked ? 45 : 0<br/>        },<br/>        ObjectPicker {<br/>            hoverEnabled: true<br/>            dragEnabled: true<br/>        }<br/>    ]<br/>}<br/>Entity {<br/>    id: plane<br/>    components: [<br/>        PlaneMesh {<br/>            mirrored: true<br/>        },<br/>        TextureMaterial {<br/>            texture: texture<br/>        },<br/>        Transform {<br/>            translation: checkBox3.checked ? Qt.vector3d(-20, 0, 0) : Qt.vector3d(20, 0, 0)<br/>            scale: 10<br/>            rotationX: 90<br/>            rotationY: 180<br/>            rotationZ: 0<br/>        },<br/>        ObjectPicker {<br/>            hoverEnabled: true<br/>            dragEnabled: true<br/>        }<br/><br/>    ]<br/>}</pre>
<p>The first item is a cube, and the second item is a plane. Most of the properties are just arbitrary values that make the scene look good. The important part is that each item has a <kbd>TextureMaterial</kbd> component, and we passed the <kbd>texture</kbd> object into it. Each item also has an <kbd>ObjectPicker</kbd> component that allows the user to interact with the item. Note that we used the <kbd>mirrored</kbd> property of <kbd>PlaneMesh</kbd> to display the texture in its original (not mirrored) orientation.</p>
<p>One plane object is usually enough to display your form. We used two objects purely for demonstration purposes.</p>
<p>While Qt Quick items and Qt 3D entities live in different worlds and don't seem to interact with each other, they are still declared in a single QML file, so you can use property bindings and other QML techniques to make all these items work together. In our example, not only is the background color of the root Qt Quick item controlled by the checkbox, but the 3D objects are also influenced by checkboxes:</p>
<div><img src="img/46724776-f305-4da1-8269-01df5ad34e00.png" width="1032" height="794"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Embedding a Qt 3D scene into a Qt Quick form</h1>
                
            
            
                
<p>Now let's see how we can perform the opposite task. This approach is useful if your application is built mainly around Qt Quick. This means that you use the <kbd>QQmlApplicationEngine</kbd> class in the <kbd>main()</kbd> function, and the root object of your <kbd>main.qml</kbd> file is usually the <kbd>Window</kbd> object. It's very easy to extend your Qt Quick application with a bit of 3D action.</p>
<p>We could place all the code into the <kbd>main.qml</kbd> file, but it's more convenient to split it because setting up a 3D scene requires quite a bit of code. Let's say you have a file named <kbd>My3DScene.qml</kbd> that contains the usual content of a 3D scene:</p>
<pre>Entity {<br/>    components: [<br/>        RenderSettings {<br/>            activeFrameGraph: ForwardRenderer { /*...*/ },<br/>        InputSettings {}<br/>    ]<br/>    Entity { /*...*/ }<br/>    Entity { /*...*/ }<br/>    //...<br/>}</pre>
<p>To add this 3D scene into the <kbd>main.qml</kbd> file (or any other Qt Quick-based QML file), you should use the <kbd>Scene3D</kbd> QML type that can be imported from the <kbd>QtQuick.Scene3D</kbd> module. For example, this is how you can create a form with a button and a 3D view:</p>
<pre>import QtQuick 2.10<br/>import QtQuick.Layouts 1.0<br/>import QtQuick.Controls 1.0<br/>import QtQuick.Window 2.0<br/>import QtQuick.Scene3D 2.0<br/><br/>Window {<br/>    visible: true<br/>    Button {<br/>        id: button1<br/>        text: "button1"<br/>        anchors {<br/>            top: parent.top<br/>            left: parent.left<br/>            right: parent.right<br/>            margins: 10<br/>        }<br/>    }<br/>    <strong>Scene3D {</strong><br/>        focus: true<br/>        anchors {<br/>            top: button1.bottom<br/>            bottom: parent.bottom<br/>            left: parent.left<br/>            right: parent.right<br/>            margins: 10<br/>        }<br/><strong>        aspects: ["input", "logic"]</strong><br/><strong>        My3DScene {}</strong><br/><strong>    }</strong><br/>}</pre>
<p>Most of the code is the usual content of a Qt Quick form. The <kbd>Scene3D</kbd> item does all the magic. The root 3D entity should be added to this item directly or, as in our case, in the form of a custom component. The <kbd>Scene3D</kbd> item sets up a Qt 3D engine and renders the passed scene:</p>
<div><img src="img/403e934d-6ae3-423a-8e4c-aa4a8257b994.png" style="width:9.50em;height:10.50em;" width="168" height="186"/></div>
<p>If you want to use <kbd>Qt3DInput</kbd> or <kbd>Qt3DLogic</kbd> modules, you need to enable the corresponding 3D aspects using the <kbd>aspects</kbd> property of <kbd>Scene3D</kbd>, as shown in the screenshot. Additionally, the <kbd>multisample</kbd> Boolean property can be used to enable multisampling. The <kbd>hoverEnabled</kbd> property can be used to enable handling of mouse events when mouse buttons are not pressed.</p>
<p>Similar to <kbd>Qt3DQuickWindow</kbd>, <kbd>Scene3D</kbd> sets the camera's aspect ratio automatically by default. You can disable it by setting its <kbd>cameraAspectRatioMode</kbd> property to <kbd>Scene3D.UserAspectRatio</kbd>.</p>
<p>This approach can also be used to display some UI controls on top of the 3D view. This will allow you to use the full power of Qt Quick to make the UI of your game amazing.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Pop quiz</h1>
                
            
            
                
<p>Q1. Which component can be used to rotate a 3D object?</p>
<ol>
<li class="mce-root"><kbd>CuboidMesh</kbd></li>
<li class="mce-root"><kbd>RotationAnimation</kbd></li>
<li class="mce-root"><kbd>Transform</kbd></li>
</ol>
<p class="mce-root">Q2. Which component is the most suitable for emulating the light of the sun?</p>
<ol>
<li class="mce-root"><kbd>DirectionalLight</kbd></li>
<li class="mce-root"><kbd>PointLight</kbd></li>
<li class="mce-root"><kbd>SpotLight</kbd></li>
</ol>
<p class="mce-root">Q3. What is a Qt 3D material?</p>
<ol>
<li class="mce-root">An object that allows you to load a texture from a file.</li>
<li class="mce-root">A component that defines the physical properties of the object.</li>
<li class="mce-root">A component that defines the visible properties of the object's surface.</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned to create 3D games with Qt. We saw how to create and position 3D objects in the scene and configure the camera for rendering. Next, we examined how we can handle user input using Qt 3D. More than that, you learned to apply your existing animation skills to Qt 3D objects. Finally, we found out how to use Qt 3D together with other Qt modules.</p>
<p class="mce-root">Like Qt Quick, Qt 3D is rapidly evolving. At the time of writing, some of the modules are still experimental. You should expect the API of Qt 3D to be improved and extended, so make sure you check the Qt documentation for newer releases.</p>
<p>This concludes our book on game programming using Qt. We have taught you the general basics of Qt, described its widget realm to you, and introduced you to the fascinating world of Qt Quick and Qt 3D. Widgets (including Graphics View), Qt Quick, and Qt 3D are the main paths you can take when creating games using the Qt framework. We have also shown you ways of merging the two approaches by making use of any OpenGL or Vulkan skills you might have, going beyond what Qt already offers today. At this point, you should start playing around and experimenting, and if at any point you feel lost or simply lack the information on how to do something, the very helpful Qt reference manual should be the first resource you direct yourself to.</p>
<p>Good luck and have lots of fun!</p>


            

            
        
    </div>



  </body></html>