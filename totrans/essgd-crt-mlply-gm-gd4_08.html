<html><head></head><body>
		<div id="_idContainer088">
			<p><a id="_idTextAnchor161"/></p>
			<h1 class="chapter-number" id="_idParaDest-114"><a id="_idTextAnchor162"/>8</h1>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor163"/>Creating an Online Co-Op Platformer Prototype</h1>
			<p>In this chapter, we will delve deeper into the work of creating action multiplayer online games. Our goal is to turn a local multiplayer puzzle platformer game prototype into an <span class="No-Break">online version.</span></p>
			<p>Here’s what the final puzzle platformer prototype will <span class="No-Break">look like:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer076">
					<img alt="Figure 8.1 – A preview of the Puzzle Platformer prototype" src="image/Figure_08.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – A preview of the Puzzle Platformer prototype</p>
			<p>By the end of this chapter, you’ll know how to use the features of the <strong class="source-inline">MultiplayerSpawner</strong> node to create and assign playable characters to each player in the game, using the features offered by <strong class="source-inline">MultiplayerSynchronizer</strong> to sync relevant properties. With these features, we can go beyond updating the position of nodes; they will allow us to synchronize other properties, particularly animations. You will also learn how to leverage <strong class="bold">Remote Procedure Calls</strong> (<strong class="bold">RPCs</strong>) to manipulate the <strong class="bold">multiplayer authority</strong> of nodes. This will enable us to implement an exciting object-grabbing mechanic that will be a key element in <span class="No-Break">our prototype.</span></p>
			<h1 id="_idParaDest-116">T<a id="_idTextAnchor164"/>echnical requirements</h1>
			<p>To access the resources for this chapter, you can find our repository of online projects by following the link provided <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0"><span class="No-Break">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</span></a><span class="No-Break">.</span></p>
			<p>Once you have the repository, open the <strong class="source-inline">res://08.designing-online-platformer</strong> folder in the Godot Engine editor. All the necessary files for this chapter are <span class="No-Break">located there.</span></p>
			<p>Now, let’s begin the onboarding process. In the upcoming section, we will familiarize ourselves with the project, explore its main classes, and identify where we need to implement <span class="No-Break">networking features.</span></p>
			<h1 id="_idParaDest-117">I<a id="_idTextAnchor165"/>ntroducing the platformer project</h1>
			<p>Our <a id="_idIndexMarker257"/>project presents a captivating puzzle platformer that will test players’ strategic thinking and collaboration skills as they overcome challenging obstacles together. At the heart of this game lies a core mechanic centered around the manipulation of objects, utilizing them to construct platforms for the other player <span class="No-Break">to traverse.</span></p>
			<p>Now, let’s dive into the essential classes that serve as the pillars of our project’s foundation. Our first encounter will be with the <strong class="source-inline">Player</strong> class, which embodies the avatars controlled by each individual player. As the main protagonist, the <strong class="source-inline">Player</strong> class handles essential functionalities such as movement and interaction with various environmental elements. Notably, the <strong class="source-inline">Player</strong> class incorporates <strong class="source-inline">InteractionArea2D</strong> that detects contact with <strong class="source-inline">InteractiveArea2D</strong>, enabling players to perform specific actions <span class="No-Break">upon them.</span></p>
			<p>Moving forward, we encounter the <strong class="source-inline">InteractiveArea2D</strong> class. This class extends the functionality of the <strong class="source-inline">Area2D</strong> node and assumes the crucial role of a trigger area for detecting interactions. When <strong class="source-inline">InteractionArea2D</strong> overlaps with <strong class="source-inline">InteractiveArea2D</strong>, it becomes responsive to input events. Triggering the designated <em class="italic">interact</em> input action emits a signal, allowing us to create further engaging <span class="No-Break">gameplay interactions.</span></p>
			<p>In our game, the <strong class="source-inline">Crate</strong> class represents an interactive object that players can skillfully manipulate. Each <strong class="source-inline">Crate</strong> instance has an <strong class="source-inline">InteractiveArea2D</strong> node and a <strong class="source-inline">CharacterBody2D</strong> node, offering players the opportunity to collide with and leap onto them, which allows players to use them as viable platforms for navigating the level. These crates stand as major elements for puzzle-solving and advancing through the <span class="No-Break">game’s levels.</span></p>
			<p>Lastly, we encounter the versatile <strong class="source-inline">PlayerSpawner</strong> class, responsible for the dynamic spawning and management of players within the game. This class adeptly adapts to the number of participating players, seamlessly instantiating a <strong class="source-inline">Player</strong> instance for each individual. Additionally, in the realm of local multiplayer, the <strong class="source-inline">PlayerSpawner</strong> class ensures a smooth and immersive gaming experience by establishing distinct controls for each player and optimizing <span class="No-Break">gameplay</span><span class="No-Break"><a id="_idIndexMarker258"/></span><span class="No-Break"> customization.</span></p>
			<p>In the upcoming section, we will dive into the <strong class="source-inline">Player</strong> object, which is composed of a script and a scene. We are going to understand how the script works with the available nodes on the scene and structures the desired behavior for our local <span class="No-Break"><strong class="source-inline">Player</strong></span><span class="No-Break"> node.</span><a id="_idTextAnchor166"/></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor167"/>Understanding the Player class</h2>
			<p>The <strong class="source-inline">Player</strong> class and<a id="_idIndexMarker259"/> scene represent the player’s avatar in the game. It is through this scene and script that players interact with the game world. The scene is a <strong class="source-inline">CharacterBody2D</strong> node with a <strong class="source-inline">CollisionShape2D</strong> Resource, a <strong class="source-inline">Node2D</strong> node called <strong class="source-inline">Sprites</strong>, which we use to group and pivot an <strong class="source-inline">AnimatedSprite2D</strong> node, and an <strong class="source-inline">InteractionArea2D</strong> node, which we are going to talk about in the <em class="italic">How the InteractiveArea2D class works</em> section. The <strong class="source-inline">InteractionArea2D</strong> node also has a <strong class="source-inline">CollisionShape2D</strong> Resource and a <strong class="source-inline">RemoteTransformer2D</strong> node, which we call <strong class="source-inline">GrabberRemoteTransformer2D</strong>. A <strong class="source-inline">RemoteTransformer2D</strong> node allows us to remotely sync the position, rotation, and scale of a node that is outside the hierarchy of the <strong class="source-inline">RemoteTransformer2D</strong>’s parent as if it were a sibling of the <strong class="source-inline">RemoteTransformer2D</strong>, which is very useful. In this case, we use the <strong class="source-inline">GrabberRemoteTransformer2D</strong> node to remotely transform the objects the player can grab, such as the <em class="italic">crate</em>, which we will talk about in the <em class="italic">Unveiling the Crate class</em> section. Finally, the <strong class="source-inline">Player</strong> class also has a <strong class="source-inline">Label</strong> node that we use to visually communicate the player controlling <span class="No-Break">the avatar.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer077">
					<img alt="Figure 8.2 – The Player’s scene node hierarchy" src="image/Figure_8.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The Player’s scene node hierarchy</p>
			<p>Now, let’s look at the <a id="_idIndexMarker260"/>script itself. There are some aspects that we won’t delve into in this section because they are more related to the basic platformer game player movement, and our focus here is on the online multiplayer aspect, so we would go beyond our scope. But the important part for your job is to know that when two players are playing locally, the <strong class="source-inline">Player</strong> node can set up its controllers dynamically so each player controls only one avatar. And this is something you’ll have to make work in the online version of the prototype: how each player will control only their own avatar. For reference, the following code snippet does <span class="No-Break">this locally:</span></p>
			<pre class="source-code">
func setup_controller(index):
    for action in InputMap.get_actions():
        var new_action = action + "%s" % index
        InputMap.add_action(new_action)
        for event in InputMap.action_get_events(action):
            var new_event = event.duplicate()
            new_event.device = index
            InputMap.action_add_event(new_action, event)
        for property in get_property_list():
            if not typeof(get(property.name)) ==
                TYPE_STRING:
                continue
            if get(property.name) == action:
                set(property.name, new_action)</pre>			<p>The preceding code<a id="_idIndexMarker261"/> iterates over actions in <strong class="source-inline">InputMap</strong> singleton and creates new actions specific to a given controller device, using an index. It also updates the events and properties associated with the actions to be specific to the given device. The purpose of this code is to set up controller mappings for different players or devices in a game, allowing customization and differentiation of <span class="No-Break">input controls.</span></p>
			<p>In the next section, let’s see how the <em class="italic">Crate</em> scene works, it’s a pretty simple scene that essentially works as a passive object that players can use as a platform to move around <span class="No-Break">the leve<a id="_idTextAnchor168"/>l.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor169"/>Unveiling the Crate class</h2>
			<p>The <strong class="source-inline">Crate</strong> scene<a id="_idIndexMarker262"/> plays a crucial role in our game prototype. It represents interactive objects that players can skillfully manipulate to overcome obstacles and progress through the levels. Each instance of the <strong class="source-inline">Crate</strong> scene is a <strong class="source-inline">Node2D</strong> equipped with two important components: <strong class="source-inline">InteractiveArea2D</strong> node and <span class="No-Break"><strong class="source-inline">CharacterBody2D</strong></span><span class="No-Break"> node.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer078">
					<img alt="Figure 8.3 – The Crate’s scene node hierarchy" src="image/Figure_8.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – The Crate’s scene node hierarchy</p>
			<p>The <strong class="source-inline">CharacterBody2D</strong> node represents the physical body of the <em class="italic">Crate</em> node within the game’s physics simulation. It ensures that the crates collide with the player’s avatar or other objects. The <strong class="source-inline">CharacterBody2D</strong> node handles the collision detection and response, allowing the player to seamlessly jump on and stand on the crate as if it were a <span class="No-Break">solid platform.</span></p>
			<p>As for <strong class="source-inline">InteractiveArea2D</strong> node, it is a special <strong class="source-inline">Area2D</strong> node that detects when <strong class="source-inline">InteractiveArea2D</strong> nodes overlap with it. In the context of the <strong class="source-inline">Crate</strong> class, the <strong class="source-inline">InteractiveArea2D</strong> node allows players to grab and lift the <em class="italic">Crate</em> nodes if they press the <strong class="source-inline">interact</strong> action while their <strong class="source-inline">InteractionArea2D</strong> node overlaps with the <em class="italic">Crate</em>’s <strong class="source-inline">InteractionArea2D</strong> node. This interaction enables players to use the <em class="italic">Crate</em> nodes as sturdy platforms to navigate the level since they will be able to move them around and jump on them even when another player is grabbing them. <strong class="source-inline">InteractiveArea2D</strong> node acts <a id="_idIndexMarker263"/>as a trigger, detecting when the player’s avatar comes into contact with the <strong class="source-inline">Crate</strong> node and assigning the <strong class="source-inline">Crate</strong> node to the player’s avatar <strong class="source-inline">GrabbingRemoteTransform2D</strong> node, synchronizing its position with the player even when they <span class="No-Break">are moving.</span></p>
			<p>The <strong class="source-inline">Crate</strong> script is fairly simple and structures how the <strong class="source-inline">Crate</strong> node responds and updates to interactions with the <span class="No-Break"><strong class="source-inline">Player</strong></span><span class="No-Break"> node:</span></p>
			<pre class="source-code">
extends Node2D
@onready var body = $CharacterBody2D
@onready var shape = $CharacterBody2D/CollisionShape2D
@onready var interactive_area = $CharacterBody2D/
    InteractiveArea2D
var lift_transformer = null
func _on_interactive_area_2d_area_entered(area):
    lift_transformer = area.get_node
        ("GrabbingRemoteTransform2D")
func _on_interactive_area_2d_interacted():
    lift_transformer.remote_path =
        lift_transformer.get_path_to(body)</pre>			<p>The preceding code sets up references to nodes in the <strong class="source-inline">Crate</strong>’s scene hierarchy. It also defines two callback functions that handle signals from the <strong class="source-inline">Crate</strong> node’s <strong class="source-inline">InteractiveArea2D</strong> node. When an <strong class="source-inline">InteractionArea2D</strong> node enters the <strong class="source-inline">Crate</strong> node’s <strong class="source-inline">InteractiveArea2D</strong> node, we presume it is the <strong class="source-inline">Player</strong> node interacting and we retrieve the <strong class="source-inline">Player</strong> node’s <strong class="source-inline">"GrabbingRemoteTransform2D"</strong> node, assigning it to the <span class="No-Break"><strong class="source-inline">lift_transformer</strong></span><span class="No-Break"> variable.</span></p>
			<p>When an interaction<a id="_idIndexMarker264"/> happens, the code assigns the <strong class="source-inline">lift_transformer.remote_path</strong> node to the path from <strong class="source-inline">lift_transformer</strong> variable to the <strong class="source-inline">Crate</strong> node’s body. Remember, <strong class="source-inline">lift_transformer</strong> variable is a <strong class="source-inline">RemoteTransform2D</strong> node. This is how we allow the <strong class="source-inline">Player</strong> node’s <strong class="source-inline">GrabbingRemoteTransform2D</strong> node to remotely transform the <strong class="source-inline">Crate</strong> node’s <strong class="source-inline">CharacterBody2D</strong> <span class="No-Break">Node position.</span></p>
			<p>In the next section, we will understand how <strong class="source-inline">InteractiveArea2D</strong> node detects players’ interactions with the <em class="italic">Crate</em> node and its role in <span class="No-Break">our g<a id="_idTextAnchor170"/>ame.</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor171"/>How the InteractiveArea2D class works</h2>
			<p>In this<a id="_idIndexMarker265"/> section, we’ll understand the role of a major scene that lies at the heart of our game’s mechanics. Called <strong class="source-inline">InteractiveArea2D</strong> node, this scene plays a fundamental role in detecting and enabling player interactions with various objects in the game environment. <strong class="source-inline">InteractiveArea2D</strong> node enables us to turn any object into an object the player can interact with. For example, in our prototype, we use <strong class="source-inline">InteractiveArea2D</strong> node to allow the player to grab a <strong class="source-inline">Crate</strong> node and move <span class="No-Break">it around.</span></p>
			<p>The <strong class="source-inline">InteractiveArea2D</strong> scene, built upon the foundation of the <strong class="source-inline">Area2D</strong> node, serves as a fundamental component in our game. Its primary function is to detect and ease player interactions with objects, particularly within the player-crate interaction mechanic. Through the use of signals and input handling, the <strong class="source-inline">InteractiveArea2D</strong> scene ensures smooth <span class="No-Break">gameplay interactions.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer079">
					<img alt="Figure 8.4 – The InteractiveArea2D’s scene node hierarchy" src="image/Figure_8.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – The InteractiveArea2D’s scene node hierarchy</p>
			<p>One of the standout features of our game is the player-<strong class="source-inline">Crate</strong> node interaction mechanism, offering players the ability to manipulate interactive objects. The <strong class="source-inline">InteractiveArea2D</strong> scene serves as the catalyst for this interaction, acting as the gateway through which players can engage with the objects that populate the <span class="No-Break">game world.</span></p>
			<p>Using <a id="_idIndexMarker266"/>signals, the <strong class="source-inline">InteractiveArea2D</strong> scene establishes communication channels with other game objects and systems. Whenever a player successfully interacts with an object, <strong class="source-inline">InteractiveArea2D</strong> node emits the <strong class="source-inline">interacted</strong> signal. On top of that, the scene emits signals to indicate the availability or unavailability of interactions, allowing us to provide visual and auditory feedback <span class="No-Break">to players.</span></p>
			<p>To detect player input, the <strong class="source-inline">InteractiveArea2D</strong> scene uses an <strong class="source-inline">_unhandled_input</strong> callback. When players press the designated <strong class="source-inline">interact</strong> input action, it triggers the <strong class="source-inline">interacted</strong> signal, signaling that an interaction has occurred. This control scheme allows the players to interact with the <span class="No-Break">game world.</span></p>
			<p>Understanding the role of the <strong class="source-inline">InteractiveArea2D</strong> scene and its seamless integration with the player-<strong class="source-inline">Crate</strong> node interaction system is key. Now, it’s time to dive into the code and unleash the full potential of this vital scene in <span class="No-Break">our game:</span></p>
			<pre class="source-code">
class_name InteractiveArea2D
extends Area2D
signal interacted
signal interaction_available
signal interaction_unavailable
@export var interact_input_action = "interact"
func _ready():
    set_process_unhandled_input(false)
func _unhandled_input(event):
    if event.is_action_pressed(interact_input_action):
        interacted.emit()
        get_viewport().set_input_as_handled()
func _on_area_entered(_area):
    set_process_unhandled_input(true)
    interaction_available.emit()
func _on_area_exited(_area):
    set_process_unhandled_input(false)
    interaction_unavailable.emit()</pre>			<p>The <strong class="source-inline">InteractiveArea2D</strong> script<a id="_idIndexMarker267"/> extends <strong class="source-inline">Area2D</strong> node and provides interaction functionality. It emits signals when an interaction occurs, when an interaction becomes available, and when an interaction becomes unavailable. It also handles unhandled input events to <span class="No-Break">trigger interactions.</span></p>
			<p>In the upcoming section and the final part of the onboarding, we will see how we create and insert <strong class="source-inline">Player</strong> instances in the game world dynamically based on how many players <span class="No-Break">are pl<a id="_idTextAnchor172"/>aying.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor173"/>Understanding the PlayerSpawner class</h2>
			<p><strong class="source-inline">PlayerSpawner</strong> scene<a id="_idIndexMarker268"/> is another vital component in our game that handles the creation and positioning of <strong class="source-inline">Player</strong> instances. The <strong class="source-inline">PlayerSpawner</strong> class, based on the <strong class="source-inline">Marker2D</strong> node, follows the <strong class="source-inline">Spawner</strong> pattern, enabling us to dynamically generate <strong class="source-inline">Player</strong> instances in the <span class="No-Break">game world.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer080">
					<img alt="Figure 8.5 – The PlayerSpawner’s scene node hierarchy" src="image/Figure_8.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – The PlayerSpawner’s scene node hierarchy</p>
			<p>One of the key features of the <strong class="source-inline">PlayerSpawner</strong> class is its ability to position the spawned <strong class="source-inline">Player</strong> instances. As a <strong class="source-inline">Marker2D</strong> node, <strong class="source-inline">PlayerSpawner</strong> node provides a convenient way to specify the location and orientation of the players within the game world. This ensures that each player starts in the appropriate position, ready to embark on <span class="No-Break">their adventure.</span></p>
			<p>Let’s see its code to understand what this class does under <span class="No-Break">the hood:</span></p>
			<pre class="source-code">
extends Marker2D
@export var players_scene = preload("res://08.designing-
    online-platformer/Actors/Player/Player2D.tscn")
func _ready():
    if Input.get_connected_joypads().size() &lt; 1:
        var player = players_scene.instantiate()
        add_child(player)
        return
    for i in Input.get_connected_joypads():
        var player = players_scene.instantiate()
        add_child(player)
        player.setup_controller(i)</pre>			<p>The preceding script showcases the implementation of a <strong class="source-inline">Spawner</strong> class, based on the <strong class="source-inline">Marker2D</strong> node. It checks for connected joypads and creates instances of the <strong class="source-inline">Player</strong> scene accordingly. If no joypads are connected, it creates a single instance. If there are connected joypads, it creates one <strong class="source-inline">Player</strong> instance per joypad and sets up their respective controls. The preceding code snippet allows for the dynamic creation of <strong class="source-inline">Player</strong> instances in a<a id="_idIndexMarker269"/> multiplayer game, easing our work developing a <span class="No-Break">multiplayer experience.</span></p>
			<p>We are finally done with our onboarding; in the next section, we’ll start to implement our online multiplayer features, turning our local prototype into something we can securely work with and polish knowing it’s ready to launch with remote <span class="No-Break">multiplayer fe<a id="_idTextAnchor174"/>atures.</span></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor175"/>Spawning players in the match</h1>
			<p>In this section, we <a id="_idIndexMarker270"/>will understand how to improve the <strong class="source-inline">PlayerSpawner</strong> class to introduce online multiplayer features to our game. Leveraging the foundation laid by the <em class="italic">Understanding the PlayerSpawner class</em>, <em class="italic">Unveiling the Crate class</em>, and the <em class="italic">Understanding the Player class</em> sections, these enhancements enable multiple players to connect and interact seamlessly within a synchronized <span class="No-Break">game environment.</span></p>
			<p><strong class="source-inline">PlayerSpawner</strong> node plays a fundamental role in our game’s multiplayer architecture, acting as the core mechanism responsible for dynamically creating instances of the <strong class="source-inline">Player</strong> class for each connected player. These instances represent the avatars through which players engage with the <span class="No-Break">game world.</span></p>
			<p>With the integration of multiplayer functionalities, we will add features designed for an online multiplayer experience. This includes mechanisms to handle multiplayer authority, enabling proper gameplay across all connected peers. On top of that, the code will establish unique player names using the peers’ IDs, allowing us to easily identify players on the network. To ensure synchronized actions, we will use RPCs, which will allow us to share events and actions among all connected players, especially the instantiation of <span class="No-Break">other players.</span></p>
			<p>One<a id="_idIndexMarker271"/> fundamental concept we are going to introduce here is the <strong class="source-inline">MultiplayerSpawner</strong> node. In the Godot Engine 4 High-Level Network API, the <strong class="source-inline">MultiplayerSpawner</strong> node is an invaluable asset for creating synced scenes in a networked multiplayer setting. In our context, it is a core component in synchronizing the creation of players, ensuring that every player can see and interact with the avatars of other players in <span class="No-Break">real time.</span></p>
			<p>With the <strong class="source-inline">MultiplayerSpawner</strong> node, we can effortlessly instantiate and position player avatars across all connected game instances. So to start with, let’s open the <strong class="source-inline">PlayerSpawner</strong> scene at <strong class="source-inline">res://08.designing-online-platformer/Levels/PlayerSpawner.tscn</strong> and add a <strong class="source-inline">MultiplayerSpawner</strong> node as <span class="No-Break">its child.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer081">
					<img alt="Figure 8.6 – A MultiplayerSpawner node as a child of the PlayerSpawner node" src="image/Figure_8.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – A MultiplayerSpawner node as a child of the PlayerSpawner node</p>
			<p>After that, we need to configure the <strong class="source-inline">MultiplayerSpawner</strong> node’s <strong class="bold">Spawn Path</strong> and <strong class="bold">Auto Spawn List</strong> properties. The first property should point to <strong class="source-inline">PlayerSpawner</strong>. This tells <strong class="source-inline">MultiplayerSpawner</strong> who should be the spawned scenes’ parent. Then, the second property should point to the same <strong class="source-inline">PackedScene</strong> Resource our <strong class="source-inline">PlayerSpawner</strong> node spawns. This will ensure that, when a new instance is created locally, <strong class="source-inline">MultiplayerSpawner</strong> node will replicate it on <span class="No-Break">connected peers.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer082">
					<img alt="Figure 8.7 – The MultiplayerSpawner’s Spawn Path and Auto Spawn List properties set up" src="image/Figure_8.07_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – The MultiplayerSpawner’s Spawn Path and Auto Spawn List properties set up</p>
			<p>With that, our <strong class="source-inline">MultiplayerSpawner</strong> node is ready to sync new players on everyone’s game<a id="_idIndexMarker272"/> instances. But we still need to configure these new instances, otherwise, only the server will be able to control them. So, let’s see how we can empower players with the ability to control their own avatars. Open the <strong class="source-inline">PlayerSpawner</strong> script at <strong class="source-inline">res://08.designing-online-platformer/Levels/PlayerSpawner.gd</strong>. In the next section, we will make some changes to <span class="No-Break">this<a id="_idTextAnchor176"/> script.</span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor177"/>Giving players control in PlayerSpawner</h2>
			<p>The new <strong class="source-inline">PlayerSpawner</strong> code introduces changes that enhance the multiplayer functionality<a id="_idIndexMarker273"/> of the game. Specifically, this code includes mechanisms to handle multiplayer synchronization and sets up <strong class="source-inline">Player</strong> instances correctly when multiple peers are connected. The changes involve checking for multiplayer authority, setting player names, and using RPCs to set up multiplayer functionality for each connected player. Let’s implement <span class="No-Break">these features:</span></p>
			<ol>
				<li>Add <strong class="source-inline">await(get_tree().create_timer(0.1).timeout)</strong> at the beginning of the <strong class="source-inline">_ready()</strong> callback. This line introduces a delay of 0.1 seconds using a timer, allowing time for the multiplayer networking initialization <span class="No-Break">to complete:</span><pre class="source-code">
func _ready():
    await(get_tree().create_timer(0.1).timeout)</pre></li>				<li>Then, let’s check whether there are connected peers by checking for the size of the <strong class="source-inline">multiplayer.get_peers()</strong> array. With that, we can check whether there are any connected peers in the multiplayer session. This condition verifies whether this is a local <span class="No-Break">game session:</span><pre class="source-code">
func _ready():
    await(get_tree().create_timer(0.1).timeout)
    if multiplayer.get_peers().size() &lt; 1:</pre></li>				<li>If this is the<a id="_idIndexMarker274"/> case, we use the original logic we <a id="_idTextAnchor178"/>saw in the <em class="italic">Understanding the Player class</em> section to set up the local players’ avatars’ controllers. With a small twist, we use the <strong class="source-inline">return</strong> keyword at the end to prevent <strong class="source-inline">_ready()</strong> from reaching the next steps, which are only necessary if this is an online <span class="No-Break">game session:</span><pre class="source-code">
func _ready():
    await(get_tree().create_timer(0.1).timeout)
    if multiplayer.get_peers().size() &lt; 1:
        if Input.get_connected_joypads().size() &lt; 1:
            var player = players_scene.instantiate()
            add_child(player)
            return
        for i in Input.get_connected_joypads():
            var player = players_scene.instantiate()
            add_child(player)
            player.setup_controller(i)
        return</pre></li>				<li>Then, if this is an online game session, we check whether this game instance is the multiplayer authority (in other words, the server), and if so, we enter a loop that iterates over the <span class="No-Break">connected peers:</span><pre class="source-code">
    if is_multiplayer_authority():
            for i in range(0, multiplayer.get_peers().
                size()):</pre></li>				<li>Similar to<a id="_idIndexMarker275"/> the local session logic, we create a <strong class="source-inline">Player</strong> instance for each <span class="No-Break">connected player:</span><pre class="source-code">
    if is_multiplayer_authority():
            for i in range(0, multiplayer.get_peers().
                size()):
                var player = players_scene.
                    instantiate()</pre></li>				<li>Here’s the catch: after creating the <strong class="source-inline">Player</strong> instance, we set its name to the player’s peer ID. Only then do we add it as a child of the <strong class="source-inline">PlayerSpawner</strong> node. This ensures each <strong class="source-inline">Player</strong> instance has a unique name and will prevent the RPCs and <strong class="source-inline">MultiplayerSpawner</strong> node from <span class="No-Break">returning errors:</span><pre class="source-code">
if is_multiplayer_authority():
        for i in range(0, multiplayer.get_peers().
            size()):
            var player = players_scene.instantiate()
            var player_id = multiplayer.get_peers()[i]
            player.name = str(player_id)
            add_child(player)</pre></li>				<li>Then, we add another timer delay of <strong class="source-inline">0.1</strong> seconds. This delay gives time for peers’ game instances to synchronize their <span class="No-Break">multiplayer setup:</span><pre class="source-code">
if is_multiplayer_authority():
        for i in range(0, multiplayer.get_peers().
            size()):
            var player = players_scene.instantiate()
            var player_id = multiplayer.get_peers()[i]
            player.name = str(player_id)
            add_child(player)
            await(get_tree().create_timer(0.1).
                timeout)</pre></li>				<li>Finally, we <a id="_idIndexMarker276"/>make an RPC to the <strong class="source-inline">Player.setup_multiplayer()</strong> method passing <strong class="source-inline">player_id</strong> as an argument. <strong class="source-inline">Player.setup_multiplayer()</strong> is responsible for configuring the player’s <em class="italic">multiplayer authority</em> based on the player ID, ultimately allowing this player, and only this player, to control this instance. We will implement this method in the <em class="italic">Setting up the Player multiplayer </em><span class="No-Break"><em class="italic">controls</em></span><span class="No-Break"> section:</span><pre class="source-code">
if is_multiplayer_authority():
        for i in range(0, multiplayer.get_peers().
            size()):
            var player = players_scene.instantiate()
            var player_id = multiplayer.get_peers()[i]
            player.name = str(player_id)
            add_child(player)
            await(get_tree().create_timer(0.1).
                timeout)
            player.rpc("setup_multiplayer", player_id)</pre></li>			</ol>
			<p>We aren’t done yet. We still need to set up the multiplayer features on other players’ avatar instances when <strong class="source-inline">MultiplayerSpawner</strong> node creates them. For that, let’s connect the <strong class="source-inline">MultiplayerSpawner </strong>node’ <strong class="source-inline">spawned</strong> signal to the <strong class="source-inline">PlayerSpawner</strong> node using a method <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">_on_multiplayer_spawner_spawned</strong></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer083">
					<img alt="Figure 8.8 – The MultiplayerSpawner spawned signal connecting to the PlayerSpawner _on_multiplayer_spawner_spawned callback" src="image/Figure_8.08_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – The MultiplayerSpawner spawned signal connecting to the PlayerSpawner _on_multiplayer_spawner_spawned callback</p>
			<p>Then, we make <a id="_idIndexMarker277"/>an RPC on the spawned node’s <strong class="source-inline">setup_multiplayer</strong> method using the node’s name as an argument. Since the name is a <strong class="source-inline">StringName</strong> variable, we need to convert it to a string and then to an integer in order for the <strong class="source-inline">Player</strong> class to handle it. The complete <strong class="source-inline">PlayerSpawner</strong> script should look like this after <span class="No-Break">these changes:</span></p>
			<pre class="source-code">
extends Marker2D
@export var players_scene = preload("res://08.designing-
    online-platformer/Actors/Player/Player2D.tscn")
func _ready():
    await(get_tree().create_timer(0.1).timeout)
    if multiplayer.get_peers().size() &lt; 1:
        if Input.get_connected_joypads().size() &lt; 1:
            var player = players_scene.instantiate()
            add_child(player)
            return
        for i in Input.get_connected_joypads():
            var player = players_scene.instantiate()
            add_child(player)
            player.setup_controller(i)
        return
    if is_multiplayer_authority():
        for i in range(0, multiplayer.get_peers().size()):
            var player = players_scene.instantiate()
            var player_id = multiplayer.get_peers()[i]
            player.name = str(player_id)
            add_child(player)
            await(get_tree().create_timer(0.1).timeout)
            player.rpc("setup_multiplayer", player_id)
func _on_multiplayer_spawner_spawned(node):
    node.rpc("setup_multiplayer", int(str(node.name)))</pre>			<p>The updated <a id="_idIndexMarker278"/>script incorporates multiplayer functionality by creating <strong class="source-inline">Player</strong> instances for each player in the network. It checks for the presence of connected joypads and multiplayer peers to determine the appropriate number of <strong class="source-inline">Player</strong> instances to create. The code also sets up the <strong class="source-inline">Player</strong> instances’ controls and synchronizes their multiplayer settings. With these changes, <strong class="source-inline">PlayerSpawner</strong> node now enables multiplayer gameplay, allowing multiple players to control their avatars and interact within the game world simultaneously with no <span class="No-Break">control conflicts.</span></p>
			<p>In the upcoming section, we will explore the implementation of the <strong class="source-inline">Player.setup_multiplayer()</strong> method, which is responsible for configuring online multiplayer <a id="_idIndexMarker279"/>settings in the <strong class="source-inline">Player</strong> class. Within the <strong class="source-inline">setup_multiplayer()</strong> method, we set the multiplayer authority, disable the physics and input processing based on the local player’s authority over the instance, and set a visual player index label updated with which player is controlling<a id="_idTextAnchor179"/> <span class="No-Break">the instance.</span></p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor180"/>Setting up the Player multiplayer controls</h2>
			<p>In this section, let’s <a id="_idIndexMarker280"/>see how to implement the <strong class="source-inline">Player.setup_multiplayer()</strong> method, which plays a core role in setting up the online multiplayer controls for the <span class="No-Break"><strong class="source-inline">Player</strong></span><span class="No-Break"> class.</span></p>
			<p>Within the <strong class="source-inline">setup_multiplayer()</strong> method, we need to take some key steps to achieve our online multiplayer controls. Firstly, we need to establish the new multiplayer authority, verifying the player’s control and decision-making capabilities within the multiplayer environment. Then, we will adjust the physics and input processing based on whether the player ID matches the player ID we designated using the node’s name. This ensures that each player controls the right <span class="No-Break"><strong class="source-inline">Player</strong></span><span class="No-Break"> instance.</span></p>
			<p>On top of that, the method updates a visual player index label, allowing players to see their assigned avatar. This visual feedback enhances the multiplayer experience by providing a clear indication of each player’s identity and presence in <span class="No-Break">the game.</span></p>
			<p>By implementing the <strong class="source-inline">setup_multiplayer()</strong> method, the game achieves synchronized multiplayer functionality, creating a cohesive and immersive multiplayer experience. Players can interact and collaborate with one another, encouraging a sense of shared adventure and enjoyment within the <span class="No-Break">game world.</span></p>
			<p>That said, let’s dive into the code and unlock the potential of our multiplayer gameplay on our prototype! Open the <strong class="source-inline">Player</strong> script at <strong class="source-inline">res://08.designing-online-platformer/Actors/Player/Player2D.gd</strong> and let’s implement the <strong class="source-inline">setup_multiplayer()</strong> method to finally allow players to control <span class="No-Break">their avatars:</span></p>
			<ol>
				<li>In the <strong class="source-inline">Player</strong> script, create a new method called <strong class="source-inline">setup_multiplayer()</strong>. It should receive an argument to get the player’s ID; here, we’ll call <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">player_id</strong></span><span class="No-Break">:</span><pre class="source-code">
func setup_multiplayer(player_id):</pre></li>				<li>Then, decorate<a id="_idIndexMarker281"/> the method with the <strong class="source-inline">@rpc</strong> annotation, using the <strong class="source-inline">"any_peer"</strong> and <strong class="source-inline">"call_local"</strong> options. This specifies that the method can be called by any peer and executed locally. So, when players spawn their avatars, they tell the other peers to set up their avatars, setting up the avatar instance locally <span class="No-Break">as well:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):</pre></li>				<li>Inside the <strong class="source-inline">setup_multiplayer()</strong> method, let’s call <strong class="source-inline">set_multiplayer_authority()</strong> passing <strong class="source-inline">player_id</strong> as an argument to set the new multiplayer authority of this <strong class="source-inline">Player</strong> instance. Remember, the multiplayer authority determines the peer’s control and decision-making capabilities over a <span class="No-Break">given node:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):
    set_multiplayer_authority(player_id)</pre></li>				<li>Then, let’s create a variable to store whether <strong class="source-inline">player_id</strong> is equal to the <strong class="source-inline">Player</strong> instance name. With that, we check whether the current avatar is supposed to be controlled by the <span class="No-Break">local player:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):
    set_multiplayer_authority(player_id)
    var is_player = str(player_id) == str(name)</pre></li>				<li>After that, we set the physics and unhandled input processes based on the value of the <strong class="source-inline">is_player</strong> variable. With that, we disable the physics processing and the input handling on the <strong class="source-inline">Player</strong> instances that don’t belong to the <span class="No-Break">local player:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):
    set_multiplayer_authority(player_id)
    var is_player = str(player_id) == str(name)
    set_physics_process(is_player)
    set_process_unhandled_input(is_player)</pre></li>				<li>Finally, we<a id="_idIndexMarker282"/> update the text of the <strong class="source-inline">label</strong> node to display the player index. Here, <strong class="source-inline">%s</strong> is a placeholder that is replaced with the value returned by <strong class="source-inline">get_index()</strong>, representing the player’s index in the <strong class="source-inline">PlayerSpawner</strong> children hierarchy (remember the first node is <strong class="source-inline">MultiplayerSpawner</strong>) so the player indexing starts <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):
    set_multiplayer_authority(player_id)
    var is_player = str(player_id) == str(name)
    set_physics_process(is_player)
    set_process_unhandled_input(is_player)
    label.text = "P%s" % get_index()</pre></li>			</ol>
			<p>With that, we have our <strong class="source-inline">Player</strong> instance ready to behave in an online multiplayer environment. The <strong class="source-inline">setup_multiplayer()</strong> method configures the multiplayer features in the <strong class="source-inline">Player</strong> instances. It sets the multiplayer authority, adjusts physics processing and input handling based on the local player ID, and updates a label with the <span class="No-Break">player’s index.</span></p>
			<p>But notice, since we are disabling physics and input processing, technically the other players’ avatars will remain static during the whole gameplay session, right? Each player will only control and see their own character moving around and we don’t want that. We want players to interact<a id="_idIndexMarker283"/> with each other and see how other players are behaving within this <span class="No-Break">shared experience.</span></p>
			<p>In the next section, we are going to use <strong class="source-inline">MultiplayerSynchronizer</strong> node to keep all other players on the same page regarding each other’s avatar, including going beyond just the avatar’s position, but also its animation and more. We will also see how we handle the <strong class="source-inline">Crate</strong> node: since players can grab and carry it around, who should have control over it? Who should be the <strong class="source-inline">Crate</strong> node’s <span class="No-Break"><strong class="bold">Mult<a id="_idTextAnchor181"/>iplayer Authority</strong></span><span class="No-Break">?</span></p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor182"/>Syncing physical objects</h1>
			<p>In this section, we <a id="_idIndexMarker284"/>will understand how to use the <strong class="source-inline">MultiplayerSynchronizer</strong> node for more than position updates. This node plays an important role in ensuring that players are synchronized with the avatars of other players in the game. As we have seen in the <em class="italic">Giving players control in PlayerSpawner</em> section, it is essential to maintain consistency among players to create a seamless <span class="No-Break">multiplayer experience.</span></p>
			<p>The <strong class="source-inline">MultiplayerSynchronizer</strong> class serves as a bridge between players, enabling real-time updates and synchronization of various properties. One key aspect that we will explore is how the <strong class="source-inline">Crate</strong> object’s position is updated based on the player who is carrying it. This functionality allows for interactive and collaborative gameplay, where players can work together to solve puzzles or <span class="No-Break">accomplish tasks.</span></p>
			<p>On top of that, we will see how the <strong class="source-inline">MultiplayerSynchronizer</strong> node handles properties related to avatar animations. By leveraging the <strong class="source-inline">MultiplayerSynchronizer</strong> class, we can ensure that all players observe the same animation state of other players’ avatars, enabling a visually <span class="No-Break">consistent experience.</span></p>
			<p>Through the usage of the <strong class="source-inline">MultiplayerSynchronizer</strong> node, we can establish a robust framework for synchronizing player actions, avatar positions, and animations. This synchronization ensures that all players perceive a cohesive and immersive multiplayer environment, fostering collaboration and enhancing the overall <span class="No-Break">gameplay experience.</span></p>
			<p>Let’s explore the implementation details <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Multi<a id="_idTextAnchor183"/>playerSynchronizer</strong></span><span class="No-Break">!</span></p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor184"/>Synchronizing the player’s position and animations</h2>
			<p>Our <strong class="source-inline">Player</strong> scene <a id="_idIndexMarker285"/>has some nodes responsible for playing animations based on the player’s actions and the current state of the avatar, namely the <strong class="source-inline">Sprites</strong> and <strong class="source-inline">AnimatedSprite2D</strong> nodes. It is important to synchronize the <strong class="source-inline">Sprites</strong> nodes’ scale and the <strong class="source-inline">AnimatedSprite</strong> animation and frame since players’ avatars would look rather weird if they jump, run, and stay idle and there’s no visual feedback updating the performance of such actions in the game world other than the avatar’s position changing. So, in this section, let’s ensure that on top of the position, other relevant properties are also synced among players. For that, let’s open the <strong class="source-inline">Player</strong> scene at <strong class="source-inline">res://08.designing-online-platformer/Actors/Player/Player2D.tscn</strong> and, of course, add <strong class="source-inline">MultiplayerSynchronizer</strong> as its child. With that, we will perform the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>First of all, we <a id="_idIndexMarker286"/>need to change the <strong class="source-inline">MultiplayerSynchronizer</strong>’s <strong class="bold">Visibility Update Mode</strong> to <strong class="bold">Physics</strong> so it syncs the physics simulations on remote peers’ <span class="No-Break">game instances.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer084">
					<img alt="Figure 8.9 – The player’s MultiplayerSynchronizer properties" src="image/Figure_8.09_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – The player’s MultiplayerSynchronizer properties</p>
			<ol>
				<li value="2">After that, in the <strong class="bold">Replication</strong> dock, we are going to add the <strong class="source-inline">PlayerCharacter2D</strong> node’s <strong class="bold">Position</strong> properties, the <strong class="source-inline">AnimatedSprite2D</strong> node’s <strong class="bold">Animation</strong> and <strong class="bold">Frame</strong> properties, and the <strong class="source-inline">Sprite</strong> nodes’ <strong class="bold">Scale</strong> properties. This will ensure that <strong class="source-inline">MultiplayerSynchronizer</strong> node also synchronizes the animation-related properties, allowing the players to see what their peers’ avatars <span class="No-Break">are doing.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer085">
					<img alt="Figure 8.10 – The MultiplayerSynchronizer’s Replication properties" src="image/Figure_8.10_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – The MultiplayerSynchronizer’s Replication properties</p>
			<p>And that’s it! With <a id="_idIndexMarker287"/>that, our players are ready to interact within a shared game world. The <strong class="source-inline">MultiplayerSynchronizer</strong> node is an incredible ally to have in our toolbelt when developing online multiplayer games. As we can see in this section, those node allows for the synchronization of a range of different properties that can help us make our online gameplay experience enjoyable. There’s a small, though very important observation to make in this regard. As we’ve seen throughout this book, especially in <em class="italic">Part 1</em>, we can’t pass objects around, and we should avoid heavy data transmission through the network. So, keep that in mind when adding properties to the <strong class="source-inline">MultiplayerSynchronizer</strong> node’s <strong class="bold">Replication</strong> menu. For instance, if you try to sync a <strong class="bold">Texture</strong> property, you are likely to fail <span class="No-Break">the replication.</span></p>
			<p>That said, in the next section, we are going to use <strong class="source-inline">MultiplayerSynchronizer</strong> node to sync the <strong class="source-inline">Crate</strong> node’s position property, but there’s a twist. Since any player can grab a <strong class="source-inline">Crate</strong> node and move it around, who should be its <strong class="bold">Multiplayer Authority</strong>? Well, that’s what <a id="_idTextAnchor185"/>we are about <span class="No-Break">to see!</span></p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor186"/>Updating the crate’s position remotely</h2>
			<p>At this point, we <a id="_idIndexMarker288"/>are fairly familiar with how <strong class="source-inline">MultiplayerSynchronizer</strong> node works and the overall concept of a node’s multiplayer authority, right? One of the core mechanics in our online multiplayer puzzle platformer game is the ability for players to collaborate by taking objects and using them as platforms to progress through the <span class="No-Break">levels’ obstacles.</span></p>
			<p>In this section, we are going to see how we can dynamically change an object’s multiplayer authority based on which player is currently interacting with it so that only that player can change<a id="_idIndexMarker289"/> the object’s properties. Open the <strong class="source-inline">Crate</strong> scene at <strong class="source-inline">res://08.designing-online-platformer/Objects/Crate/Crate.tscn</strong>, and add a new <strong class="source-inline">MultiplayerSynchronizer</strong> node as its child. Then, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Just like in the <strong class="source-inline">Player</strong> scene, we need to change the <strong class="source-inline">MultiplayerSynchronizer</strong> node’s <strong class="bold">Visibility Update Mode</strong> to <strong class="bold">Physics</strong> to maintain the physics <span class="No-Break">simulations consistently.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer086">
					<img alt="Figure 8.11 – The crate’s MultiplerSynchronizer properties" src="image/Figure_8.11_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – The crate’s MultiplerSynchronizer properties</p>
			<ol>
				<li value="2">Then, in the <strong class="bold">Replication</strong> menu, we are going to add the <strong class="source-inline">CharacterBody2D</strong> node’s <strong class="bold">Position</strong> property to <span class="No-Break">the syncing.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer087">
					<img alt="Figure 8.12 – The crate’s CharacterBody2D position property in the Replication menu" src="image/Figure_8.12_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – The crate’s CharacterBody2D position property in the Replication menu</p>
			<p>With that, believe it <a id="_idIndexMarker290"/>or not, we already have what we need to sync the crate’s position. Currently, the crate does not have any built-in behavior to move on its own, as its position is expected to be altered by the players who interact with it. To enable this functionality, we will make some additions to the <strong class="source-inline">Crate</strong> script. To get started, let’s open the script file <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">res://08.designing-online-platformer/Objects/Crate/Crate.gd</strong></span><span class="No-Break">.</span></p>
			<p>In the <strong class="source-inline">_on_interactive_area_2d_area_entered()</strong> method, we need to change the crate’s multiplayer authority to match the player it’s interacting with. For that, we can call the <strong class="source-inline">set_multiplayer_authority()</strong> method passing the area’s multiplayer authority. This area that just entered is the player’s <strong class="source-inline">InteractionArea2D</strong> node, so its multiplayer authority is the same as that of <span class="No-Break">the player’s:</span></p>
			<pre class="source-code">
func _on_interactive_area_2d_area_entered(area):
    lift_transformer = area.get_node
        ("GrabbingRemoteTransform2D")
    set_multiplayer_authority
        (area.get_multiplayer_authority())</pre>			<p>With that, whenever the <a id="_idIndexMarker291"/>player’s avatar enters the crate’s <strong class="source-inline">InteractiveArea2D</strong> node, the player will become the crate’s multiplayer authority and will be able to grab it and change its position once they interact with it. With this addition, we are ready to witness the seamless synchronization of the crate’s position as players interact with it. You can test the prototype to explore the possibilities of collaborative gameplay and enjoy the immersive multiplayer experience we have <span class="No-Break">just created!</span></p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor187"/>Summary</h1>
			<p>In this chapter, we dived into the world of online multiplayer puzzle platformers, which emphasized teamwork and collaboration. Players will be challenged to work together, leveraging their skills to overcome obstacles and progress through intricate levels. Throughout the chapter, we explored key concepts and techniques to enhance the multiplayer experience and create a seamless collaborative <span class="No-Break">gameplay environment.</span></p>
			<p>To enable multiplayer functionality, we introduced the <strong class="source-inline">MultiplayerSpawner</strong> class, which dynamically instantiates <strong class="source-inline">Player</strong> instances based on the number of connected players. This ensures that each player has a unique avatar in the game, promoting a personalized and immersive multiplayer experience. The <strong class="source-inline">Player</strong> class played a crucial role, and we implemented the <strong class="source-inline">setup_multiplayer()</strong> method to configure its multiplayer settings. This method allowed us to set each instance’s multiplayer authority, adjust physics and input processing, and update a visual player index label, providing players with a clear identification in <span class="No-Break">the game.</span></p>
			<p>To achieve synchronization between players, we harnessed the power of <strong class="source-inline">MultiplayerSynchronizer</strong> node. This powerful tool enabled us to synchronize not only the positions of players but also their animations. By incorporating <strong class="source-inline">MultiplayerSynchronizer</strong> node, we created a visually captivating multiplayer experience where players moved and interacted with the game world in perfect harmony. This synchronization brought the multiplayer gameplay to life, enhancing immersion and ensuring a cohesive and enjoyable <span class="No-Break">shared experience.</span></p>
			<p>An exciting feature we implemented was the ability for players to grab and manipulate the <strong class="source-inline">Crate</strong> object. By dynamically changing the crate’s multiplayer authority, we ensured that only the player interacting with the crate had control over its movements. This added an extra layer of collaboration and puzzle-solving, as players can strategically use the crate as a platform to navigate the levels, fostering teamwork <span class="No-Break">and coordination.</span></p>
			<p>To sum up, this chapter provided a solid foundation for understanding and implementing multiplayer features using the Godot Engine High-level Network API. By combining the concepts and techniques explored, we created an online multiplayer puzzle platformer prototype, where players can seamlessly collaborate, synchronize their actions, and conquer challenges together. This chapter opened doors to endless possibilities in future multiplayer game development endeavors, empowering you to create engaging and interactive <span class="No-Break">multiplayer experiences.</span></p>
			<p>In the next chapter, we’ll leverage all the knowledge we’ve seen so far in <em class="italic">Part 2</em> of this book to create a multiplayer online adventure with a persistent section system where players can log in and out and maintain their progress. The players will also synchronize the server’s world with their game instance world, which also means they will be able to see all the other players that are currently playing as well and interact with one another. It’s fundamentally a prototype that you can expand to a <strong class="bold">Massive Multiplayer Online Role Playing Game</strong> (<strong class="bold">MMORPG</strong>) if <span class="No-Break">you want.</span></p>
		</div>
	</body></html>