<html><head></head><body>
		<div><p><a id="_idTextAnchor161"/></p>
			<h1 class="chapter-number" id="_idParaDest-114"><a id="_idTextAnchor162"/>8</h1>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor163"/>Creating an Online Co-Op Platformer Prototype</h1>
			<p>In this chapter, we will delve deeper into the work of creating action multiplayer online games. Our goal is to turn a local multiplayer puzzle platformer game prototype into an online version.</p>
			<p>Here’s what the final puzzle platformer prototype will look like:</p>
			<div><div><img alt="Figure 8.1 – A preview of the Puzzle Platformer prototype" src="img/Figure_08.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – A preview of the Puzzle Platformer prototype</p>
			<p>By the end of this chapter, you’ll know how to use the features of the <code>MultiplayerSpawner</code> node to create and assign playable characters to each player in the game, using the features offered by <code>MultiplayerSynchronizer</code> to sync relevant properties. With these features, we can go beyond updating the position of nodes; they will allow us to synchronize other properties, particularly animations. You will also learn how to leverage <strong class="bold">Remote Procedure Calls</strong> (<strong class="bold">RPCs</strong>) to manipulate the <strong class="bold">multiplayer authority</strong> of nodes. This will enable us to implement an exciting object-grabbing mechanic that will be a key element in our prototype.</p>
			<h1 id="_idParaDest-116">T<a id="_idTextAnchor164"/>echnical requirements</h1>
			<p>To access the resources for this chapter, you can find our repository of online projects by following the link provided here: <a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</a>.</p>
			<p>Once you have the repository, open the <code>res://08.designing-online-platformer</code> folder in the Godot Engine editor. All the necessary files for this chapter are located there.</p>
			<p>Now, let’s begin the onboarding process. In the upcoming section, we will familiarize ourselves with the project, explore its main classes, and identify where we need to implement networking features.</p>
			<h1 id="_idParaDest-117">I<a id="_idTextAnchor165"/>ntroducing the platformer project</h1>
			<p>Our <a id="_idIndexMarker257"/>project presents a captivating puzzle platformer that will test players’ strategic thinking and collaboration skills as they overcome challenging obstacles together. At the heart of this game lies a core mechanic centered around the manipulation of objects, utilizing them to construct platforms for the other player to traverse.</p>
			<p>Now, let’s dive into the essential classes that serve as the pillars of our project’s foundation. Our first encounter will be with the <code>Player</code> class, which embodies the avatars controlled by each individual player. As the main protagonist, the <code>Player</code> class handles essential functionalities such as movement and interaction with various environmental elements. Notably, the <code>Player</code> class incorporates <code>InteractionArea2D</code> that detects contact with <code>InteractiveArea2D</code>, enabling players to perform specific actions upon them.</p>
			<p>Moving forward, we encounter the <code>InteractiveArea2D</code> class. This class extends the functionality of the <code>Area2D</code> node and assumes the crucial role of a trigger area for detecting interactions. When <code>InteractionArea2D</code> overlaps with <code>InteractiveArea2D</code>, it becomes responsive to input events. Triggering the designated <em class="italic">interact</em> input action emits a signal, allowing us to create further engaging gameplay interactions.</p>
			<p>In our game, the <code>Crate</code> class represents an interactive object that players can skillfully manipulate. Each <code>Crate</code> instance has an <code>InteractiveArea2D</code> node and a <code>CharacterBody2D</code> node, offering players the opportunity to collide with and leap onto them, which allows players to use them as viable platforms for navigating the level. These crates stand as major elements for puzzle-solving and advancing through the game’s levels.</p>
			<p>Lastly, we encounter the versatile <code>PlayerSpawner</code> class, responsible for the dynamic spawning and management of players within the game. This class adeptly adapts to the number of participating players, seamlessly instantiating a <code>Player</code> instance for each individual. Additionally, in the realm of local multiplayer, the <code>PlayerSpawner</code> class ensures a smooth and immersive gaming experience by establishing distinct controls for each player and optimizing gameplay<a id="_idIndexMarker258"/> customization.</p>
			<p>In the upcoming section, we will dive into the <code>Player</code> object, which is composed of a script and a scene. We are going to understand how the script works with the available nodes on the scene and structures the desired behavior for our local <code>Player</code> node.<a id="_idTextAnchor166"/></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor167"/>Understanding the Player class</h2>
			<p>The <code>Player</code> class and<a id="_idIndexMarker259"/> scene represent the player’s avatar in the game. It is through this scene and script that players interact with the game world. The scene is a <code>CharacterBody2D</code> node with a <code>CollisionShape2D</code> Resource, a <code>Node2D</code> node called <code>Sprites</code>, which we use to group and pivot an <code>AnimatedSprite2D</code> node, and an <code>InteractionArea2D</code> node, which we are going to talk about in the <em class="italic">How the InteractiveArea2D class works</em> section. The <code>InteractionArea2D</code> node also has a <code>CollisionShape2D</code> Resource and a <code>RemoteTransformer2D</code> node, which we call <code>GrabberRemoteTransformer2D</code>. A <code>RemoteTransformer2D</code> node allows us to remotely sync the position, rotation, and scale of a node that is outside the hierarchy of the <code>RemoteTransformer2D</code>’s parent as if it were a sibling of the <code>RemoteTransformer2D</code>, which is very useful. In this case, we use the <code>GrabberRemoteTransformer2D</code> node to remotely transform the objects the player can grab, such as the <em class="italic">crate</em>, which we will talk about in the <em class="italic">Unveiling the Crate class</em> section. Finally, the <code>Player</code> class also has a <code>Label</code> node that we use to visually communicate the player controlling the avatar.</p>
			<div><div><img alt="Figure 8.2 – The Player’s scene node hierarchy" src="img/Figure_8.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The Player’s scene node hierarchy</p>
			<p>Now, let’s look at the <a id="_idIndexMarker260"/>script itself. There are some aspects that we won’t delve into in this section because they are more related to the basic platformer game player movement, and our focus here is on the online multiplayer aspect, so we would go beyond our scope. But the important part for your job is to know that when two players are playing locally, the <code>Player</code> node can set up its controllers dynamically so each player controls only one avatar. And this is something you’ll have to make work in the online version of the prototype: how each player will control only their own avatar. For reference, the following code snippet does this locally:</p>
			<pre class="source-code">
func setup_controller(index):
    for action in InputMap.get_actions():
        var new_action = action + "%s" % index
        InputMap.add_action(new_action)
        for event in InputMap.action_get_events(action):
            var new_event = event.duplicate()
            new_event.device = index
            InputMap.action_add_event(new_action, event)
        for property in get_property_list():
            if not typeof(get(property.name)) ==
                TYPE_STRING:
                continue
            if get(property.name) == action:
                set(property.name, new_action)</pre>			<p>The preceding code<a id="_idIndexMarker261"/> iterates over actions in <code>InputMap</code> singleton and creates new actions specific to a given controller device, using an index. It also updates the events and properties associated with the actions to be specific to the given device. The purpose of this code is to set up controller mappings for different players or devices in a game, allowing customization and differentiation of input controls.</p>
			<p>In the next section, let’s see how the <em class="italic">Crate</em> scene works, it’s a pretty simple scene that essentially works as a passive object that players can use as a platform to move around the leve<a id="_idTextAnchor168"/>l.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor169"/>Unveiling the Crate class</h2>
			<p>The <code>Crate</code> scene<a id="_idIndexMarker262"/> plays a crucial role in our game prototype. It represents interactive objects that players can skillfully manipulate to overcome obstacles and progress through the levels. Each instance of the <code>Crate</code> scene is a <code>Node2D</code> equipped with two important components: <code>InteractiveArea2D</code> node and <code>CharacterBody2D</code> node.</p>
			<div><div><img alt="Figure 8.3 – The Crate’s scene node hierarchy" src="img/Figure_8.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – The Crate’s scene node hierarchy</p>
			<p>The <code>CharacterBody2D</code> node represents the physical body of the <em class="italic">Crate</em> node within the game’s physics simulation. It ensures that the crates collide with the player’s avatar or other objects. The <code>CharacterBody2D</code> node handles the collision detection and response, allowing the player to seamlessly jump on and stand on the crate as if it were a solid platform.</p>
			<p>As for <code>InteractiveArea2D</code> node, it is a special <code>Area2D</code> node that detects when <code>InteractiveArea2D</code> nodes overlap with it. In the context of the <code>Crate</code> class, the <code>InteractiveArea2D</code> node allows players to grab and lift the <em class="italic">Crate</em> nodes if they press the <code>interact</code> action while their <code>InteractionArea2D</code> node overlaps with the <em class="italic">Crate</em>’s <code>InteractionArea2D</code> node. This interaction enables players to use the <em class="italic">Crate</em> nodes as sturdy platforms to navigate the level since they will be able to move them around and jump on them even when another player is grabbing them. <code>InteractiveArea2D</code> node acts <a id="_idIndexMarker263"/>as a trigger, detecting when the player’s avatar comes into contact with the <code>Crate</code> node and assigning the <code>Crate</code> node to the player’s avatar <code>GrabbingRemoteTransform2D</code> node, synchronizing its position with the player even when they are moving.</p>
			<p>The <code>Crate</code> script is fairly simple and structures how the <code>Crate</code> node responds and updates to interactions with the <code>Player</code> node:</p>
			<pre class="source-code">
extends Node2D
@onready var body = $CharacterBody2D
@onready var shape = $CharacterBody2D/CollisionShape2D
@onready var interactive_area = $CharacterBody2D/
    InteractiveArea2D
var lift_transformer = null
func _on_interactive_area_2d_area_entered(area):
    lift_transformer = area.get_node
        ("GrabbingRemoteTransform2D")
func _on_interactive_area_2d_interacted():
    lift_transformer.remote_path =
        lift_transformer.get_path_to(body)</pre>			<p>The preceding code sets up references to nodes in the <code>Crate</code>’s scene hierarchy. It also defines two callback functions that handle signals from the <code>Crate</code> node’s <code>InteractiveArea2D</code> node. When an <code>InteractionArea2D</code> node enters the <code>Crate</code> node’s <code>InteractiveArea2D</code> node, we presume it is the <code>Player</code> node interacting and we retrieve the <code>Player</code> node’s <code>"GrabbingRemoteTransform2D"</code> node, assigning it to the <code>lift_transformer</code> variable.</p>
			<p>When an interaction<a id="_idIndexMarker264"/> happens, the code assigns the <code>lift_transformer.remote_path</code> node to the path from <code>lift_transformer</code> variable to the <code>Crate</code> node’s body. Remember, <code>lift_transformer</code> variable is a <code>RemoteTransform2D</code> node. This is how we allow the <code>Player</code> node’s <code>GrabbingRemoteTransform2D</code> node to remotely transform the <code>Crate</code> node’s <code>CharacterBody2D</code> Node position.</p>
			<p>In the next section, we will understand how <code>InteractiveArea2D</code> node detects players’ interactions with the <em class="italic">Crate</em> node and its role in our g<a id="_idTextAnchor170"/>ame.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor171"/>How the InteractiveArea2D class works</h2>
			<p>In this<a id="_idIndexMarker265"/> section, we’ll understand the role of a major scene that lies at the heart of our game’s mechanics. Called <code>InteractiveArea2D</code> node, this scene plays a fundamental role in detecting and enabling player interactions with various objects in the game environment. <code>InteractiveArea2D</code> node enables us to turn any object into an object the player can interact with. For example, in our prototype, we use <code>InteractiveArea2D</code> node to allow the player to grab a <code>Crate</code> node and move it around.</p>
			<p>The <code>InteractiveArea2D</code> scene, built upon the foundation of the <code>Area2D</code> node, serves as a fundamental component in our game. Its primary function is to detect and ease player interactions with objects, particularly within the player-crate interaction mechanic. Through the use of signals and input handling, the <code>InteractiveArea2D</code> scene ensures smooth gameplay interactions.</p>
			<div><div><img alt="Figure 8.4 – The InteractiveArea2D’s scene node hierarchy" src="img/Figure_8.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – The InteractiveArea2D’s scene node hierarchy</p>
			<p>One of the standout features of our game is the player-<code>Crate</code> node interaction mechanism, offering players the ability to manipulate interactive objects. The <code>InteractiveArea2D</code> scene serves as the catalyst for this interaction, acting as the gateway through which players can engage with the objects that populate the game world.</p>
			<p>Using <a id="_idIndexMarker266"/>signals, the <code>InteractiveArea2D</code> scene establishes communication channels with other game objects and systems. Whenever a player successfully interacts with an object, <code>InteractiveArea2D</code> node emits the <code>interacted</code> signal. On top of that, the scene emits signals to indicate the availability or unavailability of interactions, allowing us to provide visual and auditory feedback to players.</p>
			<p>To detect player input, the <code>InteractiveArea2D</code> scene uses an <code>_unhandled_input</code> callback. When players press the designated <code>interact</code> input action, it triggers the <code>interacted</code> signal, signaling that an interaction has occurred. This control scheme allows the players to interact with the game world.</p>
			<p>Understanding the role of the <code>InteractiveArea2D</code> scene and its seamless integration with the player-<code>Crate</code> node interaction system is key. Now, it’s time to dive into the code and unleash the full potential of this vital scene in our game:</p>
			<pre class="source-code">
class_name InteractiveArea2D
extends Area2D
signal interacted
signal interaction_available
signal interaction_unavailable
@export var interact_input_action = "interact"
func _ready():
    set_process_unhandled_input(false)
func _unhandled_input(event):
    if event.is_action_pressed(interact_input_action):
        interacted.emit()
        get_viewport().set_input_as_handled()
func _on_area_entered(_area):
    set_process_unhandled_input(true)
    interaction_available.emit()
func _on_area_exited(_area):
    set_process_unhandled_input(false)
    interaction_unavailable.emit()</pre>			<p>The <code>InteractiveArea2D</code> script<a id="_idIndexMarker267"/> extends <code>Area2D</code> node and provides interaction functionality. It emits signals when an interaction occurs, when an interaction becomes available, and when an interaction becomes unavailable. It also handles unhandled input events to trigger interactions.</p>
			<p>In the upcoming section and the final part of the onboarding, we will see how we create and insert <code>Player</code> instances in the game world dynamically based on how many players are pl<a id="_idTextAnchor172"/>aying.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor173"/>Understanding the PlayerSpawner class</h2>
			<p><code>PlayerSpawner</code> scene<a id="_idIndexMarker268"/> is another vital component in our game that handles the creation and positioning of <code>Player</code> instances. The <code>PlayerSpawner</code> class, based on the <code>Marker2D</code> node, follows the <code>Spawner</code> pattern, enabling us to dynamically generate <code>Player</code> instances in the game world.</p>
			<div><div><img alt="Figure 8.5 – The PlayerSpawner’s scene node hierarchy" src="img/Figure_8.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – The PlayerSpawner’s scene node hierarchy</p>
			<p>One of the key features of the <code>PlayerSpawner</code> class is its ability to position the spawned <code>Player</code> instances. As a <code>Marker2D</code> node, <code>PlayerSpawner</code> node provides a convenient way to specify the location and orientation of the players within the game world. This ensures that each player starts in the appropriate position, ready to embark on their adventure.</p>
			<p>Let’s see its code to understand what this class does under the hood:</p>
			<pre class="source-code">
extends Marker2D
@export var players_scene = preload("res://08.designing-
    online-platformer/Actors/Player/Player2D.tscn")
func _ready():
    if Input.get_connected_joypads().size() &lt; 1:
        var player = players_scene.instantiate()
        add_child(player)
        return
    for i in Input.get_connected_joypads():
        var player = players_scene.instantiate()
        add_child(player)
        player.setup_controller(i)</pre>			<p>The preceding script showcases the implementation of a <code>Spawner</code> class, based on the <code>Marker2D</code> node. It checks for connected joypads and creates instances of the <code>Player</code> scene accordingly. If no joypads are connected, it creates a single instance. If there are connected joypads, it creates one <code>Player</code> instance per joypad and sets up their respective controls. The preceding code snippet allows for the dynamic creation of <code>Player</code> instances in a<a id="_idIndexMarker269"/> multiplayer game, easing our work developing a multiplayer experience.</p>
			<p>We are finally done with our onboarding; in the next section, we’ll start to implement our online multiplayer features, turning our local prototype into something we can securely work with and polish knowing it’s ready to launch with remote multiplayer fe<a id="_idTextAnchor174"/>atures.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor175"/>Spawning players in the match</h1>
			<p>In this section, we <a id="_idIndexMarker270"/>will understand how to improve the <code>PlayerSpawner</code> class to introduce online multiplayer features to our game. Leveraging the foundation laid by the <em class="italic">Understanding the PlayerSpawner class</em>, <em class="italic">Unveiling the Crate class</em>, and the <em class="italic">Understanding the Player class</em> sections, these enhancements enable multiple players to connect and interact seamlessly within a synchronized game environment.</p>
			<p><code>PlayerSpawner</code> node plays a fundamental role in our game’s multiplayer architecture, acting as the core mechanism responsible for dynamically creating instances of the <code>Player</code> class for each connected player. These instances represent the avatars through which players engage with the game world.</p>
			<p>With the integration of multiplayer functionalities, we will add features designed for an online multiplayer experience. This includes mechanisms to handle multiplayer authority, enabling proper gameplay across all connected peers. On top of that, the code will establish unique player names using the peers’ IDs, allowing us to easily identify players on the network. To ensure synchronized actions, we will use RPCs, which will allow us to share events and actions among all connected players, especially the instantiation of other players.</p>
			<p>One<a id="_idIndexMarker271"/> fundamental concept we are going to introduce here is the <code>MultiplayerSpawner</code> node. In the Godot Engine 4 High-Level Network API, the <code>MultiplayerSpawner</code> node is an invaluable asset for creating synced scenes in a networked multiplayer setting. In our context, it is a core component in synchronizing the creation of players, ensuring that every player can see and interact with the avatars of other players in real time.</p>
			<p>With the <code>MultiplayerSpawner</code> node, we can effortlessly instantiate and position player avatars across all connected game instances. So to start with, let’s open the <code>PlayerSpawner</code> scene at <code>res://08.designing-online-platformer/Levels/PlayerSpawner.tscn</code> and add a <code>MultiplayerSpawner</code> node as its child.</p>
			<div><div><img alt="Figure 8.6 – A MultiplayerSpawner node as a child of the PlayerSpawner node" src="img/Figure_8.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – A MultiplayerSpawner node as a child of the PlayerSpawner node</p>
			<p>After that, we need to configure the <code>MultiplayerSpawner</code> node’s <code>PlayerSpawner</code>. This tells <code>MultiplayerSpawner</code> who should be the spawned scenes’ parent. Then, the second property should point to the same <code>PackedScene</code> Resource our <code>PlayerSpawner</code> node spawns. This will ensure that, when a new instance is created locally, <code>MultiplayerSpawner</code> node will replicate it on connected peers.</p>
			<div><div><img alt="Figure 8.7 – The MultiplayerSpawner’s Spawn Path and Auto Spawn List properties set up" src="img/Figure_8.07_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – The MultiplayerSpawner’s Spawn Path and Auto Spawn List properties set up</p>
			<p>With that, our <code>MultiplayerSpawner</code> node is ready to sync new players on everyone’s game<a id="_idIndexMarker272"/> instances. But we still need to configure these new instances, otherwise, only the server will be able to control them. So, let’s see how we can empower players with the ability to control their own avatars. Open the <code>PlayerSpawner</code> script at <code>res://08.designing-online-platformer/Levels/PlayerSpawner.gd</code>. In the next section, we will make some changes to this<a id="_idTextAnchor176"/> script.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor177"/>Giving players control in PlayerSpawner</h2>
			<p>The new <code>PlayerSpawner</code> code introduces changes that enhance the multiplayer functionality<a id="_idIndexMarker273"/> of the game. Specifically, this code includes mechanisms to handle multiplayer synchronization and sets up <code>Player</code> instances correctly when multiple peers are connected. The changes involve checking for multiplayer authority, setting player names, and using RPCs to set up multiplayer functionality for each connected player. Let’s implement these features:</p>
			<ol>
				<li>Add <code>await(get_tree().create_timer(0.1).timeout)</code> at the beginning of the <code>_ready()</code> callback. This line introduces a delay of 0.1 seconds using a timer, allowing time for the multiplayer networking initialization to complete:<pre class="source-code">
func _ready():
    await(get_tree().create_timer(0.1).timeout)</pre></li>				<li>Then, let’s check whether there are connected peers by checking for the size of the <code>multiplayer.get_peers()</code> array. With that, we can check whether there are any connected peers in the multiplayer session. This condition verifies whether this is a local game session:<pre class="source-code">
func _ready():
    await(get_tree().create_timer(0.1).timeout)
    if multiplayer.get_peers().size() &lt; 1:</pre></li>				<li>If this is the<a id="_idIndexMarker274"/> case, we use the original logic we <a id="_idTextAnchor178"/>saw in the <em class="italic">Understanding the Player class</em> section to set up the local players’ avatars’ controllers. With a small twist, we use the <code>return</code> keyword at the end to prevent <code>_ready()</code> from reaching the next steps, which are only necessary if this is an online game session:<pre class="source-code">
func _ready():
    await(get_tree().create_timer(0.1).timeout)
    if multiplayer.get_peers().size() &lt; 1:
        if Input.get_connected_joypads().size() &lt; 1:
            var player = players_scene.instantiate()
            add_child(player)
            return
        for i in Input.get_connected_joypads():
            var player = players_scene.instantiate()
            add_child(player)
            player.setup_controller(i)
        return</pre></li>				<li>Then, if this is an online game session, we check whether this game instance is the multiplayer authority (in other words, the server), and if so, we enter a loop that iterates over the connected peers:<pre class="source-code">
    if is_multiplayer_authority():
            for i in range(0, multiplayer.get_peers().
                size()):</pre></li>				<li>Similar to<a id="_idIndexMarker275"/> the local session logic, we create a <code>Player</code> instance for each connected player:<pre class="source-code">
    if is_multiplayer_authority():
            for i in range(0, multiplayer.get_peers().
                size()):
                var player = players_scene.
                    instantiate()</pre></li>				<li>Here’s the catch: after creating the <code>Player</code> instance, we set its name to the player’s peer ID. Only then do we add it as a child of the <code>PlayerSpawner</code> node. This ensures each <code>Player</code> instance has a unique name and will prevent the RPCs and <code>MultiplayerSpawner</code> node from returning errors:<pre class="source-code">
if is_multiplayer_authority():
        for i in range(0, multiplayer.get_peers().
            size()):
            var player = players_scene.instantiate()
            var player_id = multiplayer.get_peers()[i]
            player.name = str(player_id)
            add_child(player)</pre></li>				<li>Then, we add another timer delay of <code>0.1</code> seconds. This delay gives time for peers’ game instances to synchronize their multiplayer setup:<pre class="source-code">
if is_multiplayer_authority():
        for i in range(0, multiplayer.get_peers().
            size()):
            var player = players_scene.instantiate()
            var player_id = multiplayer.get_peers()[i]
            player.name = str(player_id)
            add_child(player)
            await(get_tree().create_timer(0.1).
                timeout)</pre></li>				<li>Finally, we <a id="_idIndexMarker276"/>make an RPC to the <code>Player.setup_multiplayer()</code> method passing <code>player_id</code> as an argument. <code>Player.setup_multiplayer()</code> is responsible for configuring the player’s <em class="italic">multiplayer authority</em> based on the player ID, ultimately allowing this player, and only this player, to control this instance. We will implement this method in the <em class="italic">Setting up the Player multiplayer </em><em class="italic">controls</em> section:<pre class="source-code">
if is_multiplayer_authority():
        for i in range(0, multiplayer.get_peers().
            size()):
            var player = players_scene.instantiate()
            var player_id = multiplayer.get_peers()[i]
            player.name = str(player_id)
            add_child(player)
            await(get_tree().create_timer(0.1).
                timeout)
            player.rpc("setup_multiplayer", player_id)</pre></li>			</ol>
			<p>We aren’t done yet. We still need to set up the multiplayer features on other players’ avatar instances when <code>MultiplayerSpawner</code> node creates them. For that, let’s connect the <code>MultiplayerSpawner </code>node’ <code>spawned</code> signal to the <code>PlayerSpawner</code> node using a method called <code>_on_multiplayer_spawner_spawned</code>.</p>
			<div><div><img alt="Figure 8.8 – The MultiplayerSpawner spawned signal connecting to the PlayerSpawner _on_multiplayer_spawner_spawned callback" src="img/Figure_8.08_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – The MultiplayerSpawner spawned signal connecting to the PlayerSpawner _on_multiplayer_spawner_spawned callback</p>
			<p>Then, we make <a id="_idIndexMarker277"/>an RPC on the spawned node’s <code>setup_multiplayer</code> method using the node’s name as an argument. Since the name is a <code>StringName</code> variable, we need to convert it to a string and then to an integer in order for the <code>Player</code> class to handle it. The complete <code>PlayerSpawner</code> script should look like this after these changes:</p>
			<pre class="source-code">
extends Marker2D
@export var players_scene = preload("res://08.designing-
    online-platformer/Actors/Player/Player2D.tscn")
func _ready():
    await(get_tree().create_timer(0.1).timeout)
    if multiplayer.get_peers().size() &lt; 1:
        if Input.get_connected_joypads().size() &lt; 1:
            var player = players_scene.instantiate()
            add_child(player)
            return
        for i in Input.get_connected_joypads():
            var player = players_scene.instantiate()
            add_child(player)
            player.setup_controller(i)
        return
    if is_multiplayer_authority():
        for i in range(0, multiplayer.get_peers().size()):
            var player = players_scene.instantiate()
            var player_id = multiplayer.get_peers()[i]
            player.name = str(player_id)
            add_child(player)
            await(get_tree().create_timer(0.1).timeout)
            player.rpc("setup_multiplayer", player_id)
func _on_multiplayer_spawner_spawned(node):
    node.rpc("setup_multiplayer", int(str(node.name)))</pre>			<p>The updated <a id="_idIndexMarker278"/>script incorporates multiplayer functionality by creating <code>Player</code> instances for each player in the network. It checks for the presence of connected joypads and multiplayer peers to determine the appropriate number of <code>Player</code> instances to create. The code also sets up the <code>Player</code> instances’ controls and synchronizes their multiplayer settings. With these changes, <code>PlayerSpawner</code> node now enables multiplayer gameplay, allowing multiple players to control their avatars and interact within the game world simultaneously with no control conflicts.</p>
			<p>In the upcoming section, we will explore the implementation of the <code>Player.setup_multiplayer()</code> method, which is responsible for configuring online multiplayer <a id="_idIndexMarker279"/>settings in the <code>Player</code> class. Within the <code>setup_multiplayer()</code> method, we set the multiplayer authority, disable the physics and input processing based on the local player’s authority over the instance, and set a visual player index label updated with which player is controlling<a id="_idTextAnchor179"/> the instance.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor180"/>Setting up the Player multiplayer controls</h2>
			<p>In this section, let’s <a id="_idIndexMarker280"/>see how to implement the <code>Player.setup_multiplayer()</code> method, which plays a core role in setting up the online multiplayer controls for the <code>Player</code> class.</p>
			<p>Within the <code>setup_multiplayer()</code> method, we need to take some key steps to achieve our online multiplayer controls. Firstly, we need to establish the new multiplayer authority, verifying the player’s control and decision-making capabilities within the multiplayer environment. Then, we will adjust the physics and input processing based on whether the player ID matches the player ID we designated using the node’s name. This ensures that each player controls the right <code>Player</code> instance.</p>
			<p>On top of that, the method updates a visual player index label, allowing players to see their assigned avatar. This visual feedback enhances the multiplayer experience by providing a clear indication of each player’s identity and presence in the game.</p>
			<p>By implementing the <code>setup_multiplayer()</code> method, the game achieves synchronized multiplayer functionality, creating a cohesive and immersive multiplayer experience. Players can interact and collaborate with one another, encouraging a sense of shared adventure and enjoyment within the game world.</p>
			<p>That said, let’s dive into the code and unlock the potential of our multiplayer gameplay on our prototype! Open the <code>Player</code> script at <code>res://08.designing-online-platformer/Actors/Player/Player2D.gd</code> and let’s implement the <code>setup_multiplayer()</code> method to finally allow players to control their avatars:</p>
			<ol>
				<li>In the <code>Player</code> script, create a new method called <code>setup_multiplayer()</code>. It should receive an argument to get the player’s ID; here, we’ll call it <code>player_id</code>:<pre class="source-code">
func setup_multiplayer(player_id):</pre></li>				<li>Then, decorate<a id="_idIndexMarker281"/> the method with the <code>@rpc</code> annotation, using the <code>"any_peer"</code> and <code>"call_local"</code> options. This specifies that the method can be called by any peer and executed locally. So, when players spawn their avatars, they tell the other peers to set up their avatars, setting up the avatar instance locally as well:<pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):</pre></li>				<li>Inside the <code>setup_multiplayer()</code> method, let’s call <code>set_multiplayer_authority()</code> passing <code>player_id</code> as an argument to set the new multiplayer authority of this <code>Player</code> instance. Remember, the multiplayer authority determines the peer’s control and decision-making capabilities over a given node:<pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):
    set_multiplayer_authority(player_id)</pre></li>				<li>Then, let’s create a variable to store whether <code>player_id</code> is equal to the <code>Player</code> instance name. With that, we check whether the current avatar is supposed to be controlled by the local player:<pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):
    set_multiplayer_authority(player_id)
    var is_player = str(player_id) == str(name)</pre></li>				<li>After that, we set the physics and unhandled input processes based on the value of the <code>is_player</code> variable. With that, we disable the physics processing and the input handling on the <code>Player</code> instances that don’t belong to the local player:<pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):
    set_multiplayer_authority(player_id)
    var is_player = str(player_id) == str(name)
    set_physics_process(is_player)
    set_process_unhandled_input(is_player)</pre></li>				<li>Finally, we<a id="_idIndexMarker282"/> update the text of the <code>label</code> node to display the player index. Here, <code>%s</code> is a placeholder that is replaced with the value returned by <code>get_index()</code>, representing the player’s index in the <code>PlayerSpawner</code> children hierarchy (remember the first node is <code>MultiplayerSpawner</code>) so the player indexing starts at <code>1</code>:<pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):
    set_multiplayer_authority(player_id)
    var is_player = str(player_id) == str(name)
    set_physics_process(is_player)
    set_process_unhandled_input(is_player)
    label.text = "P%s" % get_index()</pre></li>			</ol>
			<p>With that, we have our <code>Player</code> instance ready to behave in an online multiplayer environment. The <code>setup_multiplayer()</code> method configures the multiplayer features in the <code>Player</code> instances. It sets the multiplayer authority, adjusts physics processing and input handling based on the local player ID, and updates a label with the player’s index.</p>
			<p>But notice, since we are disabling physics and input processing, technically the other players’ avatars will remain static during the whole gameplay session, right? Each player will only control and see their own character moving around and we don’t want that. We want players to interact<a id="_idIndexMarker283"/> with each other and see how other players are behaving within this shared experience.</p>
			<p>In the next section, we are going to use <code>MultiplayerSynchronizer</code> node to keep all other players on the same page regarding each other’s avatar, including going beyond just the avatar’s position, but also its animation and more. We will also see how we handle the <code>Crate</code> node: since players can grab and carry it around, who should have control over it? Who should be the <code>Crate</code> node’s <strong class="bold">Mult<a id="_idTextAnchor181"/>iplayer Authority</strong>?</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor182"/>Syncing physical objects</h1>
			<p>In this section, we <a id="_idIndexMarker284"/>will understand how to use the <code>MultiplayerSynchronizer</code> node for more than position updates. This node plays an important role in ensuring that players are synchronized with the avatars of other players in the game. As we have seen in the <em class="italic">Giving players control in PlayerSpawner</em> section, it is essential to maintain consistency among players to create a seamless multiplayer experience.</p>
			<p>The <code>MultiplayerSynchronizer</code> class serves as a bridge between players, enabling real-time updates and synchronization of various properties. One key aspect that we will explore is how the <code>Crate</code> object’s position is updated based on the player who is carrying it. This functionality allows for interactive and collaborative gameplay, where players can work together to solve puzzles or accomplish tasks.</p>
			<p>On top of that, we will see how the <code>MultiplayerSynchronizer</code> node handles properties related to avatar animations. By leveraging the <code>MultiplayerSynchronizer</code> class, we can ensure that all players observe the same animation state of other players’ avatars, enabling a visually consistent experience.</p>
			<p>Through the usage of the <code>MultiplayerSynchronizer</code> node, we can establish a robust framework for synchronizing player actions, avatar positions, and animations. This synchronization ensures that all players perceive a cohesive and immersive multiplayer environment, fostering collaboration and enhancing the overall gameplay experience.</p>
			<p>Let’s explore the implementation details of <code>Multi<a id="_idTextAnchor183"/>playerSynchronizer</code>!</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor184"/>Synchronizing the player’s position and animations</h2>
			<p>Our <code>Player</code> scene <a id="_idIndexMarker285"/>has some nodes responsible for playing animations based on the player’s actions and the current state of the avatar, namely the <code>Sprites</code> and <code>AnimatedSprite2D</code> nodes. It is important to synchronize the <code>Sprites</code> nodes’ scale and the <code>AnimatedSprite</code> animation and frame since players’ avatars would look rather weird if they jump, run, and stay idle and there’s no visual feedback updating the performance of such actions in the game world other than the avatar’s position changing. So, in this section, let’s ensure that on top of the position, other relevant properties are also synced among players. For that, let’s open the <code>Player</code> scene at <code>res://08.designing-online-platformer/Actors/Player/Player2D.tscn</code> and, of course, add <code>MultiplayerSynchronizer</code> as its child. With that, we will perform the following steps:</p>
			<ol>
				<li>First of all, we <a id="_idIndexMarker286"/>need to change the <code>MultiplayerSynchronizer</code>’s <strong class="bold">Visibility Update Mode</strong> to <strong class="bold">Physics</strong> so it syncs the physics simulations on remote peers’ game instances.</li>
			</ol>
			<div><div><img alt="Figure 8.9 – The player’s MultiplayerSynchronizer properties" src="img/Figure_8.09_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – The player’s MultiplayerSynchronizer properties</p>
			<ol>
				<li value="2">After that, in the <code>PlayerCharacter2D</code> node’s <code>AnimatedSprite2D</code> node’s <code>Sprite</code> nodes’ <code>MultiplayerSynchronizer</code> node also synchronizes the animation-related properties, allowing the players to see what their peers’ avatars are doing.</li>
			</ol>
			<div><div><img alt="Figure 8.10 – The MultiplayerSynchronizer’s Replication properties" src="img/Figure_8.10_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – The MultiplayerSynchronizer’s Replication properties</p>
			<p>And that’s it! With <a id="_idIndexMarker287"/>that, our players are ready to interact within a shared game world. The <code>MultiplayerSynchronizer</code> node is an incredible ally to have in our toolbelt when developing online multiplayer games. As we can see in this section, those node allows for the synchronization of a range of different properties that can help us make our online gameplay experience enjoyable. There’s a small, though very important observation to make in this regard. As we’ve seen throughout this book, especially in <em class="italic">Part 1</em>, we can’t pass objects around, and we should avoid heavy data transmission through the network. So, keep that in mind when adding properties to the <code>MultiplayerSynchronizer</code> node’s <strong class="bold">Replication</strong> menu. For instance, if you try to sync a <strong class="bold">Texture</strong> property, you are likely to fail the replication.</p>
			<p>That said, in the next section, we are going to use <code>MultiplayerSynchronizer</code> node to sync the <code>Crate</code> node’s position property, but there’s a twist. Since any player can grab a <code>Crate</code> node and move it around, who should be its <strong class="bold">Multiplayer Authority</strong>? Well, that’s what <a id="_idTextAnchor185"/>we are about to see!</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor186"/>Updating the crate’s position remotely</h2>
			<p>At this point, we <a id="_idIndexMarker288"/>are fairly familiar with how <code>MultiplayerSynchronizer</code> node works and the overall concept of a node’s multiplayer authority, right? One of the core mechanics in our online multiplayer puzzle platformer game is the ability for players to collaborate by taking objects and using them as platforms to progress through the levels’ obstacles.</p>
			<p>In this section, we are going to see how we can dynamically change an object’s multiplayer authority based on which player is currently interacting with it so that only that player can change<a id="_idIndexMarker289"/> the object’s properties. Open the <code>Crate</code> scene at <code>res://08.designing-online-platformer/Objects/Crate/Crate.tscn</code>, and add a new <code>MultiplayerSynchronizer</code> node as its child. Then, follow these steps:</p>
			<ol>
				<li>Just like in the <code>Player</code> scene, we need to change the <code>MultiplayerSynchronizer</code> node’s <strong class="bold">Visibility Update Mode</strong> to <strong class="bold">Physics</strong> to maintain the physics simulations consistently.</li>
			</ol>
			<div><div><img alt="Figure 8.11 – The crate’s MultiplerSynchronizer properties" src="img/Figure_8.11_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – The crate’s MultiplerSynchronizer properties</p>
			<ol>
				<li value="2">Then, in the <code>CharacterBody2D</code> node’s <strong class="bold">Position</strong> property to the syncing.</li>
			</ol>
			<div><div><img alt="Figure 8.12 – The crate’s CharacterBody2D position property in the Replication menu" src="img/Figure_8.12_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – The crate’s CharacterBody2D position property in the Replication menu</p>
			<p>With that, believe it <a id="_idIndexMarker290"/>or not, we already have what we need to sync the crate’s position. Currently, the crate does not have any built-in behavior to move on its own, as its position is expected to be altered by the players who interact with it. To enable this functionality, we will make some additions to the <code>Crate</code> script. To get started, let’s open the script file at <code>res://08.designing-online-platformer/Objects/Crate/Crate.gd</code>.</p>
			<p>In the <code>_on_interactive_area_2d_area_entered()</code> method, we need to change the crate’s multiplayer authority to match the player it’s interacting with. For that, we can call the <code>set_multiplayer_authority()</code> method passing the area’s multiplayer authority. This area that just entered is the player’s <code>InteractionArea2D</code> node, so its multiplayer authority is the same as that of the player’s:</p>
			<pre class="source-code">
func _on_interactive_area_2d_area_entered(area):
    lift_transformer = area.get_node
        ("GrabbingRemoteTransform2D")
    set_multiplayer_authority
        (area.get_multiplayer_authority())</pre>			<p>With that, whenever the <a id="_idIndexMarker291"/>player’s avatar enters the crate’s <code>InteractiveArea2D</code> node, the player will become the crate’s multiplayer authority and will be able to grab it and change its position once they interact with it. With this addition, we are ready to witness the seamless synchronization of the crate’s position as players interact with it. You can test the prototype to explore the possibilities of collaborative gameplay and enjoy the immersive multiplayer experience we have just created!</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor187"/>Summary</h1>
			<p>In this chapter, we dived into the world of online multiplayer puzzle platformers, which emphasized teamwork and collaboration. Players will be challenged to work together, leveraging their skills to overcome obstacles and progress through intricate levels. Throughout the chapter, we explored key concepts and techniques to enhance the multiplayer experience and create a seamless collaborative gameplay environment.</p>
			<p>To enable multiplayer functionality, we introduced the <code>MultiplayerSpawner</code> class, which dynamically instantiates <code>Player</code> instances based on the number of connected players. This ensures that each player has a unique avatar in the game, promoting a personalized and immersive multiplayer experience. The <code>Player</code> class played a crucial role, and we implemented the <code>setup_multiplayer()</code> method to configure its multiplayer settings. This method allowed us to set each instance’s multiplayer authority, adjust physics and input processing, and update a visual player index label, providing players with a clear identification in the game.</p>
			<p>To achieve synchronization between players, we harnessed the power of <code>MultiplayerSynchronizer</code> node. This powerful tool enabled us to synchronize not only the positions of players but also their animations. By incorporating <code>MultiplayerSynchronizer</code> node, we created a visually captivating multiplayer experience where players moved and interacted with the game world in perfect harmony. This synchronization brought the multiplayer gameplay to life, enhancing immersion and ensuring a cohesive and enjoyable shared experience.</p>
			<p>An exciting feature we implemented was the ability for players to grab and manipulate the <code>Crate</code> object. By dynamically changing the crate’s multiplayer authority, we ensured that only the player interacting with the crate had control over its movements. This added an extra layer of collaboration and puzzle-solving, as players can strategically use the crate as a platform to navigate the levels, fostering teamwork and coordination.</p>
			<p>To sum up, this chapter provided a solid foundation for understanding and implementing multiplayer features using the Godot Engine High-level Network API. By combining the concepts and techniques explored, we created an online multiplayer puzzle platformer prototype, where players can seamlessly collaborate, synchronize their actions, and conquer challenges together. This chapter opened doors to endless possibilities in future multiplayer game development endeavors, empowering you to create engaging and interactive multiplayer experiences.</p>
			<p>In the next chapter, we’ll leverage all the knowledge we’ve seen so far in <em class="italic">Part 2</em> of this book to create a multiplayer online adventure with a persistent section system where players can log in and out and maintain their progress. The players will also synchronize the server’s world with their game instance world, which also means they will be able to see all the other players that are currently playing as well and interact with one another. It’s fundamentally a prototype that you can expand to a <strong class="bold">Massive Multiplayer Online Role Playing Game</strong> (<strong class="bold">MMORPG</strong>) if you want.</p>
		</div>
	</body></html>