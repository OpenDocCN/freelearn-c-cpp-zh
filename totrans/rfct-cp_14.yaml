- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software development, maintaining a clean commit history is essential for
    producing enduring and coherent code. This chapter emphasizes that a well-organized
    commit history is fundamental to robust software engineering. By focusing on version
    control, particularly through clear commit summaries and messages, we will explore
    the techniques and intentional practices needed to achieve clarity and precision.
  prefs: []
  type: TYPE_NORMAL
- en: Committing code is like adding individual threads to the overall narrative of
    a project’s development. Each commit, with its summary and message, contributes
    to the understanding of the project’s history and future direction. Maintaining
    a clean commit history goes beyond organizational neatness; it embodies effective
    communication among developers, facilitates seamless collaboration, and enables
    quick navigation through the project’s development history.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will examine what makes a “good” commit, focusing
    on attributes that bring clarity, purpose, and utility to commit messages. This
    exploration goes beyond the basics, delving into strategic documentation of code
    changes and insights gained through tools such as Git. With illustrative examples,
    we will see how well-crafted commit histories can transform understanding, aid
    in debugging, and streamline the review process by clearly conveying the rationale
    behind code alterations.
  prefs: []
  type: TYPE_NORMAL
- en: Advancing further, we will decode the Conventional Commits specification, a
    structured framework designed to standardize commit messages, thereby infusing
    them with predictability and machine-parseable clarity. This section illuminates
    the symbiotic relationship between commit message structure and automated tooling,
    showcasing how adherence to such conventions can dramatically enhance project
    maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress, the narrative unfolds to reveal the practicalities of enforcing
    these best practices through the lens of commit linting. Here, we delve into the
    integration of automated tools within **Continuous Integration** (**CI**) workflows,
    demonstrating how such mechanisms serve as vigilant guardians of commit quality,
    ensuring consistency and compliance with established norms.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter goes beyond explaining the mechanics of version control; it invites
    you to view crafting clean commit histories as a vital part of software craftsmanship.
    By following the principles and practices discussed here, developers and teams
    can improve their code repositories’ quality and create an environment that promotes
    innovation, collaboration, and efficiency. As we explore this chapter, remember
    that a clear commit history reflects our dedication to excellence in software
    development.
  prefs: []
  type: TYPE_NORMAL
- en: What is a good commit?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the heart of effective version control practices lies the concept of a “good
    commit,” a fundamental unit of change that embodies the principles of clarity,
    atomicity, and purposefulness within the code base. Understanding what constitutes
    a good commit is essential for developers who strive to maintain a clean, navigable,
    and informative project history. This section delves into the key attributes that
    define the quality of a commit, offering insights into how developers can enhance
    their version control practices.
  prefs: []
  type: TYPE_NORMAL
- en: The principle of singular focus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good commit adheres to the principle of atomicity, meaning it encapsulates
    a single logical change within the code base. This singular focus ensures that
    each commit is independently meaningful and that the project can be safely and
    easily reverted or modified by reverting or adjusting individual commits. Atomic
    commits simplify code review processes, making it easier for team members to understand
    and evaluate each change without the noise of unrelated modifications. For example,
    instead of combining a new feature implementation with a separate bug fix in one
    commit, they should be split into two distinct commits, each with its clear purpose
    and scope.
  prefs: []
  type: TYPE_NORMAL
- en: The art of communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The essence of a good commit also lies in its clarity, particularly evident
    in the commit message. A clear commit message succinctly describes the what and
    the why of the change, serving as concise documentation for future reference.
    This clarity extends beyond the immediate team, aiding anyone who interacts with
    the code base, including new team members, external collaborators, and even the
    future self. This becomes especially important when revisiting the code base after
    a prolonged period, as the commit messages serve as a historical record of the
    project’s evolution. This approach is crucial for open source projects because
    it allows contributors to understand the context and rationale behind the changes,
    thereby fostering a collaborative and inclusive environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'A well-structured commit message typically includes a concise title line summarizing
    the change, followed by a blank line and a more detailed explanation if necessary.
    The explanation can delve into the rationale behind the change, any implications
    it might have, and any additional context that helps understand the commit’s purpose.
    It is recommended to keep the subject line up to 50 characters. This ensures that
    the message fits within the standard width of most terminals, is not terminated
    by GitHub or other platforms, and is easily scannable. GitHub truncates subjects
    shorter than 72 characters, so 72 will be a hard limit and 50 a soft one. For
    example, the commit message `feat: added a lots of needed include directives to
    make things compile properly` will be truncated by GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Truncated commit message](img/B19606_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Truncated commit message
  prefs: []
  type: TYPE_NORMAL
- en: GitHub truncates the last word, `properly`, and in order to read it, developers
    will have to click on the commit message. This is not a big deal but it is a small
    inconvenience that can be easily avoided by keeping the subject line short.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, it forces the author to be concise and to the point.
  prefs: []
  type: TYPE_NORMAL
- en: Other useful practices include using the imperative mood in the subject line,
    which is a common convention in commit messages. This means that the subject line
    should be phrased as a command or instruction, such as `fix the bug` or `add the
    feature`. This style of writing is more direct and aligns with the idea that a
    commit represents a change that is being applied to the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Prefer not to end the subject line with a period, as it is not a complete sentence
    and does not help to keep the message short. The body of the commit message can
    provide additional context, such as the motivation for the change, the problem
    it solves, and any relevant details about the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Prefer to wrap the body at 72 characters, because Git does not wrap text for
    you. It is a common convention and it makes the message more readable in various
    contexts, such as terminal windows, text editors, and version control tools. It
    can be easily achieved by configuring your code editor.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the moment spent in reflection before finalizing a commit is not
    just about ensuring the clarity of the message; it is about reaffirming the value
    and intent behind the changes themselves. It is an opportunity to ensure that
    each contribution to the code base is deliberate, meaningful, and aligned with
    the project’s objectives. In this light, taking the time to craft a precise and
    informative commit message is not only a good practice but a testament to the
    developer’s commitment to quality and collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: The art of refinement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before merging feature branches into the `main` branch, it’s prudent for developers
    to consider the cleanliness and clarity of their commit history. Squashing intermediate
    commits is a thoughtful practice that streamlines the commit log, making it more
    readable and meaningful for anyone who explores the project history.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re on the verge of integrating your work, take a moment to reflect
    on the commit messages that have accumulated during development. Ask yourself
    whether each commit message adds value to the understanding of the project’s evolution
    or whether it merely clutters the history with redundant or overly granular details.
    In many cases, the iterative steps you took to arrive at the final solution—such
    as minor bug fixes, adjustments in response to code reviews, or corrections to
    unit tests—may not hold significant value for other contributors or for the future
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a commit history filled with messages such as `fix bug`, `fix unit
    test`, or multiple `fix cr` entries. Such messages, while indicative of the development
    process, do not necessarily provide meaningful insights into the changes or their
    impact on the project. Squashing these intermediate commits into a single, well-crafted
    commit not only tidies up the commit log but also ensures that each entry in the
    history conveys a significant step in the project’s development.
  prefs: []
  type: TYPE_NORMAL
- en: By squashing commits, you consolidate these iterative changes into a cohesive
    narrative that highlights the introduction of a new feature, the resolution of
    a significant bug, or the implementation of a crucial refactor. This curated history
    aids both current contributors and future maintainers in navigating and understanding
    the project’s progression, enhancing collaboration and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, before merging, consider the broader perspective of the project’s
    commit history. Squashing intermediate commits is a practice in mindfulness, ensuring
    that the commit log remains a valuable and navigable resource for all contributors,
    encapsulating the essence of each change in a clear and concise manner.
  prefs: []
  type: TYPE_NORMAL
- en: Conventional Commits specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consistency in commit messages and structures across a project enhances readability
    and predictability, making it easier for team members to navigate the project
    history. Adhering to a predefined format or set of conventions, such as the Conventional
    Commits specification, ensures that commit messages are uniformly structured and
    informative. These might include starting commit messages with a verb in the imperative
    mood, specifying the type of change (e.g., `fix`, `feat`, or `refactor`), and
    optionally including a scope to clarify what part of the project is affected.
  prefs: []
  type: TYPE_NORMAL
- en: Linking code to context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good commit enhances traceability by linking the code change to its broader
    context, such as a ticket in the project’s issue-tracking system or relevant documentation.
    Including references in commit messages creates a tangible connection between
    the technical implementation and the requirements or issues it addresses, facilitating
    better understanding and tracking of project progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'Incorporating issue tracker IDs, ticket numbers, or other relevant identifiers
    in commit messages can significantly improve the traceability of changes and the
    ease with which they can be related to the project’s objectives or reported issues.
    It often looks similar to `fix(FP-1234): corrected the user authentication flow`,
    where `FP-1234` is the ticket number in the issue-tracking system.'
  prefs: []
  type: TYPE_NORMAL
- en: In essence, a good commit acts as a coherent, self-contained story within the
    broader narrative of a project’s development history. By adhering to these principles,
    developers not only contribute to the maintainability and readability of the code
    base but also foster a culture of meticulousness and accountability in version
    control practices. Through the disciplined creation of good commits, the project’s
    history becomes a valuable asset for collaboration, review, and understanding
    the evolution of the software.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best ways to create good commit messages is by following the Conventional
    Commits specification. The Conventional Commits specification stands as a structured
    framework for commit message formatting, designed with the dual aim of simplifying
    the process of creating readable commit logs and enabling automated tooling to
    facilitate version management and release note generation. This specification
    delineates a standardized format for commit messages, intending to clearly communicate
    the nature and intent of changes within a version control system, such as Git.
  prefs: []
  type: TYPE_NORMAL
- en: Overview and intent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At its core, the Conventional Commits specification prescribes a format that
    includes a type, an optional scope, and a succinct description. The format typically
    follows this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The *type* categorizes the commit according to the nature of the change it introduces,
    such as `feat` for a new feature or `fix` for a bug fix. The *scope*, though optional,
    provides additional contextual information, often indicating the part of the code
    base affected by the change. The *description* offers a concise summary of the
    change, crafted in an imperative mood.
  prefs: []
  type: TYPE_NORMAL
- en: Options and usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Commit linting, particularly when adhering to the Conventional Commits specification,
    ensures that commits are structured in a clear, predictable, and useful manner.
    Here are some examples of commits that comply with commit linting rules, showcasing
    various types of changes that might occur in a software project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a new feature:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This commit message indicates that a new feature (`feat`) has been added, (specifically,
    biometric authentication support) and the scope of this feature is within the
    authentication module of the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Fixing a bug:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, a bug fix (`fix`) is being committed, addressing a race condition issue
    within the `database` module, particularly in the process of user data retrieval.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Improving documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This example shows a documentation update (`docs`), with the changes made to
    the project’s README file to update the installation instructions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Code refactoring:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this commit, existing code has been refactored (`refactor`) without adding
    any new features or fixing any bugs. The scope of the refactoring is the UI, specifically
    simplifying the logic used in a `button` component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Style adjustments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This commit message signifies a styling change (`style`), where unused CSS classes
    are being removed. It’s worth noting that this type of commit does not affect
    the functionality of the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Adding tests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, new tests (`test`) have been added for a new user endpoint in the API,
    indicating an enhancement in the project’s test coverage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Chore tasks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This commit represents a chore (`chore`), typically a maintenance or setup task
    that doesn’t directly modify the source code or add functionality, such as updating
    a build script for deployment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Breaking change:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another method to indicate a breaking change is by adding an exclamation mark
    (`!`) after the type and scope but before the colon in the commit message. This
    method is succinct and visually noticeable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This commit introduces a new feature (`feat`) related to the database schema
    of the user’s table but also includes a breaking change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These examples illustrate how commit linting, guided by the Conventional Commits
    specification, facilitates clear, structured, and informative commit messages
    that enhance project maintainability and collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: Origins and adoption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Conventional Commits specification was inspired by the need to streamline
    the creation of readable and automated changelogs. It builds upon earlier practices
    from the AngularJS team and has since been adopted by various open source and
    enterprise projects seeking to standardize commit messaging for improved project
    maintainability and collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of Conventional Commits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adhering to the Conventional Commits specification offers numerous benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated Semver handling**: By categorizing commits, tools can automatically
    determine version bumps based on the semantic meaning of changes, adhering to
    **Semantic Versioning** (**Semver**) principles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streamlined release notes**: Automated tools can generate comprehensive and
    clear release notes and changelogs by parsing structured commit messages, significantly
    reducing manual effort and enhancing release documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced readability**: The standardized format improves the readability
    of commit history, making it easier for developers to navigate and understand
    project evolution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facilitated code reviews**: The clear categorization and description of changes
    aid in the code review process, enabling reviewers to quickly grasp the scope
    and intent of changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commitlint – enforcing commit message standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Commitlint is a powerful, configurable tool designed to enforce commit message
    conventions, ensuring consistency and clarity across a project’s commit history.
    It plays a crucial role in maintaining a clean, readable, and meaningful commit
    log, particularly when used in conjunction with conventions such as the Conventional
    Commits specification. This section provides a comprehensive guide on how to install,
    configure, and use commitlint to check commit messages locally, fostering a disciplined
    approach to version control and collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Commitlint is typically installed via npm, the package manager for Node.js.
    To get started, you’ll need to have Node.js and npm installed on your development
    machine. Once set up, you can install commitlint and its conventional `config`
    package by running the following commands in your project’s root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This command installs commitlint and the conventional commits configuration
    as development dependencies in your project, making them available for use in
    the local development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After installation, commitlint requires a configuration file to define the
    rules it will enforce. The most straightforward way to configure commitlint is
    by using the conventional commits configuration, which aligns with the Conventional
    Commits specification. Create a file named `commitlint.config.js` in your project’s
    root directory, and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This configuration instructs commitlint to use the standard rules provided by
    the Conventional Commits configuration, which include checks for the structure,
    types, and scopes of commit messages.
  prefs: []
  type: TYPE_NORMAL
- en: Local usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To check commit messages locally, you can use commitlint in conjunction with
    Husky, a tool for managing Git hooks. Husky can be configured to trigger commitlint
    to evaluate commit messages before they are committed, providing immediate feedback
    to the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install Husky as a development dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us check local commits with commitlint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `--from HEAD~1` and `--to HEAD` specify the range of commits
    to check, and `--verbose` provides detailed output. If the commit message does
    not adhere to the specified conventions, commitlint will output an error message,
    indicating the violations that need to be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add a bad commit message and check it with commitlint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Commitlint can be integrated as a Git hook by adding the following configuration
    to your `package.json` file or by creating a `.huskyrc` file with the same content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This configuration sets up a pre-commit hook that invokes commitlint with the
    commit message that is about to be committed. If the commit message does not meet
    the specified standards, commitlint will reject the commit, and the developer
    will need to revise the message accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Commitlint offers a wide array of configuration and customization options, allowing
    teams to tailor commit message validation rules to fit their specific project
    requirements and workflows. This flexibility ensures that commitlint can be adapted
    to support various commit conventions beyond the standard Conventional Commits
    format, providing a robust framework for enforcing consistent and meaningful commit
    messages across diverse development environments.
  prefs: []
  type: TYPE_NORMAL
- en: Basic configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic configuration of commitlint involves setting up a `commitlint.config.js`
    file in your project’s root directory. This file serves as the central point for
    defining the rules and conventions that commitlint will enforce. At its simplest,
    the configuration might extend a predefined set of rules, such as those provided
    by `@commitlint/config-conventional`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This configuration instructs commitlint to use the conventional commit message
    rules, enforcing a standard structure and set of types for commit messages.
  prefs: []
  type: TYPE_NORMAL
- en: Custom rule configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Commitlint’s real power lies in its ability to customize rules to match specific
    project needs. Each rule in commitlint is identified by a string key and can be
    configured with an array specifying the rule’s level, applicability, and, in some
    cases, additional options or values. The rule configuration array generally follows
    the format `[level,` `applicability, value]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0` = disabled, `1` = warning, and `2` = error)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''always''` or `''never''`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value**: Additional parameters or options for the rule, varying by rule'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, to enforce that commit messages must start with a type followed
    by a colon and a space, you could configure the `type-enum` rule as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This configuration sets the rule level to error (`2`), specifies that the rule
    should always be applied, and defines a list of acceptable types for commit messages.
  prefs: []
  type: TYPE_NORMAL
- en: Scope and subject configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Commitlint also allows for detailed configuration of commit message scopes
    and subjects. For instance, you can enforce specific scopes or require that commit
    message subjects do not end with a period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This setup mandates that commits must use one of the predefined scopes and that
    the subject line must not end with a period.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing and sharing configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For projects or organizations with unique commit message conventions, custom
    configurations can be defined and, if needed, shared across multiple projects.
    You can create a dedicated npm package for your commitlint configuration, allowing
    teams to easily extend this shared configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This approach promotes consistency across projects and simplifies the management
    of commit message rules within an organization.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensuring the enforcement of commitlint via CI is a crucial practice in maintaining
    high-quality commit messages across a project. While local Git hooks, such as
    those managed by Husky, offer a first line of defense by checking commit messages
    on the developer’s machine, they are not infallible. Developers might intentionally
    or accidentally disable Git hooks, and **Integrated Development Environments**
    (**IDEs**) or text editors might not be properly configured to enforce these hooks
    or might encounter issues that lead to their malfunction.
  prefs: []
  type: TYPE_NORMAL
- en: Given these potential gaps in local enforcement, CI serves as the authoritative
    source of truth, providing a centralized, consistent platform for verifying commit
    messages against the project’s standards. By integrating commitlint into the CI
    pipeline, projects ensure that every commit, regardless of its origin or the method
    used to submit it, adheres to the defined commit message conventions before it
    is merged into the main code base. This CI-based enforcement fosters a culture
    of discipline and accountability, ensuring that all contributions, regardless
    of their source, meet the project’s quality standards.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating commitlint into CI with GitHub Actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub Actions offers a straightforward and powerful platform for integrating
    commitlint into your CI workflow. The following example demonstrates how to set
    up a GitHub action to enforce commit message standards using commitlint on every
    push or pull request targeting the `main` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new file in your repository under `.github/workflows/commitlint.yml`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This workflow defines a job named `commitlint` that triggers on pushes and
    pull requests to the `main` branch. The only configuration that I would like to
    highlight is `failOnWarnings: true`, which configures the action to fail the job
    if any commitlint warnings are encountered. This ensures strict adherence to the
    commit message standards by treating warnings with the same severity as errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create a bad commit message and open a PR to see how the action works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After we open a PR, we will see that the action has failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Commitlint action failed](img/B19606_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Commitlint action failed
  prefs: []
  type: TYPE_NORMAL
- en: 'The logs will show the reason for the failure in the same format as the local
    check:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Commitlint action log failed](img/B19606_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – Commitlint action log failed
  prefs: []
  type: TYPE_NORMAL
- en: By incorporating this workflow into your project, you ensure that every commit
    is scrutinized for adherence to your commit message standards before it becomes
    part of the `main` branch. This CI-based check acts as a final gatekeeper, reinforcing
    the importance of well-structured commit messages and maintaining the integrity
    of the project’s commit history.
  prefs: []
  type: TYPE_NORMAL
- en: Commitlint’s configurability and customization options provide a powerful platform
    for enforcing commit message standards tailored to a project’s or organization’s
    specific needs. By leveraging these capabilities, teams can ensure that their
    commit logs remain clear, consistent, and meaningful, thereby enhancing project
    maintainability and collaboration. Whether adhering to widely accepted conventions
    such as the Conventional Commits specification or defining a set of custom rules,
    commitlint offers the flexibility and control needed to maintain a high-quality
    commit history.
  prefs: []
  type: TYPE_NORMAL
- en: Generating changelogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automatic changelog generation is a method where software tools automatically
    create a log of changes made to a project, categorizing and listing updates, fixes,
    and features. This process is favored for its efficiency and consistency, ensuring
    that all significant modifications are documented systematically. We’ll explore
    this concept through GitCliff, a tool that parses structured commit messages to
    generate detailed changelogs, aiding in transparent project management and communication.
    GitCliff’s utility in this process exemplifies its role in automating and streamlining
    project documentation tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GitCliff is written in Rust and can be installed using Cargo, the Rust package
    manager. To install GitCliff, ensure that you have Rust and Cargo installed on
    your system, and then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing Rust, you can install GitCliff using Cargo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The last configuration step is to initialize GitCliff in your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This generates a default configuration file, `.cliff.toml`, in the root of your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: GitCliff usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After installing and initializing GitCliff, you can generate a changelog by
    running the following command in your project’s root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The tool generates a Markdown file with the changelog, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Generated changelog](img/B19606_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – Generated changelog
  prefs: []
  type: TYPE_NORMAL
- en: The log contains a list of changes, categorized by type, and it highlights breaking
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add a release tag and generate a changelog for the release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The changelog will now contain the release tag and the changes since the last
    release:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Generated changelog with release tag](img/B19606_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Generated changelog with release tag
  prefs: []
  type: TYPE_NORMAL
- en: 'We can introduce a breaking change and bump the version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, GitCliff has detected the breaking change and bumped the version
    to 2.0.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Generated changelog with breaking change](img/B19606_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – Generated changelog with breaking change
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding sections, we have comprehensively explored the significant
    functionalities of `git-cliff`, revealing its substantial utility in automating
    change log generation. This tool distinguishes itself not only through its capacity
    to streamline the documentation process but also through its seamless integration
    with CI platforms, including but not limited to GitHub. Such integration ensures
    that changelogs are consistently synchronized with the latest project developments,
    thereby maintaining the accuracy and relevance of project documentation.
  prefs: []
  type: TYPE_NORMAL
- en: An equally noteworthy feature of git-cliff is the extensive customization it
    offers for changelog generation. Users are afforded the flexibility to tailor
    the format, content, and presentation of changelogs to meet specific project requirements
    or personal preferences. This high degree of customizability ensures that the
    output not only aligns with but also enhances the project’s documentation standards.
  prefs: []
  type: TYPE_NORMAL
- en: Given the depth of functionality and the potential benefits that git-cliff offers,
    those interested in leveraging this tool to its fullest are encouraged to consult
    the official documentation. This resource is a treasure trove of detailed information,
    covering the breadth of features, configurations, and best practices associated
    with git-cliff. Engaging with the official documentation will not only solidify
    your understanding of the tool but also equip you with the knowledge to implement
    it effectively in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, having delved into the major capabilities and advantages of git-cliff,
    the path forward for those looking to integrate this tool into their development
    workflow is through a thorough exploration of the official documentation. This
    exploration promises to extend your proficiency in utilizing git-cliff, ensuring
    that you can fully harness its capabilities to enhance your project’s change log
    generation and documentation processes.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing git-bisect in bug hunting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the process of software development, the task of identifying and rectifying
    bugs is paramount to ensure the stability and reliability of the application.
    Among the arsenal available to developers for this purpose, `git-bisect` stands
    out as a powerful tool, specifically designed for the task of isolating the commit
    that introduced a bug into the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded within the Git version control system, `git-bisect` is a utility based
    on the binary search algorithm. It aids developers in sifting through a potentially
    vast commit history to pinpoint the exact change that caused a regression or introduced
    an error. By adopting a divide-and-conquer strategy, `git-bisect` significantly
    streamlines the debugging process, making it an efficient approach to troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The journey with `git-bisect` begins by establishing two critical points in
    the project’s timeline: a commit where the bug is known to be absent (referred
    to as `good`) and a commit where the bug is confirmed to be present (`bad`). With
    these markers set, `git-bisect` proceeds to check out a commit that lies midway
    between the `good` and `bad` commits. This step requires the developer to test
    the current state of the application to determine whether the bug is present or
    not.'
  prefs: []
  type: TYPE_NORMAL
- en: The iterative process involves `git-bisect` selecting a new commit based on
    the developer’s feedback, and continually narrowing down the search area by halving
    it with each step. The cycle of testing and feedback continues until `git-bisect`
    successfully isolates the commit that introduced the bug, effectively zeroing
    in on the root cause with minimal manual review.
  prefs: []
  type: TYPE_NORMAL
- en: The efficiency of `git-bisect` lies in its ability to reduce the number of commits
    that need to be scrutinized manually, thus conserving valuable development time.
    Its methodical approach ensures precision in identifying the problematic commit,
    which is crucial for understanding the context of the bug and formulating an effective
    fix. Being an integral part of the Git ecosystem, `git-bisect` seamlessly fits
    into the developer’s existing workflow, offering a familiar and straightforward
    interface for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: To optimize the effectiveness of `git-bisect`, it is imperative to use a reliable
    and accurate test case for evaluating each commit. This ensures that the feedback
    provided to `git-bisect` correctly reflects the presence or absence of the bug,
    thereby preventing misidentification. Maintaining a clean and logical commit history,
    where each commit encapsulates a single change, enhances the tool’s efficiency.
    Furthermore, automating the testing process within the `git-bisect` session, when
    feasible, can expedite the bug-hunting endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a scenario where a regression is detected in a feature that was previously
    functioning correctly. It happens often when certain tests are running only at
    night. The task is to identify the commit responsible for this regression using
    `git-bisect`:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the `bisect` session with `git` `bisect start`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark the commit in which the bug is present as `git bisect bad <commit hash>`
    (usually, it is `HEAD`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify a commit in the past where the feature worked correctly and mark it
    as `good` using `git bisect` `good <commit-hash>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`git-bisect` will then check out a commit halfway between the `good` and `bad`
    commits. Test this commit to see whether the bug exists.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on the test outcome, mark the commit as `good` or `bad`. `git-bisect`
    uses this feedback to narrow down the search space and selects a new commit for
    testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the testing and marking process until `git-bisect` identifies the commit
    that introduced the bug.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the problematic commit is identified, developers can examine the changes
    introduced in that commit to understand the cause of the bug and proceed with
    developing a fix.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how it works, I cloned the master branch of the `rapidjson`
    library a bug and put it in the middle of the local repo. The Git log looks as
    follows, where `Bad commit (6 hours ago) <f-squirrel>` is the `bad` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us start bisecting by marking `good` and `bad` commits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'I have prepared a script that checks whether the bug is present in the current
    commit. The script is called `test.sh` and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time I run the script, I mark the commit as `good` or `bad`. After a
    few iterations, I have found the commit that introduced the bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the test script again, we will see that the bug is present in the
    commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Once we finish our bug hunt, we can reset the `bisect` session with `git` `bisect
    reset`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jumping between commits for a user is a useful functionality but not the only
    one. `git-bisect` can be automated with a script that will run the tests and mark
    the commits as good or bad based on the test results. Note that the script should
    return `0` if the commit is good and `1` if the commit is bad. The script will
    run until the bug is found and the `bisect` session will be reset. For our repository,
    it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`git-bisect` is an indispensable debugging tool within the Git suite, offering
    a systematic and efficient approach to identifying bug-inducing commits. Its integration
    into the development workflow, combined with the practice of maintaining a clear
    commit history and employing automated tests, makes it a highly effective solution
    for maintaining code quality and stability.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter dedicated to version control, we embarked on an insightful journey
    through the core principles and practices that underpin effective software version
    management. Central to our exploration was the adoption of conventional commits,
    a structured approach to commit messaging that enhances readability and facilitates
    automated processing of commit logs. This practice, grounded in a standardized
    format for commit messages, enables teams to convey the nature and intent of changes
    with clarity and precision.
  prefs: []
  type: TYPE_NORMAL
- en: We also delved into SemVer, a methodology designed to manage version numbers
    in a meaningful way. SemVer’s systematic approach to versioning, based on the
    significance of changes in the code base, provides clear guidelines on when and
    how version numbers should be incremented. This method offers a transparent framework
    for version control, ensuring compatibility and facilitating effective dependency
    management within and across projects.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter further introduced change log creation tools, with a particular
    focus on git-cliff, a versatile tool that automates the generation of detailed
    and customizable change logs from Git history. These tools streamline the documentation
    process, ensuring that project stakeholders are well informed about the changes,
    features, and fixes introduced with each new version.
  prefs: []
  type: TYPE_NORMAL
- en: A significant portion of the chapter was dedicated to debugging techniques,
    highlighting the utility of `git-bisect` in the process of isolating bugs. `git-bisect`,
    through its binary search algorithm, enables developers to efficiently pinpoint
    the commit that introduced a bug, thereby significantly reducing the time and
    effort required for troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, this chapter provided a comprehensive overview of version control
    practices, emphasizing the importance of structured commit messages, strategic
    versioning, automated changelog generation, and efficient debugging techniques.
    By adopting these practices, development teams can enhance collaboration, maintain
    code base integrity, and ensure the delivery of high-quality software.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will turn our attention to a critical aspect of the
    development process: code reviews. We will examine the importance of code reviews
    in ensuring code quality, fostering team collaboration, and enhancing overall
    productivity. By understanding best practices and effective strategies for conducting
    thorough and constructive code reviews, you will be well equipped to elevate the
    standards of your code base and contribute more effectively to your team’s success.
    Stay tuned as we embark on this insightful journey into the art and science of
    code reviews.'
  prefs: []
  type: TYPE_NORMAL
