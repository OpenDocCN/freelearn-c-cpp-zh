- en: General-Purpose Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用工具
- en: In this chapter, we are going to learn about the different functions that are
    used when performing different tasks. We will learn how to register functions
    that execute automatically when a program terminates. We will learn about functions
    that measure the clock ticks and CPU seconds required for the execution of certain
    tasks. We will also learn how to allocate memory at runtime, and then free it
    up when its task is over. Finally, we will learn how to handle different signals.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习在执行不同任务时使用的不同函数。我们将学习如何注册在程序终止时自动执行的函数。我们将学习关于测量特定任务执行所需的时钟滴答和CPU秒数的函数。我们还将学习如何在运行时分配内存，并在任务完成后释放它。最后，我们将学习如何处理不同的信号。
- en: 'In this chapter, we will dive into the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入以下食谱：
- en: Registering a function that is called when a program exits
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册在程序退出时调用的函数
- en: Measuring the clock ticks and CPU seconds required in the execution of a function
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量函数执行所需的时钟滴答和CPU秒数
- en: Performing dynamic memory allocation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行动态内存分配
- en: Handling signals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理信号
- en: However, before we proceed, a small introduction to dynamic memory allocation
    and some related functions is in order.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们继续之前，对动态内存分配和一些相关函数的简要介绍是必要的。
- en: Dynamic memory allocation
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态内存分配
- en: As the name suggests, **dynamic memory allocation** is the concept of allocating
    memory at runtime. Unlike static memory allocation, where the memory is prebooked,
    dynamic memory allocation can be booked as and when required. The size of memory
    that is statically allocated cannot be increased or decreased, whereas the size
    of dynamically allocated memory blocks can be increased and decreased as per your
    requirements. Additionally, when processing is over, the dynamically allocated
    memory can be freed so that it can be used by other applications. The following
    subsections describe several functions that are required in dynamic memory allocation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，**动态内存分配**是在运行时分配内存的概念。与预定的静态内存分配不同，动态内存分配可以根据需要随时预订。静态分配的内存大小不能增加或减少，而动态分配的内存块的大小可以根据您的需求增加或减少。此外，当处理完成后，动态分配的内存可以释放，以便其他应用程序可以使用。以下小节描述了动态内存分配所需的几个函数。
- en: malloc()
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: malloc()
- en: 'This function allocates memory dynamically, that is, during runtime. A block
    of memory of a given size in bytes is allocated and a pointer pointing to that
    block is returned. Here is its syntax:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数动态分配内存，即在运行时。分配给定大小的内存块（以字节为单位），并返回指向该块的指针。以下是它的语法：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This function doesn't initialize the allocated memory, as that memory block
    initially contains some garbage values.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数不会初始化分配的内存，因为该内存块最初包含一些垃圾值。
- en: calloc()
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: calloc()
- en: 'This function allocates multiple blocks of memory and returns a pointer pointing
    to that memory block. Here is its syntax:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数分配多个内存块，并返回指向该内存块的指针。以下是它的语法：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function initializes the allocated memory blocks to zero.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将分配的内存块初始化为零。
- en: realloc()
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: realloc()
- en: 'As the name suggests, this function is used to reallocate or resize the allocated
    memory. The reallocation of memory will not result in the loss of the existing
    data. Here is its syntax:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，此函数用于重新分配或调整分配的内存大小。内存重新分配不会导致现有数据的丢失。以下是它的语法：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `pointer` is a pointer to the existing allocated memory block. `new_blocksize`
    represents the new size of the block in bytes and can be smaller or larger than
    the existing allocated block size.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`pointer`是指向现有分配内存块的指针。`new_blocksize`表示以字节为单位的新块大小，可以比现有分配块大小小或大。
- en: free()
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: free()
- en: 'When the job or task assigned to the allocated block of memory is over, that
    memory block needs to be freed up so that it can be used by another application.
    To free up the dynamically allocated memory, the `free` function is used. Here
    is its syntax:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当分配的内存块中的任务或作业完成时，该内存块需要被释放，以便其他应用程序可以使用。为了释放动态分配的内存，使用`free`函数。以下是它的语法：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `pointer` represents the pointer to the allocated memory.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`pointer`代表指向分配内存的指针。
- en: Let's now begin with our first recipe!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始我们的第一个食谱！
- en: Registering a function that is called when a program exits
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册在程序退出时调用的函数
- en: Our first recipe will be to register a function that executes automatically
    when a program terminates normally. For this recipe, we will be using the `atexit()`
    function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一道菜谱将是注册一个在程序正常终止时自动执行的函数。为此菜谱，我们将使用`atexit()`函数。
- en: The `atexit` function is set to point to a function; this function is automatically
    called without arguments when the program terminates. If more than one `atexit`
    function is defined in a program, then these functions will be called in the **Last
    In, First Out** (**LIFO**) order, that is, the function pointed to last by the
    `atexit` function will be executed first, followed by the second to last one,
    and so on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`atexit`函数被设置为指向一个函数；这个函数在程序终止时将自动无参数调用。如果一个程序中定义了多个`atexit`函数，那么这些函数将以**后进先出**（**LIFO**）的顺序调用，即`atexit`函数最后指向的函数将首先执行，然后是倒数第二个，依此类推。'
- en: 'The `atexit` function accepts a single mandatory parameter: the pointer to
    the function to be called on program termination. Additionally, the function returns `0`
    if the function is registered successfully, that is, the function to be invoked
    is successfully pointed. The function returns a nonzero value if it is not registered.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`atexit`函数接受一个单一强制参数：程序终止时要调用的函数的指针。此外，如果函数注册成功，即要调用的函数成功指向，则函数返回`0`。如果没有注册，则函数返回非零值。'
- en: In this recipe, we will dynamically allocate some memory for accepting a string
    from the user. The string entered is displayed on the screen, and, when the program
    terminates, the registered function is automatically executed, which frees up
    the dynamically allocated memory.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将动态分配一些内存以接受用户输入的字符串。输入的字符串将在屏幕上显示，当程序终止时，注册的函数将自动执行，从而释放动态分配的内存。
- en: How to do it…
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to create a recipe that registers a function that executes
    automatically when a program terminates normally:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个注册程序正常终止时自动执行的函数的菜谱：
- en: Register a function using the `atexit` function.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`atexit`函数注册一个函数。
- en: Allocate some memory dynamically and allow that memory to be pointed to by a
    pointer.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态分配一些内存，并允许该内存通过指针指向。
- en: Ask the user to enter a string and assign the string to the dynamically allocated
    memory block.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求用户输入一个字符串，并将该字符串分配给动态分配的内存块。
- en: Display the entered string on the screen.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕上显示输入的字符串。
- en: When the program terminates, the function registered via the `atexit` function
    is invoked automatically.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序终止时，通过`atexit`函数注册的函数将自动调用。
- en: The registered function simply frees up the dynamically allocated memory so
    that it can be used by other applications.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册的函数简单地释放动态分配的内存，以便其他应用程序可以使用。
- en: 'The program for registering a function that automatically executes when a program
    terminates is as follows (`atexistprog1.c`):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注册程序在程序终止时自动执行的函数的程序如下（`atexistprog1.c`）：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using the `atexit` function, register a function called `freeup`, ensuring that
    the `freeup` function will be invoked if the program terminates normally. The
    value returned by the `atexit` function is checked to see that it is zero only.
    If the value returned by the `atexit` function is a nonzero value, then that means
    the function is not registered successfully and the program will terminate after
    displaying an error message.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`atexit`函数注册一个名为`freeup`的函数，确保如果程序正常终止，则`freeup`函数将被调用。检查`atexit`函数返回的值，确保它为零。如果`atexit`函数返回的值是非零值，则表示函数未成功注册，程序将在显示错误消息后终止。
- en: If the function is registered successfully, 20 bytes are dynamically allocated
    and the allocated memory block is assigned to a character pointer, `str`. If the
    `str` pointer is `NULL`, then this means an error has occurred in the allocation
    of the memory block. If it is confirmed that the `str` pointer is not `NULL` and
    is pointing to a memory block, the user will be asked to enter a string. The string
    entered by the user is assigned to the memory block pointed to by the `str` pointer.
    The string entered by the user is then displayed on the screen, and, finally,
    the program terminates. However, before the program terminates, the function that
    is registered using the `atexit` function, `freeup`, is invoked. The `freeup`
    function frees the memory allocated to the `str` pointer and displays a message: `Allocated
    memory is freed`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数注册成功，则动态分配 20 字节，并将分配的内存块赋值给字符指针 `str`。如果 `str` 指针为 `NULL`，则表示内存块分配过程中发生了错误。如果确认
    `str` 指针不为 `NULL` 并指向一个内存块，用户将被要求输入一个字符串。用户输入的字符串将被赋值给由 `str` 指针指向的内存块。然后，用户输入的字符串将在屏幕上显示，最后程序终止。然而，在程序终止之前，使用
    `atexit` 函数注册的 `freeup` 函数被调用。`freeup` 函数释放了分配给 `str` 指针的内存，并显示一条消息：“已分配的内存已释放”。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, the `atexistprog1.c` program has successfully
    compiled into a `.exe` file: `atexistprog1.exe`. Upon executing this file, the
    user is prompted to enter a string that is assigned to the dynamically allocated
    memory. On program termination, the function registered with `atexit` is executed,
    which frees up the dynamically allocated memory, as is confirmed by the text message
    in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用 GCC 编译，如下面的截图所示。因为在编译过程中没有出现错误，所以 `atexistprog1.c` 程序已成功编译成 `.exe` 文件：`atexistprog1.exe`。执行此文件时，用户将被提示输入一个字符串，该字符串将被分配给动态分配的内存。在程序终止时，使用
    `atexit` 注册的函数被执行，释放了动态分配的内存，如下面的截图中的文本消息所确认：
- en: '![](img/7d8abe93-f66d-4ca9-9e7c-e38eed4ae180.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d8abe93-f66d-4ca9-9e7c-e38eed4ae180.png)'
- en: Figure 14.1
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1
- en: Voilà! We have successfully registered a function that is called when the program
    exits.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Voilà! 我们已经成功注册了一个在程序退出时调用的函数。
- en: There's more...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If there is more than one function that is registered via the `atexit` function,
    then these functions will be executed in LIFO order. To understand this, let''s
    modify the preceding `atexistprog1.c` program to register two functions via the
    `atexit` function. We will save the modified program as `atexistprog2.c` as follows
    (`atexistprog2.c`):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过 `atexit` 函数注册了多个函数，那么这些函数将按照后进先出（LIFO）的顺序执行。为了理解这一点，让我们修改前面的 `atexistprog1.c`
    程序，通过 `atexit` 函数注册两个函数。我们将修改后的程序保存为 `atexistprog2.c`，如下所示（`atexistprog2.c`）：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On compiling and executing the program, we get the following output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并执行程序后，我们得到以下输出：
- en: '![](img/4379bed0-b65e-4b7c-b4b6-639f3db57ab8.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4379bed0-b65e-4b7c-b4b6-639f3db57ab8.png)'
- en: Figure 14.2
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2
- en: This output confirms that the last registered function, `freeup2`, is executed
    first, followed by the first registered function, `freeup1`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出确认了最后注册的函数 `freeup2` 首先执行，然后是第一个注册的函数 `freeup1`。
- en: Now, let's move on to the next recipe!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个菜谱！
- en: Measuring the clock ticks and CPU seconds required in the execution of a function
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量函数执行所需的时钟滴答和 CPU 秒数
- en: In this recipe, we will learn how to find out the clock ticks and CPU seconds
    that are required in the execution of a function. We will create a program that
    contains a function. This function will simply run a nested loop and we will find
    out the time required to run it. To do so, we will make use of the `clock()` function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何找出函数执行所需的时钟滴答和 CPU 秒数。我们将创建一个包含函数的程序。这个函数将简单地运行一个嵌套循环，我们将找出运行它所需的时间。为此，我们将使用
    `clock()` 函数。
- en: The `clock()` function returns the processor time that is consumed by the program.
    Essentially, this time is dependent on the technique that the operating system
    uses in allocating the resources to the process. More precisely, the function
    returns the number of clock ticks elapsed from the time the program is invoked.
    The function does not require any parameters and returns either the processor
    time that is required in running certain statements or returns `-1` if there is
    any failure.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`clock()`函数返回程序消耗的处理器时间。本质上，这个时间取决于操作系统在分配资源给进程时使用的技巧。更精确地说，该函数返回从程序被调用时开始经过的时钟滴答数。该函数不需要任何参数，并返回运行某些语句所需的处理器时间，或者在出现任何故障时返回`-1`。'
- en: The time returned by the function is measured in `CLOCKS_PER_SECs` of a second,
    where `CLOCKS_PER_SEC` varies as per the operating system and its value is around
    1,000,000\. So, in order to find the number of seconds used by the CPU, the number
    of clock ticks returned by the function is divided by `CLOCKS_PER_SEC`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回的时间以每秒`CLOCKS_PER_SEC`的`CLOCKS_PER_SEC`来衡量，其中`CLOCKS_PER_SEC`根据操作系统而变化，其值大约为1,000,000。因此，为了找到CPU使用的秒数，需要将函数返回的时钟滴答数除以`CLOCKS_PER_SEC`。
- en: The value returned by the `clock()` function is of the `clock_t` data type.
    The `clock_t` data type is used to represent the processor time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`clock()`函数返回的值是`clock_t`数据类型。`clock_t`数据类型用于表示处理器时间。'
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to find out the number of clock ticks and CPU seconds required
    to run a function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤查找运行函数所需的时钟滴答数和CPU秒数：
- en: Define two variables of the `clock_t` data type for saving processor time.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个`clock_t`数据类型的变量来保存处理器时间。
- en: Invoke the `clock()` function to discern the number of clock ticks elapsed from
    the time the program is invoked. The clock ticks are saved in one of the variables.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`clock()`函数以确定从程序被调用时开始经过的时钟滴答数。时钟滴答数保存在其中一个变量中。
- en: Invoke a function whose processing time has to be established.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用一个需要确定其处理时间的函数。
- en: Again, invoke the `clock()` function and then save the returned number of clock
    ticks to another variable.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次调用`clock()`函数，并将返回的时钟滴答数保存到另一个变量中。
- en: Subtract the number of clock ticks in the two variables to discern the number
    of clock ticks required to execute the function.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从两个变量中的时钟滴答数中减去，以确定执行函数所需的时钟滴答数。
- en: Divide the number of clock ticks returned in the preceding steps by `CLOCKS_PER_SEC`
    to identify the number of seconds used by the function.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前一步返回的时钟滴答数除以`CLOCKS_PER_SEC`，以确定函数使用的秒数。
- en: Both the number of clock ticks and the CPU seconds required to execute the function
    are displayed on the screen.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 屏幕上显示函数所需的时钟滴答数和CPU秒数。
- en: 'The program for knowing the number of clock ticks and CPU seconds required
    in executing a function is as follows (`timecalc.c`):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 知道执行函数所需的时钟滴答数和CPU秒数的程序如下（`timecalc.c`）：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解幕后，以便更好地理解代码。
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Define two variables, `clocktickstart` and `clocktickend`, of the `clock_t`
    data type, as they will be used to represent the processor time. The main idea
    of this program is to ascertain the time consumed during the execution of a function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 定义两个`clock_t`数据类型的变量，`clocktickstart`和`clocktickend`，因为它们将用于表示处理器时间。这个程序的主要思想是确定函数执行过程中消耗的时间。
- en: The `clock` function is invoked to know the number of clock ticks elapsed from
    the time the program is invoked. Assign the number of clock ticks returned to
    a `clocktickstart` variable. Then, invoke a `somefunction()` function, which includes
    a nested `for` loop. The idea of using nested loops is just to make the CPU invest
    some time in executing these loops. After the `somefunction` function is over,
    invoke the `clock()` function, and assign the number of clock ticks elapsed from
    the time the program is invoked to the `clocktickend` variable. The difference
    between the `clocktickend` and `clocktickstart` variables will give us the number
    of clock ticks used in executing the `somefunction` function. The number of clock
    ticks is then divided by `CLOCKS_PER_SEC` to distinguish the number of CPU seconds
    used to execute the function. Finally, the number of clock ticks used in executing
    the `somefunction` function and the CPU seconds used by it are displayed on the
    screen.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`clock`函数是为了知道从程序被调用以来经过的时钟滴答数。将返回的时钟滴答数赋值给`clocktickstart`变量。然后，调用一个`somefunction()`函数，该函数包含一个嵌套的`for`循环。使用嵌套循环的目的是让CPU在执行这些循环上投入一些时间。`somefunction`函数执行完毕后，再次调用`clock()`函数，并将从程序调用以来经过的时钟滴答数赋值给`clocktickend`变量。`clocktickend`和`clocktickstart`变量之间的差值将给出执行`somefunction`函数所使用的时钟滴答数。然后，将时钟滴答数除以`CLOCKS_PER_SEC`以区分执行函数所使用的CPU秒数。最后，将执行`somefunction`函数所使用的时钟滴答数和它所使用的CPU秒数显示在屏幕上。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, the `timecalc.c` program is successfully
    compiled into a `.exe` file: `timecalc.exe`. Upon executing this file, the number
    of clock ticks and the number of CPU seconds required in the execution of the
    specific function in the program are displayed on the screen as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用GCC编译，如下所示。由于编译过程中没有出现错误，`timecalc.c`程序成功编译成`.exe`文件：`timecalc.exe`。执行此文件后，屏幕上会显示程序中特定函数执行所需的时钟滴答数和CPU秒数，如下所示：
- en: '![](img/f3e91a19-d7c9-4959-8ddf-b82e83f5363c.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f3e91a19-d7c9-4959-8ddf-b82e83f5363c.png)'
- en: Figure 14.3
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3
- en: Now, let's move on to the next recipe!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个配方！
- en: Performing dynamic memory allocation
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行动态内存分配
- en: In this recipe, we will learn how to dynamically allocate some memory. We will
    also learn how to increase the number of memory blocks, how to decrease the number
    of allocated memory blocks, and how to free up memory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习如何动态分配一些内存。我们还将学习如何增加内存块的数量，如何减少已分配内存块的数量，以及如何释放内存。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will ask the user how many memory blocks need to be allocated, and we will dynamically
    allocate that number of memory blocks. The user will then be asked to assign integer
    values to those memory blocks. After that, the user will be asked how many more
    additional blocks need to be allocated. Similarly, the user will be asked how
    many memory blocks need to be reduced too. The following are the steps to be performed
    in order to dynamically allocate memory, by increasing and decreasing memory blocks:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将询问用户需要分配多少内存块，并将动态分配相应数量的内存块。然后，将要求用户将这些内存块分配整数值。之后，将询问用户还需要分配多少额外的内存块。同样，将询问用户需要减少多少内存块。以下是通过增加和减少内存块动态分配内存的步骤：
- en: The user is asked to enter an integer value, and that number of memory blocks
    will be dynamically allocated by invoking the `calloc` function. Each allocated
    memory block will be capable of storing a numerical of the integer data type.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户被要求输入一个整数值，然后通过调用`calloc`函数动态分配相应数量的内存块。每个分配的内存块将能够存储整数数据类型的数值。
- en: The user is then asked to enter values in the dynamically allocated memory blocks.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将要求用户在动态分配的内存块中输入值。
- en: Display the integer values on the screen that are assigned to the memory blocks.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示分配给内存块的整数值。
- en: Ask the user how many more memory blocks need to be added.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问用户还需要添加多少内存块。
- en: Invoke the `realloc` function to increase the number of allocated memory blocks.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`realloc`函数来增加已分配内存块的数量。
- en: Ask the user to enter the integer values in the newly added memory blocks.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要求用户在新增的内存块中输入整数值。
- en: Display all the integer values assigned to the memory blocks.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示分配给内存块的整数值。
- en: Ask the user how many of the available memory blocks are required.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问用户需要多少可用的内存块。
- en: Again, invoke the `realloc` function to reduce the number of allocated memory
    blocks.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次调用`realloc`函数以减少分配的内存块数量。
- en: Display the integer values available in the existing memory blocks.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示现有内存块中可用的整数值。
- en: Free up all of the memory blocks so that they can be used by other applications.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放所有内存块，以便其他应用程序可以使用。
- en: 'The program for showing the benefits of dynamic memory allocation, that is,
    how the memory can be allocated at runtime, and how its size can be increased
    or decreased and is freed, is as follows (`dynamicmem.c`):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 显示动态内存分配优势的程序，即如何在运行时分配内存，以及如何增加或减少其大小并释放它，如下所示（`dynamicmem.c`）：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码背后的原理。
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The user will be asked to specify the number of elements. The value entered
    by the user will be assigned to the variable `n`. Let's assume the value entered
    by the user is `4`, which is then assigned to the variable `n`. Using the `calloc`
    function, `4` memory blocks are dynamically allocated, where the size of each
    memory block is equal to the size consumed by an `int` data type. In other words,
    a memory block that can store four integer values is dynamically allocated and
    a pointer, `ptr`, is set to point to it. If the `ptr` pointer is `NULL`, then
    this means that the memory could not be allocated and the program will terminate
    after displaying an error message.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户指定的元素数量分配给变量`n`。假设用户输入的值是`4`，然后将其分配给变量`n`。使用`calloc`函数，动态分配了`4`个内存块，每个内存块的大小等于`int`数据类型消耗的大小。换句话说，动态分配了一个可以存储四个整数值的内存块，并将指针`ptr`设置为指向它。如果`ptr`指针是`NULL`，则这意味着内存无法分配，程序将在显示错误消息后终止。
- en: If the memory is successfully allocated, the user will be asked to enter four
    integer values. The values entered will be assigned to individual memory blocks
    pointed to by the pointer, `ptr`. The integer values entered by the user are then
    displayed on the screen. The user will then be asked if they want to add more
    elements. Assuming that the user wants to add two more memory blocks to the existing
    allocated ones, the value of `2` entered by the user will be assigned to the variable
    `m`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内存分配成功，将要求用户输入四个整数值。输入的值将被分配给由指针`ptr`指向的各个内存块。然后，在屏幕上显示用户输入的整数值。随后将询问用户是否想要添加更多元素。假设用户想要将两个额外的内存块添加到现有的已分配内存块中，用户输入的`2`值将被分配给变量`m`。
- en: Using the `realloc` function, the quantity of the memory blocks increases from
    four to six, where each memory block is able to store an integer number. The user
    will be asked to enter the integer values for two newly added memory blocks. To
    indicate that the size of memory blocks has increased from four to six, all of
    the six integers assigned to the memory blocks are displayed on the screen. Thereafter,
    the user will be asked how many blocks they want to keep out of the six memory
    blocks. Let's assume the value entered by the user is `3`; that is, the user wants
    to keep the integers in the first three memory blocks and discard the rest.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`realloc`函数，内存块的数量从四个增加到六个，其中每个内存块能够存储一个整数。将要求用户输入两个新添加的内存块中的整数值。为了表示内存块的大小已从四个增加到六个，将显示分配给六个内存块的所有六个整数。之后，将询问用户想要保留多少个内存块中的六个内存块。假设用户输入的值是`3`；即用户想要保留前三个内存块中的整数，并丢弃其余的。
- en: The value of `3` entered by the user will be assigned to the variable `m`. Again,
    the `realloc` function is invoked to reduce the number of memory blocks from six
    to three. Finally, the integers in the three memory blocks are displayed on the
    screen.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入的`3`值将被分配给变量`m`。再次调用`realloc`函数，将内存块的数量从六个减少到三个。最后，在屏幕上显示三个内存块中的整数。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, the `dynamicmem.c` program has successfully
    compiled into a `.exe` file: `dynamicmem.exe`. Upon executing this file, the user
    is prompted to define how many memory blocks they want to dynamically allocate.
    After that, the user is asked how many additional memory blocks they want. The
    user is also asked whether they want to keep some memory blocks active from the
    total, thereby reducing the number of allocated memory blocks, and, finally, all
    the memory blocks are freed. All of the actions appear as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用GCC编译，如下面的截图所示。由于编译过程中没有出现错误，`dynamicmem.c` 程序已成功编译成 `.exe` 文件：`dynamicmem.exe`。执行此文件后，用户会被提示定义他们想要动态分配多少内存块。之后，用户会被问及他们想要多少额外的内存块。用户还会被问及是否希望从总数中保留一些内存块以保持活跃，从而减少分配的内存块数量，最后，所有内存块都会被释放。所有这些操作如下所示：
- en: '![](img/2835e744-847e-410d-b0ac-d25c63e6bc80.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2835e744-847e-410d-b0ac-d25c63e6bc80.png)'
- en: Figure 14.4
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4
- en: Now, let's move on to the next recipe!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个食谱！
- en: Handling signals
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理信号
- en: In this recipe, we will learn signal handling. We will learn how to automatically
    raise a signal, how signals are raised by user actions, and how signals are directed
    to specific signal-handling functions. Signal handling is required to take necessary
    action when the signal occurs. The actions may include ignoring the signal, terminating
    the process, blocking or suspending a process, resuming a process, and many more.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习信号处理。我们将学习如何自动引发信号，用户如何通过操作引发信号，以及信号如何被引导到特定的信号处理函数。信号处理需要在信号发生时采取必要的行动。这些行动可能包括忽略信号、终止进程、阻塞或挂起进程、恢复进程等等。
- en: Let's start with a quick overview of signals before we dive into the recipe.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入到食谱之前，让我们先快速了解一下信号。
- en: Signals
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号
- en: A signal is an indicator that is generated through software and is used to stop
    the usual execution of the program, and through a branch of CPU to perform some
    specific tasks. The signal can be generated either by a process or when the user
    presses *Ctrl *+ *C*. When something goes wrong or some error occurs while executing
    an operation, the signal acts as a medium of communication between the process
    and the operating system. The signal is raised by the operating system and is
    forwarded to the process to take necessary actions. Essentially, a corresponding
    signal handler is executed as a corrective measure.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是通过软件生成的指示器，用于停止程序的常规执行，并通过CPU的一个分支执行一些特定任务。信号可以由进程生成，或者当用户按下 *Ctrl* + *C*
    时生成。当执行操作时出现错误或发生某些错误时，信号充当进程和操作系统之间的通信媒介。信号由操作系统引发，并转发给进程以采取必要的行动。本质上，执行相应的信号处理程序作为纠正措施。
- en: 'The following are some of the important signals that you should be aware of:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你应该了解的重要信号：
- en: '**SIGABRT** (**Signal Abort**): This signal reports the abnormal termination
    of the program. The signal is raised in the case of critical errors; for example,
    if an assertion fails or memory could not be allocated, or any similar memory
    heap errors.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SIGABRT**（**信号终止**）：此信号报告程序的异常终止。在出现关键错误的情况下会引发此信号；例如，如果断言失败或无法分配内存，或者任何类似的内存堆错误。'
- en: '**SIGFPE** (**Signal Floating-Point Exception**): This signal reports an arithmetic
    error. Any arithmetic error, including overflow or divide by zero, is covered
    by this signal.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SIGFPE**（**信号浮点异常**）：此信号报告算术错误。任何算术错误，包括溢出或除以零，都包含在此信号中。'
- en: '**SIGILL** (**Signal Illegal Instruction**): This signal reports illegal instructions.
    Such a signal is raised when the program tries to execute data or an executable
    file is corrupted. In other words, the signal is raised when the program is trying
    to execute a nonexecutable instruction.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SIGILL**（**信号非法指令**）：此信号报告非法指令。当程序尝试执行数据或可执行文件损坏时，会引发此类信号。换句话说，当程序尝试执行非可执行指令时，会引发此信号。'
- en: '**SIGINT** (**Signal Interrupt**): This is a program interrupt signal that
    is generated by the user by pressing *Ctrl* + *C*.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SIGINT**（**信号中断**）：这是由用户通过按下 *Ctrl* + *C* 生成的程序中断信号。'
- en: '**SIGSEGV** (**Signal Segmentation Violation**): This signal is raised when
    the program tries to write into read-only memory or into a block that does not
    have write permissions. The signal is also raised when a program tries to read
    or write into memory that is outside the range that is allocated to it.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SIGSEGV**（**信号段违规**）：当程序尝试写入只读内存或没有写权限的块时，会触发此信号。当程序尝试读取或写入分配给它范围之外的内存时，也会触发此信号。'
- en: '**SIGTERM** (**Signal Terminate**): This is a termination signal that is sent
    to a process in order to terminate it.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SIGTERM**（**信号终止**）：这是一个发送给进程以终止它的终止信号。'
- en: To handle signals in a program, the `signal()` function is used. Let's look
    at a quick introduction to the signal function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要在程序中处理信号，使用 `signal()` 函数。让我们快速了解一下信号函数。
- en: signal()
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: signal()
- en: 'The signal function directs the occurrence of the signal to any of the following
    signal handlers:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 信号函数将信号的发生指向以下任一信号处理函数：
- en: '`SIG_IGN`: This will result in the signal being ignored.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIG_IGN`：这将导致信号被忽略。'
- en: '`SIG_DFL`: This will result in invoking the default action that is associated
    with the raised signal.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIG_DFL`：这将导致调用与触发信号关联的默认动作。'
- en: '`user_defined_function`: This will result in the invoking of the user-defined
    function when the signal is raised.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_defined_function`：这将导致在信号被触发时调用用户定义的函数。'
- en: Now, let's begin with the recipe.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始编写步骤。
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following are the steps for associating signals to signal-handling functions,
    automatically raise the signals, and get the desired actions performed when signals
    are raised by user actions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将信号关联到信号处理函数、自动触发信号以及当用户触发信号时执行所需动作的步骤如下：
- en: Associate a signal interrupt, `(SIGINT)`, to a function. This function will
    act as a signal handler.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个信号中断 `(SIGINT)` 关联到一个函数。这个函数将作为信号处理函数。
- en: Write some code in the signal handler function.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在信号处理函数中编写一些代码。
- en: In the `main` function, make a `while` loop that executes 5 times. You can make
    the `while` loop run for as many times as you want. The `while` loop is set to
    display a text message after a delay of 1 second.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，创建一个执行5次的 `while` 循环。你可以让 `while` 循环运行任意次数。`while` 循环被设置为在延迟1秒后显示一条文本消息。
- en: The idea is to automatically raise the signal after 5 seconds. So, after its
    5 iterations, the `while` loop ends and the interrupt signal is automatically
    raised.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 策略是在5秒后自动触发信号。因此，在经过5次迭代后，`while` 循环结束，中断信号被自动触发。
- en: The associated signal handler function is executed.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行相关的信号处理函数。
- en: After executing the code in the signal handler, in the `main` function, again,
    associate a signal interrupt, `(SIGINT)`, with another signal handler function.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在信号处理函数中执行代码后，在 `main` 函数中，再次将信号中断 `(SIGINT)` 关联到另一个信号处理函数。
- en: Set an infinite `while` loop to execute, which displays a text message after
    each delay of 1 second.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个无限 `while` 循环执行，每次延迟1秒后显示一条文本消息。
- en: If the user presses *Ctrl* + *C* , the signal interrupt is raised and the associated
    signal handler is raised.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户按下 *Ctrl* + *C*，则信号中断被触发，并调用相关的信号处理函数。
- en: In the signal handler, we associate the signal interrupt with its default action.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在信号处理函数中，我们将信号中断与其默认动作关联。
- en: 'Consequently, if the user presses *Ctrl* + *C* again, that is, if the signal
    interrupt is raised again, the default action will take place: the program will
    terminate.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，如果用户再次按下 *Ctrl* + *C*，即如果信号中断再次被触发，将执行默认动作：程序将终止。
- en: 'The program for showing how the signals are automatically raised, how signals
    are raised by the user, and how they are handled, is as follows (`signalhandling.c`):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 显示信号如何自动触发、用户如何触发信号以及如何处理的程序如下（`signalhandling.c`）：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后了解代码，以便更好地理解。
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Using the `signal` function, a signal interrupt, `(SIGINT)`, is associated
    with a function called `signalhandler1`. That is, if the interrupt is autogenerated
    or is generated by the user, the `sighandler1` function will be invoked. A counter, `x`,
    is initialized to `1` and a `while` loop is set to execute until the value of
    counter `x` becomes larger than `5`. Within the `while` loop, the following text
    is displayed: `Signal will be raised automatically after 5 seconds`. In addition
    to this, the value of counter `x` is incremented by `1` within the `while` loop.
    A delay of 1 second is inserted in the `while` loop. In short, the `while` loop
    will display a text message after a gap of 1 second each. After displaying the
    text message 5 times, the `raise` function is invoked to raise the `SIGINT` signal.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `signal` 函数，将信号中断 `(SIGINT)` 与名为 `signalhandler1` 的函数关联。也就是说，如果中断是自动生成的或是由用户生成的，`sighandler1`
    函数将被调用。计数器 `x` 被初始化为 `1`，并设置一个 `while` 循环执行，直到计数器 `x` 的值大于 `5`。在 `while` 循环中，显示以下文本：“信号将在
    5 秒后自动提升”。此外，在 `while` 循环中，计数器 `x` 的值增加 `1`。在 `while` 循环中插入 1 秒的延迟。简而言之，`while`
    循环将在每次间隔 1 秒后显示一条文本消息。在显示文本消息 5 次后，调用 `raise` 函数提升 `SIGINT` 信号。
- en: 'On raising the `SIGINT` signal, the `signalhandler1` function will be invoked.
    The `signalhandler1` function does nothing other than display a text message:
    `Ctrl+C is auto pressed`. After executing the `signalhandler1` function, the control
    resumes executing the statements in the `main` function. Again, the `signal` function
    is invoked and the `SIGINT` signal is associated with the `sighandler2` function. Once
    more, a `while` loop is set to execute; however, this time, the loop will run
    indefinitely. Within the `while` loop, a text message, `Infinite loop, press Ctrl+C
    to raise signal`, is displayed. After displaying the text message, a delay of
    1 second is inserted; that is, the text message will keep on displaying indefinitely
    after a gap of 1 second. If the user presses *Ctrl* + *C*, the signal interrupt
    will be raised and the `sighandler2` function will be invoked.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当提升 `SIGINT` 信号时，将调用 `signalhandler1` 函数。`signalhandler1` 函数除了显示一条文本消息：“Ctrl+C
    已自动按下”外，不做任何操作。执行 `signalhandler1` 函数后，控制权恢复执行 `main` 函数中的语句。再次调用 `signal` 函数并将
    `SIGINT` 信号与 `sighandler2` 函数关联。再次设置一个 `while` 循环执行；然而，这次循环将无限运行。在 `while` 循环中，显示一条文本消息：“无限循环，按
    Ctrl+C 生成信号”。在显示文本消息后，插入 1 秒的延迟；也就是说，在 1 秒的间隔后，文本消息将无限期地显示。如果用户按下 *Ctrl* + *C*，将提升信号中断并调用
    `sighandler2` 函数。
- en: In the `sighandler2` function, a text message, `You have pressed Ctrl+C`, is
    displayed on one line and, on the next line, `Press Ctrl+C again to exit` is displayed.
    Thereafter, the `signal` function is invoked to set the `SIGINT` signal to take
    the default action. The default action of the `SIGINT` interrupt is to terminate
    and exit from the program. This means that if the user again presses *Ctrl* +
    *C*, the program will terminate.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sighandler2` 函数中，一行显示一条文本消息，“您已按下 Ctrl+C”，下一行显示“再次按 Ctrl+C 退出”。之后，调用 `signal`
    函数将 `SIGINT` 信号设置为默认操作。`SIGINT` 中断的默认操作是终止并退出程序。这意味着如果用户再次按下 *Ctrl* + *C*，程序将终止。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, the `signalhandling.c` program has successfully
    compiled into a `.exe` file: `signalhandling.exe`. Upon executing this file, five
    text messages are displayed on the screen through the first `while` loop. After
    that, the signal is automatically raised and the text message from the first signal
    handler appears on the screen. Thereafter, a text message from the infinite `while`
    loop appears. Finally, the output from the second signal handler appears, which
    is executed when the signal interrupt is generated by the user.  All of the actions
    appear as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序使用 GCC 进行编译，如下所示截图。由于编译过程中没有出现错误，`signalhandling.c` 程序已成功编译成 `.exe` 文件：`signalhandling.exe`。执行此文件后，通过第一个
    `while` 循环在屏幕上显示五条文本消息。之后，信号自动提升，第一个信号处理器的文本消息出现在屏幕上。然后，无限 `while` 循环的文本消息出现。最后，当用户生成信号中断时，第二个信号处理器的输出出现。所有动作如下所示：
- en: '![](img/18d32e1f-2fb8-4b38-a22e-daf2e0eacff0.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18d32e1f-2fb8-4b38-a22e-daf2e0eacff0.png)'
- en: Figure 14.5
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5
- en: Voilà! We have successfully handled signals.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Voilà！我们已经成功处理了信号。
