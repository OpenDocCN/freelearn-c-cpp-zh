- en: General-Purpose Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn about the different functions that are
    used when performing different tasks. We will learn how to register functions
    that execute automatically when a program terminates. We will learn about functions
    that measure the clock ticks and CPU seconds required for the execution of certain
    tasks. We will also learn how to allocate memory at runtime, and then free it
    up when its task is over. Finally, we will learn how to handle different signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will dive into the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Registering a function that is called when a program exits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring the clock ticks and CPU seconds required in the execution of a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing dynamic memory allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, before we proceed, a small introduction to dynamic memory allocation
    and some related functions is in order.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic memory allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, **dynamic memory allocation** is the concept of allocating
    memory at runtime. Unlike static memory allocation, where the memory is prebooked,
    dynamic memory allocation can be booked as and when required. The size of memory
    that is statically allocated cannot be increased or decreased, whereas the size
    of dynamically allocated memory blocks can be increased and decreased as per your
    requirements. Additionally, when processing is over, the dynamically allocated
    memory can be freed so that it can be used by other applications. The following
    subsections describe several functions that are required in dynamic memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: malloc()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function allocates memory dynamically, that is, during runtime. A block
    of memory of a given size in bytes is allocated and a pointer pointing to that
    block is returned. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This function doesn't initialize the allocated memory, as that memory block
    initially contains some garbage values.
  prefs: []
  type: TYPE_NORMAL
- en: calloc()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This function allocates multiple blocks of memory and returns a pointer pointing
    to that memory block. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function initializes the allocated memory blocks to zero.
  prefs: []
  type: TYPE_NORMAL
- en: realloc()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, this function is used to reallocate or resize the allocated
    memory. The reallocation of memory will not result in the loss of the existing
    data. Here is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, `pointer` is a pointer to the existing allocated memory block. `new_blocksize`
    represents the new size of the block in bytes and can be smaller or larger than
    the existing allocated block size.
  prefs: []
  type: TYPE_NORMAL
- en: free()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the job or task assigned to the allocated block of memory is over, that
    memory block needs to be freed up so that it can be used by another application.
    To free up the dynamically allocated memory, the `free` function is used. Here
    is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `pointer` represents the pointer to the allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now begin with our first recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Registering a function that is called when a program exits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first recipe will be to register a function that executes automatically
    when a program terminates normally. For this recipe, we will be using the `atexit()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The `atexit` function is set to point to a function; this function is automatically
    called without arguments when the program terminates. If more than one `atexit`
    function is defined in a program, then these functions will be called in the **Last
    In, First Out** (**LIFO**) order, that is, the function pointed to last by the
    `atexit` function will be executed first, followed by the second to last one,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `atexit` function accepts a single mandatory parameter: the pointer to
    the function to be called on program termination. Additionally, the function returns `0`
    if the function is registered successfully, that is, the function to be invoked
    is successfully pointed. The function returns a nonzero value if it is not registered.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will dynamically allocate some memory for accepting a string
    from the user. The string entered is displayed on the screen, and, when the program
    terminates, the registered function is automatically executed, which frees up
    the dynamically allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create a recipe that registers a function that executes
    automatically when a program terminates normally:'
  prefs: []
  type: TYPE_NORMAL
- en: Register a function using the `atexit` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocate some memory dynamically and allow that memory to be pointed to by a
    pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask the user to enter a string and assign the string to the dynamically allocated
    memory block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the entered string on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the program terminates, the function registered via the `atexit` function
    is invoked automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The registered function simply frees up the dynamically allocated memory so
    that it can be used by other applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for registering a function that automatically executes when a program
    terminates is as follows (`atexistprog1.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `atexit` function, register a function called `freeup`, ensuring that
    the `freeup` function will be invoked if the program terminates normally. The
    value returned by the `atexit` function is checked to see that it is zero only.
    If the value returned by the `atexit` function is a nonzero value, then that means
    the function is not registered successfully and the program will terminate after
    displaying an error message.
  prefs: []
  type: TYPE_NORMAL
- en: If the function is registered successfully, 20 bytes are dynamically allocated
    and the allocated memory block is assigned to a character pointer, `str`. If the
    `str` pointer is `NULL`, then this means an error has occurred in the allocation
    of the memory block. If it is confirmed that the `str` pointer is not `NULL` and
    is pointing to a memory block, the user will be asked to enter a string. The string
    entered by the user is assigned to the memory block pointed to by the `str` pointer.
    The string entered by the user is then displayed on the screen, and, finally,
    the program terminates. However, before the program terminates, the function that
    is registered using the `atexit` function, `freeup`, is invoked. The `freeup`
    function frees the memory allocated to the `str` pointer and displays a message: `Allocated
    memory is freed`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, the `atexistprog1.c` program has successfully
    compiled into a `.exe` file: `atexistprog1.exe`. Upon executing this file, the
    user is prompted to enter a string that is assigned to the dynamically allocated
    memory. On program termination, the function registered with `atexit` is executed,
    which frees up the dynamically allocated memory, as is confirmed by the text message
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d8abe93-f66d-4ca9-9e7c-e38eed4ae180.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We have successfully registered a function that is called when the program
    exits.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If there is more than one function that is registered via the `atexit` function,
    then these functions will be executed in LIFO order. To understand this, let''s
    modify the preceding `atexistprog1.c` program to register two functions via the
    `atexit` function. We will save the modified program as `atexistprog2.c` as follows
    (`atexistprog2.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'On compiling and executing the program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4379bed0-b65e-4b7c-b4b6-639f3db57ab8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2
  prefs: []
  type: TYPE_NORMAL
- en: This output confirms that the last registered function, `freeup2`, is executed
    first, followed by the first registered function, `freeup1`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the clock ticks and CPU seconds required in the execution of a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to find out the clock ticks and CPU seconds
    that are required in the execution of a function. We will create a program that
    contains a function. This function will simply run a nested loop and we will find
    out the time required to run it. To do so, we will make use of the `clock()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `clock()` function returns the processor time that is consumed by the program.
    Essentially, this time is dependent on the technique that the operating system
    uses in allocating the resources to the process. More precisely, the function
    returns the number of clock ticks elapsed from the time the program is invoked.
    The function does not require any parameters and returns either the processor
    time that is required in running certain statements or returns `-1` if there is
    any failure.
  prefs: []
  type: TYPE_NORMAL
- en: The time returned by the function is measured in `CLOCKS_PER_SECs` of a second,
    where `CLOCKS_PER_SEC` varies as per the operating system and its value is around
    1,000,000\. So, in order to find the number of seconds used by the CPU, the number
    of clock ticks returned by the function is divided by `CLOCKS_PER_SEC`.
  prefs: []
  type: TYPE_NORMAL
- en: The value returned by the `clock()` function is of the `clock_t` data type.
    The `clock_t` data type is used to represent the processor time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to find out the number of clock ticks and CPU seconds required
    to run a function:'
  prefs: []
  type: TYPE_NORMAL
- en: Define two variables of the `clock_t` data type for saving processor time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `clock()` function to discern the number of clock ticks elapsed from
    the time the program is invoked. The clock ticks are saved in one of the variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke a function whose processing time has to be established.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, invoke the `clock()` function and then save the returned number of clock
    ticks to another variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subtract the number of clock ticks in the two variables to discern the number
    of clock ticks required to execute the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Divide the number of clock ticks returned in the preceding steps by `CLOCKS_PER_SEC`
    to identify the number of seconds used by the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both the number of clock ticks and the CPU seconds required to execute the function
    are displayed on the screen.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for knowing the number of clock ticks and CPU seconds required
    in executing a function is as follows (`timecalc.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Define two variables, `clocktickstart` and `clocktickend`, of the `clock_t`
    data type, as they will be used to represent the processor time. The main idea
    of this program is to ascertain the time consumed during the execution of a function.
  prefs: []
  type: TYPE_NORMAL
- en: The `clock` function is invoked to know the number of clock ticks elapsed from
    the time the program is invoked. Assign the number of clock ticks returned to
    a `clocktickstart` variable. Then, invoke a `somefunction()` function, which includes
    a nested `for` loop. The idea of using nested loops is just to make the CPU invest
    some time in executing these loops. After the `somefunction` function is over,
    invoke the `clock()` function, and assign the number of clock ticks elapsed from
    the time the program is invoked to the `clocktickend` variable. The difference
    between the `clocktickend` and `clocktickstart` variables will give us the number
    of clock ticks used in executing the `somefunction` function. The number of clock
    ticks is then divided by `CLOCKS_PER_SEC` to distinguish the number of CPU seconds
    used to execute the function. Finally, the number of clock ticks used in executing
    the `somefunction` function and the CPU seconds used by it are displayed on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, the `timecalc.c` program is successfully
    compiled into a `.exe` file: `timecalc.exe`. Upon executing this file, the number
    of clock ticks and the number of CPU seconds required in the execution of the
    specific function in the program are displayed on the screen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3e91a19-d7c9-4959-8ddf-b82e83f5363c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Performing dynamic memory allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to dynamically allocate some memory. We will
    also learn how to increase the number of memory blocks, how to decrease the number
    of allocated memory blocks, and how to free up memory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will ask the user how many memory blocks need to be allocated, and we will dynamically
    allocate that number of memory blocks. The user will then be asked to assign integer
    values to those memory blocks. After that, the user will be asked how many more
    additional blocks need to be allocated. Similarly, the user will be asked how
    many memory blocks need to be reduced too. The following are the steps to be performed
    in order to dynamically allocate memory, by increasing and decreasing memory blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: The user is asked to enter an integer value, and that number of memory blocks
    will be dynamically allocated by invoking the `calloc` function. Each allocated
    memory block will be capable of storing a numerical of the integer data type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is then asked to enter values in the dynamically allocated memory blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the integer values on the screen that are assigned to the memory blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask the user how many more memory blocks need to be added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `realloc` function to increase the number of allocated memory blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask the user to enter the integer values in the newly added memory blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display all the integer values assigned to the memory blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask the user how many of the available memory blocks are required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, invoke the `realloc` function to reduce the number of allocated memory
    blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the integer values available in the existing memory blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Free up all of the memory blocks so that they can be used by other applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for showing the benefits of dynamic memory allocation, that is,
    how the memory can be allocated at runtime, and how its size can be increased
    or decreased and is freed, is as follows (`dynamicmem.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user will be asked to specify the number of elements. The value entered
    by the user will be assigned to the variable `n`. Let's assume the value entered
    by the user is `4`, which is then assigned to the variable `n`. Using the `calloc`
    function, `4` memory blocks are dynamically allocated, where the size of each
    memory block is equal to the size consumed by an `int` data type. In other words,
    a memory block that can store four integer values is dynamically allocated and
    a pointer, `ptr`, is set to point to it. If the `ptr` pointer is `NULL`, then
    this means that the memory could not be allocated and the program will terminate
    after displaying an error message.
  prefs: []
  type: TYPE_NORMAL
- en: If the memory is successfully allocated, the user will be asked to enter four
    integer values. The values entered will be assigned to individual memory blocks
    pointed to by the pointer, `ptr`. The integer values entered by the user are then
    displayed on the screen. The user will then be asked if they want to add more
    elements. Assuming that the user wants to add two more memory blocks to the existing
    allocated ones, the value of `2` entered by the user will be assigned to the variable
    `m`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `realloc` function, the quantity of the memory blocks increases from
    four to six, where each memory block is able to store an integer number. The user
    will be asked to enter the integer values for two newly added memory blocks. To
    indicate that the size of memory blocks has increased from four to six, all of
    the six integers assigned to the memory blocks are displayed on the screen. Thereafter,
    the user will be asked how many blocks they want to keep out of the six memory
    blocks. Let's assume the value entered by the user is `3`; that is, the user wants
    to keep the integers in the first three memory blocks and discard the rest.
  prefs: []
  type: TYPE_NORMAL
- en: The value of `3` entered by the user will be assigned to the variable `m`. Again,
    the `realloc` function is invoked to reduce the number of memory blocks from six
    to three. Finally, the integers in the three memory blocks are displayed on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, the `dynamicmem.c` program has successfully
    compiled into a `.exe` file: `dynamicmem.exe`. Upon executing this file, the user
    is prompted to define how many memory blocks they want to dynamically allocate.
    After that, the user is asked how many additional memory blocks they want. The
    user is also asked whether they want to keep some memory blocks active from the
    total, thereby reducing the number of allocated memory blocks, and, finally, all
    the memory blocks are freed. All of the actions appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2835e744-847e-410d-b0ac-d25c63e6bc80.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next recipe!
  prefs: []
  type: TYPE_NORMAL
- en: Handling signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn signal handling. We will learn how to automatically
    raise a signal, how signals are raised by user actions, and how signals are directed
    to specific signal-handling functions. Signal handling is required to take necessary
    action when the signal occurs. The actions may include ignoring the signal, terminating
    the process, blocking or suspending a process, resuming a process, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a quick overview of signals before we dive into the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A signal is an indicator that is generated through software and is used to stop
    the usual execution of the program, and through a branch of CPU to perform some
    specific tasks. The signal can be generated either by a process or when the user
    presses *Ctrl *+ *C*. When something goes wrong or some error occurs while executing
    an operation, the signal acts as a medium of communication between the process
    and the operating system. The signal is raised by the operating system and is
    forwarded to the process to take necessary actions. Essentially, a corresponding
    signal handler is executed as a corrective measure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the important signals that you should be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIGABRT** (**Signal Abort**): This signal reports the abnormal termination
    of the program. The signal is raised in the case of critical errors; for example,
    if an assertion fails or memory could not be allocated, or any similar memory
    heap errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SIGFPE** (**Signal Floating-Point Exception**): This signal reports an arithmetic
    error. Any arithmetic error, including overflow or divide by zero, is covered
    by this signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SIGILL** (**Signal Illegal Instruction**): This signal reports illegal instructions.
    Such a signal is raised when the program tries to execute data or an executable
    file is corrupted. In other words, the signal is raised when the program is trying
    to execute a nonexecutable instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SIGINT** (**Signal Interrupt**): This is a program interrupt signal that
    is generated by the user by pressing *Ctrl* + *C*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SIGSEGV** (**Signal Segmentation Violation**): This signal is raised when
    the program tries to write into read-only memory or into a block that does not
    have write permissions. The signal is also raised when a program tries to read
    or write into memory that is outside the range that is allocated to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SIGTERM** (**Signal Terminate**): This is a termination signal that is sent
    to a process in order to terminate it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To handle signals in a program, the `signal()` function is used. Let's look
    at a quick introduction to the signal function.
  prefs: []
  type: TYPE_NORMAL
- en: signal()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The signal function directs the occurrence of the signal to any of the following
    signal handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIG_IGN`: This will result in the signal being ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIG_DFL`: This will result in invoking the default action that is associated
    with the raised signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user_defined_function`: This will result in the invoking of the user-defined
    function when the signal is raised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's begin with the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps for associating signals to signal-handling functions,
    automatically raise the signals, and get the desired actions performed when signals
    are raised by user actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Associate a signal interrupt, `(SIGINT)`, to a function. This function will
    act as a signal handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write some code in the signal handler function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main` function, make a `while` loop that executes 5 times. You can make
    the `while` loop run for as many times as you want. The `while` loop is set to
    display a text message after a delay of 1 second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The idea is to automatically raise the signal after 5 seconds. So, after its
    5 iterations, the `while` loop ends and the interrupt signal is automatically
    raised.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The associated signal handler function is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After executing the code in the signal handler, in the `main` function, again,
    associate a signal interrupt, `(SIGINT)`, with another signal handler function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set an infinite `while` loop to execute, which displays a text message after
    each delay of 1 second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user presses *Ctrl* + *C* , the signal interrupt is raised and the associated
    signal handler is raised.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the signal handler, we associate the signal interrupt with its default action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consequently, if the user presses *Ctrl* + *C* again, that is, if the signal
    interrupt is raised again, the default action will take place: the program will
    terminate.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The program for showing how the signals are automatically raised, how signals
    are raised by the user, and how they are handled, is as follows (`signalhandling.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go behind the scenes to understand the code better.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `signal` function, a signal interrupt, `(SIGINT)`, is associated
    with a function called `signalhandler1`. That is, if the interrupt is autogenerated
    or is generated by the user, the `sighandler1` function will be invoked. A counter, `x`,
    is initialized to `1` and a `while` loop is set to execute until the value of
    counter `x` becomes larger than `5`. Within the `while` loop, the following text
    is displayed: `Signal will be raised automatically after 5 seconds`. In addition
    to this, the value of counter `x` is incremented by `1` within the `while` loop.
    A delay of 1 second is inserted in the `while` loop. In short, the `while` loop
    will display a text message after a gap of 1 second each. After displaying the
    text message 5 times, the `raise` function is invoked to raise the `SIGINT` signal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On raising the `SIGINT` signal, the `signalhandler1` function will be invoked.
    The `signalhandler1` function does nothing other than display a text message:
    `Ctrl+C is auto pressed`. After executing the `signalhandler1` function, the control
    resumes executing the statements in the `main` function. Again, the `signal` function
    is invoked and the `SIGINT` signal is associated with the `sighandler2` function. Once
    more, a `while` loop is set to execute; however, this time, the loop will run
    indefinitely. Within the `while` loop, a text message, `Infinite loop, press Ctrl+C
    to raise signal`, is displayed. After displaying the text message, a delay of
    1 second is inserted; that is, the text message will keep on displaying indefinitely
    after a gap of 1 second. If the user presses *Ctrl* + *C*, the signal interrupt
    will be raised and the `sighandler2` function will be invoked.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `sighandler2` function, a text message, `You have pressed Ctrl+C`, is
    displayed on one line and, on the next line, `Press Ctrl+C again to exit` is displayed.
    Thereafter, the `signal` function is invoked to set the `SIGINT` signal to take
    the default action. The default action of the `SIGINT` interrupt is to terminate
    and exit from the program. This means that if the user again presses *Ctrl* +
    *C*, the program will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears during compilation, the `signalhandling.c` program has successfully
    compiled into a `.exe` file: `signalhandling.exe`. Upon executing this file, five
    text messages are displayed on the screen through the first `while` loop. After
    that, the signal is automatically raised and the text message from the first signal
    handler appears on the screen. Thereafter, a text message from the infinite `while`
    loop appears. Finally, the output from the second signal handler appears, which
    is executed when the signal interrupt is generated by the user.  All of the actions
    appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18d32e1f-2fb8-4b38-a22e-daf2e0eacff0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5
  prefs: []
  type: TYPE_NORMAL
- en: Voilà! We have successfully handled signals.
  prefs: []
  type: TYPE_NORMAL
