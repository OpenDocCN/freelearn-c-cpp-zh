["```cpp\nvoid enter_sleep_mode(void) {\n    // Clear the SLEEPDEEP bit to enter Sleep mode\n    SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;\n    // Request Wait For Interrupt\n    __WFI();\n}\n```", "```cpp\nvoid enter_stop_mode(void) {\n    // Set SLEEPDEEP bit to enable deep sleep mode\n    SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;\n    // Request Wait For Interrupt\n    __WFI();\n}\n```", "```cpp\nvoid enter_standby_mode(void) {\n    // Clear Wakeup flag\n    PWR->CR |= PWR_CR_CWUF;\n    // Set the PDDS bit to enter Standby mode\n    PWR->CR |= PWR_CR_PDDS;\n    // Set the SLEEPDEEP bit to enable deep sleep mode\n    SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;\n    // Request Wait For Interrupt\n    __WFI();\n}\n```", "```cpp\n#include \"standby_mode.h\"\n#define PWR_MODE_STANDBY        (PWR_CR_PDDS)\n#define WK_PIN                (1U<<0)\nstatic void set_power_mode(uint32_t pwr_mode);\nvoid wakeup_pin_init(void)\n{\n    //Enable clock for GPIOA\n    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;\n    //Set PA0 as input pin\n    GPIOA->MODER &= ~(1U<<0);\n    GPIOA->MODER &= ~(1U<<1);\n    //No pull\n    GPIOA->PUPDR &= ~(1U<<0);\n    GPIOA->PUPDR &= ~(1U<<1);\n}\n```", "```cpp\nvoid standby_wakeup_pin_setup(void)\n{\n    /*Wait for wakeup pin to be released*/\n    while(get_wakeup_pin_state() == 0){}\n    /*Disable wakeup pin*/\n    PWR->CSR &=~(1U<<8);\n    /*Clear all wakeup flags*/\n    PWR->CR |=(1U<<2);\n    /*Enable wakeup pin*/\n    PWR->CSR |=(1U<<8);\n    /*Enter StandBy mode*/\n    set_power_mode(PWR_MODE_STANDBY);\n    /*Set SLEEPDEEP bit in the CortexM System Control Register*/\n    SCB->SCR |=(1U<<2);\n    /*Wait for interrupt*/\n    __WFI();\n}\n```", "```cpp\nuint32_t get_wakeup_pin_state(void)\n{\n      return ((GPIOA->IDR & WK_PIN) == WK_PIN);\n}\n```", "```cpp\nstatic void set_power_mode(uint32_t pwr_mode)\n{\n  MODIFY_REG(PWR->CR, (PWR_CR_PDDS | PWR_CR_LPDS | PWR_CR_FPDS | PWR_\n  CR_LPLVDS | PWR_CR_MRLVDS), pwr_mode);\n}\n```", "```cpp\n#ifndef STANDBY_MODE_H__\n#define STANDBY_MODE_H__\n#include <stdint.h>\n#include \"stm32f4xx.h\"\nuint32_t get_wakeup_pin_state(void);\nvoid wakeup_pin_init(void);\nvoid standby_wakeup_pin_setup(void);\nmain.c. Update your main.c file, as shown here:\n\n```", "```cpp\n\n\t\t\tThe `main` function starts by initializing the UART for serial communication with `uart_init`, ensuring that we can send debugging information to the serial port. Next, it configures the wake-up pin by calling `wakeup_pin_init`, preparing the microcontroller to respond to external wake-up signals. The `check_reset_source` function is then called to determine the cause of the microcontroller’s reset, whether from standby mode or another source, and to handle any necessary flag clearing. Following this, the `PC13` is initialized with `pc13_exti_init`. The function then enters an infinite `while(1)`, maintaining the program’s operational state and waiting for interrupts or events to occur:\n\n```", "```cpp\n\n\t\t\tThis function determines the cause of the microcontroller’s reset and handles the necessary flags accordingly. It begins by enabling the clock for the power control (`PWR`) peripheral to ensure access to the power control and status registers. It then checks whether the `PWR_CSR` register, which indicates that the system has resumed from standby mode. If the flag is set, it clears the SBF and prints a message, indicating that the system has resumed from standby. The function also waits for the wake-up pin to be released, ensuring that the pin is in a stable state. Additionally, it checks whether the Wakeup flag (`WUF`) is set and, if so, clears the flag to reset the wake-up status.\n\t\t\tThis is the interrupt callback function:\n\n```", "```cpp\n\n\t\t\tAnd finally, we have the interrupt handler:\n\n```", "```cpp\n\n\t\t\tThe `exti_callback` function, coupled with `EXTI15_10_IRQHandler`, ensures that the microcontroller properly handles external interrupts from the wake-up pin. The `exti_callback` function is a straightforward handler that calls `standby_wakeup_pin_setup`. The `EXTI15_10_IRQHandler` function is an interrupt service routine specifically for EXTI lines 15 to 10\\. It checks whether the interrupt was triggered by line 13 (associated with the wake-up pin), and if so, it clears the interrupt pending flag to acknowledge the interrupt. After clearing the flag, it calls `exti_callback` to handle the wake-up event.\n\t\t\tNow, let’s test the project!\n\t\t\tTo test the project, start by pressing the blue push button to enter standby mode. Remember that `PA0` is configured as the wake-up pin and is active low. In normal mode, connect a jumper wire from `PA0` to the ground. To trigger a wake-up event, pull out the jumper wire and connect it to 3.3V, causing a change in logic that will wake the microcontroller from standby mode.\n\t\t\tTo test on the microcontroller, simply build the project and run it.\n\t\t\tOpen RealTerm and configure the appropriate port and baud rate to view the printed message that confirms the system has resumed from standby mode.\n\t\t\tSummary\n\t\t\tIn this chapter, we delved into the critical aspects of power management and energy efficiency in embedded systems. Efficient power management is essential for prolonging battery life and ensuring optimal performance in embedded devices. We began by exploring various power management techniques, laying the foundation for understanding how to reduce power consumption in embedded systems.\n\t\t\tWe then examined the different low-power modes available in STM32F4 microcontrollers, providing detailed insights into their configurations and applications. Then, we discussed the wake-up sources and triggers in STM32F4, which are essential to ensure that a microcontroller can promptly come out of low-power modes.\n\t\t\tFinally, we put theory into practice by developing a driver to enter standby mode and wake up the microcontroller.\n\t\t\tWith this journey into bare-metal embedded C programming now complete, it’s important to acknowledge the profound expertise you’ve gained. By mastering the nuances of microcontroller architecture and the discipline of register-level programming, you’ve equipped yourself with the tools to create efficient and reliable embedded systems from the ground up. This book was designed to offer more than just technical instruction; it also aimed to instill a deeper understanding of the hardware and a methodical approach to firmware development. As you move forward, remember that true mastery in this field lies in the continuous application and refinement of these principles.\n\n```"]