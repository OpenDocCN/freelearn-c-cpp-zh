- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Environment Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the basic steps of setting up the environment
    for future experiments with Clang . The setup is appropriate for Unix-based systems
    such as Linux and Mac OS (Darwin). In addition, you will get important information
    on how to download, configure, and build the LLVM source code. We will continue
    with a short session that explains how to build and use the **LLVM debugger (LLDB**
    ), which will be used as the primary tool for code investigation throughout the
    book. Finally, we will finish with a simple Clang tool that can check C/C++ files
    for compilation errors. We will use LLDB for a simple debug session for the created
    tool and clang internal. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know LLVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source code compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a custom Clang tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.1 Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Downloading and building LLVM code is very easy and does not require any paid
    tools. You will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Unix-based OS (Linux, Darwin)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command line git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Build tools: CMake and Ninja'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use the debugger as the source investigation tool. LLVM has its own
    debugger, LLDB. We will build it as our first tool from LLVM monorepo: [https://github.com/llvm/llvm-project.git](https://github.com/llvm/llvm-project.git).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any build process consists of two steps. The first one is the project configuration
    and the last one is the build itself. LLVM uses CMake as a project configuration
    tool. It also can use a wide range of build tools, such as Unix Makefiles, and
    Ninja. It can also generate project files for popular IDEs such as Visual Studio
    and XCode. We are going to use Ninja as the build tool because it speeds up the
    build process, and most LLVM developers use it. You can find additional information
    about the tools here: [https://llvm.org/docs/GettingStarted.html](https://llvm.org/docs/GettingStarted.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is located in the `chapter1` folder of the
    book’s GitHub repository: [https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter1](https://github.com/PacktPublishing/Clang-Compiler-Frontend-Packt/tree/main/chapter1)'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.1 CMake as project configuration tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CMake is an source, cross-platform build system generator. It has been used
    as the primary build system for LLVM since version 3.3, which was released in
    2013.
  prefs: []
  type: TYPE_NORMAL
- en: Before LLVM began using CMake, it used autoconf, a tool that generates a configure
    script that can be used to build and install software on a wide range of Unix-like
    systems. However, autoconf has several limitations, such as being difficult to
    use and maintain and having poor support for cross-platform builds. CMake was
    chosen as an alternative to autoconf because it addresses these limitations and
    is easier to use and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being used as the build system for LLVM, CMake is also used for
    many other software projects, including Qt, OpenCV, and Google Test.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1.2 Ninja as build tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ninja is a small build system with a focus on speed. It is designed to be used
    in conjunction with a build generator, such as CMake, which generates a build
    file that describes the build rules for a project.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of Ninja is its speed. It is able to execute builds
    much faster than other build systems, such as Unix Makefiles, by only rebuilding
    the minimum set of files necessary to complete the build. This is because it keeps
    track of the dependencies between build targets and only rebuilds targets that
    are out of date.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Ninja is simple and easy to use. It has a small and straightforward
    command-line interface, and the build files it uses are simple text files that
    are easy to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, Ninja is a good choice for build systems when speed is a concern, and
    when a simple and easy-to-use tool is desired.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most useful Ninja option is `-j` . This option allows you to specify
    the number of threads to be run in parallel. You may want to specify the number
    depending on the hardware you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Our next goal is to download the LLVM code and investigate the project structure.
    We also need to set up the necessary utilities for the build process and establish
    the environment for our future experiments with LLVM code. This will ensure that
    we have the tools and dependencies in place to proceed with our work efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 Getting to know LLVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s begin by covering some foundational information about LLVM, including
    the project history as well as its structure.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.1 Short LLVM history
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Clang compiler is a part of the LLVM project. The project was started in
    2000 by Chris Lattner and Vikram Adve as their project at the University of Illinois
    at Urbana–Champaign [[26](B19722_Bib.xhtml#XLLVM_CGO04)].
  prefs: []
  type: TYPE_NORMAL
- en: LLVM was originally designed to be a next-generation code generation infrastructure
    that could be used to build optimizing compilers for many programming languages.
    However, it has since evolved into a full-featured platform that can be used to
    build a wide variety of tools, including debuggers, profilers, and static analysis
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: LLVM has been widely adopted in the software industry and is used by many companies
    and organizations to build a variety of tools and applications. It is also used
    in academic research and teaching and has inspired the development of similar
    projects in other fields.
  prefs: []
  type: TYPE_NORMAL
- en: The project received an additional boost when Apple hired Chris Lattner in 2005
    and formed a team to work on LLVM. LLVM became an integral part of the development
    tools created by Apple (XCode).
  prefs: []
  type: TYPE_NORMAL
- en: Initially, **GNU Compile Collection (GCC)** was used as the C/C++ frontend for
    LLVM. But that had some problems. One of them was related to GNU **General Public
    License (GPL**) that prevented the frontend usage at some proprietary projects.
    Another disadvantage was the limited support for Objective-C in GCC at the time,
    which was important for Apple. The Clang project was started by Chris Lattner
    in 2006 to address the issues.
  prefs: []
  type: TYPE_NORMAL
- en: Clang was originally designed as a unified parser for the C family of languages,
    including C, Objective-C, C++, and Objective-C++. This unification was intended
    to simplify maintenance by using a single frontend implementation for multiple
    languages, rather than maintaining multiple implementations for each language.
    The project became successful very quickly. One of the primary reasons for the
    success of Clang and LLVM was their modularity. Everything in LLVM is a library,
    including Clang . It opened the opportunity to create a lot of amazing tools based
    on Clang and LLVM, such as clang-tidy and clangd, which will be covered later
    in the book ([*Chapter** 5*](B19722_05.xhtml#x1-990005)*, Clang-Tidy Linter Framework*
    and [*Chapter** 8*](B19722_08.xhtml#x1-1520008)*, IDE* *Support and Clangd*).
  prefs: []
  type: TYPE_NORMAL
- en: LLVM and Clang have a very clear architecture and are written in C++. That makes
    it possible to be investigated and used by any C++ developer. We can see the huge
    community created around LLVM and the extremely fast growth of its usage.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.2 OS support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are planning to focus on OS for personal computers here, such as Linux, Darwin,
    and Windows. On the other hand, Clang is not limited by personal computers but
    can also be used to compile code for mobile platforms such as iOS and different
    embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The GCC is the default set of dev tools on Linux, especially `gcc` (for C programs)
    and `g++` (for C++ programs) being the default compilers. Clang can also be used
    to compile source code on Linux. Moreover, it mimics to `gcc` and supports most
    of its options. LLVM support might be limited for some GNU tools, however; for
    instance, GNU Emacs does not support LLDB as a debugger. But despite this, Linux
    is the most suitable OS for LLVM development and investigation, thus we will mainly
    use this OS (Fedora 39) for future examples.
  prefs: []
  type: TYPE_NORMAL
- en: Darwin (macOS)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Clang is considered the main build tool for Darwin. The entire build infrastructure
    is based on LLVM, and Clang is the default C/C++ compiler. The developer tools,
    such as the debugger (LLDB ), also come from LLVM. You can get the primary developer
    utilities from XCode, which are based on LLVM. However, you may need to install
    additional command-line tools, such as CMake and Ninja, either as separate packages
    or through package systems such as MacPorts or Homebrew.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can get CMake using Homebrew as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'or for MacPorts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On Windows, Clang can be used as a command-line compiler or as part of a larger
    development environment such as Visual Studio. Clang on Windows includes support
    for the **Microsoft Visual C++ (MSVC)** ABI, so you can use Clang to compile programs
    that use the **Microsoft C runtime** **library (CRT)** and the C++ **Standard
    Template Library (STL)**. Clang also supports many of the same language features
    as GCC, so it can be used as a drop-in replacement for GCC on Windows in many
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth mentioning `clang-cl` [[9](B19722_Bib.xhtml#Xllvm_clangcl)]. It is
    a command-line compiler driver for Clang that is designed to be used as a drop-in
    replacement for the MSVC compiler, `cl.exe` . It was introduced as part of the
    Clang compiler, and is created to be used with the LLVM toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: Like `cl.exe` , `clang-cl` is designed to be used as part of the build process
    for Windows programs, and it supports many of the same command-line options as
    the MSVC compiler. It can be used to compile C, C++, and Objective-C code on Windows,
    and it can also be used to link object files and libraries to create executable
    programs or **dynamic link libraries** **(DLLs)**.
  prefs: []
  type: TYPE_NORMAL
- en: The development process for Windows is different from that of Unix-like systems,
    which require additional specifics that might make the book material quite complicated.
    To avoid this complexity, our primary goal is to focus on Unix-based systems,
    such as Linux and Darwin, and we will omit Windows-specific examples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2.3 LLVM/Clang project structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Clang source is a part of the LLVM **monolithic repository** **(monorepo)**.
    LLVM started to use the monorepo in 2019 as a part of its transition to Git [[4](B19722_Bib.xhtml#Xllvm_llvm2git)].
    The decision was driven by several factors, such as better code reuse, improved
    efficiency, and collaboration. Thus you can find all the LLVM projects in one
    place. As mentioned in the [Preface](B19722_Preface.xhtml#x1-5000doc), we will
    be using LLVM version 18.x in this book. The following command will allow you
    to download it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.1**: Getting the LLVM code base'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The release 18 is the latest version of LLVM, expected to be released in March
    2024\. This book is based on the version from January 23, 2024, when the release
    branch was created.
  prefs: []
  type: TYPE_NORMAL
- en: The most important parts of the **llvm-project** that will be used in the book
    are shown in [Figure 1.2](#x1-25007r2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: LLVM project tree ](img/Figure1.2_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.2**: LLVM project tree'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lld` : The LLVM linker tool. You may want to use it as a replacement for standard
    linker tools, such as GNU `ld`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`llvm` : Common libraries for LLVM projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clang` : The clang driver and frontend'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clang-tools-extra` : These are different clang tools that will be covered
    in the second part of the book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most projects have the structure shown in [Figure 1.3](#x1-25011r3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: Typical LLVM project structure ](img/Figure1.3_B19722.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.3**: Typical LLVM project structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'LLVM projects, such as `clang` or `llvm` , typically contain two primary folders:
    `include` and `lib` . The `include` folder contains the project interfaces (header
    files), while the `lib` folder contains the implementation. Each LLVM project
    has a variety of different tests, which can be divided into two primary groups:
    unit tests located in the `unittests` folder and implemented using the Google
    Test framework, and end-to-end tests implemented using the **LLVM Integrated Tester
    (LIT** **)** framework. You can get more info about LLVM/Clang testing in [*Section** 4.5.2*](B19722_04.xhtml#x1-830002)*,
    LLVM test* *framework*.'
  prefs: []
  type: TYPE_NORMAL
- en: The most important projects for us are `clang` and `clang-tools-extra` . The
    `clang` folder contains the frontend and driver.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The compiler driver is used to run different stages of compilation (parsing,
    optimization, link, and so on.). You can get more info about it at [*Section** 2.3*](B19722_02.xhtml#x1-410003)*,
    Clang driver overview*.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the lexer implementation is located in the `clang/lib/Lex` folder.
    You can also see the `clang/test` folder, which contains end-to-end tests, and
    the `clang/unittest` folder, which contains unit tests for the frontend and the
    driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important folder is `clang-tools-extra` . It contains some tools based
    on different Clang libraries. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clang-tools-extra/clangd` : A language server that provides navigation info
    for IDEs such as VSCode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clang-tools-extra/clang-tidy` : A powerful lint framework with several hundred
    different checks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clang-tools-extra/clang-format` : A code formatting tool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After obtaining the source code and setting up build tools, we are ready to
    compile the LLVM source code.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 Source code compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are compiling our source code in debug mode to make it suitable for future
    investigations with a debugger. We are using LLDB as the debugger. We will start
    with an overview of the build process and finish building the LLDB as a concrete
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.1 Configuration with CMake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a build folder where the compiler and related tools will be built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The minimal configuration command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The command requires the build type to be specified (e.g. `Debug` in our case)
    as well as the primary argument that points to a folder with the build configuration
    file. The configuration file is stored as `CMakeLists.txt` and is located in the
    `llvm` folder, which explains the `../llvm` argument usage. The command generates
    `Makefile` located in the build folder, thus you can use the simple `make` command
    to start the build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use more advanced configuration commands in the book. One of the commands
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.4**: Basic CMake configuration'
  prefs: []
  type: TYPE_NORMAL
- en: 'The are several LLVM/cmake options specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-G Ninja` specifies Ninja as the build generator, otherwise it will use make
    (which is slow).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-DCMAKE``_BUILD``_TYPE=Debug` sets the build mode. The build with debug info
    will be created. There is a primary build configuration for Clang internals investigations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-DCMAKE``_INSTALL``_PREFIX=../install` specifies the installation folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-DLLVM``_TARGETS``_TO``_BUILD="X86"` sets exact targets to be build. It will
    avoid building unnecessary targets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-DLLVM``_ENABLE``_PROJECTS="lldb;clang;clang-tools-extra"` specifies the LLVM
    projects we want to build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-DLLVM``_USE``_SPLIT``_DWARF=ON` splits debug information into separate files.
    This option saves disk space as well as memory consumption during the LLVM build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We used `-DLLVM``_USE``_SPLIT``_DWARF=ON` to save some space on the disk. For
    instance, the Clang build (`ninja clang` build command) with the option enabled
    takes up 20 GB, but it takes up 27 GB space with the option disabled. Note that
    the option requires a compiler used for the build to support it. You might also
    notice that we create the build for one specific architecture: `X86` . This option
    also saved some space for us because otherwise, all supported architecture will
    be built and the required space will also increase from 20 GB to 27 GB.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'You might want to avoid using the `-DLLVM``_TARGETS``_TO``_BUILD="X86"` setting
    if your host platform is different from X86, for instance, ARM. For ARM, you can
    use the following configuration: `-DLLVM``_TARGETS``_TO``_BUILD="ARM;X86;AArch64"`
    [[15](B19722_Bib.xhtml#Xllvm_arm_build)]. The full list of supported platforms
    can be found in [[7](B19722_Bib.xhtml#Xllvm_build)] and includes (as of March
    2023) 19 different targets.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the default settings and not specify the `LLVM``_TARGETS``_TO``_BUILD`
    configuration setting. Be prepared for both an increase in build time and the
    amount of space used.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can save more space if you use dynamic libraries instead of static ones.
    The configuration setting `-DBUILD``_SHARED``_LIBS=ON` will build each LLVM component
    as a shared library. The space used will be 14 GB, and the overall config command
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.5**: CMake configuration that enables shared libraries instead of
    static ones'
  prefs: []
  type: TYPE_NORMAL
- en: 'For performance purposes, on Linux, you might want to use the `gold` linker
    instead of the default one. The `gold` linker is an alternative to the GNU Linker,
    which was developed as part of the GNU Binary Utilities (binutils) package. It
    is designed to be faster and more efficient than the GNU Linker, especially when
    linking large projects. One way it achieves this is by using a more efficient
    algorithm for symbol resolution and a more compact file format for the resulting
    executable. It can be enabled with the `-DLLVM``_USE``_LINKER=gold` option. The
    result configuration command will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.6**: CMake configuration that uses gold linker'
  prefs: []
  type: TYPE_NORMAL
- en: 'The debug build can be very slow, so you may want to consider an alternative.
    A good compromise between debuggability and performance is the release build with
    debug information. To obtain this build, you can change the `CMAKE``_BUILD``_TYPE`
    flag to `RelWithDebInfo` in your overall configuration command. The command will
    then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.7**: CMake configuration that uses RelWithDebInfo build type'
  prefs: []
  type: TYPE_NORMAL
- en: The following table keeps the list of some popular options ( [https://llvm.org/docs/CMake.html](https://llvm.org/docs/CMake.html)).
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `CMAKE``_BUILD``_TYPE` | Specifies the build configuration. |'
  prefs: []
  type: TYPE_TB
- en: '|  | Possible values are `Release&#124;Debug&#124;RelWithDebInfo&#124;MinSizeRel`
    . |'
  prefs: []
  type: TYPE_TB
- en: '|  | `Release` and `RelWithDebInfo` are optimized for performance, while |'
  prefs: []
  type: TYPE_TB
- en: '|  | `MinSizeRel` is optimized for size. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `CMAKE``_INSTALL``_PREFIX` | Installation prefix |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `CMAKE``_C,CXX``_FLAGS` | Extra C/C++ flags be used for compilation |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `CMAKE``_C,CXX``_COMPILER` | C/C++ compiler be used for compilation. |'
  prefs: []
  type: TYPE_TB
- en: '|  | You might want to specify a non-default compiler to use some |'
  prefs: []
  type: TYPE_TB
- en: '|  | options that are not available or not supported by the default compiler.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `LLVM``_ENABLE``_PROJECTS` | The projects to be enabled. We will use `clang;clang-tools-extra`
    . |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `LLVM``_USE``_LINKER` | Specifies the linker to be used. |'
  prefs: []
  type: TYPE_TB
- en: '|  | There are several options, including `gold` and `lld` . |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  |'
  prefs: []
  type: TYPE_TB
- en: '**Table 1.1:** Configuration options'
  prefs: []
  type: TYPE_NORMAL
- en: 1.3.2 Build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to call Ninja to build the projects. If you want to build all specified
    projects, you can run Ninja without arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The command for the Clang build will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also run unit and end-to-end tests for the compiler with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The compiler binary is `bin/clang` and can be found in the `build` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also install the binaries into the folder specified in the `-DCMAKE``_INSTALL``_PREFIX`
    option. It can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `../install` folder (specified as the installation folder in [Figure 1.4](#x1-27004r4))
    will have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 1.3.3 The LLVM debugger, its build, and usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The LLVM debugger, LLDB , has been created with a look at the GNU debugger (GDB
    ). Some of its commands repeat the counterparts from GDB . You may ask ”Why do
    we need a new debugger if we have a good one?” The answer can be found in the
    different architecture solutions used by GCC and LLVM. LLVM uses a modular architecture,
    and different parts of the compiler can be reused. For example, the Clang frontend
    can be reused in the debugger, resulting in support for modern C/C++ features.
    For example, the print command in `lldb` can specify any valid language constructions,
    and you can use some modern C++ features with the `lldb` print command.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, GCC uses a monolithic architecture, and it’s hard to separate the
    C/C++ frontend from other parts. Therefore, GDB has to implement language features
    separately, which may take some time before modern language features implemented
    in GCC become available in GDB .
  prefs: []
  type: TYPE_NORMAL
- en: 'You may find some info about LLDB build and a typical usage scenario in the
    following example. We are going to create a separate folder for the release build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.8**: Release build for LLVM'
  prefs: []
  type: TYPE_NORMAL
- en: 'We configure our project in release mode and specify the `lldb` and `clang`
    projects only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.9**: CMake configuration that uses Release build type'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to build both Clang and LLDB using the maximum threads available
    in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can install the created executables with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The binary will be installed into the folder specified via the `-DCMAKE``_INSTALL``_PREFIX`
    config command argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following simple C++ program for the example debugger session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.10**: Test C++ program: main.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program can be compiled using the following command (`<...>` was used to
    refer the folder where llvm-project was cloned):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, we don’t use optimization (the `-O0` option) and store
    debug info in the binary (with the `-g` option).
  prefs: []
  type: TYPE_NORMAL
- en: A typical debug session for the created executable is shown in [Figure 1.11](#listing-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.11**: LLDB session example'
  prefs: []
  type: TYPE_NORMAL
- en: 'Several actions are taken:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the debug session with `<...>/llvm-project/install/bin/lldb` `main` , where
    `main` is the executable we want to debug. See [Figure 1.11](#listing-7), *Line
    1*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set a breakpoint in the `main` function. See [Figure 1.11](#listing-7), *Line
    4*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the session with `"r"` command. See [Figure 1.11](#listing-7), *Line 6*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see that the process is interrupted at the breakpoint. See [Figure 1.11](#listing-7),
    *Lines 8, 12*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We finish the session with the `"q"` command. See [Figure 1.11](#listing-7),
    *Line 14*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to use LLDB as one of our tools for the Clang internal investigation.
    We will use the same sequence of commands that is shown in [Figure 1.11](#listing-7).
    You can also use another debugger, such as GDB , that has a similar set of commands
    as LLDB .
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 Test project – syntax check with a Clang tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our first test project, we will create a simple Clang tool that runs the
    compiler and checks the syntax for the provided source file. We will create a
    so-called out-of-tree LLVM project, that is, a project that will use LLVM but
    will be located outside the main LLVM source tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several actions are required to create the project:'
  prefs: []
  type: TYPE_NORMAL
- en: The required LLVM libraries and headers have to be built and installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to create a build configuration file for our test project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code that uses LLVM has to be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will start with the first step and install the Clang support libraries and
    headers. We will use the following configuration command for CMake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.12**: LLVM CMake configuration for a simple syntax checking Clang
    tool'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed, we enabled only one project: `clang`. All other options
    are standard for our debug build. The command has to be run from a created `build`
    folder inside the LLVM source tree, as was suggested in [*Section** 1.3.1*](#x1-270001)*,*
    *Configuration with CMake*.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The configuration specified in [Figure 1.12](#x1-30003r12) will be the default
    build configuration used throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration with shared libraries, in addition to the reduced size, has
    the advantage of simplifying the specification of dependencies. You only need
    to specify the shared libraries that your project directly depends on, and the
    dynamic linker takes care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The required libraries and headers can be installed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The libraries and headers will be installed into `install` folder, as was specified
    by the `CMAKE_INSTALL_PREFIX` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to create two files for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMakeLists.txt`: The project configuration file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestProject.cpp`: The project source code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The project configuration file, `CMakeLists.txt` , will accept a path to the
    LLVM install folder via the `LLVM_HOME` environment variable. The file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.13**: CMake file for simple syntax check Clang Tool'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important parts of the file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 2*: We specify the project name (syntax-check). That is also the name
    of our executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Lines 4-7*: Test for the `LLVM_HOME` environment variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 10*: We set a path to the LLVM CMake helpers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 11*: We load the LLVM CMake package from the paths specified on *Line
    10*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 14*: We specify our source file that should be compiled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 16*: We set up an additional flag for compilation: `-fno-rtti`. The flag
    is required as soon as LLVM is built without RTTI. This is done in an effort to
    reduce code and executable size [[11](B19722_Bib.xhtml#Xllvm_coding_standards)].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Lines 18-22* We specify the required libraries to be linked to our program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The source code for our tool is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.14**: SyntaxCheck.cpp'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important part of the file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Lines 7-9*: The majority of compiler tools have the same set of command line
    arguments. The LLVM command-line library [[12](B19722_Bib.xhtml#Xllvm_commandline_library)]
    provides some APIs to process compiler command options. We set up the library
    on *Line 7*. We also set up additional help messages on lines 8-10.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Lines 13-18*: We parse command-line arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Lines 19-24*: We create and run our Clang tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Lines 22-23*: We use the `clang::SyntaxOnlyAction` frontend action, which
    will run syntax and semantic checks on the input file. You can get more info about
    frontend actions in [*Section** 2.4.1*](B19722_02.xhtml#x1-480001)*, Frontend
    action*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have to specify a path to the LLVM `install` folder to build our tool. As
    was mentioned earlier, the path has to be specified via the `LLVM_HOME` environment
    variable. Our configuration command (see [Figure 1.12](#x1-30003r12)) specifies
    the path as the `install` folder inside the LLVM project source tree. Thus we
    can build our tool as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.15**: The syntax-check build commands'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the tool as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.16**: The syntax-check –help output'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program will successively terminate if we run it on a valid C++ source
    file, but it will produce an error message if it’s run on a broken C++ file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.17**: The syntax-check run on a file with a syntax error'
  prefs: []
  type: TYPE_NORMAL
- en: We used ’- -’ to pass additional arguments to the compiler in [Figure 1.17](#x1-30067r17),
    specifically indicating that we want to use C++17 with the option ’-std=c++17’.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also run our tool with the LLDB debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.18**: The syntax-check run under debugger'
  prefs: []
  type: TYPE_NORMAL
- en: We run `syntax-check` as the primary binary and set `main.cpp` source file as
    an argument for the tool ([Figure 1.18](#x1-30069r18)). We also pass additional
    compilation flags (-std=c++17) to the syntax-check executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set a breakpoint and run the program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure 1.19**: LLDB session for Clang Tool test project'
  prefs: []
  type: TYPE_NORMAL
- en: We set a breakpoint in the `clang``::``ParseAST` function ([Figure 1.19](#x1-30091r19),
    line 1). The function is the primary entry point for source code parsing. We run
    the program on *Line 3* and continue the execution after the breakpoint on *Line*
    *16*.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the same debugging techniques later in the book when we investigate
    Clang’s source code.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we covered the history of the LLVM project, obtained the source
    code for LLVM, and explored its internal structure. We learned about the tools
    used to build LLVM, such as CMake and Ninja. We studied the various configuration
    options for building LLVM and how they can be used to optimize resources, including
    disk space. We built Clang and LLDB in debug and release modes and used the resulting
    tools to compile a basic program and run it with the debugger. We also created
    a simple Clang tool and ran it with the LLDB debugger.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will introduce you to the compiler design architecture and
    explain how it appears in the context of Clang . We will primarily focus on the
    Clang frontend, but we will also cover the important concept of the Clang driver
    – the backbone that manages all stages of the compilation process, from parsing
    to linking.
  prefs: []
  type: TYPE_NORMAL
- en: 1.6 Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Getting Started with the LLVM System: [https://llvm.org/docs/GettingStarted.html](https://llvm.org/docs/GettingStarted.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Building LLVM with CMake: [https://llvm.org/docs/CMake.html](https://llvm.org/docs/CMake.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clang Compiler User’s Manual: [https://clang.llvm.org/docs/UsersManual.html](https://clang.llvm.org/docs/UsersManual.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
