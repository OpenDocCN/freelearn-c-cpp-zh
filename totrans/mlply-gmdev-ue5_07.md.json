["```cpp\nUFUNCTION(Client)\nvoid DoSomething_Client();\n```", "```cpp\nUFUNCTION(Server)\nvoid DoSomething_Server();\n```", "```cpp\nvoid DoSomething_Server_Implementation()\n{ /* Your code here */ }\n```", "```cpp\nUFUNCTION(Client, Reliable)\nvoid DoSomethingReliably_Client();\n```", "```cpp\nUFUNCTION(Server, WithValidation)\nvoid DoSomethingWithValidation();\n```", "```cpp\nvoid DoSomethingWithValidation_Implementation()\n{ /* Your code here */ }\n```", "```cpp\nbool DoSomethingWithValidation_Validate()\n{ /* Your code here */ }\n```", "```cpp\nUFUNCTION(Server, Reliable)\nvoid SprintStart_Server();\nUFUNCTION(Server, Reliable)\nvoid SprintEnd_Server();\n```", "```cpp\nvoid AUS_Character::SprintStart_Server_Implementation()\n{\n if (GetCharacterStats())\n {\n  GetCharacterMovement()->MaxWalkSpeed = GetCharacterStats()->SprintSpeed;\n }\n}\nvoid AUS_Character::SprintEnd_Server_Implementation()\n{\n if (GetCharacterStats())\n {\n  GetCharacterMovement()->MaxWalkSpeed = GetCharacterStats()->WalkSpeed;\n }\n}\n```", "```cpp\nSprintStart_Server();\n```", "```cpp\nSprintEnd_Server();\n```", "```cpp\nauto IsSprinting = false;\nif(GetCharacterStats())\n{\n IsSprinting = GetCharacterMovement()->MaxWalkSpeed == GetCharacterStats()->SprintSpeed;\n}\n```", "```cpp\nGetCharacterMovement()->MaxWalkSpeed = GetCharacterStats()->WalkSpeed;\n```", "```cpp\nif(IsSprinting)\n{\n SprintStart_Server();\n}\n```", "```cpp\n#pragma once\n#include \"CoreMinimal.h\"\n#include \"UObject/Interface.h\"\n#include \"US_Interactable.generated.h\"\nUINTERFACE(MinimalAPI, Blueprintable)\nclass UUS_Interactable : public UInterface\n{\n GENERATED_BODY()\n};\nclass UNREALSHADOWS_LOTL_API IUS_Interactable\n{\n GENERATED_BODY()\npublic:\n UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = \"Interaction\", meta=(DisplayName=\"Interact\"))\n void Interact(class AUS_Character* CharacterInstigator);\n UFUNCTION(BlueprintCallable, BlueprintNativeEvent, Category = \"Interaction\", meta=(DisplayName=\"Can Interact\"))\n bool CanInteract( AUS_Character * CharacterInstigator) const;\n};\n```", "```cpp\nvoid Interact(const FInputActionValue& Value);\n```", "```cpp\nUFUNCTION(Server, Reliable)\nvoid Interact_Server();\n```", "```cpp\nUPROPERTY()\nAActor* InteractableActor;\n```", "```cpp\n#include \"US_Interactable.h\"\n#include \"Kismet/KismetSystemLibrary.h\"\n```", "```cpp\nInteract_Server();\n```", "```cpp\nvoid AUS_Character::Interact_Server_Implementation()\n{\n if(InteractableActor)\n {\n  IUS_Interactable::Execute_Interact(InteractableActor, this);\n }\n}\n```", "```cpp\nif(GetLocalRole() != ROLE_Authority) return;\nFHitResult HitResult;\nFCollisionQueryParams QueryParams;\nQueryParams.bTraceComplex = true;\nQueryParams.AddIgnoredActor(this);\nauto SphereRadius = 50.f;\nauto StartLocation = GetActorLocation() + GetActorForwardVector() * 150.f;\nauto EndLocation = StartLocation + GetActorForwardVector() * 500.f;\nauto IsHit = UKismetSystemLibrary::SphereTraceSingle(\n GetWorld(),\n StartLocation,\n EndLocation,\n SphereRadius,\n UEngineTypes::ConvertToTraceType(ECC_WorldStatic),\n false,\n TArray<AActor*>(),\n EDrawDebugTrace::ForOneFrame,\n HitResult,\n true\n);\n```", "```cpp\nif (IsHit && HitResult.GetActor()->GetClass()->ImplementsInterface(UUS_Interactable::StaticClass()))\n{\n DrawDebugSphere(GetWorld(), HitResult.ImpactPoint, SphereRadius, 12, FColor::Magenta, false, 1.f);\n InteractableActor = HitResult.GetActor();\n}\nelse\n{\n InteractableActor = nullptr;\n}\n```"]