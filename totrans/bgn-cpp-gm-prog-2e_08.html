<html><head></head><body>
		<div id="_idContainer057">
			<h1 id="_idParaDest-171"><a id="_idTextAnchor175"/><em class="italic">Chapter 7</em>: Dynamic Collision Detection and Physics – Finishing the Pong Game</h1>
			<p>In this chapter, we will code our second class. We will see that although the ball is obviously quite different from the bat, we will use the exact same techniques to encapsulate the appearance and functionality of a ball inside a <strong class="source-inline">Ball</strong> class, just like we did with the bat and the <strong class="source-inline">Bat</strong> class. We will then add the finishing touches to the Pong game by coding some dynamic collision detection and scorekeeping. This might sound complicated but as we are coming to expect, SFML will make things much easier than they otherwise would be.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Coding the Ball class</li>
				<li>Using the Ball class</li>
				<li>Collision detection and scoring</li>
				<li>Running the game </li>
			</ul>
			<p>We will start by coding the class that represents the ball.</p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor176"/>Coding the Ball class</h1>
			<p>To get started, we will code the header file. Right-click on <strong class="bold">Header Files</strong> in the Solution Explorer window and select <strong class="bold">ADD</strong> | <strong class="bold">New Item</strong>. Next, choose the <strong class="bold">Header File (.h)</strong> option and name the new file <strong class="source-inline">Ball.h</strong>. Click the <strong class="bold">Add</strong> button. Now, we are ready to code the file.</p>
			<p>Add the following code to <strong class="source-inline">Ball.h</strong>:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Ball</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    Vector2f m_Position;    </p>
			<p class="source-code">    RectangleShape m_Shape;</p>
			<p class="source-code">    float m_Speed = 300.0f;</p>
			<p class="source-code">    float m_DirectionX = .2f;</p>
			<p class="source-code">    float m_DirectionY = .2f;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    Ball(float startX, float startY);</p>
			<p class="source-code">    FloatRect getPosition();</p>
			<p class="source-code">    RectangleShape getShape();</p>
			<p class="source-code">    float getXVelocity();</p>
			<p class="source-code">    void reboundSides();</p>
			<p class="source-code">    void reboundBatOrTop();</p>
			<p class="source-code">    void reboundBottom();</p>
			<p class="source-code">    void update(Time dt);</p>
			<p class="source-code">};</p>
			<p>The first thing you will notice is the similarity in the member variables compared to the <strong class="source-inline">Bat</strong> class. There is a member variable for the position, appearance, and speed, just like there was for the player's bat, and they are the same types (<strong class="source-inline">Vector2f</strong>, <strong class="source-inline">RectangleShape</strong>, and <strong class="source-inline">float</strong>, respectively). They even have the same names (<strong class="source-inline">m_Position</strong>, <strong class="source-inline">m_Shape</strong>, and <strong class="source-inline">m_Speed</strong>, respectively). The difference between the member variables of this class is that the direction is handled with two <strong class="source-inline">float</strong> variables that will track horizontal and vertical movement. These are <strong class="source-inline">m_DirectionX</strong> and <strong class="source-inline">m_DirectionY</strong>.</p>
			<p>Note that we will need to code eight functions to bring the ball to life. There is a constructor that has the same name as the class, which we will use to initialize a <strong class="source-inline">Ball</strong> instance. There are three functions with the same name and usage as the <strong class="source-inline">Bat</strong> class. They are <strong class="source-inline">getPosition</strong>, <strong class="source-inline">getShape</strong>, and <strong class="source-inline">update</strong>. The <strong class="source-inline">getPosition</strong> and <strong class="source-inline">getShape</strong> functions will share the location and the appearance of the ball with the <strong class="source-inline">main</strong> function, and the <strong class="source-inline">update</strong> function will be called from the <strong class="source-inline">main</strong> function to allow the <strong class="source-inline">Ball</strong> class to update its position once per frame. </p>
			<p>The remaining functions control the direction the ball will travel in. The <strong class="source-inline">reboundSides</strong> function will be called from <strong class="source-inline">main</strong> when a collision is detected with either side of the screen, the <strong class="source-inline">reboundBatOrTop</strong> function will be called in response to the ball hitting the player's bat or the top of the screen, and the <strong class="source-inline">reboundBottom</strong> function will be called when the ball hits the bottom of the screen.</p>
			<p>Of course, these are just the declarations, so let's write the C++ that actually does the work in the <strong class="source-inline">Ball.cpp</strong> file.</p>
			<p>Let's create the file, and then we can start discussing the code. Right-click the <strong class="bold">Source Files</strong> folder in the Solution Explorer window. Now, select <strong class="bold">C++ File (.cpp)</strong> and enter <strong class="source-inline">Ball.cpp</strong> in the <strong class="bold">Name:</strong> field. Click the <strong class="bold">Add</strong> button and our new file will be created for us.</p>
			<p>Add the following code to <strong class="source-inline">Ball.cpp</strong>:</p>
			<p class="source-code">#include "Ball.h"</p>
			<p class="source-code">// This the constructor function</p>
			<p class="source-code">Ball::Ball(float startX, float startY)</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Position.x = startX;</p>
			<p class="source-code">    m_Position.y = startY;</p>
			<p class="source-code">    m_Shape.setSize(sf::Vector2f(10, 10));</p>
			<p class="source-code">    m_Shape.setPosition(m_Position);</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we have added the required <strong class="source-inline">include</strong> directive for the <strong class="source-inline">Ball </strong>class header file. The constructor function with the same name as the class receives two <strong class="source-inline">float</strong> parameters, which are used to initialize the <strong class="source-inline">m_Position</strong> member's <strong class="source-inline">Vector2f</strong> instance. The <strong class="source-inline">RectangleShape</strong> instance is then sized with the <strong class="source-inline">setSize</strong> function and positioned with <strong class="source-inline">setPosition</strong>. The size that's being used is 10 pixels wide and 10 high; this is arbitrary but works well. The position that's being used is, of course, taken from the <strong class="source-inline">m_Position Vector2f</strong> instance.</p>
			<p>Add the following code underneath the constructor in the <strong class="source-inline">Ball.cpp</strong> function:</p>
			<p class="source-code">FloatRect Ball::getPosition()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Shape.getGlobalBounds();</p>
			<p class="source-code">}</p>
			<p class="source-code">RectangleShape Ball::getShape()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Shape;</p>
			<p class="source-code">}</p>
			<p class="source-code">float Ball::getXVelocity()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_DirectionX;</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we are coding the three getter functions of the <strong class="source-inline">Ball</strong> class. They each return something to the <strong class="source-inline">main</strong> function. The first, <strong class="source-inline">getPosition</strong>, uses the <strong class="source-inline">getGlobalBounds</strong> function on <strong class="source-inline">m_Shape</strong> to return a <strong class="source-inline">FloatRect</strong> instance. This will be used for collision detection. </p>
			<p>The <strong class="source-inline">getShape</strong> function returns <strong class="source-inline">m_Shape</strong> so that it can be drawn each frame of the game loop. The <strong class="source-inline">getXVelocity</strong> function tells the <strong class="source-inline">main</strong> function which direction the ball is traveling in, and we will see very soon exactly how this is useful to us. Since we don't ever need to get the vertical velocity, there is no corresponding <strong class="source-inline">getYVelocity</strong> function, but it would be simple to add one if we did.</p>
			<p>Add the following functions underneath the previous code we just added:</p>
			<p class="source-code">void Ball::reboundSides()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_DirectionX = -m_DirectionX;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Ball::reboundBatOrTop()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_DirectionY = -m_DirectionY;</p>
			<p class="source-code">}</p>
			<p class="source-code">void Ball::reboundBottom()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Position.y = 0;</p>
			<p class="source-code">    m_Position.x = 500;</p>
			<p class="source-code">    m_DirectionY = -m_DirectionY;</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the three functions whose names begin with <strong class="source-inline">rebound…</strong> handle what happens when the ball collides with various places. In the <strong class="source-inline">reboundSides</strong> function, <strong class="source-inline">m_DirectionX</strong> has its value inverted, which will have the effect of making a positive value negative and a negative value positive, thereby reversing (horizontally) the direction the ball is traveling in. <strong class="source-inline">reboundBatOrTop</strong> does exactly the same but with <strong class="source-inline">m_DirectionY</strong>, which has the effect of reversing the direction the ball is traveling in vertically. The <strong class="source-inline">reboundBottom</strong> function repositions the ball at the top center of the screen and sends it downward. This is just what we want after the player has missed a ball and it has hit the bottom of the screen.</p>
			<p>Finally, for the <strong class="source-inline">Ball</strong> class, add the update function, as follows:</p>
			<p class="source-code">void Ball::update(Time dt)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Update the ball's position</p>
			<p class="source-code">    m_Position.y += m_DirectionY * m_Speed * dt.asSeconds();</p>
			<p class="source-code">    m_Position.x += m_DirectionX * m_Speed * dt.asSeconds();</p>
			<p class="source-code">    // Move the ball </p>
			<p class="source-code">    m_Shape.setPosition(m_Position);</p>
			<p class="source-code">}</p>
			<p>In the preceding code, <strong class="source-inline">m_Position.y</strong> and <strong class="source-inline">m_Position.x</strong> are updated using the appropriate direction velocity, the speed, and the amount of time the current frame took to complete. The newly updated <strong class="source-inline">m_Position</strong> values are then used to change the position the <strong class="source-inline">m_Shape RectangleShape</strong> instance is positioned at.</p>
			<p>The <strong class="source-inline">Ball</strong> class is done, so let's put it into action.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor177"/>Using the Ball class</h1>
			<p>To put the ball into action, add the following code to make the <strong class="source-inline">Ball</strong> class available in the <strong class="source-inline">main</strong> function:</p>
			<p class="source-code">#include "Ball.h"</p>
			<p>Add the following highlighted line of code to declare and initialize an instance of the <strong class="source-inline">Ball</strong> class using the constructor function that we have just coded:</p>
			<p class="source-code">// Create a bat</p>
			<p class="source-code">Bat bat(1920 / 2, 1080 - 20);</p>
			<p class="source-code">// Create a ball</p>
			<p class="source-code"><strong class="bold">Ball ball(1920 / 2, 0);</strong></p>
			<p class="source-code">// Create a Text object called HUD</p>
			<p class="source-code">Text hud;</p>
			<p>Add the following code positioned exactly as highlighted:</p>
			<p class="source-code">/*</p>
			<p class="source-code">Update the bat, the ball and the HUD</p>
			<p class="source-code">****************************************************</p>
			<p class="source-code">****************************************************</p>
			<p class="source-code">****************************************************</p>
			<p class="source-code">*/</p>
			<p class="source-code">// Update the delta time</p>
			<p class="source-code">Time dt = clock.restart();</p>
			<p class="source-code">bat.update(dt);</p>
			<p class="source-code"><strong class="bold">ball.update(dt);</strong></p>
			<p class="source-code">// Update the HUD text</p>
			<p class="source-code">std::stringstream ss;</p>
			<p class="source-code">ss &lt;&lt; "Score:" &lt;&lt; score &lt;&lt; "    Lives:" &lt;&lt; lives;</p>
			<p class="source-code">hud.setString(ss.str());</p>
			<p>In the preceding code, we simply call <strong class="source-inline">update</strong> on the <strong class="source-inline">ball</strong> instance. The ball will be repositioned accordingly.</p>
			<p>Add the following highlighted code to draw the ball on each frame of the game loop:</p>
			<p class="source-code">/*</p>
			<p class="source-code">Draw the bat, the ball and the HUD</p>
			<p class="source-code">*********************************************</p>
			<p class="source-code">*********************************************</p>
			<p class="source-code">*********************************************</p>
			<p class="source-code">*/</p>
			<p class="source-code">window.clear();</p>
			<p class="source-code">window.draw(hud);</p>
			<p class="source-code">window.draw(bat.getShape());</p>
			<p class="source-code"><strong class="bold">window.draw(ball.getShape());</strong></p>
			<p class="source-code">window.display();</p>
			<p>At this stage, you could run the game and the ball would spawn at the top of the screen and begin its descent toward the bottom of the screen. It would, however, disappear off the bottom of the screen because we are not detecting any collisions yet. Let's fix that now.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor178"/>Collision detection and scoring</h1>
			<p>Unlike in the Timber!!! game when we simply checked whether a branch in the lowest position was on the same side as the player's character, in this game, we will need to mathematically check for the intersection of the ball with the bat or the ball with any of the four sides of the screen.</p>
			<p>Let's look at some hypothetical code that would achieve this so that we understand what we are doing. Then, we will turn to SFML to solve the problem for us.</p>
			<p>The code for testing the intersection of two rectangles would look something like this. Don't use the following code. It is for demonstration purposes only:</p>
			<p class="source-code">if(objectA.getPosition().right &gt; objectB.getPosition().left</p>
			<p class="source-code">    &amp;&amp; objectA.getPosition().left &lt; objectB.getPosition().right )</p>
			<p class="source-code">{    </p>
			<p class="source-code">    // objectA is intersecting objectB on x axis    </p>
			<p class="source-code">    // But they could be at different heights    </p>
			<p class="source-code">    </p>
			<p class="source-code">    if(objectA.getPosition().top &lt; objectB.getPosition().bottom         </p>
			<p class="source-code">        &amp;&amp; objectA.getPosition().bottom &gt; objectB.getPosition().top )</p>
			<p class="source-code">        {       </p>
			<p class="source-code">            // objectA is intersecting objectB on y axis as well </p>
			<p class="source-code">            // Collision detected  </p>
			<p class="source-code">        } </p>
			<p class="source-code">}</p>
			<p>We don't need to write this code; however, we will be using the SFML <strong class="source-inline">intersects</strong> function, which works on <strong class="source-inline">FloatRect</strong> objects. Think or look back to the <strong class="source-inline">Bat</strong> and <strong class="source-inline">Ball</strong> classes; they both had a <strong class="source-inline">getPosition</strong> function, which returned a <strong class="source-inline">FloatRect</strong> of the object's current location. We will see how we can use <strong class="source-inline">getPosition</strong>, along with <strong class="source-inline">intersects</strong>, to do all our collision detection.</p>
			<p>Add the following highlighted code at the end of the update section of the main function:</p>
			<p class="source-code">/*</p>
			<p class="source-code">Update the bat, the ball and the HUD</p>
			<p class="source-code">**************************************</p>
			<p class="source-code">**************************************</p>
			<p class="source-code">**************************************</p>
			<p class="source-code">*/</p>
			<p class="source-code">// Update the delta time</p>
			<p class="source-code">Time dt = clock.restart();</p>
			<p class="source-code">bat.update(dt);</p>
			<p class="source-code">ball.update(dt);</p>
			<p class="source-code">// Update the HUD text</p>
			<p class="source-code">std::stringstream ss;</p>
			<p class="source-code">ss &lt;&lt; "Score:" &lt;&lt; score &lt;&lt; "    Lives:" &lt;&lt; lives;</p>
			<p class="source-code">hud.setString(ss.str());</p>
			<p class="source-code"><strong class="bold">// Handle ball hitting the bottom</strong></p>
			<p class="source-code"><strong class="bold">if (ball.getPosition().top &gt; window.getSize().y)</strong></p>
			<p class="source-code"><strong class="bold">{</strong></p>
			<p class="source-code"><strong class="bold">    // reverse the ball direction</strong></p>
			<p class="source-code"><strong class="bold">    ball.reboundBottom();</strong></p>
			<p class="source-code"><strong class="bold">    // Remove a life</strong></p>
			<p class="source-code"><strong class="bold">    lives--;</strong></p>
			<p class="source-code"><strong class="bold">    // Check for zero lives</strong></p>
			<p class="source-code"><strong class="bold">    if (lives &lt; 1) {</strong></p>
			<p class="source-code"><strong class="bold">        // reset the score</strong></p>
			<p class="source-code"><strong class="bold">        score = 0;</strong></p>
			<p class="source-code"><strong class="bold">        // reset the lives</strong></p>
			<p class="source-code"><strong class="bold">        lives = 3;</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code"><strong class="bold">}</strong></p>
			<p>In the preceding code, the first <strong class="source-inline">if</strong> condition checks whether the ball has hit the bottom of the screen:</p>
			<p class="source-code"><strong class="bold">if (ball.getPosition().top &gt; window.getSize().y)</strong></p>
			<p>If the top of the ball is at a greater position than the height of the window, then the ball has disappeared off the bottom of the player's view. In response, the <strong class="source-inline">ball.reboundBottom</strong> function is called. Remember that, in this function, the ball is repositioned at the top of the screen. At this point, the player has lost a life, so the <strong class="source-inline">lives</strong> variable is decremented.</p>
			<p>The second <strong class="source-inline">if</strong> condition checks whether the player has run out of lives (<strong class="source-inline">lives &lt; 1</strong>). If this is the case, the score is reset to 0, the number of lives is reset to 3, and the game is restarted. In the next project, we will learn how to keep and display the player's highest score.</p>
			<p>Add the following code underneath the previous code:</p>
			<p class="source-code">// Handle ball hitting top</p>
			<p class="source-code">if (ball.getPosition().top &lt; 0)</p>
			<p class="source-code">{</p>
			<p class="source-code">    ball.reboundBatOrTop();</p>
			<p class="source-code">    // Add a point to the players score</p>
			<p class="source-code">    score++;</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we are detecting that the top of the ball hits the top of the screen. When this occurs, the player is awarded a point and <strong class="source-inline">ball.reboundBatOrTop</strong> is called, which reverses the vertical direction of travel and sends the ball back toward the bottom of the screen.</p>
			<p>Add the following code underneath the previous code:</p>
			<p class="source-code">// Handle ball hitting sides</p>
			<p class="source-code">if (ball.getPosition().left &lt; 0 || </p>
			<p class="source-code">    ball.getPosition().left + ball.getPosition().width&gt; window.getSize().x)</p>
			<p class="source-code">{</p>
			<p class="source-code">    ball.reboundSides();</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the <strong class="source-inline">if</strong> condition detects a collision with the left-hand side of the ball with the left-hand side of the screen or the right-hand side of the ball (left + 10) with the right-hand side of the screen. In either event, the <strong class="source-inline">ball.reboundSides</strong> function is called and the horizontal direction of travel is reversed.</p>
			<p>Add the following code:</p>
			<p class="source-code">// Has the ball hit the bat?</p>
			<p class="source-code">if (ball.getPosition().intersects(bat.getPosition()))</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Hit detected so reverse the ball and score a point</p>
			<p class="source-code">    ball.reboundBatOrTop();</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the <strong class="source-inline">intersects</strong> function is used to determine whether the ball has hit the bat. When this occurs, we use the same function that we used for a collision with the top of the screen to reverse the vertical direction of travel of the ball.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor179"/>Running the game</h1>
			<p>You can now run the game and bounce the ball around the screen. The score will increase when you hit the ball with the bat and the lives will decrease when you miss it. When <strong class="source-inline">lives</strong> gets to 0, the score will reset, and the <strong class="source-inline">lives</strong> will go back up to 3, as follows:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Image86489.jpg" alt=""/>
				</div>
			</div>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor180"/>Summary</h1>
			<p>Congratulations; that's the second game completed! We could have added more features to that game such as coop play, high scores, sound effects, and more, but I just wanted to use the simplest possible example to introduce classes and dynamic collision detection. Now that we hav<a id="_idTextAnchor181"/>e these topics in our game developer's arsenal, we can move on to a much more exciting project and yet more game development topics. </p>
			<p>In the next chapter, we will plan the Zombie Arena game, learn about the SFML <strong class="source-inline">View</strong> class, which acts as a virtual camera into our game world, and code some more classes.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor182"/>FAQ</h1>
			<p>Q) Isn't this game a little quiet?</p>
			<p>A) I didn't add sound effects to this game because I wanted to keep the code as short as possible while using our first classes and learning to use the time to smoothly animate all the game objects. If you want to add sound effects, then all you need to do is add the .wav files to the project, use SFML to load the sounds, and play a sound effect in each of the collision events. We will do this in the next project.</p>
			<p>Q) The game is too easy! How can I make the ball speed up a little?</p>
			<p>A) There are lots of ways you can make the game more challenging. One simple way would be to add a line of code in the <strong class="source-inline">Ball</strong> class' <strong class="source-inline">reboundBatOrTop</strong> function that increases the speed. As an example, the following code would increase the speed of the ball by 10% each time the function is called:</p>
			<p class="source-code">// Speed up a little bit on each hit</p>
			<p class="source-code">m_Speed = m_Speed * 1.1f;</p>
			<p>The ball would get quite fast quite quickly. You would then need to devise a way to reset the speed back to <strong class="source-inline">300.0f</strong> when the player has lost all their lives. You could create a new function in the <strong class="source-inline">Ball</strong> class, perhaps called <strong class="source-inline">resetSpeed</strong>, and call it from <strong class="source-inline">main</strong> when the code detects that the player has lost their last life.</p>
		</div>
	</body></html>