<html><head></head><body>
		<div><h1 id="_idParaDest-171"><a id="_idTextAnchor175"/><em class="italic">Chapter 7</em>: Dynamic Collision Detection and Physics – Finishing the Pong Game</h1>
			<p>In this chapter, we will code our second class. We will see that although the ball is obviously quite different from the bat, we will use the exact same techniques to encapsulate the appearance and functionality of a ball inside a <code>Ball</code> class, just like we did with the bat and the <code>Bat</code> class. We will then add the finishing touches to the Pong game by coding some dynamic collision detection and scorekeeping. This might sound complicated but as we are coming to expect, SFML will make things much easier than they otherwise would be.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Coding the Ball class</li>
				<li>Using the Ball class</li>
				<li>Collision detection and scoring</li>
				<li>Running the game </li>
			</ul>
			<p>We will start by coding the class that represents the ball.</p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor176"/>Coding the Ball class</h1>
			<p>To get started, we will code the header file. Right-click on <code>Ball.h</code>. Click the <strong class="bold">Add</strong> button. Now, we are ready to code the file.</p>
			<p>Add the following code to <code>Ball.h</code>:</p>
			<pre>#pragma once
#include &lt;SFML/Graphics.hpp&gt;
using namespace sf;
class Ball
{
private:
    Vector2f m_Position;    
    RectangleShape m_Shape;
    float m_Speed = 300.0f;
    float m_DirectionX = .2f;
    float m_DirectionY = .2f;
public:
    Ball(float startX, float startY);
    FloatRect getPosition();
    RectangleShape getShape();
    float getXVelocity();
    void reboundSides();
    void reboundBatOrTop();
    void reboundBottom();
    void update(Time dt);
};</pre>
			<p>The first thing you will notice is the similarity in the member variables compared to the <code>Bat</code> class. There is a member variable for the position, appearance, and speed, just like there was for the player's bat, and they are the same types (<code>Vector2f</code>, <code>RectangleShape</code>, and <code>float</code>, respectively). They even have the same names (<code>m_Position</code>, <code>m_Shape</code>, and <code>m_Speed</code>, respectively). The difference between the member variables of this class is that the direction is handled with two <code>float</code> variables that will track horizontal and vertical movement. These are <code>m_DirectionX</code> and <code>m_DirectionY</code>.</p>
			<p>Note that we will need to code eight functions to bring the ball to life. There is a constructor that has the same name as the class, which we will use to initialize a <code>Ball</code> instance. There are three functions with the same name and usage as the <code>Bat</code> class. They are <code>getPosition</code>, <code>getShape</code>, and <code>update</code>. The <code>getPosition</code> and <code>getShape</code> functions will share the location and the appearance of the ball with the <code>main</code> function, and the <code>update</code> function will be called from the <code>main</code> function to allow the <code>Ball</code> class to update its position once per frame. </p>
			<p>The remaining functions control the direction the ball will travel in. The <code>reboundSides</code> function will be called from <code>main</code> when a collision is detected with either side of the screen, the <code>reboundBatOrTop</code> function will be called in response to the ball hitting the player's bat or the top of the screen, and the <code>reboundBottom</code> function will be called when the ball hits the bottom of the screen.</p>
			<p>Of course, these are just the declarations, so let's write the C++ that actually does the work in the <code>Ball.cpp</code> file.</p>
			<p>Let's create the file, and then we can start discussing the code. Right-click the <code>Ball.cpp</code> in the <strong class="bold">Name:</strong> field. Click the <strong class="bold">Add</strong> button and our new file will be created for us.</p>
			<p>Add the following code to <code>Ball.cpp</code>:</p>
			<pre>#include "Ball.h"
// This the constructor function
Ball::Ball(float startX, float startY)
{
    m_Position.x = startX;
    m_Position.y = startY;
    m_Shape.setSize(sf::Vector2f(10, 10));
    m_Shape.setPosition(m_Position);
}</pre>
			<p>In the preceding code, we have added the required <code>include</code> directive for the <code>Ball </code>class header file. The constructor function with the same name as the class receives two <code>float</code> parameters, which are used to initialize the <code>m_Position</code> member's <code>Vector2f</code> instance. The <code>RectangleShape</code> instance is then sized with the <code>setSize</code> function and positioned with <code>setPosition</code>. The size that's being used is 10 pixels wide and 10 high; this is arbitrary but works well. The position that's being used is, of course, taken from the <code>m_Position Vector2f</code> instance.</p>
			<p>Add the following code underneath the constructor in the <code>Ball.cpp</code> function:</p>
			<pre>FloatRect Ball::getPosition()
{
    return m_Shape.getGlobalBounds();
}
RectangleShape Ball::getShape()
{
    return m_Shape;
}
float Ball::getXVelocity()
{
    return m_DirectionX;
}</pre>
			<p>In the preceding code, we are coding the three getter functions of the <code>Ball</code> class. They each return something to the <code>main</code> function. The first, <code>getPosition</code>, uses the <code>getGlobalBounds</code> function on <code>m_Shape</code> to return a <code>FloatRect</code> instance. This will be used for collision detection. </p>
			<p>The <code>getShape</code> function returns <code>m_Shape</code> so that it can be drawn each frame of the game loop. The <code>getXVelocity</code> function tells the <code>main</code> function which direction the ball is traveling in, and we will see very soon exactly how this is useful to us. Since we don't ever need to get the vertical velocity, there is no corresponding <code>getYVelocity</code> function, but it would be simple to add one if we did.</p>
			<p>Add the following functions underneath the previous code we just added:</p>
			<pre>void Ball::reboundSides()
{
    m_DirectionX = -m_DirectionX;
}
void Ball::reboundBatOrTop()
{
    m_DirectionY = -m_DirectionY;
}
void Ball::reboundBottom()
{
    m_Position.y = 0;
    m_Position.x = 500;
    m_DirectionY = -m_DirectionY;
}</pre>
			<p>In the preceding code, the three functions whose names begin with <code>rebound…</code> handle what happens when the ball collides with various places. In the <code>reboundSides</code> function, <code>m_DirectionX</code> has its value inverted, which will have the effect of making a positive value negative and a negative value positive, thereby reversing (horizontally) the direction the ball is traveling in. <code>reboundBatOrTop</code> does exactly the same but with <code>m_DirectionY</code>, which has the effect of reversing the direction the ball is traveling in vertically. The <code>reboundBottom</code> function repositions the ball at the top center of the screen and sends it downward. This is just what we want after the player has missed a ball and it has hit the bottom of the screen.</p>
			<p>Finally, for the <code>Ball</code> class, add the update function, as follows:</p>
			<pre>void Ball::update(Time dt)
{
    // Update the ball's position
    m_Position.y += m_DirectionY * m_Speed * dt.asSeconds();
    m_Position.x += m_DirectionX * m_Speed * dt.asSeconds();
    // Move the ball 
    m_Shape.setPosition(m_Position);
}</pre>
			<p>In the preceding code, <code>m_Position.y</code> and <code>m_Position.x</code> are updated using the appropriate direction velocity, the speed, and the amount of time the current frame took to complete. The newly updated <code>m_Position</code> values are then used to change the position the <code>m_Shape RectangleShape</code> instance is positioned at.</p>
			<p>The <code>Ball</code> class is done, so let's put it into action.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor177"/>Using the Ball class</h1>
			<p>To put the ball into action, add the following code to make the <code>Ball</code> class available in the <code>main</code> function:</p>
			<pre>#include "Ball.h"</pre>
			<p>Add the following highlighted line of code to declare and initialize an instance of the <code>Ball</code> class using the constructor function that we have just coded:</p>
			<pre>// Create a bat
Bat bat(1920 / 2, 1080 - 20);
// Create a ball
<strong class="bold">Ball ball(1920 / 2, 0);</strong>
// Create a Text object called HUD
Text hud;</pre>
			<p>Add the following code positioned exactly as highlighted:</p>
			<pre>/*
Update the bat, the ball and the HUD
****************************************************
****************************************************
****************************************************
*/
// Update the delta time
Time dt = clock.restart();
bat.update(dt);
<strong class="bold">ball.update(dt);</strong>
// Update the HUD text
std::stringstream ss;
ss &lt;&lt; "Score:" &lt;&lt; score &lt;&lt; "    Lives:" &lt;&lt; lives;
hud.setString(ss.str());</pre>
			<p>In the preceding code, we simply call <code>update</code> on the <code>ball</code> instance. The ball will be repositioned accordingly.</p>
			<p>Add the following highlighted code to draw the ball on each frame of the game loop:</p>
			<pre>/*
Draw the bat, the ball and the HUD
*********************************************
*********************************************
*********************************************
*/
window.clear();
window.draw(hud);
window.draw(bat.getShape());
<strong class="bold">window.draw(ball.getShape());</strong>
window.display();</pre>
			<p>At this stage, you could run the game and the ball would spawn at the top of the screen and begin its descent toward the bottom of the screen. It would, however, disappear off the bottom of the screen because we are not detecting any collisions yet. Let's fix that now.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor178"/>Collision detection and scoring</h1>
			<p>Unlike in the Timber!!! game when we simply checked whether a branch in the lowest position was on the same side as the player's character, in this game, we will need to mathematically check for the intersection of the ball with the bat or the ball with any of the four sides of the screen.</p>
			<p>Let's look at some hypothetical code that would achieve this so that we understand what we are doing. Then, we will turn to SFML to solve the problem for us.</p>
			<p>The code for testing the intersection of two rectangles would look something like this. Don't use the following code. It is for demonstration purposes only:</p>
			<pre>if(objectA.getPosition().right &gt; objectB.getPosition().left
    &amp;&amp; objectA.getPosition().left &lt; objectB.getPosition().right )
{    
    // objectA is intersecting objectB on x axis    
    // But they could be at different heights    
    
    if(objectA.getPosition().top &lt; objectB.getPosition().bottom         
        &amp;&amp; objectA.getPosition().bottom &gt; objectB.getPosition().top )
        {       
            // objectA is intersecting objectB on y axis as well 
            // Collision detected  
        } 
}</pre>
			<p>We don't need to write this code; however, we will be using the SFML <code>intersects</code> function, which works on <code>FloatRect</code> objects. Think or look back to the <code>Bat</code> and <code>Ball</code> classes; they both had a <code>getPosition</code> function, which returned a <code>FloatRect</code> of the object's current location. We will see how we can use <code>getPosition</code>, along with <code>intersects</code>, to do all our collision detection.</p>
			<p>Add the following highlighted code at the end of the update section of the main function:</p>
			<pre>/*
Update the bat, the ball and the HUD
**************************************
**************************************
**************************************
*/
// Update the delta time
Time dt = clock.restart();
bat.update(dt);
ball.update(dt);
// Update the HUD text
std::stringstream ss;
ss &lt;&lt; "Score:" &lt;&lt; score &lt;&lt; "    Lives:" &lt;&lt; lives;
hud.setString(ss.str());
<strong class="bold">// Handle ball hitting the bottom</strong>
<strong class="bold">if (ball.getPosition().top &gt; window.getSize().y)</strong>
<strong class="bold">{</strong>
<strong class="bold">    // reverse the ball direction</strong>
<strong class="bold">    ball.reboundBottom();</strong>
<strong class="bold">    // Remove a life</strong>
<strong class="bold">    lives--;</strong>
<strong class="bold">    // Check for zero lives</strong>
<strong class="bold">    if (lives &lt; 1) {</strong>
<strong class="bold">        // reset the score</strong>
<strong class="bold">        score = 0;</strong>
<strong class="bold">        // reset the lives</strong>
<strong class="bold">        lives = 3;</strong>
<strong class="bold">    }</strong>
<strong class="bold">}</strong></pre>
			<p>In the preceding code, the first <code>if</code> condition checks whether the ball has hit the bottom of the screen:</p>
			<pre><strong class="bold">if (ball.getPosition().top &gt; window.getSize().y)</strong></pre>
			<p>If the top of the ball is at a greater position than the height of the window, then the ball has disappeared off the bottom of the player's view. In response, the <code>ball.reboundBottom</code> function is called. Remember that, in this function, the ball is repositioned at the top of the screen. At this point, the player has lost a life, so the <code>lives</code> variable is decremented.</p>
			<p>The second <code>if</code> condition checks whether the player has run out of lives (<code>lives &lt; 1</code>). If this is the case, the score is reset to 0, the number of lives is reset to 3, and the game is restarted. In the next project, we will learn how to keep and display the player's highest score.</p>
			<p>Add the following code underneath the previous code:</p>
			<pre>// Handle ball hitting top
if (ball.getPosition().top &lt; 0)
{
    ball.reboundBatOrTop();
    // Add a point to the players score
    score++;
}</pre>
			<p>In the preceding code, we are detecting that the top of the ball hits the top of the screen. When this occurs, the player is awarded a point and <code>ball.reboundBatOrTop</code> is called, which reverses the vertical direction of travel and sends the ball back toward the bottom of the screen.</p>
			<p>Add the following code underneath the previous code:</p>
			<pre>// Handle ball hitting sides
if (ball.getPosition().left &lt; 0 || 
    ball.getPosition().left + ball.getPosition().width&gt; window.getSize().x)
{
    ball.reboundSides();
}</pre>
			<p>In the preceding code, the <code>if</code> condition detects a collision with the left-hand side of the ball with the left-hand side of the screen or the right-hand side of the ball (left + 10) with the right-hand side of the screen. In either event, the <code>ball.reboundSides</code> function is called and the horizontal direction of travel is reversed.</p>
			<p>Add the following code:</p>
			<pre>// Has the ball hit the bat?
if (ball.getPosition().intersects(bat.getPosition()))
{
    // Hit detected so reverse the ball and score a point
    ball.reboundBatOrTop();
}</pre>
			<p>In the preceding code, the <code>intersects</code> function is used to determine whether the ball has hit the bat. When this occurs, we use the same function that we used for a collision with the top of the screen to reverse the vertical direction of travel of the ball.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor179"/>Running the game</h1>
			<p>You can now run the game and bounce the ball around the screen. The score will increase when you hit the ball with the bat and the lives will decrease when you miss it. When <code>lives</code> gets to 0, the score will reset, and the <code>lives</code> will go back up to 3, as follows:</p>
			<div><div><img src="img/Image86489.jpg" alt=""/>
				</div>
			</div>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor180"/>Summary</h1>
			<p>Congratulations; that's the second game completed! We could have added more features to that game such as coop play, high scores, sound effects, and more, but I just wanted to use the simplest possible example to introduce classes and dynamic collision detection. Now that we hav<a id="_idTextAnchor181"/>e these topics in our game developer's arsenal, we can move on to a much more exciting project and yet more game development topics. </p>
			<p>In the next chapter, we will plan the Zombie Arena game, learn about the SFML <code>View</code> class, which acts as a virtual camera into our game world, and code some more classes.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor182"/>FAQ</h1>
			<p>Q) Isn't this game a little quiet?</p>
			<p>A) I didn't add sound effects to this game because I wanted to keep the code as short as possible while using our first classes and learning to use the time to smoothly animate all the game objects. If you want to add sound effects, then all you need to do is add the .wav files to the project, use SFML to load the sounds, and play a sound effect in each of the collision events. We will do this in the next project.</p>
			<p>Q) The game is too easy! How can I make the ball speed up a little?</p>
			<p>A) There are lots of ways you can make the game more challenging. One simple way would be to add a line of code in the <code>Ball</code> class' <code>reboundBatOrTop</code> function that increases the speed. As an example, the following code would increase the speed of the ball by 10% each time the function is called:</p>
			<pre>// Speed up a little bit on each hit
m_Speed = m_Speed * 1.1f;</pre>
			<p>The ball would get quite fast quite quickly. You would then need to devise a way to reset the speed back to <code>300.0f</code> when the player has lost all their lives. You could create a new function in the <code>Ball</code> class, perhaps called <code>resetSpeed</code>, and call it from <code>main</code> when the code detects that the player has lost their last life.</p>
		</div>
	</body></html>