- en: Chapter 6. Quick and Easy Sprite – Victorian Rush Hour
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 快速简单的精灵 - 维多利亚时代高峰期
- en: '*In our fourth example of a game built with Cocos2d-x, I''ll show you a simple
    technique for rapid prototyping. Often in game development, you want to test the
    core ideas of your game as soon as possible, because a game may sound fun in your
    head but in reality it just doesn''t work. Rapid prototyping techniques allow
    you to test your game as early as possible in the development process as well
    as build up on the good ideas.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在我们的第四个使用 Cocos2d-x 构建的游戏示例中，我将向你展示一个快速原型设计的简单技巧。在游戏开发中，你通常希望尽快测试你游戏的核心想法，因为一个游戏在你脑海中可能听起来很有趣，但现实中可能根本行不通。快速原型设计技术允许你在开发过程的早期就测试你的游戏，并在此基础上构建好的想法。*'
- en: 'Here''s what you''ll learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是你将学习的内容：
- en: How to quickly create placeholder sprites
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何快速创建占位符精灵
- en: How to code collisions for a platform game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为平台游戏编写碰撞代码
- en: How to create varied terrain for a side-scroller
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为横版滚动游戏创建多样化的地形
- en: The game – Victorian Rush Hour
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏 - 维多利亚时代高峰期
- en: In this game (Victorian Rush Hour), you control a cyclist in Victorian London
    trying to avoid rush-hour traffic on his way home. For reasons no one can explain,
    he's riding his bike on top of the buildings. As the player, it is your job to
    ensure he makes it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏（维多利亚时代高峰期）中，你控制一位在维多利亚时代的伦敦骑自行车的骑车人，试图避免他在回家的路上遇到高峰期交通。由于没有人能解释的原因，他骑自行车在建筑物的顶部。作为玩家，你的任务是确保他安全到达。
- en: 'The controls are very simple: you tap the screen to make the cyclist jump and
    while he''s in the air, if you tap the screen again, the cyclist will open his
    trusty umbrella, either slowing his descent or adding a boost to his jump.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 控制方式非常简单：你轻触屏幕使骑车人跳跃，当他处于空中时，如果你再次轻触屏幕，骑车人将打开他可靠的雨伞，这要么会减缓他的下降，要么会为他的跳跃增加动力。
- en: 'This game is of a type commonly known as a dash game or endless runner, a genre
    that has become increasingly popular online and on various app stores. Usually
    in these types of games you, the developer, have two choices: either make the
    terrain the main obstacle and challenge in the game, or make what''s added to
    the terrain the main challenge (enemies, pick-ups, obstacles, and so on). With
    this game, I decided on the first option.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏是一种常见的类型，通常被称为冲刺游戏或无尽跑酷游戏，这种类型在网上和各种应用商店中越来越受欢迎。通常在这些类型的游戏中，作为开发者的你有两个选择：要么让地形成为游戏中的主要障碍和挑战，要么让添加到地形中的元素成为主要挑战（敌人、拾取物、障碍物等）。对于这款游戏，我选择了第一个选项。
- en: So our challenge is to create a game where the terrain is the enemy but not
    an unbeatable one.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们的挑战是创建一个游戏，其中地形是敌人，但不是不可战胜的。
- en: The game settings
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏设置
- en: The game is a universal application, designed for the iPad retina display but
    with support for other display sizes. It is played in the landscape mode and it
    does not support multitouch.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏是一个通用应用程序，专为 iPad Retina 显示屏设计，但支持其他显示尺寸。它以横屏模式进行游戏，不支持多点触控。
- en: Rapid prototyping with Cocos2d-x
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cocos2d-x 进行快速原型设计
- en: The idea behind this is to create sprites as placeholders for your game elements
    as quickly as possible, so you can test your game ideas and refine them. Every
    game in this book was initially developed in the way I'm about to show you, with
    simple rectangles in place of textured sprites.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的理念是尽可能快速地创建精灵作为游戏元素的占位符，这样你就可以测试你的游戏想法并对其进行改进。本书中的每个游戏最初都是按照我即将展示的方式开发的，用简单的矩形代替纹理精灵。
- en: 'The technique shown here allows you to create rectangles of any size and of
    any color to be used in your game logic:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的技术允许你创建任何大小和颜色的矩形，用于你的游戏逻辑：
- en: '![Rapid prototyping with Cocos2d-x](img/00020.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Cocos2d-x 进行快速原型设计](img/00020.jpeg)'
- en: Time for action – creating placeholder sprites
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建占位符精灵
- en: 'So let me show you how to do that:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我来展示如何做到这一点：
- en: Go ahead and download the `4198_06_START_PROJECT.zip` file if you haven't done
    so already.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有下载，请继续下载 `4198_06_START_PROJECT.zip` 文件。
- en: When you open the project in Xcode, you will see all the classes we'll need
    for the game, and we'll go over them in a second. But for now, just go to `GameLayer.cpp`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在 Xcode 中打开项目时，你会看到我们为游戏所需的所有类，我们将在下一秒中讲解它们。但现在，请先转到 `GameLayer.cpp`。
- en: 'Scroll down to the last `createGameScreen` method and add the following lines:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到最后一个 `createGameScreen` 方法，并添加以下行：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And that's it. The sprite is created with a texture called `blank.png`. This
    is a 1 x 1 pixel white square you will find in the `Resources` folder. Then we
    set the size of the sprite's texture rectangle to 100 x 100 pixels (`setTextureRect`),
    and fill it with a white color (`setColor`). By resizing the texture rectangle,
    we in effect resize the sprite. If you run the game now, you should see a white
    square smack in the middle of the screen.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样。精灵是用一个名为 `blank.png` 的纹理创建的。这是一个位于 `Resources` 文件夹中的 1 x 1 像素的白色方块。然后我们将精灵纹理矩形的大小设置为
    100 x 100 像素（`setTextureRect`），并用白色填充它（`setColor`）。通过调整纹理矩形的大小，我们实际上调整了精灵的大小。如果你现在运行游戏，你应该会在屏幕中央看到一个白色方块。
- en: 'Now delete the previous lines and replace them with these:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在删除之前的行，并用这些替换：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This creates `_gameBatchNode` that uses as its source texture the same `blank.png`
    file. Now we are ready to place as many rectangles inside `_gameBatchNode` as
    we'd like, and set a different color for each one of them if we want. We can,
    in other words, build an entire test game with one tiny image. Which is what we'll
    proceed to do now.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这创建了 `_gameBatchNode`，它使用相同的 `blank.png` 文件作为其源纹理。现在我们准备好在 `_gameBatchNode`
    内放置尽可能多的矩形，并且如果需要，为每个矩形设置不同的颜色。换句话说，我们可以用一张微小的图片构建整个测试游戏。这正是我们现在要做的。
- en: 'So, to finish up here, add these last lines:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，为了完成这里的任务，添加这些最后一行：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*What just happened?*'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'We just created a placeholder sprite we can use to test gameplay ideas quickly
    and painlessly. And we created our game''s two main objects: the `Player` and
    `Terrain` object. These are empty shells at the moment, but we''ll start working
    on them next. But first let''s go over the different game elements.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个占位符精灵，我们可以用它快速且轻松地测试游戏玩法想法。我们还创建了游戏的两个主要对象：`Player` 和 `Terrain` 对象。目前它们是空壳，但我们将从它们开始工作。但首先，让我们回顾一下不同的游戏元素。
- en: The Player object
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家对象
- en: This represents our cyclist. It will jump, float, and collide with the `_terrain`
    object. Its `x` speed is passed to the `_terrain` object causing the `Terrain`
    object to move, side scrolling to the left of the screen.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表我们的自行车手。它会跳跃、漂浮，并与 `_terrain` 对象发生碰撞。它的 `x` 速度传递给 `_terrain` 对象，导致 `Terrain`
    对象移动，向屏幕左侧滚动。
- en: The `Player` object derives, once again, from a `GameSprite` class. This one
    has getters and setters for next position, vector of movement, and the sprite's
    width and height.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 对象再次从 `GameSprite` 类派生。这个类有获取器和设置器来获取下一个位置、移动向量以及精灵的宽度和高度。'
- en: The `Player` interface has inline helper methods to retrieve information about
    its rectangle boundaries related to its current position (left, right, top, bottom),
    and its next position (`next_left`, `next_right`, `next_top`, `next_bottom`).
    These will be used in collision detection with the `_terrain` object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player` 接口有内联辅助方法来检索与其当前位置相关的矩形边界信息（左、右、上、下），以及其下一个位置（`next_left`、`next_right`、`next_top`、`next_bottom`）。这些将在与
    `_terrain` 对象的碰撞检测中使用。'
- en: The Block object
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块对象
- en: These objects form the individual pieces of the `_terrain` object. They can
    take the shape of a building, or an empty gap between buildings. We'll have four
    different types of buildings, which later will represent four different types
    of textures when we finally bring in our sprite sheets. These blocks can have
    different widths and heights.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象构成了 `_terrain` 对象的各个独立部分。它们可以呈现建筑物的形状，或者建筑物之间的空隙。我们将有四种不同的建筑物类型，这些类型最终将代表我们引入精灵图集时的四种不同类型的纹理。这些块可以有不同的大小和高度。
- en: '`Block` also derives from `GameSprite` and it also has inline helper methods
    to retrieve information about its boundaries, but only in relation to its current
    position, since `Block` doesn''t technically move.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Block` 也从 `GameSprite` 派生，它也有内联辅助方法来检索其边界信息，但仅与其当前位置相关，因为 `Block` 并非技术上会移动。'
- en: The terrain object
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地形对象
- en: This object contains the individual `Block` objects that form the landscape.
    It contains just enough `Block` objects to fill the screen, and as the `_terrain`
    object scrolls to the left, the `Block` objects that leave the screen are moved
    to the far right side of the `_terrain` and reused as new blocks, ensuring continuous
    scrolling.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象包含构成景观的各个 `Block` 对象。它包含足够的 `Block` 对象来填满屏幕，并且当 `_terrain` 对象向左滚动时，离开屏幕的
    `Block` 对象会被移动到 `_terrain` 的右侧边缘，并作为新的块重新使用，确保连续滚动。
- en: The `_terrain` object is also responsible for collision checks with the `_player`
    object, since it has quick access to all information we'll need for collision
    detection; namely the list of blocks currently on the screen, their size, type,
    and position. Our main loop then will call on the `Terrain` object to test for
    collision with the `player` object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`_terrain`对象也负责与`_player`对象的碰撞检测，因为它可以快速访问我们进行碰撞检测所需的所有信息；即当前屏幕上所有块的信息，它们的大小、类型和位置。然后我们的主循环将调用`Terrain`对象来测试与`player`对象的碰撞。'
- en: Let's work on these main objects, starting with the `Player` object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们着手处理这些主要对象，从`Player`对象开始。
- en: Time for action – coding the player
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候动手编码玩家了
- en: Open up the `Player.cpp` class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Player.cpp`类。
- en: 'The `_player` object is created through a static method that uses our `blank.png`
    file to texture the sprite. That method also makes a call to `initPlayer`, and
    this is what you should type for that method:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_player`对象是通过一个静态方法创建的，该方法使用我们的`blank.png`文件来纹理精灵。该方法还调用`initPlayer`，这就是你应该为该方法输入的内容：'
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `_player` object will have its registration point at the top of the sprite.
    The reason behind this top center anchor point has much more to do with the way
    the `_player` object will be animated when floating, than with any collision logic
    requirements.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`_player`对象的注册点将在精灵的顶部。这个顶部中心锚点的原因更多是与`_player`对象在漂浮时将被如何动画处理有关，而不是与任何碰撞逻辑要求有关。'
- en: 'Next comes `setFloating`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`setFloating`：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `_hasFloated` property will ensure the player can only open the umbrella
    once while in the air. And when we set `_floating` to `true`, we give the `_player.y`
    vector a boost.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`_hasFloated`属性将确保玩家在空中只能打开一次雨伞。当我们把`_floating`设置为`true`时，我们给`_player.y`向量一个加速。'
- en: 'We begin the update method of `_player` with:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`_player`的更新方法开始：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The game will increase `_maxSpeed` of the `_player` object as time goes on,
    making the game more difficult. These first lines make the change from the `_players`
    current `_speed` up to `_maxSpeed` a bit smoother and not an immediate change.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随着时间的推移，游戏将增加`_player`对象的`_maxSpeed`，使游戏难度增加。这些第一行代码使得从`_players`当前的`_speed`到`_maxSpeed`的转换更加平滑，而不是立即改变。
- en: Note
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Victorian Rush Hour has no levels, so it's important to figure out a way to
    make it incrementally harder to play, and yet not impossible. Finding that sweet
    spot in your logic may take some time and it's one more reason to test game ideas
    as soon as possible. Here we make the game harder by increasing the player's speed
    and the size of the gaps between buildings. These are updated inside a countdown
    in the main loop.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 维多利亚时代高峰时段没有关卡，因此找出一种方法使其游戏难度逐渐增加，但又不是不可能的，这一点非常重要。在逻辑中找到这个最佳点可能需要一些时间，这也是尽快测试游戏想法的另一个原因。在这里，我们通过增加玩家的速度和建筑物之间间隙的大小来使游戏更难。这些更新都在主循环的倒计时中完成。
- en: 'Next, we update the `_player` object based on its `_state` of movement:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们根据`_player`对象的`_state`移动状态更新`_player`对象：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have different values for gravity and friction depending on move state.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们根据移动状态的不同，对重力和摩擦力有不同的取值。
- en: We also have a time limit for how long the `_player` object can be floating,
    and we reset that timer when the `_player` object is not floating. If the `_player`
    object is dying (collided with a wall), we move the `_player` object backward
    and downward until it leaves the screen.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还设定了`_player`对象可以漂浮的时间限制，并且当`_player`对象不再漂浮时重置那个计时器。如果`_player`对象正在死亡（与墙壁碰撞），我们将`_player`对象向后和向下移动，直到它离开屏幕。
- en: 'We finish with:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们以以下内容结束：
- en: '[PRE7]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the player presses the screen for a jump, we shouldn't make the sprite
    jump immediately. Changes in state should always happen smoothly. So we have a
    `boolean` property in `_player` called `_jumping`. It is set to `true` when the
    player presses the screen and we slowly add the jump force to `_vector.y`. So
    the longer the player presses the screen, the higher the jump will be and a quick
    tap will result in a shorter jump. This is a nice feature to add to any platform
    game.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当玩家按下屏幕进行跳跃时，我们不应该让精灵立即跳跃。状态的变化应该总是平滑发生的。因此，我们在`_player`中有一个名为`_jumping`的布尔属性。当玩家按下屏幕时，它被设置为`true`，我们缓慢地给`_vector.y`添加跳跃力。所以玩家按屏幕的时间越长，跳跃就越高，快速轻触会导致跳跃较短。这是任何平台游戏都值得添加的一个好功能。
- en: We next limit the `y` speed with a terminal velocity, update the next position
    of the `_player` object, and update the floating timer if `_player` is floating.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们接下来用终端速度限制`y`速度，更新`_player`对象的下一个位置，如果`_player`正在漂浮，则更新漂浮计时器。
- en: '*What just happened?*'
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The `_player` object is updated through a series of states. Touching the screen
    will make changes to this `_state` property, as will the results of collision
    checking with `_terrain`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`_player` 对象通过一系列状态进行更新。触摸屏幕将改变这个 `_state` 属性，以及与 `_terrain` 进行碰撞检查的结果。'
- en: Now let's work on the `Block` class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来编写 `Block` 类。
- en: Time for action – coding the Block object
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 编写 Block 对象的代码
- en: 'Once again a static method, `create`, will use `blank.png` to create our `Block`
    sprite. Only this time, we don''t actually change the texture rectangle for `Block`
    inside `create`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用一个静态方法 `create`，将使用 `blank.png` 创建我们的 `Block` 精灵。但这一次，我们实际上没有在 `create`
    中更改 `Block` 的纹理矩形：
- en: 'The `Block` object is properly textured inside the `setupBlock` method:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setupBlock` 方法中，`Block` 对象被正确地纹理化：
- en: '[PRE8]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A `Block` object's appearance will be based on its type, width, and height.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Block` 对象的外观将基于其类型、宽度和高度。'
- en: The `Block` sprite's registration point is set to top left. And we finally change
    the `Block` object's texture rectangle size here.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Block` 精灵的注册点设置为左上角。我们最终在这里更改 `Block` 对象的纹理矩形大小。'
- en: 'Then we set the `Block` object''s color based on type:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们根据类型设置 `Block` 对象的颜色：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`kBlockGap` means there is no building, just a gap the `_player` object must
    jump. We make the block invisible in that case and return from the function. So
    again, gaps are actually types of blocks in our logic.'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`kBlockGap` 表示没有建筑，只有 `_player` 对象必须跳过的空隙。在这种情况下，我们使方块不可见并从函数中返回。所以，再次强调，空隙在我们的逻辑中实际上是块的一种类型。'
- en: In this test version, the different types of buildings are represented with
    different colors. Later we'll use different textures.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试版本中，不同的建筑类型用不同的颜色表示。稍后我们将使用不同的纹理。
- en: '*What just happened?*'
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: The `Block` object is very simple. We just need its values for `_width` and
    `_height` whether it's a gap or not, so we can properly run collision detection
    with these objects.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Block` 对象非常简单。我们只需要它的 `_width` 和 `_height` 值，无论它是空隙还是不是，这样我们就可以正确地运行与这些对象的碰撞检测。'
- en: Planning the Terrain class
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规划 Terrain 类
- en: Before we jump to coding the `Terrain` class, we need to discuss a few things
    regarding randomness.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳转到编写 `Terrain` 类之前，我们需要讨论一些关于随机性的问题。
- en: It is a very common mistake among game developers to confuse randomness with
    variableness, and very important to know when you need what.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发者中，混淆随机性和可变性是一个非常常见的错误，而且知道何时需要什么非常重要。
- en: A random number can be anything. 1234 is a random series of numbers. And the
    next time you want a random series of numbers and you once again get 1234 this
    will be just as random as the previous one. But not varied.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数可以是任何东西。1234 是一组随机数字。下次你想得到一组随机数字，并且再次得到 1234，这将与之前一样随机。但不是变化的。
- en: If you decide to build a random terrain, you will probably be disappointed in
    the result as it won't necessarily be varied. Also, remember that we need to make
    the terrain the key challenge of the game; but this means it can be neither too
    easy nor too difficult. True randomness would not allow us enough control here,
    or worse, we would end up with a long list of conditionals to make sure we have
    the correct combination of blocks, and that would result in at least one recurrent
    function inside our main loop, which is not a good idea.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定构建随机地形，你可能会对结果感到失望，因为它不一定会有变化。此外，请记住，我们需要使地形成为游戏的关键挑战；但这意味着它既不能太简单也不能太难。真正的随机性不会给我们足够的控制，或者更糟糕的是，我们最终会得到一个长的条件列表，以确保我们有正确的块组合，这会在主循环中至少导致一个循环函数，这不是一个好主意。
- en: We need instead to control the results and their variableness by applying our
    own patterns to them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过应用自己的模式来控制结果及其可变性。
- en: So we'll apply this logic of patterns to our `_terrain` object, forming a kind
    of pool of proper random choices. We'll use four arrays to store possible results
    in our decision making, and we'll shuffle three of these arrays during the game
    to add the "randomness" feel to our terrain.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将把这个模式的逻辑应用到我们的 `_terrain` 对象上，形成一个合适的随机选择池。我们将使用四个数组来存储决策中的可能结果，并在游戏中对其中三个数组进行洗牌，以增加地形中的“随机性”感觉。
- en: 'These arrays are:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数组是：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This holds the information of how many buildings (`Blocks`) we have in a row,
    between gaps.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了我们在空隙之间一行中拥有的建筑（`Blocks`）的数量信息。
- en: You can easily change the `patterns` value just by adding new values or by increasing
    or reducing the number of times one value appears. So here we're making a terrain
    with far more groupings of two buildings between gaps, than groups of three or
    one.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加新值或增加或减少一个值出现的次数来轻松更改`patterns`值。所以在这里，我们正在创建一个在间隙之间有更多两座建筑组合的地形，而不是三座或一座的组合。
- en: 'Next, consider the following lines:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑以下行：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding lines specify the widths and heights of each new building. These
    will be multiplied with the tile size determined for our game to get the final
    width and height values as you saw in `Block:setupBlock`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行指定了每个新建筑的宽度和高度。这些将乘以我们为游戏确定的瓷砖大小，以获得你在`Block:setupBlock`中看到的最终宽度和高度值。
- en: We'll use a `0` value for height to mean there is no change in height from the
    previous building. A similar logic could be easily applied to widths.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`0`值表示高度，表示与上一个建筑之间没有高度变化。类似的逻辑可以很容易地应用于宽度。
- en: 'And finally:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These are building types and this array will not be shuffled unlike the three
    previous ones, so this is the `patterns` array of `types` we'll use throughout
    the game and it will loop continuously. You can make it as long as you wish.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是建筑类型，这个数组将不会像前三个那样洗牌，所以这是我们将用于整个游戏的`types`的`patterns`数组，它将连续循环。你可以让它尽可能长。
- en: Building the terrain object
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建地形对象
- en: So every time we need to create a new block, we'll set it up based on the information
    contained in these arrays.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所以每次我们需要创建一个新的方块时，我们都会根据这些数组中包含的信息来设置它。
- en: 'This gives us far more control over the terrain, so that we don''t create impossible
    combinations of obstacles for the player: a common mistake in randomly-built terrain
    for dash games.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们更多的控制权，这样我们就不可能为玩家创建不可能的障碍物组合：这是随机构建的地形在冲刺游戏中常见的错误。
- en: But at the same time, we can easily expand this logic to fit every possible
    need. For instance, we could apply level logic to our game by creating multiple
    versions of these arrays, so as the game gets harder, we begin sampling data from
    arrays that contain particularly hard combinations of values.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但同时，我们可以轻松地扩展这个逻辑以适应每一个可能的需求。例如，我们可以通过创建这些数组的多个版本来将等级逻辑应用于我们的游戏，这样随着游戏的难度增加，我们就开始从包含特别困难值组合的数组中采样数据。
- en: And we can still use a conditional loop to refine results even further and I'll
    give you at least one example of this.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用条件循环来进一步细化结果，我会至少给你一个这样的例子。
- en: The values you saw in the `patterns` arrays will be stored inside the lists
    called `_blockPattern`, `_blockWidths`, `_blockHeights`, and `_blockTypes`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`patterns`数组中看到的值将被存储在名为`_blockPattern`、`_blockWidths`、`_blockHeights`和`_blockTypes`的列表中。
- en: The `Terrain` class then takes care of building the game's terrain in three
    stages. First we initialize the `_terrain` object, creating among other things
    a pool for `Block` objects. Then we add the first blocks to the `_terrain` object
    until a minimum width is reached to ensure the whole screen is populated with
    `Blocks`. And finally we distribute the various block objects.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`Terrain`类负责在三个阶段构建游戏的地形。首先我们初始化`_terrain`对象，创建一个`Block`对象的池子。然后我们向`_terrain`对象添加第一个方块，直到达到最小宽度，以确保整个屏幕都填充了`Blocks`。最后我们分配各种方块对象。
- en: Time for action – initializing our Terrain class
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——初始化我们的Terrain类
- en: 'We''ll go over these steps next:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一步中介绍这些步骤：
- en: 'The first important method to implement is `initTerrain`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先需要实现的重要方法是`initTerrain`：
- en: '[PRE13]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have a timer to increase the width of gaps (we begin with gaps two tiles
    long).
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们有一个计时器来增加间隙的宽度（我们开始时使用两个瓷砖长度的间隙）。
- en: We create a pool for blocks so we don't instantiate any during the game. And
    `20` blocks is more than enough for what we need.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建一个方块池，这样在游戏中就不会实例化任何方块。`20`个方块对于我们需要的来说已经足够多了。
- en: The blocks we are currently using in the terrain will be stored inside a `_blocks`
    vector.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们目前在地形中使用的方块将被存储在`_blocks`向量中。
- en: We determine that the minimum width the `_terrain` object must have is `1.5`
    times the screen width. We'll keep adding blocks until the `_terrain` object reaches
    this minimum width. We end by shuffling the `patterns` arrays and adding the blocks.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们确定`_terrain`对象必须具有的最小宽度是屏幕宽度的`1.5`倍。我们将继续添加方块，直到`_terrain`对象达到这个最小宽度。最后，我们洗牌`patterns`数组并添加方块。
- en: 'The `addBlocks` method should look like this:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addBlocks`方法应该看起来像这样：'
- en: '[PRE14]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The logic inside the `while` loop will continue to add blocks until `currentWidth`
    of the `_terrain` object reaches `_minTerrainWidth`. Every new block we retrieve
    from the pool in order to reach `_minTerrainWidth` gets added to the `_blocks`
    vector.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`while` 循环内部的逻辑将继续添加方块，直到 `_terrain` 对象的 `currentWidth` 达到 `_minTerrainWidth`。为了达到
    `_minTerrainWidth`，我们从池中检索的每个新方块都会被添加到 `_blocks` 向量中。'
- en: 'Blocks are distributed based on their widths:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方块根据它们的宽度进行分布：
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*What just happened?*'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: '`Terrain` is a container of `Blocks`, and we just added the logic that will
    add a new `block` object to this container. Inside `addBlocks`, we call an `initBlock`
    method, which will use the information from our `patterns` arrays to initialize
    each block used in the terrain. It is this method we''ll implement next.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Terrain` 是 `Blocks` 的容器，我们刚刚添加了将新 `block` 对象添加到这个容器的逻辑。在 `addBlocks` 中，我们调用
    `initBlock` 方法，该方法将使用我们 `patterns` 数组中的信息来初始化在地形中使用的每个方块。这就是我们将要实现的方法。'
- en: Time for action – initializing our Blocks object
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 初始化我们的 Blocks 对象
- en: 'Finally, we will discuss the method that initializes the blocks based on our
    `patterns` array:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将讨论基于我们的 `patterns` 数组初始化方块的方法：
- en: 'So inside the `Terrain` class, we start the `initBlock` method as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在 `Terrain` 类中，我们以如下方式开始 `initBlock` 方法：
- en: '[PRE16]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Begin by determining the type of building we are initializing. See how we loop
    through the `_blockTypes` array using the index stored in `_currentTypeIndex`.
    We'll use a similar logic for the other `patterns` arrays.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先确定我们正在初始化的建筑类型。看看我们是如何使用存储在 `_currentTypeIndex` 中的索引遍历 `_blockTypes` 数组的。我们会对其他
    `patterns` 数组使用类似的逻辑。
- en: 'Then, let''s start building our blocks:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们开始构建我们的方块：
- en: '[PRE17]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The player must tap the screen to begin the game (`_startTerrain`). Until then,
    we show buildings with the same height (two tiles) and random width:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 玩家必须点击屏幕开始游戏（`_startTerrain`）。在此之前，我们显示具有相同高度（两个地砖）和随机宽度的建筑：
- en: '![Time for action – initializing our Blocks object](img/00021.jpeg)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 初始化我们的 Blocks 对象](img/00021.jpeg)'
- en: We will store `_lastBlockHeight` and `_lastBlockWidth` because the more information
    we have about the terrain the better we can apply our own conditions to it, as
    you will see in a moment.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将存储 `_lastBlockHeight` 和 `_lastBlockWidth`，因为关于地形的信息越多，我们就能更好地应用自己的条件，正如你一会儿会看到的。
- en: 'Consider that we are set to `_startTerrain`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到我们设置为 `_startTerrain`：
- en: '[PRE18]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the following screenshot, you can see the different widths used for our
    blocks:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，你可以看到我们方块使用的不同宽度：
- en: '![Time for action – initializing our Blocks object](img/00022.jpeg)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 初始化我们的 Blocks 对象](img/00022.jpeg)'
- en: The information inside `_blockPattern` determines how many buildings we show
    in a row, and once a series is completed, we show a gap by setting the `boolean`
    value of `_showGap` to `true`. A gap's width is based on the current value of
    `_gapSize`, which may increase as the game gets harder and it can't be less than
    two times the tile width.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`_blockPattern` 中的信息决定了我们一行显示多少座建筑，一旦一个系列完成，我们通过将 `_showGap` 的布尔值设置为 `true`
    来显示一个间隙。间隙的宽度基于 `_gapSize` 的当前值，随着游戏难度增加，它可能会增加，但不能小于两倍的地砖宽度。'
- en: 'If we are not creating a gap this time, we determine the width and height of
    the new block based on the current indexed values of `_blockWidths` and `_blockHeights`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这次我们不创建间隙，我们将根据 `_blockWidths` 和 `_blockHeights` 的当前索引值确定新方块的宽度和高度：
- en: '[PRE19]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice how we reshuffle the arrays once we are done iterating through them (`random_shuffle`).
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们在遍历完数组后重新洗牌了数组（`random_shuffle`）。
- en: We use `_lastBlockHeight` to apply an extra condition to our terrain. We don't
    want the next block to be too tall in relation to the previous building, at least
    not in the beginning of the game, which we can determine by checking the value
    for `_gapSize`, which is only increased when the game gets harder.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `_lastBlockHeight` 来对我们的地形应用一个额外的条件。我们不希望下一个方块相对于前一个建筑过高，至少在游戏初期不是这样，我们可以通过检查
    `_gapSize` 的值来确定这一点，该值只有在游戏难度增加时才会增加。
- en: And if the value from `_blockHeights` is `0`, we don't change the height of
    the new building and use instead the same value from `_lastBlockHeight`.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `_blockHeights` 的值是 `0`，我们不会改变新建筑的层数，而是使用 `_lastBlockHeight` 的相同值。
- en: 'We finish by updating the count in the current series of buildings to determine
    whether we should show a gap next, or not:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过更新当前建筑系列的计数来确定是否应该显示下一个间隙，或者不显示：
- en: '[PRE20]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*What just happened?*'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We finally got to use our `patterns` arrays and build the blocks inside the
    terrain. The possibilities are endless here in how much control we can have in
    building our blocks. But the key idea here is to make sure the game does not become
    ridiculously hard, and I advise you to play some more with the values to achieve
    even better results (don't take my choices for granted).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终可以使用我们的 `patterns` 数组并在地形中构建方块。在这里，我们可以无限地控制构建方块的方式。但关键思想是确保游戏不会变得荒谬地困难，我建议你多尝试一些值以获得更好的结果（不要理所当然地接受我的选择）。
- en: Before we tackle collision, let's add the logic to move and reset the terrain.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理碰撞之前，让我们添加移动和重置地形的逻辑。
- en: Time for action – moving and resetting
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 移动和重置
- en: We move the terrain inside the `move` method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `move` 方法中移动地形。
- en: 'The `move` method receives as a parameter the amount of movement in the `x`
    axis:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`move` 方法接收一个参数，即 `x` 轴上的移动量：'
- en: '[PRE21]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The value for `xMove` comes from the `_player` speed.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`xMove` 的值来自 `_player` 的速度。'
- en: We start by updating the timer that will make the gaps wider. Then we move the
    terrain to the left. If after moving the terrain, a block leaves the screen, we
    move the block back to the end of the `_blocks` vector and reinitialize it as
    a new block through `initBlock`.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先更新将使缝隙变宽的计时器。然后我们将地形向左移动。如果移动地形后，一个方块离开了屏幕，我们将方块移回到 `_blocks` 向量的末尾，并通过
    `initBlock` 重新初始化它作为一个新的方块。
- en: We make a call to `addBlocks` just in case the reinitialized block made the
    total width of the terrain less than the minimum width required.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们调用 `addBlocks`，以防重新初始化的方块使得地形总宽度小于所需的最小宽度。
- en: 'Next, our `reset` method:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们的 `reset` 方法：
- en: '[PRE22]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `reset` method is called whenever we restart the game. We move `_terrain`
    back to its starting point, and we reinitialize all the current `Block` objects
    currently inside the `_terrain` object. This is done because we are back to `_startTerrain
    = false`, which means all blocks should have the same height and a random width.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次我们重新启动游戏时都会调用 `reset` 方法。我们将 `_terrain` 移回到其起始点，并重新初始化 `_terrain` 对象中当前的所有
    `Block` 对象。这是因为在 `_startTerrain = false`，这意味着所有方块应该具有相同的高度和随机的宽度。
- en: If at the end of the reset we need more blocks to reach `_minTerrainWidth`,
    we add them accordingly.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在重置的最后需要更多的方块以达到 `_minTerrainWidth`，我们将相应地添加它们。
- en: '*What just happened?*'
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We can now move the `_terrain` object and all the blocks it contains, and we
    can restart the process all over again if we need to.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以移动 `_terrain` 对象及其包含的所有方块，并且如果我们需要，我们可以重新开始整个过程。
- en: Once again, using the container behavior of nodes simplified our job tremendously.
    When you scroll the terrain, you scroll all the `Block` objects it contains.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，使用节点的容器行为极大地简化了我们的工作。当你滚动地形时，你也会滚动它包含的所有 `Block` 对象。
- en: So we are finally ready to run collision logic.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们最终准备好运行碰撞逻辑。
- en: Platform collision logic
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台碰撞逻辑
- en: We have in place all the information we need to check for collision through
    the inline methods found in `Player` and `Block`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了检查碰撞所需的所有信息，这些信息可以通过 `Player` 和 `Block` 中找到的内置方法进行检查。
- en: 'In this game, we''ll need to check collision between the `_player` object''s
    bottom side and the `block` object''s top side, and between the `_player` object''s
    right side and the `Block` class'' left side. And we''ll do that by checking the
    `_player` object''s current position and its next position. We are looking for
    these conditions:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们需要检查 `_player` 对象的底部与 `block` 对象的顶部之间的碰撞，以及 `_player` 对象的右侧与 `Block`
    类的左侧之间的碰撞。我们将通过检查 `_player` 对象的当前位置和下一个位置来完成这一点。我们正在寻找以下条件：
- en: '![Platform collision logic](img/00023.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![平台碰撞逻辑](img/00023.jpeg)'
- en: The diagram represents the conditions for bottom side collision, but the same
    idea applies to right side collision.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图表表示底部碰撞的条件，但同样的想法也适用于右侧碰撞。
- en: In the current position, the `_player` object must be above the top of the block
    or touching it. In the next position, the `_player` object must be either touching
    the top of the block or already overlapping it (or has moved past it altogether).
    This would mean a collision has occurred.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前位置，`_player` 对象必须位于方块顶部之上或接触它。在下一个位置，`_player` 对象必须接触方块顶部或已经重叠它（或者完全移动过它）。这意味着发生了碰撞。
- en: Time for action – adding collision detection
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 添加碰撞检测
- en: 'Let''s see how that translates to code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这如何转化为代码：
- en: 'Still in `Terrain.cpp`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `Terrain.cpp` 中：
- en: '[PRE23]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First we state that the `_player` object is currently falling with `inAir =
    true;` we'll let the collision check determine if this will remain true or not.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们声明`_player`对象当前正在下落，`inAir = true;`我们将让碰撞检查来确定这是否会保持为真。
- en: We don't check the collision if `_player` is dying and we skip collision checks
    with any gap blocks.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`_player`正在死亡，我们不检查碰撞，并且跳过与任何缝隙块的碰撞检查。
- en: We check collision on the `y` axis, which here means the bottom of the `_player`
    and top of the block. We first need to determine if the `_player` object is within
    range of the block we want to check against collision. This means the center of
    the `_player` object must be between the left and right side of the block; otherwise,
    the block is too far from the `_player` object and may be ignored.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在`y`轴上检查碰撞，在这里这意味着`_player`的底部和块的顶部。我们首先需要确定`_player`对象是否在我们想要检查碰撞的块的范围之内。这意味着`_player`对象的重心必须在块的左右两侧之间；否则，块离`_player`对象太远，可能会被忽略。
- en: Then we run a basic check to see if there is a collision between the `_player`
    object's current position and next position, using the conditions I explained
    earlier. If so, we fix the `_player` object's position and change its `y` vector
    speed to `0` and we determine that `inAir = false` after all, the `_player` object
    has landed.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们运行一个基本的检查，看看`_player`对象当前的位置和下一个位置之间是否有碰撞，使用我之前解释的条件。如果有，我们固定`_player`对象的位置，将其`y`向量速度更改为`0`，并且最终确定`inAir
    = false`，因为`_player`对象已经着陆。
- en: 'Next we check collision on the `x` axis, meaning the right side of the `_player`
    object with the left side of the blocks:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查`x`轴上的碰撞，这意味着`_player`对象的右侧与块的左侧：
- en: '[PRE24]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Similar steps are used to determine if we have a viable block or not.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相似的步骤用于确定我们是否有可行的块。
- en: If we do have a side collision, the `_player` state is changed to `kPlayerDying`,
    we reverse its `x` speed so the `_player` state will move to the left and off
    the screen, and we return from this method.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们确实有侧面碰撞，将`_player`状态更改为`kPlayerDying`，我们反转其`x`速度，这样`_player`状态就会向左移动并离开屏幕，然后我们从该方法返回。
- en: 'We end by updating the `_player` object''s state based on our collision results:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过更新`_player`对象的状态来结束，基于我们的碰撞结果：
- en: '[PRE25]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*What just happened?*'
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么事？*'
- en: We just added the collision logic to our platform game. As we did in our first
    game, Air Hockey, we test the player's current position for collision as well
    as its next position to determine if a collision occurred between the current
    iteration and the next one. The test simply looks for overlaps between the player's
    and block's boundaries.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将碰撞逻辑添加到我们的平台游戏中。就像我们在我们的第一个游戏，冰球一样，我们测试玩家的当前位置和下一个位置以确定当前迭代和下一个迭代之间是否发生了碰撞。测试只是寻找玩家和块边界之间的重叠。
- en: Adding the controls
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加控制
- en: It is fairly common in a dash game such as this to have very simple controls.
    Often the player must only press the screen for jumping. But we spiced things
    up a bit, adding a floating state.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在像这样的冲刺游戏中，非常常见的是有非常简单的控制。通常，玩家只需按下屏幕进行跳跃。但我们增加了一些趣味，添加了一个浮动状态。
- en: 'And remember we want smooth transitions between states, so pay attention to
    how jumping is implemented: not by immediately applying a force to the player''s
    vector but by simply changing a `boolean` property and letting the `_player` object''s
    update method handle the change smoothly.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 并且记住我们想要在状态之间有平滑的过渡，所以注意跳跃是如何实现的：不是通过立即对玩家的向量施加力，而是简单地改变一个`boolean`属性，并让`_player`对象的更新方法平滑地处理变化。
- en: We'll handle the touch events next.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个步骤中处理触摸事件。
- en: Time for action – handling touches
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——处理触摸
- en: Let's go back to `GameLayer.cpp` and add our game's final touches (pun intended).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`GameLayer.cpp`并添加我们游戏的最终细节（有意为之）。
- en: 'First we work on our `onTouchBegan` method:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们处理我们的`onTouchBegan`方法：
- en: '[PRE26]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we are not running the game and the `_player` object died, we reset the game
    on touch.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们没有运行游戏，并且`_player`对象死亡，我们在触摸时重置游戏。
- en: 'Next, if the terrain has not started, insert the following:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果地形尚未开始，插入以下内容：
- en: '[PRE27]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Remember that at first the buildings are all the same height and there are no
    gaps. Once the player presses the screen, we begin changing that through `setStartTerrain`.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，一开始建筑都是相同的高度，没有缝隙。一旦玩家按下屏幕，我们就通过`setStartTerrain`开始改变这一点。
- en: 'We finish with:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后完成：
- en: '[PRE28]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we are in play, and if the `_player` object is falling, we either open or
    close the umbrella, whichever the case may be, through a call to `setFloating`.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们进入了游戏状态，如果 `_player` 对象正在下落，我们就通过调用 `setFloating` 来打开或关闭雨伞，具体情况而定。
- en: And if the `_player` object is not falling, nor dying, we make it jump with
    `setJumping(true)`.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `_player` 对象既没有下落也没有死亡，我们就通过 `setJumping(true)` 让它跳跃。
- en: 'With touches ended, we just need to stop any jumps:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在触摸结束之后，我们只需要停止任何跳跃：
- en: '[PRE29]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*What just happened?*'
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We added the logic for the game's controls. The `_player` object will change
    to floating if currently falling or to jumping if currently riding on top of a
    building.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了游戏控制的逻辑。如果 `_player` 对象当前正在下落，它将变为漂浮状态；如果当前位于建筑顶部，它将变为跳跃状态。
- en: It's time to add our main game loop.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加我们的主游戏循环了。
- en: Time for action – coding the main loop
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 编写主循环
- en: Finally, it's time for the last part in our logic.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是我们逻辑中的最后一部分。
- en: 'Inside `GameLayer.cpp`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameLayer.cpp` 中：
- en: '[PRE30]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If the `_player` object is off screen, we stop the game.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `_player` 对象离屏幕，我们停止游戏。
- en: 'Now update all the elements, positions and check for collision:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新所有元素、位置并检查碰撞：
- en: '[PRE31]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Move `_gameBatchNode` in relation to the `_player` object:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `_gameBatchNode` 与 `_player` 对象相关移动：
- en: '[PRE32]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Make the game more difficult as time goes on by increasing the `_player` object''s
    maximum speed:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着时间的推移，通过增加 `_player` 对象的最大速度来使游戏难度逐渐提高：
- en: '[PRE33]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*What just happened?*'
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We have our test game in place. From here, we can test our terrain patterns,
    our speeds, and our general gameplay to find spots where things could be improved.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了测试游戏。从这里，我们可以测试我们的地形模式、速度和一般玩法，以找到可以改进的地方。
- en: We should check in particular whether the game gets too hard too fast or whether
    we have combinations of buildings that are just impossible to get past.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该特别检查游戏是否变得过于困难，或者我们是否有组合的建筑根本无法通过。
- en: I find, for instance, that starting with larger groups of buildings, say four
    or five, and then slowly reducing them to two and one between gaps can make the
    game even more fun to play, so the patterns could be changed to reflect that idea.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我发现从更大的建筑群开始，比如四到五个，然后慢慢减少到两个和一，在间隙之间，可以使游戏更具趣味性，因此模式可以改变以反映这一想法。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Every game has a simple idea for its gameplay at its core. But often, this idea
    needs a whole lot of testing and improvement before we can determine whether it's
    fun or not, which is why rapid prototyping is vital.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏在其核心玩法中都包含一个简单的想法。但通常，这个想法需要大量的测试和改进，我们才能确定它是否有趣，这就是为什么快速原型设计至关重要的原因。
- en: We can use Cocos2d-x to quickly test core gameplay ideas and run them in the
    simulator or on a device in a matter of minutes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Cocos2d-x 快速测试核心玩法想法，并在几分钟内在模拟器或设备上运行它们。
- en: Also, the techniques shown here can be used to build interface elements (such
    as the energy bar from our previous game) as well as an entire game! If you don't
    believe me, check out the game *Square Ball* in an App Store near you.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里展示的技术可以用来构建界面元素（例如我们之前游戏中的能量条）以及整个游戏！如果你不相信我，可以去你附近的 App Store 查看游戏 *Square
    Ball*。
- en: Now, with all the logic for gameplay in its proper place, we can proceed to
    making this game look good! We'll do that in the next chapter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着游戏玩法逻辑的适当位置，我们可以继续制作这个游戏看起来更好！我们将在下一章中这样做。
