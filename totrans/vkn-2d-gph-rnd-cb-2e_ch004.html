<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Working with Vulkan Objects</title>
<link href="../styles/stylesheet1.css" rel="stylesheet" type="text/css"/>
<link href="../styles/stylesheet2.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section class="level1 pkt" data-number="4" id="working-with-vulkan-objects">
<h1 data-number="4">3 Working with Vulkan Objects</h1>
<section class="level2" data-number="4.1" id="join-our-book-community-on-discord-2">
<h2 data-number="4.1">Join our book community on Discord</h2>
<p>
<img height="301" src="../media/file40.png" style="width:15rem" width="301"/>
</p>
<p><a href="https://packt.link/unitydev">https://packt.link/unitydev</a></p>
<p>In the previous chapter, we learned how to get our first triangle on the screen using Vulkan. Let’s move forward and learn how to deal with textures and buffers to build a modern Vulkan wrapper. The recipes of this chapter will not be focusing solely on the graphics APIs but on various tips and tricks necessary to improve graphical application development and various 3D graphics algorithms. On the Vulkan side, we will cover the basic stuff to get it up and running. The underlying Vulkan implementation is based on the <em>LightweightVK</em> library (<a href="https://github.com/corporateshark/lightweightvk">https://github.com/corporateshark/lightweightvk</a>).</p>
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Dealing with buffers in Vulkan</li>
<li>Implementing staging buffers</li>
<li>Using texture data in Vulkan</li>
<li>Storing Vulkan objects</li>
<li>Using Vulkan descriptor indexing</li>
</ul>
</section>
<section class="level2" data-number="4.2" id="technical-requirements-1">
<h2 data-number="4.2">Technical requirements</h2>
<p>To run the recipes from this chapter, you have to use a Windows or Linux computer with a video card and drivers supporting Vulkan 1.3. Read the previous chapter, <em>Chapter 2, Getting started with Vulkan</em>, to learn the basics necessary to get you started with Vulkan.</p>
</section>
<section class="level2" data-number="4.3" id="dealing-with-buffers-in-vulkan">
<h2 data-number="4.3">Dealing with buffers in Vulkan</h2>
<p>Buffers in Vulkan are essentially memory regions that hold arbitrary data capable of being accessed by the GPU. To be more precise, Vulkan buffers refer to metadata <code>VkBuffer</code> connected with memory regions <code>VkDeviceMemory</code>. To render a 3D scene using the Vulkan API, we have to transform the scene data into a format suitable for the GPU. In this recipe, we will describe how to create GPU buffers and upload vertex data into them. We will use an open-source asset-loading library, <em>Assimp</em>, (<a href="https://github.com/assimp/assimp">https://github.com/assimp/assimp</a>) to load a 3D model from an <code>.obj</code> file and render it using <em>LightweightVK</em> and Vulkan. Besides that, the recipe covers some basic usage of the <strong>Vulkan Memory Allocator</strong> (<strong>VMA</strong>) library.</p>
<section class="level3" data-number="4.3.1" id="getting-ready-13">
<h3 data-number="4.3.1">Getting ready</h3>
<p>Uploading data into GPU buffers is an operation that is executed, just like any other Vulkan operation, using command buffers. This means we need to have a command queue capable of transfer operations. The creation and usage of command buffers were covered in the previous chapter, in the <em>Using Vulkan command buffers</em> recipe.</p>
</section>
<section class="level3" data-number="4.3.2" id="how-to-do-it...-13">
<h3 data-number="4.3.2">How to do it...</h3>
<p>Let us start from the high-level code in our sampler application, <code>Chapter03/01_Assimp</code>, and explore all the way down to the Vulkan API from there:</p>
<ol>
<li>First, we need to load our model from an .obj file with some help from the Assimp library. Here is some basic code to do it. Don’t forget that <code>reserve()</code> can be called on vectors for better performance. For simplicity here, we load just the first mesh and read only vertex positions and indices.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  const aiScene* scene = aiImportFile(
    “data/rubber_duck/scene.gltf”, aiProcess_Triangulate);
  const aiMesh* mesh = scene-&gt;mMeshes[0];
  std::vector&lt;vec3&gt; positions;
  std::vector&lt;uint32_t&gt; indices;
  positions.reserve(mesh-&gt;mNumVertices);
  indices.reserve(3 * mesh-&gt;mNumFaces);
  for (unsigned int i = 0; i != mesh-&gt;mNumVertices; i++) {
    const aiVector3D v = mesh-&gt;mVertices[i];
    positions.push_back(vec3(v.x, v.y, v.z));
  }
  for (unsigned int i = 0; i != mesh-&gt;mNumFaces; i++) {
    for (int j = 0; j != 3; j++)
      indices.push_back(mesh-&gt;mFaces[i].mIndices[j]);
  }
  aiReleaseImport(scene);</code></pre>
</div>
<ol>
<li>Now we have to create buffers for loaded vertex positions and indices. Our vertex buffer will have a usage flag <code>BufferUsageBits_Vertex</code>. We ask <em>LightweightVK</em> to upload the initial buffer data from <code>positions.data()</code> right from the get-go. The C++20 designated initializers syntax is very handy for this type of high-level API. The index buffer has a corresponding usage flag <code>BufferUsageBits_Index</code>. Both buffers are stored in GPU memory for better performance. This is ensured by specifying the storage type <code>StorageType_Device</code>, which is parsed in <em>LightweightVK</em> to pick an appropriate Vulkan memory type for these buffers.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  Holder&lt;lvk::BufferHandle&gt; vertexBuffer = ctx-&gt;createBuffer(
      { .usage     = lvk::BufferUsageBits_Vertex,
        .storage   = lvk::StorageType_Device,
        .size      = sizeof(vec3) * positions.size(),
        .data      = positions.data(),
        .debugName = “Buffer: vertex” }, nullptr);
  Holder&lt;lvk::BufferHandle&gt; indexBuffer = ctx-&gt;createBuffer(
      { .usage     = lvk::BufferUsageBits_Index,
        .storage   = lvk::StorageType_Device,
        .size      = sizeof(uint32_t) * indices.size(),
        .data      = indices.data(),
        .debugName = “Buffer: index” }, nullptr);</code></pre>
</div>
<ol>
<li>To render a complicated concave mesh with Vulkan, we have to use a depth buffer. We need to create one ourselves as follows. We specify <code>Format_Z_F32</code> here but the underlying <em>LightweightVK</em> Vulkan backend will replace it with whatever closes format is actually available on the current Vulkan implementation. The values of <code>width</code> and <code>height</code> correspond to the dimensions of the framebuffer. We are going to use the depth texture only as a depth buffer and are not going to sample from it, which means specifying usage flags as <code>TextureUsageBits_Attachment</code> is sufficient.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    Holder&lt;lvk::TextureHandle&gt; depthTexture = ctx-&gt;createTexture({
        .type       = lvk::TextureType_2D,
        .format     = lvk::Format_Z_F32,
        .dimensions = {(uint32_t)width, (uint32_t)height},
        .usage      = lvk::TextureUsageBits_Attachment,
        .debugName  = “Depth buffer”,
    });</code></pre>
</div>
<ol>
<li>Before we go forward and create rendering pipelines as was described in the previous chapter in the recipe <em>Initializing Vulkan pipelines</em>, we have to specify the vertex input state for them using the abovementioned vertex buffer. Here’s how we can do it. Here, <code>.location = 0</code> corresponds to the input location in a GLSL vertex shader, which will render this mesh.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  const lvk::VertexInput vdesc = {
    .attributes    = { { .location = 0, 
                         .format = lvk::VertexFormat::Float3 } },
    .inputBindings = { { .stride = sizeof(vec3) } },
  };</code></pre>
</div>
<ol>
<li>Now we can create two rendering pipelines. The first one is required to render a solid mesh. The other will render a wireframe mesh on top of it. Note that <code>.depthFormat</code> is set to the format of the depth texture we created earlier.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  Holder&lt;lvk::ShaderModuleHandle&gt; vert =
    loadShaderModule(ctx, “Chapter03/01_Assimp/src/main.vert”);
  Holder&lt;lvk::ShaderModuleHandle&gt; frag =
    loadShaderModule(ctx, “Chapter03/01_Assimp/src/main.frag”);
  Holder&lt;lvk::RenderPipelineHandle&gt; pipelineSolid =
    ctx-&gt;createRenderPipeline({
      .vertexInput = vdesc,
      .smVert      = vert,
      .smFrag      = frag,
      .color       = { { .format = ctx-&gt;getSwapchainFormat() } },
      .depthFormat = ctx-&gt;getFormat(depthTexture),
      .cullMode    = lvk::CullMode_Back,
  });</code></pre>
</div>
<ol>
<li>The second rendering pipeline does wireframe rendering by setting the <code>.polygonMode</code> field to <code>PolygonMode_Line</code>. Both pipelines use the same set of shaders. A specialization constant is used to change the shader behavior.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  const uint32_t isWireframe = 1;
  Holder&lt;lvk::RenderPipelineHandle&gt; pipelineWireframe =
    ctx-&gt;createRenderPipeline({
      .vertexInput = vdesc,
      .smVert      = vert,
      .smFrag      = frag,
      .specInfo = { .entries = { { .constantId = 0,
                                   .size = sizeof(uint32_t) } },
        .data = &amp;isWireframe, .dataSize = sizeof(isWireframe) },
      .color       = { { .format = ctx-&gt;getSwapchainFormat() } },
      .depthFormat = ctx-&gt;getFormat(depthTexture),
      .cullMode    = lvk::CullMode_Back,
      .polygonMode = lvk::PolygonMode_Line,
  });</code></pre>
</div>
<ol>
<li>Before we can enter the main loop, we need to define a depth state. The depth state enables depth buffer writes and sets an appropriate depth comparison operator.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  const lvk::DepthState dState = {
    .compareOp = lvk::CompareOp_Less, .isDepthWriteEnabled = true   };</code></pre>
</div>
<p>Now we can take a look at the application’s main loop. We skip GLFW events pulling and framebuffer size update code here. You can find them in <code>Chapter03/01_Assimp/src/main.cpp</code>:</p>
<ol>
<li>The main loop updates the projection matrix <code>p</code> based on the current framebuffer aspect ratio.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  while (!glfwWindowShouldClose(window)) {
    …
    const float ratio = width / height;
    const mat4 p = glm::perspective(45.0f, ratio, 0.1f, 1000.0f);</code></pre>
</div>
<ol>
<li>Set the model-view matrix to enable a gradual rotation of the model around the vertical axis. The model matrix <code>m</code> is responsible for aligning the model’s “up” direction with the vertical axis in Vulkan. The view matrix <code>v</code> is responsible for our 3D camera orientation and viewing direction, which rotates slowly around the vertical axis <code>Y</code>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    const mat4 m = glm::rotate(
      mat4(1.0f), glm::radians(-90.0f), vec3(1, 0, 0));
    const mat4 v = glm::rotate(glm::translate(mat4(1.0f),
      vec3(0.0f, -0.5f, -1.5f)), (float)glfwGetTime(),
      vec3(0.0f, 1.0f, 0.0f));</code></pre>
</div>
<ol>
<li>A render pass now requires specifying a load operation and a clear value for the depth buffer. The framebuffer has only one color-attachment – the current swapchain image.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    const lvk::RenderPass renderPass = {
      .color = {
        { .loadOp = LoadOp_Clear, .clearColor = { 1., 1., 1., 1. }}
      },
      .depth = { .loadOp = LoadOp_Clear, .clearDepth = 1. }
    };
    const lvk::Framebuffer framebuffer = {
      .color = { { .texture = ctx-&gt;getCurrentSwapchainTexture() } },
      .depthStencil = { .texture = depthTexture },
    };</code></pre>
</div>
<ol>
<li>With all preparations done, we can acquire a command buffer as described in the recipe <em>Using Vulkan command buffers</em> and begin rendering. Curly braces are used to emphasize the scope.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    lvk::ICommandBuffer&amp; buf = ctx-&gt;acquireCommandBuffer();
    buf.cmdBeginRendering(renderPass, framebuffer);</code></pre>
</div>
<ol>
<li>Both vertex and index buffers should be bound. The vertex buffer is bound to the binding point <code>0</code>. The index buffer uses unsigned 32-bit integer values as indices.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    buf.cmdBindVertexBuffer(0, vertexBuffer);
    buf.cmdBindIndexBuffer(indexBuffer, lvk::IndexFormat_UI32);</code></pre>
</div>
<ol>
<li>Let’s render a solid mesh using the first rendering pipeline and the depth state. The model-view-projection matrix is sent to the shader using Vulkan push constants. Push constants are a performant mechanism to pass very small amounts of data to shaders. Vulkan 1.3 guarantees at least <code>128</code> bytes for push constants, which is sufficient to store <code>2</code> 4x4 matrices or <code>16</code> arbitrary 64-bit GPU buffer addresses.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    buf.cmdBindRenderPipeline(pipelineSolid);
    buf.cmdBindDepthState(dState);
    buf.cmdPushConstants(p * v * m);
    buf.cmdDrawIndexed(lvk::Primitive_Triangle, indices.size());</code></pre>
</div>
<ol>
<li>Then, we render a wireframe copy of the mesh on top of the solid one. We set the depth bias so that wireframe edges are rendered correctly and without flickering.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    buf.cmdBindRenderPipeline(pipelineWireframe);
    buf.cmdSetDepthBias(0.0f, -1.0f, 0.0f);
    buf.cmdDrawIndexed(lvk::Primitive_Triangle, indices.size());</code></pre>
</div>
<ol>
<li>Now the command buffer can be submitted for execution.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    buf.cmdEndRendering();
    ctx-&gt;submit(buf, ctx-&gt;getCurrentSwapchainTexture());</code></pre>
</div>
<p>The demo application should render a colored rotating ducky with a wireframe overlay, as in the following screenshot.</p>
<figure>
<img alt="Figure 3.1: Rendering a mesh loaded with Assimp" height="756" src="../media/file15.png" width="1430"/><figcaption aria-hidden="true">Figure 3.1: Rendering a mesh loaded with Assimp</figcaption>
</figure>
<p>The high-level part was easy. Now let’s dive deep into the underlying implementation and learn how to implement this lean buffers-management interface using the Vulkan API.</p>
</section>
<section class="level3" data-number="4.3.3" id="how-it-works-2">
<h3 data-number="4.3.3">How it works…</h3>
<p>Let’s take a look at the low-level Vulkan code to understand how buffers work. Our deep dive starts with the exploration of <code>IContext::createBuffer()</code>, which takes a buffer description structure <code>BufferDesc</code> as input:</p>
<ol>
<li>The declaration of <code>BufferDesc</code> looks as follows.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>struct BufferDesc final {
  uint8_t usage = 0;
  StorageType storage = StorageType_HostVisible;
  size_t size = 0;
  const void* data = nullptr;
  const char* debugName = ““;
};</code></pre>
</div>
<p>The storage type can be one of the following three enum values: <code>StorageType_Device</code>, <code>StorageType_HostVisible</code>. They correspond to GPU local memory – which is not visible from the CPU side – and host-visible memory. The actual Vulkan memory type is selected more precisely by the underlying <em>LightweightVK</em> code and the <strong>VulkanMemoryAllocator</strong> (<strong>VMA</strong>) library.</p>
<ol>
<li>The buffer usage mode is a combination of the following flags. These flags are very flexible and we can request any necessary combination of them, except that uniform and storage buffers are exclusive.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>enum BufferUsageBits : uint8_t {
  BufferUsageBits_Index = 1 &lt;&lt; 0,
  BufferUsageBits_Vertex = 1 &lt;&lt; 1,
  BufferUsageBits_Uniform = 1 &lt;&lt; 2,
  BufferUsageBits_Storage = 1 &lt;&lt; 3,
  BufferUsageBits_Indirect = 1 &lt;&lt; 4,
};</code></pre>
</div>
<p>Let’s now look into the implementation of <code>VulkanContext::createBuffer()</code>, which converts requested LightweightVK buffer properties into corresponding supported Vulkan flags:</p>
<ol>
<li>Before everything else, we should check if a staging buffer should be used to upload data into this new buffer. If the staging buffer is disabled, for example, because our GPU has only one shared memory heap that is both host-visible and device-local, we override the requested device-local storage mode with <code>StorageType_HostVisible</code>. This is important to eliminate that extra copy on GPUs with such memory configurations.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>Holder&lt;BufferHandle&gt; VulkanContext::createBuffer(
  const BufferDesc&amp; requestedDesc, Result* outResult) {
  BufferDesc desc = requestedDesc;
  if (!useStaging_ &amp;&amp; (desc.storage == StorageType_Device))
    desc.storage = StorageType_HostVisible;</code></pre>
</div>
<ol>
<li>If the application wants a device-local buffer, we should use a staging buffer to transfer data into our device-local buffer. Set corresponding Vulkan flags to make sure we can transfer to and from such a buffer.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  VkBufferUsageFlags usageFlags = desc.storage == StorageType_Device ?
    VK_BUFFER_USAGE_TRANSFER_DST_BIT |
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT : 0;</code></pre>
</div>
<ol>
<li>For each requested usage flag, enable a specific set of necessary Vulkan usage flags. To use the buffer device address feature and access buffers by pointers from shaders, we should add the flag <code>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</code>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  if (desc.usage &amp; BufferUsageBits_Index)
    usageFlags |= VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
  if (desc.usage &amp; BufferUsageBits_Vertex)
    usageFlags |= VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
  if (desc.usage &amp; BufferUsageBits_Uniform)
    usageFlags |= VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT |
                  VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
  if (desc.usage &amp; BufferUsageBits_Storage)
    usageFlags |= VK_BUFFER_USAGE_STORAGE_BUFFER_BIT |
                  VK_BUFFER_USAGE_TRANSFER_DST_BIT |
                  VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
  if (desc.usage &amp; BufferUsageBits_Indirect)
    usageFlags |= VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT |
                  VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;</code></pre>
</div>
<ol>
<li>Get required Vulkan memory properties using a helper function and then call another variant of <code>VulkanContext::createBuffer()</code> that accepts only Vulkan flags. Delegation is helpful because this function is used inside the <em>LightweightVK</em> Vulkan backend to create internal auxiliary buffers. This function checks buffer size limits and creates a <code>VulkanBuffer</code> object in a corresponding pool.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  const VkMemoryPropertyFlags memFlags =
    storageTypeToVkMemoryPropertyFlags(desc.storage);
  Result result;
  BufferHandle handle = createBuffer(
    desc.size, usageFlags, memFlags, &amp;result, desc.debugName);</code></pre>
</div>
<ol>
<li>If some initial buffer data was provided, upload it immediately.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  if (desc.data) {
    upload(handle, desc.data, desc.size, 0);
  }
  Result::setResult(outResult, Result());
  return {this, handle};
}</code></pre>
</div>
<p>Let’s take a look at the interface of <code>VulkanBuffer</code>, which wraps Vulkan buffer management functionality.</p>
<ol>
<li>All previously obtained Vulkan flags are passed to the class constructor. The default constructor is trivial and enables <code>VulkanBuffer</code> to be stored in <em>LightweightVK</em> object pools. We will talk about these pools later in subsequent chapters.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>class VulkanBuffer final {
 public:
  VulkanBuffer() = default;
  VulkanBuffer(lvk::VulkanContext* ctx,
               VkDevice device,
               VkDeviceSize bufferSize,
               VkBufferUsageFlags usageFlags,
               VkMemoryPropertyFlags memFlags,
               const char* debugName = nullptr);
  ~VulkanBuffer();</code></pre>
</div>
<ol>
<li>A bunch of methods to get data from the host into and out of buffers. All host-visible buffers are automatically mapped so that we can access their data via normal C++ pointers. The function <code>flushMappedMemory()</code> is necessary in case buffers on our system do not support coherent memory. This function is called to make the data, written into the mapped memory by the host, become available to the GPU. It is a wrapper over <code>vkFlushMappedMemoryRanges()</code> and <code>vmaFlushAllocation()</code> when the <strong>Vulkan Memory Allocator</strong> (<strong>VMA</strong>) library is enabled.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  void bufferSubData(size_t offset, size_t size, const void* data);
  void getBufferSubData(size_t offset, size_t size, void* data);
  [[nodiscard]] uint8_t* getMappedPtr() const {
    return static_cast&lt;uint8_t*&gt;(mappedPtr_);
  }
  bool isMapped() const { return mappedPtr_ != nullptr; }
  void flushMappedMemory(VkDeviceSize offset, VkDeviceSize size);</code></pre>
</div>
<ol>
<li>Data members encapsulate everything necessary related to the underlying Vulkan buffer management code. VMA-related fields are used only when the <em>VMA</em> library is enabled.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  lvk::VulkanContext* ctx_ = nullptr;
  VkDevice device_ = VK_NULL_HANDLE;
  VkBuffer vkBuffer_ = VK_NULL_HANDLE;
  VkDeviceMemory vkMemory_ = VK_NULL_HANDLE;
  VmaAllocationCreateInfo vmaAllocInfo_ = {};
  VmaAllocation vmaAllocation_ = VK_NULL_HANDLE;
  VkDeviceAddress vkDeviceAddress_ = 0;
  VkDeviceSize bufferSize_ = 0;
  VkBufferUsageFlags vkUsageFlags_ = 0;
  VkMemoryPropertyFlags vkMemFlags_ = 0;
  void* mappedPtr_ = nullptr;
};</code></pre>
</div>
<p>Now we are ready to create an actual Vulkan buffer object. Let’s take a look at the code. Error handling is omitted for the sake of better understanding:</p>
<ol>
<li>Constructor parameters are used directly to populate the <em>VkBufferCreateInfo</em> structure.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>lvk::VulkanBuffer::VulkanBuffer(lvk::VulkanContext* ctx,
                                VkDevice device,
                                VkDeviceSize bufferSize,
                                VkBufferUsageFlags usageFlags,
                                VkMemoryPropertyFlags memFlags,
                                const char* debugName) :
  ctx_(ctx), device_(device), bufferSize_(bufferSize),
  vkUsageFlags_(usageFlags), vkMemFlags_(memFlags)
{
  const VkBufferCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
      .pNext = nullptr,
      .flags = 0,
      .size = bufferSize,
      .usage = usageFlags,
      .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
      .queueFamilyIndexCount = 0,
      .pQueueFamilyIndices = nullptr,
  };</code></pre>
</div>
<ol>
<li>Now we decide whether to use Vulkan directly or let <em>Vulkan Memory Allocator</em> do all the memory allocation for us. VMA is the main code path, while direct Vulkan calls are helpful to do debugging when necessary. In the case of VMA, we convert flags once again.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  if (LVK_VULKAN_USE_VMA) {
    if (memFlags &amp; VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) {
      vmaAllocInfo_.requiredFlags =
        VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT;
      vmaAllocInfo_.preferredFlags =
        VK_MEMORY_PROPERTY_HOST_COHERENT_BIT |
        VK_MEMORY_PROPERTY_HOST_CACHED_BIT;
      vmaAllocInfo_.flags = VMA_ALLOCATION_CREATE_MAPPED_BIT |
        VMA_ALLOCATION_CREATE_HOST_ACCESS_RANDOM_BIT;
    }
    if (memFlags &amp; VK_MEMORY_PROPERTY_HOST_COHERENT_BIT)
      vmaAllocInfo_.requiredFlags |=
        VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
    vmaAllocInfo_.usage = VMA_MEMORY_USAGE_AUTO;
    vmaCreateBuffer((VmaAllocator)ctx_-&gt;getVmaAllocator(), &amp;ci,
      &amp;vmaAllocInfo_, &amp;vkBuffer_, &amp;vmaAllocation_, nullptr);</code></pre>
</div>
<ol>
<li>Handle host-visible memory-mapped buffers. Use persistent mapping for the entire lifetime of the buffer.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    if (memFlags &amp; VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) {
      vmaMapMemory((VmaAllocator)ctx_-&gt;getVmaAllocator(),
        vmaAllocation_, &amp;mappedPtr_);
    }
  } else {</code></pre>
</div>
<ol>
<li>The direct Vulkan code path is straightforward but requires manual memory allocation. Refer to <code>lvk/vulkan/VulkanClasses.cpp</code> for full detailed error checking, which is omitted here in the text.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    vkCreateBuffer(device_, &amp;ci, nullptr, &amp;vkBuffer_);
    VkMemoryRequirements requirements = {};
    vkGetBufferMemoryRequirements(device_, vkBuffer_, &amp;requirements);
    lvk::allocateMemory(ctx_-&gt;getVkPhysicalDevice(), device_,
      &amp;requirements, memFlags, &amp;vkMemory_));
    vkBindBufferMemory(device_, vkBuffer_, vkMemory_, 0);</code></pre>
</div>
<ol>
<li>Host-visible buffers are handled in a similar way.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    if (memFlags &amp; VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) {
      vkMapMemory(device_, vkMemory_, 0, bufferSize_, 0, &amp;mappedPtr_);
    }
  }</code></pre>
</div>
<ol>
<li>Let’s set a user-provided debug name for this buffer.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  lvk::setDebugObjectName(
    device_, VK_OBJECT_TYPE_BUFFER, (uint64_t)vkBuffer_, debugName);</code></pre>
</div>
<ol>
<li>Once the buffer is created, get a buffer device address that can be used in shaders to access this buffer.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  if (usageFlags &amp; VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT) {
    const VkBufferDeviceAddressInfo ai = {
      .sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
      .buffer = vkBuffer_,     };
    vkDeviceAddress_ = vkGetBufferDeviceAddress(device_, &amp;ai);
  }
}</code></pre>
</div>
<p>The buffer destruction process is interesting and worth mentioning because Vulkan buffers should not be deleted while still in use by the GPU. Besides doing VMA and Vulkan calls for memory unmapping and deallocation, the destructor defers the actual deallocation until the buffer is no longer in use by the GPU:</p>
<ol>
<li>If this <code>VulkanBuffer</code> object was created with the default constructor and does not have any payload, we can just return immediately. The <code>deferredTask()</code> member function postpones the execution of its lambda argument to a later time when all previously submitted command buffers have completed processing. We will look into this mechanism in subsequent chapters.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>lvk::VulkanBuffer::~VulkanBuffer() {
  if (!ctx_) return;
  if (LVK_VULKAN_USE_VMA) {
    if (mappedPtr_)
      vmaUnmapMemory(
        (VmaAllocator)ctx_-&gt;getVmaAllocator(), vmaAllocation_);
    ctx_-&gt;deferredTask(std::packaged_task&lt;void()&gt;(
      [vma = ctx_-&gt;getVmaAllocator(),
       buffer = vkBuffer_,
       allocation = vmaAllocation_]() {
      vmaDestroyBuffer((VmaAllocator)vma, buffer, allocation);
    }));
  } else {</code></pre>
</div>
<ol>
<li>A similar approach is taken when we do not use VMA and talk to Vulkan directly.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    if (mappedPtr_)
      vkUnmapMemory(device_, vkMemory_);
    ctx_-&gt;deferredTask(std::packaged_task&lt;void()&gt;(
      [device = device_, buffer = vkBuffer_, memory = vkMemory_]() {
      vkDestroyBuffer(device, buffer, nullptr);
      vkFreeMemory(device, memory, nullptr);
    }));
  }
}</code></pre>
</div>
<p>There are three other member functions to mention here before we conclude how we work with Vulkan buffers:</p>
<ol>
<li>The function <code>flushMappedMemory()</code> is used to ensure that host writes to the buffer mapped memory become available to the GPU when the coherent memory is not supported.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>void lvk::VulkanBuffer::flushMappedMemory(
  VkDeviceSize offset, VkDeviceSize size) const
{
  if (!LVK_VERIFY(isMapped()))return;
  if (LVK_VULKAN_USE_VMA) {
    vmaFlushAllocation((VmaAllocator)ctx_-&gt;getVmaAllocator(),
      vmaAllocation_, offset, size);
  } else {
    const VkMappedMemoryRange memoryRange = {
      .sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE,
      .memory = vkMemory_,
      .offset = offset,
      .size = size,
    };
    vkFlushMappedMemoryRanges(device_, 1, &amp;memoryRange);
  }
}</code></pre>
</div>
<ol>
<li>The function <code>getBufferSubData()</code> wraps a <code>memcpy()</code> operation in a convenient way. It only works with memory-mapped host-visible buffers. Device-local buffers are handled separately using a staging buffer. We will discuss this mechanism in subsequent chapters.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>void lvk::VulkanBuffer::getBufferSubData(
  size_t offset, size_t size, void* data) {
  LVK_ASSERT(mappedPtr_);
  if (!mappedPtr_) return;
  LVK_ASSERT(offset + size &lt;= bufferSize_);
  const uint8_t* src = static_cast&lt;uint8_t*&gt;(mappedPtr_) + offset;
  memcpy(data, src, size);
}</code></pre>
</div>
<ol>
<li>The function <code>bufferSubData()</code> is a similar wrapper. It is trivial for host-visible buffers. Note how <code>memset()</code> is used here to set the content of the buffer to <code>0</code>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>void lvk::VulkanBuffer::bufferSubData(
  size_t offset, size_t size, const void* data) {
  if (!mappedPtr_) return;
  LVK_ASSERT(offset + size &lt;= bufferSize_);
  if (data) {
    memcpy((uint8_t*)mappedPtr_ + offset, data, size);
  } else {
    memset((uint8_t*)mappedPtr_ + offset, 0, size);
  }
}</code></pre>
</div>
<p>Now we’ve covered all the Vulkan code necessary to run the app <code>Chapter03/01_Assimp</code>, which renders an <code>.obj</code> 3D model loaded via <em>Assimp</em>. There are two small functions to mention that bind vertex and index buffers, respectively, and are part of the <code>ICommandBuffer</code> interface.</p>
<ol>
<li>The first function binds a vertex buffer via <code>vkCmdBindVertexBuffers()</code> to be used for vertex input. A few checks are necessary to ensure the correct usage of buffers. In subsequent chapters, we will learn how to omit vertex buffers altogether and learn the <em>Programmable-Vertex-Pulling</em> (<em>PVP</em>) approach.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>void lvk::CommandBuffer::cmdBindVertexBuffer(uint32_t index,
  BufferHandle buffer, size_t bufferOffset)
{
  if (!LVK_VERIFY(!buffer.empty()))return;
  lvk::VulkanBuffer* buf = ctx_-&gt;buffersPool_.get(buffer);
  VkBuffer vkBuf = buf-&gt;vkBuffer_;
  LVK_ASSERT(buf-&gt;vkUsageFlags_ &amp; VK_BUFFER_USAGE_VERTEX_BUFFER_BIT);
  const VkDeviceSize offset = bufferOffset;
  vkCmdBindVertexBuffers(
    wrapper_-&gt;cmdBuf_, index, 1, &amp;vkBuf, &amp;offset);
}</code></pre>
</div>
<ol>
<li>The second function binds an index buffer using <code>vkCmdBindIndexBuffer()</code>. Besides assertions, some enum types conversion from <em>LightweightVK</em> to the Vulkan API.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>void lvk::CommandBuffer::cmdBindIndexBuffer(BufferHandle indexBuffer,
  IndexFormat indexFormat, size_t indexBufferOffset)
{
  lvk::VulkanBuffer* buf = ctx_-&gt;buffersPool_.get(indexBuffer);
  LVK_ASSERT(buf-&gt;vkUsageFlags_ &amp; VK_BUFFER_USAGE_INDEX_BUFFER_BIT);
  const VkIndexType type = indexFormatToVkIndexType(indexFormat);
  vkCmdBindIndexBuffer(
    wrapper_-&gt;cmdBuf_, buf-&gt;vkBuffer_, indexBufferOffset, type);
}</code></pre>
</div>
<p>The application <code>Chapter03/01_Assimp</code> should render the following image.</p>
<figure>
<img alt="Figure 3.2: Rendering a mesh loaded with Assimp" height="756" src="../media/file16.png" width="1430"/><figcaption aria-hidden="true">Figure 3.2: Rendering a mesh loaded with Assimp</figcaption>
</figure>
<p>Now we are done with some very basic Vulkan usage and ready to add some textures to our examples.</p>
</section>
</section>
<section class="level2" data-number="4.4" id="implementing-staging-buffers">
<h2 data-number="4.4">Implementing staging buffers</h2>
<p>GPU device-local buffers are not visible from the host, and we can upload data into them using various CPU-GPU-CPU copy operations. In Vulkan, this can be done by creating an auxiliary buffer, called a staging buffer, which is CPU-visible or host-visible, uploading some data into it from the host and then issuing GPU commands to copy from this staging buffer into a device-local buffer. Let’s learn how to implement this technique in Vulkan.</p>
<section class="level3" data-number="4.4.1" id="getting-ready-14">
<h3 data-number="4.4.1">Getting ready</h3>
<p>Before reading any further, check out the previous recipe, <em>Dealing with buffers in Vulkan</em>, to learn how to create different types of Vulkan buffers.</p>
</section>
<section class="level3" data-number="4.4.2" id="how-to-do-it-1">
<h3 data-number="4.4.2">How to do it…</h3>
<p>As usual, let’s start from the high-level interface of LightweightVK and then dive deep into the implementation. The interface class <code>IContext</code> declared in <code>lvk/LVK.h</code> exposes the following methods to operate on buffers.</p>
<div class="C0-SHCodePACKT">
<pre><code>Result upload(BufferHandle handle,
  const void* data, size_t size, size_t offset = 0) = 0;
uint8_t* getMappedPtr(BufferHandle handle) const = 0;
uint64_t gpuAddress(BufferHandle handle, size_t offset = 0) const = 0;
void flushMappedMemory(BufferHandle handle,
  size_t offset, size_t size) const = 0;</code></pre>
</div>
<p>These methods are implemented in a subclass <code>VulkanContext</code> and roughly correspond to the implementation of <code>VulkanBuffer</code> that was discussed in detail in the previous recipe. We also saw how <code>VulkanContext::createBuffer()</code> calls <code>VulkanContext::uload()</code> in case there’s some initial data to be uploaded into a buffer. Let’s take a look at what is inside that method.</p>
<ol>
<li>First of all, we have to convert a buffer handle into a pointer to a <code>VulkanBuffer</code> object. This is done by a pool that stores all <code>VulkanBuffer</code> objects in the system. The pool implementation will be discussed in subsequent recipes. For now, let’s just pretend that it is an opaque mechanism to map an integer handle into a <code>VulkanBuffer</code> object pointer.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>Result VulkanContext::upload(lvk::BufferHandle handle,
  const void* data, size_t size, size_t offset) {
  if (!LVK_VERIFY(data)) return lvk::Result();
  lvk::VulkanBuffer* buf = buffersPool_.get(handle);</code></pre>
</div>
<ol>
<li>After doing some range checking, we delegate the work to the member function <code>VulkanStagingDevice::bufferSubData()</code>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  if (!LVK_VERIFY(offset + size &lt;= buf-&gt;bufferSize_))
    return Result(Result::Code::ArgumentOutOfRange, “Out of range”);
  stagingDevice_-&gt;bufferSubData(*buf, offset, size, data);
  return lvk::Result();
}</code></pre>
</div>
<p>The class <code>VulkanStagingDevice</code> encapsulates all the functionality necessary to manage Vulkan staging buffers.</p>
<ol>
<li>The staging device provides functionality to access device-local buffers and images. In this recipe, we will focus only on the buffers part and 2D images. While 3D image uploading is supported by <em>LightweightVK</em>, it is not used in our book, and we will skip it. If you are interested in learning those details, you are encouraged to check the actual source code of <em>LightweightVK</em> at <code>lvk/vulkan/VulkanClasses.cpp</code>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>class VulkanStagingDevice final {
 public:
  explicit VulkanStagingDevice(VulkanContext&amp; ctx);
  ~VulkanStagingDevice();
  void bufferSubData(VulkanBuffer&amp; buffer,
    size_t dstOffset, size_t size, const void* data);
  void imageData2D(VulkanImage&amp; image,
                   const VkRect2D&amp; imageRegion,
                   uint32_t baseMipLevel,
                   uint32_t numMipLevels,
                   uint32_t layer,
                   uint32_t numLayers,
                   VkFormat format,
                   const void* data[]);
  // … imageData3D() is skipped</code></pre>
</div>
<ol>
<li>Each call to <code>bufferSubData()</code> or <code>imageData2D()</code> occupies some space in the staging buffer. The structure <code>MemoryRegionDesc</code> describes such a memory region with one <code>SubmitHandle</code> that was used to upload data through it.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code> private:
  struct MemoryRegionDesc {
    uint32_t srcOffset_ = 0;
    uint32_t alignedSize_ = 0;
    SubmitHandle handle_ = {};
  };</code></pre>
</div>
<ol>
<li>The function <code>getNextFreeOffset()</code> returns the next available memory region suitable to accommodate <code>size</code> bytes of data. The function <code>waitAndReset()</code> is used internally to wait until all memory regions become available.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  MemoryRegionDesc getNextFreeOffset(uint32_t size);
  void waitAndReset();
 private:
  VulkanContext&amp; ctx_;
  BufferHandle stagingBuffer_;
  std::unique_ptr&lt;lvk::VulkanImmediateCommands&gt; immediate_;
  uint32_t stagingBufferFrontOffset_ = 0;
  uint32_t stagingBufferSize_ = 0;
  uint32_t bufferCapacity_ = 0;
  std::vector&lt;MemoryRegionDesc&gt; regions_;
};</code></pre>
</div>
<p>The uploading process is trivial once we understand how the <code>getNextFreeOffset()</code> helper function works. Let’s take a look:</p>
<ol>
<li>Make sure the requested buffer size is aligned. Some compressed image formats require the size to be padded to <code>16</code> bytes. We just use that value greedily here. A simple binary arithmetic trick is used to ensure the size value is aligned as required.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>MemoryRegionDesc VulkanStagingDevice::getNextFreeOffset(uint32_t size) {
  constexpr uint32_t kStagingBufferAlignment_ = 16;
  uint32_t alignedSize = (size + kStagingBufferAlignment_ - 1) &amp;
     ~(kStagingBufferAlignment_ - 1);</code></pre>
</div>
<ol>
<li>Track the most suitable memory region. Check if we can reuse any of the previously used memory regions. This may cause some memory fragmentation in the staging buffer, but it’s not a concern since these sub-allocations have a very short lifespan.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  auto bestIt = regions_.begin();
  for (auto it = regions_.begin(); it != regions_.end(); it++) {
    if (immediate_-&gt;isReady(SubmitHandle(it-&gt;handle_))) {
      if (it-&gt;alignedSize_ &gt;= alignedSize) {
        SCOPE_EXIT { regions_.erase(it); };
        return *it;
      }
      if (bestIt-&gt;alignedSize_ &lt; it-&gt;alignedSize_) bestIt = it;
    }
  }</code></pre>
</div>
<ol>
<li>Reclaim and return the memory region. If there is no more space available in the staging buffer, reclaim all previous memory regions.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  if (bestIt != regions_.end() &amp;&amp; 
      bufferCapacity_ &lt; bestIt-&gt;alignedSize_) {
    regions_.erase(bestIt);
    return *bestIt;
  }
  if (bufferCapacity_ == 0) waitAndReset();</code></pre>
</div>
<ol>
<li>If we cannot reuse any previous memory region, allocate a new one from the free staging memory.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  alignedSize =
    (alignedSize &lt;= bufferCapacity_) ? alignedSize : bufferCapacity_;
  const uint32_t srcOffset = stagingBufferFrontOffset_;
  stagingBufferFrontOffset_ =
    (stagingBufferFrontOffset_ + alignedSize) % stagingBufferSize_;
  bufferCapacity_ -= alignedSize;
  return {srcOffset, alignedSize};
}</code></pre>
</div>
<p>Now we can implement the <code>VulkanStagingDevice::bufferSubData()</code> function. The main complexity here comes when the size of the data to upload is greater than the size of the staging buffer.</p>
<ol>
<li>If the destination buffer is host-visible, just mem-copy the data into it as we discussed in the previous recipe, <em>Dealing with buffers in Vulkan:</em></li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>void VulkanStagingDevice::bufferSubData(VulkanBuffer&amp; buffer,
  size_t dstOffset, size_t size, const void* data)
{
  if (buffer.isMapped()) {
    buffer.bufferSubData(dstOffset, size, data);
    return;
  }
  lvk::VulkanBuffer* stagingBuffer =
    ctx_.buffersPool_.get(stagingBuffer_);</code></pre>
</div>
<ol>
<li>Iterate while there’s still some data to upload. On each iteration, we try to obtain a memory region to fit the entire remaining size. We select a chunk size accordingly:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  while (size) {
    MemoryRegionDesc desc = getNextFreeOffset((uint32_t)size);
    const uint32_t chunkSize =
      std::min((uint32_t)size, desc.alignedSize_);</code></pre>
</div>
<ol>
<li>The staging buffer itself is always host-visible, so we can mem-copy our data into it:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    stagingBuffer-&gt;bufferSubData(desc.srcOffset_, chunkSize, data);</code></pre>
</div>
<ol>
<li>Acquire a command buffer and issue Vulkan commands to copy buffer data between the staging buffer and the destination buffer:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    const VkBufferCopy copy = {desc.srcOffset_, dstOffset, chunkSize};
    auto&amp; wrapper = immediate_-&gt;acquire();
    vkCmdCopyBuffer(wrapper.cmdBuf_,
      stagingBuffer-&gt;vkBuffer_, buffer.vkBuffer_, 1, &amp;copy);
    desc.handle_ = immediate_-&gt;submit(wrapper);</code></pre>
</div>
<ol>
<li>As the GPU is doing the copying, we add this memory region – together with its <code>SubmitHandle</code> – to the container of occupied memory regions:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    regions_.push_back(desc);
    size -= chunkSize;
    data = (uint8_t*)data + chunkSize;
    dstOffset += chunkSize;
  }
}</code></pre>
</div>
<p>Another crucial role of the staging buffer is to copy pixel data into Vulkan images. Let’s take a look at how it can be implemented. This function is significantly more complicated, so we omit all the error checking again here in the text for the sake of better understanding the code.</p>
<ol>
<li>The <code>imageData2D()</code> function can upload in one go multiple layers of an image, starting from <code>layer</code>, together with multiple mip-levels starting from <code>baseMipLevel</code>. <em>LightweightVK</em> assumes there’s a maximum possible number of mip-levels. We calculate the size in bytes of each mip-level.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>void VulkanStagingDevice::imageData2D(VulkanImage&amp; image,
                                      const VkRect2D&amp; imageRegion,
                                      uint32_t baseMipLevel,
                                      uint32_t numMipLevels,
                                      uint32_t layer,
                                      uint32_t numLayers,
                                      VkFormat format,
                                      const void* data[])
{
  uint32_t mipSizes[LVK_MAX_MIP_LEVELS];</code></pre>
</div>
<ol>
<li>As we know the base mip-level number that we want to update, we can calculate its dimensions from the Vulkan image extents by bit-shifting.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  uint32_t width = image.vkExtent_.width &gt;&gt; baseMipLevel;
  uint32_t height = image.vkExtent_.height &gt;&gt; baseMipLevel;
  const Format texFormat(vkFormatToFormat(format));</code></pre>
</div>
<ol>
<li>Now let us calculate per-layer storage sizes, which are necessary to accommodate all corresponding mip-levels of the image. The function <code>getTextureBytesPerLayer()</code> returns the size in bytes of a layer with the requested image format. Store the results in <code>mipSizes[]</code>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  uint32_t layerStorageSize = 0;
  for (uint32_t i = 0; i &lt; numMipLevels; ++i) {
    const uint32_t mipSize = lvk::getTextureBytesPerLayer(
      image.vkExtent_.width, image.vkExtent_.height, texFormat, i);
    layerStorageSize += mipSize;
    mipSizes[i] = mipSize;
    width = width &lt;= 1 ? 1 : width &gt;&gt; 1;
    height = height &lt;= 1 ? 1 : height &gt;&gt; 1;
  }</code></pre>
</div>
<ol>
<li>Now we know the size necessary to store the entire image data. Try to acquire the next memory region from the staging buffer. <em>LightweightVK</em> provides no support for copying image data in multiple smaller chunks. If we get a memory region smaller than <code>storageSize</code>, we should until a bigger memory region becomes available. One consequence of this is that <em>LightweightVK</em> is unable to upload images whose memory footprint is larger than the staging buffer size.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  const uint32_t storageSize = layerStorageSize * numLayers;
  MemoryRegionDesc desc = getNextFreeOffset(layerStorageSize);
  if (desc.alignedSize_ &lt; storageSize) {
    waitAndReset();
    desc = getNextFreeOffset(storageSize);
  }
  LVK_ASSERT(desc.alignedSize_ &gt;= storageSize);</code></pre>
</div>
<ol>
<li>Once we have a suitable memory region in the staging buffer, we can iterate over image layers and mip-levels to prepare the data for Vulkan.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  lvk::VulkanBuffer* stagingBuffer =
    ctx_.buffersPool_.get(stagingBuffer_);
  auto&amp; wrapper = immediate_-&gt;acquire();
  for (uint32_t layer = 0; layer != numLayers; layer++) {
    stagingBuffer-&gt;bufferSubData(
      desc.srcOffset_ + layer * layerStorageSize,
      layerStorageSize,
      data[layer]);
    uint32_t mipLevelOffset = 0;
    for (uint32_t mipLevel = 0; mipLevel &lt; numMipLevels; ++mipLevel) {
      const auto currentMipLevel = baseMipLevel + mipLevel;</code></pre>
</div>
<ol>
<li>Transition the image layout into <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code> so that we can use it as a destination in Vulkan transfer operations.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>      lvk::imageMemoryBarrier(wrapper.cmdBuf_,
                              image.vkImage_,
                              0,
                              VK_ACCESS_TRANSFER_WRITE_BIT,
                              VK_IMAGE_LAYOUT_UNDEFINED,
                              VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
                              VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
                              VK_PIPELINE_STAGE_TRANSFER_BIT,
                              VkImageSubresourceRange{
                                VK_IMAGE_ASPECT_COLOR_BIT,
                                currentMipLevel, 1, layer, 1});</code></pre>
</div>
<ol>
<li>Copy the pixel data from the staging buffer into the image. The buffer offset for this level is at the start of all mip-levels plus the size of all previous mip-levels being uploaded.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>      const VkRect2D region = {
        .offset = {.x = imageRegion.offset.x &gt;&gt; mipLevel,
                   .y = imageRegion.offset.y &gt;&gt; mipLevel},
        .extent = {.width =
                     max(1u, imageRegion.extent.width &gt;&gt; mipLevel),
                   .height=
                     max(1u, imageRegion.extent.height &gt;&gt; mipLevel)},
      };
      const VkBufferImageCopy copy = {
          .bufferOffset =
            desc.srcOffset_ + layer*layerStorageSize + mipLevelOffset,
          .bufferRowLength = 0,
          .bufferImageHeight = 0,
          .imageSubresource = VkImageSubresourceLayers{
            VK_IMAGE_ASPECT_COLOR_BIT, currentMipLevel, layer, 1},
          .imageOffset = {.x = region.offset.x,
                          .y = region.offset.y,
                          .z = 0},
          .imageExtent = {.width = region.extent.width,
                          .height = region.extent.height,
                          .depth = 1u},
      };
      vkCmdCopyBufferToImage(wrapper.cmdBuf_,
        stagingBuffer-&gt;vkBuffer_, image.vkImage_,
        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &amp;copy);</code></pre>
</div>
<ol>
<li>We are done with this mip-level and layer. Transition its image layout from <code>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</code>, into <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>. This is necessary for normal workflow as any subsequent code dealing with images expects this image layout.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>      lvk::imageMemoryBarrier(
        wrapper.cmdBuf_,
        image.vkImage_,
        VK_ACCESS_TRANSFER_READ_BIT | VK_ACCESS_TRANSFER_WRITE_BIT,
        VK_ACCESS_SHADER_READ_BIT,
        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
        VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
        VK_PIPELINE_STAGE_TRANSFER_BIT,
        VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
        VkImageSubresourceRange{
          VK_IMAGE_ASPECT_COLOR_BIT, currentMipLevel, 1, layer, 1});</code></pre>
</div>
<p>The Vulkan image layout is a property of each image sub-resource that describes how the data in memory is organized in some opaque implementation-specific manner. This property is considered by the Vulkan implementation when the image is accessed. Not specifying correct layouts for different use cases may result in undefined behavior and distorted images.</p>
<ol>
<li>Advance the buffer offset to the next mip-level.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>      mipLevelOffset += mipSizes[mipLevel];
    }
  }</code></pre>
</div>
<ol>
<li>Once the Vulkan commands are recorded in the command buffer, we can submit it to copy the image data. Before we exit, we set the last image layout to <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code> so that correct image layout transitions can happen later on.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  desc.handle_ = immediate_-&gt;submit(wrapper);
  image.vkImageLayout_ = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
  regions_.push_back(desc);
}</code></pre>
</div>
<p>This is all regarding the staging buffers implementation and the uploading device-local buffer data and images via them.</p>
</section>
<section class="level3" data-number="4.4.3" id="theres-more-2">
<h3 data-number="4.4.3">There’s more…</h3>
<p><em>LightweightVK</em> has a function <code>VulkanStagingDevice::imageData3D()</code> to upload 3D texture data using a staging buffer. It can be found in <code>lvk/vulkan/VulkanClasses.cpp</code>. Make sure you explore it.</p>
<p>There can be a memory heap described by the flags <code>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT | VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>. Some GPUs can have a separate relatively small memory heap like that, while some GPUs can have the entire device memory marked as host-visible. This is called Resizable BAR, or ReBAR, which is a hardware feature allowing the CPU to access GPU device memory. If you have such a memory heap, you can use it to write data to GPU local memory directly. For example, you can allocate a staging buffer in that memory. If you want to learn more comprehensive details about Vulkan memory types and how to use them, here’s an amazing article by Adam Sawicki: <code>https://asawicki.info/news_1740_vulkan_memory_types_on_pc_and_how_to_use_them</code>.</p>
<p>Now, we have everything we need to know about how to deal with Vulkan images. Let’s go to the next recipe and learn how to use Vulkan images to create textures.</p>
</section>
</section>
<section class="level2" data-number="4.5" id="using-texture-data-in-vulkan">
<h2 data-number="4.5">Using texture data in Vulkan</h2>
<p>Before we can write meaningful 3D rendering applications with Vulkan, we need to learn how to deal with textures. This recipe shows how to implement a number of functions to create, destroy, and modify texture objects on the GPU using the Vulkan API.</p>
<section class="level3" data-number="4.5.1" id="getting-ready-15">
<h3 data-number="4.5.1">Getting ready</h3>
<p>Uploading texture data to the GPU requires a staging buffer. Read the recipe <em>Dealing with buffers</em> before you proceed further.</p>
<p>The source code for this recipe can be found in <code>Chapter03/02_STB</code>.</p>
</section>
<section class="level3" data-number="4.5.2" id="how-to-do-it...-14">
<h3 data-number="4.5.2">How to do it...</h3>
<p>The first thing we do is create an image. A Vulkan image is another type of object backed by memory, designed to store 1D, 2D, and 3D images or arrays of those images. Readers familiar with OpenGL will probably be wondering about cube maps. Cube maps are represented as an array of six 2D images and can be constructed by setting the <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code> flag in the <code>VkImageCreateInfo</code> structure. We will come back to that later. Now let us investigate the basic use case with just a 2D image. Let’s start with the high-level application code and go all the way down to Vulkan image allocation:</p>
<ol>
<li>The application <code>Chapter03/02_STB</code> loads pixel data from a <code>.jpg</code> file using the STB library (<a href="https://github.com/nothings/stb">https://github.com/nothings/stb</a>). We enforce conversion to 4-channels to simplify texture handling. Many Vulkan implementations do not support 3-channel images.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  int w, h, comp;
  const uint8_t* img = stbi_load(“data/wood.jpg”, &amp;w, &amp;h, &amp;comp, 4);</code></pre>
</div>
<ol>
<li>A handle to a texture object is created. The texture format is normalized unsigned 8-bit RGBA, which corresponds to the Vulkan format <code>VK_FORMAT_R8G8B8A8_UNORM</code>. We intend to use this texture for sampling in shaders, so we specify the texture usage flag <code>TextureUsageBits_Sampled</code>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  lvk::Holder&lt;lvk::TextureHandle&gt; texture = ctx-&gt;createTexture({
      .type       = lvk::TextureType_2D,
      .format     = lvk::Format_RGBA_UN8,
      .dimensions = {(uint32_t)w, (uint32_t)h},
      .usage      = lvk::TextureUsageBits_Sampled,
      .data       = img,
      .debugName  = “03_STB.jpg”,
  });</code></pre>
</div>
<ol>
<li>Do not forget to free the image memory.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  stbi_image_free((void*)img);</code></pre>
</div>
<ol>
<li>Let’s take a look at the main loop. <em>LightweightVK</em> is built around the bindless renderer design. Bindless rendering is a technique that allows for more efficient GPU resource management by removing the need to explicitly bind resources, such as textures, buffers, or samplers. Here’s how we can pass texture data into shaders using push constants. After that, we render a quad formed of <code>4</code> triangle strip vertices.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    const struct PerFrameData {
      mat4 mvp;
      uint32_t textureId;
    } pc = {
      .mvp       = p * m,
      .textureId = texture.index(),
    };
    …
    buf.cmdPushConstants(pc);
    buf.cmdDraw(lvk::Primitive_TriangleStrip, 0, 4);
    …</code></pre>
</div>
<ol>
<li>The vertices are generated without any vertex input right in the vertex shader <code>Chapter03/02_STB/src/main.vert</code>, which looks as follows.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>#version 460 core
layout(push_constant) uniform PerFrameData {
  uniform mat4 MVP;
  uint textureId;
};
layout (location=0) out vec2 uv;
const vec2 pos[4] = vec2[4](
  vec2(1.0, -1.0), vec2(1.0,  1.0), vec2(-1.0, -1.0), vec2(-1.0, 1.0)
);
void main() {
  gl_Position = MVP * vec4(0.5 * pos[gl_VertexIndex], 0.0, 1.0);
  uv = (pos[gl_VertexIndex]+vec2(0.5)) * 0.5;
}</code></pre>
</div>
<ol>
<li>The fragment shader is much more interesting. We need to declare arrays of 2D textures and samplers provided by <em>LightweightVK</em>. They contain all textures and all samplers loaded at the current moment. The element <code>0</code> in both arrays corresponds to a dummy object. This is useful for safely utilizing null values as texture identifiers. Our push constant <code>textureId</code> is nothing but an index into the <code>kTextures2D</code> array.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>#version 460 core
#extension GL_EXT_nonuniform_qualifier : require
layout (set = 0, binding = 0) uniform texture2D kTextures2D[];
layout (set = 0, binding = 1) uniform sampler kSamplers[];
layout (location=0) in vec2 uv;
layout (location=0) out vec4 out_FragColor;
layout(push_constant) uniform PerFrameData {
  uniform mat4 MVP;
  uint textureId;
};</code></pre>
</div>
<ol>
<li>Here’s a handy helper function <code>textureBindless2D()</code> to sample from a bindless 2D texture using a bindless sampler. We shall use it instead of standard GLSL <code>texture()</code> to quickly sample a texture.</li>
</ol>
<p>Here we provided the entire fragment shader GLSL source code ourselves. If we skip the <code>#version</code> directive at the beginning of the shader, <em>LightweightVK</em> will inject this and many other helper functions into our GLSL source code, together with <code>kTextures2D[]</code> and other declarations. We will use this functionality in subsequent chapters to simplify our shaders. Here we list this function just for purely educational reasons.</p>
<div class="C1-SHCodePACKT">
<pre><code>vec4 textureBindless2D(uint textureid, uint samplerid, vec2 uv) {
  return texture(sampler2D(kTextures2D[textureid],
                           kSamplers[samplerid]), uv);
}
void main() {
  out_FragColor = textureBindless2D(textureId, 0, uv);
}</code></pre>
</div>
<p>In case of not dynamically uniform texture indices, the <code>nonuniformEXT</code> type qualifier is required by the Vulkan API to be used when indexing descriptor bindings.</p>
<p>The resulting application <code>Chapter03/02_STB</code> should render a textured rotating quad as in the following screenshot.</p>
<figure>
<img alt="Figure 3.3: Rendering a textured quad" height="756" src="../media/file17.png" width="1430"/><figcaption aria-hidden="true">Figure 3.3: Rendering a textured quad</figcaption>
</figure>
<p>The high-level part was pretty short and straightforward, hiding all the Vulkan complexity from us. Now let’s take a look at the underlying implementation to learn how it works.</p>
</section>
<section class="level3" data-number="4.5.3" id="how-it-works-3">
<h3 data-number="4.5.3">How it works…</h3>
<p>Vulkan textures, namely images and image views, are complex. Together with descriptor sets, they are necessary to access texture data in shaders. The <em>LightweightVK</em> implementation of textures comes in many layers. Let’s dissect them one by one and learn how.</p>
<p>The tip of the iceberg is the function <code>VulkanContext::createTexture()</code>, which returns a handle to a texture. The function is quite long, so we omit the error-checking code here again to make it a bit easier to understand:</p>
<ol>
<li>This function converts a <em>LightweightVK</em> texture description <code>TextureDesc</code> into various Vulkan flags for images and image views. The extra argument <code>debugName</code> provides a convenient way to override the <code>TextureDesc::debugName</code> field. It is very useful if we want to create multiple textures using the same <code>TextureDesc</code> object.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>Holder&lt; TextureHandle&gt; VulkanContext::createTexture(
  const TextureDesc&amp; requestedDesc,
  const char* debugName,
  Result* outResult)
{
  TextureDesc desc(requestedDesc);
  if (debugName &amp;&amp; *debugName) desc.debugName = debugName;</code></pre>
</div>
<ol>
<li>Convert the <em>LightweightVK</em> format into Vulkan format. Vulkan has somewhat stronger guarantees regarding the support of color formats. Therefore, depth formats are converted based on the actual availability, while color formats are converted as is.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  const VkFormat vkFormat = lvk::isDepthOrStencilFormat(desc.format) ?
    getClosestDepthStencilFormat(desc.format) :
    formatToVkFormat(desc.format);
  const lvk::TextureType type = desc.type;</code></pre>
</div>
<ol>
<li>If the image is going to be allocated in the GPU device memory, we should set the <code>VK_IMAGE_USAGE_TRANSFER_DST_BIT</code> to allow Vulkan to transfer data into it. Other Vulkan image usage flags are set accordingly to the <em>LVK</em> usage flags.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  VkImageUsageFlags usageFlags = desc.storage == StorageType_Device ?
    VK_IMAGE_USAGE_TRANSFER_DST_BIT : 0;
  if (desc.usage &amp; lvk::TextureUsageBits_Sampled)
    usageFlags |= VK_IMAGE_USAGE_SAMPLED_BIT;
  if (desc.usage &amp; lvk::TextureUsageBits_Storage)
    usageFlags |= VK_IMAGE_USAGE_STORAGE_BIT;
  if (desc.usage &amp; lvk::TextureUsageBits_Attachment)
    usageFlags |= lvk::isDepthOrStencilFormat(desc.format) ?
      VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT :
      VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;</code></pre>
</div>
<ol>
<li>For convenience, we always allow an image to be read back from the GPU to the CPU. However, it might be worth checking if this usage flag is actually supported. The memory flags are chosen in the same way as we did for buffers in the recipe <em>Dealing with buffers in Vulkan</em>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  usageFlags |= VK_IMAGE_USAGE_TRANSFER_SRC_BIT;
  const VkMemoryPropertyFlags memFlags =
    storageTypeToVkMemoryPropertyFlags(desc.storage);</code></pre>
</div>
<ol>
<li>Generate debug names for Vulkan image and image view objects by prefixing the provided <code>debugName</code> string.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  const bool hasDebugName = desc.debugName &amp;&amp; *desc.debugName;
  char debugNameImage[256] = {0};
  char debugNameImageView[256] = {0};
  if (hasDebugName) {
    snprintf(debugNameImage, sizeof(debugNameImage)-1,
      “Image: %s”, desc.debugName);
    snprintf(debugNameImageView, sizeof(debugNameImageView) - 1,
      “Image View: %s”, desc.debugName);
  }</code></pre>
</div>
<ol>
<li>Now we can deduce <code>VkImageCreateFlags</code> and types of the Vulkan image and image view.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  VkImageCreateFlags createFlags = 0;
  uint32_t arrayLayerCount = static_cast&lt;uint32_t&gt;(desc.numLayers);
  VkImageViewType imageViewType;
  VkImageType imageType;
  VkSampleCountFlagBits samples = VK_SAMPLE_COUNT_1_BIT;
  switch (desc.type) {</code></pre>
</div>
<ol>
<li>2D images can be multisampled (<a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">https://en.wikipedia.org/wiki/Multisample_anti-aliasing</a>).</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    case TextureType_2D:
      imageViewType = VK_IMAGE_VIEW_TYPE_2D;
      imageType = VK_IMAGE_TYPE_2D;
      samples = lvk::getVulkanSampleCountFlags(desc.numSamples);
      break;
    case TextureType_3D:
      imageViewType = VK_IMAGE_VIEW_TYPE_3D;
      imageType = VK_IMAGE_TYPE_3D;
      break;</code></pre>
</div>
<ol>
<li>Cube textures in Vulkan can be represented with an image view of the type <code>VK_IMAGE_VIEW_TYPE_CUBE</code> and a 2D image with a special flag <code>VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT</code>. The number of layers if multiplied by <code>6</code> to accommodate all cube map faces according to the Vulkan specification.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    case TextureType_Cube:
      imageViewType = VK_IMAGE_VIEW_TYPE_CUBE;
      arrayLayerCount *= 6;
      imageType = VK_IMAGE_TYPE_2D;
      createFlags = VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT;
      break;
  }</code></pre>
</div>
<ol>
<li>Now we can create a wrapper object <code>VulkanImage</code> which encapsulates all necessary <code>VkImage</code> related properties. We will explore the <code>createImage()</code> function a bit later.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  Result result;
  std::shared_ptr&lt;VulkanImage&gt; image = createImage(imageType,
    VkExtent3D{ desc.dimensions.width,
                desc.dimensions.height,
                desc.dimensions.depth},
    vkFormat,
    desc.numMipLevels,
    arrayLayerCount,
    VK_IMAGE_TILING_OPTIMAL,
    usageFlags,
    memFlags,
    createFlags,
    samples,
    &amp;result,
    debugNameImage);</code></pre>
</div>
<ol>
<li>To access a Vulkan image from shaders, we need to create a <code>VkImageView</code> object. To do so, we have to choose which image “aspect” should be included in the view. Images in Vulkan can have multiple aspects simultaneously, such as combined depth-stencil images, hence depth and stencil bits are handled separately.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  VkImageAspectFlags aspect = 0;
  if (image-&gt;isDepthFormat_ || image-&gt;isStencilFormat_) {
    if (image-&gt;isDepthFormat_) {
      aspect |= VK_IMAGE_ASPECT_DEPTH_BIT;
    } else if (image-&gt;isStencilFormat_) {
      aspect |= VK_IMAGE_ASPECT_STENCIL_BIT;
    }
  } else {
    aspect = VK_IMAGE_ASPECT_COLOR_BIT;
  }</code></pre>
</div>
<ol>
<li>An image view can control which mip-levels and layers are included. Here we create an image view that contains all levels and layers of the image. Later, we will need separate image views for framebuffer attachments that can have only one layer and one mip-level.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  VkImageView view = image-&gt;createImageView(
    imageViewType, vkFormat, aspect, 0, VK_REMAINING_MIP_LEVELS, 0,
    arrayLayerCount, debugNameImageView);</code></pre>
</div>
<ol>
<li><em>LightweightVK</em> calls a pair of objects – <code>VkImage</code>, wrapped in the <code>VulkanImage</code> class, and <code>VkImageView</code> – as a texture. The Boolean flag <code>awaitingCreation_</code> tells <code>VulkanContext</code> that a texture was created and the bindless descriptor set has to be updated. We will come back to this in the next chapters.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  TextureHandle handle = texturesPool_.create(
    lvk::VulkanTexture(std::move(image), view));
  awaitingCreation_ = true;</code></pre>
</div>
<ol>
<li>Before we return a handle to the newly created texture, let’s upload the initial texture data.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  if (desc.data) {
    const void* mipMaps[] = {desc.data};
    upload(handle,
      {.dimensions = desc.dimensions, .numMipLevels = 1}, mipMaps);
  }
  return {this, handle};
}</code></pre>
</div>
<p>The abovementioned helper function <code>createImage()</code> creates a <code>VulkanImage</code> object. It does some error checking, which is omitted here, and delegates the actual work to the constructor of <code>VulkanImage</code>. Here’s its implementation just for convenience.</p>
<div class="C1-SHCodePACKT">
<pre><code>std::shared_ptr&lt;VulkanImage&gt; VulkanContext::createImage(
  VkImageType imageType, VkExtent3D extent,  VkFormat format,
  uint32_t numLevels,   uint32_t numLayers, VkImageTiling tiling,
  VkImageUsageFlags usageFlags, VkMemoryPropertyFlags memFlags,
  VkImageCreateFlags flags, VkSampleCountFlagBits samples,
  lvk::Result* outResult, const char* debugName)
{
  return std::make_shared&lt;VulkanImage&gt;(*this, vkDevice_, extent,
    imageType, format, numLevels, numLayers, tiling, usageFlags,
    memFlags, flags, samples, debugName);
}</code></pre>
</div>
<p>We will be more interested in the <code>VulkanImage</code> constructor, which creates an actual <code>VkImage</code> object.</p>
<ol>
<li>The constructor takes a bunch of parameters describing all necessary Vulkan properties of the image.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>VulkanImage::VulkanImage(VulkanContext&amp; ctx, VkDevice device,
  VkExtent3D extent, VkImageType type, VkFormat format,
  uint32_t numLevels, uint32_t numLayers, VkImageTiling tiling,
  VkImageUsageFlags usageFlags, VkMemoryPropertyFlags memFlags,
  VkImageCreateFlags createFlags, VkSampleCountFlagBits samples,
  const char* debugName) :
  ctx_(ctx), vkDevice_(device), vkUsageFlags_(usageFlags),
  vkExtent_(extent), vkType_(type), vkImageFormat_(format),
  numLevels_(numLevels), numLayers_(numLayers), vkSamples_(samples),
  isDepthFormat_(isDepthFormat(format)),
  isStencilFormat_(isStencilFormat(format))
 {</code></pre>
</div>
<ol>
<li>Using these parameters, we can fill in the <code>VkImageCreateInfo</code> structure right away. LightweightVK does not work with multiple Vulkan queues, so it sets the sharing mode to <code>VK_SHARING_MODE_EXCLUSIVE</code>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>   const VkImageCreateInfo ci = {
      .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
      .flags = createFlags,
      .imageType = type,
      .format = vkImageFormat_,
      .extent = vkExtent_,
      .mipLevels = numLevels_,
      .arrayLayers = numLayers_,
      .samples = samples,
      .tiling = tiling,
      .usage = usageFlags,
      .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
      .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
  };</code></pre>
</div>
<ol>
<li>In the same way that we dealt with buffers in the recipe <em>Dealing with buffers in Vulkan</em>, we have two code paths for Vulkan images. One uses the <em>Vulkan Memory Allocator</em> library and the other calls Vulkan directly to allocate memory. This is useful for debugging purposes.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  if (LVK_VULKAN_USE_VMA) {
    vmaAllocInfo_.usage = memFlags &amp;
      VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT ?
        VMA_MEMORY_USAGE_CPU_TO_GPU : VMA_MEMORY_USAGE_AUTO;
    VkResult result = vmaCreateImage(
      (VmaAllocator)ctx_.getVmaAllocator(), &amp;ci, &amp;vmaAllocInfo_,
      &amp;vkImage_, &amp;vmaAllocation_, nullptr);</code></pre>
</div>
<ol>
<li>We can have memory-mapped images in the same way we have memory-mapped buffers. However, this is only useful for non-tiled image layouts.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    if (memFlags &amp; VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) {
      vmaMapMemory((VmaAllocator)ctx_.getVmaAllocator(),
        vmaAllocation_, &amp;mappedPtr_);
    }
  } else {</code></pre>
</div>
<ol>
<li>The direct Vulkan code path is quite similar. We call <code>vkCreateImage()</code> and then allocate some memory and bind it using <code>vkBindImageMemory()</code>. Memory allocation is done in the same way as we did earlier in this chapter for buffers in the recipe <em>Dealing with buffers in Vulkan</em>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    VK_ASSERT(vkCreateImage(vkDevice_, &amp;ci, nullptr, &amp;vkImage_));
    VkMemoryRequirements memRequirements;
    vkGetImageMemoryRequirements(device, vkImage_, &amp;memRequirements);
    VK_ASSERT(lvk::allocateMemory(ctx.getVkPhysicalDevice(),
      vkDevice_, &amp;memRequirements, memFlags, &amp;vkMemory_));
    VK_ASSERT(vkBindImageMemory(vkDevice_, vkImage_, vkMemory_, 0));
    if (memFlags &amp; VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) {
      VK_ASSERT(vkMapMemory(
        vkDevice_, vkMemory_, 0, VK_WHOLE_SIZE, 0, &amp;mappedPtr_));
    }
  }</code></pre>
</div>
<ol>
<li>Before exiting, set the debug name of the created <code>VkImage</code> object and retrieve physical device format properties for further use.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  VK_ASSERT(lvk::setDebugObjectName(vkDevice_, VK_OBJECT_TYPE_IMAGE,
    (uint64_t)vkImage_, debugName));
  vkGetPhysicalDeviceFormatProperties(ctx.getVkPhysicalDevice(),
    vkImageFormat_, &amp;vkFormatProperties_);
}</code></pre>
</div>
<p>Once we have a <code>VulkanImage</code> wrapper object, we can create an image view. This is much simpler and can be done using a short member <code>createImageView()</code> function.</p>
<ol>
<li>This function does not use any wrappers and creates a <code>VkImageView</code> object directly.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>VkImageView VulkanImage::createImageView(VkImageViewType type,
  VkFormat format, VkImageAspectFlags aspectMask,
  uint32_t baseLevel, uint32_t numLevels,
  uint32_t baseLayer, uint32_t numLayers,
  const char* debugName) const
 {
  const VkImageViewCreateInfo ci = {
    .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
    .image = vkImage_,
    .viewType = type,
    .format = format,
    .components = {.r = VK_COMPONENT_SWIZZLE_IDENTITY,
                   .g = VK_COMPONENT_SWIZZLE_IDENTITY,
                   .b = VK_COMPONENT_SWIZZLE_IDENTITY,
                   .a = VK_COMPONENT_SWIZZLE_IDENTITY},</code></pre>
</div>
<ol>
<li>If a non-zero <code>numLevels</code> argument was provided, we would use it to override the number of mip-levels we want to have in this new image view. Otherwise, we use all mip-levels available in the current image to create the image view. This is handy because image views for framebuffer attachments should have only <code>1</code> mip-level.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    .subresourceRange = { 
      aspectMask, baseLevel,
      numLevels ? numLevels : numLevels_,
      baseLayer, numLayers},
  };
  VkImageView vkView = VK_NULL_HANDLE;
  VK_ASSERT(vkCreateImageView(vkDevice_, &amp;ci, nullptr, &amp;vkView));
  VK_ASSERT(lvk::setDebugObjectName(vkDevice_,
    VK_OBJECT_TYPE_IMAGE_VIEW, (uint64_t)vkView, debugName));
  return vkView;
}</code></pre>
</div>
<p>The <code>VkImage</code> and <code>VkImageView</code> objects created above can represent a texture. <em>LightweightVK</em> groups them together into the <code>VulkanTexture</code> class.</p>
<div class="C1-SHCodePACKT">
<pre><code>struct VulkanTexture final {
  VulkanTexture() = default;
  VulkanTexture(std::shared_ptr&lt;lvk::VulkanImage&gt; image,
                VkImageView imageView);
  ~VulkanTexture();
  VkExtent3D getExtent() const { return image_-&gt;vkExtent_;  }
  VkImageView getOrCreateVkImageViewForFramebuffer(
    uint8_t level, uint16_t layer);
  std::shared_ptr&lt;lvk::VulkanImage&gt; image_;
  VkImageView imageView_ = VK_NULL_HANDLE; // all mip-levels
  VkImageView imageViewForFramebuffer_[LVK_MAX_MIP_LEVELS][6] = {}; // max 6 faces for cubemap rendering
};</code></pre>
</div>
<p>As you can see, the <code>VulkanTexture</code> class is just a data container and the only interesting part is the <code>getOrCreateVkImageViewForFramebuffer()</code> function. As we mentioned earlier, image views that are used as framebuffer attachments should have only <code>1</code> mip-level and <code>1</code> layer. This function precaches such image views in a simple way inside the array <code>imageViewForFramebuffer_[][]</code>. It supports a maximum of only <code>6</code> layers – this is just enough to render into the faces of a cube map.</p>
</section>
<section class="level3" data-number="4.5.4" id="theres-more-3">
<h3 data-number="4.5.4">There’s more…</h3>
<p>While technically all of the abovementioned code is sufficient to create <code>VkImage</code> and <code>VkImageView</code> objects, we still cannot access them from shaders. To do that, we need to learn how to store these objects and how to create and manage Vulkan descriptor sets. Let’s move on to the next recipes to learn that.</p>
</section>
</section>
<section class="level2" data-number="4.6" id="storing-vulkan-objects">
<h2 data-number="4.6">Storing Vulkan objects</h2>
<p>In the previous recipes, we mentioned a plethora of <code>lvk::…Handle</code> classes wrapped in a unique-pointer-like class <code>lvk::Holder</code>. They are central to how <em>LightweightVK</em> manages Vulkan objects and other resources. Handles are lightweight value types that are cheap to pass around as integers and we pay no costs of shared ownership with atomic counters compared to <code>std::shared_ptr</code> and similar reference-counted smart pointers. When having ownership of some object is desirable, we wrap handles in the <code>lvk::Holder</code> class, which conceptually is similar to <code>std::unique_ptr</code>.</p>
<section class="level3" data-number="4.6.1" id="getting-ready-16">
<h3 data-number="4.6.1">Getting ready</h3>
<p>The <em>LightweightVK</em> implementation of handles is inspired by Sebastian Aaltonen`s SIGGRAPH 2023 presentation <em>HypeHype Mobile Rendering Architecture</em>. If you want to learn more low-level interesting details about an API design using handles, make sure to read: <a href="https://advances.realtimerendering.com/s2023/AaltonenHypeHypeAdvances2023.pdf">https://advances.realtimerendering.com/s2023/AaltonenHypeHypeAdvances2023.pdf</a>.</p>
</section>
<section class="level3" data-number="4.6.2" id="how-to-do-it-2">
<h3 data-number="4.6.2">How to do it…</h3>
<p>An abstract handle is represented by a templated class <code>Handle&lt;&gt;</code>:</p>
<ol>
<li>Handles are designed to serve as pointers to objects that are stored in arrays. An index into an array is sufficient to identify an object. To handle situations when objects are deallocated and then replaced by other objects, we introduce a value <code>gen_</code>, which represents the object’s “generation” and is incremented every time a new object is assigned to the same element in the storage array.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>template&lt;typename ObjectType&gt; class Handle final {
  uint32_t index_ = 0;
  uint32_t gen_ = 0;</code></pre>
</div>
<ol>
<li>These values are private so that handles can be constructed only by a friendly <code>Pool</code> class. The <code>Pool</code> class is templated and is parametrized by two types; one corresponds to the handle`s object type and the other is the type stored inside the implementation array. It is not visible from the interface.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  Handle(uint32_t index, uint32_t gen) : index_(index), gen_(gen){};
  template&lt;typename ObjectType,
           typename ImplObjectType&gt; friend class Pool;
 public:
  Handle() = default;</code></pre>
</div>
<ol>
<li>The contract is that handles with a generation equal to 0 are considered empty null-handles.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  bool empty() const { return gen_ == 0; }
  bool valid() const { return gen_ != 0; }
  uint32_t index() const { return index_; }
  uint32_t gen() const { return gen_; }</code></pre>
</div>
<ol>
<li>The <code>indexAsVoid()</code> function is helpful when we need to pass a handle through some third-party C-style interface that accepts <code>void*</code> parameters. One example used in this book is <em>ImGui</em> integration, which is discussed in the next chapter, <em>Chapter 4</em>, <em>Adding User Interaction and Productivity Tools</em>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  void* indexAsVoid() const 
  { return reinterpret_cast&lt;void*&gt;(static_cast&lt;ptrdiff_t&gt;(index_)); }
  bool operator==(const Handle&lt;ObjectType&gt;&amp; other) const
  { return index_ == other.index_ &amp;&amp; gen_ == other.gen_;  }
  bool operator!=(const Handle&lt;ObjectType&gt;&amp; other) const
  { return index_ != other.index_ || gen_ != other.gen_; }</code></pre>
</div>
<ol>
<li>The explicit conversion to <code>bool</code> is necessary to allow the usage of handles in conditional statements such as <code>if (handle) …</code>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  explicit operator bool() const { return gen_ != 0; }
};
static_assert(sizeof(Handle&lt;class Foo&gt;) == sizeof(uint64_t));</code></pre>
</div>
<p>The <code>Handle&lt;&gt;</code> template can be parametrized with a forward-declared object, which is never defined. This is done to ensure type safety so that heterogenous handles cannot be mixed with each other. Here is how <em>LightweightVK</em> declares all its <code>Handle&lt;&gt;</code> types. All structs are declared but not defined.</p>
<div class="C1-SHCodePACKT">
<pre><code>using ComputePipelineHandle = lvk::Handle&lt;struct ComputePipeline&gt;;
using RenderPipelineHandle = lvk::Handle&lt;struct RenderPipeline&gt;;
using ShaderModuleHandle = lvk::Handle&lt;struct ShaderModule&gt;;
using SamplerHandle = lvk::Handle&lt;struct Sampler&gt;;
using BufferHandle = lvk::Handle&lt;struct Buffer&gt;;
using TextureHandle = lvk::Handle&lt;struct Texture&gt;;</code></pre>
</div>
<p>Handles do not own the objects they point to. Only the <code>Holder&lt;&gt;</code> class does. Let’s take a look at its implementation:</p>
<ol>
<li>The <code>Holder&lt;&gt;</code> class is templated with a <code>Handle</code> type it can hold. The constructor accepts a handle and a pointer to <code>lvk::IContext</code> to ensure the handle can be destroyed properly. The class has move-only semantics similar to <code>std::unique_ptr</code>. We skip definitions of the move constructor and move assignment for the sake of brevity.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>template&lt;typename HandleType&gt; class Holder final {
 public:
  Holder() = default;
  Holder(lvk::IContext* ctx, HandleType handle)
    : ctx_(ctx), handle_(handle) {}</code></pre>
</div>
<ol>
<li>We do not have a declaration of the <code>IContext</code> class here. That is why we use an overloaded forward-declared function <code>lvk::destroy()</code> to deallocate the handle.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  ~Holder() { lvk::destroy(ctx_, handle_); }
  Holder(const Holder&amp;) = delete;
  Holder(Holder&amp;&amp; other):ctx_(other.ctx_), handle_(other.handle_) {…}
  Holder&amp; operator=(const Holder&amp;) = delete;
  Holder&amp; operator=(Holder&amp;&amp; other) { … }</code></pre>
</div>
<ol>
<li>Assign <code>nullptr</code> to a holder:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  Holder&amp; operator=(std::nullptr_t) { this-&gt;reset(); return *this; }
  inline operator HandleType() const { return handle_; }
  bool valid() const { return handle_.valid(); }
  bool empty() const { return handle_.empty(); }</code></pre>
</div>
<ol>
<li>Manually reset the holder and make it deallocate the stored handle or just return the handle and release ownership when necessary:</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  void reset() {
    lvk::destroy(ctx_, handle_);
    ctx_ = nullptr;
    handle_ = HandleType{};
  }
  HandleType release() {
    ctx_ = nullptr;
    return std::exchange(handle_, HandleType{});
  }
  uint32_t index() const { return handle_.index(); }
  void* indexAsVoid() const { return handle_.indexAsVoid(); }
 private:
  lvk::IContext* ctx_ = nullptr;
  HandleType handle_;
};</code></pre>
</div>
<ol>
<li>The <code>Holder</code> class calls a family of overloaded <code>destroy()</code> functions. Here is how <em>LightweightVK</em> defines them, once function per each handle type.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>void destroy(lvk::IContext* ctx, lvk::ComputePipelineHandle handle);
void destroy(lvk::IContext* ctx, lvk::RenderPipelineHandle handle);
void destroy(lvk::IContext* ctx, lvk::ShaderModuleHandle handle);
void destroy(lvk::IContext* ctx, lvk::SamplerHandle handle);
void destroy(lvk::IContext* ctx, lvk::BufferHandle handle);
void destroy(lvk::IContext* ctx, lvk::TextureHandle handle);</code></pre>
</div>
<ol>
<li>Implementations of these functions are located in <code>lightweightvk/lvk/LVK.cpp</code> and they all look very similar. Each function calls a corresponding overloaded method in <code>IContext</code>. While it may seem unnecessary, this actually helps to avoid a circular dependency between the <code>Holder</code> class and <code>IContext</code>, making the interface much cleaner.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>void destroy(lvk::IContext* ctx, lvk::ComputePipelineHandle handle) {
  if (ctx) ctx-&gt;destroy(handle);
}</code></pre>
</div>
<p>That is all there is to discuss about the <code>Holder</code> class and the portion of the Handle-Holder mechanism exposed in the interface. Now, let’s delve into the implementation and understand how object <code>Pool</code>s can be implemented.</p>
</section>
<section class="level3" data-number="4.6.3" id="how-it-works-4">
<h3 data-number="4.6.3">How it works…</h3>
<p>The implementation starts with a class <code>Pool&lt;&gt;</code>, which is located in <code>lightweightvk/lvk/Pool.h</code>. It stores a collection of objects of type <code>ImplObjectType</code> inside <code>std::vector</code> and can manage handles to these objects. Let’s look at the implementation details:</p>
<ol>
<li>Every array element is a struct <code>PoolEntry</code> that stores an <code>ImplObjectType</code> object by value together with its generation used to check handles that point to this element. The field <code>nextFree_</code> is used to maintain a linked list of free elements inside the array. Once a handle is deallocated, a corresponding array element is added to the free list. The field <code>freeListHead_</code> stores an index of the first free element, or <code>kListEndSentinel</code> if there are no free elements.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>template&lt;typename ObjectType, typename ImplObjectType&gt;
class Pool {
  static constexpr uint32_t kListEndSentinel = 0xffffffff;
  struct PoolEntry {
    explicit PoolEntry(ImplObjectType&amp; obj) : obj_(std::move(obj)) {}
    ImplObjectType obj_ = {};
    uint32_t gen_ = 1;
    uint32_t nextFree_ = kListEndSentinel;
  };
  uint32_t freeListHead_ = kListEndSentinel;
public:
  std::vector&lt;PoolEntry&gt; objects_;</code></pre>
</div>
<p>Proponents of data-oriented design may argue that this structure minimizes cache utilization by interleaving the payload of <code>ImplObjectType</code> with utility values <code>gen_</code> and <code>nextFree_</code>. This is indeed true. One approach to mitigate this is to maintain two separate arrays. The first array can tightly pack <code>ImplObjectType</code> values, while the second one can store the necessary metadata for bookkeeping. In fact, it can go a step further, as mentioned in the original presentation by Sebastian Aaltonen, by separating a high-frequency accessed “hot” object type from a low-frequency accessed “cold” type, which can be stored in different arrays. However, for the sake of simplicity, we will leave this as an exercise for our readers.</p>
<ol>
<li>A method to create a new handle takes an R-value reference. It checks the head of the free list. If there is a free element within the array, we can promptly place our object into it and remove the front element from the free list.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  Handle&lt;ObjectType&gt; create(ImplObjectType&amp;&amp; obj) {
    uint32_t idx = 0;
    if (freeListHead_ != kListEndSentinel) {
      idx = freeListHead_;
      freeListHead_ = objects_[idx].nextFree_;
      objects_[idx].obj_ = std::move(obj);
    } else {</code></pre>
</div>
<ol>
<li>If there’s no space inside, append a new element to the <code>std::vector</code> container.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>      idx = (uint32_t)objects_.size();
      objects_.emplace_back(obj);
    }
    numObjects_++;
    return Handle&lt;ObjectType&gt;(idx, objects_[idx].gen_);
  }</code></pre>
</div>
<ol>
<li>Destruction is simple but involves some additional error checking. Empty handles should not be destroyed. Trying to remove a non-empty handle from an empty pool means a logic error and should assert. If the generation of the handle does not match the generation of the corresponding array element, it means we are trying to do double-deletion.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  void destroy(Handle&lt;ObjectType&gt; handle) {
    if (handle.empty()) return;
    assert(numObjects_ &gt; 0);
    const uint32_t index = handle.index();
    assert(index &lt; objects_.size());
    assert(handle.gen() == objects_[index].gen_); // double deletion</code></pre>
</div>
<ol>
<li>If all the checks are successful, replace the stored object with an empty default-constructed object and increment its generation. Then, place this array element at the front of the free list.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    objects_[index].obj_ = ImplObjectType{};
    objects_[index].gen_++;
    objects_[index].nextFree_ = freeListHead_;
    freeListHead_ = index;
    numObjects_--;
  }</code></pre>
</div>
<ol>
<li>Dereferencing a handle is done via the <code>get()</code> method, which has <code>const</code> and non-<code>const</code> implementations. They are identical, so we can check only one. A mismatch of the generation allows us to identify access to a deleted object.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  ImplObjectType* get(Handle&lt;ObjectType&gt; handle) {
    if (handle.empty()) return nullptr;
    const uint32_t index = handle.index();
    assert(index &lt; objects_.size());
    assert(handle.gen() == objects_[index].gen_); // deleted object
    return &amp;objects_[index].obj_;
  }</code></pre>
</div>
<ol>
<li>A pool can be manually cleared so that a destructor is called for every object.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  void clear() {
    objects_.clear();
    freeListHead_ = kListEndSentinel;
    numObjects_ = 0;
  }</code></pre>
</div>
<ol>
<li>The member field <code>numObjects_</code> is used to track memory leaks and prevent deallocations inside an empty pool.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  uint32_t numObjects() const {
    return numObjects_;
  }
  uint32_t numObjects_ = 0;
};</code></pre>
</div>
<p>That is how <code>Pool</code>s work. The actual implementation in <code>VulkanContext</code> uses them to store all implementation-specific objects that are accessible by handles from the interface side. These are the declarations that can be found in <code>lightweightvk/lvk/vulkan/VulkanClasses.h</code>. In many situations, Vulkan objects – such as <code>VkShaderModule</code> and <code>VkSampler</code> – can be stored directly. If some additional bookkeeping is required, a wrapper object is stored instead.</p>
<div class="C0-SHCodePACKT">
<pre><code>Pool&lt;lvk::ShaderModule, VkShaderModule&gt; shaderModulesPool_;
Pool&lt;lvk::RenderPipeline, RenderPipelineState&gt; renderPipelinesPool_;
Pool&lt;lvk::ComputePipeline, ComputePipelineState&gt;
  computePipelinesPool_;
Pool&lt;lvk::Sampler, VkSampler&gt; samplersPool_;
Pool&lt;lvk::Buffer, VulkanBuffer&gt; buffersPool_;
Pool&lt;lvk::Texture, VulkanTexture&gt; texturesPool_;</code></pre>
</div>
<p>Now we know how to store various objects and expose access to them via handles. Before we can conclude the topic of this chapter and finish our introduction to Vulkan, let’s take a look at how to construct bindless descriptor sets to access textures from GLSL shaders.</p>
</section>
</section>
<section class="level2" data-number="4.7" id="using-vulkan-descriptor-indexing">
<h2 data-number="4.7">Using Vulkan descriptor indexing</h2>
<p>Descriptor indexing became a part of the Vulkan core in version 1.2 as an optional feature. Vulkan 1.3 made it mandatory. This feature allows applications to put all the resources they have into one huge descriptor set and make it available to all shaders. There is no need to manage descriptor pools, and no need to construct per-shader descriptor sets. Everything is available to the shaders at once. Shaders can access all resources in the system, and the only practical limit is performance.</p>
<p>Let us learn how to work with descriptor sets and descriptor indexing Vulkan by exploring the <em>LightweightVK</em> framework.</p>
<section class="level3" data-number="4.7.1" id="how-to-do-it...-15">
<h3 data-number="4.7.1">How to do it...</h3>
<p>Let’s take a look at some parts of the <code>lvk::VulkanContext</code> class that deals with descriptors. The <code>VulkanContext</code> class declaration in <code>lightweightvk/lvk/vulkan/VulkanClasses.h</code> contains these member fields. The integer variables store the maximal number of resources that can be stored in the currently allocated descriptor set <code>vkDSet_</code>, which is allocated from a descriptor pool <code>vkDPool_</code>. The descriptor pool is allocated according to the descriptor set layout <code>vkDSL_</code>. The submit handle <code>lastSubmitHandle_</code> corresponds to the last submit this descriptor set was a part of. Submit handles were discussed in the previous chapter in the recipe <em>Using Vulkan command buffers</em>.</p>
<div class="C0-SHCodePACKT">
<pre><code>  uint32_t currentMaxTextures_ = 16;
  uint32_t currentMaxSamplers_ = 16;
  VkPipelineLayout vkPipelineLayout_ = VK_NULL_HANDLE;
  VkDescriptorSetLayout vkDSL_ = VK_NULL_HANDLE;
  VkDescriptorPool vkDPool_ = VK_NULL_HANDLE;
  VkDescriptorSet vkDSet_ = VK_NULL_HANDLE;
  SubmitHandle lastSubmitHandle = SubmitHandle();</code></pre>
</div>
<p>Let’s start our exploration with the function <code>growDescriptorPool()</code>, which recreates Vulkan objects as needed to accommodate the requested number of textures and samplers. Excessive error checking is omitted for the sake of readability:</p>
<ol>
<li>First, error checking is done to ensure the number of resources is within the hardware-specific limits.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>Result lvk::VulkanContext::growDescriptorPool(
  uint32_t maxTextures, uint32_t maxSamplers)
{
  currentMaxTextures_ = maxTextures;
  currentMaxSamplers_ = maxSamplers;
  if (!LVK_VERIFY(maxTextures &lt;= vkPhysicalDeviceVulkan12Properties_.
        maxDescriptorSetUpdateAfterBindSampledImages))
    LLOGW(“Max Textures exceeded: %u (max %u)”, maxTextures,
        vkPhysicalDeviceVulkan12Properties_.
          maxDescriptorSetUpdateAfterBindSampledImages);
  if (!LVK_VERIFY(maxSamplers &lt;= vkPhysicalDeviceVulkan12Properties_.
        maxDescriptorSetUpdateAfterBindSamplers))
    LLOGW(“Max Samplers exceeded %u (max %u)”, maxSamplers,
        vkPhysicalDeviceVulkan12Properties_.
          maxDescriptorSetUpdateAfterBindSamplers);</code></pre>
</div>
<ol>
<li>Deallocate previous Vulkan resources if they exist.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  if (vkDSL_ != VK_NULL_HANDLE) {
    deferredTask(std::packaged_task&lt;void()&gt;(
      [device = vkDevice_, dsl = vkDSL_]() {
        vkDestroyDescriptorSetLayout(device, dsl, nullptr); })); }
  if (vkDPool_ != VK_NULL_HANDLE) {
    deferredTask(std::packaged_task&lt;void()&gt;(
      [device = vkDevice_, dp = vkDPool_]() {
        vkDestroyDescriptorPool(device, dp, nullptr); })); }
  if (vkPipelineLayout_ != VK_NULL_HANDLE) {
    deferredTask(std::packaged_task&lt;void()&gt;(
      [device = vkDevice_, layout = vkPipelineLayout_]() {
        vkDestroyPipelineLayout(device, layout, nullptr); })); }</code></pre>
</div>
<ol>
<li>Create a new descriptor set layout, which is going to be shared by all Vulkan pipelines. It should contain all Vulkan resources <em>LightweightVK</em> supports – sampled images, samplers, and storage images.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  const VkDescriptorSetLayoutBinding bindings[kBinding_NumBindings] ={
    getDSLBinding(kBinding_Textures,
      VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, maxTextures),
    getDSLBinding(kBinding_Samplers,
      VK_DESCRIPTOR_TYPE_SAMPLER, maxSamplers),
    getDSLBinding(kBinding_StorageImages,
      VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, maxTextures),
  };</code></pre>
</div>
<ol>
<li>The descriptor indexing feature allows descriptor sets to be updated after they were bound.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  const uint32_t flags = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT |
               VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT |
                           VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT;
  VkDescriptorBindingFlags bindingFlags[kBinding_NumBindings];
  for (int i = 0; i &lt; kBinding_NumBindings; ++i)
    bindingFlags[i] = flags;</code></pre>
</div>
<ol>
<li>A chain of Vulkan <code>Vk…CreateInfo</code> structures should be prepared to create a desired <code>VkDesciptorSetLayout</code> object.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  const VkDescriptorSetLayoutBindingFlagsCreateInfo bindingFlagsci = {
      .sType =  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT,
      .bindingCount = kBinding_NumBindings,
      .pBindingFlags = bindingFlags,
  };
  const VkDescriptorSetLayoutCreateInfo dslci = {
      .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
      .pNext = &amp;bindingFlagsci,
      .flags =
       VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT,
      .bindingCount = kBinding_NumBindings,
      .pBindings = bindings,
  };
  vkCreateDescriptorSetLayout(vkDevice_, &amp;dslci, nullptr, &amp;vkDSL_);</code></pre>
</div>
<ol>
<li>Using this newly created descriptor set layout, we can create a new descriptor pool. Note the flag <code>VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT</code>, which is required to support the corresponding flag for the descriptor set layout <code>VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT</code>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  const VkDescriptorPoolSize poolSizes[kBinding_NumBindings] = {
    VkDescriptorPoolSize{
      VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, maxTextures},
    VkDescriptorPoolSize{
      VK_DESCRIPTOR_TYPE_SAMPLER, maxSamplers},
    VkDescriptorPoolSize{
      VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, maxTextures},
  };
  const VkDescriptorPoolCreateInfo ci = {
    .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
    .flags = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,
    .maxSets = 1,
    .poolSizeCount = kBinding_NumBindings,
    .pPoolSizes = poolSizes,
  };
  vkCreateDescriptorPool(vkDevice_, &amp;ci, nullptr, &amp;vkDPool_);</code></pre>
</div>
<ol>
<li>Now we can allocate one descriptor set from the descriptor pool <code>vkDPool_</code>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  const VkDescriptorSetAllocateInfo ai = {
    .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
    .descriptorPool = vkDPool_,
    .descriptorSetCount = 1,
    .pSetLayouts = &amp;vkDSL_,
  };
  vkAllocateDescriptorSets(vkDevice_, &amp;ai, &amp;vkDSet_);</code></pre>
</div>
<ol>
<li>To create Vulkan pipelines, we need a pipeline layout. The pipeline layout in <em>LightweightVK</em> is shared between all pipelines. In Vulkan 1.3, it would be sufficient to use a single descriptor set layout <code>vkDSL_</code> to create the pipeline layout. However, <em>LightweightVK</em> supports running on Mac using MoltenVK and <em>Metal Shading Language</em> cannot support aliasing of descriptor sets in shaders. Hence, we do the duplication here to prevent aliasing and keep compatibility with MoltenVK. We set the size of push constants to <code>128</code> bytes, which is the maximal guaranteed size by the Vulkan specification.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  const VkDescriptorSetLayout dsls[] = {vkDSL_, vkDSL_, vkDSL_};
  const VkPushConstantRange range = {
    .stageFlags = VK_SHADER_STAGE_VERTEX_BIT |
                  VK_SHADER_STAGE_FRAGMENT_BIT |
                  VK_SHADER_STAGE_COMPUTE_BIT,
    .offset = 0,
    .size = 128,
  };
  const VkPipelineLayoutCreateInfo ci = {
    .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
    .setLayoutCount = (uint32_t)LVK_ARRAY_NUM_ELEMENTS(dsls),
    .pSetLayouts = dsls,
    .pushConstantRangeCount = 1,
    .pPushConstantRanges = &amp;range,
  };
  vkCreatePipelineLayout(
    vkDevice_, &amp;ci, nullptr, &amp;vkPipelineLayout_);
  return Result();
}</code></pre>
</div>
<p>The <code>growDescriptorPool()</code> function was the first part of our descriptor set management mechanism. We have a descriptor set and we have to update it. Updating is done in another function, <code>checkAndUpdateDescriptorSets()</code>, which is called before we can dispatch Vulkan draw calls. Some parts of error checking have been left out once again:</p>
<ol>
<li>Newly created resources can be used immediately – make sure they are put into descriptor sets. We discussed the texture creation process earlier in the recipe <em>Using texture data in Vulkan</em>. Once a new texture is created, the flag <code>awaitingCreation_</code> is set to signal that we need to update the descriptor set. If there are no new textures or samplers, no descriptor set updates are required.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>void VulkanContext::checkAndUpdateDescriptorSets() {
  if (!awaitingCreation_) return;</code></pre>
</div>
<ol>
<li>As we learned from the previous recipe, <em>Storing Vulkan objects</em>, textures and samplers are stored in pools within <code>VulkanContext</code>. Here we grow the descriptor pool as needed to accommodate all those textures and samplers.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  uint32_t newMaxTextures = currentMaxTextures_;
  uint32_t newMaxSamplers = currentMaxSamplers_;
  while (texturesPool_.objects_.size() &gt; newMaxTextures)
    newMaxTextures *= 2;
  while (samplersPool_.objects_.size() &gt; newMaxSamplers)
    newMaxSamplers *= 2;
  if (newMaxTextures != currentMaxTextures_ ||
      newMaxSamplers != currentMaxSamplers_) {
    growDescriptorPool(newMaxTextures, newMaxSamplers);
  }</code></pre>
</div>
<ol>
<li>Let’s prepare Vulkan structures to update the descriptor set with sampled and storage images. <em>LightweightVK</em> always stores a dummy texture at the index <code>0</code> to avoid sparse arrays in GLSL shaders and enable all shaders to safely sample non-existing textures.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  std::vector&lt;VkDescriptorImageInfo&gt; infoSampledImages;
  std::vector&lt;VkDescriptorImageInfo&gt; infoStorageImages;
  infoSampledImages.reserve(texturesPool_.numObjects());
  infoStorageImages.reserve(texturesPool_.numObjects());
  VkImageView dummyImageView =
    texturesPool_.objects_[0].obj_.imageView_;</code></pre>
</div>
<ol>
<li>Iterate over the pool of textures and fill in the <code>VkDescriptorImageInfo</code> structures according to the image properties. Multisampled images can be accessed from shaders only using <code>texelFetch()</code>. This is not supported by <em>LightweightVK</em>, so we will skip this here.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  for (const auto&amp; obj : texturesPool_.objects_) {
    const VulkanTexture&amp; texture = obj.obj_;
    const bool isTextureAvailable = texture.image_ &amp;&amp;
      ((texture.image_-&gt;vkSamples_ &amp; VK_SAMPLE_COUNT_1_BIT) ==
        VK_SAMPLE_COUNT_1_BIT);
    const bool isSampledImage = isTextureAvailable &amp;&amp;
      texture.image_-&gt;isSampledImage();
    const bool isStorageImage = isTextureAvailable &amp;&amp; 
      texture.image_-&gt;isStorageImage();</code></pre>
</div>
<ol>
<li>Images are expected to be in specific image layouts. Sampled images should use <code>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL</code>, while storage images should use <code>VK_IMAGE_LAYOUT_GENERAL</code>. <em>LightweightVK</em> ensures proper image layout conversions automatically. We will talk about it in subsequent chapters.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>    infoSampledImages.push_back({
      VK_NULL_HANDLE,
      isSampledImage ? texture.imageView_ : dummyImageView,
      VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL});
    infoStorageImages.push_back({
      VK_NULL_HANDLE,
      isStorageImage ? texture.imageView_ : dummyImageView,
      VK_IMAGE_LAYOUT_GENERAL});
  }</code></pre>
</div>
<ol>
<li>Samplers are handled in a very similar way.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  std::vector&lt;VkDescriptorImageInfo&gt; infoSamplers;
  infoSamplers.reserve(samplersPool_.objects_.size());
  for (const auto&amp; sampler : samplersPool_.objects_) {
    infoSamplers.push_back({
      sampler.obj_ ? sampler.obj_ : samplersPool_.objects_[0].obj_,
      VK_NULL_HANDLE,
      VK_IMAGE_LAYOUT_UNDEFINED});
  }</code></pre>
</div>
<ol>
<li>The structure <code>VkWriteDescriptorSet</code> specifies parameters of a descriptor set write operation. We need to fill in one structure per each of our <code>3</code> bindings that correspond to <code>3</code> different descriptor types: <code>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE</code>, <code>VK_DESCRIPTOR_TYPE_SAMPLER</code>, and <code>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE</code>. This code snippet is straightforward but somewhat lengthy. We include it here in its entirety for your reference.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  VkWriteDescriptorSet write[kBinding_NumBindings] = {};
  uint32_t numWrites = 0;
  if (!infoSampledImages.empty())
    write[numWrites++] = VkWriteDescriptorSet{
      .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
      .dstSet = vkDSet_,
      .dstBinding = kBinding_Textures,
      .dstArrayElement = 0,
      .descriptorCount = (uint32_t)infoSampledImages.size(),
      .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
      .pImageInfo = infoSampledImages.data(),
    };
  if (!infoSamplers.empty())
    write[numWrites++] = VkWriteDescriptorSet{
      .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
      .dstSet = vkDSet_,
      .dstBinding = kBinding_Samplers,
      .dstArrayElement = 0,
      .descriptorCount = (uint32_t)infoSamplers.size(),
      .descriptorType = VK_DESCRIPTOR_TYPE_SAMPLER,
      .pImageInfo = infoSamplers.data(),
    };
  if (!infoStorageImages.empty())
    write[numWrites++] = VkWriteDescriptorSet{
      .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
      .dstSet = vkDSet_,
      .dstBinding = kBinding_StorageImages,
      .dstArrayElement = 0,
      .descriptorCount = (uint32_t)infoStorageImages.size(),
      .descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
      .pImageInfo = infoStorageImages.data(),
    };</code></pre>
</div>
<ol>
<li>If we have filled in any <code>VkWriteDescriptorSet</code> structures, invoke the Vulkan function <code>vkUpdateDescriptorSets()</code> to update the descriptor set. Since we are updating the entire descriptor set, it is essential to ensure that Vulkan is not using it by calling <code>wait()</code> with the last known submit handle. This mechanism was discussed in the previous chapter in the recipe <em>Using Vulkan command buffers</em>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>  if (numWrites) {
    immediate_-&gt;wait(std::exchange(
      lastSubmitHandle, immediate_-&gt;getLastSubmitHandle()));
    vkUpdateDescriptorSets(vkDevice_, numWrites, write, 0, nullptr);
  }
  awaitingCreation_ = false;
}</code></pre>
</div>
<p>The C++ part of the descriptor set updating process is concluded. The only remaining part now is how to access these descriptor sets from GLSL shaders. Let’s learn how it works.</p>
</section>
<section class="level3" data-number="4.7.2" id="how-it-works-5">
<h3 data-number="4.7.2">How it works…</h3>
<p><code>VulkanContext</code> injects some helper code into GLSL shaders to simplify the workflow with our bindless descriptor sets. Let’s recall the function <code>VulkanContext::createShaderModule()</code>, which does the injection. Here’s the GLSL code that automatically inserts into every fragment shader:</p>
<ol>
<li>First, it declares some unbound arrays that are stored in our bindless descriptor set. Here, you’ll notice that the descriptor set ID ranges from <code>0</code> to <code>2</code>. However, don’t be misled by this; it is the same descriptor set bound to three different locations. As demonstrated earlier in this recipe, this is necessary to ensure compatibility with <em>MoltenVK</em>.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>layout (set = 0, binding = 0) uniform texture2D kTextures2D[];
layout (set = 1, binding = 0) uniform texture3D kTextures3D[];
layout (set = 2, binding = 0) uniform textureCube kTexturesCube[];
layout (set = 0, binding = 1) uniform sampler kSamplers[];
layout (set = 1, binding = 1) uniform samplerShadow kSamplersShadow[];</code></pre>
</div>
<ol>
<li>Then, some helper functions are added. These functions correspond to the standard GLSL functions, such as <code>texture()</code>, <code>textureLod()</code>, and others. These functions streamline the process of working with descriptor indexing. We list here only some of them so you can get the overall picture.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>vec4 textureBindless2D(uint textureid, uint samplerid, vec2 uv) {
  return texture(sampler2D(kTextures2D[textureid],
                           kSamplers[samplerid]), uv);
}
vec4 textureBindless2DLod(
  uint textureid, uint samplerid, vec2 uv, float lod) {
  return textureLod(sampler2D(kTextures2D[textureid],
                              kSamplers[samplerid]), uv, lod);
}
float textureBindless2DShadow(
  uint textureid, uint samplerid, vec3 uvw) {
  return texture(sampler2DShadow(kTextures2D[textureid],
                                 kSamplersShadow[samplerid]), uvw);
}
ivec2 textureBindlessSize2D(uint textureid) {
  return textureSize(kTextures2D[textureid], 0);
}</code></pre>
</div>
<ol>
<li>With this, our GLSL fragment shader <code>Chapter03/02_STB/main.frag</code> can be rewritten as follows without any manual declarations of the lengthy data structures.</li>
</ol>
<div class="C1-SHCodePACKT">
<pre><code>layout (location=0) in vec2 uv;
layout (location=0) out vec4 out_FragColor;
layout(push_constant) uniform PerFrameData {
  uniform mat4 MVP;
  uint textureId;
};
void main() {
  out_FragColor = textureBindless2D(textureId, 0, uv);
};</code></pre>
</div>
<p>With the bindless descriptor set code in place, we can render textured objects such as the one in the following image.</p>
<figure>
<img alt="Figure 3.4: Rendering a textured quad" height="756" src="../media/img_chapter03_image5.png" width="1430"/><figcaption aria-hidden="true">Figure 3.4: Rendering a textured quad</figcaption>
</figure>
</section>
<section class="level3" data-number="4.7.3" id="theres-more-4">
<h3 data-number="4.7.3">There’s more…</h3>
<p>The topic of efficient resource management in Vulkan is vast and complicated. We will return to descriptor set management later when we discuss 3D scene data management and the rendering of complex multitextured materials.</p>
</section>
</section>
</section>
</div></body>
</html>