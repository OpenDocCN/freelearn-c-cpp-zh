["```cpp\n#define TIXML_USE_STL\n```", "```cpp\n<?xml version=\"1.0\" ?>\n<ROOT>\n    <ELEMENT>\n    </ELEMENT>\n</ROOT>\n```", "```cpp\n<?xml version=\"1.0\" ?>\n<ROOT>\n    <ELEMENTS>\n        <ELEMENT>Hello,</ELEMENT>\n        <ELEMENT> World!</ELEMENT>\n    </ELEMENTS>\n</ROOT>\n```", "```cpp\n<ROOT>\n    <ELEMENTS>\n        <ELEMENT text=\"Hello,\"/>\n        <ELEMENT text=\" World!\"/>\n    </ELEMENTS>\n</ROOT>\n```", "```cpp\n<?xml version=\"1.0\" ?>\n<STATES>\n\n<!--The Menu State-->\n<MENU>\n<TEXTURES>\n  <texture filename=\"button.png\" ID=\"playbutton\"/>\n  <texture filename=\"exit.png\" ID=\"exitbutton\"/>\n</TEXTURES>\n\n<OBJECTS>\n  <object type=\"MenuButton\" x=\"100\" y=\"100\" width=\"400\" \n  height=\"100\" textureID=\"playbutton\"/>\n  <object type=\"MenuButton\" x=\"100\" y=\"300\" width=\"400\" \n  height=\"100\" textureID=\"exitbutton\"/>\n</OBJECTS>\n</MENU>\n\n<!--The Play State-->\n<PLAY>\n</PLAY>\n\n<!-- The Game Over State -->\n<GAMEOVER>\n</GAMEOVER>\n</STATES>\n```", "```cpp\nGameObject* GameObjectFactory::createGameObject(ID id)\n{\n  switch(id)\n  {\n    case \"PLAYER\":\n      return new Player();\n    break;\n\n    case \"ENEMY\":\n      return new Enemy();\n    break;\n\n    // lots more object types \n  }\n}\n```", "```cpp\n#include <string>\n#include <map>\n#include \"GameObject.h\"\n\nclass BaseCreator\n{\n  public:\n\n  virtual GameObject* createGameObject() const = 0;\n  virtual ~BaseCreator() {}\n};\n```", "```cpp\nclass GameObjectFactory\n{\n  public:\n\n  bool registerType(std::string typeID, BaseCreator* pCreator)\n  {\n    std::map<std::string, BaseCreator*>::iterator it = \n    m_creators.find(typeID);\n\n    // if the type is already registered, do nothing\n    if(it != m_creators.end())\n    {\n      delete pCreator;\n      return false;\n    }\n\n    m_creators[typeID] = pCreator;\n\n    return true;\n  }\n\n  GameObject* create(std::string typeID)\n  {\n    std::map<std::string, BaseCreator*>::iterator it = \n    m_creators.find(typeID);\n\n    if(it == m_creators.end())\n    {\n      std::cout << \"could not find type: \" << typeID << \"\\n\";\n      return NULL;\n    }\n\n    BaseCreator* pCreator = (*it).second;\n    return pCreator->createGameObject();\n  }\n\n  private:\n\n  std::map<std::string, BaseCreator*> m_creators;\n\n};\n```", "```cpp\nstd::map<std::string, BaseCreator*> m_creators;\n```", "```cpp\nbool registerType(std::string typeID, BaseCreator* pCreator)\n```", "```cpp\nstd::map<std::string, BaseCreator*>::iterator it = m_creators.find(typeID);\n```", "```cpp\nif(it != m_creators.end())\n{\n  delete pCreator;\n  return false;\n}\n```", "```cpp\nm_creators[typeID] = pCreator;\nreturn true;\n}\n```", "```cpp\nGameObject* create(std::string typeID)\n{\n  std::map<std::string, BaseCreator*>::iterator it = \n  m_creators.find(typeID);\n\n  if(it == m_creators.end())\n  {\n    std::cout << \"could not find type: \" << typeID << \"\\n\";\n    return 0;\n  }\n\n  BaseCreator* pCreator = (*it).second;\n  return pCreator->createGameObject();\n}\n```", "```cpp\nclass PlayerCreator : public BaseCreator\n{\n  GameObject* createGameObject() const\n  {\n    return new Player();\n  }\n};\n```", "```cpp\nclass GameObject\n{\n  public:\n\n  virtual void draw()=0;\n  virtual void update()=0;\n  virtual void clean()=0;\n\n  // new load function \n  virtual void load(const LoaderParams* pParams)=0;\n\n  protected:\n\n  GameObject() {}\n  virtual ~GameObject() {}\n};\n```", "```cpp\nSDLGameObject::SDLGameObject() : GameObject()\n{\n}\n\nvoidSDLGameObject::load(const LoaderParams *pParams)\n{\n  m_position = Vector2D(pParams->getX(),pParams->getY());\n  m_velocity = Vector2D(0,0);\n  m_acceleration = Vector2D(0,0);\n  m_width = pParams->getWidth();\n  m_height = pParams->getHeight();\n  m_textureID = pParams->getTextureID();\n  m_currentRow = 1;\n  m_currentFrame = 1;\n  m_numFrames = pParams->getNumFrames();\n}\n```", "```cpp\nPlayer::Player() : SDLGameObject()\n{\n\n}\n\nvoid Player::load(const LoaderParams *pParams)\n{\n  SDLGameObject::load(pParams);\n}\n```", "```cpp\nLoaderParams(int x, int y, int width, int height, std::string textureID, int numFrames, int callbackID = 0, int animSpeed = 0) :\nm_x(x),\nm_y(y),\nm_width(width),\nm_height(height),\nm_textureID(textureID),\nm_numFrames(numFrames),\nm_callbackID(callbackID),\nm_animSpeed(animSpeed)\n{\n\n}\n```", "```cpp\n<?xml version=\"1.0\" ?>\n<STATES>\n<MENU>\n<TEXTURES>\n  <texture filename=\"assets/button.png\" ID=\"playbutton\"/>\n  <texture filename=\"assets/exit.png\" ID=\"exitbutton\"/>\n</TEXTURES>\n\n<OBJECTS>\n  <object type=\"MenuButton\" x=\"100\" y=\"100\" width=\"400\" \n  height=\"100\" textureID=\"playbutton\" numFrames=\"0\" \n  callbackID=\"1\"/>\n  <object type=\"MenuButton\" x=\"100\" y=\"300\" width=\"400\" \n  height=\"100\" textureID=\"exitbutton\" numFrames=\"0\" \n  callbackID=\"2\"/>\n</OBJECTS>\n</MENU>\n<PLAY>\n</PLAY>\n\n<GAMEOVER>\n</GAMEOVER>\n</STATES>\n```", "```cpp\n#include <iostream>\n#include <vector>\n#include \"tinyxml.h\"\n\nclass GameObject;\n\nclass StateParser\n{\n  public:\n\n  bool parseState(const char* stateFile, std::string stateID, \n  std::vector<GameObject*> *pObjects);\n\n  private:\n\n  void parseObjects(TiXmlElement* pStateRoot, \n  std::vector<GameObject*> *pObjects);\n  void parseTextures(TiXmlElement* pStateRoot, \n  std::vector<std::string> *pTextureIDs);\n\n};\n```", "```cpp\nbool StateParser::parseState(const char *stateFile, string \nstateID, vector<GameObject *> *pObjects, std::vector<std::string> \n*pTextureIDs)\n{\n  // create the XML document\n  TiXmlDocument xmlDoc;\n\n  // load the state file\n  if(!xmlDoc.LoadFile(stateFile))\n  {\n    cerr << xmlDoc.ErrorDesc() << \"\\n\";\n    return false;\n  }\n\n  // get the root element\n  TiXmlElement* pRoot = xmlDoc.RootElement();\n\n  // pre declare the states root node\n  TiXmlElement* pStateRoot = 0;\n  // get this states root node and assign it to pStateRoot\n  for(TiXmlElement* e = pRoot->FirstChildElement(); e != NULL; e = \n  e->NextSiblingElement())\n  {\n    if(e->Value() == stateID)\n    {\n      pStateRoot = e;\n    }\n  }\n\n  // pre declare the texture root\n  TiXmlElement* pTextureRoot = 0;\n\n  // get the root of the texture elements\n  for(TiXmlElement* e = pStateRoot->FirstChildElement(); e != \n  NULL; e = e->NextSiblingElement())\n  {\n    if(e->Value() == string(\"TEXTURES\"))\n    {\n      pTextureRoot = e;\n    }\n  }\n\n  // now parse the textures\n  parseTextures(pTextureRoot, pTextureIDs);\n\n  // pre declare the object root node\n  TiXmlElement* pObjectRoot = 0;\n\n  // get the root node and assign it to pObjectRoot\n  for(TiXmlElement* e = pStateRoot->FirstChildElement(); e != \n  NULL; e = e->NextSiblingElement())\n  {\n    if(e->Value() == string(\"OBJECTS\"))\n    {\n      pObjectRoot = e;\n    }\n  }\n\n  // now parse the objects\n  parseObjects(pObjectRoot, pObjects);\n\n  return true;\n}\n```", "```cpp\n// create the XML document\nTiXmlDocument xmlDoc;\n\n// load the state file\nif(!xmlDoc.LoadFile(stateFile))\n{\n  cerr << xmlDoc.ErrorDesc() << \"\\n\";\n  return false;\n}\n```", "```cpp\n// get the root element\nTiXmlElement* pRoot = xmlDoc.RootElement(); // <STATES>\n```", "```cpp\n// declare the states root node\nTiXmlElement* pStateRoot = 0;\n// get this states root node and assign it to pStateRoot\nfor(TiXmlElement* e = pRoot->FirstChildElement(); e != NULL; e = e->NextSiblingElement())\n{\n  if(e->Value() == stateID)\n  {\n    pStateRoot = e;\n  }\n}\n```", "```cpp\n<MENU> // the states root node\n```", "```cpp\n// pre declare the texture root\nTiXmlElement* pTextureRoot = 0;\n\n// get the root of the texture elements\nfor(TiXmlElement* e = pStateRoot->FirstChildElement(); e != NULL;\ne = e->NextSiblingElement())\n{\n  if(e->Value() == string(\"TEXTURES\"))\n  {\n    pTextureRoot = e;\n  }\n}\n```", "```cpp\nparseTextures(pTextureRoot, std::vector<std::string> *pTextureIDs);\n```", "```cpp\n  // pre declare the object root node\n  TiXmlElement* pObjectRoot = 0;\n\n  // get the root node and assign it to pObjectRoot\n  for(TiXmlElement* e = pStateRoot->FirstChildElement(); e != NULL; e = e->NextSiblingElement())\n  {\n    if(e->Value() == string(\"OBJECTS\"))\n    {\n      pObjectRoot = e;\n    }\n  }\n  parseObjects(pObjectRoot, pObjects);\n  return true;\n}\n```", "```cpp\nvoid StateParser::parseTextures(TiXmlElement* pStateRoot, std::vector<std::string> *pTextureIDs)\n{\n  for(TiXmlElement* e = pStateRoot->FirstChildElement(); e != \n  NULL; e = e->NextSiblingElement())\n  {\n    string filenameAttribute = e->Attribute(\"filename\");\n    string idAttribute = e->Attribute(\"ID\");\n    pTextureIDs->push_back(idAttribute); // push into list\n\n    TheTextureManager::Instance()->load(filenameAttribute, \n    idAttribute, TheGame::Instance()->getRenderer());\n  }\n}\n```", "```cpp\n<TEXTURES>\n  <texture filename=\"button.png\" ID=\"playbutton\"/>\n  <texture filename=\"exit.png\" ID=\"exitbutton\"/>\n</TEXTURES>\n```", "```cpp\nTheTextureManager::Instance()->load(filenameAttribute, idAttribute, TheGame::Instance()->getRenderer());\n```", "```cpp\n<OBJECTS>\n  <object type=\"MenuButton\" x=\"100\" y=\"100\" width=\"400\" \n  height=\"100\" textureID=\"playbutton\" numFrames=\"0\" \n  callbackID=\"1\"/>\n  <object type=\"MenuButton\" x=\"100\" y=\"300\" width=\"400\" \n  height=\"100\" textureID=\"exitbutton\" numFrames=\"0\" \n  callbackID=\"2\"/>\n</OBJECTS>\n```", "```cpp\nvoid StateParser::parseObjects(TiXmlElement *pStateRoot, \nstd::vector<GameObject *> *pObjects)\n{\n  for(TiXmlElement* e = pStateRoot->FirstChildElement(); e != \n  NULL; e = e->NextSiblingElement())\n  {\n    int x, y, width, height, numFrames, callbackID, animSpeed;\n    string textureID;\n\n    e->Attribute(\"x\", &x);\n    e->Attribute(\"y\", &y);\n    e->Attribute(\"width\",&width);\n    e->Attribute(\"height\", &height);\n    e->Attribute(\"numFrames\", &numFrames);\n    e->Attribute(\"callbackID\", &callbackID);\n    e->Attribute(\"animSpeed\", &animSpeed);\n\n    textureID = e->Attribute(\"textureID\");\n\n    GameObject* pGameObject = TheGameObjectFactory::Instance()\n    ->create(e->Attribute(\"type\"));\n    pGameObject->load(new LoaderParams\n    (x,y,width,height,textureID,numFrames,callbackID, animSpeed));\n    pObjects->push_back(pGameObject);\n  }\n}\n```", "```cpp\ne->Attribute(\"x\", &x);\n```", "```cpp\nGameObject* pGameObject = TheGameObjectFactory::Instance()->create(e->Attribute(\"type\"));\n```", "```cpp\npGameObject->load(new LoaderParams(x,y,width,height,textureID,numFrames,callbackID));\n```", "```cpp\npObjects->push_back(pGameObject);\n```", "```cpp\nvoid MenuButton::load(const LoaderParams *pParams)\n{\n  SDLGameObject::load(pParams);\n  m_callbackID = pParams->getCallbackID();\n  m_currentFrame = MOUSE_OUT;\n}\n```", "```cpp\nvoid setCallback(void(*callback)()) { m_callback = callback;}\nint getCallbackID() { return m_callbackID; }\n```", "```cpp\nclass MenuState : public GameState\n{\n  protected:\n\n  typedef void(*Callback)();\n  virtual void setCallbacks(const std::vector<Callback>& callbacks) \n  = 0;\n\n  std::vector<Callback> m_callbacks;\n};\n```", "```cpp\n#include \"MenuState.h\"\n#include \"GameObject.h\"\n\nclass MainMenuState : public MenuState\n{\n  public:\n\n  virtual void update();\n  virtual void render();\n\n  virtual bool onEnter(); \n  virtual bool onExit(); \n\n  virtual std::string getStateID() const { return s_menuID; }\n\n  private:\n\n  virtual void setCallbacks(const std::vector<Callback>& \n  callbacks);\n\n  // call back functions for menu items\n  static void s_menuToPlay();\n  static void s_exitFromMenu();\n\n  static const std::string s_menuID;\n\n  std::vector<GameObject*> m_gameObjects;\n};\n```", "```cpp\nbool MainMenuState::onEnter()\n{\n  // parse the state\n  StateParser stateParser;\n  stateParser.parseState(\"test.xml\", s_menuID, &m_gameObjects, \n  &m_textureIDList);\n\n  m_callbacks.push_back(0); //pushback 0 callbackID start from 1\n  m_callbacks.push_back(s_menuToPlay);\n  m_callbacks.push_back(s_exitFromMenu);\n\n  // set the callbacks for menu items\n  setCallbacks(m_callbacks);\n\n  std::cout << \"entering MenuState\\n\";\n  return true;\n}\n```", "```cpp\nvoid MainMenuState::setCallbacks(const std::vector<Callback>& \ncallbacks)\n{\n  // go through the game objects\n  for(int i = 0; i < m_gameObjects.size(); i++)\n  {\n    // if they are of type MenuButton then assign a callback \n    based on the id passed in from the file\n    if(dynamic_cast<MenuButton*>(m_gameObjects[i]))\n    {\n      MenuButton* pButton = \n      dynamic_cast<MenuButton*>(m_gameObjects[i]);\n      pButton->setCallback(callbacks[pButton->getCallbackID()]);\n    }\n  }\n}\n```", "```cpp\nprotected:\nstd::vector<std::string> m_textureIDList;\n```", "```cpp\n// clear the texture manager\nfor(int i = 0; i < m_textureIDList.size(); i++)\n{\n  TheTextureManager::Instance()->\n  clearFromTextureMap(m_textureIDList[i]);\n}\n```", "```cpp\nTheGameObjectFactory::Instance()->registerType(\"MenuButton\", new MenuButtonCreator());\n```", "```cpp\nbool PlayState::onEnter()\n{\n  // parse the state\n  StateParser stateParser;\n  stateParser.parseState(\"test.xml\", s_playID, &m_gameObjects, \n  &m_textureIDList);\n\n  std::cout << \"entering PlayState\\n\";\n  return true;\n}\n```", "```cpp\n// clear the texture manager\nfor(int i = 0; i < m_textureIDList.size(); i++)\n{\n  TheTextureManager::Instance()->\n  clearFromTextureMap(m_textureIDList[i]);\n}\n```", "```cpp\n<PLAY>\n<TEXTURES>\n  <texture filename=\"helicopter.png\" ID=\"helicopter\"/>\n  <texture filename=\"helicopter2.png\" ID=\"helicopter2\"/>\n</TEXTURES>\n\n<OBJECTS>\n  <object type=\"Player\" x=\"500\" y=\"100\" width=\"128\" height=\"55\" \n  textureID=\"helicopter\" numFrames=\"4\"/>\n  <object type=\"Enemy\" x=\"100\" y=\"100\" width=\"128\" height=\"55\" \n  textureID=\"helicopter2\" numFrames=\"4\"/>\n</OBJECTS>\n</PLAY>\n```", "```cpp\nvoid Enemy::load(const LoaderParams *pParams)\n{\n  SDLGameObject::load(pParams);\n  m_velocity.setY(2);\n}\n```", "```cpp\nTheGameObjectFactory::Instance()->registerType(\"Player\", new PlayerCreator());\nTheGameObjectFactory::Instance()->registerType(\"Enemy\", new EnemyCreator());\n```", "```cpp\nclass PauseState : public MenuState\n```", "```cpp\nvirtual void setCallbacks(const std::vector<Callback>& callbacks);\n```", "```cpp\nbool PauseState::onEnter()\n{\n  StateParser stateParser;\n  stateParser.parseState(\"test.xml\", s_pauseID, &m_gameObjects, \n  &m_textureIDList);\n\n  m_callbacks.push_back(0);\n  m_callbacks.push_back(s_pauseToMain);\n  m_callbacks.push_back(s_resumePlay);\n\n  setCallbacks(m_callbacks);\n\n  std::cout << \"entering PauseState\\n\";\n  return true;\n}\n```", "```cpp\nvoid PauseState::setCallbacks(const std::vector<Callback>& \ncallbacks)\n{\n  // go through the game objects\n  for(int i = 0; i < m_gameObjects.size(); i++)\n  {\n    // if they are of type MenuButton then assign a callback based \n    on the id passed in from the file\n    if(dynamic_cast<MenuButton*>(m_gameObjects[i]))\n    {\n      MenuButton* pButton = \n      dynamic_cast<MenuButton*>(m_gameObjects[i]);\n      pButton->setCallback(callbacks[pButton->getCallbackID()]);\n    }\n  }\n}\n```", "```cpp\n// clear the texture manager\nfor(int i = 0; i < m_textureIDList.size(); i++)\n{\n  TheTextureManager::Instance()->\n  clearFromTextureMap(m_textureIDList[i]);\n}\n```", "```cpp\n<PAUSE>\n<TEXTURES>\n  <texture filename=\"resume.png\" ID=\"resumebutton\"/>\n  <texture filename=\"main.png\" ID=\"mainbutton\"/>\n</TEXTURES>\n\n<OBJECTS>\n  <object type=\"MenuButton\" x=\"200\" y=\"100\" width=\"200\" \n  height=\"80\" textureID=\"mainbutton\" numFrames=\"0\" \n  callbackID=\"1\"/>\n  <object type=\"MenuButton\" x=\"200\" y=\"300\" width=\"200\" \n  height=\"80\" textureID=\"resumebutton\" numFrames=\"0\" \n  callbackID=\"2\"/>\n</OBJECTS>\n</PAUSE>\n```", "```cpp\nclass GameOverState : public MenuState\n```", "```cpp\nvirtual void setCallbacks(const std::vector<Callback>& callbacks);\n```", "```cpp\nbool GameOverState::onEnter()\n{\n  // parse the state\n  StateParser stateParser;\n  stateParser.parseState(\"test.xml\", s_gameOverID, &m_gameObjects, \n  &m_textureIDList);\n  m_callbacks.push_back(0);\n  m_callbacks.push_back(s_gameOverToMain);\n  m_callbacks.push_back(s_restartPlay);\n\n  // set the callbacks for menu items\n  setCallbacks(m_callbacks);\n\n  std::cout << \"entering PauseState\\n\";\n  return true;\n}\n```", "```cpp\nvoid AnimatedGraphic::load(const LoaderParams *pParams)\n{\n  SDLGameObject::load(pParams);\n  m_animSpeed = pParams->getAnimSpeed();\n}\n```", "```cpp\nTheGameObjectFactory::Instance()->registerType(\"AnimatedGraphic\", new AnimatedGraphicCreator());\n```", "```cpp\n<GAMEOVER>\n<TEXTURES>\n  <texture filename=\"gameover.png\" ID=\"gameovertext\"/>\n  <texture filename=\"main.png\" ID=\"mainbutton\"/>\n  <texture filename=\"restart.png\" ID=\"restartbutton\"/>\n</TEXTURES>\n\n<OBJECTS>\n  <object type=\"AnimatedGraphic\" x=\"200\" y=\"100\" width=\"190\" \n  height=\"30\" textureID=\"gameovertext\" numFrames=\"2\" \n  animSpeed=\"2\"/>\n  <object type=\"MenuButton\" x=\"200\" y=\"200\" width=\"200\" \n  height=\"80\" textureID=\"mainbutton\" numFrames=\"0\" \n  callbackID=\"1\"/>\n  <object type=\"MenuButton\" x=\"200\" y=\"300\" width=\"200\" \n  height=\"80\" textureID=\"restartbutton\" numFrames=\"0\" \n  callbackID=\"2\"/>\n</OBJECTS>\n</GAMEOVER>\n```"]