<html><head></head><body>
        

                            
                    <h1 class="header-title">AI for Controlling NPCs</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Implementing a simple following behavior</li>
<li>Laying down a Navigation Mesh</li>
<li>Creating a Blackboard</li>
<li>Creating a Behavior Tree</li>
<li>Connecting a Behavior Tree to a Character</li>
<li>Creating a BTService</li>
<li>Creating a BTTask</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p class="chapter-content">AI includes many aspects of a game's NPC, as well as player behavior. The general topic of AI includes pathfinding and NPC behavior. Generally, we term the selection of what the NPC does for a period of time within the game as behavior.</p>
<p>AI in UE4 is well supported. A number of constructs exist to allow basic AI programming from within the editor, but we will be focusing on using C++ to program elements while touching on engine aspects when needed.</p>
<p>To make it easier to visualize our AI character and the interactions with the player, in this chapter, I will be using the C++ Third Person template:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0293a11c-8c73-4598-b464-097efdc453a5.png"/></p>
<p>While I would love to cover all aspects of working with AI in Unreal Engine 4, that could take a whole book of its own. If you are interested in exploring AI even more after reading this chapter, I suggest that you check out <em>Unreal Engine 4 AI Programming Essentials</em>, also available from Packt Publishing.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017 as the IDE. Instructions on how to install both pieces of software and the requirements for them can be found in <a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml">Chapter 1</a>, <em>UE4 Development Tools</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing a simple following behavior</h1>
                
            
            
                
<p>The most simple way to implement any kind of AI is to just write it out by hand. This allows you to get something up-and-running quickly, but lacks the elegance and finesse that using Unreal's built-in systems gives us. This recipe gives us a super-simple implementation of making an object follow another one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Have a UE4 project ready with a simple landscape or set of geometry on the ground, ideally with a <em>cul-de-sac</em> somewhere in the geometry to test AI movement functions. The <kbd>ThirdPersonExampleMap</kbd> that comes with the C++ Third Person template should work just fine.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new C++ class that derives from <kbd>Character</kbd> by going to Add New | New C++ Class. Under the Add C++ Class menu, select Character and hit the Next button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/39d55e09-2d74-4208-a316-e58723a542d9.png" style="width:52.83em;height:31.92em;"/></p>
<ol start="2">
<li>From the next screen, Name the class <kbd>FollowingCharacter</kbd> and click on the Create Class button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/597248e0-ee12-459f-9588-84457a32324a.png"/></p>
<ol start="3">
<li>From the <kbd>FollowingCharacter.cpp</kbd> file, update the <kbd>Tick</kbd> function to the following:</li>
</ol>
<pre style="padding-left: 60px">void AFollowingCharacter::Tick(float DeltaTime)<br/>{<br/>    Super::Tick(DeltaTime);<br/><br/><strong>    // Get current location</strong><br/><strong>    auto startPos = GetActorLocation();</strong><br/><br/><strong>    // Get player's location</strong><br/><strong>    FVector playerPos = GetWorld()-&gt;GetFirstPlayerController()-&gt;GetPawn()-&gt;GetActorLocation();</strong><br/><br/><strong>    // Get the direction to move in</strong><br/><strong>    FVector direction = playerPos - startPos;</strong><br/><strong>    direction.Normalize();</strong><br/><br/><strong>    // Move the player in that direction</strong><br/><strong>    SetActorLocation(startPos + direction);</strong><br/>}</pre>
<p>The <kbd>auto</kbd> keyword can be used for variable declarations if the compiler can deduce what the type of an object is from the assignment given to it.</p>
<ol start="4">
<li>Save your script and compile your code.</li>
</ol>
<ol start="5">
<li>Drag and drop the Following Character into your scene. There is currently no visualization of the character, so go ahead and select the object. Then, from the Details tab, click the Add Component button. From there, select the Cylinder shape: </li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/c8d54ec0-bd6d-4269-8951-2fcc86cf0489.png"/></p>
<p style="padding-left: 60px">If all goes well, you should see the object on the screen.</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/eaec7727-a31c-429c-a0c9-d53b6b24b012.png"/></p>
<p>The Following Character with a Cylinder shape added</p>
<ol start="6">
<li>Run the game and move around. You should notice that the cylinder will follow the player, no matter where they go!</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In this example, we are effectively <em>hard-coding</em> this enemy to follow the player character by doing simple vector math ourselves. While this technically works, it doesn't make use of Unreal's built-in AI functionality. It will also stop the AI at walls since there is no actual path-finding going on, and it will break the player character if you let the AI catch up. The player won't be able to move anymore due to collisions.</p>
<p>The rest of this chapter will be working with Unreal's actual built-in systems, which create a much more robust implementation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Laying down a Navigation Mesh</h1>
                
            
            
                
<p>A Navigation Mesh (also known as a <strong>Nav Mesh</strong>) is basically a definition of areas that an AI-controlled unit considers passable (that is, areas that the "AI-controlled" unit is allowed to move into or across). A Nav Mesh does not include geometry that would block the player if the player tried to move through it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Constructing a Nav Mesh based on your scene's geometry is fairly easy in UE4. Start with a project that has some obstacles around it, or one that uses terrain. The <kbd>ThirdPersonExampleMap</kbd> included with the C++ Third Person template works well for this purpose.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To construct your Nav Mesh, simply perform the following steps:</p>
<ol>
<li>Go to Modes | Volumes.</li>
<li>Drag the Nav Mesh Bounds Volume option onto your viewport.</li>
<li>Use the Scale tool to increase the size of the Nav Mesh so that it covers the area the actors that use the Nav Mesh should be allowed to navigate and pathfind in. To toggle the visibility of the completed Nav Mesh, press the <em>P</em> key:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/9b025c53-495a-412d-91e5-ae9c9e6b5b92.png"/></p>
<p>A Nav Mesh drawn within the bounds of the Nav Mesh Bounds Volume</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>A Nav Mesh doesn't block the player pawn (or other entities) from stepping on a certain geometry, but it serves to guide AI-controlled entities as to where they can and cannot go.</p>
<p class="packt_figref">For more information on scaling objects in UE4, check out the following link: <a href="https://docs.unrealengine.com/en-us/Engine/Actors/Transform">https://docs.unrealengine.com/en-us/Engine/Actors/Transform</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Blackboard</h1>
                
            
            
                
<p>A <strong>Blackboard</strong> is a container for variables that are often used with Behavior Trees. This data is used for decision-making purposes, either by a single AI or a whole group of others. We will be creating a Blackboard here that we will then use in future recipes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>From the Content Browser under the <kbd>Content</kbd> folder, select Add New | Artificial Intelligence | Blackboard:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ab959cad-1fb0-4c9f-9d53-5425a5ed955c.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="2">
<li>When asked for a name, provide <kbd>EnemyBlackboard</kbd>. Double-click on the file to open the Blackboard Editor.</li>
<li>From the Blackboard tab, click New Key | Object:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/bf12d03b-7d23-4239-bdb8-8f1bdc718b8a.png"/></p>
<ol start="4">
<li>When asked for the name of the object, insert <kbd>Target</kbd>. Then, open the Key Type property by clicking the arrow to the left of the name and set the Base Class property to <kbd>Actor</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/bf4829a3-3d30-4687-a757-43229a9bed7c.png"/></p>
<ol start="5">
<li>Add any other properties you wish to have access to and then click on the Save button.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In this recipe, we created a blackboard that we will later use in code to set and get the value of the player that we will use in our behavior tree.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a Behavior Tree</h1>
                
            
            
                
<p>If a Blackboard is the shared memory of an AI, the Behavior Tree is the AI's processor, which will contain the logic of the AI. It makes decisions, and then acts on those decisions to enable an AI to actually do something when the game is running. In this recipe, we will create a Behavior Tree and then assign its Blackboard.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>From the Content Browser under the <kbd>Content</kbd> folder, select Add New | Artificial Intelligence | Behavior Tree:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/144f462c-a25f-4e5f-9243-507ee517881a.png" style="width:28.25em;height:37.08em;"/></p>
<ol start="2">
<li>When asked for a name, provide <kbd>EnemyBehaviorTree</kbd>. Double-click on the file to open the Behavior Tree Editor.</li>
<li>Once opened, under the Details tab, open the AI | Behavior Tree section and verify that the Blackboard Asset property is set to <kbd>EnemyBlackboard</kbd>. You should notice the Target property we created listed under Keys. If not, close the editor and open it again:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/40020a2c-e30b-4f4b-b880-8c227ee889d0.png"/></p>
<p>A view of the Behavior Tree Editor</p>
<ol start="4">
<li>Once finished, click on the Save button.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In this recipe, we created a Behavior Tree, which is required by the AI system so that it can fulfill tasks and other assorted features. In future recipes, we will use this to create our own custom Character classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Connecting a Behavior Tree to a Character</h1>
                
            
            
                
<p>A <kbd>BehaviorTree</kbd> chooses a behavior to be exhibited by an AI-controlled unit at any given moment. Behavior Trees are relatively simple to construct, but there is a lot of setting up to do to get one running. You also have to be familiar with the components that are available for constructing your <strong>Behavior Tree</strong> to do so effectively.</p>
<p>A Behavior Tree is extremely useful for defining NPC behavior that is more varied than simply moving toward an opponent (as shown in the previous recipe with <kbd>AIMoveTo</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Before starting this recipe, verify that you have completed the following recipes:</p>
<ul>
<li><em>Laying down a Navigation Mesh</em></li>
<li><em>Creating a Blackboard</em></li>
<li><em>Creating a Behavior Tree</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Open up your <kbd>.Build.cs</kbd> file (in our case, <kbd>Chapter_13.Build.cs</kbd>) and add the following dependencies:</li>
</ol>
<pre style="padding-left: 60px">using UnrealBuildTool;<br/><br/>public class Chapter_13 : ModuleRules<br/>{<br/>  public Chapter_13(ReadOnlyTargetRules Target) : base(Target)<br/>  {<br/>    PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br/><br/>    PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "HeadMountedDisplay" });<br/>        <strong>PublicDependencyModuleNames.AddRange(new string[] { "AIModule", "GameplayTasks" });</strong><br/><br/>    }<br/>}</pre>
<ol start="2">
<li>Compile your code. </li>
<li>From the Content Browser, select Add New | New C++ Class. At the Add C++ Class menu, check the Show All Classes option type in <kbd>AIController</kbd>, and then select the <kbd>AIController</kbd> class. Then, click on Next:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/4db220e7-1fa7-48a1-9f27-d230b88354d4.png"/></p>
<ol start="4">
<li>When asked for a name for the class, name it <kbd>EnemyAIController</kbd> and click on the Create Class button.</li>
</ol>
<ol start="5">
<li>Open up Visual Studio and update the <kbd>EnemyAIController.h</kbd> file to the following:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "AIController.h"<br/><strong>#include "BehaviorTree/BehaviorTreeComponent.h"<br/>#include "BehaviorTree/BlackboardComponent.h"</strong><br/>#include "EnemyAIController.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_13_API AEnemyAIController : public AAIController<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>private:</strong><br/><strong>    // AI Component references</strong><br/><strong>    UBehaviorTreeComponent* BehaviorComp;</strong><br/><strong>    UBlackboardComponent* BlackboardComp;</strong><br/><br/><strong>public:</strong><br/><strong>    AEnemyAIController();</strong><br/><br/><strong>    // Called when the controller possesses a Pawn/Character</strong><br/><strong>    virtual void Possess(APawn* InPawn) override;<br/><br/>    FBlackboard::FKey TargetKeyID;</strong><br/><br/>};<br/><br/></pre>
<ol start="6">
<li>After creating the function declarations, we need to define them in the <kbd>EnemyAIController.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#include "EnemyAIController.h"<br/><br/>AEnemyAIController::AEnemyAIController()<br/>{<br/>    //Initialize components<br/>    BehaviorComp = CreateDefaultSubobject&lt;UBehaviorTreeComponent&gt;(TEXT("BehaviorComp"));<br/>    BlackboardComp = CreateDefaultSubobject&lt;UBlackboardComponent&gt;(TEXT("BlackboardComp"));<br/>}<br/><br/>// Called when the controller possesses a Pawn/Character<br/>void AEnemyAIController::Possess(APawn* InPawn)<br/>{<br/>    Super::Possess(InPawn);<br/>}</pre>
<p style="padding-left: 60px">In addition to an AI Controller, we also need to have a Character. </p>
<ol start="7">
<li>Create a new C++ class that derives from <kbd>Character</kbd> by going to Add New | New C++ Class. Under the Add C++ Class menu, select Character and hit the Next button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/9f10b90b-8e30-4d27-9752-a97c1c011ad5.png"/></p>
<ol start="8">
<li>From the next screen, <kbd>Name</kbd> the class <kbd>EnemyCharacter</kbd> and click on the Create Class button.</li>
</ol>
<ol start="9">
<li>Open Visual Studio. Under the <kbd>EnemyCharacter.h</kbd> file, add the following property:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Character.h"<br/>#include "EnemyCharacter.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_13_API AEnemyCharacter : public ACharacter<br/>{<br/>    GENERATED_BODY()<br/><br/>public:<br/>    // Sets default values for this character's properties<br/>    AEnemyCharacter();<br/><br/><strong>    UPROPERTY(EditAnywhere, Category = Behavior)</strong><br/><strong>    class UBehaviorTree *EnemyBehaviorTree;</strong><br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/>    // Called to bind functionality to input<br/>    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;<br/><br/>};</pre>
<ol start="10">
<li>Then, we can go back into the <kbd>EnemyAIController.cpp</kbd> file and update the <kbd>Possess</kbd> function since our Character class exists:</li>
</ol>
<pre style="padding-left: 60px">#include "EnemyAIController.h"<br/><strong>#include "EnemyCharacter.h"</strong><br/><strong>#include "BehaviorTree/BehaviorTree.h"</strong><br/><br/><br/>AEnemyAIController::AEnemyAIController()<br/>{<br/>    // Initialize components<br/>    BehaviorComp = CreateDefaultSubobject&lt;UBehaviorTreeComponent&gt;(TEXT("BehaviorComp"));<br/>    BlackboardComp = CreateDefaultSubobject&lt;UBlackboardComponent&gt;(TEXT("BlackboardComp"));<br/>}<br/><br/>// Called when the controller possesses a Pawn/Character<br/>void AEnemyAIController::Possess(APawn* InPawn)<br/>{<br/>    Super::Possess(InPawn);<br/><br/><strong>    // Convert InPawn to EnemyCharacter</strong><br/><strong>    auto Character = Cast&lt;AEnemyCharacter&gt;(InPawn);</strong><br/><br/><strong>    // Check if pointers are valid</strong><br/><strong>    if(Character &amp;&amp; Character-&gt;EnemyBehaviorTree)</strong><br/><strong>    {</strong><br/><strong>        BlackboardComp-&gt;InitializeBlackboard(*Character-&gt;EnemyBehaviorTree-&gt;BlackboardAsset);</strong><br/><br/><strong>        TargetKeyID = BlackboardComp-&gt;GetKeyID("Target");</strong><br/><br/><strong>        BehaviorComp-&gt;StartTree(*Character-&gt;EnemyBehaviorTree);</strong><br/><strong>    }</strong><br/>}</pre>
<ol start="11">
<li>Save your scripts and compile your code.</li>
</ol>
<p style="padding-left: 60px">Now, we will create a Blueprint version of the two classes we just created and assign our variables.</p>
<ol start="12">
<li>From the Content Browser under the <kbd>C++ Classes/Chapter_13</kbd> folder, right-click on the <kbd>EnemyAIController</kbd> object and select the Create Blueprint class based on EnemyAIController option. Give it a name and click on the Create Blueprint Class button.</li>
<li>Likewise, do the same thing for the <kbd>EnemyCharacter</kbd> object.</li>
</ol>
<ol start="14">
<li>Double-click on your <kbd>MyEnemyCharacter</kbd> Blueprint and, under the Details tab, set the Enemy Behavior Tree property to EnemyBehaviorTree. Then, set the AI Controller Class property to <kbd>MyEnemyAIController</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/553deaf5-094e-49be-850d-047a325d2958.png"/></p>
<p>Assigning the Enemy Behavior Tree and AI Controller Class properties</p>
<ol start="15">
<li>You'll likely want a visual component for the character as well, so from the Components tab, click on the Add Component button and select Cube. Afterward, modify the Scale to (<kbd>0.5, 0.5, 1.5</kbd>). </li>
</ol>
<p style="padding-left: 60px">As we discussed previously, you may need to click on the Open Full Blueprint Editor text to see all of the available options.</p>
<p style="padding-left: 60px">16. Then, hit Compile and save all of your assets:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ea359363-aa31-4d0b-b7d0-c8d67aab84e7.png"/></p>
<p>The completed enemy character</p>
<p>And with that, we've set up a connection between an AI Character, an AI Controller, and a Behavior Tree!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The AI Controller class we created will add both the Behavior Tree and the Blackboard that we created in the previous two recipes. </p>
<p>A Behavior Tree is connected to an AI Controller, which in turn is connected to a Character. We will control the behavior of <kbd>Character</kbd> through the Behavior Tree by entering Task and Service nodes in the diagram.</p>
<p>A Behavior Tree hosts six different types of node, as follows:</p>
<ol>
<li><strong>Task</strong>: Task nodes are the purple nodes in the Behavior Tree that contain Blueprint code to run. It's something that the AI-controlled unit has to do (code-wise). Tasks must return either <kbd>true</kbd> or <kbd>false</kbd>, depending on whether the task succeeded or not (by providing a <kbd>FinishExecution()</kbd> node at the end).</li>
<li><strong>Decorator</strong>: A decorator is just a Boolean condition for the execution of a node. It checks a condition, and is typically used within a Selector or Sequence block.</li>
<li><strong>Service</strong>: This runs some Blueprint code when it ticks. The tick interval for these nodes is adjustable (it can run slower than a per-frame tick, for example, every 10 seconds). You can use these to query the scene for updates, a new opponent to chase, and so on. The Blackboard can be used to store queried information. Service nodes do not have a <kbd>FinishExecute()</kbd> call at the end of them.</li>
<li><strong>Selector</strong>: This runs all subtrees from left to right until it encounters a success. When it encounters a success, the execution goes back up the tree.</li>
<li><strong>Sequence</strong>: This runs all subtrees from left to right until it encounters a failure. When a failure is encountered, the execution goes back up the tree.</li>
<li><strong>Simple Parallel</strong>: This runs a single task (purple) in parallel with a subtree (gray).</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a BTService</h1>
                
            
            
                
<p>Services attach to nodes in Behavior Trees and will execute at their defined frequency; that is, as long as their branch is being executed. Similar to Parallel nodes in other Behavior Tree systems, these are often used to make checks and to update the Blackboard, which we will use in this recipe to find our player object and assign it to our Blackboard. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready...</h1>
                
            
            
                
<p>Finish the previous recipe, <em>Connecting a Behavior Tree to a Character</em>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>From the Content Browser, select Add New | New C++ Class. From the Choose Parent Class menu, check the Show All Classes option and look for the <kbd>BTService</kbd> class. Select it and then hit the Next button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0a41289d-bab4-4f68-a540-4f354a5e08a8.png" style="width:54.58em;height:33.00em;"/></p>
<ol start="2">
<li>At the next menu, set its name to <kbd>BTService_FindPlayer</kbd> and then click on the Create Class option.</li>
<li>From the <kbd>BTService_FindPlayer.h</kbd> file, use the following code:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "BehaviorTree/BTService.h"<br/><strong>#include "BehaviorTree/BehaviorTreeComponent.h"</strong><br/>#include "BTService_FindPlayer.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_13_API UBTService_FindPlayer : public UBTService<br/>{<br/>    GENERATED_BODY()<br/><br/><strong>public:</strong><br/><strong>    UBTService_FindPlayer();</strong><br/><strong>    </strong><br/><strong>    /** update next tick interval</strong><br/><strong>    * this function should be considered as const (don't modify state of object) if node is not instanced! */</strong><br/><strong>    virtual void TickNode(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, float DeltaSeconds) override;</strong><br/><br/>};</pre>
<ol start="4">
<li>From the <kbd>BTService_FindPlayer.cpp</kbd> file, use the following code:</li>
</ol>
<pre style="padding-left: 60px">#include "BTService_FindPlayer.h"<br/>#include "EnemyAIController.h"<br/>#include "BehaviorTree/Blackboard/BlackboardKeyType_Object.h"<br/><br/>UBTService_FindPlayer::UBTService_FindPlayer()<br/>{<br/>    bCreateNodeInstance = true;<br/>}<br/><br/>void UBTService_FindPlayer::TickNode(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory, float DeltaSeconds)<br/>{<br/>    Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds);<br/><br/>    auto EnemyAIController = Cast&lt;AEnemyAIController&gt;(OwnerComp.GetAIOwner());<br/><br/>    if(EnemyAIController)<br/>    {<br/>        auto PlayerPawn = GetWorld()-&gt;GetFirstPlayerController()-&gt;GetPawn();<br/>        OwnerComp.GetBlackboardComponent()-&gt;SetValue&lt;UBlackboardKeyType_Object&gt;(EnemyAIController-&gt;TargetKeyID, PlayerPawn);<br/>        UE_LOG(LogTemp, Warning, TEXT("Target has been set!"));<br/><br/>    }<br/><br/>}</pre>
<ol start="5">
<li>Save your scripts and compile them.</li>
</ol>
<ol start="6">
<li>In the Content Browser, go to the <kbd>Content</kbd> folder where the <kbd>EnemyBehaviorTree</kbd> we created previously is located and double-click on it to open the Behavior Tree editor.</li>
<li>From there, drag a line from ROOT down and select Selector:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/02b17ca7-1f63-459e-812c-f631ef24d0e5.png" style="width:32.75em;height:20.33em;"/></p>
<p style="padding-left: 60px">It's important to note that you need to drag from the darker gray rectangle on the bottom. If you try to drag from the middle of ROOT, you'll just move the node.</p>
<ol start="8">
<li>Right-click on the Selector node and select Add Service | FindPlayer:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/36058d95-940d-494f-bcd3-9f1d70ff5617.png" style="width:20.42em;height:17.17em;"/></p>
<p class="mce-root"/>
<ol start="9">
<li>Now, drag and drop an instance of your <kbd>MyEnemyCharacter</kbd> object into your scene and run the game:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/538167bc-799d-4532-a475-eaa0eee25c53.png"/></p>
<p>As you can see, the value has been set!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Our Behavior Tree will continue to call the Selector as there are no other nodes for it to transition to.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a BTTask</h1>
                
            
            
                
<p>In addition to Services, we also have Tasks, which are leaf nodes of Behavior Trees. These are the things that actually perform actions. In our example, we are going to have our AI follow our target, the player.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready...</h1>
                
            
            
                
<p>Finish the previous recipe, <em>Creating a BTService</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>From the Content Browser, select Add New | New C++ Class. From the Choose Parent Class menu, check the Show All Classes option and look for the <kbd>BTTask_BlackboardBase</kbd> class. Select it and then hit the Next button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/91d4a05e-cee6-4e79-bdc9-18e76094d6d9.png" style="width:52.25em;height:31.58em;"/></p>
<ol start="2">
<li>At the next menu, set its name to <kbd>BTTask_MoveToPlayer</kbd> and then click on the Create Class option:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/00eb28d3-9f0c-4946-89f3-a726f8b2f435.png"/></p>
<ol start="3">
<li>Open Visual Studio and add the following function to <kbd>BTTask_MoveToPlayer.h</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "BehaviorTree/Tasks/BTTask_BlackboardBase.h"<br/>#include "BTTask_MoveToPlayer.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_13_API UBTTask_MoveToPlayer : public UBTTask_BlackboardBase<br/>{<br/>    GENERATED_BODY()<br/><br/>public:<br/><strong>    /** starts this task, should return Succeeded, Failed or InProgress</strong><br/><strong>     * (use FinishLatentTask() when returning InProgress)</strong><br/><strong>     * this function should be considered as const (don't modify state of object) if node is not instanced! */</strong><br/><strong>    virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory) override;</strong><br/>    <br/>};</pre>
<p class="mce-root"/>
<ol start="4">
<li>Then, open the <kbd>BTTask_MoveToPlayer.cpp</kbd> file and update it to the following:</li>
</ol>
<pre style="padding-left: 60px">#include "BTTask_MoveToPlayer.h"<br/><strong>#include "EnemyAIController.h"</strong><br/><strong>#include "GameFramework/Character.h"</strong><br/><strong>#include "BehaviorTree/Blackboard/BlackboardKeyType_Object.h"</strong><br/><br/><strong>EBTNodeResult::Type UBTTask_MoveToPlayer::ExecuteTask(UBehaviorTreeComponent&amp; OwnerComp, uint8* NodeMemory)</strong><br/><strong>{</strong><br/><strong>    auto EnemyController = Cast&lt;AEnemyAIController&gt;(OwnerComp.GetAIOwner());</strong><br/><strong>    auto Blackboard = OwnerComp.GetBlackboardComponent();</strong><br/><br/><strong>    ACharacter * Target = Cast&lt;ACharacter&gt;(Blackboard-&gt;GetValue&lt;UBlackboardKeyType_Object&gt;(EnemyController-&gt;TargetKeyID));</strong><br/><br/><strong>    if(Target)</strong><br/><strong>    {</strong><br/><strong>        EnemyController-&gt;MoveToActor(Target, 50.0f);</strong><br/><strong>        return EBTNodeResult::Succeeded;</strong><br/><strong>    }</strong><br/><br/><strong>    return EBTNodeResult::Failed;</strong><br/><strong>}</strong></pre>
<ol start="5">
<li>Save your files and return to the Unreal Editor. Compile your code.</li>
<li>In the Content Browser, go to the <kbd>Content</kbd> folder where the <kbd>EnemyBehaviorTree</kbd> we created previously is located and double-click on it to open the Behavior Tree editor.</li>
</ol>
<ol start="7">
<li>Drag this below the Selector node and select Tasks | Move to Player:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/571d92a5-1006-40e6-b2a4-64a3d13b72fc.png"/></p>
<p class="mce-root"/>
<ol start="8">
<li>Save the Behavior Tree and return to the Unreal Editor. Drag and drop a <kbd>MyEnemyCharacter</kbd> object into the scene if you haven't done so already and play the game:</li>
</ol>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="img/dcddb9f0-f8a7-4b70-b9c9-2088fd700a86.png"/></p>
<p>As you can see, our enemy is now following our player, which will happen for as long as the NavMesh covers the area!</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>This recipe takes all of the materials we've covered so far and compiles them all together. The <kbd>ExecuteTask</kbd> method will be called as long as the BehaviorTree is inside this state. This function requires us to return an <kbd>EBTNodeResult</kbd>, which should return <kbd>Succeeded</kbd>, <kbd>Failed</kbd>, or <kbd>InProgress</kbd> to let the BehaviorTree know whether we can change states or not.</p>
<p>In our case, we first obtain the <kbd>EnemyController</kbd> and the <kbd>Target</kbd> objects so that we can figure out who we want to move and where we want to move to. As long as those properties are valid, we can call the <kbd>MoveToActor</kbd> function.</p>
<p>There are a lot of other properties that the <kbd>MoveToActor</kbd> function offers that may be useful so that you can customize your movement. For more information, check out the following link: <a href="https://api.unrealengine.com/INT/API/Runtime/AIModule/AAIController/MoveToActor/index.html">https://api.unrealengine.com/INT/API/Runtime/AIModule/AAIController/MoveToActor/index.html</a>.<br/>
For those of you who are interested in exploring additional AI concepts with UE4, I highly suggest checking out Orfeas Eleftheriou's UE4 AI Tutorials: <a href="https://orfeasel.com/category/ue_tuts/ai-programming/">https://orfeasel.com/category/ue_tuts/ai-programming/</a>.</p>


            

            
        
    </body></html>