- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating STL -Compatible Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discusses creating versatile and efficient algorithms in C++. Developers
    will learn type-generic programming, understand the function overloading, and
    learn to tailor existing algorithms to specific needs. The chapter will include
    theory, best practices, and hands-on techniques. By the end, we will be equipped
    to develop powerful and adaptable algorithms for various scenarios.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Template functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overloading
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating generic algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing existing algorithms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Template functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the hallmarks of the C++ **Standard Template Library** (**STL**) is its
    commitment to type-generic programming. This allows algorithms to be written to
    operate on multiple data types, effectively sidestepping the restrictions of traditional
    type-specific functions. C++ achieves this remarkable feat using template functions.
    Let us explore these template functions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: A primer on function templates
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the heart of type-generic programming lies the function template, an incredible
    tool that allows developers to write functions without specifying the exact data
    types they will operate on. Instead of committing to a single type, templates
    let you define a blueprint, making the function adaptable to various types. Here’s
    a simple example: imagine writing a function that swaps the values of two variables.
    With function templates, this `swap` function can cater to integers, floats, strings,
    and even custom types!'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Variadic templates – multiplicity in templates
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Variadic templates** elevate the power of function templates by allowing
    you to write functions that accept a variable number of template arguments. This
    is especially handy when crafting algorithms that need to operate on different
    numbers of inputs. They become indispensable when you think of functions that
    combine, transform, or process multiple containers or elements simultaneously.
    As you explore the STL, you’ll see many instances where this flexibility becomes
    crucial.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: SFINAE – fine-tuning template substitution
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Substitution failure is not an error** (**SFINAE**) sounds like a cryptic
    concept, but it is a cornerstone for creating resilient template functions in
    C++. It’s a mechanism that allows the compiler to discard specific template overloads
    based on whether the type substitution leads to a valid result. In essence, it
    is like giving the compiler a set of rules on which template to pick based on
    the specifics of the provided types.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you’re writing a function template that operates on STL containers.
    With SFINAE, you can direct the compiler to pick a particular overload when the
    container is a sequence container and another when it is an associative container.
    The magic here lies in ensuring that the template substitution remains valid.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Harnessing SFINAE with std::enable_if
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::enable_if` utility is a boon when working with SFINAE. It’s a type
    trait that can conditionally remove or add a particular function overload from
    the set of overloads considered during template substitution. Coupling `std::enable_if`
    with type traits allows you to fine-tune your algorithms to cater to specific
    STL container characteristics.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example that demonstrates the concepts of function templates,
    variadic templates, and SFINAE:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the example output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code demonstrates the concepts of function templates, variadic templates,
    and SFINAE. The `swap` function is a simple function template that swaps two variables
    of any type. The `print` function is a variadic template that prints any number
    of arguments. The `process` functions demonstrate SFINAE with `std::enable_if`,
    where different overloads are chosen based on the type of argument. Finally, the
    `processContainer` functions show how SFINAE can be used to differentiate between
    different STL containers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and mastering function templates will be pivotal as you venture
    deeper into creating STL-compatible algorithms. They ensure that your algorithms
    are versatile, adapting to various types and scenarios. But more than just flexibility,
    templates bolster efficiency. By working closely with the type system, your algorithms
    can be optimized for specific types, yielding performance benefits.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Function templates, variadic templates, and SFINAE are more than just tools;
    they are the bedrock upon which the STL’s type-generic paradigm stands. By leveraging
    these, you are aligning with the STL’s philosophy and elevating your algorithms’
    adaptability and power.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: As we progress further into the chapter, we’ll review overloading techniques,
    understand the nuances of creating truly generic algorithms, and learn the art
    of customizing existing ones for specific needs. Each step brings us closer to
    mastering the art of crafting exceptional STL-compatible algorithms.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Overloading
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Function overloading** is a cornerstone of C++ programming, enabling developers
    to define multiple versions of a function with the same name but different parameters.
    This ability is especially crucial when crafting algorithms that interact with
    the diverse palette of STL containers, each with its unique characteristics and
    requirements. With overloading, you can tailor your algorithms to specific containers
    or situations, ensuring optimal performance and flexibility.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Crafting multiple algorithm versions for STL containers
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A need to treat specific containers differently based on their inherent properties
    might arise when designing algorithms compatible with STL containers. For instance,
    an algorithm interacting with `std::vector` might have different requirements
    than when dealing with `std::map`. By utilizing function overloading, you can
    design separate versions of the algorithm optimized for each container type, ensuring
    that each interaction is as efficient as possible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Function resolution – navigating the intricacies
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function overloading comes with challenges, and understanding function resolution
    is pivotal. When multiple overloaded functions are potential candidates for a
    call, the compiler follows a strict set of rules to determine the best match.
    It considers the number of arguments, their types, and their potential type conversions.
    As you overload functions for STL-compatible algorithms, being aware of these
    rules is paramount. It ensures that the correct version of your function gets
    invoked and prevents any unexpected behaviors or ambiguities.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Overloading with care – clarity and consistency
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The power to overload functions can be both a boon and a pitfall. While it allows
    for greater flexibility, it also introduces the risk of cluttering your code base
    with too many function variations, potentially leading to confusion. A golden
    rule when overloading is to maintain clarity and consistency.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Ask yourself whether the overloaded version offers a different or optimized
    approach for a particular STL container or scenario. If it doesn’t, perhaps relying
    on a generic version that can cater to multiple scenarios is more prudent. A well-designed
    function signature, combined with meaningful parameter names, can often convey
    the function’s purpose, reducing the need for excessive overloading.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, ensure that your documentation is precise. Mention the purpose
    of each overloaded version, the scenarios in which it should be used, and how
    it differs from other versions. This not only aids other developers who might
    use or maintain your algorithms but also serves as a valuable reference for your
    future self.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: With a firm grasp on overloading, you are now poised to dive further into the
    world of STL-compatible algorithms. The techniques you’ve acquired here lay the
    foundation for creating generic algorithms and customizing existing ones to cater
    to specific needs. The journey ahead is exciting, filled with opportunities to
    design robust, versatile algorithms that seamlessly integrate with the vast expanse
    of STL containers, genuinely exemplifying the essence of C++ programming.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Creating generic algorithms
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about constructing algorithms that transcend
    type-specific boundaries, a fundamental aspect of advanced C++ programming. This
    approach is crucial for developing robust and versatile software, as it allows
    algorithms to operate seamlessly across a diverse array of data types and structures.
    This section will guide you through the principles and techniques necessary to
    design algorithms that are not just efficient but also adaptable and type-agnostic,
    aligning perfectly with the philosophy of the STL.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The ability to write generic algorithms is invaluable. It ensures that your
    code is not only reusable across various applications but also capable of handling
    unforeseen future requirements. This versatility is especially important in C++
    programming, where the complexity and diversity of data types can pose significant
    challenges. By focusing on a type-independent approach and embracing tools such
    as iterators, predicates, and functors, you will learn to create algorithms that
    are not constrained by type-specific limitations. This knowledge will empower
    you to write code that is more maintainable, scalable, and aligned with best practices
    in C++ programming. As we work through these concepts, you’ll gain the skills
    to make your algorithms a perfect fit for the STL, enhancing both their utility
    and performance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Toward a type-independent approach
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you create generic algorithms, one guiding principle is the type-independent
    approach. The strength of C++ and the STL is their ability to craft algorithms
    that, at their core, do not care about the type they operate on. They focus on
    logic, and the underlying machinery handles the type-specific details, primarily
    templates and iterators.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Embracing iterators – the bridge to generics
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many ways, iterators are the secret sauce behind the generic nature of STL
    algorithms. Think of iterators as bridging the gap between type-specific containers
    and type-agnostic algorithms. When crafting a generic algorithm, you typically
    wouldn’t accept a container as a parameter. Instead, you’d accept iterators, and
    these iterators abstract away the underlying container and its type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: For example, instead of designing an algorithm specifically for `std::vector<int>`,
    accept iterators as parameters. This makes your algorithm applicable to `std::vector<int>`
    and potentially to any container that provides the required iterator type.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These examples show how a function that takes iterators as parameters can be
    more versatile than one that takes a reference to a container.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Predicates – customizing algorithm behavior
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But what if you wish to introduce a hint of customization? What if you want
    your generic algorithm to have a configurable behavior? Enter predicates.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '**Predicates** are Boolean-valued unary or binary functions (or function objects).
    When passed to an algorithm, they can influence its behavior. For instance, when
    sorting a collection, you can provide a predicate to determine the ordering of
    elements. By harnessing predicates, your algorithms can remain generic but still
    be tailored to specific scenarios without hardcoding any behavior.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The magic of functors – enhancing flexibility
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While predicates allow customization, functors (or function objects) take this
    to another level. A **functor** is an object that can be called as if it were
    a function. The essential advantage here is statefulness. Unlike simple function
    pointers or lambdas, functors can maintain state, providing a more significant
    degree of flexibility.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Imagine designing a generic algorithm that applies a transformation to each
    element in an STL container. By accepting a functor as a parameter, users of your
    algorithm can not only specify the transformation logic but also carry some state
    with it, making for robust and adaptable solutions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: With iterators, predicates, and functors in your toolkit, you’re well-equipped
    to craft generic algorithms that are versatile yet type-agnostic. Always focus
    on the logic, keep the type specifics abstracted away, and provide avenues (such
    as predicates and functors) for users to inject custom behavior.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: As you move ahead, remember that the essence of generic programming is adaptability.
    Algorithms should be built to cater to a wide range of scenarios and types. The
    upcoming section will guide you through adapting and extending the already robust
    set of STL algorithms, amplifying the power of your C++ code base.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Customizing existing algorithms
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The STL provides for adapting and enhancing its already robust set of algorithms.
    This skill is crucial for any proficient C++ programmer, as it allows for the
    fine-tuning of algorithms to meet specific needs without starting from scratch.
    In this section, you will learn how to use design patterns, such as the **decorator
    pattern**, and lambda functions to modify existing algorithms, making them more
    suitable for your unique requirements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: In practical programming scenarios, you often encounter situations where an
    existing STL algorithm *almost* meets your needs but requires some adjustments.
    Knowing how to customize these algorithms, as opposed to creating entirely new
    ones, can save significant time and effort. This section will teach you to leverage
    existing solutions and adapt them creatively, ensuring efficiency and maintainability.
    You will discover how to integrate design patterns to add new behaviors or modify
    existing ones and how to use lambda functions for concise and effective customizations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the decorator pattern in action
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When confronted with an STL algorithm that almost fits the bill but not entirely,
    resisting the urge to reinvent the wheel is crucial. Instead, adapting these algorithms
    using tried and true design patterns can often lead to a more elegant, efficient,
    and maintainable solution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: One of the most potent design patterns in this context is the decorator pattern.
    It allows you to take an existing algorithm and add or modify behaviors without
    altering its structure. Consider a scenario where you have a sorting algorithm
    and want to add logging capabilities. Instead of rewriting or overloading the
    function, use the decorator pattern to create a new algorithm that calls the original
    sorting function and adds logging on top. The beauty here is in the separation
    of concerns and the ability to chain decorators for multiple additional behaviors.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the decorator pattern in action. We will use it to add logging
    to an STL comparison function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the example output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, `LoggingCompareDecorator` is a template class that takes a
    comparison function object (`comp`) and adds logging around it. `operator()` is
    overridden to add logging before calling the original comparison function. The
    original sorting algorithm (`std::sort`) is used with the decorated comparison
    function, thereby adding logging to each comparison operation without altering
    the sorting algorithm itself. This demonstrates the decorator pattern by allowing
    additional behavior (logging) to be added to an existing function (`std::less`)
    in a manner that is clean and maintainable and adheres to the separation of concerns
    principle.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Harnessing the power of lambda functions
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lambda functions are magnificent tools in the C++ arsenal. They enable developers
    to define anonymous functions in place, making code concise and, in many cases,
    more readable. When customizing existing STL algorithms, lambdas can be a game-changer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you’re using the `std::transform` algorithm, which applies a function
    to every element in a container. The beauty of `std::transform` is its flexibility
    in accepting any callable object, including lambdas. So, instead of defining a
    whole new function or functor, you can pass a lambda function directly to tailor
    its behavior to your needs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take an example. Suppose you want to square each element in a vector.
    Instead of creating a separate function named `square`, you can pass a lambda,
    as shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Lambdas can also capture variables from their surrounding scope, giving you
    the power to use external data in your custom logic. For instance, if you want
    to multiply each element in a vector by a dynamic factor, you can capture that
    factor in a lambda and use it inside:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Lambda functions in C++ offer a succinct and flexible way to define anonymous,
    inline functions, greatly simplifying the code, especially for short, one-time-use
    functions. They enhance readability and maintainability, and when used in conjunction
    with STL algorithms, they allow for concise and powerful custom behaviors without
    the need for verbose function or functor definitions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Mixing patterns with lambdas for ultimate customization
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you combine the power of design patterns with the flexibility of lambda
    functions, you get a toolset that allows for profound customization of existing
    algorithms. For instance, you could use the **strategy pattern** to define a family
    of algorithms and then employ lambda functions to fine-tune the behavior of each
    strategy. This synergy can lead to highly modular and adaptable code, maximizing
    code reuse and minimizing redundancy.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of using lambdas with the strategy pattern:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the example output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, `Strategy` is an abstract base class that defines a family
    of algorithms. `ForEachStrategy` and `TransformStrategy` are concrete strategies
    that implement these algorithms using `std::for_each` and `std::transform`, respectively.
    Both algorithms use lambda functions to define their behavior. The `Context` class
    uses `Strategy` to execute an algorithm, and `Strategy` can be changed at runtime.
    This demonstrates the power of combining design patterns with lambda functions
    to create highly modular and adaptable code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Customizing existing algorithms is an art and a science. It requires a deep
    understanding of the existing STL tools, a dash of creativity, and the discipline
    to maintain clarity and efficiency. As you venture forward, always prioritize
    understanding the problem and choosing the right tool for the job. Customize thoughtfully,
    and the STL will reward you with elegant solutions to even the most intricate
    problems.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we conclude this chapter on creating STL-compatible algorithms, we have learned
    the essential techniques and concepts for crafting versatile and efficient algorithms
    in C++. Starting with the fundamentals of type-generic programming, you have learned
    the art of using function templates, variadic templates, and the subtle yet powerful
    SFINAE principle. These tools enable you to write algorithms that are adaptable
    to a multitude of data types, a hallmark of the STL’s flexibility and power.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has also guided you through the intricacies of function overloading,
    a critical skill for tailoring algorithms to different STL containers and scenarios.
    You’ve learned how to navigate the complexities of function resolution and the
    importance of maintaining clarity and consistency when overloading functions.
    This knowledge ensures that your algorithms are not only versatile but also intuitive
    and efficient in their interaction with various STL components.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead, the next chapter will uncover the world of type traits and policies,
    exploring how these tools enhance code adaptability and empower metaprogramming.
    You’ll learn about the benefits of using policies in relation to the STL, how
    to build modular components, and the potential challenges you may encounter. This
    chapter will not only deepen your understanding of advanced C++ features but also
    equip you with practical skills for implementing type traits and policies in your
    code, ensuring compatibility and flexibility in your programming.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，下一章将揭示类型特性和策略的世界，探讨这些工具如何增强代码的适应性并赋予元编程能力。你将了解使用策略与 STL 相关的好处，如何构建模块化组件，以及你可能遇到的潜在挑战。这一章不仅将加深你对高级
    C++ 特性的理解，还将为你提供在代码中实现类型特性和策略的实用技能，确保你的编程具有兼容性和灵活性。
