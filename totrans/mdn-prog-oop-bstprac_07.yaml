- en: '*Chapter 5*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coding Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you learned programming by studying a book or an online course, you probably
    sat at your computer with a text editor or IDE, solving each problem completely
    as it came. Most software teams have two additional problems to contend with—the
    applications they're writing are much larger, and there's more than one of them
    working on the product at once. In this chapter, I'll look at some common ways
    to set about the task of programming on a larger project (though, teamwork plays
    such a big part in this that it has its own chapter later in the book).
  prefs: []
  type: TYPE_NORMAL
- en: Most of this chapter will act as a quick reference, with an inline reading list
    and a few opinions thrown in for good measure. The reason is that the concepts
    are too large to cover in detail in a single section of a novel-length book like
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Test-Driven Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**TDD** (**Test-Driven Development**) is such a big topic, plenty of books
    have been written about it. Indeed, one of those books was written by me: **Test-Driven
    iOS Development** ([http://www.pearsoned.co.uk/bookshop/detail.asp?item=100000000444373](http://www.pearsoned.co.uk/bookshop/detail.asp?item=100000000444373)).
    So, I won''t go into too much detail here. If you''ve never come across test-driven
    development before, or the phrase "red-green-refactor," I recommend **Growing
    Object-Oriented Software, Guided By Tests** ([http://www.growing-object-oriented-software.com/](http://www.growing-object-oriented-software.com/))
    (unless you''re focusing on iOS, of course).'
  prefs: []
  type: TYPE_NORMAL
- en: The point of TDD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: People talk about test-driven development as a way to ensure high test coverage.
    It does that, for sure. But its main utility is as a *design tool*. You can construct
    an executable specification of a module or class, based on how you need to use
    that class in your product. Often, I'll create some tests while I'm designing
    a class, but remove them as the code changes and they become obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: I've delegated classes to other developers before by writing a suite of tests
    and asking them to fill in the implementation. I've left myself a failing test
    on a Friday evening, so I know what I'm supposed to be doing on Monday morning
    (the `#error` C preprocessor command, which inserts a compiler error with a custom
    message, is also useful for this). TDD has plenty of utilities beyond generating
    automated regression tests.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that TDD only helps you with your design when you limit yourself to designs
    that can be (easily) achieved by doing TDD. That's no bad thing, as it means that
    everything will be designed in similar, understandable ways. It's like a magazine
    having a tone and style guide, so readers have a base level of expectations of
    any article.
  prefs: []
  type: TYPE_NORMAL
- en: Particular constraints, or at least *suggestions*, derived from allowing TDD
    to elicit design choices include that your design will probably be loosely coupled
    (that is, each module will not depend greatly on other modules in the system)
    with interchangeable dependencies injected from the outside. If your response
    to that is "great - that's what I'd want," then you'll have no problem.
  prefs: []
  type: TYPE_NORMAL
- en: The Software I'm Writing Can't Be Tested
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actually, it probably can. Apart from the sample code from the afore-mentioned
    book, there's code in every project I've written that hasn't been tested. In most
    cases, it probably *can* be tested. Let's look at some of the real reasons the
    tests haven't been written.
  prefs: []
  type: TYPE_NORMAL
- en: '*I''ve already written the code without tests, and can''t work out how to retroactively
    test it*'
  prefs: []
  type: TYPE_NORMAL
- en: This is a common complaint. Don't let a TDD proponent smugly say "well, you
    should have written tests in the first place" – that's dogmatic and unhelpful.
    Besides, it's too late. Instead, you should decide whether you want to (and can)
    spend the time changing the code to make it amenable to testing.
  prefs: []
  type: TYPE_NORMAL
- en: It's not just time, of course; there's a risk associated with any change to
    software. – As mentioned elsewhere in this book, any code you write is a liability,
    not an asset. The decision regarding whether or not you adapt the code to support
    tests' adaptation should consider not only the cost of doing the work, but the
    potential risk of doing it. (I'm deliberately calling this work "adaptation" rather
    than "refactoring." Refactoring means to change the structure of a module without
    affecting its behavior. Until you have the tests in place, you cannot guarantee
    that the behavior is unchanged.) These need to be balanced against the potential
    benefits of having the code under test, and the opportunity cost of not getting
    the code into shape when you get the chance.
  prefs: []
  type: TYPE_NORMAL
- en: If you decide you *do* want to go ahead with the changes, you should plan your
    approach so that the work done to support the tests is not too invasive. You don't
    want to change the behavior of the software until you can see whether such changes
    reflect your expectations. A great resource for this is Michael Feathers' **Working
    Effectively With Legacy Code** ([https://c2.com/cgi/wiki?WorkingEffectivelyWithLegacyCode](https://c2.com/cgi/wiki?WorkingEffectivelyWithLegacyCode)).
  prefs: []
  type: TYPE_NORMAL
- en: '*I don''t know how to test that API/design/whatever*'
  prefs: []
  type: TYPE_NORMAL
- en: Often, "this can't be tested" comes down to "I don't know how this could be
    tested." Sometimes, it's actually true that some particular API doesn't lend itself
    to being used in isolation. A good example is low-level graphics code, which often
    expects that some context exists into which you're drawing. It can be very hard
    (if indeed it's possible at all) to reproduce this context in a way that allows
    a test harness to capture and inspect the drawing commands.
  prefs: []
  type: TYPE_NORMAL
- en: You can provide such an inspection capability by wrapping the problematic API
    in an interface of your own design. Then, you can swap that out for a testable
    implementation – or for an alternative API, if that becomes desirable. OK, the
    adaptor class you wrote probably can't be tested still, but it should be thin
    enough for that to be a low risk.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, there is a way to test the code that can be brought out with
    a bit of thought. I'm often told that an app with a lot of GUI code can't be tested.
    Why not?
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s in a GUI app? For a start, there are a load of data models and "business"
    logic that would be the same in any other context and can easily be tested. Then,
    there''s the interaction with the UI: the "controller" layer in the MVC world.
    That''s code that reacts to events coming from the UI by triggering changes in
    the model and reacts to events coming from the model by updating the view. That''s
    easy to test too, by simulating the events and ensuring that the controller responds
    to them correctly; mocking the "other end" of the interaction.'
  prefs: []
  type: TYPE_NORMAL
- en: This just leaves any custom drawing code in the view layer. This can indeed
    be both difficult (see above) and irrelevant – sometimes, what's important about
    graphics isn't their "correctness" but their aesthetic qualities. You can't really
    derive an automated test for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your app really is mainly custom drawing code, then: (i) I might be willing
    to concede that most of it can''t be tested; (ii) you may need to rethink your
    architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: '*I don''t have time right now*'
  prefs: []
  type: TYPE_NORMAL
- en: There! There's a real answer to "why aren't there tests for this?" It genuinely
    can be quicker and/or cheaper to write code without tests than to create both,
    particularly if working out how to test the feature needs to be factored in. As
    I said earlier though, a full cost analysis of the testing effort should include
    the potential costs of *not having the tests*. And, as we know, trying to predict
    how many bugs will be present in untested code is hard.
  prefs: []
  type: TYPE_NORMAL
- en: So Is Test-Driven Development A Silver Bullet?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you will see later in this chapter, it is not believed that there *is* a
    silver bullet to making software. Plenty of people are happy with the results
    they get from TDD. Other people are happy with the results they get from other
    practices. My opinion is that if you are making something that solves problems
    and can demonstrate with high confidence that what you are doing is solving those
    problems, then you are making a valuable contribution. Personally, I am currently
    happy with TDD as a way to show which parts of a problem I have solved with software.
  prefs: []
  type: TYPE_NORMAL
- en: Domain-Driven Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Domain-Driven Design** (**DDD**) is a term introduced in the 2004 book *of
    the same name*—[http://domaindrivendesign.org/books/evans_2003](http://domaindrivendesign.org/books/evans_2003),
    though most of its principles have been around quite a bit longer among practitioners
    of object-oriented analysis and design. Indeed, the core of DDD can be thought
    of as deriving from the simulation techniques employed in Simula 67 – a language
    that influenced the design of C++.'
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, much software (particularly "enterprise" software) is created as
    a solution to a particular problem. Therefore, software should be designed by
    software experts in conjunction with domain experts. They should use a shared
    model of the problem domain, so that it's clear the whole team is trying to solve
    the same problem.
  prefs: []
  type: TYPE_NORMAL
- en: In an attempt to reduce communication problems, a "ubiquitous language" is defined
    – a common glossary of terms that's used throughout the documentation and the
    software. This includes the source code – classes and methods are named using
    the ubiquitous language to reflect the parts of the problem they address.
  prefs: []
  type: TYPE_NORMAL
- en: I think it was learning some of the principles of domain-driven design that
    finally made **Object-Oriented programming** (**OOP**) "click" with me (there's
    more on OOP later in this chapter). I'd been doing C and Pascal programming for
    a long time when I started to approach languages such as C++ and Java. While I
    could see that methods belonged to classes, in much the same way that modules
    work, deciding *what* should be an object, where its boundaries were, and how
    it interacted with other objects took me a long time to get to grips with.
  prefs: []
  type: TYPE_NORMAL
- en: 'At some point, I went on a training course that talked about domain modelling
    – and made it very simple. The core of it went something like this: listen to
    a domain expert describing a problem. Whenever they describe a concept in the
    problem domain with a noun, that''s a candidate class, or maybe an attribute of
    a class. Whenever something''s described as a verb, that''s a candidate for a
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: That short description of how to translate a problem specification into objects
    and actions was a huge eye-opener for me; I can't think about OOP in any other
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior-Driven Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I found it hard to decide whether to put BDD in this chapter or to discuss it
    with teamwork, because it's really an exercise in communication masquerading as
    a coding practice. But it's here, so there you go. Indeed, many of the sections
    in this chapter will skirt that boundary between coding and communication, because
    programming is a collaborative activity.
  prefs: []
  type: TYPE_NORMAL
- en: BDD is really an amalgamation of other techniques. It relies heavily on DDD
    ideas like the ubiquitous language and combines them with test-driven development.
    The main innovation is applying test-first principles at the feature level. Using
    the ubiquitous language as a **Domain-Specific Language** ([http://martinfowler.com/books/dsl.html](http://martinfowler.com/books/dsl.html)),
    the team works with the customer to express the specifications for features in
    an executable form, as an automated acceptance test. Then, the developers work
    to satisfy the conditions expressed in the acceptance tests.
  prefs: []
  type: TYPE_NORMAL
- en: My own experience has been that BDD tends to stay at the conversation level,
    not the implementation level. It's easy for an agile team (which includes its
    customers) to collaborate on the acceptance criteria for a story, and then for
    the technical members of the team to implement tests that evaluate the system
    according to those criteria. It's hard – – for the team – and I've never seen
    it happen – to collaborate on the authorship of automated tests whose outcomes
    convince the customer that the user story has been correctly built.
  prefs: []
  type: TYPE_NORMAL
- en: xDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It seems like every time there's a developer conference, there's a new **(something)-Driven
    Development** buzzword introduced. TDD; BDD; **Acceptance Test-Driven Development**—([http://www.methodsandtools.com/archive/archive.php?id=72](http://www.methodsandtools.com/archive/archive.php?id=72));
    **Model Driven Development** ([https://social.msdn.microsoft.com/Forums/azure/en-US/d9fa0158-d9c7-4a88-8ba6-a36a242e2542/model-driven-development-net?forum=dslvsarchx](https://social.msdn.microsoft.com/Forums/azure/en-US/d9fa0158-d9c7-4a88-8ba6-a36a242e2542/model-driven-development-net?forum=dslvsarchx)).
    Some people think *it's too much*—[http://scottberkun.com/2007/asshole-driven-development/](http://scottberkun.com/2007/asshole-driven-development/).
  prefs: []
  type: TYPE_NORMAL
- en: Many of the new terms are introduced by people hoping to carve out their niche
    as a trainer or consultant in the field they just defined. Many are just catchy
    names that encompass existing practices. – Indeed, TDD is really a codification
    of the test-first practices popularized by **Extreme Programming**. This doesn't
    mean that they are devoid of value though; sometimes, the part that's truly original
    is indeed novel and worth knowing about. And often, the communities that congregate
    around these techniques have their own customs and ways of working that are worth
    exploring.
  prefs: []
  type: TYPE_NORMAL
- en: Design by Contract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A little confession about one of my most recent software projects: it has a
    lot of unit tests in it. But for every test assertion, there are more than three
    assertions *in the code itself*.'
  prefs: []
  type: TYPE_NORMAL
- en: These have proven invaluable for documenting my assumptions about how the code
    is put together. While unit tests show that each method or class works as expected
    in isolation, these assertions are about ensuring that the boundaries respect
    the assumptions that are made within the methods – that is, they act as a form
    of integration test.
  prefs: []
  type: TYPE_NORMAL
- en: The assertions I've written mainly fall into three categories – testing that
    expectations are met when the method is entered, that its results are what I expected
    before it was returned, and that certain transformations done during the method
    yield results conforming to particular conditions. In developer builds, whenever
    one of these assumptions is not met, the app crashes at the failing assertion.
    I can then decide whether the method needs to be changed, or whether the way it's
    being used is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'In designing the **Eiffel language** ([http://docs.eiffel.com/book/method/object-oriented-software-construction-2nd-edition](http://docs.eiffel.com/book/method/object-oriented-software-construction-2nd-edition))
    in 1988, Bertrand Meyer formalized a "contract" comprising three distinct types
    of test that are similar to the assertions described above:'
  prefs: []
  type: TYPE_NORMAL
- en: '*preconditions* should be true on function entry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*postconditions* should be true on function exit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*invariants* remain true at all "stable" times – immediately after the constructor
    exits, and at any time that one of the object''s methods is not being executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rather than codifying these conditions as assertions, in Eiffel they''re actually
    part of a method definition. The contracts formalize the relationship between
    the caller of a method and its implementor: the caller is required to ensure that
    preconditions are met before calling the method. In return, the `callee` promises
    to satisfy the postconditions. These conditions can be inserted into the code
    by the compiler as assertions to verify that classes are behaving correctly at
    runtime. You could also imagine pointing an automated checker like **Klee** ([http://klee.github.io/getting-started/](http://klee.github.io/getting-started/)),
    at a class; it could check all the code paths of a method and report on those
    that, even though they start with the preconditions and invariants satisfied,
    do not end up meeting the postconditions or invariants.'
  prefs: []
  type: TYPE_NORMAL
- en: Meyer coined the term *Design by Contract* to refer to this practice of including
    preconditions, postconditions, and invariants in method definitions in Eiffel.
    The term is in fact a trademark that his company owns; implementations for other
    languages are called contract programming or contract coding (thankfully, not
    contract-driven development…).
  prefs: []
  type: TYPE_NORMAL
- en: As we've seen, I tend to use a poor replacement of contract programming even
    when I don't have language support for the capability. I see these contract-style
    assertions fail in development much more frequently than I see unit test failures;
    to me, contract programming is a better early warning system for bugs than TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Development by Specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is, as far as I'm aware, not a common development practice currently. But
    as a natural progression from Test-Driven Development, I think it deserves a mention
    and consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests, even when used as part of TDD, are employed in a craft way – as
    a bespoke specification for our one-of-a-kind classes. We could benefit from more
    use of these tests, substituting the static, error-prone type tests used in many
    APIs for dynamic specification tests.
  prefs: []
  type: TYPE_NORMAL
- en: A table view, for example, does not need something that merely responds to the
    data source selectors; it needs something that *behaves* like a data source. So,
    let's create some tests that any data source should satisfy, and bundle them up
    as a specification that can be tested at runtime. Notice that these aren't quite
    unit tests, in that we're not testing our data source – we're testing *any* data
    source.
  prefs: []
  type: TYPE_NORMAL
- en: A table view needs to know how many rows there are, and the content of each
    row. So, you can see that a dynamic test of a table view's data source would not
    simply test each of these methods in isolation; it would test that the data source
    could supply as many values as it said there were rows. You could imagine that,
    in languages that support design-by-contract, such as Eiffel, the specification
    of a collaborator could be part of the contract of a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'These specifications would be tested by objects at the point their collaborators
    are supplied, rather than waiting for something to fail during execution. Yes,
    this is slower than doing the error-prone type hierarchy or conformance tests
    that usually occur in a method''s precondition. No, that''s not a problem: we
    want to make it right before making it fast.'
  prefs: []
  type: TYPE_NORMAL
- en: Treating test fixtures as specifications for collaboration between objects,
    rather than (or in addition to) one-off tests for one-off classes, opens up new
    routes for collaboration between the developers of the objects. Framework vendors
    can supply specifications as enhanced documentation. Framework consumers can supply
    specifications of how they're using the frameworks as bug reports or support questions;
    vendors can add those specifications to a regression testing arsenal. Application
    authors can create specifications to send to contractors or vendors as acceptance
    tests. Vendors can demonstrate that their code is "a drop-in replacement" for
    some other code by demonstrating that both pass the same specification.
  prefs: []
  type: TYPE_NORMAL
- en: Pair programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I've pair-programmed a lot during my career, though it has only accounted for
    the minority of my time. I've also watched other people pair programming; the
    interactions between partners can make for very interesting viewing.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into what I think makes *good* pair programming, I'm going to
    describe what makes *bad* pair programming.
  prefs: []
  type: TYPE_NORMAL
- en: Back-Seat Driving Is Not Pair Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because I've been doing TDD for a while, I'm used to deliberately letting my
    code go through a little bit of a worthless phase before it gets good enough to
    integrate. Maybe I'll leave out handling a failure condition until I see it fail
    or add that in at the end. Perhaps I can't think of what to call a method so will
    name it `DoTheThing()` until I've got a clearer image.
  prefs: []
  type: TYPE_NORMAL
- en: What I have to remember is that *my partner might not work the same way*. Yes,
    it's annoying to see an unhandled condition, or a variable that isn't named according
    to my preferred convention, but is that the most urgent problem *right at this
    moment*? Probably not; the problem that the driver is currently working on has
    their attention and talking about something else is just a distraction. I should
    help them work on that and bring up other issues when it's appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more extreme form of this problem: stealing the keyboard is not pair programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Being A Silent Partner Is Not Pair Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The situation in which I most frequently see this happen is when the navigator
    (for want of a better, more general word to describe the person who isn't driving
    – though not "passenger," for obvious reasons) feels either inferior to or intimidated
    by the driver. They feel afraid of contributing or unqualified to contribute,
    because they don't want to appear stupid or fear the response to their contribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section is not for the driver in such circumstances – I''ll come on to
    that; it''s for the navigator. If you can''t see how the code does what it ought,
    maybe it doesn''t do it. If you ask about it to your partner, one of two things
    will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: You'll find a bug, which will get fixed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That bug won't exist, but you'll find out how the code addresses that issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Technically, there's a third option, which is that the driver will tell you
    to shut up. At that point, you want a book about human resources, not being a
    developer.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t ask, one of two things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The bug will exist, and won't get fixed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bug won't exist, and you won't find out how the code works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, there's a higher chance that the bug will remain in the code if you
    don't ask about it, so you should consider it your professional duty to ask.
  prefs: []
  type: TYPE_NORMAL
- en: So, Is Pair Programming Just The Balance Between Those Things?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That's an over-simplistic view of things, but yes. Pair programming works best
    when both people are involved; otherwise, one of them is redundant, even if they
    happen to be acting as a typist. How to do pair programming *well* depends on
    what you're trying to use it *for*.
  prefs: []
  type: TYPE_NORMAL
- en: Pair Programming As Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The few times I''ve used pair programming as a means to get code into an app,
    I''ve found that the simple rule to make sure both people are involved is nothing
    can happen until both people agree. This allows the driver to moderate back-seat
    driving: "That''s a good point, but let''s put it to one side until we''ve finished
    this bit." It also *requires* the driver to involve the silent partner.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Something I''m guilty of when navigating in pair programming is taking the
    helm: "Let me just show you what I mean." The **both people** rule is as much
    a rule for me as for other people, as it requires me to find better ways to describe
    what I''m thinking of than by destroying the partnership. Having a whiteboard
    available really helps.'
  prefs: []
  type: TYPE_NORMAL
- en: If the goal is to write production code, pairing works best with two people
    of roughly the same skill level in the target environment, who can take turns
    at driving. When there's an imbalance between their abilities, it turns into…
  prefs: []
  type: TYPE_NORMAL
- en: Pairing As A Coaching Practice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pairing is great as a teaching exercise. The same rule about not writing code
    until both people agree still applies, ensuring that the student discusses any
    issues with the tutor, who has the opportunity to guide the process.
  prefs: []
  type: TYPE_NORMAL
- en: I think pair coaching works best when the coach takes the navigator's seat.
    Their role is to encourage the student to ask questions, and then to be the petulant
    toddler who answers every question with another question.
  prefs: []
  type: TYPE_NORMAL
- en: Seriously. The best way I've found to help someone through a problem is to identify
    and raise the questions they should be asking themselves. It uncovers hidden assumptions,
    makes people come up with verbal arguments to support (or sometimes leads them
    to change) their position, and they end up trying to guess which questions will
    come next, meaning they have answers before they're asked. This technique is even
    useful when you have no knowledge of the subject you're coaching on – but for
    now, we'll assume that the coach programmer is the more accomplished programmer.
  prefs: []
  type: TYPE_NORMAL
- en: When the student is staring at a blank file in the IDE, questions can be very
    high-level. What does the code we're about to write interface with, and what constraints
    does that impose? Do we have a choice of the APIs we use, and if so, which shall
    we go with? The occasional "why?" helps to tease out the student's train of thought.
  prefs: []
  type: TYPE_NORMAL
- en: Action has a place in the learning process, and so sometimes the appropriate
    response is not a question but "well, let's try that." Even if your student hasn't
    hit upon what *you* think is the best solution, making a start is a quick way
    to find out which one of you is wrong about what's going to happen.
  prefs: []
  type: TYPE_NORMAL
- en: But Does It Work?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Is pair programming actually beneficial? It certainly appears to be *in the
    context of programming classes* ([http://dl.acm.org/citation.cfm?id=563353](http://dl.acm.org/citation.cfm?id=563353)),
    where pair programmers produce better software than sole programmers *and are
    more likely to get higher grades* ([http://portal.acm.org/citation.cfm?doid=611892.612006](http://portal.acm.org/citation.cfm?doid=611892.612006)).
    Whether these results can be generalized to all programmers is questionable; it'd
    be interesting to find out *why* these subjects do better when they're pairing
    and discover whether those conditions apply to more skilled programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Code Reviews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another thing it's safe to say that pair programming is *not* is a code review
    exercise; they have different goals. A code review should be conducted to discuss
    and improve existing code. Pair programming is about two people constructing some
    code *de novo*. If your pair programming is about one person writing code and
    one person saying they've done it wrong, you need to rethink your practices (or
    your partnership).
  prefs: []
  type: TYPE_NORMAL
- en: Mind you, that's true of code review when it's going badly, too. One problem
    with code reviews is that it's much easier to spot code that satisfies "I wouldn't
    have written it like that" than it is to spot code that satisfies "it should've
    been written to consider these things." This often gets in the way of getting
    useful information out of code reviews, because the reviewer gets frustrated with
    the tabs/spaces/variable names/other degenerate properties of the code.
  prefs: []
  type: TYPE_NORMAL
- en: It's problems like this that make me prefer asynchronous, distributed code reviews
    over face-to-face reviews. We frequently see that **people** ([http://programmers.stackexchange.com/questions/80469/how-to-stand-ground-when-colleagues-are-neglecting-the-process](http://programmers.stackexchange.com/questions/80469/how-to-stand-ground-when-colleagues-are-neglecting-the-process))
    *don't understand* the **motivations** ([http://thedailywtf.com](http://thedailywtf.com))
    of their colleagues. Let the reviewer work out that initial frustration and anger
    on their own – preferably, *without the author present as a punching bag*. The
    reviewer gets a chance to calm down, to acquaint themselves with the requirements,
    and to study the code in detail… This is not true of in-person reviews, where
    there's someone else in the room, waiting for the first gem of wisdom to be granted.
  prefs: []
  type: TYPE_NORMAL
- en: On the subject of face-to-face reviews, be wary of people citing the "classics"
    in this field. People espousing the benefits of code reviews will often cite **Fagan's
    paper on code inspections** ([http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5388086](http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5388086)),
    claiming that it shows a reduction in the cost of developing software after introducing
    code reviews. Well, it does. But not in any way you'd recognize from modern software
    development.
  prefs: []
  type: TYPE_NORMAL
- en: The code inspections performed in Fagan's group would, by and large, uncover
    problems that, today, would be reported by a modern IDE before you even compile
    the code. Indeed, Fagan specifically describes code being inspected *after* a
    product is written, but *before* it's submitted to the compiler. Think back to
    the last time you *completely* wrote an application before you tried building
    it. For most developers working today, that hasn't ever happened.
  prefs: []
  type: TYPE_NORMAL
- en: Fagan's reviews would've discovered things such as missing semicolons or spelling
    mistakes before a deck of punchcards was submitted to a batch compiler. That was,
    indeed, a valuable saving in terms of lost computer time and rework. For a modern
    code review, though, to be valuable, it has to save time elsewhere. The reviewer
    should be encouraged to focus on real issues at higher levels. Does the code represent
    a good abstraction? Is there an opportunity to reuse components of it elsewhere?
    Does it accurately solve the problem at hand?
  prefs: []
  type: TYPE_NORMAL
- en: The tool I've found most useful for achieving this is a checklist. A short collection
    of things the reviewer should focus on directs the review away from trivial questions
    about style and naming practice. Further, it also directs the *author* to think
    about these problems while writing code, which should make the actual review itself
    fairly short. After using the same checklist a few times, its effectiveness will
    be reduced, as everyone on the team will have a shared approach to dealing with
    the problems that appear on it. Therefore, the items on the checklist should be
    swapped in and out as old items become irrelevant and the importance of other
    problems increases.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the teams I'm working on do code reviews when integrating a piece of
    work into a release. This has worked better than scheduled reviews (the code is
    rarely baked, leading to the reviewer focusing on known rough edges) or reviews
    upon request (developers just don't ask). This is supported in tools like GitHub
    by "pull requests"—when the author wants to merge some code into an upstream branch
    or repository, they send a request, which is a chance to do the review. Other
    tools, such as **gerrit** ([http://code.google.com/p/gerrit/](http://code.google.com/p/gerrit/)),
    provide similar capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code reviews should ideally be treated as learning activities. The author should
    learn *why* the reviewer is suggesting particular changes, what the problems are,
    and why the proposed changes address those problems in ways that the code, as
    submitted to the review, did not. The reviewer should be learning too: there are
    opportunities to learn from the submitted code and practice your rhetorical skills
    by coming up with convincing arguments for why your changes should be accepted
    arguments that aren''t "because I know best." For this to work, the outcome of
    a code review must be a discussion, even if it''s a comment thread in a review
    tool. Making some additional fixes and accepting the fixed changes without discussion
    loses a lot of the benefit of having the review.'
  prefs: []
  type: TYPE_NORMAL
- en: Programming Paradigms And Their Applicability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On one (theoretically correct, though practically unpleasing) level, all software
    is just comprised of loads, stores, mathematics, and jumps, so any application
    can be written using any tool that permits the correct ordering of those basic
    operations. A key theme running through this book though, is the idea of software''s
    interpersonal nature, and here, we have a concrete example of that: the application
    source code as a source of mutual understanding between the programmers who work
    on it.'
  prefs: []
  type: TYPE_NORMAL
- en: Before exploring that though, a little diversion into history, to make an idea
    explicit so that we can leave it behind. This is the idea of successive layers
    of abstraction allowing people to build on what came before. Yes, all software
    is built out of the basic operations described above but thinking about your problem
    in terms of the computer's operations is hard. Within a few years of stored-program
    computers being invented, EDSAC programmers created an *assembler* that translated
    mnemonic operation names (such as *A* for add) into the operation `codes` used
    by the computer. Programmers could then worry just about the fact that they were
    adding things, not about which number the processor used to represent addition
    in this particular addressing mode (on computers that have more than one).
  prefs: []
  type: TYPE_NORMAL
- en: Other work, including that on macro assemblers and Grace Hopper's work on A-1
    and other compilers, let programmers move a level away from computer operations
    (even with "friendly" names) and express *what they want to happen* in a way that
    can be translated into low-level instructions. For example, a loop over some code
    with an index variable taking even values from 2 to 20 can be expressed as `FOR
    I=2 TO 20 STEP 2:…:NEXT I` rather than the initialization, test, branch, and update
    steps the computer actually needs to execute.
  prefs: []
  type: TYPE_NORMAL
- en: So, when someone solves a problem in software once, others can (legality, compatibility,
    and availability permitting) build other software on top of that solution. This
    applies to the discussion that follows objects can be built out of other objects
    and functions can be built out of other functions. Functions can be built out
    of objects and objects out of functions, too. This is not that story. This is
    the story of *stories* being built out of functions and objects; of choosing programming
    paradigms as ways to *think* about software and to *describe* thoughts about software
    to other programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it first became a popular technique in the middle of the 1980s, some people
    tried to position OOP as the solution to all of the software industry's ills (whether
    those ills existed in the forms described is probably a discussion for another
    time). Fred Brooks, a manager on IBM's infamous System/360 project, had told programmers
    that there is *no silver bullet*—[http://www.cs.nott.ac.uk/~cah/G51ISS/Documents/NoSilverBullet.html](http://www.cs.nott.ac.uk/~cah/G51ISS/Documents/NoSilverBullet.html);
    that the problems faced by the software industry are hard and no technology solution
    would make it any easier. Brad Cox asked rhetorically in response, *what if there
    is a silver bullet*—[http://dl.acm.org/citation.cfm?id=132388](http://dl.acm.org/citation.cfm?id=132388)
    (that is, object technology), and your competitors are already using it?
  prefs: []
  type: TYPE_NORMAL
- en: 'As Cox saw it (or at least positioned it in marketing his company), object-oriented
    programming was the cultural shift that would move software construction from
    a cottage industry of separate one-off craft pieces to a true engineering discipline,
    by introducing the *object* as an interchangeable component with a standard interface,
    just like the pozidrive screw or the four-by-two plank. (Software-ICs: another
    metaphor Cox used, particularly in his book *Object-Oriented Programming: An Evolutionary
    Approach*—[http://books.google.co.uk/books/about/Object_Oriented_Programming.html?id=deZQAAAAMAAJ&redir_esc=y](http://books.google.co.uk/books/about/Object_Oriented_Programming.html?id=deZQAAAAMAAJ&redir_esc=y),
    was that of the *Software Integrated Circuit*. Just as the development of computer
    hardware had accelerated by moving from assembling computers out of discrete components
    to connecting together standard ICs, he envisaged a sort of software Moore''s
    Law arising from the successive development of applications assembled from standard
    objects or Software ICs.)'
  prefs: []
  type: TYPE_NORMAL
- en: Software manufacturing companies could build these standard parts and make them
    available to an object marketplace. This would be the software equivalent of the
    trade store, where blue-collar tradesmen and do-it-yourself computer users could
    buy objects off the shelf and assemble them into the applications they needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it happens, Brooks had already pointed out that there were two classes of
    problem associated with building software: the *essential* problems that arise
    from it being a complex activity and the *accidental* problems related to the
    current processes or technology and their flaws. Object-oriented programming did
    not solve the essential problems and replaced some accidental problems with others.'
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, all of this history may be of some interest but what *is* object-oriented
    programming? The problem we need to look at is not one of manipulating data or
    of instructing the computer, but one of *organizing* that data and those instructions
    to aid (human) comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: The property of object-oriented software that distinguishes it from other techniques
    is the interrelated organization of code and the data that code acts on into autonomous
    units (the eponymous *objects*) that interact by sending each other messages.
    The argument in favor of this approach is that a programmer working on one such
    unit need only understand the *interface* of its collaborating units—the messages
    they understand along with the preconditions and results of those messages; not
    the *implementation*—how those units do what they do. A large program comprising
    many instructions is thus split into multiple independent entities that can be
    developed in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Plenty of programming languages that predate object-oriented programming already
    allow the organization of code into modules, each module having its own functions
    and data. Such modules can be restricted to communicating with each other only
    using particular interface functions. What OOP brings on top of this is the idea
    of the automaton, of the self-contained package of code and data that is independent
    both from unrelated parts of the software system and from other instances of things
    like itself. So, while a multiplayer game written in Modula-2 might have a module
    that controls the player characters and hides their details away from the rest
    of the game, were it written in an object-oriented language like Oberon-2, it
    might have an object representing each of the player characters that hides its
    internals from the rest of the game and from each other player object.
  prefs: []
  type: TYPE_NORMAL
- en: Given this desire to make a system of autonomous agents that communicate via
    messages (cpp-messages), some readers may take umbridge at the statement that
    OOP involves message sending, using languages such as C++ with its member functions
    as counter examples. Suffice it to say that the *mental model* of objects sending
    messages to each other is still useful, however the language actually implements
    it. Now, some other readers are going to dig up quotes by Alan Kay to assert that
    *only* languages with message-sending can be considered object-oriented. (If you
    dig hard enough, you'll find that, in Smalltalk, the phrase "object-oriented"
    was sometimes used to refer to the *memory management* paradigm; in other words,
    to the garbage collector. The programming model was called "message-passing."
    So, perhaps C++ with the Boehm-Demers-Weiser garbage collector truly *is* "object-oriented"
    as purists would understand it. Whatever. If you take issue with it, please find
    someone else to email.) The largest problem (if not *the* problem; the question
    being the only one introduced by adopting OOP) is choosing which objects are responsible
    for which actions. This is a difficult problem to solve; I remember getting it
    very wrong on the first object-oriented systems I created and still want to improve
    nearly a decade later. Programmers in all fields have written about heuristics
    for decomposing systems into component objects, and some people have developed
    tools to evaluate software in relation to those heuristics and to automatically
    change the composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those heuristics range from woolly concepts (the open-closed principle, the
    single responsibility principle, and others) to precisely defined mathematical
    rules (the Liskov substitution principle, the Law of Demeter, and others). Most
    (or maybe all) of these have the high-level goal of increasing the *autonomy*
    of objects in the system, reducing the extent to which they depend on the rest
    of the system. The stated benefits of doing this are: the increased reusability
    of objects across different systems, and the reduced likelihood that a given object
    will need changing in reaction to a change elsewhere in the system.'
  prefs: []
  type: TYPE_NORMAL
- en: Researchers have also found that **object-oriented software** is *harder to
    review*—[http://dl.acm.org/citation.cfm?id=337343](http://dl.acm.org/citation.cfm?id=337343)
    than structured software. The desirable design properties that lead to a connected
    system of loosely coupled objects also produce a system where it's difficult to
    discover the flow of execution; you can't easily see where control goes as a result
    of any particular message. Tools do exist that aim to address this by providing
    multiple related views of an object-oriented system, such as Code Bubbles and
    Eclipse Mylyn. These are not (yet) mainstream. Then, of course, there are the
    documents that describe object-oriented software at a high level, often expressed
    diagrammatically using a notation such as UML. The value of these documents is
    described in the *Chapter 8, Documentation*.
  prefs: []
  type: TYPE_NORMAL
- en: I find that the most interesting reading on object-oriented programming is that
    written when it was new; new to the commercial programmer anyway. It's that material
    that attempts to persuade you of the benefits of OOP, and to explain the reasoning
    behind the paradigm. Specific practices have changed significantly in the intervening
    few decades, but modern books assume that you know *why* you want to do OOP, and
    often even that you know what it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''d recommend that even readers who consider themselves experienced object-oriented
    programmers read *Object-Oriented Programming: An Evolutionary Approach*—[http://books.google.co.uk/books/about/Object_oriented_programming.html?id=U8AgAQAAIAAJ&redir_esc=y](http://books.google.co.uk/books/about/Object_oriented_programming.html?id=U8AgAQAAIAAJ&redir_esc=y))
    and **Object-Oriented Software Construction**—[http://books.google.co.uk/books?id=v1YZAQAAIAAJ&source=gbs_similarbooks](http://books.google.co.uk/books?id=v1YZAQAAIAAJ&source=gbs_similarbooks).
    These books not only tell you about particular languages (Objective-C and Eiffel,
    respectively) but also on the problems that those languages are supposed to solve.'
  prefs: []
  type: TYPE_NORMAL
- en: What you may learn from these and other foundational texts in the field is that
    the reason OOP did not succeed is not because it failed, but because it was not
    attempted. Keen to make OOP accessible, the **Object Technology** companies made
    it clear that what you were already doing was already OOP. If you know how to
    write sequential statements in C, you'll *love* writing sequential statements
    in Java, and then you'll be doing OOP.
  prefs: []
  type: TYPE_NORMAL
- en: Aspect-Oriented Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An extension to object-oriented programming that so far has not reached the
    same level of application and currency, aspect-oriented programming sets out to
    solve a particular problem in the construction of object-oriented systems. More
    specifically, the problem exists in class-based object-oriented systems with single
    inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: The previous section described the existence of many heuristics, created to
    guide the organization of code in object-based systems. One of these heuristics
    was the *Single Responsibility Principle*, which says that the code in one class
    should be responsible for just one thing. Imagine, then, a database application
    for a human resources department (almost the canonical OOP example, if recipe
    managers are ignored). One class might represent an employee, having a name, salary,
    manager, and so on. Not everyone should be able to change an employee's salary,
    so some access control will be needed. It could also be useful for auditing and
    debugging purposes to be able to log any change to an employee's salary.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are then three responsibilities: updating the database, access control,
    and auditing. The Single Responsibility Principle means that we should avoid putting
    all the responsibilities in the `Employee` class. Indeed, that would lead to a
    lot of duplication because the access control and auditing facilities would be
    needed elsewhere in the application too. They are *cross-cutting concerns*, where
    the same facilities must be provided by many, otherwise different, classes.'
  prefs: []
  type: TYPE_NORMAL
- en: While there are other ways to build these cross-cutting concerns into an application,
    aspect-oriented programming opens up configurable *join points* in an object-oriented
    system. These join points include method entry or exit, the transfer of execution
    to exception handlers, and fields being read or changed. An aspect defines the
    predicate a join point must satisfy for this aspect to be relevant (called a pointcut)
    and the code that is run at that join point (sometimes called advice).
  prefs: []
  type: TYPE_NORMAL
- en: AOP extensions are available for popular OOP environments (**AspectJ** ([http://www.eclipse.org/aspectj/](http://www.eclipse.org/aspectj/))
    for Java and **Aspect#** ([http://sourceforge.net/projects/aspectsharp/](http://sourceforge.net/projects/aspectsharp/))
    for .NET), but as previously mentioned, the style is not widely used. It adds
    further to the problem OOP already suffers from, in that it's hard to work out
    exactly what code is executed in response to a given event. Other systems, such
    as Ruby and Self (and C++), have "traits" or "mix-ins," which take the position
    of aspects but not the name.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Something that's even less new—though needed a bit of rediscovery—than object-oriented
    programming is functional programming. As the name suggests, functional programming
    is all about functions; in this case, functions in the mathematical sense of operations
    that can be applied to some input domain and produce output in a corresponding
    range. Whereas object-oriented systems describe the imperative commands the computer
    must execute, a functional program describes the functions that are applied to
    given input.
  prefs: []
  type: TYPE_NORMAL
- en: This distinction leads to some interesting departures from imperative systems
    (though these departures can be modelled in OO code, they are prevalent in FP).
    Parts of functional systems can be *lazily evaluated*; in other words, the computer,
    seeing that an x^2 result is required, can defer the computation of that result
    until it's actually used, or the CPU is quiescent. That's not so interesting for
    calculating a square but can lead to tricks like working with a list of all integers.
    In imperative code, a list of all integers would need computing when it was created,
    which is impossible to do. Functional software can define something that evaluates
    to a list of all integers, then lazily evaluate only those entries that are actually
    accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, results can be *memorized*: the result x times x for x==2 is always
    4; we know it doesn''t depend on anything else, such as the state of a database
    or what keys a user presses on the keyboard, so having calculated 2 times 2=4
    once, we can always remember it and use the answer 4 again.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Recursion* is a weapon frequently wielded in functional programs. How might
    we build a list of all integers? Let''s restrict ourselves to a list of positive
    integers. Define the `f(x)` function such that:'
  prefs: []
  type: TYPE_NORMAL
- en: If `x` is at the head of a list `l`, `f(x)=1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, `f(x)=1+f(previous entry)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, for a list with one entry, the result of applying `f` is 1\. With two
    entries, it becomes `1+f(single-entry)=2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion and lazy evaluation are both useful properties, but neither is intrinsic
    to a functional style of programming; they are merely frequently found being employed
    in such fields. A more essential part of the program-as-function model is the
    absence of side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Because mathematical functions have no side effects, the output of a function
    depends only on its input. Evangelists of functional programming say that this
    makes software easier to understand (nothing "magic" can happen), and that it
    makes for a good approach to building multi-threaded software as there can be
    no race conditions; if the input to a function can be prepared, the function can
    produce its output. If a function works well with a number as its input, it will
    work equally well with the (numeric) output of *another* function as its input;
    its execution depends only on what it receives.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, many software systems have requirements to produce side effects such
    as drawing images on a display or modifying the saved state of a database. Different
    functional programming languages then provide different techniques for *encapsulating*
    – not completely removing – mutable state. For example, stateful components of
    a software system written in Haskell will be expressed as data types that are
    the results of functions and can themselves be executed to produce the required
    side effects; in this way, stateful parts can act as sinks or sources to the functional
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming has gained a lot of popularity in the commercial sector
    in the last couple of years, primarily with the availability of functional languages
    that interface with existing (object-oriented) code; examples being **Clojure**
    ([http://clojure.org](http://clojure.org)) on the **Java Virtual Machine** (**JVM**)
    and **F#** ([https://fsharp.org/learn.html](https://fsharp.org/learn.html)) on
    the .Net VM. The principles though are a lot older—LISP was *first described in
    1958*—[http://www-formal.stanford.edu/jmc/recursive.html](http://www-formal.stanford.edu/jmc/recursive.html)
    but based on mathematical concepts that *predate the programmable computer*—[http://www.jstor.org/stable/1968337](http://www.jstor.org/stable/1968337).
    A great reference on the how and why of functional programming is **Structure
    and Interpretation of Computer Programs** ([https://web.mit.edu/alexmv/6.037/sicp.pdf](https://web.mit.edu/alexmv/6.037/sicp.pdf)),
    even though recent versions of this book use the not-at-first-glance functional
    language, Python.
  prefs: []
  type: TYPE_NORMAL
