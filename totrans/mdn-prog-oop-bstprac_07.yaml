- en: '*Chapter 5*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*'
- en: Coding Practices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码实践
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引言
- en: If you learned programming by studying a book or an online course, you probably
    sat at your computer with a text editor or IDE, solving each problem completely
    as it came. Most software teams have two additional problems to contend with—the
    applications they're writing are much larger, and there's more than one of them
    working on the product at once. In this chapter, I'll look at some common ways
    to set about the task of programming on a larger project (though, teamwork plays
    such a big part in this that it has its own chapter later in the book).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过阅读书籍或在线课程来学习编程，你可能坐在电脑前，使用文本编辑器或 IDE，完全解决每个问题。大多数软件团队都有两个额外的问题需要应对——他们正在编写的应用程序更大，并且有不止一个人同时在工作产品上。在本章中，我将探讨一些在更大项目上进行编程的常见方法（尽管，团队合作在这个问题中扮演了如此重要的角色，以至于在本书后面的章节中有一个专门的章节来讨论它）。
- en: Most of this chapter will act as a quick reference, with an inline reading list
    and a few opinions thrown in for good measure. The reason is that the concepts
    are too large to cover in detail in a single section of a novel-length book like
    this.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容将作为快速参考，包括一个内联阅读列表和一些额外的观点。原因是这些概念太大，无法在这本小说长度的一章中详细说明。
- en: Test-Driven Development
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: '**TDD** (**Test-Driven Development**) is such a big topic, plenty of books
    have been written about it. Indeed, one of those books was written by me: **Test-Driven
    iOS Development** ([http://www.pearsoned.co.uk/bookshop/detail.asp?item=100000000444373](http://www.pearsoned.co.uk/bookshop/detail.asp?item=100000000444373)).
    So, I won''t go into too much detail here. If you''ve never come across test-driven
    development before, or the phrase "red-green-refactor," I recommend **Growing
    Object-Oriented Software, Guided By Tests** ([http://www.growing-object-oriented-software.com/](http://www.growing-object-oriented-software.com/))
    (unless you''re focusing on iOS, of course).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**TDD**（**测试驱动开发**）是一个很大的话题，关于它的书籍已经有很多了。确实，其中一本书是我写的：**《测试驱动 iOS 开发**》([http://www.pearsoned.co.uk/bookshop/detail.asp?item=100000000444373](http://www.pearsoned.co.uk/bookshop/detail.asp?item=100000000444373))。所以，这里不会过多地深入细节。如果你之前从未遇到过测试驱动开发，或者“红-绿-重构”这个短语，我推荐阅读**《通过测试引导面向对象软件开发**》([http://www.growing-object-oriented-software.com/](http://www.growing-object-oriented-software.com/))（当然，除非你专注于
    iOS）。'
- en: The point of TDD
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TDD 的目的
- en: People talk about test-driven development as a way to ensure high test coverage.
    It does that, for sure. But its main utility is as a *design tool*. You can construct
    an executable specification of a module or class, based on how you need to use
    that class in your product. Often, I'll create some tests while I'm designing
    a class, but remove them as the code changes and they become obsolete.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 人们谈论测试驱动开发作为一种确保高测试覆盖率的方法。当然，它确实做到了这一点。但它的主要用途是一个 *设计工具*。你可以根据你在产品中需要如何使用该类来构建模块或类的可执行规范。通常，我会在设计类的时候创建一些测试，但随着代码的变化，它们变得过时，我会移除它们。
- en: I've delegated classes to other developers before by writing a suite of tests
    and asking them to fill in the implementation. I've left myself a failing test
    on a Friday evening, so I know what I'm supposed to be doing on Monday morning
    (the `#error` C preprocessor command, which inserts a compiler error with a custom
    message, is also useful for this). TDD has plenty of utilities beyond generating
    automated regression tests.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前通过编写一系列测试并将实现工作委托给其他开发者来分配课程。我在周五晚上留下了一个失败的测试，这样我知道周一早上应该做什么（`#error` C 预处理器命令，它通过插入带有自定义消息的编译器错误来使用，对此也很有用）。TDD
    在生成自动化回归测试之外还有很多实用工具。
- en: Notice that TDD only helps you with your design when you limit yourself to designs
    that can be (easily) achieved by doing TDD. That's no bad thing, as it means that
    everything will be designed in similar, understandable ways. It's like a magazine
    having a tone and style guide, so readers have a base level of expectations of
    any article.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，TDD 只在你将自己限制在可以通过 TDD（轻松地）实现的设计时，才能帮助你进行设计。这并不是坏事，因为它意味着所有内容都将以相似、可理解的方式进行设计。就像一本杂志有一个语气和风格指南，这样读者对任何文章都有一个基本的期望水平。
- en: Particular constraints, or at least *suggestions*, derived from allowing TDD
    to elicit design choices include that your design will probably be loosely coupled
    (that is, each module will not depend greatly on other modules in the system)
    with interchangeable dependencies injected from the outside. If your response
    to that is "great - that's what I'd want," then you'll have no problem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从允许TDD引发设计选择中得出的特定约束，或者至少是*建议*，包括你的设计可能会是松散耦合的（也就是说，每个模块不会在很大程度上依赖于系统中的其他模块）以及从外部注入的可互换依赖项。如果你的反应是“太好了——这正是我想要的”，那么你不会有任何问题。
- en: The Software I'm Writing Can't Be Tested
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我正在编写的软件无法进行测试
- en: Actually, it probably can. Apart from the sample code from the afore-mentioned
    book, there's code in every project I've written that hasn't been tested. In most
    cases, it probably *can* be tested. Let's look at some of the real reasons the
    tests haven't been written.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可能可以。除了前面提到的书中提供的示例代码外，我在写的每个项目中都有未测试的代码。在大多数情况下，它可能*确实*可以测试。让我们看看一些没有编写测试的真正原因。
- en: '*I''ve already written the code without tests, and can''t work out how to retroactively
    test it*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*我已经编写了没有测试的代码，无法想出如何进行回溯测试*'
- en: This is a common complaint. Don't let a TDD proponent smugly say "well, you
    should have written tests in the first place" – that's dogmatic and unhelpful.
    Besides, it's too late. Instead, you should decide whether you want to (and can)
    spend the time changing the code to make it amenable to testing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的抱怨。不要让TDD的支持者自鸣得意地说“好吧，你一开始就应该编写测试”，这是教条且无用的。此外，已经太晚了。相反，你应该决定你是否愿意（并且能够）花时间更改代码，使其易于测试。
- en: It's not just time, of course; there's a risk associated with any change to
    software. – As mentioned elsewhere in this book, any code you write is a liability,
    not an asset. The decision regarding whether or not you adapt the code to support
    tests' adaptation should consider not only the cost of doing the work, but the
    potential risk of doing it. (I'm deliberately calling this work "adaptation" rather
    than "refactoring." Refactoring means to change the structure of a module without
    affecting its behavior. Until you have the tests in place, you cannot guarantee
    that the behavior is unchanged.) These need to be balanced against the potential
    benefits of having the code under test, and the opportunity cost of not getting
    the code into shape when you get the chance.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不仅仅是时间；任何软件的任何更改都存在风险。 – 正如本书其他地方提到的，你编写的任何代码都是一种负债，而不是资产。关于是否将代码适应以支持测试的适应性的决定，应考虑的不仅仅是工作的成本，还有执行工作的潜在风险。（我故意将这项工作称为“适应”而不是“重构”。重构意味着在不影响行为的情况下更改模块的结构。在你设置测试之前，你不能保证行为没有改变。）这些需要与代码在测试下的潜在好处以及错过将代码整理好的机会成本相平衡。
- en: If you decide you *do* want to go ahead with the changes, you should plan your
    approach so that the work done to support the tests is not too invasive. You don't
    want to change the behavior of the software until you can see whether such changes
    reflect your expectations. A great resource for this is Michael Feathers' **Working
    Effectively With Legacy Code** ([https://c2.com/cgi/wiki?WorkingEffectivelyWithLegacyCode](https://c2.com/cgi/wiki?WorkingEffectivelyWithLegacyCode)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定*确实*想要继续进行这些更改，你应该规划你的方法，以确保为测试所做的支持工作不会过于侵入性。在你看到这些更改是否反映了你的期望之前，你不想改变软件的行为。在这方面，迈克尔·费瑟斯的《**与遗留代码有效工作**》([https://c2.com/cgi/wiki?WorkingEffectivelyWithLegacyCode](https://c2.com/cgi/wiki?WorkingEffectivelyWithLegacyCode))是一本很好的资源。
- en: '*I don''t know how to test that API/design/whatever*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*我不知道如何测试那个API/设计/等等*'
- en: Often, "this can't be tested" comes down to "I don't know how this could be
    tested." Sometimes, it's actually true that some particular API doesn't lend itself
    to being used in isolation. A good example is low-level graphics code, which often
    expects that some context exists into which you're drawing. It can be very hard
    (if indeed it's possible at all) to reproduce this context in a way that allows
    a test harness to capture and inspect the drawing commands.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，“这个无法测试”归结为“我不知道如何测试它。”有时，确实存在某些特定的API不适合独立使用的情况。一个很好的例子是低级图形代码，它通常期望存在一个你正在绘制的上下文。在一种方式下重现这个上下文，以便测试框架捕获和检查绘图命令，这可能非常困难（如果确实可能的话）。
- en: You can provide such an inspection capability by wrapping the problematic API
    in an interface of your own design. Then, you can swap that out for a testable
    implementation – or for an alternative API, if that becomes desirable. OK, the
    adaptor class you wrote probably can't be tested still, but it should be thin
    enough for that to be a low risk.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将问题API包装在你自己设计的接口中来提供这种检查能力。然后，你可以用可测试的实现来替换它——或者如果需要，用替代API。好吧，你写的适配器类可能仍然无法进行测试，但它应该足够薄，以至于风险很低。
- en: In other cases, there is a way to test the code that can be brought out with
    a bit of thought. I'm often told that an app with a lot of GUI code can't be tested.
    Why not?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，通过一点思考，可以找到测试代码的方法。我经常被告知，带有大量GUI代码的应用程序无法进行测试。为什么不能呢？
- en: 'What''s in a GUI app? For a start, there are a load of data models and "business"
    logic that would be the same in any other context and can easily be tested. Then,
    there''s the interaction with the UI: the "controller" layer in the MVC world.
    That''s code that reacts to events coming from the UI by triggering changes in
    the model and reacts to events coming from the model by updating the view. That''s
    easy to test too, by simulating the events and ensuring that the controller responds
    to them correctly; mocking the "other end" of the interaction.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: GUI应用程序中有什么？首先，有大量的数据模型和“业务”逻辑，这些在其他任何上下文中都是相同的，并且可以轻松地进行测试。然后，是与UI的交互：MVC世界中的“控制器”层。这是通过触发模型中的变化来响应来自UI的事件，并通过更新视图来响应来自模型的事件的代码。这也很容易测试，通过模拟事件并确保控制器正确地响应它们；模拟交互的“另一端”。
- en: This just leaves any custom drawing code in the view layer. This can indeed
    be both difficult (see above) and irrelevant – sometimes, what's important about
    graphics isn't their "correctness" but their aesthetic qualities. You can't really
    derive an automated test for that.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就只剩下视图层中的任何自定义绘图代码了。这确实可能既困难（见上文）又无关紧要——有时，图形的重要性不在于它们的“正确性”，而在于它们的美学品质。你无法真正为这一点推导出自动测试。
- en: 'If your app really is mainly custom drawing code, then: (i) I might be willing
    to concede that most of it can''t be tested; (ii) you may need to rethink your
    architecture.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序确实主要是自定义绘图代码，那么：（i）我可能愿意承认其中大部分无法进行测试；（ii）你可能需要重新思考你的架构。
- en: '*I don''t have time right now*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*我现在没有时间*'
- en: There! There's a real answer to "why aren't there tests for this?" It genuinely
    can be quicker and/or cheaper to write code without tests than to create both,
    particularly if working out how to test the feature needs to be factored in. As
    I said earlier though, a full cost analysis of the testing effort should include
    the potential costs of *not having the tests*. And, as we know, trying to predict
    how many bugs will be present in untested code is hard.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧！这就是“为什么没有对这个进行测试？”的真正答案。实际上，编写没有测试的代码可能比创建测试更快、更便宜，尤其是如果需要考虑如何测试该功能的话。然而，正如我之前所说的，对测试努力的全面成本分析应该包括没有测试可能带来的潜在成本。而且，正如我们所知，预测未测试代码中可能存在的错误数量是困难的。
- en: So Is Test-Driven Development A Silver Bullet?
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 那么，测试驱动开发是不是一个银弹？
- en: As you will see later in this chapter, it is not believed that there *is* a
    silver bullet to making software. Plenty of people are happy with the results
    they get from TDD. Other people are happy with the results they get from other
    practices. My opinion is that if you are making something that solves problems
    and can demonstrate with high confidence that what you are doing is solving those
    problems, then you are making a valuable contribution. Personally, I am currently
    happy with TDD as a way to show which parts of a problem I have solved with software.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在本章后面看到的那样，人们并不相信存在一个制作软件的银弹。很多人对TDD得到的结果感到满意。其他人则对其他实践得到的结果感到满意。我的观点是，如果你正在制作解决问题的东西，并且可以非常有信心地证明你所做的是在解决问题，那么你就在做出有价值的贡献。就我个人而言，我目前对TDD作为一种展示我如何用软件解决问题各个部分的方法感到满意。
- en: Domain-Driven Design
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域驱动设计
- en: '**Domain-Driven Design** (**DDD**) is a term introduced in the 2004 book *of
    the same name*—[http://domaindrivendesign.org/books/evans_2003](http://domaindrivendesign.org/books/evans_2003),
    though most of its principles have been around quite a bit longer among practitioners
    of object-oriented analysis and design. Indeed, the core of DDD can be thought
    of as deriving from the simulation techniques employed in Simula 67 – a language
    that influenced the design of C++.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（**DDD**）这个术语是在2004年出版的同名书中提出的——[http://domaindrivendesign.org/books/evans_2003](http://domaindrivendesign.org/books/evans_2003)，尽管其大部分原则在面向对象分析和设计实践者中已经存在了相当长的时间。实际上，DDD的核心可以被认为是源自Simula
    67中使用的模拟技术——这是一种影响了C++设计的语言。'
- en: Simply put, much software (particularly "enterprise" software) is created as
    a solution to a particular problem. Therefore, software should be designed by
    software experts in conjunction with domain experts. They should use a shared
    model of the problem domain, so that it's clear the whole team is trying to solve
    the same problem.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，许多软件（尤其是“企业”软件）都是作为特定问题的解决方案而创建的。因此，软件应由软件专家与领域专家共同设计。他们应该使用一个共享的问题域模型，这样整个团队都在努力解决同一个问题。
- en: In an attempt to reduce communication problems, a "ubiquitous language" is defined
    – a common glossary of terms that's used throughout the documentation and the
    software. This includes the source code – classes and methods are named using
    the ubiquitous language to reflect the parts of the problem they address.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少沟通问题，定义了一个“通用语言”——一个在文档和软件中使用的通用术语表。这包括源代码——类和方法使用通用语言命名，以反映它们解决的问题部分。
- en: I think it was learning some of the principles of domain-driven design that
    finally made **Object-Oriented programming** (**OOP**) "click" with me (there's
    more on OOP later in this chapter). I'd been doing C and Pascal programming for
    a long time when I started to approach languages such as C++ and Java. While I
    could see that methods belonged to classes, in much the same way that modules
    work, deciding *what* should be an object, where its boundaries were, and how
    it interacted with other objects took me a long time to get to grips with.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为是学习领域驱动设计的一些原则最终让我对**面向对象编程**（**OOP**）有了“点击”的感觉（本章后面还有更多关于OOP的内容）。当我开始接触C++和Java等语言时，我已经做了很长时间的C和Pascal编程。虽然我能看到方法属于类，就像模块一样工作，但决定**什么**应该是一个对象，它的边界在哪里，以及它如何与其他对象交互，这让我花了很长时间才掌握。
- en: 'At some point, I went on a training course that talked about domain modelling
    – and made it very simple. The core of it went something like this: listen to
    a domain expert describing a problem. Whenever they describe a concept in the
    problem domain with a noun, that''s a candidate class, or maybe an attribute of
    a class. Whenever something''s described as a verb, that''s a candidate for a
    method.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，我参加了一个关于领域建模的培训课程——它使这个过程变得非常简单。其核心内容大致如下：倾听领域专家描述一个问题。每当他们用名词描述问题域中的概念时，那就是一个候选类，或者可能是类的属性。每当某事被描述为动词时，那就是一个方法候选。
- en: That short description of how to translate a problem specification into objects
    and actions was a huge eye-opener for me; I can't think about OOP in any other
    way.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将问题规范转换为对象和动作的简短描述对我来说是一个巨大的启发；我无法用其他方式思考面向对象编程。
- en: Behavior-Driven Development
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: I found it hard to decide whether to put BDD in this chapter or to discuss it
    with teamwork, because it's really an exercise in communication masquerading as
    a coding practice. But it's here, so there you go. Indeed, many of the sections
    in this chapter will skirt that boundary between coding and communication, because
    programming is a collaborative activity.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现很难决定是把BDD（行为驱动开发）放在这一章，还是与团队合作一起讨论，因为它实际上是一种伪装成编码实践的沟通练习。但无论如何，它就在这里。确实，本章中的许多部分都会在编码和沟通之间徘徊，因为编程是一种协作活动。
- en: BDD is really an amalgamation of other techniques. It relies heavily on DDD
    ideas like the ubiquitous language and combines them with test-driven development.
    The main innovation is applying test-first principles at the feature level. Using
    the ubiquitous language as a **Domain-Specific Language** ([http://martinfowler.com/books/dsl.html](http://martinfowler.com/books/dsl.html)),
    the team works with the customer to express the specifications for features in
    an executable form, as an automated acceptance test. Then, the developers work
    to satisfy the conditions expressed in the acceptance tests.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: BDD实际上是一种其他技术的融合。它严重依赖于DDD（领域驱动设计）的理念，如通用语言，并将它们与测试驱动开发相结合。主要创新是在功能级别应用测试优先原则。使用通用语言作为**领域特定语言**（[http://martinfowler.com/books/dsl.html](http://martinfowler.com/books/dsl.html)），团队与客户合作，以可执行的形式表达功能规格，作为自动验收测试。然后，开发者努力满足验收测试中表达的条件。
- en: My own experience has been that BDD tends to stay at the conversation level,
    not the implementation level. It's easy for an agile team (which includes its
    customers) to collaborate on the acceptance criteria for a story, and then for
    the technical members of the team to implement tests that evaluate the system
    according to those criteria. It's hard – – for the team – and I've never seen
    it happen – to collaborate on the authorship of automated tests whose outcomes
    convince the customer that the user story has been correctly built.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我自己的经验是，BDD往往停留在对话层面，而不是实施层面。敏捷团队（包括其客户）很容易就故事的可接受标准进行合作，然后技术团队成员根据这些标准实施评估系统的测试。对于团队来说，合作编写自动化测试，其结果让客户确信用户故事已被正确构建，这是很难的——我从未见过这种情况发生。
- en: xDD
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: xDD
- en: It seems like every time there's a developer conference, there's a new **(something)-Driven
    Development** buzzword introduced. TDD; BDD; **Acceptance Test-Driven Development**—([http://www.methodsandtools.com/archive/archive.php?id=72](http://www.methodsandtools.com/archive/archive.php?id=72));
    **Model Driven Development** ([https://social.msdn.microsoft.com/Forums/azure/en-US/d9fa0158-d9c7-4a88-8ba6-a36a242e2542/model-driven-development-net?forum=dslvsarchx](https://social.msdn.microsoft.com/Forums/azure/en-US/d9fa0158-d9c7-4a88-8ba6-a36a242e2542/model-driven-development-net?forum=dslvsarchx)).
    Some people think *it's too much*—[http://scottberkun.com/2007/asshole-driven-development/](http://scottberkun.com/2007/asshole-driven-development/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎每次开发者大会都会出现一个新的**（某种）驱动开发**的流行词汇。TDD；BDD；**验收测试驱动开发**（[http://www.methodsandtools.com/archive/archive.php?id=72](http://www.methodsandtools.com/archive/archive.php?id=72)）；**模型驱动开发**（[https://social.msdn.microsoft.com/Forums/azure/en-US/d9fa0158-d9c7-4a88-8ba6-a36a242e2542/model-driven-development-net?forum=dslvsarchx](https://social.msdn.microsoft.com/Forums/azure/en-US/d9fa0158-d9c7-4a88-8ba6-a36a242e2542/model-driven-development-net?forum=dslvsarchx)）。有些人认为*这太多了*——[http://scottberkun.com/2007/asshole-driven-development/](http://scottberkun.com/2007/asshole-driven-development/)。
- en: Many of the new terms are introduced by people hoping to carve out their niche
    as a trainer or consultant in the field they just defined. Many are just catchy
    names that encompass existing practices. – Indeed, TDD is really a codification
    of the test-first practices popularized by **Extreme Programming**. This doesn't
    mean that they are devoid of value though; sometimes, the part that's truly original
    is indeed novel and worth knowing about. And often, the communities that congregate
    around these techniques have their own customs and ways of working that are worth
    exploring.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 许多新术语都是由那些希望在他们刚刚定义的领域内开辟自己的一片天地的人引入的。许多只是吸引人的名字，涵盖了现有的实践。——的确，TDD实际上是**极限编程**中流行的测试优先实践的编码化。但这并不意味着它们没有价值；有时，真正原创的部分确实是新颖的，值得了解。而且，围绕这些技术聚集的社区有自己的习俗和工作方式，值得探索。
- en: Design by Contract
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计由合同
- en: 'A little confession about one of my most recent software projects: it has a
    lot of unit tests in it. But for every test assertion, there are more than three
    assertions *in the code itself*.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我最近的一个软件项目，我有点儿坦白：里面有很多单元测试。但是，对于每一个测试断言，代码本身中都有超过三个断言。
- en: These have proven invaluable for documenting my assumptions about how the code
    is put together. While unit tests show that each method or class works as expected
    in isolation, these assertions are about ensuring that the boundaries respect
    the assumptions that are made within the methods – that is, they act as a form
    of integration test.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对于记录我对代码如何组合的假设非常有价值。虽然单元测试表明每个方法或类在独立工作时都按预期工作，但这些断言是确保边界尊重方法内部所做的假设——也就是说，它们充当了一种集成测试的形式。
- en: The assertions I've written mainly fall into three categories – testing that
    expectations are met when the method is entered, that its results are what I expected
    before it was returned, and that certain transformations done during the method
    yield results conforming to particular conditions. In developer builds, whenever
    one of these assumptions is not met, the app crashes at the failing assertion.
    I can then decide whether the method needs to be changed, or whether the way it's
    being used is wrong.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我所写的断言主要分为三类——测试当方法进入时期望是否得到满足，其结果是否如我在返回之前所期望，以及方法执行期间进行的某些转换是否产生符合特定条件的结果。在开发者构建中，每当这些假设中有一个未得到满足时，应用程序会在失败的断言处崩溃。然后我可以决定是否需要更改该方法，或者它被使用的这种方式是否错误。
- en: 'In designing the **Eiffel language** ([http://docs.eiffel.com/book/method/object-oriented-software-construction-2nd-edition](http://docs.eiffel.com/book/method/object-oriented-software-construction-2nd-edition))
    in 1988, Bertrand Meyer formalized a "contract" comprising three distinct types
    of test that are similar to the assertions described above:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在1988年设计**Eiffel语言**([http://docs.eiffel.com/book/method/object-oriented-software-construction-2nd-edition](http://docs.eiffel.com/book/method/object-oriented-software-construction-2nd-edition))时，Bertrand
    Meyer将一个包含三种不同类型测试的“合同”形式化，这些测试与上述断言类似：
- en: '*preconditions* should be true on function entry'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*前置条件*应在函数进入时为真'
- en: '*postconditions* should be true on function exit'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*后置条件*应在函数退出时为真'
- en: '*invariants* remain true at all "stable" times – immediately after the constructor
    exits, and at any time that one of the object''s methods is not being executed.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不变性*在所有“稳定”时刻都保持为真——在构造函数退出后，以及在任何对象的方法没有被执行的时刻。 '
- en: 'Rather than codifying these conditions as assertions, in Eiffel they''re actually
    part of a method definition. The contracts formalize the relationship between
    the caller of a method and its implementor: the caller is required to ensure that
    preconditions are met before calling the method. In return, the `callee` promises
    to satisfy the postconditions. These conditions can be inserted into the code
    by the compiler as assertions to verify that classes are behaving correctly at
    runtime. You could also imagine pointing an automated checker like **Klee** ([http://klee.github.io/getting-started/](http://klee.github.io/getting-started/)),
    at a class; it could check all the code paths of a method and report on those
    that, even though they start with the preconditions and invariants satisfied,
    do not end up meeting the postconditions or invariants.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与将条件编码为断言不同，在Eiffel中，它们实际上是方法定义的一部分。合同形式化了方法调用者与其实现者之间的关系：调用者需要在调用方法之前确保满足前置条件。作为回报，`被调用者`承诺满足后置条件。这些条件可以通过编译器插入到代码中作为断言，以验证类在运行时是否表现正确。你也可以想象将一个自动检查器，如**Klee**([http://klee.github.io/getting-started/](http://klee.github.io/getting-started/))，指向一个类；它可以检查方法的所有代码路径，并报告那些即使它们从满足前置条件和不变性开始，但最终没有满足后置条件或不变性的路径。
- en: Meyer coined the term *Design by Contract* to refer to this practice of including
    preconditions, postconditions, and invariants in method definitions in Eiffel.
    The term is in fact a trademark that his company owns; implementations for other
    languages are called contract programming or contract coding (thankfully, not
    contract-driven development…).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Meyer创造了*设计合同*这个术语来指代在Eiffel方法定义中包含前置条件、后置条件和不变性的做法。实际上，这个术语是他的公司拥有的商标；其他语言的实现被称为合同编程或合同编码（幸运的是，不是合同驱动开发…）。
- en: As we've seen, I tend to use a poor replacement of contract programming even
    when I don't have language support for the capability. I see these contract-style
    assertions fail in development much more frequently than I see unit test failures;
    to me, contract programming is a better early warning system for bugs than TDD.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，即使没有语言支持这种功能，我也倾向于使用合同编程的糟糕替代品。我发现这些合同式断言在开发中失败得比单元测试失败得多；对我来说，合同编程是比TDD更好的早期警告系统。
- en: Development by Specification
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按规格开发
- en: This is, as far as I'm aware, not a common development practice currently. But
    as a natural progression from Test-Driven Development, I think it deserves a mention
    and consideration.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 据我所知，这目前不是一种常见的开发实践。但作为测试驱动开发的自然发展，我认为它值得提及和考虑。
- en: Unit tests, even when used as part of TDD, are employed in a craft way – as
    a bespoke specification for our one-of-a-kind classes. We could benefit from more
    use of these tests, substituting the static, error-prone type tests used in many
    APIs for dynamic specification tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试，即使作为TDD的一部分使用，也是以定制的方式使用的——作为我们独特类别的定制规范。我们可以从更多地使用这些测试中受益，用动态规范测试来替代许多API中使用的静态、易出错的类型测试。
- en: A table view, for example, does not need something that merely responds to the
    data source selectors; it needs something that *behaves* like a data source. So,
    let's create some tests that any data source should satisfy, and bundle them up
    as a specification that can be tested at runtime. Notice that these aren't quite
    unit tests, in that we're not testing our data source – we're testing *any* data
    source.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表视图不需要仅仅响应数据源选择器的某些东西；它需要的是像数据源一样*行为*的东西。所以，让我们创建一些任何数据源都应该满足的测试，并将它们捆绑成一个可以在运行时测试的规范。请注意，这些并不是真正的单元测试，因为我们不是在测试我们的数据源——我们在测试*任何*数据源。
- en: A table view needs to know how many rows there are, and the content of each
    row. So, you can see that a dynamic test of a table view's data source would not
    simply test each of these methods in isolation; it would test that the data source
    could supply as many values as it said there were rows. You could imagine that,
    in languages that support design-by-contract, such as Eiffel, the specification
    of a collaborator could be part of the contract of a class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表视图需要知道有多少行，以及每行的内容。因此，你可以看到，对表视图数据源的动态测试并不仅仅是单独测试这些方法；它还会测试数据源能否提供它所说的行数那么多值。你可以想象，在支持设计-by-contract的语言中，例如Eiffel，合作者的规范可以是类合同的一部分。
- en: 'These specifications would be tested by objects at the point their collaborators
    are supplied, rather than waiting for something to fail during execution. Yes,
    this is slower than doing the error-prone type hierarchy or conformance tests
    that usually occur in a method''s precondition. No, that''s not a problem: we
    want to make it right before making it fast.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规范将在协作者提供时由对象进行测试，而不是等待在执行过程中出现失败。是的，这比通常在方法的前置条件中发生的易出错的类型层次或一致性测试要慢。不，这不是问题：我们希望在让它变得快速之前先让它变得正确。
- en: Treating test fixtures as specifications for collaboration between objects,
    rather than (or in addition to) one-off tests for one-off classes, opens up new
    routes for collaboration between the developers of the objects. Framework vendors
    can supply specifications as enhanced documentation. Framework consumers can supply
    specifications of how they're using the frameworks as bug reports or support questions;
    vendors can add those specifications to a regression testing arsenal. Application
    authors can create specifications to send to contractors or vendors as acceptance
    tests. Vendors can demonstrate that their code is "a drop-in replacement" for
    some other code by demonstrating that both pass the same specification.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试用例视为对象之间协作的规范，而不是（或除了）为特定类进行的单一测试，为开发者之间的协作开辟了新的途径。框架供应商可以提供作为增强文档的规范。框架消费者可以提供他们如何使用框架的规范作为错误报告或支持问题；供应商可以将这些规范添加到回归测试工具中。应用程序作者可以创建规范发送给承包商或供应商作为验收测试。供应商可以通过证明他们的代码是某些其他代码的“即插即用”替代品来展示他们的代码。
- en: Pair programming
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结对编程
- en: I've pair-programmed a lot during my career, though it has only accounted for
    the minority of my time. I've also watched other people pair programming; the
    interactions between partners can make for very interesting viewing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，我进行了很多结对编程，尽管它只占我时间的少数部分。我也观察过其他人进行结对编程；合作伙伴之间的互动可以是非常有趣的观看。
- en: Before diving into what I think makes *good* pair programming, I'm going to
    describe what makes *bad* pair programming.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨我认为的*良好*结对编程之前，我将描述一下*不良*结对编程的特点。
- en: Back-Seat Driving Is Not Pair Programming
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后排驾驶并非结对编程
- en: Because I've been doing TDD for a while, I'm used to deliberately letting my
    code go through a little bit of a worthless phase before it gets good enough to
    integrate. Maybe I'll leave out handling a failure condition until I see it fail
    or add that in at the end. Perhaps I can't think of what to call a method so will
    name it `DoTheThing()` until I've got a clearer image.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我已经做了很长时间的TDD，我习惯于故意让我的代码在足够好以集成之前经历一段无价值的阶段。也许我会等到看到它失败后再处理失败条件，或者最后再添加它。也许我想不出一个方法名，所以会先命名为`DoTheThing()`，直到我有一个更清晰的图像。
- en: What I have to remember is that *my partner might not work the same way*. Yes,
    it's annoying to see an unhandled condition, or a variable that isn't named according
    to my preferred convention, but is that the most urgent problem *right at this
    moment*? Probably not; the problem that the driver is currently working on has
    their attention and talking about something else is just a distraction. I should
    help them work on that and bring up other issues when it's appropriate.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须记住的是，*我的搭档可能不会以同样的方式工作*。是的，看到未处理的条件或未按照我偏好的约定命名的变量很烦人，但那是不是现在最紧迫的问题？可能不是；司机目前正在处理的问题吸引了他们的注意力，谈论其他事情只是分心。我应该帮助他们工作，并在适当的时候提出其他问题。
- en: 'A more extreme form of this problem: stealing the keyboard is not pair programming.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题的更极端形式：偷走键盘并不是结对编程。
- en: Being A Silent Partner Is Not Pair Programming
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为一名沉默的搭档并不是结对编程
- en: The situation in which I most frequently see this happen is when the navigator
    (for want of a better, more general word to describe the person who isn't driving
    – though not "passenger," for obvious reasons) feels either inferior to or intimidated
    by the driver. They feel afraid of contributing or unqualified to contribute,
    because they don't want to appear stupid or fear the response to their contribution.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我最常看到这种情况发生的情况是，领航员（由于没有更好的、更通用的词来描述那个不驾驶的人——尽管不是“乘客”，很明显的原因）感到自己不如司机，或者被司机吓到了。他们害怕贡献，或者觉得自己不够资格贡献，因为他们不想显得愚蠢或害怕对他们的贡献的反应。
- en: 'This section is not for the driver in such circumstances – I''ll come on to
    that; it''s for the navigator. If you can''t see how the code does what it ought,
    maybe it doesn''t do it. If you ask about it to your partner, one of two things
    will happen:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分不是为在这种情况下开车的司机准备的——我稍后会提到；这是为领航员准备的。如果你看不出代码是如何做到它应该做到的，也许它根本就没有做到。如果你向你的搭档询问，可能会发生以下两种情况：
- en: You'll find a bug, which will get fixed
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会发现一个错误，它将被修复
- en: That bug won't exist, but you'll find out how the code addresses that issue
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个错误根本不存在，但你将了解到代码是如何处理那个问题的
- en: (Technically, there's a third option, which is that the driver will tell you
    to shut up. At that point, you want a book about human resources, not being a
    developer.)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: （技术上，还有第三种选择，即司机可能会告诉你闭嘴。到那时，你想要一本关于人力资源的书，而不是成为一名开发者。）
- en: 'If you don''t ask, one of two things happen:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有询问，可能会发生以下两种情况：
- en: The bug will exist, and won't get fixed
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个错误将存在，并且不会被修复
- en: The bug won't exist, and you won't find out how the code works
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个错误根本不存在，你也不会了解到代码是如何工作的
- en: In short, there's a higher chance that the bug will remain in the code if you
    don't ask about it, so you should consider it your professional duty to ask.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果你不询问，错误更有可能留在代码中，所以你应该考虑这是你的职业责任去询问。
- en: So, Is Pair Programming Just The Balance Between Those Things?
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 那么，结对编程仅仅是那些事物之间的平衡吗？
- en: That's an over-simplistic view of things, but yes. Pair programming works best
    when both people are involved; otherwise, one of them is redundant, even if they
    happen to be acting as a typist. How to do pair programming *well* depends on
    what you're trying to use it *for*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那是对事情的一种过于简化的看法，但是的。结对编程在两个人都参与时效果最好；否则，其中一个人可能是多余的，即使他们碰巧在充当打字员。如何*良好地*进行结对编程取决于你试图用它来做什么。
- en: Pair Programming As Programming
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结对编程作为编程
- en: 'The few times I''ve used pair programming as a means to get code into an app,
    I''ve found that the simple rule to make sure both people are involved is nothing
    can happen until both people agree. This allows the driver to moderate back-seat
    driving: "That''s a good point, but let''s put it to one side until we''ve finished
    this bit." It also *requires* the driver to involve the silent partner.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我很少使用结对编程作为将代码放入应用程序的手段，我发现确保两个人都参与的简单规则是：直到两个人都同意，任何事情都不会发生。这允许司机调节副驾驶的行为：“那是个好点子，但让我们把它放在一边，直到我们完成这部分。”这也*要求*司机让沉默的搭档参与。
- en: 'Something I''m guilty of when navigating in pair programming is taking the
    helm: "Let me just show you what I mean." The **both people** rule is as much
    a rule for me as for other people, as it requires me to find better ways to describe
    what I''m thinking of than by destroying the partnership. Having a whiteboard
    available really helps.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行配对编程时，我常常会犯的错误是掌舵：“让我给你展示一下我的意思。”**双方**的规则对我来说和其他人一样重要，因为它要求我找到比破坏合作关系更好的方式来描述我的想法。有一个白板真的很有帮助。
- en: If the goal is to write production code, pairing works best with two people
    of roughly the same skill level in the target environment, who can take turns
    at driving. When there's an imbalance between their abilities, it turns into…
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标是编写生产代码，配对在两个技能水平大致相同的人之间进行时效果最好，他们可以轮流驾驶。当他们的能力之间存在不平衡时，它就会变成……
- en: Pairing As A Coaching Practice
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配对作为一种辅导实践
- en: Pairing is great as a teaching exercise. The same rule about not writing code
    until both people agree still applies, ensuring that the student discusses any
    issues with the tutor, who has the opportunity to guide the process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 配对作为教学练习非常出色。关于在两人都同意之前不写代码的规则仍然适用，这确保了学生能够与导师讨论任何问题，导师有机会引导这个过程。
- en: I think pair coaching works best when the coach takes the navigator's seat.
    Their role is to encourage the student to ask questions, and then to be the petulant
    toddler who answers every question with another question.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为当教练坐在导航员的位置上时，配对辅导效果最好。他们的角色是鼓励学生提问，然后成为那个用另一个问题回答每个问题的任性的幼儿。
- en: Seriously. The best way I've found to help someone through a problem is to identify
    and raise the questions they should be asking themselves. It uncovers hidden assumptions,
    makes people come up with verbal arguments to support (or sometimes leads them
    to change) their position, and they end up trying to guess which questions will
    come next, meaning they have answers before they're asked. This technique is even
    useful when you have no knowledge of the subject you're coaching on – but for
    now, we'll assume that the coach programmer is the more accomplished programmer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 严肃地说。我发现帮助某人通过问题的最好方法是识别并提出他们应该问自己的问题。这揭示了隐藏的假设，让人们提出口头论据来支持（有时引导他们改变）他们的立场，最终他们会尝试猜测接下来会问哪些问题，这意味着他们在被问之前就有了答案。这种技巧在你对辅导的主题一无所知时也非常有用——但到目前为止，我们假设教练程序员是更有经验的程序员。
- en: When the student is staring at a blank file in the IDE, questions can be very
    high-level. What does the code we're about to write interface with, and what constraints
    does that impose? Do we have a choice of the APIs we use, and if so, which shall
    we go with? The occasional "why?" helps to tease out the student's train of thought.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当学生盯着IDE中的空白文件时，问题可以非常高级。我们即将编写的代码将接口于何处，它又强加什么约束？我们是否有选择我们使用的API，如果有，我们应该选择哪一个？偶尔的“为什么？”有助于揭示学生的思维过程。
- en: Action has a place in the learning process, and so sometimes the appropriate
    response is not a question but "well, let's try that." Even if your student hasn't
    hit upon what *you* think is the best solution, making a start is a quick way
    to find out which one of you is wrong about what's going to happen.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 行动在学习过程中有它的位置，因此有时适当的回应不是一个问题，而是“好吧，让我们试试看。”即使你的学生还没有找到你认为最好的解决方案，开始尝试也是快速找出哪一方对将要发生的事情判断错误的好方法。
- en: But Does It Work?
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 但它有效吗？
- en: Is pair programming actually beneficial? It certainly appears to be *in the
    context of programming classes* ([http://dl.acm.org/citation.cfm?id=563353](http://dl.acm.org/citation.cfm?id=563353)),
    where pair programmers produce better software than sole programmers *and are
    more likely to get higher grades* ([http://portal.acm.org/citation.cfm?doid=611892.612006](http://portal.acm.org/citation.cfm?doid=611892.612006)).
    Whether these results can be generalized to all programmers is questionable; it'd
    be interesting to find out *why* these subjects do better when they're pairing
    and discover whether those conditions apply to more skilled programmers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 配对编程实际上有益吗？它在编程课程的环境中显然是有益的（[http://dl.acm.org/citation.cfm?id=563353](http://dl.acm.org/citation.cfm?id=563353))，其中配对程序员生产的软件比单独程序员更好，并且更有可能获得更高的分数（[http://portal.acm.org/citation.cfm?doid=611892.612006](http://portal.acm.org/citation.cfm?doid=611892.612006))。这些结果是否可以推广到所有程序员是有疑问的；了解为什么这些主题在配对时表现更好，以及这些条件是否适用于更熟练的程序员将很有趣。
- en: Code Reviews
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码审查
- en: Another thing it's safe to say that pair programming is *not* is a code review
    exercise; they have different goals. A code review should be conducted to discuss
    and improve existing code. Pair programming is about two people constructing some
    code *de novo*. If your pair programming is about one person writing code and
    one person saying they've done it wrong, you need to rethink your practices (or
    your partnership).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件可以肯定的是，结对编程**不是**代码审查练习；它们有不同的目标。代码审查应该进行以讨论和改进现有代码。结对编程是关于两个人从头开始构建一些代码。如果你的结对编程是关于一个人编写代码，另一个人说他们做错了，那么你需要重新思考你的实践（或者你的合作关系）。
- en: Mind you, that's true of code review when it's going badly, too. One problem
    with code reviews is that it's much easier to spot code that satisfies "I wouldn't
    have written it like that" than it is to spot code that satisfies "it should've
    been written to consider these things." This often gets in the way of getting
    useful information out of code reviews, because the reviewer gets frustrated with
    the tabs/spaces/variable names/other degenerate properties of the code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当代码审查进行得不顺利时，这也是真的。代码审查的一个问题是，发现满足“我不会那样写”的代码比发现满足“应该考虑到这些因素”的代码要容易得多。这往往阻碍了从代码审查中获得有用信息，因为审查者会对代码的制表符/空格/变量名/其他退化特性感到沮丧。
- en: It's problems like this that make me prefer asynchronous, distributed code reviews
    over face-to-face reviews. We frequently see that **people** ([http://programmers.stackexchange.com/questions/80469/how-to-stand-ground-when-colleagues-are-neglecting-the-process](http://programmers.stackexchange.com/questions/80469/how-to-stand-ground-when-colleagues-are-neglecting-the-process))
    *don't understand* the **motivations** ([http://thedailywtf.com](http://thedailywtf.com))
    of their colleagues. Let the reviewer work out that initial frustration and anger
    on their own – preferably, *without the author present as a punching bag*. The
    reviewer gets a chance to calm down, to acquaint themselves with the requirements,
    and to study the code in detail… This is not true of in-person reviews, where
    there's someone else in the room, waiting for the first gem of wisdom to be granted.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这类问题让我更倾向于异步、分布式的代码审查而不是面对面审查。我们经常看到，**人们**([http://programmers.stackexchange.com/questions/80469/how-to-stand-ground-when-colleagues-are-neglecting-the-process](http://programmers.stackexchange.com/questions/80469/how-to-stand-ground-when-colleagues-are-neglecting-the-process))**不理解**他们同事的**动机**([http://thedailywtf.com](http://thedailywtf.com))。让审查者自己解决最初的挫折和愤怒——最好是，**没有作者在场作为出气筒**。审查者有机会冷静下来，熟悉要求，并详细研究代码……这在面对面的审查中并不成立，因为房间里还有其他人，等着得到第一块智慧之石。
- en: On the subject of face-to-face reviews, be wary of people citing the "classics"
    in this field. People espousing the benefits of code reviews will often cite **Fagan's
    paper on code inspections** ([http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5388086](http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5388086)),
    claiming that it shows a reduction in the cost of developing software after introducing
    code reviews. Well, it does. But not in any way you'd recognize from modern software
    development.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关于面对面审查的话题，要警惕那些在这个领域引用“经典”的人。鼓吹代码审查好处的人经常会引用**Fagan关于代码检查的论文**([http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5388086](http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=5388086))，声称它表明在引入代码审查后，软件开发成本有所降低。好吧，确实如此。但并不是以任何你从现代软件开发中认识到的任何方式。
- en: The code inspections performed in Fagan's group would, by and large, uncover
    problems that, today, would be reported by a modern IDE before you even compile
    the code. Indeed, Fagan specifically describes code being inspected *after* a
    product is written, but *before* it's submitted to the compiler. Think back to
    the last time you *completely* wrote an application before you tried building
    it. For most developers working today, that hasn't ever happened.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Fagan小组进行的代码检查在很大程度上会揭露今天在编译代码之前现代IDE就会报告的问题。确实，Fagan特别描述了在产品编写后、提交给编译器之前进行代码检查。回想一下你上一次在尝试构建之前**完全**编写应用程序的时候。对于今天的大多数开发者来说，这种情况从未发生过。
- en: Fagan's reviews would've discovered things such as missing semicolons or spelling
    mistakes before a deck of punchcards was submitted to a batch compiler. That was,
    indeed, a valuable saving in terms of lost computer time and rework. For a modern
    code review, though, to be valuable, it has to save time elsewhere. The reviewer
    should be encouraged to focus on real issues at higher levels. Does the code represent
    a good abstraction? Is there an opportunity to reuse components of it elsewhere?
    Does it accurately solve the problem at hand?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Fagan的审查会在将一叠穿孔卡片提交到批量编译器之前发现诸如缺少分号或拼写错误等问题。这确实是在失去计算机时间和返工方面的一项宝贵节省。然而，对于现代代码审查来说，要具有价值，它必须在其他地方节省时间。应该鼓励审阅者关注更高层次的实际问题。代码是否代表了一个良好的抽象？是否有在其他地方重用其组件的机会？它是否准确地解决了当前的问题？
- en: The tool I've found most useful for achieving this is a checklist. A short collection
    of things the reviewer should focus on directs the review away from trivial questions
    about style and naming practice. Further, it also directs the *author* to think
    about these problems while writing code, which should make the actual review itself
    fairly short. After using the same checklist a few times, its effectiveness will
    be reduced, as everyone on the team will have a shared approach to dealing with
    the problems that appear on it. Therefore, the items on the checklist should be
    swapped in and out as old items become irrelevant and the importance of other
    problems increases.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现对实现这一目标最有用的工具是清单。一组简短的、审阅者应关注的事项可以将审阅引导远离关于风格和命名实践的琐细问题。此外，它还指导*作者*在编写代码时思考这些问题，这应该会使实际的审阅过程本身相当简短。使用相同的清单几次之后，其有效性会降低，因为团队中的每个人都会对清单上出现的问题有一个共享的处理方法。因此，当旧项目变得不相关而其他问题的重要性增加时，清单上的项目应该进行交换。
- en: Usually, the teams I'm working on do code reviews when integrating a piece of
    work into a release. This has worked better than scheduled reviews (the code is
    rarely baked, leading to the reviewer focusing on known rough edges) or reviews
    upon request (developers just don't ask). This is supported in tools like GitHub
    by "pull requests"—when the author wants to merge some code into an upstream branch
    or repository, they send a request, which is a chance to do the review. Other
    tools, such as **gerrit** ([http://code.google.com/p/gerrit/](http://code.google.com/p/gerrit/)),
    provide similar capabilities.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我正在工作的团队在将某个工作集成到发布版本时会进行代码审查。这比计划中的审查（代码很少经过充分准备，导致审阅者专注于已知的粗糙边缘）或请求审查（开发者根本不会请求）要好。GitHub等工具通过“拉取请求”支持这一点——当作者想要将一些代码合并到上游分支或存储库时，他们会发送一个请求，这是一个进行审查的机会。其他工具，如**gerrit**
    ([http://code.google.com/p/gerrit/](http://code.google.com/p/gerrit/))，也提供了类似的功能。
- en: 'Code reviews should ideally be treated as learning activities. The author should
    learn *why* the reviewer is suggesting particular changes, what the problems are,
    and why the proposed changes address those problems in ways that the code, as
    submitted to the review, did not. The reviewer should be learning too: there are
    opportunities to learn from the submitted code and practice your rhetorical skills
    by coming up with convincing arguments for why your changes should be accepted
    arguments that aren''t "because I know best." For this to work, the outcome of
    a code review must be a discussion, even if it''s a comment thread in a review
    tool. Making some additional fixes and accepting the fixed changes without discussion
    loses a lot of the benefit of having the review.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，代码审查应被视为学习活动。作者应该学习*为什么*审阅者建议特定的更改，存在什么问题，以及为什么提出的更改以代码提交到审查的方式解决了这些问题。审阅者也应该在学习：从提交的代码中学习的机会，通过提出令人信服的论据来支持为什么你的更改应该被接受，这些论据不是“因为我最懂”。为了使这起作用，代码审查的结果必须是一个讨论，即使它是一个审查工具中的评论线程。做一些额外的修复并接受没有讨论的修复更改会失去审查的大部分好处。
- en: Programming Paradigms And Their Applicability
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程范式及其适用性
- en: 'On one (theoretically correct, though practically unpleasing) level, all software
    is just comprised of loads, stores, mathematics, and jumps, so any application
    can be written using any tool that permits the correct ordering of those basic
    operations. A key theme running through this book though, is the idea of software''s
    interpersonal nature, and here, we have a concrete example of that: the application
    source code as a source of mutual understanding between the programmers who work
    on it.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个（理论上正确，但实际并不令人愉快）层面上，所有软件都是由加载、存储、数学和跳转组成的，所以任何应用程序都可以使用任何允许正确排序这些基本操作的工具来编写。然而，贯穿这本书的一个关键主题是软件的人际性质，在这里，我们有一个具体的例子：应用程序源代码是程序员之间相互理解的来源。
- en: Before exploring that though, a little diversion into history, to make an idea
    explicit so that we can leave it behind. This is the idea of successive layers
    of abstraction allowing people to build on what came before. Yes, all software
    is built out of the basic operations described above but thinking about your problem
    in terms of the computer's operations is hard. Within a few years of stored-program
    computers being invented, EDSAC programmers created an *assembler* that translated
    mnemonic operation names (such as *A* for add) into the operation `codes` used
    by the computer. Programmers could then worry just about the fact that they were
    adding things, not about which number the processor used to represent addition
    in this particular addressing mode (on computers that have more than one).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索这个话题之前，我们先稍微回顾一下历史，以便明确这个想法，这样我们就可以将其放下。这是关于连续层抽象的想法，它允许人们在前人的基础上构建。是的，所有软件都是由上述基本操作构建的，但用计算机操作来思考你的问题是困难的。在存储程序计算机被发明后的几年里，EDSAC程序员创建了一个*汇编器*，它将助记操作名称（如*加*表示为*A*）转换成计算机使用的操作`代码`。然后程序员只需关注他们正在添加事物的事实，而不必关注处理器在这个特定的寻址模式中用哪个数字来表示加法（在有多于一种寻址模式的计算机上）。
- en: Other work, including that on macro assemblers and Grace Hopper's work on A-1
    and other compilers, let programmers move a level away from computer operations
    (even with "friendly" names) and express *what they want to happen* in a way that
    can be translated into low-level instructions. For example, a loop over some code
    with an index variable taking even values from 2 to 20 can be expressed as `FOR
    I=2 TO 20 STEP 2:…:NEXT I` rather than the initialization, test, branch, and update
    steps the computer actually needs to execute.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其他工作，包括对宏汇编器的研究以及格蕾丝·霍珀在A-1和其他编译器上的工作，使得程序员能够从计算机操作（即使是“友好”的名称）中提升一个层次，并以一种可以被翻译成低级指令的方式表达*他们想要发生的事情*。例如，一个循环遍历某些代码，使用索引变量从2到20取偶数值，可以表示为`FOR
    I=2 TO 20 STEP 2:…:NEXT I`，而不是计算机实际需要执行的初始化、测试、分支和更新步骤。
- en: So, when someone solves a problem in software once, others can (legality, compatibility,
    and availability permitting) build other software on top of that solution. This
    applies to the discussion that follows objects can be built out of other objects
    and functions can be built out of other functions. Functions can be built out
    of objects and objects out of functions, too. This is not that story. This is
    the story of *stories* being built out of functions and objects; of choosing programming
    paradigms as ways to *think* about software and to *describe* thoughts about software
    to other programmers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当某人第一次在软件中解决问题时，其他人（在合法性、兼容性和可用性允许的情况下）可以在该解决方案之上构建其他软件。这适用于以下讨论：对象可以由其他对象构建，函数可以由其他函数构建。函数也可以由对象构建，对象也可以由函数构建。这不是那个故事。这是关于*故事*由函数和对象构建的故事；关于将编程范式作为思考软件和向其他程序员描述关于软件思考的方式。
- en: Object-Oriented Programming
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: When it first became a popular technique in the middle of the 1980s, some people
    tried to position OOP as the solution to all of the software industry's ills (whether
    those ills existed in the forms described is probably a discussion for another
    time). Fred Brooks, a manager on IBM's infamous System/360 project, had told programmers
    that there is *no silver bullet*—[http://www.cs.nott.ac.uk/~cah/G51ISS/Documents/NoSilverBullet.html](http://www.cs.nott.ac.uk/~cah/G51ISS/Documents/NoSilverBullet.html);
    that the problems faced by the software industry are hard and no technology solution
    would make it any easier. Brad Cox asked rhetorically in response, *what if there
    is a silver bullet*—[http://dl.acm.org/citation.cfm?id=132388](http://dl.acm.org/citation.cfm?id=132388)
    (that is, object technology), and your competitors are already using it?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当它在20世纪80年代中期成为一种流行的技术时，有些人试图将OOP定位为解决软件行业所有问题的方案（这些问题是否以描述的形式存在可能是一个需要另一次讨论的话题）。IBM臭名昭著的System/360项目的管理者弗雷德·布鲁克斯曾告诉程序员，没有*银弹*——[http://www.cs.nott.ac.uk/~cah/G51ISS/Documents/NoSilverBullet.html](http://www.cs.nott.ac.uk/~cah/G51ISS/Documents/NoSilverBullet.html)；软件行业面临的问题是困难的，没有任何技术解决方案会使它变得更容易。布拉德·考克斯反问，*如果真的有银弹*——[http://dl.acm.org/citation.cfm?id=132388](http://dl.acm.org/citation.cfm?id=132388)（即面向对象技术），而你的竞争对手已经在使用它？
- en: 'As Cox saw it (or at least positioned it in marketing his company), object-oriented
    programming was the cultural shift that would move software construction from
    a cottage industry of separate one-off craft pieces to a true engineering discipline,
    by introducing the *object* as an interchangeable component with a standard interface,
    just like the pozidrive screw or the four-by-two plank. (Software-ICs: another
    metaphor Cox used, particularly in his book *Object-Oriented Programming: An Evolutionary
    Approach*—[http://books.google.co.uk/books/about/Object_Oriented_Programming.html?id=deZQAAAAMAAJ&redir_esc=y](http://books.google.co.uk/books/about/Object_Oriented_Programming.html?id=deZQAAAAMAAJ&redir_esc=y),
    was that of the *Software Integrated Circuit*. Just as the development of computer
    hardware had accelerated by moving from assembling computers out of discrete components
    to connecting together standard ICs, he envisaged a sort of software Moore''s
    Law arising from the successive development of applications assembled from standard
    objects or Software ICs.)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就考克斯所看到的（或者至少在推广他的公司时定位它），面向对象编程是文化转变，它将软件构建从分离的独立手工艺品行业转变为真正的工程学科，通过引入*对象*作为具有标准接口的可互换组件，就像pozidrive螺丝或四乘二的板条。（软件-集成电路：考克斯使用的另一个隐喻，尤其是在他的书《面向对象编程：一种进化方法》——[http://books.google.co.uk/books/about/Object_Oriented_Programming.html?id=deZQAAAAMAAJ&redir_esc=y](http://books.google.co.uk/books/about/Object_Oriented_Programming.html?id=deZQAAAAMAAJ&redir_esc=y)中，是*软件集成电路*。正如计算机硬件的发展通过从组装离散组件的计算机到连接标准集成电路而加速一样，他设想了一种软件摩尔定律，这种定律源于从标准对象或软件集成电路组装的应用程序的连续发展。）
- en: Software manufacturing companies could build these standard parts and make them
    available to an object marketplace. This would be the software equivalent of the
    trade store, where blue-collar tradesmen and do-it-yourself computer users could
    buy objects off the shelf and assemble them into the applications they needed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 软件制造公司可以构建这些标准组件，并将它们提供给对象市场。这将相当于软件行业的贸易商店，蓝领工匠和DIY计算机用户可以从货架上购买对象，并将它们组装成他们需要的应用程序。
- en: 'As it happens, Brooks had already pointed out that there were two classes of
    problem associated with building software: the *essential* problems that arise
    from it being a complex activity and the *accidental* problems related to the
    current processes or technology and their flaws. Object-oriented programming did
    not solve the essential problems and replaced some accidental problems with others.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，布鲁克斯已经指出，与软件开发相关的问题分为两类：一类是源于其作为复杂活动的*本质*问题，另一类是与当前流程或技术及其缺陷相关的*偶然*问题。面向对象编程没有解决本质问题，而是用其他偶然问题取代了一些问题。
- en: Anyway, all of this history may be of some interest but what *is* object-oriented
    programming? The problem we need to look at is not one of manipulating data or
    of instructing the computer, but one of *organizing* that data and those instructions
    to aid (human) comprehension.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，所有这些历史可能有些兴趣，但什么是面向对象编程呢？我们需要关注的问题不是操纵数据或指导计算机，而是如何*组织*这些数据和指令以帮助（人类）理解。
- en: The property of object-oriented software that distinguishes it from other techniques
    is the interrelated organization of code and the data that code acts on into autonomous
    units (the eponymous *objects*) that interact by sending each other messages.
    The argument in favor of this approach is that a programmer working on one such
    unit need only understand the *interface* of its collaborating units—the messages
    they understand along with the preconditions and results of those messages; not
    the *implementation*—how those units do what they do. A large program comprising
    many instructions is thus split into multiple independent entities that can be
    developed in isolation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象软件区别于其他技术的特性是其代码及其作用的数据以相互关联的组织形式构成自主单元（即所谓的*对象*），通过发送消息相互交互。支持这种方法的论点是，一个在这样一个单元上工作的程序员只需要理解其协作单元的*接口*——他们理解的消息以及这些消息的前提条件和结果；而不需要理解*实现*——这些单元是如何工作的。因此，一个由许多指令组成的大型程序被分割成多个独立的实体，这些实体可以独立开发。
- en: Plenty of programming languages that predate object-oriented programming already
    allow the organization of code into modules, each module having its own functions
    and data. Such modules can be restricted to communicating with each other only
    using particular interface functions. What OOP brings on top of this is the idea
    of the automaton, of the self-contained package of code and data that is independent
    both from unrelated parts of the software system and from other instances of things
    like itself. So, while a multiplayer game written in Modula-2 might have a module
    that controls the player characters and hides their details away from the rest
    of the game, were it written in an object-oriented language like Oberon-2, it
    might have an object representing each of the player characters that hides its
    internals from the rest of the game and from each other player object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 许多在面向对象编程之前就已经存在的编程语言已经允许将代码组织成模块，每个模块都有自己的功能和数据。这些模块可以限制只通过特定的接口函数相互通信。面向对象编程在此基础上引入了自动机的概念，即代码和数据自包含的包，它既独立于软件系统中的无关部分，也独立于其他类似实例。因此，虽然用Modula-2编写的多人游戏可能有一个控制玩家角色并隐藏其细节的模块，但如果用像Oberon-2这样的面向对象语言编写，它可能有一个代表每个玩家角色的对象，该对象隐藏其内部细节，既隐藏于游戏的其他部分，也隐藏于其他玩家对象。
- en: Given this desire to make a system of autonomous agents that communicate via
    messages (cpp-messages), some readers may take umbridge at the statement that
    OOP involves message sending, using languages such as C++ with its member functions
    as counter examples. Suffice it to say that the *mental model* of objects sending
    messages to each other is still useful, however the language actually implements
    it. Now, some other readers are going to dig up quotes by Alan Kay to assert that
    *only* languages with message-sending can be considered object-oriented. (If you
    dig hard enough, you'll find that, in Smalltalk, the phrase "object-oriented"
    was sometimes used to refer to the *memory management* paradigm; in other words,
    to the garbage collector. The programming model was called "message-passing."
    So, perhaps C++ with the Boehm-Demers-Weiser garbage collector truly *is* "object-oriented"
    as purists would understand it. Whatever. If you take issue with it, please find
    someone else to email.) The largest problem (if not *the* problem; the question
    being the only one introduced by adopting OOP) is choosing which objects are responsible
    for which actions. This is a difficult problem to solve; I remember getting it
    very wrong on the first object-oriented systems I created and still want to improve
    nearly a decade later. Programmers in all fields have written about heuristics
    for decomposing systems into component objects, and some people have developed
    tools to evaluate software in relation to those heuristics and to automatically
    change the composition.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种希望构建一个通过消息（cpp-messages）进行通信的自主代理系统，一些读者可能会对“面向对象编程涉及消息发送”的说法表示异议，他们认为使用C++等语言（其成员函数作为反例）并不涉及消息发送。但可以简单地说，对象之间发送消息的*心智模型*仍然是有用的，尽管实际的语言实现可能不同。现在，一些其他读者可能会引用艾伦·凯的言论来断言，只有具有消息发送功能的语言才能被认为是面向对象的。（如果你挖掘得足够深，你会发现，在Smalltalk中，“面向对象”有时被用来指代*内存管理*范式；换句话说，就是垃圾回收器。编程模型被称为“消息传递”。因此，也许带有Boehm-Demers-Weiser垃圾回收器的C++在纯粹主义者看来确实*是*面向对象的。不管怎样。如果你对此有异议，请找其他人发邮件。）最大的问题（如果不是*唯一*的问题；采用面向对象编程引入的唯一问题是选择哪些对象负责哪些动作。这是一个难以解决的问题；我记得我在创建第一个面向对象系统时犯了很多错误，直到近十年后才想要改进。所有领域的程序员都写过关于将系统分解为组件对象的经验法则，有些人还开发了评估软件与这些经验法则相关性的工具，以及自动改变组成的工具。
- en: 'Those heuristics range from woolly concepts (the open-closed principle, the
    single responsibility principle, and others) to precisely defined mathematical
    rules (the Liskov substitution principle, the Law of Demeter, and others). Most
    (or maybe all) of these have the high-level goal of increasing the *autonomy*
    of objects in the system, reducing the extent to which they depend on the rest
    of the system. The stated benefits of doing this are: the increased reusability
    of objects across different systems, and the reduced likelihood that a given object
    will need changing in reaction to a change elsewhere in the system.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些启发式方法从模糊的概念（如开闭原则、单一职责原则等）到精确定义的数学规则（如Liskov替换原则、迪米特法则等）不等。大多数（或许全部）这些方法都有一个高级目标，那就是提高系统中对象的*自主性*，减少它们对系统其他部分的依赖程度。这样做的好处是：提高了对象在不同系统中的可重用性，以及减少了某个特定对象因系统其他部分的变动而需要修改的可能性。
- en: Researchers have also found that **object-oriented software** is *harder to
    review*—[http://dl.acm.org/citation.cfm?id=337343](http://dl.acm.org/citation.cfm?id=337343)
    than structured software. The desirable design properties that lead to a connected
    system of loosely coupled objects also produce a system where it's difficult to
    discover the flow of execution; you can't easily see where control goes as a result
    of any particular message. Tools do exist that aim to address this by providing
    multiple related views of an object-oriented system, such as Code Bubbles and
    Eclipse Mylyn. These are not (yet) mainstream. Then, of course, there are the
    documents that describe object-oriented software at a high level, often expressed
    diagrammatically using a notation such as UML. The value of these documents is
    described in the *Chapter 8, Documentation*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员还发现，**面向对象软件**比结构化软件更难进行审查——[http://dl.acm.org/citation.cfm?id=337343](http://dl.acm.org/citation.cfm?id=337343)。导致紧密耦合对象连接系统的理想设计属性也产生了一个难以发现执行流程的系统；你不能轻易地看到任何特定消息的结果控制流向何方。确实存在一些工具旨在通过提供面向对象系统的多个相关视图来解决这个问题，例如Code
    Bubbles和Eclipse Mylyn。这些工具目前还不是主流。当然，还有那些以UML等符号图示化方式描述面向对象软件的文档，这些文档的价值在*第8章，文档*中有所描述。
- en: I find that the most interesting reading on object-oriented programming is that
    written when it was new; new to the commercial programmer anyway. It's that material
    that attempts to persuade you of the benefits of OOP, and to explain the reasoning
    behind the paradigm. Specific practices have changed significantly in the intervening
    few decades, but modern books assume that you know *why* you want to do OOP, and
    often even that you know what it is.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现，关于面向对象编程最有趣的阅读材料是它在新兴时期所写的；至少对于商业程序员来说是新的。这些材料试图说服你面向对象编程的好处，并解释这种范式的推理。在接下来的几十年中，具体的实践发生了显著变化，但现代书籍假设你知道*为什么*想要做面向对象编程，甚至常常假设你知道它是什么。
- en: 'I''d recommend that even readers who consider themselves experienced object-oriented
    programmers read *Object-Oriented Programming: An Evolutionary Approach*—[http://books.google.co.uk/books/about/Object_oriented_programming.html?id=U8AgAQAAIAAJ&redir_esc=y](http://books.google.co.uk/books/about/Object_oriented_programming.html?id=U8AgAQAAIAAJ&redir_esc=y))
    and **Object-Oriented Software Construction**—[http://books.google.co.uk/books?id=v1YZAQAAIAAJ&source=gbs_similarbooks](http://books.google.co.uk/books?id=v1YZAQAAIAAJ&source=gbs_similarbooks).
    These books not only tell you about particular languages (Objective-C and Eiffel,
    respectively) but also on the problems that those languages are supposed to solve.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议即使是自认为经验丰富的面向对象程序员也应该阅读《面向对象编程：一种进化方法》（[http://books.google.co.uk/books/about/Object_oriented_programming.html?id=U8AgAQAAIAAJ&redir_esc=y](http://books.google.co.uk/books/about/Object_oriented_programming.html?id=U8AgAQAAIAAJ&redir_esc=y)）和《面向对象软件构造》（[http://books.google.co.uk/books?id=v1YZAQAAIAAJ&source=gbs_similarbooks](http://books.google.co.uk/books?id=v1YZAQAAIAAJ&source=gbs_similarbooks)）。这些书籍不仅告诉你关于特定语言（分别是Objective-C和Eiffel）的信息，还介绍了这些语言旨在解决的问题。
- en: What you may learn from these and other foundational texts in the field is that
    the reason OOP did not succeed is not because it failed, but because it was not
    attempted. Keen to make OOP accessible, the **Object Technology** companies made
    it clear that what you were already doing was already OOP. If you know how to
    write sequential statements in C, you'll *love* writing sequential statements
    in Java, and then you'll be doing OOP.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些以及其他领域的基石性文本中，你可能学到的就是，面向对象编程（OOP）没有成功的原因并不是它失败了，而是它从未被尝试过。为了使OOP易于理解，**面向对象技术**公司明确指出，你已经在做的事情其实已经是面向对象编程了。如果你知道如何在C语言中编写顺序语句，你会*喜欢*在Java中编写顺序语句，然后你就在做面向对象编程了。
- en: Aspect-Oriented Programming
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向方面编程
- en: An extension to object-oriented programming that so far has not reached the
    same level of application and currency, aspect-oriented programming sets out to
    solve a particular problem in the construction of object-oriented systems. More
    specifically, the problem exists in class-based object-oriented systems with single
    inheritance.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的一个扩展，到目前为止还没有达到相同的应用和货币水平，即面向方面编程，旨在解决面向对象系统构建中的特定问题。更具体地说，这个问题存在于具有单一继承的单继承类面向对象系统中。
- en: The previous section described the existence of many heuristics, created to
    guide the organization of code in object-based systems. One of these heuristics
    was the *Single Responsibility Principle*, which says that the code in one class
    should be responsible for just one thing. Imagine, then, a database application
    for a human resources department (almost the canonical OOP example, if recipe
    managers are ignored). One class might represent an employee, having a name, salary,
    manager, and so on. Not everyone should be able to change an employee's salary,
    so some access control will be needed. It could also be useful for auditing and
    debugging purposes to be able to log any change to an employee's salary.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节描述了许多启发式方法的存在，这些方法是为了指导基于对象系统的代码组织。其中一种启发式方法是*单一职责原则*，它表示一个类中的代码应该只负责一件事。想象一下，然后是一个人力资源部门的数据库应用程序（如果忽略食谱管理器，几乎是面向对象示例的典范）。一个类可能代表一个员工，具有姓名、薪水、经理等属性。不应让每个人都能够更改员工的薪水，因此需要一些访问控制。为了审计和调试目的，能够记录员工薪水的任何更改也可能很有用。
- en: 'There are then three responsibilities: updating the database, access control,
    and auditing. The Single Responsibility Principle means that we should avoid putting
    all the responsibilities in the `Employee` class. Indeed, that would lead to a
    lot of duplication because the access control and auditing facilities would be
    needed elsewhere in the application too. They are *cross-cutting concerns*, where
    the same facilities must be provided by many, otherwise different, classes.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此有三个职责：更新数据库、访问控制和审计。单一职责原则意味着我们应该避免将所有职责放入`Employee`类中。实际上，这会导致大量重复，因为访问控制和审计功能也需要在应用程序的其他地方使用。它们是*横切关注点*，许多不同类必须提供相同的设施。
- en: While there are other ways to build these cross-cutting concerns into an application,
    aspect-oriented programming opens up configurable *join points* in an object-oriented
    system. These join points include method entry or exit, the transfer of execution
    to exception handlers, and fields being read or changed. An aspect defines the
    predicate a join point must satisfy for this aspect to be relevant (called a pointcut)
    and the code that is run at that join point (sometimes called advice).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有其他方法可以将这些横切关注点构建到应用程序中，但面向方面编程在面向对象系统中打开了可配置的*连接点*。这些连接点包括方法进入或退出、执行转移到异常处理器以及字段被读取或更改。方面定义了连接点必须满足的谓词，以便此方面相关（称为切入点）以及在该连接点运行的代码（有时称为建议）。
- en: AOP extensions are available for popular OOP environments (**AspectJ** ([http://www.eclipse.org/aspectj/](http://www.eclipse.org/aspectj/))
    for Java and **Aspect#** ([http://sourceforge.net/projects/aspectsharp/](http://sourceforge.net/projects/aspectsharp/))
    for .NET), but as previously mentioned, the style is not widely used. It adds
    further to the problem OOP already suffers from, in that it's hard to work out
    exactly what code is executed in response to a given event. Other systems, such
    as Ruby and Self (and C++), have "traits" or "mix-ins," which take the position
    of aspects but not the name.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 面向方面编程扩展适用于流行的面向对象环境（**AspectJ** ([http://www.eclipse.org/aspectj/](http://www.eclipse.org/aspectj/))
    用于Java 和 **Aspect#** ([http://sourceforge.net/projects/aspectsharp/](http://sourceforge.net/projects/aspectsharp/))
    用于.NET)），但如前所述，这种风格并不广泛使用。它进一步加剧了面向对象已经存在的问题，即很难确定在给定事件响应中确切执行了哪些代码。其他系统，如Ruby和Self（以及C++），有“特性”或“混入”，它们占据着方面的位置，但不是名称。
- en: Functional Programming
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Something that's even less new—though needed a bit of rediscovery—than object-oriented
    programming is functional programming. As the name suggests, functional programming
    is all about functions; in this case, functions in the mathematical sense of operations
    that can be applied to some input domain and produce output in a corresponding
    range. Whereas object-oriented systems describe the imperative commands the computer
    must execute, a functional program describes the functions that are applied to
    given input.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 比面向对象编程还要不那么新颖——尽管需要一点重新发现——的是函数式编程。正如其名所示，函数式编程完全是关于函数的；在这种情况下，是在数学意义上可以应用于某个输入域并产生相应范围输出的操作。而面向对象系统描述了计算机必须执行的命令式命令，函数式程序描述了应用于给定输入的函数。
- en: This distinction leads to some interesting departures from imperative systems
    (though these departures can be modelled in OO code, they are prevalent in FP).
    Parts of functional systems can be *lazily evaluated*; in other words, the computer,
    seeing that an x^2 result is required, can defer the computation of that result
    until it's actually used, or the CPU is quiescent. That's not so interesting for
    calculating a square but can lead to tricks like working with a list of all integers.
    In imperative code, a list of all integers would need computing when it was created,
    which is impossible to do. Functional software can define something that evaluates
    to a list of all integers, then lazily evaluate only those entries that are actually
    accessed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别导致了一些从命令式系统（尽管这些偏离可以在面向对象代码中建模，但在函数式编程中很普遍）中出现的有趣差异。函数式系统的一部分可以*惰性评估*；换句话说，计算机看到需要
    x 的平方结果，可以推迟计算该结果，直到它实际上被使用，或者 CPU 处于空闲状态。这在对计算平方来说并不那么有趣，但可以导致像处理所有整数的列表这样的技巧。在命令式代码中，所有整数的列表在创建时就需要计算，这是不可能做到的。函数式软件可以定义一个评估为所有整数列表的东西，然后只对实际访问的条目进行惰性评估。
- en: 'Similarly, results can be *memorized*: the result x times x for x==2 is always
    4; we know it doesn''t depend on anything else, such as the state of a database
    or what keys a user presses on the keyboard, so having calculated 2 times 2=4
    once, we can always remember it and use the answer 4 again.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，结果可以被*记忆化*：当 x 等于 2 时，x 乘以 x 的结果总是 4；我们知道它不依赖于任何其他东西，例如数据库的状态或用户在键盘上按下的键，所以一旦计算出
    2 乘以 2 等于 4，我们就可以始终记住它并再次使用答案 4。
- en: '*Recursion* is a weapon frequently wielded in functional programs. How might
    we build a list of all integers? Let''s restrict ourselves to a list of positive
    integers. Define the `f(x)` function such that:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归*是函数程序中经常使用的武器。我们如何构建所有整数的列表？让我们限制自己为正整数的列表。定义 `f(x)` 函数，使得：'
- en: If `x` is at the head of a list `l`, `f(x)=1`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `x` 是列表 `l` 的头部，`f(x)=1`
- en: Otherwise, `f(x)=1+f(previous entry)`
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，`f(x)=1+f(previous entry)`
- en: Then, for a list with one entry, the result of applying `f` is 1\. With two
    entries, it becomes `1+f(single-entry)=2`, and so on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，对于一个只有一个条目的列表，应用 `f` 的结果是 1。对于两个条目的列表，它变成 `1+f(single-entry)=2`，依此类推。
- en: Recursion and lazy evaluation are both useful properties, but neither is intrinsic
    to a functional style of programming; they are merely frequently found being employed
    in such fields. A more essential part of the program-as-function model is the
    absence of side effects.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 递归和惰性评估都是有用的特性，但它们都不是函数式编程风格的固有特性；它们只是经常被用于这些领域。程序作为函数模型的一个更本质的部分是副作用的缺失。
- en: Because mathematical functions have no side effects, the output of a function
    depends only on its input. Evangelists of functional programming say that this
    makes software easier to understand (nothing "magic" can happen), and that it
    makes for a good approach to building multi-threaded software as there can be
    no race conditions; if the input to a function can be prepared, the function can
    produce its output. If a function works well with a number as its input, it will
    work equally well with the (numeric) output of *another* function as its input;
    its execution depends only on what it receives.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数学函数没有副作用，函数的输出只取决于其输入。函数式编程的倡导者说，这使得软件更容易理解（不会发生任何“魔法”），并且它为构建多线程软件提供了一个良好的方法，因为不可能出现竞态条件；如果函数的输入可以准备，函数就可以产生其输出。如果一个函数与一个数字作为输入工作得很好，它将以相同的方式与另一个函数的（数值）输出作为输入工作；它的执行只取决于它接收到的。
- en: Of course, many software systems have requirements to produce side effects such
    as drawing images on a display or modifying the saved state of a database. Different
    functional programming languages then provide different techniques for *encapsulating*
    – not completely removing – mutable state. For example, stateful components of
    a software system written in Haskell will be expressed as data types that are
    the results of functions and can themselves be executed to produce the required
    side effects; in this way, stateful parts can act as sinks or sources to the functional
    program.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，许多软件系统都有产生副作用的要求，例如在显示屏上绘制图像或修改数据库的保存状态。不同的函数式编程语言随后提供了不同的技术来*封装*——而不是完全删除——可变状态。例如，用
    Haskell 编写的软件系统的有状态组件将被表示为函数的结果，并且可以自身执行以产生所需副作用；这样，有状态的部分可以充当函数程序的汇或源。
- en: Functional programming has gained a lot of popularity in the commercial sector
    in the last couple of years, primarily with the availability of functional languages
    that interface with existing (object-oriented) code; examples being **Clojure**
    ([http://clojure.org](http://clojure.org)) on the **Java Virtual Machine** (**JVM**)
    and **F#** ([https://fsharp.org/learn.html](https://fsharp.org/learn.html)) on
    the .Net VM. The principles though are a lot older—LISP was *first described in
    1958*—[http://www-formal.stanford.edu/jmc/recursive.html](http://www-formal.stanford.edu/jmc/recursive.html)
    but based on mathematical concepts that *predate the programmable computer*—[http://www.jstor.org/stable/1968337](http://www.jstor.org/stable/1968337).
    A great reference on the how and why of functional programming is **Structure
    and Interpretation of Computer Programs** ([https://web.mit.edu/alexmv/6.037/sicp.pdf](https://web.mit.edu/alexmv/6.037/sicp.pdf)),
    even though recent versions of this book use the not-at-first-glance functional
    language, Python.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程在过去的几年里在商业领域获得了极大的流行，这主要得益于功能语言与现有（面向对象）代码的接口；例如，**Clojure** ([http://clojure.org](http://clojure.org))
    是在 **Java虚拟机** (**JVM**) 上运行的，而 **F#** ([https://fsharp.org/learn.html](https://fsharp.org/learn.html))
    是在 .Net 虚拟机上的。尽管如此，其原则却要古老得多——LISP 是在 1958 年首次被描述的——[http://www-formal.stanford.edu/jmc/recursive.html](http://www-formal.stanford.edu/jmc/recursive.html)，但这些原则是基于早于可编程计算机的数学概念——[http://www.jstor.org/stable/1968337](http://www.jstor.org/stable/1968337)。关于函数式编程的如何和为什么，一本很好的参考书是
    **《计算机程序的构造和解释》** ([https://web.mit.edu/alexmv/6.037/sicp.pdf](https://web.mit.edu/alexmv/6.037/sicp.pdf))，尽管这本书的最近版本使用了乍一看不是功能语言的
    Python。
