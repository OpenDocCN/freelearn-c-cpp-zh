<html><head></head><body>
		<div><h1 id="_idParaDest-24" class="chapter-number" lang="en-GB"><a id="_idTextAnchor023"/>2</h1>
			<h1 id="_idParaDest-25" lang="en-GB"><a id="_idTextAnchor024"/>Test Results</h1>
			<p lang="en-GB">So far, we have a test library that can only have a single test. You’ll see what happens in this chapter when we try to add another test and you’ll see how to enhance the test library to support multiple tests. We’ll need to use an old and rarely used capability of C++ that actually comes from its early C roots to support multiple tests.</p>
			<p lang="en-GB">Once we get more than one test, we’ll need a way to view the results. This will let you tell at a glance whether everything passed or not. And finally, we’ll fix the result output so that it no longer assumes <code>std::cout</code>.</p>
			<p lang="en-GB">We’ll cover the following main topics in this chapter:</p>
			<ul>
				<li lang="en-GB">Reporting a single test result based on exceptions</li>
				<li lang="en-GB">Enhancing the test library to support multiple tests</li>
				<li lang="en-GB">Summarizing the test results to clearly see what failed and what passed</li>
				<li lang="en-GB">Redirecting the test result so the output can go to any stream</li>
			</ul>
			<h1 id="_idParaDest-26" lang="en-GB"><a id="_idTextAnchor025"/>Technical requirements</h1>
			<p lang="en-GB">All code in this chapter uses standard C++ that builds on any modern C++ 17 or later compiler and standard library. The code is based on and continues from the previous chapter.</p>
			<p lang="en-GB">You can find all the code for this chapter at the following GitHub repository: <a href="https://github.com/PacktPublishing/Test-Driven-Development-with-CPP">https://github.com/PacktPublishing/Test-Driven-Development-with-CPP</a>.</p>
			<h1 id="_idParaDest-27" lang="en-GB"><a id="_idTextAnchor026"/>Reporting a single test result</h1>
			<p lang="en-GB">So far, our single test just <a id="_idIndexMarker034"/>prints its hardcoded name when run. There was some early thinking that we might need a result in addition to the test name. This is actually a good example of adding something to the code that is not needed or used. Okay, a minor example because we will need something to keep track of whether the test passes or fails, but it’s still a good example of getting ahead of ourselves because we have actually never used the <code>mResult</code> data member yet. We’re going to fix that now with a better way to track the result of running a test.</p>
			<p lang="en-GB">We’ll assume that a test succeeds unless something happens to cause it to fail. What can happen? There will eventually be a lot of ways you can cause a test to fail. For now, we’ll just consider exceptions. This could be an exception that a test throws on purpose when it detects something is wrong or it could be an unexpected exception that gets thrown.</p>
			<p lang="en-GB">We don’t want any <a id="_idIndexMarker035"/>exceptions to stop the tests from running. An exception thrown from one test shouldn’t be a reason to stop running others. We still only have a single test but we can make sure that an exception doesn’t stop the entire test process.</p>
			<p lang="en-GB">What we want is to wrap the <code>run</code> function call in a <code>try</code> block so that any exceptions will be treated as a failure, like this:</p>
			<pre class="source-code" lang="en-GB">
inline void runTests ()
{
    for (auto * test: getTests())
    {
        try
        {
            test-&gt;run();
        }
        catch (...)
        {
            test-&gt;setFailed("Unexpected exception thrown.");
        }
    }
}</pre>
			<p lang="en-GB">When an exception is caught, we want to do two things. The first is to mark the test as a failure. The second is to set a message so that the result can be reported. The problem is that we don’t have a method called <code>setFailed</code> on the <code>TestInterface</code> class. It’s actually good to first write the code as we’d like it to be.</p>
			<p lang="en-GB">In fact, the idea of <code>TestInterface</code> was for it to be a set of pure virtual methods like an interface. We could add a new method called <code>setFailed</code> but then the implementation <a id="_idIndexMarker036"/>would need to be written in a derived class. This seems like a basic part of a test to be able to hold the result and a message.</p>
			<p lang="en-GB">So, let’s refactor the design and change <code>TestInterface</code> into more of a base class and call it <code>TestBase</code> instead. We can also move the data members from the class declared inside the <code>TEST</code> macro and put them in the <code>TestBase</code> class:</p>
			<pre class="source-code" lang="en-GB">
class TestBase
{
public:
    TestBase (std::string_view name)
    : mName(name), mPassed(true)
    { }
    virtual ~TestBase () = default;
    virtual void run () = 0;
    std::string_view name () const
    {
        return mName;
    }
    bool passed () const
    {
        return mPassed;
    }
    std::string_view reason () const
    {
        return mReason;
    }
    void setFailed (std::string_view reason)
    {
        mPassed = false;
        mReason = reason;
    }
private:
    std::string mName;
    bool mPassed;
    std::string mReason;
};</pre>
			<p lang="en-GB">With the new <code>setFailed</code> method, it no longer made sense to have an <code>mResult</code> data member. Instead, there’s an <code>mPassed</code> member, along with the <code>mName</code> member; both came from the <code>TEST</code> macro. It also seemed like a good idea to add some getter methods, especially now that there’s also an <code>mReason</code> data member. Altogether, each test can now store its <a id="_idIndexMarker037"/>name, remember whether it passed or not, and the reason for failure, if it failed.</p>
			<p lang="en-GB">Only a slight change is needed in the <code>getTests</code> function to refer to the <code>TestBase</code> class:</p>
			<pre class="source-code" lang="en-GB">
inline std::vector&lt;TestBase *&gt; &amp; getTests ()
{
    static std::vector&lt;TestBase *&gt; tests;
    return tests;
}</pre>
			<p lang="en-GB">The rest of the changes simplify the <code>TEST</code> macro like this to remove the data members, which are now in the <a id="_idIndexMarker038"/>base class, and to inherit from <code>TestBase</code>:</p>
			<pre class="source-code" lang="en-GB">
#define TEST \
class Test : public MereTDD::TestBase \
{ \
public: \
    Test (std::string_view name) \
    : TestBase(name) \
    { \
        MereTDD::getTests().push_back(this); \
    } \
    void run () override; \
}; \
Test test("testCanBeCreated"); \
void Test::run ()</pre>
			<p lang="en-GB">Checking to make sure <a id="_idIndexMarker039"/>everything builds and runs again shows that we are back to a running program with the same result as before. You’ll see this technique often with a refactor. It’s good to keep any functional changes to a minimum when refactoring and focus mostly on just getting back to the same behavior as before.</p>
			<p lang="en-GB">Now, we can make some changes that <em class="italic" lang="">will</em> affect observable behavior. We want to report what is happening while the test is running. For now, we’ll just send the output to <code>std::cout</code>. We’ll change this later in this chapter to avoid assuming the output destination. The first change is to include <code>iostream</code> in <code>Test.h</code>:</p>
			<pre class="source-code" lang="en-GB">
#define MERETDD_TEST_H
#include &lt;iostream&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;</pre>
			<p lang="en-GB">Then, change the <code>runTests</code> function to report the progress of the test being run, like this:</p>
			<pre class="source-code" lang="en-GB">
inline void runTests ()
{
    for (auto * test: getTests())
    {
        std::cout &lt;&lt; "---------------\n"
            &lt;&lt; test-&gt;name()
            &lt;&lt; std::endl;
        try
        {
            test-&gt;run();
        }
        catch (...)
        {
            test-&gt;setFailed("Unexpected exception thrown.");
        }
        if (test-&gt;passed())
        {
            std::cout &lt;&lt; "Passed"
                &lt;&lt; std::endl;
        }
        else
        {
            std::cout &lt;&lt; "Failed\n"
                &lt;&lt; test-&gt;reason()
                &lt;&lt; std::endl;
        }
    }
}</pre>
			<p lang="en-GB">The original <code>try/catch</code> remains unchanged. All we do is print some dashes for a separator and the name of the test. It’s probably a good idea to flush this line to the output right away. In the case that something happens later, at least the name of the test will be recorded. After the test is run, the test is checked to see whether it passed or not, and the appropriate message is displayed.</p>
			<p lang="en-GB">We’ll also change the<a id="_idIndexMarker040"/> test in <code>Creation.cpp</code> to throw something to make sure we get a failure. We no longer need to include <code>iostream</code> because it’s usually not a good idea to display anything from the test itself. You can display output from the test if you want to but any output in the test itself tends to mess up the reporting of the test results. When I sometimes need to display output from within a test, it’s usually temporary.</p>
			<p lang="en-GB">Here is the test modified to throw an int:</p>
			<pre class="source-code" lang="en-GB">
#include "../Test.h"
TEST
{
    throw 1;
}</pre>
			<p lang="en-GB">Normally, you would write code that throws something other than a simple <code>int</code> value, but at this point, we just want to show what happens when something does get thrown.</p>
			<p lang="en-GB">Building and running it now shows the expected failure due to an unexpected exception:</p>
			<pre>---------------
testCanBeCreated
Failed
Unexpected exception thrown.
Program ended with exit code: 0</pre>
			<p lang="en-GB">We can remove the <code>throw</code> statement from the test so that the body is completely empty and the test <a id="_idIndexMarker041"/>will now pass:</p>
			<pre>---------------
testCanBeCreated
Passed
Program ended with exit code: 0</pre>
			<p lang="en-GB">We don’t want to keep modifying the test for different scenarios. It’s time to add support for multiple tests.</p>
			<h1 id="_idParaDest-28" lang="en-GB"><a id="_idTextAnchor027"/>Enhancing the test declaration to support multiple tests</h1>
			<p lang="en-GB">While a single test works, trying to <a id="_idIndexMarker042"/>add another one does not build. This is what I tried to do in <code>Creation.cpp</code> by adding another test. One <a id="_idIndexMarker043"/>of the tests is empty and the second test throws an int. These are the two scenarios we were just trying to work with:</p>
			<pre class="source-code" lang="en-GB">
#include "../Test.h"
TEST
{
}
TEST
{
    throw 1;
}</pre>
			<p lang="en-GB">The failure is due to the <code>Test</code> class being declared twice, as well as the <code>run</code> method. The <code>TEST</code> macro declares a new global instance of the <code>Test</code> class each time it’s used. Each instance is called <code>test</code>. We don’t see the classes or the instances in the code because they are hidden by the <code>TEST</code> macro.</p>
			<p lang="en-GB">We’ll need to modify the <code>TEST</code> macro so that it will generate unique class and instance names. And while we’re doing that, let’s also fix the name of the test itself. We don’t want all tests to<a id="_idIndexMarker044"/> have the name <code>"testCanBeCreated"</code>, and since the name will need to come from the test declaration, we’ll <a id="_idIndexMarker045"/>need to also modify the <code>TEST</code> macro to accept a string. Here is how the new <code>Creation.cpp</code> file should look:</p>
			<pre class="source-code" lang="en-GB">
#include "../Test.h"
TEST("Test can be created")
{
}
TEST("Test with throw can be created")
{
    throw 1;
}</pre>
			<p lang="en-GB">This lets us give sentence names to each test, instead of treating the name like a single-word function name. We still need to modify the <code>TEST</code> macro but it’s good to start with the intended usage first and then make it work.</p>
			<p lang="en-GB">For making unique class and instance names, we could just ask for something unique from the programmer, but the type name of the class and the instance name of that class really are details<a id="_idIndexMarker046"/> that the programmer writing tests shouldn’t need to worry about. Requiring a unique<a id="_idIndexMarker047"/> name to be supplied would only make the details visible. We could instead use a base name and add to it the line number where the test is declared to make both the class and instance names unique.</p>
			<p lang="en-GB">Macros have the ability to get the line number of the source code file where the macro is used. All we have to do is modify the resulting class and instance names by appending this line number.</p>
			<p lang="en-GB">It would be nice if this was easy.</p>
			<p lang="en-GB">All the macros are handled by the preprocessor. It’s actually a bit more complicated than that but thinking in terms of the preprocessor is a good simplification. The preprocessor knows how to do simple text replacement and manipulation. The compiler never sees the original code that is written with the macro. The compiler instead sees the end result after the preprocessor is done.</p>
			<p lang="en-GB">We will need two sets of macros declared in <code>Test.h</code>. One set will generate a unique class name, such as <code>Test7</code> if the <code>TEST</code> macro was used on line 7. The other set of macros will generate a unique instance name, such as <code>test7</code>.</p>
			<p lang="en-GB">We need a set of macros because going from a line number to a concatenated result such as <code>Test7</code> requires multiple steps. If this is the first time you’ve seen macros used like this, it’s normal to find them confusing. Macros use simple text replacement rules that can seem like extra work for us at first. Going from a line number to a unique name requires multiple steps of text replacement that are not obvious. The macros look like this:</p>
			<pre class="source-code" lang="en-GB">
#define MERETDD_CLASS_FINAL( line ) Test ## line
#define MERETDD_CLASS_RELAY( line ) MERETDD_CLASS_FINAL( line )
#define MERETDD_CLASS MERETDD_CLASS_RELAY( __LINE__ )
#define MERETDD_INSTANCE_FINAL( line ) test ## line
#define MERETDD_INSTANCE_RELAY( line ) MERETDD_INSTANCE_FINAL( line )
#define MERETDD_INSTANCE MERETDD_INSTANCE_RELAY( __LINE__ )</pre>
			<p lang="en-GB">Each set needs three <a id="_idIndexMarker048"/>macros. The macro to use is the last in each set, <code>MERETDD_CLASS</code> and <code>MERETDD_INSTANCE</code>. Each of these will be replaced with the <code>relay</code> macro using the <code>__LINE__</code> value. The <code>relay</code> macro will see the real line number instead of <code>__LINE__</code> and the <code>relay</code> macro will then be replaced with the final macro and the line number it was given. The final macro will use the <code>##</code> operator to do the concatenation. I did warn you that it would be nice if this was easy. I’m sure this is one of the reasons so many programmers avoid macros. At least you’ve already made it through the most difficult usage of macros in this book.</p>
			<p lang="en-GB">The end result will be, for example, <code>Test7</code> for the class name and <code>test7</code> for the instance name. The <a id="_idIndexMarker049"/>only real difference between these two sets of macros is that the class name uses a capital <em class="italic" lang="">T</em> for <code>Test</code> and the instance name uses a lowercase <em class="italic" lang="">t</em> for <code>test</code>.</p>
			<p lang="en-GB">The class and instance macros need to be added to <code>Test.h</code> right above the definition of the <code>TEST</code> macro that will need to use them. All of this works because, even though the <code>TEST</code> macro looks like it uses many source code lines, remember that each line is terminated with a backslash. This causes everything to end up on a single line of code. This way, all the line numbers will be the same each time the <code>TEST</code> macro is used and the line number will be different the next time it’s used.</p>
			<p lang="en-GB">The new <code>TEST</code> macro looks like this:</p>
			<pre class="source-code" lang="en-GB">
#define TEST( testName ) \
class MERETDD_CLASS : public MereTDD::TestBase \
{ \
public: \
    MERETDD_CLASS (std::string_view name) \
    : TestBase(name) \
    { \
        MereTDD::getTests().push_back(this); \
    } \
    void run () override; \
}; \
MERETDD_CLASS MERETDD_INSTANCE(testName); \
void MERETDD_CLASS::run ()</pre>
			<p lang="en-GB">The <code>MERETDD_CLASS</code> macro is used to declare the class name, declare the constructor, declare<a id="_idIndexMarker050"/> the type of the global instance, and<a id="_idIndexMarker051"/> scope the <code>run</code> method declaration to the class. All four of these macros will use the same line number because of the backslashes at the end of each line.</p>
			<p lang="en-GB">The <code>MERETDD_INSTANCE</code> macro is used just once to declare the name of the global instance. It will also use the same line number as the class name.</p>
			<p lang="en-GB">Building the project and running now shows that the first test passes because it doesn’t really do anything and the second test fails because it throws the following:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test can be created</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test with throw can be created</strong>
<strong class="bold" lang="">Failed</strong>
<strong class="bold" lang="">Unexpected exception thrown.</strong>
<strong class="bold" lang="">Program ended with exit code: 0</strong></pre>
			<p lang="en-GB">The output ends a <a id="_idIndexMarker052"/>bit abruptly and it’s time <a id="_idIndexMarker053"/>to fix that. We’ll add a summary next.</p>
			<h1 id="_idParaDest-29" lang="en-GB"><a id="_idTextAnchor028"/>Summarizing the results</h1>
			<p lang="en-GB">The summary can begin with a <a id="_idIndexMarker054"/>count of how many tests will be run. I thought about adding a running count for each test but decided against that because the tests are run in no particular order right now. I don’t mean that they will be run in a different order each time the testing application is run but they could be reordered if the code is changed and the project is rebuilt. This is because there is no fixed order when creating the final application that the linker will use between multiple <code>.cpp</code> compilation units. Of course, we would need tests spread across multiple files to see the reordering, and right now, all the tests are in <code>Creation.cpp</code>.</p>
			<p lang="en-GB">The point is that the tests register themselves based on how the global instances get initialized. Within a single <code>.cpp</code> source file, there is a defined order, but there is no guaranteed order between multiple files. Because of this, I decided not to include a number next to each test result.</p>
			<p lang="en-GB">We’ll keep track of how many tests passed and how many failed, and at the end of the <code>for</code> loop that runs all the tests, a summary can be displayed.</p>
			<p lang="en-GB">As an additional benefit, we can also change the <code>runTests</code> function to return the count of how many tests failed. This will let the <code>main</code> function return the failed count too so that a script can test this value to see whether the tests passed or how many failed. An application exit code of zero will mean that nothing failed. Anything other than zero will represent a failed run and will indicate how many tests have failed.</p>
			<p lang="en-GB">Here is the simple change to <code>main.cpp</code> to return the failed count:</p>
			<pre class="source-code" lang="en-GB">
int main ()
{
    return MereTDD::runTests();
}</pre>
			<p lang="en-GB">Then, here is the new <code>runTests</code> function with the summary changes. The changes are described in three parts. All of this is a single function. Only the description is broken into three parts. The<a id="_idIndexMarker055"/> first part just displays the count of how many tests will be run:</p>
			<pre class="source-code" lang="en-GB">
inline int runTests ()
{
    std::cout &lt;&lt; "Running "
        &lt;&lt; getTests().size()
        &lt;&lt; " tests\n";</pre>
			<p lang="en-GB">In the second part, we need to keep track of how many tests pass and how many fail, like this:</p>
			<pre class="source-code" lang="en-GB">
    int numPassed = 0;
    int numFailed = 0;
    for (auto * test: getTests())
    {
        std::cout &lt;&lt; "---------------\n"
            &lt;&lt; test-&gt;name()
            &lt;&lt; std::endl;
        try
        {
            test-&gt;run();
        }
        catch (...)
        {
            test-&gt;setFailed("Unexpected exception thrown.");
        }
        if (test-&gt;passed())
        {
            ++numPassed;
            std::cout &lt;&lt; "Passed"
                &lt;&lt; std::endl;
        }
        else
        {
            ++numFailed;
            std::cout &lt;&lt; "Failed\n"
                &lt;&lt; test-&gt;reason()
                &lt;&lt; std::endl;
        }
    }</pre>
			<p lang="en-GB">And in the third part, after<a id="_idIndexMarker056"/> looping through all the tests and counting how many passed and how many failed, we display a summary with the counts, like this:</p>
			<pre class="source-code" lang="en-GB">
    std::cout &lt;&lt; "---------------\n";
    if (numFailed == 0)
    {
        std::cout &lt;&lt; "All tests passed."
            &lt;&lt; std::endl;
    }
    else
    {
        std::cout &lt;&lt; "Tests passed: " &lt;&lt; numPassed
            &lt;&lt; "\nTests failed: " &lt;&lt; numFailed
            &lt;&lt; std::endl;
    }
    return numFailed;
}</pre>
			<p lang="en-GB">Running the project now shows an initial count, the individual test results, and a final summary, and you can also see the application exit code is <code>1</code> because of the failed test:</p>
			<pre class="source-code" lang="en-GB">
<strong class="bold" lang="">Running 2 tests</strong>
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test can be created</strong>
<strong class="bold" lang="">Passed</strong>
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Test with throw can be created</strong>
<strong class="bold" lang="">Failed</strong>
<strong class="bold" lang="">Unexpected exception thrown.</strong>
<strong class="bold" lang="">---------------</strong>
<strong class="bold" lang="">Tests passed: 1</strong>
<strong class="bold" lang="">Tests failed: 1</strong>
<strong class="bold" lang="">Program ended with exit code: 1</strong></pre>
			<p lang="en-GB">The final line that displays the exit code is not actually part of the testing application. This is normally not <a id="_idIndexMarker057"/>shown when the application is run. It’s part of the development environment that I am using to write this code. You would normally be interested in the exit code if you were running the testing application from a script such as Python as part of an automated build script.</p>
			<p lang="en-GB">We have one bit of cleanup still to do with the results. You see, right now, everything gets sent to <code>std::cout</code> and this assumption should be fixed so that the results can be sent to any output stream. The next section will do this cleanup.</p>
			<h1 id="_idParaDest-30" lang="en-GB"><a id="_idTextAnchor029"/>Redirecting the output results</h1>
			<p lang="en-GB">This is a simple edit that should not <a id="_idIndexMarker058"/>cause any real change to the application so far. Right now, the <code>runTests</code> function uses <code>std::cout</code> directly when displaying the results. We’re going to change this so that the <code>main</code> function will pass <code>std::cout</code> as an argument to <code>runTests</code>. Nothing will actually change because we’ll still be using <code>std::cout</code> for the results but this is a better design because it lets the testing application decide where to send the results, instead of the testing library.</p>
			<p lang="en-GB">By the testing library, I mean the <code>Test.h</code> file. This is the file that other applications will include in order to create <a id="_idIndexMarker059"/>and run tests. With the project we have so far, it’s a bit different because we’re writing tests to test the library itself. So, the whole application is just the <code>Test.h</code> file and the <code>tests</code> folder containing the testing application.</p>
			<p lang="en-GB">We first need to change <code>main.cpp</code> to include <code>iostream</code> and then pass <code>std::cout</code> to <code>runTests</code>, like this:</p>
			<pre class="source-code" lang="en-GB">
#include "../Test.h"
#include &lt;iostream&gt;
int main ()
{
    return MereTDD::runTests(std::cout);
}</pre>
			<p lang="en-GB">Then, we no longer need to include <code>iostream</code> in <code>Test.h</code>, because it really doesn’t need any input and it doesn’t need to refer to <code>std::cout</code> directly. All it needs is to include <code>ostream</code> for the output stream. This could be the standard output, a file, or some other stream:</p>
			<pre class="source-code" lang="en-GB">
#ifndef MERETDD_TEST_H
#define MERETDD_TEST_H
#include &lt;ostream&gt;
#include &lt;string_view&gt;
#include &lt;vector&gt;</pre>
			<p lang="en-GB">Most of the changes<a id="_idIndexMarker060"/> are to replace <code>std::cout</code> with a new parameter called <code>output</code>, like this in the <code>runTests</code> function:</p>
			<pre class="source-code" lang="en-GB">
inline int runTests (std::ostream &amp; output)
{
    output &lt;&lt; "Running "
        &lt;&lt; getTests().size()
        &lt;&lt; " tests\n";
    int numPassed = 0;
    int numFailed = 0;
    for (auto * test: getTests())
    {
        output &lt;&lt; "---------------\n"
            &lt;&lt; test-&gt;name()
            &lt;&lt; std::endl;</pre>
			<p lang="en-GB">Not all of the changes are shown in the previous code. All you need to do is replace every use of <code>std::cout</code> with <code>output</code>.</p>
			<p lang="en-GB">This was a simple change and does not affect the output of the application at all. In fact, it’s good to make changes like this that are isolated from other changes, just so the new results can be compared with previous results to make sure nothing unexpected has changed.</p>
			<h1 id="_idParaDest-31" lang="en-GB"><a id="_idTextAnchor030"/>Summary</h1>
			<p lang="en-GB">This chapter introduced macros and their ability to generate code based on the line number as a way to enable multiple tests. Each test is its own class with its own uniquely named global object instance.</p>
			<p lang="en-GB">Once multiple tests were supported, then you saw how to track and report the results of each test.</p>
			<p lang="en-GB">The next chapter will use the build failures in this chapter to show you the first step in the TDD process. We’ve been following these process steps already without specifically mentioning them. You’ll learn more about the TDD process in the next chapter, and the way that the test library has been developed so far should start making more sense as you understand the reasons.</p>
		</div>
	</body></html>