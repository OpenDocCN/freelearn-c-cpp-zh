- en: Blueprint Review and When to Use BP Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to our next chapter. This will be our first departure from focusing
    on C++ code, but not the last. Unreal has many systems with great capabilities
    that exist in a form you can access from the editor without writing any code.
    The most flexible and most closely related to actually writing code will be explored
    here, delving into UE4''s blueprint system and its capabilities and limitations.
    Up until now, most of our work has been implementing things in C++ and minimally
    showing how these are interacted with as blueprint objects in the editor. Blueprint
    is capable of much more, including making whole games.  In this chapter we''ll
    cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint review/overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blueprint-only games, pros and cons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scritping an object with blueprint (elevator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blueprint tips & tricks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like last time, the work in this chapter will be done by utilizing what was
    finished in [Chapter 2](5cc3645d-8420-4178-9897-2c71100caeac.xhtml), *Inventory
    and Weapons for the Player*. This, however, is not strictly required and the contents
    here should be implementable with the [Chapter 1](dfc11944-e8b6-45b1-8997-5f1a59d0f8ac.xhtml), *Making
    a C++ Project for a First-Person Shooter*, project or even a new UE4 template.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, the GitHub branch for this chapter is here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-3](https://github.com/PacktPublishing/Mastering-Game-Development-with-Unreal-Engine-4-Second-Edition/tree/Chapter-3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Engine version used: 4.19.0.'
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint review and Blueprint-only games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s fair to ask: just what exactly is "blueprint?" There are really two main
    areas to be concerned with. The first we have already touched on previously and
    used: integrating C++ classes with the UE4 editor. Classes used in the editor
    are typically derived from `UObject` at some level, and this allows for them to
    utilize things such as the `UPROPERTY` and `UFUNCTION` macros that then allow
    these to be accessed by blueprint instances of those classes, such as `StealthCharacter`.
    With a few exceptions of some basic geometry and other essential game objects,
    almost everything placed directly in a level by yourself or designers or artists
    will be an instance of a blueprint class, such as our character in the level now.
    The other area to be aware of that every project should evaluate for its needs
    is the **blueprint visual scripting** (**BVS**) system. Almost all gameplay concepts
    you can think of doing in C++ are possible in blueprint scripting. It also has
    an integrated debugger you can use with breakpoints during runtime. Here, we will
    delve into these concepts a bit more deeply and look at some of the advantages
    and limitations for scripting.'
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have shown multiple times in our previous chapters, the advantages of
    exposing variables that will be iterated upon or made unique in many instances
    of the same class type is fairly obvious: these variables can be modified while
    running the editor by content creators with no programming knowledge whatsoever.
    System designers in particular depend on having the right variables exposed so
    they can tune and build variants of systems quickly and test them equally quickly.
    Doing this almost entirely from C++ as the FPS template begins means that changing
    those values at best requires compiling and doing a hot-reload of the game while
    in the editor, and at worst, shutting down the editor, building, and restarting
    it. Much like scripting in blueprint, discussed in the next paragraph, much of
    blueprint''s exposure and utilization in your game comes down, once again, to
    your team''s and project''s needs. If the design of a class for your game is almost
    certain to never change or change very minimally over the course of the project,
    and you have plenty of C++ programmers as resources, maybe it makes sense to get
    things done in a very direct way like the FPS template''s character started for
    us. However, if you have designers (system-level or otherwise) who are anxious
    to get started building a variety of game objects and are constantly changing
    them, adding new variations, and testing these quickly in levels, the more blueprint
    flexibility you can give them, the better!  As noted previously, at the most basic
    level, blueprint classes are excellent data containers: even if designers or artists
    are never going to use them, programmers directly benefit from having access to
    view and often modify as much data as possible in classes while staying in the
    editor. The iteration time is instantaneous, and you can always check your values
    without switching context from the editor to Visual Studio or other windows. Of
    course, there are sensitive, critical values that you may not want anyone arbitrarily
    modifying from blueprint, but with `UPROPERTY` flags such as `BlueprintReadOnly`,
    you can easily give people the availability to view what is currently set for
    a property without letting someone accidentally modify it and save a bad value.
    Hopefully the point is made well enough here that other than making sure you keep
    inexperienced people from changing critical data, there is almost no downside
    to exposing any interesting variables of a class that can be viewed in the editor
    as `UPROPERTY` types.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, on to visual scripting. This is so far wholly untouched in our prject,
    but that is about to change with a fully utilized example in the next section
    (*Blueprint scripting and performance*). For those new to using blueprint scripting,
    as it's possible also to make entire games while never using it at all, don't
    worry, there will be lots of screenshots and direct work in it in that section.
    For now, though, we will simply discuss from a high level the capabilities and
    drawbacks of using scripting. First, what are some major things that you can do
    in blueprint scripting?
  prefs: []
  type: TYPE_NORMAL
- en: 'Game logic: Including `for`/`while` loops, using local and class variables
    of most types, and access to huge numbers of functions in existing UE4 classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Game mechanics: Interaction between objects in the world, collision responses,
    movement, and even pathfinding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access shareable Blueprint Function Libraries: These are groups of stateless/static
    utility functions you can write in both C++ or blueprint scripting, and share
    with different teams or projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily integrate with UI in the UMG editor, often crucial for UI/UX designers'
    workflow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No rebuilding any executable or code, and easy referencing of one object to
    another: as will be discussed in the section immediately following this one, you
    can (and people do) make whole games just using scripting for logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sounds great, right!? Well, before you think there''s a very big *but* coming,
    let''s be clear: blueprint scripting *is* quite great, and powerful. Here is a
    quick list of some drawbacks to be aware of, but comparing those to the capabilities
    blueprint scripting gives out of the box to teams who invest in getting familiar
    and comfortable with it, well, the drawbacks are overall very minor:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance costs can be significant: It''s generally possible to minimize
    these, but profiling them and determining problem areas is harder and requires
    a different skillset than profiling C++ code for issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loss of access to certain data types: C++ is only dependent on your platform
    compiler settings, but blueprints must be usable and accessible across all platforms
    UE4 supports (32 and 64 bit, mobile, web, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Debugging can be... buggy: Often, the context of how you got to a breakpoint
    is missing, or certain variables won''t be available when you hover over them.
    It''s great to have the debugger, but when it doesn''t work, you''re on your own.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Anyone can modify or add things to blueprints: *anyone!*This means your team
    needs to have very well-defined roles for who can modify what types of things,
    to prevent someone without expertise introducing bugs that are hard to find.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Switching back and forth between C++ code and blueprint scripting can be distracting:
    Often, to get the whole picture of what''s going on, you need data from both,
    and switching contexts can slow down development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, a brief discussion of a few of these points and how to mitigate them.
    For performance profiling, the editor has a very good tool built into it that
    if you''re not already familiar with, take some time and see what it can do. This
    is the Profiler in the Session Frontend window, which can be accessed from the
    Window toolbar under Development Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b51d360a-c291-4c51-88fc-ee4a44c9cebd.png)'
  prefs: []
  type: TYPE_IMG
- en: If a team is disciplined about tracking performance from the start, it is usually
    a bit easier to track down what has changed and caused a problem. But again, keep
    in mind, something as simple as changing a value of one variable might be detrimental
    to performance, and if you use compiled blueprints, there may be no way to easily
    search for that change in version tracking history. Two strategies to mitigate
    this are to integrate source control to the editor, and "nativize" blueprints.
    If you have a supported source control package (this book's project is using Git),
    you can enable source control integration by right-clicking any blueprint asset
    in the editor, and at the bottom of the popup is the option to connect to source
    control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it''s set up, you can right-click on any blueprint asset again, such as
    the FirstPersonCharacter, and different. versions of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50c96fb5-a61e-4085-8987-388f6e7f3947.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding data changes can be difficult at times (look closely and you'll see
    where Can Crouch was changed in the preceding screenshot), but when it works right,
    showing script changes as visual graphs side by side can be incredibly helpful
    in tracking down where a new change may have caused a problem.
  prefs: []
  type: TYPE_NORMAL
- en: A tutorial on setting this up for Git can be found in the *Further reading*
    section of this chapter. Nativizing blueprints can be enabled under Project Settings | Packaging
    | Blueprints.  This turns all blueprint classes in the editor into intermediate
    C++ classes, and packages them to your project. You may have a few reasons to
    do this. It's something to experiment with if your project is having trouble understanding
    why some blueprints are not working as expected, but we won't spend further time
    on this option here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, regarding the loss of data types, it''s entirely possible with Blueprint
    Function Libraries. You can use native (compiler) types for your platform and
    return results in types that blueprint can then use. For example, if you had some
    UI using the existing UE4 `FDateTime` values and want the difference between them
    in seconds, this is not doable in blueprint directly because the values of those
    date-time `structs` is natively in `int64` format. So you could easily make a
    function such as this, which takes the two dates from blueprint, does the math
    natively (`ToUnixTimestamp` returns an `int64`) and then returns the result as
    an `int32`, which blueprint can then access (and thus the UI can display):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And then the simple C++ implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, in the C++, we use a type that isn't allowed to be used directly in a blueprint,
    but this works across all modern C++ compilers. Of course, if the dates are very
    far apart, you could lose some data in this calculation/truncation, but so long
    as it can be assumed that there is no case where dates would be near that level
    of separation, it is an easy solution to an `int64` calculation that can now be
    accessed from anywhere in blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Right before the list of drawbacks mentioned previously, it was stated that
    these issues overall are very minor, but keep in mind that this was in the context
    of the power blueprint gives you. For example, you can set up a multiplayer game
    session, have other players search for and connect to it, and begin playing a
    match together, all from just a few existing blueprint nodes UE4 provides to you.
    This is incredibly powerful and could take a programmer who's unfamiliar with
    that workflow days or even weeks to get correct using `FAsyncTask` tasks and `OnlineSubsystem`
    calls, all triggered from the right events in the `GameMode`, or the like. So
    is this the way to go 100%, and let's forget this whole C++ business for your
    project?  That's what we'll finally discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint-only games – is this right for you?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have established that blueprints are required at some level for any game,
    and blueprint scripting is a very powerful tool that can save a ton of time when
    implementing systems or reusable pieces that would otherwise be written with dozens,
    hundreds, or potentially many thousands of lines of C++ code. We have now also
    discussed the risks and drawbacks to using blueprint scripting, but now keep in
    mind that in a project that is blueprint only, you are stuck with these choices.
    As soon as you hit a problem that seemingly can't be solved and have to add as
    much as one new C++ class to your project, well, you might as well have started
    with a basic C++ project from day one in hindsight, and that is a very common
    outcome. Teams that are very experienced with blueprint scripting and its limitations
    when starting a project can navigate these things in their design up-front. If
    you're unsure whether you can do all of what needs to be done for your game's
    design at the start of your project, make it C++ and then you can use as much
    from blueprint and C++ as your team's bandwidth and developers prefer, but converting
    a very large blueprint-only project to C++ will be a great deal more work later
    in a project's workflow.  Adding C++ builds may be very disruptive and distracting
    to a team used to never having to do them if you are farther along in development,
    so again, when in doubt, just start with C++ capabilities in your flow and balance
    your workload between the two systems in whichever way is optimal. A team with
    very little C++ code that changes or is added over time will find their workflow
    then to mostly be the same quick iterations as a blueprint-only project anyway,
    but have all the infrastructure available and workflow established to add C++
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'iOS developers! There is a huge reason for you to consider staying blueprint-only
    for a long time, if not for a whole project, depending on its scope: UE4 can package,
    run, and test on iOS device builds from a Windows PC, *if *they are blueprint
    only. This can be a huge advantage to proving out an iOS concept quickly, or to
    massively reduce build times when iterating quickly on gameplay ideas. You will
    still eventually need at least a Mac that can run a version of Xcode, and an Apple
    Developer License, to ultimately submit to Apple, but blueprint-only is a great
    way to quickly prove what your game can do on an iPhone or iPad.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a rule of thumb, there are generally two types of teams that will want to
    go blueprint-only:'
  prefs: []
  type: TYPE_NORMAL
- en: Those with no one available to handle difficult C++ development, problems, or
    set up the workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those with a very simple design, or a very experienced set of blueprint-developers
    who know its limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often indie-teams fall into a bit of each of these, and again, there is nothing
    wrong with prototyping a game quickly in blueprint only and if you find you must
    switch later, it can be done. For those with some experience on a few different
    teams, though, always weigh the preceding topics and decide wisely before starting,
    if at all possible.
  prefs: []
  type: TYPE_NORMAL
- en: Going *back* to a blueprint-only game after some (even not so significant/major)
    C++ work has been done can be a very difficult to downright-impractical process.
    It's also another good rule of thumb to just accept once you open the C++ box,
    do not have any expectation you will shut it again.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint scripting and performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So you may be thinking at this point: we sure have talked a lot about the benefits
    and drawbacks of blueprint scripting and blueprint-only problems, but we still
    haven''t just sat down and *made* any to see how it goes and how we can profile
    its performance. Let''s do so now, and get a real-world game system built that
    we can investigate with: in this case, a game''s classic moving platform.'
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint scripting example – moving platform and elevator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I''m sure you can imagine after all of this talk, this class, and the work
    implementing its gameplay, will be done almost exclusively in the editor (there
    are ways you can always hook C++ to blueprint, which will be discussed near the
    end). So, start off by opening the editor and going in the content browser tab
    to our Content | FirstPersonCPP | Blueprints and right-click, like we have done
    before, to make a new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b345a7ac-f962-4d3b-9fcc-8511c2313585.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click Actor as the parent class for the blueprint, and name it MovingPlatform.
    Now, we have a completely bare-bones actor we could place in our world, but it
    doesn''t even have any geometry, of course. Let''s quickly fix this. Panning around
    the level, you''ll see two gray rectangular boxes (not the white boxes, but those
    actually work fine too): click one and then right-click on it and select Browse
    to Asset (*Ctrl* + *B*) (note, you can also find this when editing most assets
    from the menu bar under Asset), and you should be in Content | Geometry | Meshes
    now with 1M_Cube selected. So, now that we know how to find this simple piece
    of geometry, let''s go back to our MovingPlatform and double-click it. You may
    notice, since we made this as a blueprint class from the start, you get the full
    blueprint editor automatically, and not the minimal interface it normally starts
    with for native classes that don''t use scripting, as we often had before. For
    our platform object, we now need to add a component. Note that you could just
    add a simple cube or plane as a static mesh component. It is great that these
    things are available, again, especially for quick prototyping. Just to get used
    to the workflow, however, which is more typical of professional games, we will
    use the static mesh cube we were just looking at. So, type to filter or just scroll
    for Static Mesh in the components drop-down and add one. Now notice in the hierarchy
    how this is added under the default scene component (named DefaultSceneRoot).
    Once we have an actor component in our case, that can *be* the root component
    of our actor object here, the default is really just a placeholder. So, rename
    the mesh component to Platform and drag it on top of the scene component to replace
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll do two more quick moves to get this platform looking right, click
    the mesh component and on the right in its properties, under Static Mesh | Static
    Mesh, select 1M_Cube, which we found earlier, and click the unlock icon to the
    right of Transsform | Scale and things should be coming together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51b4acd1-05eb-48ea-8d0b-5cfc5c3e2ea3.png)'
  prefs: []
  type: TYPE_IMG
- en: We can now drag these into our scene, but of course, it won't do anything other
    than block our player, as the step-height is too high for its collision to handle.
    You will also notice it need to compile and save, good steps any time you are
    making progress on a blueprint, though if its scripting is not ready to successfully
    compile, obviously hold off until it is. You can save and use blueprints with
    broken scripting, but their warning messages can be very distracting and allow
    people to not notice other broken blueprint issues that may be critical.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can really use and script this platform, however, we need to add one
    more component. Unreal keeps blocking (hit) and overlap (touch) collisions separate,
    and in this case we need a bit of both. So, click Add Component, and this time
    we simply will add a cube from its list. Notice it should be parented to Platform and
    because of this, its size is the same since the scale from Platform propagates
    to our new cube. Now, raise it up a few centimeters by either dragging in the
    viewport along the Z axis or typing in a value in its transform until you can
    see it is above but is still basically touching our original platform (I found
    a Z value of 50 worked for 5 cm since our Z scale is 0.1). Now, scroll down until
    you see the Collision flyout and make sure Generate Overlap Events is checked.
    Click in the drop-down for preset to OverlapOnlyPawn, and down in the Rendering
    flyout, uncheck Visible as we don't want to see this piece because it is only
    there to detect our character walking on it. In the Platform component's collision
    events, you can leave this as BlockAllDynamic, and note that generating overlap
    events is irrelevant as hit events supersede overlap, so you will receive events
    when projectiles or the player hit the platform, but we would never get the overlap
    events we need with these filters.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/962489d1-4b3c-4d6f-bdfd-0b232062fce8.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how everything should look right before clicking the Visible box at
    the bottom of this screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, to some blueprint scripting! Click over to the Event Graph tab
    and you''ll see the existing events are grayed out with notes about how to enable
    them. In our case, we want the overlap box. Click and drag from the blue Other
    Actor pin (from here on, we''ll just call this a *pull* from the pin), and you
    will see a list of many things we can add that are context-sorted (so long as
    the checkbox remains checked) to things that take an actor as input, the way that
    pin from the event is supplying it as an output. Filter for `GetClass`, and you
    see it has been added now. For those familiar with blueprint scripting, just check
    out the following screenshot for the progress. Here are the steps (after adding
    `GetClass`) to have that in place:'
  prefs: []
  type: TYPE_NORMAL
- en: Pull the return value for Get Class, and find Is Child Of in the list. These
    should now be wired. In the Is Child Of box, in its dropdown, select our MasteringCharacter
    class as the type so only our player gives a true result here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull the red result pin from is child of and filter or find Branch, then wire
    this from the white triangle output pin of the actor begin overlap event, and
    in to the input white pin of the Branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull the white output (which points right) pin from the branch's True result
    and filter and add a MoveComponentTo block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull left from the MoveComponentTo block's blue component pin and type to filter
    for GetPlatform (a reference to our root component).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull left from the TargetRelativeLocation yellow pin and type + or otherwise
    filter/scroll for vector + vector in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull from its top left pin and type/filter for GetActorLocation, and you can
    leave the input pin on that node as self (that's what we want).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the bottom vector's destination to what you want. In my test case, a Z value
    of 300 puts us up even with these other large gray blocks around the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The TargetRelativeLocation variable seems a bit poorly named, as what it wants
    for a proper motion is a world location. And lastly, on that MoveToLocation node,
    set the time to whatever you like: 4 seconds as here is a little slow and boring,
    but great for demonstrating that this all works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e147bd98-1250-4ba5-ac1b-2233b7c687b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Don't forget to compile and save.
  prefs: []
  type: TYPE_NORMAL
- en: Note that running the game in play-in-editor mode will always try to compile
    any edited blueprints before running (and give errors to the output log if there
    are any), but it will *not* save those assets!  You still have to do this with
    a save-all or Ctrl + S on your blueprints and level editing windows! If you shut
    down your editor directly via Visual Studio, you won't even get prompted to save
    any unsaved levels or assets, so it's usually best when working in editor to close
    via its window 's X button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all that''s left to show this off is to drag one of our Moving it into
    the world on the floor somewhere, and walk over and step on it. Off you go in
    the air! Note that if you step on it again by hopping off and on, it takes you
    up further. We''ll make this thing a bit better shortly, but right now, this is
    a good checkpoint for the GitHub version of the project. Here you can see where
    it is placed in the book''s project''s map (again, by dragging the MovingPlatform
    blueprint icon into the main level window itself):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2591cbb9-b7a8-46f6-a226-a3a8f469c185.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are many, many more options that we could do with something like this
    now. It''s possible to add all kinds of logic, including other components, allowing
    this platform to do pathfinding navigation, or adding a spline to the world that
    in the level blueprint for the platform uses (from the main editor window, click
    Blueprints | Open Editor Blueprint to access individual blueprints that can reference
    each other in the level). There is a massive amount of very valuable work that
    can be done in these areas. For now, we will make the platform head back to its
    start point when the player steps off, and the same when it reaches the top of
    its movement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3ea792d-aecf-4d1e-92b4-1f5c03cb02a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that this uses a couple of blueprint variables added to the class, too,
    a short reference to which is added in the *Further reading* section. The short
    version is under the My Blueprint tab on the left. There is Add New, and under
    that is Variable. Once you add one, you can change the type and default value.
    Here, we added one we renamed under My Blueprint | Variables as StartPosition,
    and on the right under details, set its type to vector, and also add GoingHome
    as a boolean. You can always then access these types, like C++ exposed variables
    too, in get/set blocks in blueprint scripting windows. Note, though, that unless
    you make a specific accessor (and here is an example that is *not* used, but you
    could implement) these variables cannot be accessed in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Making this a blueprint-implementable event that means for a hybrid C++/blueprint
    class you could add this as an event type function in blueprint and then simply
    have it return StartPosition. This way, a variable that is only defined in blueprint
    could be accessed by C++. Similarly, to make native functions in C++ that can
    do work as we have before, be sure to keep in mind BlueprintCallable as a `UFUNCTION` keyword,
    as these can be accessed *by* blueprint any time you are in or using an instance
    of the class that implements it.  Spoiler alert: we will be doing this quite a
    bit in the next chapter, [Chapter 4](eadb37a8-4ecb-4fc9-b391-e65671c99fc0.xhtml), *U.I.
    Necessities: Menus, HUD, and Load/Save*, similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These functions do work in C++, but can be directly called by blueprint. Note
    also that these calls from C++ to blueprint and vice versa have a fairly significant
    call-stack overhead. On previous hardware this was a major performance issue,
    but to save you time here and now, on most platforms these days, the overhead
    really is minimal. Keep this in mind that if you switch between the two frequently,
    but there is no longer the same level of stress that was caused in UE3's similar
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so these asides about how to call back and forth from C++ to blueprint
    notwithstanding, let''s get back to our quick logic to get this elevator in a
    finished state. As you can see, there are several steps, and once again for brevity,
    let''s just add them here in an ordered list:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need our two new variables, so as noted earlier, in the My Blueprint
    tab, click add new twice and pick variable from the list for each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the first one, rename it GoingHome, and its type can remain as-is, as a
    boolean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the second, also as noted, name it StartPosition and give it the type of
    a vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, pull from the event for BeginPlay in the scripting window and filter to
    Set Start Position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull left from its vector and pick GetActorLocation like we did earlier, again
    leaving self as the object. Now, when we begin playing, this platform will mark
    its initial location and save it in a blueprint-only variable we just made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now pull from our existing MoveComponentTo node and filter to Set Going Home,
    and check its box to true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull from that node, and make a new MoveComponentTo node similar to how we did
    before. Use Platform again as the input component, but as the TargetRelativeLocation,
    drag from it and filter to GetStartPosition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull from the new MoveComponentTo node's output and filter to SetGoingHome,
    making sure this time the node is unchecked so it's set to false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need a new event: right-click anywhere and filter to ActorEndOverlap.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from its output and add another branch. Pull that branch's condition and
    do the same logic we did before, pulling the end-overlap's OtherActor to a `GetClass`
    node, then that return to a ClassIsChildOf MasteringCharacter, or just copy and
    paste those nodes with a multi or shift/control select from the begin-overlap
    and save yourself some trouble.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When that branch is true (this means our player's character is no longer on
    the platform), pull from the true, filter to SetGoingHome, and check its box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull from that to a branch, pull from its condition to and filter to GetGoingHome.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull from the branch's true and add the same set of logic as before with MoveComponentTo
    (to StartPosition, clearing GoingHome to false after completion).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What you should have now should match both the preceding screenshot and the
    final check-in for GitHub in the `chapter 3` branch. This elevator pad should
    now reliably get you up to the next floor, but also return to its start once it
    arrives there or is abandoned. Ideally there should probably be a timer when reaching
    the top before it auto-returns, and there's no reason most games could not generally
    just rely on the end-overlap path to reset the platform. Again, this is just showing
    a hint of what blueprint can do for you and is a great starting point for further
    experimentation!
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint tips, tricks, and performance hits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last real question with blueprints is how to see where your performance
    problems may arise and what can make life easier. As has already been noted, you
    can use the built-in UE4 profiling tools. This is always a good place to start.
    Also listed at the end of this section in additional reading is a Stack Overflow
    discussion of profiling tools. I highly recommend VTune from Intel, and if you
    have a hardware device that''s compatible, the NVIDIA Visual Profiler is also
    an excellent tool. However, note that these items will show you in C++ classes
    what the hot-spots are. When you see K2 classes (or for older types, classes with
    *Kismet* in the name) from C++, you can be assured those are things spending time
    in blueprint doing work, but other things such as pathfinding, physics, or collisions
    may be less obvious. You may then have to work backwards to find what these mean
    in blueprint. A faster but cruder way to test performance with blueprints is simply
    to unhook (make pieces of blueprint not be called) and compare previous profiling
    with current profiling (or even just look at your frames per second!). There may
    be obvious areas of blueprint that are causing you performance pain, and fixing
    them or changing them will mitigate the problem. Keep especially in mind, though,
    like in the example of what''s possible: pathfinding, or modifying the NavMesh,
    is entirely possible from blueprint objects. If our elevator platform modifies
    the NavMesh (this is a fairly simple setting, but beyond the scope of this chapter),
    it can be a significant performance hit as it moves! Know your tools and use what
    works best, but always have an eye on performance. Every game has to run smoothly
    on your target platforms to be a success.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One last rule of thumb for this chapter: if you *can* do it in blueprint, *do* it
    in blueprint first. Prove a mechanic works and is fun there in short order. Get
    players joining and starting multiplayer games together with blueprint nodes and
    not huge amounts of new C++ code. Use what is there, and find when it finally
    hits the limits of your requirements before you write your own C++ versions. Blueprint
    can''t do everything, but it can do a huge amount of things quite well, with very
    minimal effort for those who know it.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve learned to do some blueprint scripting, seen some examples
    thereof, and some of the limitations and performance problems that it brings.
    It''s vastly powerful and easy to learn compared to writing C++ code, but using
    it late in a complex project it can be a big headache. Know your team, know your
    options, and know your limitations: these are the keys to making the right decisions
    when it comes to blueprint and your project. Additionally, this blueprint knowledge
    will be invaluable when doing even basic UI work as we will in the next chapter.
    UMG (the editing interface primarily used by UE4) is heavily ingrained in blueprint
    work, and blueprint has a relatively easy time integrating from the game back
    into that UI. These are, like most things in UE4, not specifically required to
    have to work together, but now that there is a solid foundation and understanding
    of the strengths of blueprint, the benefits reaped in getting UI working quickly
    and to desired specifications will be easy to see!'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What two systems from UE3 did blueprint grow from, giving in the K2_ prefix
    for most of its C++ classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a huge advantage of having source control integration in the editor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are `UFUNCTIONS` and `UPROPERTIES` so valuable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a good estimate of the time it would take to add session joining via
    C++?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some tools to use to profile the performance of work done in blueprint?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some drawbacks to building gameplay in blueprint and not C++?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is blueprint at some level absolutely required for any UE4 project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you also need to do if you let running the PIE game compile your blueprints?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Git integration in UE4 editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.unrealengine.com/Git_source_control_(Tutorial)](https://wiki.unrealengine.com/Git_source_control_(Tutorial))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Quick overview of blueprint online session nodes. Be sure to read the link
    about online subsystems if you''re unfamiliar with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/OnlineNodes](https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/OnlineNodes)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Blueprint variables overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/Variables](https://docs.unrealengine.com/en-us/Engine/Blueprints/UserGuide/Variables)'
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ profiling tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://stackoverflow.com/questions/67554/whats-the-best-free-c-profiler-for-windows](https://stackoverflow.com/questions/67554/whats-the-best-free-c-profiler-for-windows)'
  prefs: []
  type: TYPE_NORMAL
