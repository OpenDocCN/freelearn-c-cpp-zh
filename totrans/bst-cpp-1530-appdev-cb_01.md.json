["```cpp\n$ cp --help \n\nUsage: cp [OPTION]... [-T] SOURCE DEST \n -a, --archive           same as -dR --preserve=all \n -b                      like --backup but does not accept an argument\n\n```", "```cpp\n$ our_program –apples=10 –oranges=20\nFruits count: 30\n\n```", "```cpp\n    #include <boost/program_options.hpp>\n    #include <iostream>\n    namespace opt = boost::program_options;\n    ```", "```cpp\n    // Constructing an options describing variable and giving\n    // it a textual description \"All options\" to it.\n    opt::options_description desc(\"All options\");\n\n    // When we are adding options, first parameter is a name\n    // to be used in command line. Second parameter is a type\n    // of that option, wrapped in value<> class. \n    // Third parameter must be a short description of that \n    // option\n    desc.add_options()\n        (\"apples\", opt::value<int>(), \"how many apples do you have\")\n        (\"oranges\", opt::value<int>(), \"how many oranges do you have\")\n    ;\n    ```", "```cpp\n    // Variable to store our command line arguments\n    opt::variables_map vm;\n\n    // Parsing and storing arguments\n    opt::store(opt::parse_command_line(argc, argv, desc), vm);\n    opt::notify(vm);\n    std::cout << \"Fruits count: \"\n        << vm[\"apples\"].as<int>() + vm[\"oranges\"].as<int>()\n        << std::endl;\n    ```", "```cpp\n        (\"help\", \"produce help message\")\n    ```", "```cpp\n    if (vm.count(\"help\")) {\n        std::cout << desc << \"\\n\";\n        return 1;\n    }\n    ```", "```cpp\n    All options: \n      --apples arg          how many apples do you have \n      --oranges arg         how many oranges do you have \n      --help                produce help message\n    ```", "```cpp\n    #include <boost/program_options.hpp>\n    // 'reading_file' exception class is declared in errors.hpp\n    #include <boost/program_options/errors.hpp>\n    #include <iostream>\n    namespace opt = boost::program_options;\n\n    int main(int argc, char *argv[])\n    {\n        opt::options_description desc(\"All options\");\n        // 'a' and 'o' are short option names for apples and \n        // oranges 'name' option is not marked with \n        // 'required()', so user may not support it\n        desc.add_options()\n            (\"apples,a\", opt::value<int>()->default_value(10), \"apples that you have\")\n            (\"oranges,o\", opt::value<int>(), \"oranges that you have\")\n            (\"name\", opt::value<std::string>(), \"your name\")\n            (\"help\", \"produce help message\")\n        ;\n        opt::variables_map vm;\n     // Parsing command line options and storing values to 'vm'\n\n       opt::store(opt::parse_command_line(argc, argv, desc), vm);\n        // We can also parse environment variables using \n        // 'parse_environment' method\n        opt::notify(vm);\n        if (vm.count(\"help\")) {\n            std::cout << desc << \"\\n\";\n            return 1;\n        }\n        // Adding missing options from \"aples_oranges.cfg\" \n        // config file.\n        // You can also provide an istreamable object as a \n        // first parameter for 'parse_config_file'\n        // 'char' template parameter will be passed to\n        // underlying std::basic_istream object\n        try {\n          opt::store(\n            opt::parse_config_file<char>(\"apples_oranges.cfg\", desc), \n            vm\n          );\n        } catch (const opt::reading_file& e) {\n            std::cout \n               << \"Failed to open file 'apples_oranges.cfg': \"\n               << e.what();\n        }\n        opt::notify(vm);\n        if (vm.count(\"name\")) {\n          std::cout << \"Hi,\" << vm[\"name\"].as<std::string>() << \"!\\n\";\n        }\n\n        std::cout << \"Fruits count: \"\n            << vm[\"apples\"].as<int>() + vm[\"oranges\"].as<int>()\n            << std::endl;\n        return 0;\n    }\n    ```", "```cpp\n$ ./our_program --help \nAll options: \n  -a [ --apples ] arg (=10) how many apples do you have \n  -o [ --oranges ] arg      how many oranges do you have \n  --name arg                your name \n  --help                    produce help message \n\n$ ./our_program \nFruits count: 30\n\n$ ./our_program -a 10 -o 10 --name=\"Reader\" \nHi,Reader! \nFruits count: 20\n```", "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <auto_ptr.h>\n\nint main()\n{\n    typedef std::auto_ptr<Object> object_ptr;\n    std::vector<object_ptr> some_values;\n    some_values.push_back(new Object(10));\n    some_values.push_back(new Object(\"Hello there\"));\n    some_values.push_back(new Object(std::string(\"Wow!\")));\n    std::string* p = \n         dynamic_cast<std::string*>(some_values.back().get());\n    assert(p);\n\n    (*p) += \" That is great!\\n\";\n    std::cout << *p;\n    return 0;\n}\n```", "```cpp\n#include <boost/any.hpp>\n#include <iostream>\n#include <vector>\n#include <string>\n\nint main()\n{\n    std::vector<boost::any> some_values;\n    some_values.push_back(10);\n    const char* c_str = \"Hello there!\";\n    some_values.push_back(c_str);\n    some_values.push_back(std::string(\"Wow!\"));\n    std::string& s = \n       boost::any_cast<std::string&>(some_values.back());\n    s += \" That is great!\\n\";\n    std::cout << s;\n    return 0;\n}\n```", "```cpp\n    boost::any variable(std::string(\"Hello world!\"));\n\n    //#1: Following method may throw a boost::bad_any_cast exception\n    // if actual value in variable is not a std::string\n    std::string s1 = boost::any_cast<std::string>(variable);\n\n    //#2: If actual value in variable is not a std::string\n    // will return an NULL pointer\n    std::string* s2 = boost::any_cast<std::string>(&variable);\n```", "```cpp\n    #include <boost/variant.hpp>\n    #include <iostream>\n    #include <vector>\n    #include <string>\n\n    int main()\n    {\n        typedef boost::variant<int, const char*, std::string> \n          my_var_t;\n        std::vector<my_var_t> some_values;\n        some_values.push_back(10);\n        some_values.push_back(\"Hello there!\");\n        some_values.push_back(std::string(\"Wow!\"));\n        std::string& s = boost::get<std::string>(some_values.back());\n        s += \" That is great!\\n\";\n        std::cout << s;\n        return 0;\n    }\n    ```", "```cpp\n        typedef boost::variant<boost::blank, int, const char*, std::string> my_var_t;\n        // Default constructor will construct an \n        // instance of boost::blank\n        my_var_t var;\n        // 'which()' method returns an index of a type,\n        // currently held by variant.\n        assert(var.which() == 0); // Empty state\n        var = \"Hello, dear reader\";\n        assert(var.which() != 0);\n    ```", "```cpp\n        boost::variant<int, std::string> variable(0);\n        // Following method may throw a boost::bad_get\n        // exception if actual value in variable is not an int\n        int s1 = boost::get<int>(variable);\n        // If actual value in variable is not an int\n        // will return an NULL pointer\n        int* s2 = boost::get<int>(&variable);\n    ```", "```cpp\n#include <boost/any.hpp>\n#include <vector>\n#include <string>\n#include <typeinfo>\n#include <algorithm>\n#include <iostream>\n\n// This typedefs and methods will be in our header,\n// that wraps around native SQL interface\ntypedef boost::any cell_t;\ntypedef std::vector<cell_t> db_row_t;\n\n// This is just an example, no actual work with database.\ndb_row_t get_row(const char* /*query*/) {\n    // In real application 'query' parameter shall have a 'const\n    // char*' or 'const std::string&' type? See recipe Using a \n    // reference to string type in Chapter 7, Manipulating Strings\n    // for an answer.\n    db_row_t row;\n    row.push_back(10);\n    row.push_back(10.1f);\n    row.push_back(std::string(\"hello again\"));\n    return row;\n}\n\n// This is how a user will use your classes\nstruct db_sum: public std::unary_function<boost::any, void> {\nprivate:\n    double& sum_;\npublic:\n    explicit db_sum(double& sum)\n        : sum_(sum)\n    {}\n\n    void operator()(const cell_t& value) {\n        const std::type_info& ti = value.type();\n        if (ti == typeid(int)) {\n            sum_ += boost::any_cast<int>(value);\n        } else if (ti == typeid(float)) {\n            sum_ += boost::any_cast<float>(value);\n        }\n    }\n};\n\nint main()\n{\n    db_row_t row = get_row(\"Query: Give me some row, please.\");\n    double res = 0.0;\n    std::for_each(row.begin(), row.end(), db_sum(res));\n    std::cout << \"Sum of arithmetic types in database row is: \" << res << std::endl;\n    return 0;\n}\n```", "```cpp\nSum of arithmetic types in database row is: 20.1\n```", "```cpp\n#include <boost/variant.hpp>\n#include <vector>\n#include <string>\n#include <iostream>\n\n// This typedefs and methods will be in header,\n// that wraps around native SQL interface.\ntypedef boost::variant<int, float, std::string> cell_t;\ntypedef std::vector<cell_t> db_row_t;\n\n// This is just an example, no actual work with database.\ndb_row_t get_row(const char* /*query*/) {\n    // See the recipe \"Using a reference to string type\" \n    // in Chapter 7, Manipulating Strings\n    // for a better type for 'query' parameter.\n    db_row_t row;\n    row.push_back(10);\n    row.push_back(10.1f);\n    row.push_back(\"hello again\");\n    return row;\n}\n\n// This is how code required to sum values\n// We can provide no template parameter\n// to boost::static_visitor<> if our visitor returns nothing.\nstruct db_sum_visitor: public boost::static_visitor<double> {\n    double operator()(int value) const {\n        return value;\n    }\n    double operator()(float value) const {\n        return value;\n    }\n    double operator()(const std::string& /*value*/) const {\n        return 0.0;\n    }\n};\n\nint main()\n{\n    db_row_t row = get_row(\"Query: Give me some row, please.\");\n    double res = 0.0;\n    db_row_t::const_iterator it = row.begin(), end = row.end();\n    for (; it != end; ++it) {\n         res += boost::apply_visitor(db_sum_visitor(), *it);\n    }\n    std::cout << \"Sum of arithmetic types in database row is: \" << res << std::endl;\n    return 0;\n}\n```", "```cpp\nswitch (which())\n{\ncase 0: return visitor(*reinterpret_cast<int*>(address()));\ncase 1: return visitor(*reinterpret_cast<float*>(address()));\ncase 2: return visitor(*reinterpret_cast<std::string*>(address()));\ndefault: assert(false);\n}\n```", "```cpp\n#include <boost/optional.hpp>\n#include <iostream>\n#include <stdlib.h>\n\nclass locked_device {\n    explicit locked_device(const char* /*param*/) {\n        // We have unique access to device\n        std::cout << \"Device is locked\\n\";\n    }\npublic:\n    ~locked_device () {\n        // Releasing device lock\n    }\n\n    void use() {\n        std::cout << \"Success!\\n\";\n    }\n    static boost::optional<locked_device> try_lock_device() {\n        if (rand()%2) {\n            // Failed to lock device\n            return boost::none;\n        }\n        // Success!\n        return locked_device(\"device name\");\n    }\n};\n\nint main()\n{\n    // Boost has a library called Random. If you wonder why it was \n    // written when stdlib.h has rand() function, see the recipe\n    // \"Using a true random number generator in Chapter 12, \n    // Scratching the Tip of the Iceberg\n    srandom(5);\n    for (unsigned i = 0; i < 10; ++i) {\n        boost::optional<locked_device> t = locked_device::try_lock_device();\n        // optional is convertible to bool\n        if (t) {\n            t->use();\n            return 0;\n        } else {\n            std::cout << \"...trying again\\n\";\n        }\n    }\n    std::cout << \"Failure!\\n\";\n    return -1;\n}\n```", "```cpp\n...trying again \n...trying again \nDevice is locked \nSuccess! \n```", "```cpp\nchar* vector_advance(char* val);\n```", "```cpp\nchar ( &vector_advance( char (&val)[4] ) )[4];\n```", "```cpp\n#include <boost/array.hpp>\ntypedef boost::array<char, 4> array4_t;array4_t& vector_advance(array4_t& val);\n```", "```cpp\n#include <boost/array.hpp>\n#include <algorithm>\n\n// Functional object to increment value by one\nstruct add_1 : public std::unary_function<char, void> {\n    void operator()(char& c) const {\n        ++ c;\n    }\n    // If you're not in a mood to write functional objects,\n    // but don't know what does 'boost::bind(std::plus<char>(),\n    // _1, 1)' do, then read recipe 'Binding a value as a function \n    // parameter'.\n};\n\ntypedef boost::array<char, 4> array4_t;\narray4_t& vector_advance(array4_t& val) {\n    // boost::array has begin(), cbegin(), end(), cend(), \n    // rbegin(), size(), empty() and other functions that are \n    // common for STL containers.\n    std::for_each(val.begin(), val.end(), add_1());\n    return val;\n}\n\nint main() {\n    // We can initialize boost::array just like an array in C++11:\n    // array4_t val = {0, 1, 2, 3};\n    // but in C++03 additional pair of curly brackets is required.\n    array4_t val = {{0, 1, 2, 3}};\n\n    // boost::array works like a usual array:\n    array4_t val_res;       // it can be default constructible and\n    val_res = vector_advance(val);  // assignable\n    // if value type supports default construction and assignment\n\n    assert(val.size() == 4);\n    assert(val[0] == 1);\n    /*val[4];*/ // Will trigger an assert because max index is 3\n    // We can make this assert work at compile-time.\n    // Interested? See recipe 'Checking sizes at compile time' \n    // in Chapter 4, Compile-time Tricks.'\n    assert(sizeof(val) == sizeof(char) * array4_t::static_size);\n    return 0;\n}\n```", "```cpp\n    #include <boost/tuple/tuple.hpp>\n    #include <string>\n\n    boost::tuple<int, std::string> almost_a_pair(10, \"Hello\");\n    boost::tuple<int, float, double, int> quad(10, 1.0f, 10.0, 1);\n    ```", "```cpp\n        int i = boost::get<0>(almost_a_pair);\n        const std::string& str = boost::get<1>(almost_a_pair);\n        double d = boost::get<2>(quad);\n    ```", "```cpp\n        using namespace boost;\n\n        // Tuple comparison operators are\n        // defined in header \"boost/tuple/tuple_comparison.hpp\"\n        // Don't forget to include it!\n        std::set<tuple<int, double, int> > s;\n        s.insert(make_tuple(1, 1.0, 2));\n        s.insert(make_tuple(2, 10.0, 2));\n        s.insert(make_tuple(3, 100.0, 2));\n\n        // Requires C++11\n        auto t = make_tuple(0, -1.0, 2);\n        assert(2 == get<2>(t));\n        // We can make a compile-time assert for type\n        // of t. Interested? See chapter 'compile-time tricks'\n    ```", "```cpp\n        boost::tuple<int, float, double, int> quad(10, 1.0f, 10.0, 1);\n        int i;\n        float f;\n        double d;\n        int i2;\n\n        // Passing values from 'quad' variables\n        // to variables 'i', 'f', 'd', 'i2'\n        boost::tie(i, f, d, i2) = quad;\n        assert(i == 10);\n        assert(i2 == 1);\n    ```", "```cpp\nstruct id_name_pair {\n    int id;\n    std::string name;\n};\n```", "```cpp\n    class Number{};\n    inline Number operator + (Number, Number);\n\n    // Your code starts here\n    struct mul_2_func_obj: public std::unary_function<Number, Number> {\n        Number operator()(Number n1) const {\n            return n1 + n1;\n        }\n    };\n\n    void mul_2_impl1(std::vector<Number>& values) {\n        std::for_each(values.begin(), values.end(), mul_2_func_obj());\n    }\n    ```", "```cpp\n    #include <boost/bind.hpp>\n    #include <functional>\n\n    void mul_2_impl2(std::vector<Number>& values) {\n       std::for_each(values.begin(), values.end(),\n           boost::bind(std::plus<Number>(), _1, _1));\n    }\n    ```", "```cpp\n    template <class T>\n    void mul_2_impl3(std::vector<T>& values) {\n       std::for_each(values.begin(), values.end(),\n           boost::bind(std::plus<T>(), _1, _1));\n    }\n    ```", "```cpp\nclass Device1 {\nprivate:\n    short temperature();\n    short wetness();\n    int illumination();\n    int atmospheric_pressure();\n    void wait_for_data();\npublic:\n    template <class FuncT>\n    void watch(const FuncT& f) {\n        for(;;) {\n            wait_for_data();\n            f(\n                temperature(),\n                wetness(),\n                illumination(),\n                atmospheric_pressure()\n            );\n        }\n    }\n};\n\nclass Device2 {\nprivate:\n    short temperature();\n    short wetness();\n    int illumination();\n    int atmospheric_pressure();\n    void wait_for_data();\npublic:\n    template <class FuncT>\n    void watch(const FuncT& f) {\n        for(;;) {\n            wait_for_data();\n            f(\n                wetness(),\n                temperature(),\n                atmospheric_pressure(),\n                illumination()\n            );\n        }\n    }\n};\n```", "```cpp\nvoid detect_storm(int wetness, int temperature, int atmospheric_pressure);\n```", "```cpp\n    Device1 d1;\n    // resulting functional object will silently ignore \n    // additional parameters passed to function call\n    d1.watch(boost::bind(&detect_storm, _2, _1, _4));\n    ...\n    Device2 d2;\n    d2.watch(boost::bind(&detect_storm, _1, _2, _3));\n```", "```cpp\ntemplate <class FuncT>\nvoid watch(const FuncT& f) {\n    f(10, std::string(\"String\"));\n    f(10, \"Char array\");\n    f(10, 10);\n}\n\nstruct templated_foo {\n    template <class T>\n    void operator()(T, int) const {\n        // No implementation, just showing that bound\n        // functions still can be used as templated\n    }\n};\n\nvoid check_templated_bind() {\n    // We can directly specify return type of a functional object\n    // when bind fails to do so\n    watch(boost::bind<void>(templated_foo(), _2, _1));\n}\n```", "```cpp\n    boost::array<int, 12> values = {{1, 2, 3, 4, 5, 6, 7, 100, 99, 98, 97, 96}};\n\n    std::size_t count0 = std::count_if(values.begin(), values.end(),\n          std::bind1st(std::less<int>(), 5));\n    std::size_t count1 = std::count_if(values.begin(), values.end(),\n          boost::bind(std::less<int>(), 5, _1));\n    assert(count0 == count1);\n    ```", "```cpp\n    boost::array<std::string, 3>  str_values = {{\"We \", \"are\", \" the champions!\"}};\n    count0 = std::count_if(str_values.begin(), str_values.end(),\n          std::mem_fun_ref(&std::string::empty));\n    count1 = std::count_if(str_values.begin(), str_values.end(),\n          boost::bind(&std::string::empty, _1));\n    assert(count0 == count1);\n    ```", "```cpp\n    // That code won't compile! And it is hard to understand\n    //count0 = std::count_if(str_values.begin(), \n    //str_values.end(),\n    //std::bind2nd(\n    //    std::bind1st(\n    //        std::less<std::size_t>(),\n    //        std::mem_fun_ref(&std::string::size)\n    //    )\n    //, 5\n    //));\n    // This will become much more readable,\n    // when you get used to bind\n    count1 = std::count_if(str_values.begin(), str_values.end(),\n        boost::bind(std::less<std::size_t>(), \n        boost::bind(&std::string::size, _1), 5));\n    assert(2 == count1);\n    ```", "```cpp\n    std::string s(\"Expensive copy constructor of std::string will be called when binding\");\n    count0 = std::count_if(str_values.begin(), str_values.end(), std::bind2nd(std::less<std::string>(), s));\n    count1 = std::count_if(str_values.begin(), str_values.end(), boost::bind(std::less<std::string>(), _1, s));\n    assert(count0 == count1);\n    ```", "```cpp\n#include <boost/ref.hpp>\n...\nstd::string s(\"Expensive copy constructor of std::string now \"\n             \"won't be called when binding\");\ncount0 = std::count_if(str_values.begin(), str_values.end(), std::bind2nd(std::less<std::string>(), boost::cref(s)));\ncount1 = std::count_if(str_values.begin(), str_values.end(), boost::bind(std::less<std::string>(), _1, boost::cref(s)));\nassert(count0 == count1);\n```", "```cpp\nvoid wierd_appender(std::string& to, const std::string& from) {\n    to += from;\n};\n\nstd::string result;\nstd::for_each(str_values.cbegin(), str_values.cend(), boost::bind(&wierd_appender, boost::ref(result), _1));\nassert(result == \"We are the champions!\");\n```", "```cpp\n    namespace other {\n        // Its default construction is cheap/fast\n        class characteristics{};\n    } // namespace other\n\n    struct person_info {\n        // Fields declared here\n        // ...\n        bool is_male_;\n        std::string name_;\n        std::string second_name_;\n        other::characteristics characteristic_;\n    };\n    ```", "```cpp\n    #include <boost/swap.hpp>\n\n        void swap(person_info& rhs) {\n            std::swap(is_male_, rhs.is_male_);\n            name_.swap(rhs.name_);\n            second_name_.swap(rhs.second_name_);\n            boost::swap(characteristic_, rhs.characteristic_);\n        }\n    ```", "```cpp\n    BOOST_COPYABLE_AND_MOVABLE(classname)\n    ```", "```cpp\n    struct person_info {\n        // Fields declared here\n        // ...\n    private:\n        BOOST_COPYABLE_AND_MOVABLE(person_info)\n    public:\n        // For the simplicity of example we will assume that \n        // person_info default constructor and swap are very \n        // fast/cheap to call\n        person_info() {}\n\n        person_info(const person_info& p)\n            : is_male_(p.is_male_)\n            , name_(p.name_)\n            , second_name_(p.second_name_)\n            , characteristic_(p.characteristic_)\n        {}\n\n        person_info(BOOST_RV_REF(person_info) person) {\n            swap(person);\n        }\n\n        person_info& operator=(BOOST_COPY_ASSIGN_REF(person_info) person) {\n            if (this != &person) {\n                 person_info tmp(person);\n                 swap(tmp);\n             }\n            return *this;\n        }\n\n        person_info& operator=(BOOST_RV_REF(person_info) person) {\n            if (this != &person) {\n                 swap(person);\n                 person_info tmp;\n                 tmp.swap(person);\n             }\n            return *this;\n        }\n\n        void swap(person_info& rhs) {\n        // …\n        }\n\n    };\n    ```", "```cpp\n    person_info vasya;\n    vasya.name_ = \"Vasya\";\n    vasya.second_name_ = \"Snow\";\n    vasya.is_male_ = true;\n\n    person_info new_vasya(boost::move(vasya));\n    assert(new_vasya.name_ == \"Vasya\");\n    assert(new_vasya.second_name_ == \"Snow\");\n    assert(vasya.name_.empty());\n    assert(vasya.second_name_.empty());\n\n    vasya = boost::move(new_vasya);\n    assert(vasya.name_ == \"Vasya\");\n    assert(vasya.second_name_ == \"Snow\");\n    assert(new_vasya.name_.empty());\n    assert(new_vasya.second_name_.empty());\n```", "```cpp\nclass descriptor_owner {\n    void* descriptor_;\n\npublic:\n    explicit descriptor_owner(const char* params);\n\n    ~descriptor_owner() {\n        system_api_free_descriptor(descriptor_);\n    }\n};\n```", "```cpp\n    descriptor_owner d1(\"O_o\");  \n    descriptor_owner d2(\"^_^\");\n\n    // Descriptor of d2 was not correctly freed\n    d2 = d1;\n\n    // destructor of d2 will free the descriptor\n    // destructor of d1 will try to free already freed descriptor\n```", "```cpp\n#include <boost/noncopyable.hpp>\n\nclass descriptor_owner_fixed : private boost::noncopyable {\n    …\n```", "```cpp\n    descriptor_owner_fixed d1(\"O_o\");\n    descriptor_owner_fixed d2(\"^_^\");\n    // Won't compile\n    d2 = d1;\n    // Won't compile either\n    descriptor_owner_fixed d3(d1);\n```", "```cpp\ndescriptor_owner construct_descriptor() {\n    return descriptor_owner(\"Construct using this string\");\n}\n```", "```cpp\nvoid construct_descriptor1(descriptor_owner& ret) {\n    descriptor_owner(\"Construct using this string\").swap(ret);\n}\n```", "```cpp\nclass descriptor_owner1 {\n    void* descriptor_;\n\npublic:\n    descriptor_owner1()\n        : descriptor_(NULL)\n    {}\n\n    explicit descriptor_owner1(const char* param)\n        : descriptor_(strdup(param))\n    {}\n\n    descriptor_owner1(descriptor_owner1&& param)\n        : descriptor_(param.descriptor_)\n    {\n        param.descriptor_ = NULL;\n    }\n\n    descriptor_owner1& operator=(descriptor_owner1&& param) {\n        clear();\n        std::swap(descriptor_, param.descriptor_);\n        return *this;\n    }\n\n    void clear() {\n        free(descriptor_);\n        descriptor_ = NULL;\n    }\n\n    bool empty() const {\n        return !descriptor_;\n    }\n\n    ~descriptor_owner1() {\n        clear();\n    }\n};\n\n// GCC compiles the following in with -std=c++0x\ndescriptor_owner1 construct_descriptor2() {\n    return descriptor_owner1(\"Construct using this string\");\n}\n\nvoid foo_rv() {\n    std::cout << \"C++11\\n\";\n    descriptor_owner1 desc;\n    desc = construct_descriptor2();\n    assert(!desc.empty());\n}\n```", "```cpp\n    class descriptor_owner_movable {\n        void* descriptor_;\n        BOOST_MOVABLE_BUT_NOT_COPYABLE(descriptor_owner_movable)\n    ```", "```cpp\n    #include <boost/move/move.hpp>\n\n    public:\n        descriptor_owner_movable()\n            : descriptor_(NULL)\n        {}\n\n        explicit descriptor_owner_movable(const char* param)\n            : descriptor_(strdup(param))\n        {}\n\n        descriptor_owner_movable(\n          BOOST_RV_REF(descriptor_owner_movable) param)\n           : descriptor_(param.descriptor_)\n        { \n        param.descriptor_ = NULL;\n        }\n\n        descriptor_owner_movable& operator=(\n          BOOST_RV_REF(descriptor_owner_movable) param)\n        {\n          clear();\n          std::swap(descriptor_, param.descriptor_);\n          return *this;\n        }\n        // ...\n    };\n\n    descriptor_owner_movable construct_descriptor3() {\n        return descriptor_owner_movable(\"Construct using this string\");\n    }\n    ```", "```cpp\n#include <boost/container/vector.hpp>\n...\n    // Following code will work on C++11 and C++03 compilers\n    descriptor_owner_movable movable;\n    movable = construct_descriptor3();\n    boost::container::vector<descriptor_owner_movable> vec;\n    vec.resize(10);\n    vec.push_back(construct_descriptor3());\n\n    vec.back() = boost::move(vec.front());\n```", "```cpp\n// your_project/vector.hpp\n// Copyright and other stuff goes here\n\n// include guards\n#ifndef YOUR_PROJECT_VECTOR_HPP\n#define YOUR_PROJECT_VECTOR_HPP\n\n#include <boost/config.hpp>\n\n// Those macro declared in boost/config.hpp header\n// This is portable and can be used with any version of boost \n// libraries\n#if !defined(BOOST_NO_RVALUE_REFERENCES) && !defined(BOOST_NO_CXX11_RVALUE_REFERENCES)\n// We do have rvalues\n#include <vector>\n\nnamespace your_project_namespace {\n  using std::vector;\n} // your_project_namespace\n\n#else\n// We do NOT have rvalues\n#include <boost/container/vector.hpp>\n\nnamespace your_project_namespace {\n  using boost::container::vector;\n} // your_project_namespace\n\n#endif // !defined(BOOST_NO_RVALUE_REFERENCES) && !defined(BOOST_NO_CXX11_RVALUE_REFERENCES)\n#endif // YOUR_PROJECT_VECTOR_HPP\n```", "```cpp\n    your_project_namespace::vector<descriptor_owner_movable> v;\n    v.resize(10);\n    v.push_back(construct_descriptor3());\n    v.back() = boost::move(v.front());\n```"]