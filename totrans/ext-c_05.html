<html><head></head><body>
		<div id="_idContainer064">
			<h1 class="chapterNumber">Chapter 05</h1>
			<h1 id="_idParaDest-82" class="chapterTitle" lang="en-GB" xml:lang="en-GB">Stack and Heap<a id="_idTextAnchor149"/></h1>
			<p class="normal">In the previous chapter, we ran an investigation of the memory layout of a running process. System programming without knowing enough about the memory structure and its various segments is like doing surgery without knowing the anatomy of the human body. The previous chapter just gave us the basic information regarding the different segments in the process memory layout, but this chapter wants us to just focus on the most frequently used segments: Stack and Heap.</p>
			<p class="normal">As a programmer, you are mostly busy working with Stack and Heap segments. Other segments such as Data or BSS are less in use, or you have less control over them. That's basically because of the fact that the Data and BSS segments are generated by the compiler, and usually, they take up a small percentage of the whole memory of a process during its lifetime. This doesn't mean that they are not important, and, in fact, there are issues that directly relate to these segments. But as you are spending most of your time with Stack and Heap, most memory issues have roots in these segments.</p>
			<p class="normal">As part of this chapter, you will learn:</p>
			<ul>
				<li class="list">How to probe the Stack segment and the tools you need for this purpose</li>
				<li class="list">How memory management is done automatically for the Stack segment</li>
				<li class="list">The various characteristics of the stack segment</li>
				<li class="list">The guidelines and best practices on how to use the Stack segment</li>
				<li class="list">How to probe the Heap segment</li>
				<li class="list">How to allocate and deallocate a Heap memory block</li>
				<li class="list">The guidelines and best practices regarding the usage of the Heap segment</li>
				<li class="list">Memory-constrained environments and tuning memory in performant environments</li>
			</ul>
			<p class="normal">Let's begin our quest by discussing the Stack segment in more detail.</p>
			<h1 id="_idParaDest-83" class="title" lang="en-GB" xml:lang="en-GB">Stack<a id="_idTextAnchor150"/></h1>
			<p class="normal">A process can continue <a id="_idIndexMarker370"/>working without the Heap segment but not without the Stack segment. This says a lot. The Stack is the main part of the process metabolism, and it cannot continue execution without it. The reason is hiding behind the mechanism driving the function calls. As briefly explained in the previous chapter, calling a function can only be done by using the Stack segment. Without a Stack segment, no function call can be made, and this means no execution at all.</p>
			<p class="normal">With that said, the Stack segment and its contents are engineered carefully to result in the healthy execution of the process. Therefore, messing with the Stack content can disrupt the execution and halt the process. Allocation from the Stack segment is fast, and it doesn't need any special function call. More than that, the deallocation and all memory management tasks happen automatically. All these facts are all very tempting and encourage you to overuse the Stack.</p>
			<p class="normal">You should be careful about this. Using the Stack segment brings its own complications. The stack is not very big, therefore you cannot store large objects in it. In addition, incorrect use of the Stack content can halt the execution and result in a crash. The following piece of code demonstrates this:</p>
			<p class="snippet code">#include &lt;string.h&gt;</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  char str[10];</p>
			<p class="snippet code">  strcpy(str, "akjsdhkhqiueryo34928739r27yeiwuyfiusdciuti7twe79ye");</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 5-1: A buffer overflow situation. The strcpy function will overwrite the content of the Stack</p>
			<p class="normal">When running the preceding code, the program will most likely crash. That's because the <code class="Code-In-Text--PACKT-">strcpy</code> is overwriting the content of the Stack, or as it is commonly termed, <em class="italics">smashing</em> the<a id="_idIndexMarker371"/> stack. As you see in <em class="italics">Code Box 5-1</em>, the <code class="Code-In-Text--PACKT-">str</code> array has <code class="Code-In-Text--PACKT-">10</code> characters, but the <code class="Code-In-Text--PACKT-">strcpy</code> is writing way more than 10 characters to the <code class="Code-In-Text--PACKT-">str</code> array. As you will see shortly, this effectively writes on the previously pushed variables and stack frames, and the program jumps to a wrong instruction after returning from the <code class="Code-In-Text--PACKT-">main</code> function. And this eventually makes it impossible to continue the execution.</p>
			<p class="normal">I hope that the preceding example has helped you to appreciate the delicacy of the Stack segment. In the first half of this chapter, we are going to have a deeper look into the Stack and examine it closely. We first start by probing into the Stack.</p>
			<h2 id="_idParaDest-84" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor151"/>Probing the Stack</h2>
			<p class="normal">Before knowing more<a id="_idIndexMarker372"/> about the Stack, we need to be able to read and, probably, modify it. As stated in the previous chapter, the Stack segment is a private memory that only the owner process has the right to read and modify. If we are going to read the Stack or change it, we need to become part of the process owning the Stack.</p>
			<p class="normal">This is where a new set of tools come in: <em class="italics">debuggers</em>. A <a id="_idIndexMarker373"/>debugger is a program that attaches to another process in order to <em class="italics">debug</em> it. One of the usual tasks while debugging a process is to observe and manipulate the various memory segments. Only when debugging a process are we able to read and modify the private memory blocks. The other thing that can be done as part of debugging is to control the order of the execution of the program instructions. We give examples on how to do these tasks using a debugger shortly, as part of this section.</p>
			<p class="normal">Let's start with an example. In <em class="italics">example 5.1</em>, we show how to compile a program and make it ready for debugging. Then, we demonstrate how to use <code class="Code-In-Text--PACKT-">gdb</code>, the GNU debugger, to run the program and read the Stack memory. This example declares a character array allocated on top of the Stack and populates its elements with some characters, as can be seen in the following code box:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  char arr[4];</p>
			<p class="snippet code">  arr[0] = 'A';</p>
			<p class="snippet code">  arr[1] = 'B';</p>
			<p class="snippet code">  arr[2] = 'C';</p>
			<p class="snippet code">  arr[3] = 'D';</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 5-2 [ExtremeC_examples_chapter5_1.c]: Declaration of an array allocated on top of the Stack</p>
			<p class="normal">The program is simple and easy to follow, but the things that are happening inside the memory are interesting. First of all, the memory required for the <code class="Code-In-Text--PACKT-">arr</code> array is allocated from the Stack simply because it is not allocated from the Heap segment and we didn't use the <code class="Code-In-Text--PACKT-">malloc</code> function. Remember, the Stack segment is the default place for allocating variables and arrays.</p>
			<p class="normal">In order to have some memory allocated from the Heap, one should acquire it by calling <code class="Code-In-Text--PACKT-">malloc</code> or other similar functions, such as <code class="Code-In-Text--PACKT-">calloc</code>. Otherwise, the memory is allocated from the Stack, and more precisely, on top of the Stack.</p>
			<p class="normal">In order to be able to debug a program, the binary must be built for debugging purposes. This means that we have to tell the compiler that we want a binary that contains <em class="italics">debug </em><em class="italics"><a id="_idIndexMarker374"/></em><em class="italics">symbols</em>. These symbols will be used to find the code lines that have been executing or those that caused a crash. Let's compile <em class="italics">example 5.1</em> and create an executable object file that contains debugging symbols.</p>
			<p class="normal">First, we build the example. We're doing our compilation in a Linux environment:</p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -g ExtremeC_examples_chapter5_1.c -o ex5_1_dbg.out</strong></p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 5-1: Compiling the example 5.1 with debug option -g</p>
			<p class="normal">The <code class="Code-In-Text--PACKT-">-g</code> option tells the compiler that the final executable object file must contain the debugging information. The size of the binary is also different when you compile the source with and without the debug option. Next, you can see the difference between the sizes of the two executable object files, the first one built without the <code class="Code-In-Text--PACKT-">-g</code> option and the second one with the <code class="Code-In-Text--PACKT-">-g</code> option:</p>
			<p class="snippet shell"><strong class="screen-text">$ gc</strong><strong class="screen-text">c ExtremeC_examples_chapter2_10.c -o ex5_1.out</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ ls -al ex5_1.out</strong></p>
			<p class="snippet shell">-rwxrwxr-x 1 kamranamini kamranamini 8640 jul 24 13:55 ex5_1.out</p>
			<p class="snippet shell"><strong class="screen-text">$ gcc -g ExtremeC_examples_chapter2_10.c -o ex5_1_dbg.out</strong></p>
			<p class="snippet shell"><strong class="screen-text">$ ls -al ex5_1.out</strong></p>
			<p class="snippet shell">-rwxrwxr-x 1 kamranamini kamranamini 9864 jul 24 13:56 ex5_1_dbg.out</p>
			<p class="snippet shell"><strong class="screen-text">$</strong></p>
			<p class="packt_figref">Shell Box 5-2: The size of the output executable object file with and without the -g option</p>
			<p class="normal">Now that we have an executable file containing the debug symbols, we can use the debugger to run the program. In this example, we are going to use <code class="Code-In-Text--PACKT-">gdb</code> for debugging <em class="italics">example 5.1</em>. Next, you can find the command to start the debugger:</p>
			<p class="snippet shell"><strong class="screen-text">$ gdb ex5_1_dbg.out</strong></p>
			<p class="packt_figref">Shell Box 5-3: Starting the debugger for the example 5.1</p>
			<div>
				<div id="_idContainer057" class="note">
					<p class="Information-Box--PACKT-"><strong class="bold">Note</strong>: </p>
					<p class="Information-Box--PACKT-"><code class="Code-In-Text--PACKT-">gdb</code> is usually installed as part of the <code class="Code-In-Text--PACKT-">build-essentials</code> package on Linux systems. In macOS systems, it can be installed using the <code class="Code-In-Text--PACKT-">brew</code> package manager like this: <code class="Code-In-Text--PACKT-">brew install gdb</code>.</p>
				</div>
			</div>
			<p class="normal">After running the debugger, the output will be something similar to the following shell box:</p>
			<p class="snippet shell"><strong class="screen-text">$ g</strong><strong class="screen-text">db ex5_1_dbg.out</strong></p>
			<p class="snippet shell">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</p>
			<p class="snippet shell">Copyright (C) 2016 Free Software Foundation, Inc.</p>
			<p class="snippet shell">License GPLv3+: GNU GPL version 3 or later http://gnu.org/licenses/gpl.html</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell">Reading symbols from ex5_1_dbg.out...done.</p>
			<p class="snippet shell"><strong class="screen-text">(gdb)</strong></p>
			<p class="packt_figref">Shell Box 5-4: The output of the debugger after getting started</p>
			<p class="normal">As you may have <a id="_idIndexMarker375"/>noticed, I've run the preceding command on a Linux machine. <code class="Code-In-Text--PACKT-">gdb</code> has a command-line interface that allows you to issue debugging commands. Enter the <code class="Code-In-Text--PACKT-">r</code> (or <code class="Code-In-Text--PACKT-">run</code>) command in order to execute the executable object file, specified as an input to the debugger. The following shell box shows how the <code class="Code-In-Text--PACKT-">run</code> command executes the program:</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell">Reading symbols from ex5_1_dbg.out...done.</p>
			<p class="snippet shell"><strong class="highlight">(gdb) run</strong></p>
			<p class="snippet shell">Starting program: .../extreme_c/5.1/ex5_1_dbg.out</p>
			<p class="snippet shell">[Inferior 1 (process 9742) exited normally]</p>
			<p class="snippet shell"><strong class="highlight">(gdb)</strong></p>
			<p class="packt_figref">Shell Box 5-5: The output of the debugger after issuing the run command</p>
			<p class="normal">In the preceding shell box, after issuing the <code class="Code-In-Text--PACKT-">run</code> command, <code class="Code-In-Text--PACKT-">gdb</code> has started the process, attached to it, and let the program execute its instructions and exit. It did not interrupt the program because we have<a id="_idIndexMarker376"/> not set a <em class="italics">breakpoint</em>. A breakpoint is an indicator that tells <code class="Code-In-Text--PACKT-">gdb</code> to pause the program execution and wait for further instructions. You can have as many breakpoints as you want.</p>
			<p class="normal">Next, we set a breakpoint on the <code class="Code-In-Text--PACKT-">main</code> function using the <code class="Code-In-Text--PACKT-">b</code> (or <code class="Code-In-Text--PACKT-">break</code>) command. After setting the breakpoint, <code class="Code-In-Text--PACKT-">gdb</code> pauses the execution when the program enters the <code class="Code-In-Text--PACKT-">main</code> function. You can see how to set a breakpoint on the <code class="Code-In-Text--PACKT-">main</code> function in the following shell box:</p>
			<p class="snippet shell"><strong class="highlight">(</strong><strong class="highlight">gdb) break main</strong></p>
			<p class="snippet shell">Breakpoint 1 at 0x400555: file ExtremeC_examples_chapter5_1.c, line 4.</p>
			<p class="snippet shell"><strong class="highlight">(gdb)</strong></p>
			<p class="packt_figref">Shell Box 5-6: Setting a breakpoint on the main function in gdb</p>
			<p class="normal">Now, we run the<a id="_idIndexMarker377"/> program again. This creates a new process, and <code class="Code-In-Text--PACKT-">gdb</code> attaches to it. Next, you can find the result:</p>
			<p class="snippet shell"><strong class="highlight">(gdb</strong><strong class="highlight">) r</strong></p>
			<p class="snippet shell">Starting program: .../extreme_c/5.1/ex5_1_dbg.out</p>
			<p class="snippet shell">Breakpoint 1, main (argc=1, argv=0x7fffffffcbd8) at ExtremeC_examples_chapter5_1.c:3</p>
			<p class="snippet shell">3       int main(int argc, char** argv) {</p>
			<p class="snippet shell"><strong class="highlight">(gdb)</strong></p>
			<p class="packt_figref">Shell Box 5-7: Running the program again after setting the breakpoint</p>
			<p class="normal">As you can see, the execution has paused at line 3, which is just the line of the <code class="Code-In-Text--PACKT-">main</code> function. Then, the debugger waits for the next command. Now, we can ask <code class="Code-In-Text--PACKT-">gdb</code> to run the next line of code and pause again. In other words, we run the program step by step and line by line. This way, you have enough time to look around and check the variables and their values inside the memory. In fact, this is the method we are going to use to probe the Stack and the Heap segments.</p>
			<p class="normal">In the following shell box, you can see how to use the <code class="Code-In-Text--PACKT-">n</code> (or <code class="Code-In-Text--PACKT-">next</code>) command to run the next line of code:</p>
			<p class="snippet shell"><strong class="highlight">(gdb</strong><strong class="highlight">) n</strong></p>
			<p class="snippet shell">5         arr[0] = 'A';</p>
			<p class="snippet shell"><strong class="highlight">(gdb) n</strong></p>
			<p class="snippet shell">6         arr[1] = 'B';</p>
			<p class="snippet shell"><strong class="highlight">(gdb) next</strong></p>
			<p class="snippet shell">7        arr[2] = 'C';</p>
			<p class="snippet shell"><strong class="highlight">(gdb) next</strong></p>
			<p class="snippet shell">8        arr[3] = 'D';</p>
			<p class="snippet shell"><strong class="highlight">(gdb) next</strong></p>
			<p class="snippet shell">9        return 0;</p>
			<p class="snippet shell"><strong class="highlight">(gdb)</strong></p>
			<p class="packt_figref">Shell Box 5-8: Using the n (or next) command to execute upcoming lines of code</p>
			<p class="normal">Now, if you enter the <code class="Code-In-Text--PACKT-">print arr</code> command in the debugger, it will show the content of the array as a string:</p>
			<p class="snippet shell"><strong class="highlight">(gdb) print arr</strong></p>
			<p class="snippet shell">$1 = "ABCD"</p>
			<p class="snippet shell"><strong class="highlight">(gdb)</strong></p>
			<p class="packt_figref">Shell Box 5-9: Printing the content of the arr array using gdb</p>
			<p class="normal">To get back to the<a id="_idIndexMarker378"/> topic, we introduced <code class="Code-In-Text--PACKT-">gdb</code> to be able to see inside the Stack memory. Now, we can do it. We have a process that has a Stack segment, and it is paused, and we have a <code class="Code-In-Text--PACKT-">gdb</code> command line to explore its memory. Let's begin and print the memory allocated for the <code class="Code-In-Text--PACKT-">arr</code> array:</p>
			<p class="snippet shell"><strong class="highlight">(gdb) x/4b arr</strong></p>
			<p class="snippet shell">0x7fffffffcae0: 0x41    0x42    0x43    0x44</p>
			<p class="snippet shell"><strong class="highlight">(gdb) x/8b arr</strong></p>
			<p class="snippet shell">0x7fffffffcae0: 0x41    0x42    0x43    0x44    0xff    0x7f    0x00    0x00</p>
			<p class="snippet shell"><strong class="highlight">(gdb)</strong></p>
			<p class="packt_figref">Shell Box 5-10: Printing bytes of memory starting from the arr array</p>
			<p class="normal">The first command, <code class="Code-In-Text--PACKT-">x/4b</code>, shows 4 bytes from the location that <code class="Code-In-Text--PACKT-">arr</code> is pointing to. Remember that <code class="Code-In-Text--PACKT-">arr</code> is a pointer that actually is pointing to the first element of the array, so it can be used to move along the memory.</p>
			<p class="normal">The second command, <code class="Code-In-Text--PACKT-">x/8b</code>, prints 8 bytes after <code class="Code-In-Text--PACKT-">arr</code>. According to the code written for <em class="italics">example 5.1</em>, and found in <em class="italics">Code Box 5-2</em>, the values <code class="Code-In-Text--PACKT-">A</code>, <code class="Code-In-Text--PACKT-">B</code>, <code class="Code-In-Text--PACKT-">C</code>, and <code class="Code-In-Text--PACKT-">D</code> are stored in the array, <code class="Code-In-Text--PACKT-">arr</code>. You should know that ASCII values are stored in the array, not the real characters. The ASCII value for <code class="Code-In-Text--PACKT-">A</code> is <code class="Code-In-Text--PACKT-">65</code> decimal or <code class="Code-In-Text--PACKT-">0x41</code> hexadecimal. For <code class="Code-In-Text--PACKT-">B</code>, it is <code class="Code-In-Text--PACKT-">66</code> or <code class="Code-In-Text--PACKT-">0x42</code>. As you can see, the values printed in the <code class="Code-In-Text--PACKT-">gdb</code> output are the values we just stored in the <code class="Code-In-Text--PACKT-">arr</code> array.</p>
			<p class="normal">What about the other 4 bytes in the second command? They are part of the Stack, and they probably contain data from the recent Stack frame put on top of the Stack while calling the <code class="Code-In-Text--PACKT-">main</code> function. </p>
			<p class="normal">Note that the Stack segment is filled in an opposite fashion in comparison to other segments.</p>
			<p class="normal">Other memory regions are filled starting from the smaller addresses and they move forward to bigger addresses, but this is not the case with the Stack segment. </p>
			<p class="normal">The Stack segment is filled from the bigger addresses and moves backward to the smaller addresses. Some of the reasons behind this design lie in the development history of modern computers, and some in the functionality of the Stack segment, which behaves like a stack data structure.</p>
			<p class="normal">With all that said, if you read the Stack segment from an addresses toward the bigger addresses, just like we did in <em class="italics">Shell Box 5-10</em>, you are effectively reading the already pushed <a id="_idIndexMarker379"/>content as part of the Stack segment, and if you try to change those bytes, you are altering the Stack, and this is not good. We will demonstrate why this is dangerous and how this can be done in future paragraphs.</p>
			<p class="normal">Why are we able to see more than the size of the <code class="Code-In-Text--PACKT-">arr</code> array? Because <code class="Code-In-Text--PACKT-">gdb</code> goes through the number of bytes in the memory that we have requested. The <code class="Code-In-Text--PACKT-">x</code> command doesn't care about the array's boundary. It just needs a starting address and the number of bytes to print the range.</p>
			<p class="normal">If you want to change the values inside the Stack, you have to use the <code class="Code-In-Text--PACKT-">set</code> command. This allows you to modify an existing memory cell. In this case, the memory cell refers to an individual byte in the <code class="Code-In-Text--PACKT-">arr</code> array:</p>
			<p class="snippet shell"><strong class="highlight">(gdb) x/4b arr</strong></p>
			<p class="snippet shell">0x7fffffffcae0: 0x41    0x42    0x43    0x44</p>
			<p class="snippet shell"><strong class="highlight">(gdb) set arr[1] = 'F'</strong></p>
			<p class="snippet shell"><strong class="highlight">(gdb) x/4b arr</strong></p>
			<p class="snippet shell">0x7fffffffcae0: 0x41    0x46    0x43    0x44</p>
			<p class="snippet shell"><strong class="highlight">(gdb) print arr</strong></p>
			<p class="snippet shell">$2 = "AFCD"</p>
			<p class="snippet shell"><strong class="highlight">(gdb)</strong></p>
			<p class="packt_figref">Shell Box 5-11: Changing an individual byte in the array using the set command</p>
			<p class="normal">As you can see, using the <code class="Code-In-Text--PACKT-">set</code> command, we have set the second element of the <code class="Code-In-Text--PACKT-">arr</code> array to <code class="Code-In-Text--PACKT-">F</code>. If you are going to change an address that is not in the boundaries of your arrays, it is still possible through <code class="Code-In-Text--PACKT-">gdb</code>. </p>
			<p class="normal">Please observe the following modification carefully. Now, we want to modify a byte located in a far bigger address than <code class="Code-In-Text--PACKT-">arr</code>, and as we explained before, we will be altering the already pushed content of the Stack. Remember, the Stack memory is filled in an opposite manner compared to other segments:</p>
			<p class="snippet shell"><strong class="highlight">(gdb) x/20x arr</strong></p>
			<p class="snippet shell">0x7fffffffcae0: 0x41    0x42    0x43    0x44    0xff    0x7f    0x00    0x00</p>
			<p class="snippet shell">0x7fffffffcae8: 0x00    0x96    0xea    0x5d    0xf0    <strong class="highlight">0x31</strong>    0xea    0x73</p>
			<p class="snippet shell">0x7fffffffcaf0: 0x90    0x05    0x40    0x00</p>
			<p class="snippet shell"><strong class="highlight">(gdb) set *(0x7fffffffcaed) = 0xff</strong></p>
			<p class="snippet shell"><strong class="highlight">(gdb) x/20x arr</strong></p>
			<p class="snippet shell">0x7fffffffcae0: 0x41    0x42    0x43    0x44    0xff    0x7f    0x00    0x00</p>
			<p class="snippet shell">0x7fffffffcae8: 0x00    0x96    0xea    0x5d    0xf0    <strong class="highlight">0xff</strong>    0x00    0x00</p>
			<p class="snippet shell">0x7fffffffcaf0: 0x00    0x05    0x40    0x00</p>
			<p class="snippet shell"><strong class="highlight">(gdb)</strong></p>
			<p class="packt_figref">Shell Box 5-12: Changing an individual byte outside of the array's boundary</p>
			<p class="normal">That is all. We just wrote the value <code class="Code-In-Text--PACKT-">0xff</code> in the <code class="Code-In-Text--PACKT-">0x7fffffffcaed</code> address, which is out of the boundary<a id="_idIndexMarker380"/> of the <code class="Code-In-Text--PACKT-">arr</code> array, and probably a byte within the stack frame pushed before entering the <code class="Code-In-Text--PACKT-">main</code> function.</p>
			<p class="normal">What will happen if we continue the execution? If we have modified a critical byte in the Stack, we expect to see a crash or at least have this modification detected by some mechanism and have the execution of the program halted. The command <code class="Code-In-Text--PACKT-">c</code> (or <code class="Code-In-Text--PACKT-">continue</code>) will continue the execution of the process in <code class="Code-In-Text--PACKT-">gdb</code>, as you can see next:</p>
			<p class="snippet shell"><strong class="highlight">(gdb) c</strong></p>
			<p class="snippet shell">Continuing.</p>
			<p class="snippet shell">*** stack smashing detected ***: .../extreme_c/5.1/ex5_1_dbg.out terminated</p>
			<p class="snippet shell">Program received signal SIGABRT, Aborted.</p>
			<p class="snippet shell">0x00007ffff7a42428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/Unix/sysv/linux/raise.c:54</p>
			<p class="snippet shell">54      ../sysdeps/Unix/sysv/linux/raise.c: No such file or directory.</p>
			<p class="snippet shell"><strong class="highlight">(gdb)</strong></p>
			<p class="packt_figref">Shell Box 5-13: Having a critical byte changed in the Stack terminates the process</p>
			<p class="normal">As you can see in the preceding shell box, we've just smashed the Stack! Modifying the content of the Stack in addresses that are not allocated by you, even by 1 byte, can be very dangerous and it usually leads to a crash or a sudden termination.</p>
			<p class="normal">As we have said before, most of the vital procedures regarding the execution of a program are done within the Stack memory. So, you should be very careful when writing to Stack variables. You should not write any values outside of the boundaries defined for variables and arrays simply because the addresses grow backward in the Stack memory, which makes it likely to overwrite the already written bytes.</p>
			<p class="normal">When you're done with debugging, and you're ready to leave the <code class="Code-In-Text--PACKT-">gdb</code>, then you can simply use the command <code class="Code-In-Text--PACKT-">q</code> (or <code class="Code-In-Text--PACKT-">quit</code>). Now, you should be out of the debugger and back in the terminal.</p>
			<p class="normal">As another note, writing unchecked values into a <em class="italics">buffer</em> (another name for a byte or character array) allocated on top of the Stack (not from the Heap) is considered a vulnerability. An<a id="_idIndexMarker381"/> attacker can carefully design a byte array and feed it to the program in order to take control of it. This is usually called an <em class="italics">exploit</em> because<a id="_idIndexMarker382"/> of a <em class="italics">buffer overflow</em> attack.</p>
			<p class="normal">The following program shows this vulnerability:</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  char str[10];</p>
			<p class="snippet code">  strcpy(str, argv[1]);</p>
			<p class="snippet code">  printf("Hello %s!\n", str);</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 5-3: A program showing the buffer overflow vulnerability</p>
			<p class="normal">The preceding code does not check the <code class="Code-In-Text--PACKT-">argv[1]</code> input for its content and its size and copies it directly into the <code class="Code-In-Text--PACKT-">str</code> array, which is allocated on top of the Stack.</p>
			<p class="normal">If you're lucky, this can lead to a crash, but in some rare but dangerous cases, this can lead to an exploit attack.</p>
			<h2 id="_idParaDest-85" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor152"/>Points on using the Stack memory </h2>
			<p class="normal">Now that you have a better<a id="_idIndexMarker383"/> understanding of the Stack segment and how it works, we can talk about the best practices and the points you should be careful about. You should be familiar<a id="_idIndexMarker384"/> with the <em class="italics">scope</em> concept. Each Stack variable has its own scope, and the scope determines the lifetime of the variable. This means that a Stack variable starts its lifetime in one scope and dies when that scope is gone. In other words, the scope determines the lifetime of a Stack variable.</p>
			<p class="normal">We also have automatic memory allocation and deallocation for Stack variables, and it is only applicable to the Stack variables. This feature, automatic memory management, comes from the nature of the Stack segment.</p>
			<p class="normal">Whenever you declare a Stack variable, it will be allocated on top of the Stack segment. Allocation happens automatically, and this can be marked as the start of its lifetime. After this point, many more variables and other stack frames are put on top of it inside the Stack. As long as the variable exists in the Stack and there are other variables on top of it, it survives and continues living.</p>
			<p class="normal">Eventually, however, this stuff will get popped out of the Stack because at some point in the future the program has to be finished, and the stack should be empty at that moment. So, there should be<a id="_idIndexMarker385"/> a point in the future when this variable is popped out of the stack. So, the deallocation, or getting popped out, happens automatically, and that can be marked as the end of the variable's lifetime. This is basically the reason why we say that we have automatic memory management for the Stack variables that is not controlled by the programmer.</p>
			<p class="normal">Suppose that you have defined a variable in the <code class="Code-In-Text--PACKT-">main</code> function, as we see in the following code box:</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  int a;</p>
			<p class="snippet code">  ...</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 5-4: Declaring a variable on top of the Stack</p>
			<p class="normal">This variable will stay in the Stack until the <code class="Code-In-Text--PACKT-">main</code> function returns. In other words, the variable exists until its scope (the <code class="Code-In-Text--PACKT-">main</code> function) is valid. Since the <code class="Code-In-Text--PACKT-">main</code> function is the function in which all the program runs, the lifetime of the variable is almost like a global variable that is declared throughout the runtime of the program.</p>
			<p class="normal">It is like a global variable, but not exactly one, because there will be a time that the variable is popped out from the Stack, whereas a global variable always has its memory even when the main function is finished and the program is being finalized. Note that there are two pieces of code that are run before and after the <code class="Code-In-Text--PACKT-">main</code> function, bootstrapping and finalizing the program respectively. As another note, global variables are allocated from a different segment, Data or BSS, that does not behave like the Stack segment.</p>
			<p class="normal">Let's now look at an example of a very common mistake. It usually happens to an amateur programmer while writing their first C programs. It is about returning an address to a local variable inside a function.</p>
			<p class="normal">The following code box shows <em class="italics">example 5.2</em>:</p>
			<p class="snippet code">int* get_integer() {</p>
			<p class="snippet code">  int var = 10;</p>
			<p class="snippet code">  return &amp;var;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  int* ptr = get_integer();</p>
			<p class="snippet code">  *ptr = 5;</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 5-5 [ExtremeC_examples_chapter5_2.c]: Declaring a variable on top of the Stack</p>
			<p class="normal">The <code class="Code-In-Text--PACKT-">get_integer</code> function returns an address to the local variable, <code class="Code-In-Text--PACKT-">var</code>, which has been declared in the scope of the <code class="Code-In-Text--PACKT-">get_integer</code> function. The <code class="Code-In-Text--PACKT-">get_integer</code> function returns the address of the local variable. Then, the <code class="Code-In-Text--PACKT-">main</code> function tries to dereference the received pointer and access the <a id="_idIndexMarker386"/>memory region behind. The following is the output of the <code class="Code-In-Text--PACKT-">gcc</code> compiler while compiling the preceding code on a Linux system:</p>
			<p class="snippet shell"><strong class="highlight">$ g</strong><strong class="highlight">cc</strong><strong class="highlight"> ExtremeC_examples_chapter5_2.c -o ex5_2.out</strong></p>
			<p class="snippet shell">ExtremeC_examples_chapter5_2.c: In function 'get_integer':</p>
			<p class="snippet shell">ExtremeC_examples_chapter5_2.c:3:11: warning: function returns address of local variable [-Wreturn-local-addr]</p>
			<p class="snippet shell">   return &amp;var;</p>
			<p class="snippet shell">          ^~~~</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 5-14: Compiling the example 5.2 in Linux</p>
			<p class="normal">As you can see, we have received a warning message. Since returning the address of a local variable is a common mistake, compilers already know about it, and they show a clear warning message like <code class="Code-In-Text--PACKT-">warning: function returns address of a local variable</code>.</p>
			<p class="normal">And this is what happens when we execute the program:</p>
			<p class="snippet shell"><strong class="highlight">$ ./ex5_2</strong><strong class="highlight">.out</strong></p>
			<p class="snippet shell">Segmentation fault (core dumped)</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 5-15: Executing the example 5.2 in Linux</p>
			<p class="normal">As you can see in <em class="italics">Shell Box 5-15</em>, a segmentation fault has happened. It can be translated as a crash. It is usually because of invalid access to a region of memory that had been allocated at some point, but now it is deallocated.</p>
			<div>
				<div id="_idContainer058" class="note">
					<p class="Information-Box--PACKT-"><strong class="bold">Note</strong>: </p>
					<p class="Information-Box--PACKT-">Some warnings should be treated as errors. For example, the preceding warning should be an error because it usually leads to a crash. If you want to make all warning to be treated as errors, it is enough to pass the <code class="Code-In-Text--PACKT-">-Werror</code> option to <code class="Code-In-Text--PACKT-">gcc</code> compiler. If you want to treat only one specific warning as an error, for example, the preceding warning, it is enough to pass the <code class="Code-In-Text--PACKT-">-Werror=return-local-addr</code> option.</p>
				</div>
			</div>
			<p class="normal">If you run the program <a id="_idIndexMarker387"/>with <code class="Code-In-Text--PACKT-">gdb</code>, you will see more details regarding the crash. But remember, you need to compile the program with the <code class="Code-In-Text--PACKT-">-g</code> option otherwise <code class="Code-In-Text--PACKT-">gdb</code> won't be that helpful.</p>
			<p class="normal">It is always mandatory to compile the sources with <code class="Code-In-Text--PACKT-">-g</code> option if you are about to debug the program using <code class="Code-In-Text--PACKT-">gdb</code> or other debugging tools such as <code class="Code-In-Text--PACKT-">valgrind</code>. The following shell box demonstrates how to compile and run <em class="italics">example 5.2</em> in the debugger:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc -g ExtremeC_examples_chapter5_2.c -o ex5_2_dbg.out</strong></p>
			<p class="snippet shell">ExtremeC_examples_chapter5_2.c: In function 'get_integer':</p>
			<p class="snippet shell">ExtremeC_examples_chapter5_2.c:3:11: warning: function returns address of local variable [-Wreturn-local-addr]</p>
			<p class="snippet shell">   return &amp;var;</p>
			<p class="snippet shell">          ^~~~</p>
			<p class="snippet shell"><strong class="highlight">$ gdb ex5_2_dbg.out</strong></p>
			<p class="snippet shell">GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell">Reading symbols from ex5_2_dbg.out...done.</p>
			<p class="snippet shell"><strong class="highlight">(gdb) run</strong></p>
			<p class="snippet shell">Starting program: .../extreme_c/5.2/ex5_2_dbg.out</p>
			<p class="snippet shell">Program received signal SIGSEGV, Segmentation fault.</p>
			<p class="snippet shell">0x00005555555546c4 in main (argc=1, argv=0x7fffffffdf88) at ExtremeC_examples_chapter5_2.c:8</p>
			<p class="snippet shell">8    *ptr = 5;</p>
			<p class="snippet shell"><strong class="highlight">(gdb) quit</strong></p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 5-16: Running the example 5.2 in the debugger</p>
			<p class="normal">As is clear from the <code class="Code-In-Text--PACKT-">gdb</code> output, the source of the crash is located at line 8 in the <code class="Code-In-Text--PACKT-">main</code> function, exactly where the program tries to write to the returned address by dereferencing the returned pointer. But the <code class="Code-In-Text--PACKT-">var</code> variable has been a local variable to the <code class="Code-In-Text--PACKT-">get_integer</code> function and it doesn't exist anymore, simply because at line 8 we have already returned from the <code class="Code-In-Text--PACKT-">get_integer</code> function and its scope, together with all variables, have vanished. Therefore, the returned pointer is a <em class="italics">dangling pointer</em>.</p>
			<p class="normal">It is usually a common <a id="_idIndexMarker388"/>practice to pass the pointers addressing the variables in the current scope to other functions but not the other way around, because as long as the current scope is valid, the variables are there. Further function calls only put more stuff on top of the Stack segment, and the current scope won't be finished before them.</p>
			<p class="normal">Note that the above statement is not a good practice regarding concurrent programs because in the future, if another concurrent task wants to use the received pointer addressing a variable inside the current scope, the current scope might have vanished already.</p>
			<p class="normal">To end this section and have a <a id="_idIndexMarker389"/>conclusion about the Stack segment, the following points can be extracted from what we have explained so far:</p>
			<ul>
				<li class="list">Stack memory has a limited size; therefore, it is not a good place to store big objects.</li>
				<li class="list">The addresses in Stack segment grow backward, therefore reading forward in the Stack memory means reading already pushed bytes.</li>
				<li class="list">Stack has automatic memory management, both for allocation and deallocation.</li>
				<li class="list">Every Stack variable has a scope and it determines its lifetime. You should design your logic based on this lifetime. You have no control over it.</li>
				<li class="list">Pointers should only point to those Stack variables that are still in a scope.</li>
				<li class="list">Memory deallocation of Stack variables is done automatically when the scope is about to finish, and you have no control over it.</li>
				<li class="list">Pointers to variables that exist in the current scope can be passed to other functions as arguments only when we are sure that the current scope will be still in place when the code in the called functions is about to use that pointer. This condition might break in situations when we have concurrent logic.</li>
			</ul>
			<p class="normal">In the next section, we will talk about the Heap segment and its va<a id="_idTextAnchor153"/>rious features.</p>
			<h1 id="_idParaDest-86" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor154"/>Heap</h1>
			<p class="normal">Almost any code, written in <a id="_idIndexMarker390"/>any programming language, uses Heap memory in some way. That's because the Heap has some unique advantages that cannot be achieved by using the Stack.</p>
			<p class="normal">On the other hand, it also<a id="_idIndexMarker391"/> has some disadvantages; for example, it is slower to allocate a region of Heap memory in comparison to a similar region in Stack memory. </p>
			<p class="normal">In this section, we are going to talk more about the Heap itself and the guidelines we should keep in mind when using Heap memory.</p>
			<p class="normal">Heap memory is<a id="_idIndexMarker392"/> important because of its unique properties. Not all of them are advantageous and, in fact, some of them can be considered as risks that should be mitigated. A great tool always has good points and some bad points, and if you are going to use it properly, you are required to know both sides very well.</p>
			<p class="normal">Here, we are going to list these features<a id="_idIndexMarker393"/> and see which ones are beneficial and which are risky:</p>
			<ol>
				<li class="list"><strong class="bold">The Heap doesn't have any memory blocks that are allocated automatically</strong>. Instead, the programmer must use <code class="Code-In-Text--PACKT-">malloc</code> or similar functions to obtain Heap memory blocks, one by one. In fact, this could be regarded as a weak point for Stack memory that is resolved by Heap memory. Stack memory can contain stack frames, which are not allocated and pushed by the programmer but as a result of function calls, and in an automatic fashion.</li>
				<li class="list"><strong class="bold">The Heap has a large memory size</strong>. While the size of the Stack is limited and it is not a good choice for keeping big objects, the Heap allows the storing of very big objects even tens of gigabytes in size. As the Heap size grows, the allocator needs to request more heap pages from the operating system, and the Heap memory blocks are spread among these pages. Note that, unlike the Stack segment, the allocating addresses in the Heap memory move forward to bigger addresses.</li>
				<li class="list"><strong class="bold">Memory allocation and deallocation inside Heap memory are managed by the programmer</strong>. This means that the programmer is the sole responsible entity for allocating the memory and then freeing it when it is not needed anymore. In many recent programming languages, freeing allocated Heap blocks is done automatically by a parallel component called <em class="italics">garbage collector</em>. But in C <a id="_idIndexMarker394"/>and C++, we don't have such a concept and freeing the Heap blocks should be done manually. This is indeed a risk, and C/C++ programmers should be very careful while using heap memory. Failing to free the allocated Heap blocks usually leads to <em class="italics">memory leaks</em>, which can<a id="_idIndexMarker395"/> be fatal in most cases.</li>
				<li class="list"><strong class="bold">Variables allocated from the Heap do not have any scope</strong>, unlike variables in the Stack. </li>
				<li class="list">This is a risk because it makes memory management much harder. You don't know when you need to deallocate the variable, and you have to come up with <a id="_idIndexMarker396"/>some new definitions for the <em class="italics">scope</em> and the <em class="italics">owner</em> of the <a id="_idIndexMarker397"/>memory block in order to do the memory management effectively. Some of these methods are covered in the upcoming sections.</li>
				<li class="list"><strong class="bold">We can only use pointers to address a Heap memory block</strong>. In other words, there is no such concept as a Heap variable. The Heap region is addressed via pointers.</li>
			</ol>
			<ol>
				<li class="list" value="7"><strong class="bold">Since the Heap segment is private to its owner process, we need to use a debugger to probe it</strong>. Fortunately, C pointers work with the Heap memory block exactly the same as they <a id="_idIndexMarker398"/>work with Stack memory blocks. C does this abstraction very well, and because of this, we can use the same pointers to address both memories. Therefore, we can use the same methods that we used to examine the Stack to probe the Heap memory.</li>
			</ol>
			<p class="normal">In the next section, we are going to discuss how to allocate and deallocate a heap memory block.</p>
			<h2 id="_idParaDest-87" class="title" lang="en-GB" xml:lang="en-GB">Heap memor<a id="_idTextAnchor155"/>y allocation and deallocation</h2>
			<p class="normal">As we said in the previous section,<a id="_idIndexMarker399"/> Heap memory should be obtained and released<a id="_idIndexMarker400"/> manually. This means that the programmer should use a set of functions or API (the C standard library's memory allocation functions) in order to allocate or free a memory block in the Heap.</p>
			<p class="normal">These functions do exist, and they are defined in the header, <code class="Code-In-Text--PACKT-">stdlib.h</code>. The functions used for obtaining a Heap memory block are <code class="Code-In-Text--PACKT-">malloc</code>, <code class="Code-In-Text--PACKT-">calloc</code>, and <code class="Code-In-Text--PACKT-">realloc</code>, and the sole function used for releasing a Heap memory block is <code class="Code-In-Text--PACKT-">free</code>. <em class="italics">Example 5.3</em> demonstrates how to use some of these functions.</p>
			<div>
				<div id="_idContainer059" class="note">
					<p class="Information-Box--PACKT-"><strong class="bold">Note</strong>: </p>
					<p class="Information-Box--PACKT-">In some texts, dynamic memory is used to refer to Heap memory. <em class="italics">Dynamic memory allocation</em> is a synonym for Heap memory allocation.</p>
				</div>
			</div>
			<p class="normal">The following code box shows the source code of <em class="italics">example 5.3</em>. It allocates two Heap memory blocks, and then it prints its own memory mappings:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;  // For printf function</p>
			<p class="snippet code">#include &lt;stdlib.h&gt; // For C library's heap memory functions</p>
			<p class="snippet code">void print_mem_maps() {</p>
			<p class="snippet code">#ifdef __linux__</p>
			<p class="snippet code">  FILE* fd = fopen("/proc/self/maps", "r");</p>
			<p class="snippet code">  if (!fd) {</p>
			<p class="snippet code">    printf("Could not open maps file.\n");</p>
			<p class="snippet code">    exit(1);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  char line[1024];</p>
			<p class="snippet code">  while (!feof(fd)) {</p>
			<p class="snippet code">    fgets(line, 1024, fd);</p>
			<p class="snippet code">    printf("&gt; %s", line);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  fclose(fd);</p>
			<p class="snippet code">#endif</p>
			<p class="snippet code">}</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  // Allocate 10 bytes without initialization</p>
			<p class="snippet code">  char* ptr1 = (char*)malloc(10 * sizeof(char));</p>
			<p class="snippet code">  printf("Address of ptr1: %p\n", (void*)&amp;ptr1);</p>
			<p class="snippet code">  printf("Memory allocated by malloc at %p: ", (void*)ptr1);</p>
			<p class="snippet code">  for (int i = 0; i &lt; 10; i++) {</p>
			<p class="snippet code">    printf("0x%02x ", (unsigned char)ptr1[i]);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  printf("\n");</p>
			<p class="snippet code">  // Allocation 10 bytes all initialized to zero</p>
			<p class="snippet code">  char* ptr2 = (char*)calloc(10, sizeof(char));</p>
			<p class="snippet code">  printf("Address of ptr2: %p\n", (void*)&amp;ptr2);</p>
			<p class="snippet code">  printf("Memory allocated by calloc at %p: ", (void*)ptr2);</p>
			<p class="snippet code">  for (int i = 0; i &lt; 10; i++) {</p>
			<p class="snippet code">    printf("0x%02x ", (unsigned char)ptr2[i]);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  printf("\n");</p>
			<p class="snippet code">  print_mem_maps();</p>
			<p class="snippet code">  free(ptr1);</p>
			<p class="snippet code">  free(ptr2);</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 5-6 [ExtremeC_examples_chapter5_3.c]: Example 5.3 showing the memory mappings after allocating two Heap memory blocks</p>
			<p class="normal">The preceding code is cross-platform, and you can compile it on most Unix-like operating systems. But the <code class="Code-In-Text--PACKT-">print_mem_maps</code> function only works on Linux since the <code class="Code-In-Text--PACKT-">__linux__</code> macro is only <a id="_idIndexMarker401"/>defined in Linux environments. Therefore, in <a id="_idIndexMarker402"/>macOS, you can compile the code, but the <code class="Code-In-Text--PACKT-">print_mem_maps</code> function won't do anything.</p>
			<p class="normal">The following shell box is the result of running the example in a Linux environment:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter5_3.c -o ex5_3.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ex5_3.out</strong></p>
			<p class="snippet shell">Address of ptr1: <strong class="highlight">0x7ffe0ad75c38</strong></p>
			<p class="snippet shell">Memory allocated by malloc at <strong class="highlight">0x564c03977260</strong>: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 </p>
			<p class="snippet shell">Address of ptr2: <strong class="highlight">0x7ffe0ad75c40</strong></p>
			<p class="snippet shell">Memory allocated by calloc at <strong class="highlight">0x564c03977690</strong>: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 </p>
			<p class="snippet shell">&gt; 564c01978000-564c01979000 r-xp 00000000 08:01 5898436                    /home/kamranamini/extreme_c/5.3/ex5_3.out</p>
			<p class="snippet shell">&gt; 564c01b79000-564c01b7a000 r--p 00001000 08:01 5898436                    /home/kamranamini/extreme_c/5.3/ex5_3.out</p>
			<p class="snippet shell">&gt; 564c01b7a000-564c01b7b000 rw-p 00002000 08:01 5898436                    /home/kamranamini/extreme_c/5.3/ex5_3.out</p>
			<p class="snippet shell"><strong class="highlight">&gt; 564c03977000-564c03998000 rw-p 00000000 00:00 0           [heap]</strong></p>
			<p class="snippet shell">&gt; 7f31978ec000-7f3197ad3000 r-xp 00000000 08:01 5247803     /lib/x86_64-linux-gnu/libc-2.27.so</p>
			<p class="snippet shell">...</p>
			<p class="snippet shell">&gt; 7f3197eef000-7f3197ef1000 rw-p 00000000 00:00 0 </p>
			<p class="snippet shell">&gt; 7f3197f04000-7f3197f05000 r--p 00027000 08:01 5247775     /lib/x86_64-linux-gnu/ld-2.27.so</p>
			<p class="snippet shell">&gt; 7f3197f05000-7f3197f06000 rw-p 00028000 08:01 5247775     /lib/x86_64-linux-gnu/ld-2.27.so</p>
			<p class="snippet shell">&gt; 7f3197f06000-7f3197f07000 rw-p 00000000 00:00 0 </p>
			<p class="snippet shell">&gt; <strong class="highlight">7ffe0ad57000-7ffe0ad78000 rw-p 00000000 00:00 0           [stack]</strong></p>
			<p class="snippet shell">&gt; 7ffe0adc2000-7ffe0adc5000 r--p 00000000 00:00 0           [vvar]</p>
			<p class="snippet shell">&gt; 7ffe0adc5000-7ffe0adc7000 r-xp 00000000 00:00 0           [vdso]</p>
			<p class="snippet shell">&gt; ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0   [vsyscall]</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 5-17: Output of example 5.3 in Linux</p>
			<p class="normal">The preceding output has a lot to say. The program prints the addresses of the pointers <code class="Code-In-Text--PACKT-">ptr1</code> and <code class="Code-In-Text--PACKT-">ptr2</code>. If you find the memory mapping of the Stack segment, as part of the printed memory mappings, you see that the Stack region starts from <code class="Code-In-Text--PACKT-">0x7ffe0ad57000</code> and ends at <code class="Code-In-Text--PACKT-">0x7ffe0ad78000</code>. The pointers are within this range. </p>
			<p class="normal">This means that the pointers are allocated from<a id="_idIndexMarker403"/> the Stack, but they are pointing to a memory region outside of the Stack segment, in this case, the Heap segment. It is very common to use a Stack pointer to address <a id="_idIndexMarker404"/>a Heap memory block.</p>
			<p class="normal">Keep in mind that the <code class="Code-In-Text--PACKT-">ptr1</code> and <code class="Code-In-Text--PACKT-">ptr2</code> pointers have the same scope and they will be freed when the <code class="Code-In-Text--PACKT-">main</code> function returns, but there is no scope to the Heap memory blocks obtained from the Heap segment. They will remain allocated until the program frees them manually. You can see that before returning from the <code class="Code-In-Text--PACKT-">main</code> function, both memory blocks are freed using the pointers pointing to them and using the <code class="Code-In-Text--PACKT-">free</code> function.</p>
			<p class="normal">As a further note regarding the above example, we can see that the addresses returned by the <code class="Code-In-Text--PACKT-">malloc</code> and <code class="Code-In-Text--PACKT-">calloc</code> functions are located inside the Heap segment. This can be investigated by comparing the returned addresses and the memory mapping described as <code class="Code-In-Text--PACKT-">[heap]</code>. The region marked as heap starts from <code class="Code-In-Text--PACKT-">0x564c03977000</code> and ends at <code class="Code-In-Text--PACKT-">0x564c03998000</code>. The <code class="Code-In-Text--PACKT-">ptr1</code> pointer points to the address <code class="Code-In-Text--PACKT-">0x564c03977260</code> and the <code class="Code-In-Text--PACKT-">ptr2 p</code>ointer points to the address <code class="Code-In-Text--PACKT-">0x564c03977690</code>, which are both inside the heap region.</p>
			<p class="normal">Regarding the Heap allocation<a id="_idIndexMarker405"/> function, as their names imply, <code class="Code-In-Text--PACKT-">calloc</code> stands for <strong class="bold">clear and allocate</strong> and <code class="Code-In-Text--PACKT-">malloc</code> stands for <strong class="bold">memory allocate</strong>. So, this means that <code class="Code-In-Text--PACKT-">calloc</code> clears the memory block <a id="_idIndexMarker406"/>after allocation, but <code class="Code-In-Text--PACKT-">malloc</code> leaves it uninitialized until the program does it itself if necessary.</p>
			<div>
				<div id="_idContainer060" class="note">
					<p class="Information-Box--PACKT-"><strong class="bold">Note</strong>: </p>
					<p class="Information-Box--PACKT-">In C++, the <code class="Code-In-Text--PACKT-">new</code> and <code class="Code-In-Text--PACKT-">delete</code> keywords do the same as <code class="Code-In-Text--PACKT-">malloc</code> and <code class="Code-In-Text--PACKT-">free</code> respectively. Additionally, new operator infers the size of the allocated memory block from the operand type and also converts the returned pointer to the operand type automatically.</p>
				</div>
			</div>
			<p class="normal">But if you look at the bytes in the two allocated blocks, both of them have zero bytes. So, it seems that <code class="Code-In-Text--PACKT-">malloc</code> has also initialized the memory block after the allocation. But based on the description of <code class="Code-In-Text--PACKT-">malloc</code> in the C Specification, <code class="Code-In-Text--PACKT-">malloc</code> doesn't initialize the allocated memory block. So, why is that? To move this further, let's run the example in a macOS environment:</p>
			<p class="snippet shell"><strong class="highlight">$ clang ExtremeC_examples_chapter5_3.c -o ex5_3.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ ex5_3.out</strong></p>
			<p class="snippet shell">Address of ptr1: 0x7ffee66b2888</p>
			<p class="snippet shell">Memory allocated by malloc at 0x7fc628c00370: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 <strong class="highlight">0x80</strong> 0x00 0x00</p>
			<p class="snippet shell">Address of ptr2: 0x7ffee66b2878</p>
			<p class="snippet shell">Memory allocated by calloc at 0x7fc628c02740: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 5-18: Output of example 5.3 on macOS</p>
			<p class="normal">If you look carefully, you can see that the memory block allocated by <code class="Code-In-Text--PACKT-">malloc</code> has some non-zero bytes, but the memory block <a id="_idIndexMarker407"/>allocated by <code class="Code-In-Text--PACKT-">calloc</code> is all zeros. So, what should we do? Should we assume that the <a id="_idIndexMarker408"/>memory block allocated by <code class="Code-In-Text--PACKT-">malloc</code> in Linux is always zeros?</p>
			<p class="normal">If you are going to write a cross-platform program, always be aligned with the C specification. The specification says <code class="Code-In-Text--PACKT-">malloc</code> does not initialize the allocated memory block. </p>
			<p class="normal">Even when you are writing your program only for Linux and not for other operating systems, be aware that future compilers may behave differently. Therefore, according to the C specification, we must always assume that the memory block allocated by the <code class="Code-In-Text--PACKT-">malloc</code> is not initialized and it should be initialized manually if necessary.</p>
			<p class="normal">Note that since <code class="Code-In-Text--PACKT-">malloc</code> doesn't initialize the allocated memory, it is usually faster than <code class="Code-In-Text--PACKT-">calloc</code>. In some implementations, <code class="Code-In-Text--PACKT-">malloc</code> doesn't actually allocate the memory block and defer the allocation until when the memory block is accessed (either read or write). This way, memory allocations happen faster.</p>
			<p class="normal">If you are going to initialize the memory after <code class="Code-In-Text--PACKT-">malloc</code>, you can use the <code class="Code-In-Text--PACKT-">memset</code> function. Here is an example:</p>
			<p class="snippet code">#include &lt;stdlib.h&gt; // For malloc</p>
			<p class="snippet code">#include &lt;string.h&gt; // For memset</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  char* ptr = (char*)malloc(16 * sizeof(char));</p>
			<p class="snippet code">  memset(ptr, 0, 16 * sizeof(char));    // Fill with 0</p>
			<p class="snippet code">  memset(ptr, 0xff, 16 * sizeof(char)); // Fill with 0xff</p>
			<p class="snippet code">  ...</p>
			<p class="snippet code">  free(ptr);</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 5-7: Using the memset<a id="_idTextAnchor156"/> function to initialize a memory block</p>
			<p class="normal">The <code class="Code-In-Text--PACKT-">realloc</code> function is<a id="_idIndexMarker409"/> another function that is introduced as part of the Heap<a id="_idIndexMarker410"/> allocation functions. It was not used as part of <em class="italics">example 5.3</em>. It actually reallocates the memory by resizing an already allocated memory block. Here is an example:</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  char* ptr = (char*)malloc(16 * sizeof(char));</p>
			<p class="snippet code">  ...</p>
			<p class="snippet code">  ptr = (char*)realloc(32 * sizeof(char));</p>
			<p class="snippet code">  ...</p>
			<p class="snippet code">  free(ptr);</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 5-8: Using the realloc function to change the size of an already allocated block</p>
			<p class="normal">The <code class="Code-In-Text--PACKT-">realloc</code> function does not change the data in the old block and only expands an already allocated block to a new one. If it cannot expand the currently allocated block because of <em class="italics">fragmentation</em>, it will find another block that's large enough and copy the data from the old block to the new one. In this case, it will also free the old block. As you can see, reallocation is not a cheap operation in some cases because it involves many steps, hence it should be used with care.</p>
			<p class="normal">The last note about <em class="italics">example 5.3</em> is on the <code class="Code-In-Text--PACKT-">free</code> function. In fact, it deallocates an already allocated Heap memory block by passing the block's address as a pointer. As it is said before, any allocated Heap block should be freed when it is not needed. Failing to do so leads to <em class="italics">memory leakage</em>. Using a <a id="_idIndexMarker411"/>new example, <em class="italics">example 5.4</em>, we are going to show you how to detect memory leaks using the <code class="Code-In-Text--PACKT-">valgrind</code> tool.</p>
			<p class="normal">Let's first produce some memory leaks as part of <em class="italics">example 5.4</em>:</p>
			<p class="snippet code">#include &lt;stdlib.h&gt; // For heap memory functions</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  char* ptr = (char*)malloc(16 * sizeof(char));</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 5-9: Producing a memory leak by not freeing the allocated block when returning from the main function</p>
			<p class="normal">The preceding program has a memory leak because when the program ends, we have <code class="Code-In-Text--PACKT-">16</code> bytes of Heap memory allocated and not freed. This example is very simple, but when the source code grows and more components are involved, it would be too hard or even impossible to detect it by sight. </p>
			<p class="normal">Memory profilers are useful programs that can detect the memory issues in a running process. The famous <code class="Code-In-Text--PACKT-">valgrind</code> tool is one of the most well knowns.</p>
			<p class="normal">In order to use <code class="Code-In-Text--PACKT-">valgrind</code> to analyze <em class="italics">example 5.4</em>, first we need to build the example with the debug option, <code class="Code-In-Text--PACKT-">-g</code>. Then, we should<a id="_idIndexMarker412"/> run it using <code class="Code-In-Text--PACKT-">valgrind</code>. While running the given<a id="_idIndexMarker413"/> executable object file, <code class="Code-In-Text--PACKT-">valgrind</code> records all of the memory allocations and deallocations. Finally, when the execution is finished or a crash happens, <code class="Code-In-Text--PACKT-">valgrind</code> prints out the summary of allocations and deallocations and the amount of memory that has not been freed. This way, it can let you know how much memory leak has been produced as part of the execution of the given program.</p>
			<p class="normal">The following shell box demonstrates how to compile and use <code class="Code-In-Text--PACKT-">valgrind</code> for <em class="italics">example 5.4</em>:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc -g ExtremeC_examples_chapter5_4.c -o ex5_4.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ valgrind ./ex5_4.out</strong></p>
			<p class="snippet shell">==12022== Memcheck, a memory error detector</p>
			<p class="snippet shell">==12022== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.</p>
			<p class="snippet shell">==12022== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</p>
			<p class="snippet shell">==12022== Command: ./ex5_4.out</p>
			<p class="snippet shell">==12022== </p>
			<p class="snippet shell">==12022== </p>
			<p class="snippet shell">==12022== HEAP SUMMARY:</p>
			<p class="snippet shell">==12022==     <strong class="highlight">in use at exit: 16 bytes in 1 blocks</strong></p>
			<p class="snippet shell">==12022==   total heap usage: 1 allocs, 0 frees, 16 bytes allocated</p>
			<p class="snippet shell">==12022== </p>
			<p class="snippet shell">==12022== LEAK SUMMARY:</p>
			<p class="snippet shell">==12022==    <strong class="highlight">definitely lost: 16 bytes in 1 blocks</strong></p>
			<p class="snippet shell">==12022==    indirectly lost: 0 bytes in 0 blocks</p>
			<p class="snippet shell">==12022==      possibly lost: 0 bytes in 0 blocks</p>
			<p class="snippet shell">==12022==    still reachable: 0 bytes in 0 blocks</p>
			<p class="snippet shell">==12022==         suppressed: 0 bytes in 0 blocks</p>
			<p class="snippet shell">==12022== Rerun with --leak-chck=full to see details of leaked memory</p>
			<p class="snippet shell">==12022== </p>
			<p class="snippet shell">==12022== For counts of detected and suppressed errors, rerun with: -v</p>
			<p class="snippet shell">==12022== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 5-19: Output of valgrind showing the 16-byte memory leak as part of the execution of example 5.4</p>
			<p class="normal">If you look into the <code class="Code-In-Text--PACKT-">HEAP SUMMARY</code> section in <em class="italics">Shell Box 5-19</em>, you can see that we had <code class="Code-In-Text--PACKT-">1</code> allocation and <code class="Code-In-Text--PACKT-">0</code> frees, and <code class="Code-In-Text--PACKT-">16</code> bytes<a id="_idIndexMarker414"/> remained allocated while exiting. If you come down a bit to the <code class="Code-In-Text--PACKT-">LEAK SUMMARY</code> section, it states that <code class="Code-In-Text--PACKT-">16</code> bytes are definitely lost, and this means a memory leak!</p>
			<p class="normal">If you want to know <a id="_idIndexMarker415"/>exactly at which line the mentioned leaking memory block has been allocated, you can use <code class="Code-In-Text--PACKT-">valgrind</code> with a special option designed for this. In the following shell box, you will see how to use <code class="Code-In-Text--PACKT-">valgrind</code> to find the lines responsible for the actual allocation:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc -g ExtremeC_examples_chapter5_4.c -o ex5_4.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ valgrind --leak-check=full ./ex5_4.out</strong></p>
			<p class="snippet shell">==12144== Memcheck, a memory error detector</p>
			<p class="snippet shell">==12144== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.</p>
			<p class="snippet shell">==12144== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</p>
			<p class="snippet shell">==12144== Command: ./ex5_4.out</p>
			<p class="snippet shell">==12144== </p>
			<p class="snippet shell">==12144== </p>
			<p class="snippet shell">==12144== HEAP SUMMARY:</p>
			<p class="snippet shell">==12144==     in use at exit: 16 bytes in 1 blocks</p>
			<p class="snippet shell">==12144==   total heap usage: 1 allocs, 0 frees, 16 bytes allocated</p>
			<p class="snippet shell">==12144== </p>
			<p class="snippet shell">==12144== 16 bytes in 1 blocks are definitely lost in loss record 1 of 1</p>
			<p class="snippet shell">==12144==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)</p>
			<p class="snippet shell">==12144==    by 0x108662: <strong class="highlight">main (ExtremeC_examples_chapter5_4.c:4)</strong></p>
			<p class="snippet shell">==12144== </p>
			<p class="snippet shell">==12144== LEAK SUMMARY:</p>
			<p class="snippet shell">==12144==    definitely lost: 16 bytes in 1 blocks</p>
			<p class="snippet shell">==12144==    indirectly lost: 0 bytes in 0 blocks</p>
			<p class="snippet shell">==12144==      possibly lost: 0 bytes in 0 blocks</p>
			<p class="snippet shell">==12144==    still reachable: 0 bytes in 0 blocks</p>
			<p class="snippet shell">==12144==         suppressed: 0 bytes in 0 blocks</p>
			<p class="snippet shell">==12144== </p>
			<p class="snippet shell">==12144== For counts of detected and suppressed errors, rerun with : -v</p>
			<p class="snippet shell">==12144== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 5-20: Output of valgrind showing the line that is responsible for the actual allocation</p>
			<p class="normal">As you can see, we have passed the <code class="Code-In-Text--PACKT-">--leak-check=full</code> option to <code class="Code-In-Text--PACKT-">valgrind</code>, and now it shows the line of code that is<a id="_idIndexMarker416"/> responsible for the leaking Heap memory. It clearly shows that line 4 in <em class="italics">Code Box 5-9</em>, which is a <code class="Code-In-Text--PACKT-">malloc</code> call, is where the leaking Heap block<a id="_idIndexMarker417"/> has been allocated. This can help you to trace it further and find the right place that the mentioned leaking block should be freed.</p>
			<p class="normal">OK, let's change the preceding example so that it frees the allocated memory. We just need to add the <code class="Code-In-Text--PACKT-">free(ptr)</code> instruction before the <code class="Code-In-Text--PACKT-">return</code> statement, as we can see here:</p>
			<p class="snippet code">#include &lt;stdlib.h&gt; // For heap memory functions</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  char* ptr = (char*)malloc(16 * sizeof(char));</p>
			<p class="snippet code">  free(ptr);</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 5-10: Freeing up the allocated memory block as part of example 5.4</p>
			<p class="normal">Now with this change, the only allocated Heap block is freed. Let's build and run <code class="Code-In-Text--PACKT-">valgrind</code> again:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc -g ExtremeC_examples_chapter5_4.c -o ex5_4.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ valgrind --leak-check=full ./ex5_4.out</strong></p>
			<p class="snippet shell">==12175== Memcheck, a memory error detector</p>
			<p class="snippet shell">==12175== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.</p>
			<p class="snippet shell">==12175== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info</p>
			<p class="snippet shell">==12175== Command: ./ex5_4.out</p>
			<p class="snippet shell">==12175== </p>
			<p class="snippet shell">==12175== </p>
			<p class="snippet shell">==12175== HEAP SUMMARY:</p>
			<p class="snippet shell">==12175==     in use at exit: 0 bytes in 0 blocks</p>
			<p class="snippet shell">==12175==   total heap usage: 1 allocs, 1 frees, 16 bytes allocated</p>
			<p class="snippet shell">==12175== </p>
			<p class="snippet shell">==12175== <strong class="highlight">All heap blocks were freed -- no leaks are possible</strong></p>
			<p class="snippet shell">==12175== </p>
			<p class="snippet shell">==12175== For counts of detected and suppressed errors, rerun with  -v</p>
			<p class="snippet shell">==12175== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 5-20: Output of valgrind after freeing the allocated memory block</p>
			<p class="normal">As you can see, <code class="Code-In-Text--PACKT-">valgrind</code> says that <code class="Code-In-Text--PACKT-">All Heap blocks were freed</code>, and this effectively means that we have no further memory<a id="_idIndexMarker418"/> leakage in our program. Running programs with <code class="Code-In-Text--PACKT-">valgrind</code> can slow them down noticeably by a factor of 10 to 50, but it can help you to spot the memory issues very <a id="_idIndexMarker419"/>easily. It's a good practice to let your written programs run inside a memory profiler and catch memory leaks as soon as possible.</p>
			<p class="normal">Memory leaks can be considered<a id="_idIndexMarker420"/> both as <em class="italics">technical debts</em>, if you have a bad design that causes<a id="_idIndexMarker421"/> the leaks, or as <em class="italics">risks</em>, where it's known that <a id="_idIndexMarker422"/>we have a leak, but we don't know what will happen if the leak continues to grow. But in my opinion, they should be<a id="_idIndexMarker423"/> treated as <em class="italics">bugs</em>; otherwise, it will take a while for you to look back at them. Usually, in teams, memory leaks are treated as bugs that should be fixed as soon as possible.</p>
			<p class="normal">There are other memory<a id="_idIndexMarker424"/> profilers other than <code class="Code-In-Text--PACKT-">valgrind</code>. <strong class="bold">LLVM Address Sanitizer</strong> (or <strong class="bold">ASAN</strong>) and <strong class="bold">MemProf</strong> are also other well-known memory profilers. Memory profilers can profile memory usage and allocations using various methods. Next, we discuss some of them:</p>
			<ul>
				<li class="list">Some profilers can behave like a sandbox, running the target program inside and monitoring all their memory activities. We've used this method to run <em class="italics">example 5.4</em> inside a <code class="Code-In-Text--PACKT-">valgrind</code> sandbox. This method does not require you to recompile your code.</li>
				<li class="list">Another method is to<a id="_idIndexMarker425"/> use the libraries provided by some memory<a id="_idIndexMarker426"/> profilers, which wrap memory-related system calls. This way, the final binary will contain all of the logic required for the profiling task. <p class="list"><code class="Code-In-Text--PACKT-">valgrind</code> and ASAN can be linked to the final executable object file as a memory profiler library. This method requires the recompilation of your target source code and even making some modifications to your source code as well.</p></li>
				<li class="list">Programs can also <em class="italics">preload</em> different libraries instead of the default C standard libraries, which contain memory <em class="italics">function interpositions</em> of the C library's standard memory allocation functions. This way, you are not required to compile your target source code. You just need to specify the libraries of such profilers in the <code class="Code-In-Text--PACKT-">LD_PRELOAD</code> environment variable to be preloaded instead of the default <code class="Code-In-Text--PACKT-">libc</code> libraries. <code class="Code-In-Text--PACKT-">MemProf</code> uses<a id="_idIndexMarker427"/> this method.</li>
			</ul>
			<div>
				<div id="_idContainer061" class="note">
					<p class="Information-Box--PACKT-"><strong class="bold">Note</strong>: </p>
					<p class="Information-Box--PACKT-">A <em class="italics">function interposition</em> is a wrapper function defined in a dynamic library loaded before the target dynamic library, which propagates calls to the target function. Dynamic libraries can be preloaded using t<a id="_idTextAnchor157"/>he <code class="Code-In-Text--PACKT-">LD_PRELOAD</code> environment variable.</p>
				</div>
			</div>
			<h2 id="_idParaDest-88" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor158"/>Heap memory principles</h2>
			<p class="normal">As pointed out before, Heap <a id="_idIndexMarker428"/>memory is different from Stack memory in several ways. Therefore, heap memory has its own guidelines regarding memory management. In this section, we are going to focus on these differences and come up with some dos and don'ts that we should consider when working with the Heap space.</p>
			<p class="normal">Every memory block (or a variable) in the Stack has a scope. So, it is an easy task to define the lifetime of a memory block based on its scope. Whenever we are out of scope, all of the variables in that scope are gone. But this is different and much more complex with Heap memory.</p>
			<p class="normal">A Heap memory block doesn't have any scope, so its lifetime is unclear and should be redefined. This is the reason behind having <a id="_idIndexMarker429"/>manual deallocation or <em class="italics">generational</em> <em class="italics">garbage collection</em> in modern languages such as Java. The Heap lifetime cannot be determined by the program itself or the C libraries used, and the programmer is the sole person who defines the lifetime of a Heap memory block.</p>
			<p class="normal">When the discussion comes to the programmer's decision, especially in this case, it is complicated and hard to<a id="_idIndexMarker430"/> propose a universal silver bullet solution. Every opinion is debatable and can lead to a trade-off.</p>
			<p class="normal">One of the best proposed strategies to overcome the complexity of the Heap lifetime, which of course is not a complete solution, is to define an <em class="italics">owner</em> for a memory block instead of having a scope that encompasses the memory block. </p>
			<p class="normal">The owner is the sole entity responsible for managing the lifetime of a Heap memory block and is the one who allocates the block in the first place and frees it when the block is not needed anymore.</p>
			<p class="normal">There are many classic examples of how to use this strategy. Most of the well-known C libraries use this strategy to handle their Heap memory allocations. <em class="italics">Example 5.5</em> is a very simple implementation of this method that is used to manage the lifetime of a queue object written in C. The following code<a id="_idIndexMarker431"/> box tries to demonstrate the <em class="italics">ownership</em> strategy:</p>
			<p class="snippet code">#include &lt;stdio.h&gt; // For printf function</p>
			<p class="snippet code">#include &lt;stdlib.h&gt; // For heap memory functions</p>
			<p class="snippet code">#define QUEUE_MAX_SIZE 100</p>
			<p class="snippet code">typedef struct {</p>
			<p class="snippet code">  int front;</p>
			<p class="snippet code">  int rear;</p>
			<p class="snippet code">  double* arr;</p>
			<p class="snippet code">} queue_t;</p>
			<p class="snippet code">void init(queue_t* q) {</p>
			<p class="snippet code">  q-&gt;front = q-&gt;rear = 0;</p>
			<p class="snippet code">  // The heap memory block allocated here is owned</p>
			<p class="snippet code">  // by the queue object.</p>
			<p class="snippet code">  q-&gt;arr = (double*)malloc(QUEUE_MAX_SIZE * sizeof(double));</p>
			<p class="snippet code">}</p>
			<p class="snippet code">void destroy(queue_t* q) {</p>
			<p class="snippet code">  free(q-&gt;arr);</p>
			<p class="snippet code">}</p>
			<p class="snippet code">int size(queue_t* q) {</p>
			<p class="snippet code">  return q-&gt;rear - q-&gt;front;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">void enqueue(queue_t* q, double item) {</p>
			<p class="snippet code">  q-&gt;arr[q-&gt;rear] = item;</p>
			<p class="snippet code">  q-&gt;rear++;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">double dequeue(queue_t* q) {</p>
			<p class="snippet code">  double item = q-&gt;arr[q-&gt;front];</p>
			<p class="snippet code">  q-&gt;front++;</p>
			<p class="snippet code">  return item;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  // The heap memory block allocated here is owned</p>
			<p class="snippet code">  // by the function main</p>
			<p class="snippet code">  queue_t* q = (queue_t*)malloc(sizeof(queue_t));</p>
			<p class="snippet code">  // Allocate needed memory for the queue object</p>
			<p class="snippet code">  init(q);</p>
			<p class="snippet code">  enqueue(q, 6.5);</p>
			<p class="snippet code">  enqueue(q, 1.3);</p>
			<p class="snippet code">  enqueue(q, 2.4);</p>
			<p class="snippet code">  printf("%f\n", dequeue(q));</p>
			<p class="snippet code">  printf("%f\n", dequeue(q));</p>
			<p class="snippet code">  printf("%f\n", dequeue(q));</p>
			<p class="snippet code">  // Release resources acquired by the queue object</p>
			<p class="snippet code">  destroy(q);</p>
			<p class="snippet code">  // Free the memory allocated for the queue object</p>
			<p class="snippet code">  // acquired by the function main</p>
			<p class="snippet code">  free(q);</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 5-11 [ExtremeC_examples_chapter5_5.c]: The example 5.5 demonstrating the ownership strategy for Heap lifetime management</p>
			<p class="normal">The preceding example contains two different ownerships each of which owning a specific object. The first ownership is about the Heap memory block addressed by the <code class="Code-In-Text--PACKT-">arr</code> pointer in the <code class="Code-In-Text--PACKT-">queue_t</code> structure that is owned by the queue object. As long as the queue object exists, this memory block must remain in place and allocated.</p>
			<p class="normal">The second ownership is<a id="_idIndexMarker432"/> regarding the Heap memory block acquired by the <code class="Code-In-Text--PACKT-">main</code> function as a placeholder for the queue object, <code class="Code-In-Text--PACKT-">q</code>, that is owned by the <code class="Code-In-Text--PACKT-">main</code> function itself. It is very important to distinguish between the Heap memory blocks owned by the queue object and the Heap memory blocks owned by the <code class="Code-In-Text--PACKT-">main</code> function because releasing one of them doesn't release another.</p>
			<p class="normal">To demonstrate how a memory leak can happen in the preceding code, suppose that you forget to call the <code class="Code-In-Text--PACKT-">destroy</code> function on the queue object. It will definitely lead to a memory leak because the Heap memory block acquired inside the <code class="Code-In-Text--PACKT-">init</code> function would be still allocated and not freed.</p>
			<p class="normal">Note that if an entity (an object, function, and so on) owns a Heap memory block, it should be expressed in the comments. Nothing should free a Heap memory block if it does not own the block. </p>
			<p class="normal">Note that multiple deallocations of the same Heap memory block will lead to a <em class="italics">double free</em> situation. A <a id="_idIndexMarker433"/>double-free situation is a memory corruption issue and like any other memory corruption issue, it should be dealt with and resolved soon after detection. Otherwise, it can have serious consequences like sudden crashes.</p>
			<p class="normal">Other than the ownership strategy, one could use a garbage collector. The garbage collector is an automatic mechanism that is embedded in a program and tries to collect memory blocks that have no pointer <a id="_idIndexMarker434"/>addressing them. One of the old well-known garbage collectors for C is the <em class="italics">Boehm-Demers-Weiser Conservative Garbage Collector</em>, which provides a set of memory allocation functions that should be called instead of <code class="Code-In-Text--PACKT-">malloc</code> and other standard C memory allocation functions.</p>
			<div>
				<div id="_idContainer062" class="note">
					<p class="Information-Box--PACKT-"><strong class="bold">Further Reading</strong>: </p>
					<p class="Information-Box--PACKT-">More informatio<a href="http://www.hboehm.info/gc/">n about the Boehm-Demers-Weise</a>r garbage collector can be found here: <a href="http://www.hboehm.info/gc/"><span class="url">http://www.hboehm.info/gc/</span></a>.</p>
				</div>
			</div>
			<p class="normal">Another technique to<a id="_idIndexMarker435"/> manage the lifetime of a Heap block is<a id="_idIndexMarker436"/> using a RAII object. <strong class="bold">RAII</strong> stands for <strong class="bold">Resource Acquisition Is Initialization</strong>. It means that we can bind the lifetime of a resource, possibly a Heap allocated memory block, to the lifetime of an object. In other words, we use an object that upon its construction initializes the resource, and upon its destruction frees the resource. Unfortunately, this technique cannot be used in C because we are not notified about the destruction of an object. But in C++, using destructors, this technique can be used effectively. In RAII objects, resource initialization happens in the constructor and the code required to de-initialize the resource is put into the destructor. Note that in C++, the destructor is invoked automatically when an object is going out of scope or being deleted.</p>
			<p class="normal">As a conclusion, the following guidelines are important when working with Heap memory:</p>
			<ul>
				<li class="list">Heap memory allocation<a id="_idIndexMarker437"/> is not free, and it has its own costs. Not all memory allocation functions have the same cost and, usually, <code class="Code-In-Text--PACKT-">malloc</code> is the cheapest one.</li>
				<li class="list">All memory blocks allocated from the Heap space must be freed either immediately when they are not needed anymore or just before ending the program.</li>
				<li class="list">Since Heap memory<a id="_idIndexMarker438"/> blocks have no scope, the program must be able to manage the memory in order to avoid any possible leakage.</li>
				<li class="list">Sticking to a chosen memory management strategy for each Heap memory block seems to be necessary.</li>
				<li class="list">The chosen strategy and its assumptions should be documented throughout the code wherever the block is accessed so that future programmers will know about it.</li>
				<li class="list">In certain programming languages like C++, we can use RAII objects to manage a resource, possibly a Heap memory block.</li>
			</ul>
			<p class="normal">So far, we have considered that we have enough memory to store big objects and run any kind of program. But in the following section, we are going to put some constraints on the available memory and discuss the environments where the memory is low, or it is costly (in terms of money, time, performance, and so on) to add further memory storage. In such cases, we need to use the available memory in <a id="_idTextAnchor159"/>the most efficient way.</p>
			<h1 id="_idParaDest-89" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor160"/>Memory management in constrained environments</h1>
			<p class="normal">There are environments in which memory is a precious resource, and it is often limited. There are also other environments in which<a id="_idIndexMarker439"/> performance is a key factor and programs should be fast, no matter how much memory we have. Regarding memory management, each of these environments requires a specific technique to overcome the memory shortage and performance degradation. First, we need to know what a constrained environment is.</p>
			<p class="normal">A constrained environment does not necessarily have a low memory capacity. There are usually some <em class="italics">constraints</em> that limit the memory usage for a program. These<a id="_idIndexMarker440"/> constraints can be your customer's hard limits regarding memory usage, or it could be because of a hardware that provides the low memory capacity, or it can be because of an operating system that does not support a bigger memory (for example, MS-DOS).</p>
			<p class="normal">Even if there are no constraints or hardware limitations, we as programmers try our best to use the least possible amount of memory and use it in an optimal way. Memory consumption is one of the key <em class="italics">non-functional requirements</em> in a project and should be monitored and tuned carefully.</p>
			<p class="normal">In this section, we'll first introduce the techniques used in low memory environments for overcoming the shortage issue, and then we will talk about the memory techniques usually used in performant environments in order to boost t<a id="_idTextAnchor161"/>he performance of the running programs.</p>
			<h2 id="_idParaDest-90" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor162"/>Memory-constrained environments</h2>
			<p class="normal">In these environments, limited<a id="_idIndexMarker441"/> memory is always a constraint, and algorithms should be designed in a way in order to cope with memory shortages. Embedded systems with a memory size of tens to hundreds of megabytes are usually in this category. There are a few tips about memory management in such environments, but none of them work as well as having a nicely tuned algorithm. In this case, algorithms with a low memory complexity are usually used. These algorithms usually have a higher <em class="italics">time complexity</em>, which should be traded off with their low memory usage.</p>
			<p class="normal">To elaborate more on this, every algorithm has specific <em class="italics">time</em> and <em class="italics">memory</em> complexities. Time complexity describes the relationship between the input size and the time that the algorithm takes to complete. Similarly, memory complexity describes the relationship between the input size and the memory that the algorithm consumes to complete its task. These complexities are <a id="_idIndexMarker442"/>usually denoted as <em class="italics">Big-O functions</em>, which we don't want to deal with in this section. Our discussion is qualitative, so we don't need any math to talk about memory-constrained environments.</p>
			<p class="normal">An algorithm should ideally have a low time complexity and also a low memory complexity. In other words, having a fast algorithm consuming a low amount of memory is highly desirable, but it is unusual to have this "best of both worlds" situation. It is also unexpected to have an algorithm with high memory consumption while not performing well</p>
			<p class="normal">Most of the time, we<a id="_idIndexMarker443"/> have a trade-off between memory and speed, which represents time. As an example, a sorting algorithm that is faster than another algorithm usually consumes more memory than the other, despite the fact that both of them do the same job.</p>
			<p class="normal">It is a good but conservative practice, especially when writing a program, to assume that we are writing code for a memory-constrained system, even if we know that we will have more than enough memory in the final production environment. We make this assumption because we want to mitigate the risk of having too much memory consumption.</p>
			<p class="normal">Note that the driving force behind this assumption should be controlled and adjusted based on a fairly accurate guess about the average memory availability, in terms of size, as part of the final setup. Algorithms designed for memory-constrained environments are intrinsically slower, and you should be careful about this trap.</p>
			<p class="normal">In the upcoming sections, we will cover some techniques that can help us to collect some wasted memory o<a id="_idTextAnchor163"/>r to use less memory in memory-constrained environments.</p>
			<h3 id="_idParaDest-91" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor164"/>Packed structures</h3>
			<p class="normal">One of the easiest ways to use less <a id="_idIndexMarker444"/>memory is to use packed structures. Packed structures discard the memory alignment and they have a more compact memory layout for storing their fields.</p>
			<p class="normal">Using packed structures is actually a trade-off. You consume less memory because you discard memory alignments and eventually end up with more memory read time while loading a structure variable. This will result in a slower program.</p>
			<p class="normal">This method is simple but not recommended for all programs. For more information regarding this method, you can read<a id="_idTextAnchor165"/> the <em class="italics">Structures</em> section found in <em class="italics">Chapter 1</em>, <em class="italics">Essential Features</em>.</p>
			<h3 id="_idParaDest-92" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor166"/>Compression</h3>
			<p class="normal">This is an effective technique, especially for programs working with a lot of textual data that should be kept inside the <a id="_idIndexMarker445"/>memory. Textual data has a high <em class="italics">compression ratio</em> in comparison to binary data. This technique allows a program to store the compressed form instead of the actual text data with a huge memory return.</p>
			<p class="normal">However, saving memory is not free; since compression algorithms are <em class="italics">CPU-bound</em> and computation-intensive, the program would have worse performance in the end. This method is ideal for programs that keep textual data that is not required often; otherwise, a lot of compression/decompression operations are needed<a id="_idTextAnchor167"/>, and the program would be almost unusable eventually.</p>
			<h3 id="_idParaDest-93" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor168"/>External data storage</h3>
			<p class="normal">Using external data storage<a id="_idIndexMarker446"/> in the forms of a network service, a cloud infrastructure, or simply a hard drive is a very common and useful technique for resolving low memory issues. Since it is usually considered that a program might be run in a limited or low memory environment, there are a lot of examples that use this method to be able to consume less memory even in environments in which enough memory is available.</p>
			<p class="normal">This technique usually assumes that memory is not the main storage, but it acts as <em class="italics">cache</em> memory. Another assumption is that we cannot keep the whole data in the memory and at any moment, only a portion of data or a <em class="italics">page</em> of data can be loaded into the memory.</p>
			<p class="normal">These algorithms are not directly addressing the low memory problem, but they are trying to solve another issue: slow external data storage. External data storage is always too slow in comparison to the main memory. So, the algorithms should balance the reads from the external data store and their internal memory. All database services, such as PostgreSQL and Oracle, use this technique.</p>
			<p class="normal">In most projects, it is<a id="_idIndexMarker447"/> not very wise to design and write these algorithms from scratch because these algorithms are not that trivial and simple to write. The teams behind famous libraries such as SQLite have been fixing bugs for years. </p>
			<p class="normal">If you need to access an external data storage such as a file, a database, or a host on the network while having a low memory <a id="_idTextAnchor169"/>footprint, there are always options out there for you.</p>
			<h2 id="_idParaDest-94" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor170"/>Performant environments</h2>
			<p class="normal">As we have explained in<a id="_idIndexMarker448"/> the previous sections about the time and memory complexities of an algorithm, it is usually expected to consume more memory when you want to have a faster algorithm. In this section, we therefore expect to consume more memory for the sake of increased performance.</p>
			<p class="normal">An intuitive example of this statement can be using a cache in order to increase the performance. Caching data means consuming more memory, but we could expect to get better performance if the cache is used properly.</p>
			<p class="normal">But adding extra memory is not always the best way to increase performance. There are other methods that are directly or indirectly related to memory and can have a substantial impact on the performance of an algo<a id="_idTextAnchor171"/>rithm. Before jumping to these methods, let's talk about caching first.</p>
			<h3 id="_idParaDest-95" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor172"/>Caching</h3>
			<p class="normal">Caching is a general term for all <a id="_idIndexMarker449"/>similar techniques utilized in many parts of a computer system when two data storages with different read/write speeds are involved. For example, the CPU has a number of internal registers that perform quickly in terms of reading and writing operations. In addition, the CPU has to fetch data from the main memory, which is many times slower than its registers. A caching mechanism is needed here; otherwise, the lower speed of the main memory becomes dominant, and it hides the high computational speed of the CPU.</p>
			<p class="normal">Working with database files is another example. Database files are usually stored on an external hard disk, which is far slower than the main memory, by orders of magnitude. Definitely, a caching mechanism is required here; otherwise, the slowest speed becomes dominant, and it determines the speed of the whole system.</p>
			<p class="normal">Caching and the details around it deserve to have a whole dedicated chapter since there are abstract models and specific terminology that should be explained. </p>
			<p class="normal">Using these models, one can predict how well a cache would behave and how much <em class="italics">performance gain</em> could be expected after introducing the cache. Here, we try to explain caching in a simple and intuitive manner.</p>
			<p class="normal">Suppose that you have slow storage that can contain many items. You also have another fast storage, but it can contain a limited number of items. This is an obvious tradeoff. We can call the faster but smaller storage a <em class="italics">cache</em>. It would be reasonable if you bring items from the slow storage into the fast one and process them on the fast storage, simply because it is faster.</p>
			<p class="normal">From time to time, you have to go to slow storage in order to bring over more items. It is obvious that you won't bring only one item over from the slow storage, as this would be very inefficient. Rather, you will bring a <em class="italics">bucket</em> of items into the faster storage. Usually, it is said that the items are cached into the faster storage.</p>
			<p class="normal">Suppose that you are processing an item that requires you to load some other item from the slow storage. The first thing that comes to mind is to search for the required item inside the recently brought bucket, which is in the cache storage at the moment.</p>
			<p class="normal">If you could find<a id="_idIndexMarker450"/> the item in the cache, there is no need to retrieve it from the slow storage, and<a id="_idIndexMarker451"/> this is called a <em class="italics">hit</em>. If the item is missing from the cache storage, you have to go to the slow storage and read another bucket of items into the cache <a id="_idIndexMarker452"/>memory. This is called a <em class="italics">miss</em>. It is clear that the more hits you observe, the more performance you get.</p>
			<p class="normal">The preceding description can be applied to the CPU cache and the main memory. The CPU cache stores recent instructions and data read from the main memory, and the main memory is slow compared to the CPU cache memory.</p>
			<p class="normal">In the following section, we discuss cache-friendly code, and we <a id="_idTextAnchor173"/>observe why cache-friendly code can be executed faster by the CPU.</p>
			<h4 class="title" lang="en-GB" xml:lang="en-GB">Cache-friendly code</h4>
			<p class="normal">When the CPU is executing <a id="_idIndexMarker453"/>an instruction, it has to fetch all required data first. The data is located in the main memory at a specific address that is determined by the instruction.</p>
			<p class="normal">The data has to be transferred to the CPU registers before any computation. But the CPU usually brings more blocks than are expected to be fetched and puts them inside its cache.</p>
			<p class="normal">Next time, if a value is needed in the <em class="italics">proximity</em> of the previous address, it should exist in the cache, and the CPU can use the cache instead of the main memory, which is far faster than reading it from the main memory. As we explained in the previous section, this is a <em class="italics">cache hit</em>. If the address is <a id="_idIndexMarker454"/>not found in the CPU cache, it is a <em class="italics">cache miss</em>, and the CPU has to <a id="_idIndexMarker455"/>access the main memory to read the target address and bring required data which is quite slow. In general, higher hit rates result in faster executions.</p>
			<p class="normal">But why does the CPU fetch the neighboring addresses (the proximity) around an address? It is because of the <em class="italics">principle of locality</em>. In computer systems, it is usually observed that the data located in the same neighborhood is more frequently accessed. So, the CPU behaves according to this principle and brings more data from a local reference. If an algorithm can exploit this behavior, it can be executed faster by the CPU. This is why we refer to such<a id="_idIndexMarker456"/> algorithm as a <em class="italics">cache-friendly</em> algorithm.</p>
			<p class="normal"><em class="italics">Example 5.6</em> demonstrates the difference between the performances of cache-friendly code and non-cache-friendly code:</p>
			<p class="snippet code">#include &lt;stdio.h&gt;  // For printf function</p>
			<p class="snippet code">#include &lt;stdlib.h&gt; // For heap memory functions</p>
			<p class="snippet code">#include &lt;string.h&gt; // For strcmp function</p>
			<p class="snippet code">void fill(int* matrix, int rows, int columns) {</p>
			<p class="snippet code">  int counter = 1;</p>
			<p class="snippet code">  for (int i = 0; i &lt; rows; i++) {</p>
			<p class="snippet code">    for (int j = 0; j &lt; columns; j++) {</p>
			<p class="snippet code">      *(matrix + i * columns + j) = counter;</p>
			<p class="snippet code">    }</p>
			<p class="snippet code">    counter++;</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">}</p>
			<p class="snippet code">void print_matrix(int* matrix, int rows, int columns) {</p>
			<p class="snippet code">  int counter = 1;</p>
			<p class="snippet code">  printf("Matrix:\n");</p>
			<p class="snippet code">  for (int i = 0; i &lt; rows; i++) {</p>
			<p class="snippet code">    for (int j = 0; j &lt; columns; j++) {</p>
			<p class="snippet code">      printf("%d ", *(matrix + i * columns + j));</p>
			<p class="snippet code">    }</p>
			<p class="snippet code">    printf("\n");</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">}</p>
			<p class="snippet code">void print_flat(int* matrix, int rows, int columns) {</p>
			<p class="snippet code">  printf("Flat matrix: ");</p>
			<p class="snippet code">  for (int i = 0; i &lt; (rows * columns); i++) {</p>
			<p class="snippet code">    printf("%d ", *(matrix + i));</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  printf("\n");</p>
			<p class="snippet code">}</p>
			<p class="snippet code">int friendly_sum(int* matrix, int rows, int columns) {</p>
			<p class="snippet code">  int sum = 0;</p>
			<p class="snippet code">  for (int i = 0; i &lt; rows; i++) {</p>
			<p class="snippet code">    for (int j = 0; j &lt; columns; j++) {</p>
			<p class="snippet code">      sum += *(matrix + i * columns + j);</p>
			<p class="snippet code">    }</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  return sum;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">int not_friendly_sum(int* matrix, int rows, int columns) {</p>
			<p class="snippet code">  int sum = 0;</p>
			<p class="snippet code">  for (int j = 0; j &lt; columns; j++) {</p>
			<p class="snippet code">    for (int i = 0; i &lt; rows; i++) {</p>
			<p class="snippet code">      sum += *(matrix + i * columns + j);</p>
			<p class="snippet code">    }</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  return sum;</p>
			<p class="snippet code">}</p>
			<p class="snippet code">int main(int argc, char** argv) {</p>
			<p class="snippet code">  if (argc &lt; 4) {</p>
			<p class="snippet code">    printf("Usage: %s [print|friendly-sum|not-friendly-sum] ");</p>
			<p class="snippet code">    printf("[number-of-rows] [number-of-columns]\n", argv[0]);</p>
			<p class="snippet code">    exit(1);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  char* operation = argv[1];</p>
			<p class="snippet code">  int rows = atol(argv[2]);</p>
			<p class="snippet code">  int columns = atol(argv[3]);</p>
			<p class="snippet code">  int* matrix = (int*)malloc(rows * columns * sizeof(int));</p>
			<p class="snippet code">  fill(matrix, rows, columns);</p>
			<p class="snippet code">  if (strcmp(operation, "print") == 0) {</p>
			<p class="snippet code">    print_matrix(matrix, rows, columns);</p>
			<p class="snippet code">    print_flat(matrix, rows, columns);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  else if (strcmp(operation, "friendly-sum") == 0) {</p>
			<p class="snippet code">    int sum = friendly_sum(matrix, rows, columns);</p>
			<p class="snippet code">    printf("Friendly sum: %d\n", sum);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  else if (strcmp(operation, "not-friendly-sum") == 0) {</p>
			<p class="snippet code">    int sum = not_friendly_sum(matrix, rows, columns);</p>
			<p class="snippet code">    printf("Not friendly sum: %d\n", sum);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  else {</p>
			<p class="snippet code">    printf("FATAL: Not supported operation!\n");</p>
			<p class="snippet code">    exit(1);</p>
			<p class="snippet code">  }</p>
			<p class="snippet code">  free(matrix);</p>
			<p class="snippet code">  return 0;</p>
			<p class="snippet code">}</p>
			<p class="packt_figref">Code Box 5-12 [ExtremeC_examples_chapter5_6.c]: Example 5.6 demonstrates the performance of cache-friendly code and non-cache-friendly code</p>
			<p class="normal">The preceding program computes and prints the sum of all elements in a matrix, but it also does more than that. </p>
			<p class="normal">The<a id="_idIndexMarker457"/> user can pass options to this program, which alters its behavior. Suppose that we want to print a 2 by 3 matrix that is initialized by an algorithm written in the <code class="Code-In-Text--PACKT-">fill</code> function. The user has to pass the <code class="Code-In-Text--PACKT-">print</code> option with the desired number of rows and columns. Next, you can see how these options are passed to the final executable binary:</p>
			<p class="snippet shell"><strong class="highlight">$ gcc ExtremeC_examples_chapter5_6.c -o ex5_6.out</strong></p>
			<p class="snippet shell"><strong class="highlight">$ ./ex5_6.out print 2 3</strong></p>
			<p class="snippet shell">Matrix:</p>
			<p class="snippet shell">1 1 1</p>
			<p class="snippet shell">2 2 2</p>
			<p class="snippet shell">Flat matrix: 1 1 1 2 2 2</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 5-21: Output of example 5.6 showing a 2 by 3 matrix</p>
			<p class="normal">The output consists of two different prints for the matrix. The first is the 2D representation of the matrix and the second is the <em class="italics">flat</em> representation of the same matrix. As you can see, the matrix is stored as a <em class="italics">row-major order</em> in memory. This means that we store it row by row. So, if something from a row is fetched by the CPU, it is probable that all of the elements in that row are fetched too. Hence, it would be better to do our summation in row-major order and not <em class="italics">column-major</em> order.</p>
			<p class="normal">If you look at the code again, you can see that the summation done in the <code class="Code-In-Text--PACKT-">friendly_sum</code> function is row-major, and the summation performed in the <code class="Code-In-Text--PACKT-">not_friendly_sum</code> function is column-major. Next, we can compare the time it takes to perform the summation of a matrix with 20,000 rows and 20,000 columns. As you can see, the difference is very clear:</p>
			<p class="snippet shell"><strong class="highlight">$ time ./ex5_6.out friendly-sum 20000 20000</strong></p>
			<p class="snippet shell">Friendly sum: 1585447424</p>
			<p class="snippet shell">real   0m5.192s</p>
			<p class="snippet shell">user   0m3.142s</p>
			<p class="snippet shell">sys    0m1.765s</p>
			<p class="snippet shell"><strong class="highlight">$ time ./ex5_6.out not-friendly-sum 20000 20000</strong></p>
			<p class="snippet shell">Not friendly sum: 1585447424</p>
			<p class="snippet shell">real   0m15.372s</p>
			<p class="snippet shell">user   0m14.031s</p>
			<p class="snippet shell">sys    0m0.791s</p>
			<p class="snippet shell"><strong class="highlight">$</strong></p>
			<p class="packt_figref">Shell Box 5-22: Demonstration of the time difference between the column-major and row-major matrix summation algorithms</p>
			<p class="normal">The difference between the<a id="_idIndexMarker458"/> measured times is about 10 seconds! The program is compiled on a macOS machine using the <code class="Code-In-Text--PACKT-">clang</code> compiler. The difference means that the same logic, using the same amount of memory, can take much longer – just by selecting a different order of accessing the matrix elements! This example clearly shows the effect of cache-friendly code.</p>
			<div>
				<div id="_idContainer063" class="note">
					<p class="Information-Box--PACKT-"><strong class="bold">Note</strong>: </p>
					<p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">time</code> utility is available<a id="_idIndexMarker459"/> in all Unix-like operating systems. It can be used to measure the time a program takes to finish.</p>
				</div>
			</div>
			<p class="normal">Before continuing to the next technique, we should ta<a id="_idTextAnchor174"/>lk a bit more about the allocation and deallocation cost.</p>
			<h3 id="_idParaDest-96" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor175"/>Allocation and deallocation cost</h3>
			<p class="normal">Here, we want to specifically talk about the cost of Heap memory allocation and deallocation. This might be a bit of a surprise if you realize that Heap memory allocation and deallocation operations are time-and memory-consuming and are usually expensive, especially when <a id="_idIndexMarker460"/>you need to allocate and deallocate Heap memory blocks many times per second.</p>
			<p class="normal">Unlike Stack allocation, which is relatively fast and the allocation itself requires no further memory, Heap allocation requires finding a free block of memory with enough size, and this can be costly.</p>
			<p class="normal">There are many algorithms designed for memory allocation and deallocation, and there is always a tradeoff between the allocation and deallocation operations. If you want to allocate quickly, you have to consume more memory as part of the allocation algorithm and vice versa if you want to consume less memory you can choose to spend more time with a slower allocation.</p>
			<p class="normal">There are memory allocators for C other than those provided by the default C standard library through the <code class="Code-In-Text--PACKT-">malloc</code> and <code class="Code-In-Text--PACKT-">free</code> functions. Some of these memory allocator libraries are <code class="Code-In-Text--PACKT-">ptmalloc</code>, <code class="Code-In-Text--PACKT-">tcmalloc</code>, <code class="Code-In-Text--PACKT-">Haord</code>, and <code class="Code-In-Text--PACKT-">dlmalloc</code>. </p>
			<p class="normal">Going through all allocators here is beyond the scope of this chapter, but it would be good practice for you to go through them and give them a try for yourself.</p>
			<p class="normal">What is the solution to this silent problem? It is simple: allocate and deallocate less frequently. This<a id="_idIndexMarker461"/> may seem impossible in some programs that are required to have a high rate of Heap allocations. These programs usually allocate a big block of the Heap memory and try to manage it themselves. It is like having another layer of allocation and deallocation logic (maybe simpler than implementations of <code class="Code-In-Text--PACKT-">malloc</code> and <code class="Code-In-Text--PACKT-">free</code>) on top of a big block of the Heap memory.</p>
			<p class="normal">There is also <a id="_idIndexMarker462"/>another method, which is using <em class="italics">memory pools</em>.<a id="_idTextAnchor176"/> We'll briefly explain this technique before we come to the end of this chapter.</p>
			<h3 id="_idParaDest-97" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor177"/>Memory pools</h3>
			<p class="normal">As we described in the <a id="_idIndexMarker463"/>previous section, memory allocation and deallocation are costly. Using a pool of preallocated fixed-size Heap memory blocks is an effective way to reduce the number of allocations and gain some performance. Each block in the pool usually has an identifier, which can be acquired through an API designed for pool management. Also, the block can be released later when it is not needed. Since the amount of allocated memory remains almost fixed, it is an excellent choice for algorithms willing to have deterministic behavior in memory-constrained environments.</p>
			<p class="normal">Describing memory pools in further detail is beyond the scope of this book; many useful resources on this topic exist online if you wish to read more about it.</p>
			<h1 id="_idParaDest-98" class="title" lang="en-GB" xml:lang="en-GB"><a id="_idTextAnchor178"/>Summary</h1>
			<p class="normal">As part of this chapter, we mainly covered the Stack and Heap segments and the way they should be used. After that, we briefly discussed memory-constrained environments and we saw how techniques like caching and memory pools can increase the performance.</p>
			<p class="normal">In this chapter:</p>
			<ul>
				<li class="list">We discussed the tools and techniques used for probing both Stack and Heap segments.</li>
				<li class="list">We introduced debuggers and we used <code class="Code-In-Text--PACKT-">gdb</code> as our main debugger to troubleshoot memory-related issues.</li>
				<li class="list">We discussed memory profilers and we used <code class="Code-In-Text--PACKT-">valgrind</code> to find memory issues such as leakages or dangling pointers happening at runtime.</li>
				<li class="list">We compared the lifetime of a Stack variable and a Heap block and we explained how we should judge the lifetime of such memory blocks.</li>
				<li class="list">We saw that memory management is automatic regarding Stack variables, but it is fully manual with Heap blocks.</li>
				<li class="list">We went through the common mistakes that happen when dealing with Stack variables.</li>
				<li class="list">We discussed the constrained environments and we saw how memory tuning can be done in these environments.</li>
				<li class="list">We discussed the performant environments and what techniques can be used to gain some performance.</li>
			</ul>
			<p class="normal">The next four chapters together cover object orientation in C. This might at first glance seem to be unrelated to C, but in fact, this is the correct way to write object-oriented code in C. As part of these chapters, you will be introduced to the proper way of designing and solving a problem in an object-orie<a id="_idTextAnchor179"/>nted fashion, and you will get guidance through writing readable and correct C code.</p>
			<p class="normal">The next chapter covers encapsulation and the basics of object-oriented programming by providing the <a id="_idTextAnchor180"/>required theoretical discussion and examples to explore the topics discussed.</p>
		</div>
</body></html>