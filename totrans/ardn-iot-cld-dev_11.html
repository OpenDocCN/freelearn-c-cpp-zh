<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-229"><a id="_idTextAnchor229"/>11</h1>
<h1 id="_idParaDest-230"><a id="_idTextAnchor230"/>Implementing the Arduino IoT Cloud Scheduler and Over-the-Air Features</h1>
<p>The world is full of different and interesting use cases that vary according to different circumstances. In the world of full automation, many use cases require applications to perform a specific operation<a id="_idIndexMarker878"/> at a certain time or frequency, defined by an end user. To handle this situation, the <strong class="bold">Arduino IoT Cloud</strong> has a <strong class="bold">Scheduler</strong> feature to let end users configure<a id="_idIndexMarker879"/> the execution time and frequency through a dashboard, without any modification to code on end devices. Initially, in this chapter, you will learn about the Arduino IoT Cloud Scheduler feature and its implementation.</p>
<p>Then, this chapter will cover the <strong class="bold">Over-the-Air</strong> (<strong class="bold">OTA</strong>) feature, which is becoming increasingly popular in remote<a id="_idIndexMarker880"/> devices such as mobile nodes, especially remote IoT nodes. The OTA feature allows you to broadcast the firmware update to IoT nodes, which will update wirelessly without any physical connection. This procedure enables the remote maintenance of commercial Arduino-based/ESP-series IoT nodes during their life cycle, reducing the related service costs when new features and security fixes become available.</p>
<p>The Arduino IoT Cloud Scheduler provides the ability to schedule operations via a dashboard widget, which helps to execute the operations on devices without modifying the code, and a user can simply adjust the time for routine operations. OTA helps you to send the latest code and updates to devices over the air without any physical connection to a device, which will save operational costs and time.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The importance of the Scheduler in IoT</li>
<li>Using the Arduino IoT Cloud Scheduler – an MKR Wi-Fi 1010 illustration</li>
<li>Initial configuration – Things, network credentials, cloud variables, and code</li>
<li>Dashboard creation and a deep dive into the Scheduler widget</li>
<li>The task at hand – an assignment</li>
<li>Exploring OTA updates in IoT</li>
<li>Leveraging the Arduino IoT Cloud for OTA updates</li>
</ul>
<h1 id="_idParaDest-231"><a id="_idTextAnchor231"/>Technical requirements</h1>
<p>Before we go any further, first of all, you need to have an Arduino IoT Cloud-compatible board. I recommend Arduino <strong class="bold">MKR Wi-Fi 1010</strong> with a bunch of 5 mm LEDs, but here is the complete list of compatible boards: <a href="https://store-usa.arduino.cc/pages/cloud-compatible-boards">https://store-usa.arduino.cc/pages/cloud-compatible-boards</a>. You can choose one according to your requirements.</p>
<p>Second, you need to have an Arduino IoT Cloud account. If you don’t already have one, you can sign up at <a href="https://cloud.arduino.cc/">https://cloud.arduino.cc/</a> and select a plan according to your requirements.</p>
<p>Third, we need to download and install the <strong class="bold">Arduino Create Agent</strong>. Arduino has created a very beautiful web-based guide for installation at <a href="https://create.arduino.cc/getting-started/plugin/welcome">https://create.arduino.cc/getting-started/plugin/welcome</a>. The code for this chapter is available in the book’s official GitHub repository at <a href="https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers">https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers</a>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">All the Arduino IoT Cloud plans were discussed in detail in <a href="B19752_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>. You can also visit the following link for updated plan pricing and features: <a href="https://cloud.arduino.cc/plans/">https://cloud.arduino.cc/plans/</a>. If you are from an educational institute, then there are plenty of good plans for students and faculties. Arduino also offers customized plans to business organizations according to their requirements.</p>
<h1 id="_idParaDest-232"><a id="_idTextAnchor232"/>The importance of the Scheduler in IoT</h1>
<p>Within the realm of IoT and cloud computing, a scheduler<a id="_idIndexMarker881"/> refers to a component or system that is responsible for managing and controlling the timing and execution of tasks, processes, or events. Its primary function is to ensure the smooth and efficient operation of various activities within an IoT cloud setup. Here are some advantages<a id="_idIndexMarker882"/> of employing a scheduler<a id="_idIndexMarker883"/> in an IoT cloud environment:</p>
<ul>
<li><strong class="bold">Task coordination</strong>: The scheduler facilitates the orchestration of multiple tasks and processes in an IoT cloud by allowing users to define dependencies and priorities. This ensures that tasks are executed in the desired sequence, which is particularly crucial in complex IoT systems involving interconnected devices and services.</li>
<li><strong class="bold">Resource optimization</strong>: With the limited computational resources typically found in an IoT cloud, a scheduler optimizes its utilization by intelligently assigning tasks based on requirements, available resources, and priorities. This prevents resource overloading or underutilization, leading to enhanced efficiency and cost-effectiveness.</li>
<li><strong class="bold">Time synchronization</strong>: Achieving synchronized timing for specific operations or events is critical in IoT systems. The scheduler aids in time synchronization by coordinating task execution according to precise timing requirements. This synchronization guarantees that devices, sensors, and services are triggered or activated at the intended moments, enabling accurate data collection, analysis, and decision-making.</li>
<li><strong class="bold">Energy efficiency</strong>: Many IoT devices operate on constrained battery power, making energy efficiency a vital concern. The scheduler optimizes task scheduling to minimize devices’ active time and maximize sleep or low-power mode, thereby conserving energy. This prolongs the battery life of IoT devices, reduces maintenance needs, and enhances overall system reliability.</li>
<li><strong class="bold">Fault tolerance</strong>: IoT systems are susceptible to failures and disruptions caused by network issues, device malfunctions, or service unavailability. By monitoring task statuses and detecting failures, the scheduler incorporates fault tolerance mechanisms. It automatically reschedules failed or interrupted tasks, ensuring operational continuity and reliability within the IoT cloud.</li>
</ul>
<p>Overall, a scheduler in an IoT cloud environment brings organization, efficiency, and reliability by coordinating tasks, optimizing resources, synchronizing time, conserving energy, ensuring fault tolerance, and supporting scalability. Its presence is instrumental in managing the complexities of IoT systems and maximizing their performance.</p>
<p>In this section, we have discussed in detail what a scheduler is and how we can benefit from it in product development. In the following section, we will take a look at how the Arduino IoT Cloud Scheduler benefits<a id="_idIndexMarker884"/> us in terms of real-world<a id="_idIndexMarker885"/> scenarios, and we will also learn how to implement the Arduino IoT Cloud Scheduler using MKR Wi-Fi 101.</p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor233"/>Using the Arduino IoT Cloud Scheduler – an MKR Wi-Fi 1010 illustration</h1>
<p>In this section, we will take a look at how the Arduino IoT Cloud Scheduler provides different benefits and when and where we require scheduler functionality. Later, we will implement a practical example of a Scheduler using MKR Wi-Fi 1010.</p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor234"/>The Arduino IoT Cloud Scheduler</h2>
<p>The <strong class="bold">Arduino IoT Cloud Scheduler</strong> is a feature integrated into the Arduino IoT Cloud platform that empowers<a id="_idIndexMarker886"/> users to schedule and automate actions and events for their connected Arduino devices. It provides a convenient way to define and manage the timing of various tasks and functions within IoT projects. Here are some key aspects and benefits<a id="_idIndexMarker887"/> of the Arduino IoT Cloud Scheduler:</p>
<ul>
<li><strong class="bold">Task scheduling</strong>: The Arduino IoT Cloud Scheduler allows users to schedule tasks and events on their Arduino devices. It enables the definition of specific timings, intervals, or triggers for actions such as data collection, device control, and sensor readings.</li>
<li><strong class="bold">Remote control</strong>: By leveraging the Scheduler, users can remotely trigger actions on their Arduino devices. This capability enables the control and automation of functions from any location, without the need for direct physical access to the devices. It enhances flexibility and enables the efficient remote management of IoT projects.</li>
<li><strong class="bold">Event-based triggers</strong>: The Scheduler supports event-based triggers, empowering users to automate actions based on specific events or conditions. For instance, tasks can be scheduled to execute when a particular sensor value surpasses a defined threshold or when an external event is detected.</li>
<li><strong class="bold">Time zone management</strong>: The Arduino IoT Cloud Scheduler handles time zone management, ensuring that tasks are executed according to the desired time zone. This functionality is particularly useful when operating across different time zones or serving users in diverse regions.</li>
<li><strong class="bold">Integration with IoT cloud services</strong>: The Scheduler seamlessly integrates with other features and services offered by the Arduino IoT Cloud platform. This includes data storage, visualization, and notification services. Users can combine scheduling with data logging, charting, and alerting to create comprehensive and cohesive IoT applications.</li>
<li><strong class="bold">Flexibility and customization</strong>: The Arduino IoT Cloud Scheduler provides a high degree of customization, enabling users to define complex schedules and conditions for their tasks. Users can specify the task frequency, duration, and intervals, and configure advanced<a id="_idIndexMarker888"/> parameters to align with their specific requirements.</li>
</ul>
<p>By harnessing the power of the Arduino IoT Cloud Scheduler, users can automate tasks, remotely control devices, and establish time-based or event-driven workflows for their Arduino-based IoT projects. This feature simplifies the management and coordination of actions across devices, elevating the functionality and efficiency of IoT applications.</p>
<p>In this section, we discussed how the Arduino IoT Cloud Scheduler provides a benefit to schedule our tasks. In the next section, we will implement a Scheduler using MKR Wi-Fi 1010.</p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor235"/>An MKR Wi-Fi 1010 example</h2>
<p>In this chapter, I will not do a complex<a id="_idIndexMarker889"/> project to demonstrate<a id="_idIndexMarker890"/> how we can use the Scheduler. Instead, we will use a simple MKR Wi-Fi 1010 with three 5 mm LEDs, and we will set up the system so that it will turn LEDs on or off after a specific time interval. This example will simplify the hardware complexity and help you understand how the Arduino IoT Cloud Scheduler works. <em class="italic">Figure 11</em><em class="italic">.1</em> shows how LEDs connect with the MKR Wi-Fi 1010 for this Scheduler example.</p>
<div><div><img alt="Figure 11.1 – The MKR Wi-Fi 1010 with LEDs" src="img/B19752_11_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – The MKR Wi-Fi 1010 with LEDs</p>
<p>Here, we will just use three LEDs for three different schedulers/timers. We used <em class="italic">Pins 8</em>, <em class="italic">7</em>, and <em class="italic">6</em> to attach the LEDs with the MKR Wi-Fi 1010, using a 220-Ohm resistance, which will control the power from these pins, and one common<strong class="bold"> ground</strong> (<strong class="bold">GND</strong>) goes to all the LEDs via the breadboard.</p>
<p>In this section, we discussed the schematic diagram of our project, where we explained which pins are used to connect the LEDs with the MKR Wi-Fi 1010. In the upcoming section, we will set up a Thing and device association with the Thing, and cloud variable creation and network configuration will be discussed step by step, along with code.</p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor236"/>Initial configuration – Things, network credentials, cloud variables, and code</h1>
<p>After setting up<a id="_idIndexMarker891"/> the hardware, it’s time to set up a Thing in the Arduino IoT Cloud. For this project, we need three cloud variables for the Scheduler, which will be linked with dashboard widgets and receive the values from users. Later, the device will perform an operation (in our example, it will turn the LEDs on and off according to a scheduler time) when the Scheduler is active. <em class="italic">Figure 11</em><em class="italic">.2</em> gives a complete<a id="_idIndexMarker892"/> overview of the <strong class="bold">Cloud </strong><strong class="bold">Scheduler</strong> Thing.</p>
<div><div><img alt="Figure 11.2 – The Cloud Scheduler Thing setup" src="img/B19752_11_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – The Cloud Scheduler Thing setup</p>
<p>Set up a new Thing with the name <code>CloudScheduler</code>. Take the following steps to create cloud variables, associate a device, set up network configuration, and finally, write the code. In <em class="italic">Figure 11</em><em class="italic">.2</em>, all the steps are marked with a number above red boxes, which relate to the following steps:</p>
<ol>
<li>Firstly, we need to set up three cloud variables for <code>CloudScheduler</code>. The complete details regarding cloud variables are available in the next section.</li>
<li>After that, we need to associate the device with the Thing. In the current project, we are using Arduino’s MKR Wi-Fi 1010, so the wizard will be the same for Arduino boards. The complete details are available in the <em class="italic">Associating a </em><em class="italic">device</em> section.</li>
<li>Finally, we need to set up the network configuration for the device. Arduino-compatible boards are configured by the Arduino IoT Cloud automatically during the device setup wizard, so you just<a id="_idIndexMarker893"/> need to provide the Wi-Fi <strong class="bold">service set identifier</strong> (<strong class="bold">SSID</strong>) and password.</li>
</ol>
<h2 id="_idParaDest-237"><a id="_idTextAnchor237"/>Cloud variables</h2>
<p>The following table explains<a id="_idIndexMarker894"/> all the properties of the variables that we need to use during cloud variable creation. For the Scheduler, we will use a custom data type, <code>Schedule</code>, which we have thanks to Arduino IoT Cloud’s extended group of variables. Then, make sure you have the same <code>declaration</code> variable as per the table; otherwise, you will need to modify the example code according to your naming.</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-7">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">S#</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Variable Name</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Variable Type</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Declaration</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Permission</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Update </strong><strong class="bold">Policy</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>1</p>
</td>
<td class="No-Table-Style">
<p><code>CloudScheduler1</code></p>
</td>
<td class="No-Table-Style">
<p><code>Schedule</code></p>
</td>
<td class="No-Table-Style">
<p><code>cloudScheduler1</code></p>
</td>
<td class="No-Table-Style">
<p>Read and write</p>
</td>
<td class="No-Table-Style">
<p>On change</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>2</p>
</td>
<td class="No-Table-Style">
<p><code>CloudScheduler2</code></p>
</td>
<td class="No-Table-Style">
<p><code>Schedule</code></p>
</td>
<td class="No-Table-Style">
<p><code>cloudScheduler2</code></p>
</td>
<td class="No-Table-Style">
<p>Read and write</p>
</td>
<td class="No-Table-Style">
<p>On change</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>3</p>
</td>
<td class="No-Table-Style">
<p><code>CloudScheduler3</code></p>
</td>
<td class="No-Table-Style">
<p><code>Schedule</code></p>
</td>
<td class="No-Table-Style">
<p><code>cloudScheduler3</code></p>
</td>
<td class="No-Table-Style">
<p>Read and write</p>
</td>
<td class="No-Table-Style">
<p>On change</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.1 – The cloud variables declaration list</p>
<p>Here, I set the permission as <em class="italic">read</em> and <em class="italic">write</em> because we will input the date, time, and interval from the Arduino dashboard, which will be controlled by the end user, and the device will only perform the LED on/off operation when the Scheduler is in a state of <code>true</code>. <strong class="bold">Update Policy</strong> is set to <strong class="bold">On change</strong>, as the dashboard will send data to the device when there is any change<a id="_idIndexMarker895"/> in Scheduler values by the user.</p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor238"/>Associating a device</h2>
<p>After creating the variable, it’s time to add a device<a id="_idIndexMarker896"/> and associate it with the Thing:</p>
<ol>
<li>Before adding the device, connect the development board to the computer and open the <strong class="bold">Arduino Create </strong><strong class="bold">Agent</strong> application.</li>
<li>After assigning a name to the Thing, we need to attach the device to it. When you click on the <strong class="bold">Select Device</strong> button, you will see a popup that shows you the available devices and an option to add a new device. In our case, we don’t have a device in the portal, so we can just click on <strong class="bold">SET UP NEW DEVICE</strong> to configure a new device in the account.</li>
</ol>
<div><div><img alt="Figure 11.3 – The associated device" src="img/B19752_11_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – The associated device</p>
<ol>
<li value="3">Then, you will see two options<a id="_idIndexMarker897"/> in the popup. The first option is <strong class="bold">Set up an Arduino device</strong>, and the second option is <strong class="bold">Set up a 3rd Party device</strong>. Here, you will see a note under both options that says <strong class="bold">Compatible devices</strong>. This means you cannot use all types of Arduino devices and third-party devices with the Arduino IoT Cloud.</li>
</ol>
<div><div><img alt="Figure 11.4 – Choosing the device" src="img/B19752_11_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Choosing the device</p>
<p class="list-inset">Select one option from the popup<a id="_idIndexMarker898"/> according to the available device. For this example, we will click on <strong class="bold">Set up an Arduino device</strong>, as in this chapter, we are using an MKR<a id="_idIndexMarker899"/> Wi-Fi 1010 board. Before adding the device, make sure the <strong class="bold">Arduino Create Agent</strong> is running on your machine.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Here is the link where you can find the Arduino IoT Cloud-compatible boards: <a href="https://store-usa.arduino.cc/pages/cloud-compatible-boards">https://store-usa.arduino.cc/pages/cloud-compatible-boards</a>. For third-party devices, we have three options, which are ESP8266, ESP32, and <strong class="bold">LoRaWAN</strong> devices. For other devices, we have API access, which was discussed in the second part of <a href="B19752_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>.</p>
<ol>
<li value="4">Now, you will see the <strong class="bold">Setup Device</strong> popup, which will start searching for your device. Make sure the device is properly connected to the machine.</li>
</ol>
<div><div><img alt="Figure 11.5 – Setup Device" src="img/B19752_11_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Setup Device</p>
<p class="list-inset">The wizard will find and list<a id="_idIndexMarker900"/> all the connected boards with their name and port details. Click on the <strong class="bold">CONFIGURE</strong> button to move forward. If the wizard didn’t show the device after searching, try to plug it into a different port, and click on the <strong class="bold">refresh</strong> link located at the bottom.</p>
<ol>
<li value="5">In the next configuration wizard, provide the device name. Spaces and special characters are not allowed in the device name. Then, click on the <strong class="bold">NEXT</strong> button.</li>
</ol>
<div><div><img alt="Figure 11.6 – The device configuration name" src="img/B19752_11_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – The device configuration name</p>
<p class="list-inset">After that, the wizard will start the device configuration process. This will take up to five minutes, but in most cases, it only takes one minute to configure the device.</p>
<ol>
<li value="6">You will then see the <strong class="bold">Congratulations! You are all set</strong> message in the next popup. Click on the <strong class="bold">Done</strong> button, and the device will be attached to your Thing.</li>
</ol>
<p>In this section, we associated<a id="_idIndexMarker901"/> the MKR Wi-Fi 1010 development board with our Thing. In the next section, we will configure the Wi-Fi network configuration for the MKR Wi-Fi 1010.</p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor239"/>Network configuration</h2>
<p>After the attachment<a id="_idIndexMarker902"/> of the device with the Thing, we can see that the device is offline. To get it online, we need to provide the Wi-Fi details.</p>
<div><div><img alt="Figure 11.7 – Network configuration" src="img/B19752_11_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Network configuration</p>
<p>On the Thing page under the <strong class="bold">Network</strong> tab, click on the <strong class="bold">CONFIGURE</strong> button. You will see the <strong class="bold">Configure network</strong> pop-up box with two fields – <strong class="bold">Wi-Fi Name</strong> and <strong class="bold">Password</strong>. Type in the Wi-Fi SSID and password, and click on the <strong class="bold">SAVE</strong> button.</p>
<p>We are done with the device<a id="_idIndexMarker903"/> and network configuration; only the coding part is left. In the next section, we will look at the code for the device.</p>
<h2 id="_idParaDest-240"><a id="_idTextAnchor240"/>Coding</h2>
<p>The code for this chapter<a id="_idIndexMarker904"/> is available in the book’s official GitHub repository. Download the <code>Cloud_Scheduler_may22a</code> code from<a id="_idIndexMarker905"/> the repository, and import it to your <strong class="bold">Arduino </strong><strong class="bold">Web Editor</strong>.</p>
<p>You can download the code and put it into your Thing by navigating to the <code>delay()</code> method, as it will block the <code>ArduinoCloud.update()</code> method:</p>
<pre class="source-code">
#define LED1 8
#define LED2 7
#define LED3 6</pre> <p>Here, we have very simple<a id="_idIndexMarker906"/> code. Firstly, we will define the pins’ <code>LED1</code>, <code>LED2</code>, and <code>LED3</code> constants, which will be initialized in the <code>setup()</code> method as output, using the <code>pinMode()</code> method:</p>
<pre class="source-code">
void setup() {
  pinMode(LED1,OUTPUT);
  pinMode(LED2,OUTPUT);
  pinMode(LED3,OUTPUT);
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);
  // Defined in thingProperties.h
  initProperties();
  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}</pre> <p>Then, we have all the code regarding Schedulers<a id="_idIndexMarker907"/> in the <code>loop()</code> method, which will perform an operation when a scheduler/timer is in an active state. In the following code, we have a separate <code>if-else</code> statement for each <code>cloudScheduler</code> cloud variable; here, we check whether <code>cloudScheduler</code> is active and then turn on the LED; otherwise, we turn off the LED. We have <code>cloudScheduler1</code>, <code>cloudScheduler2</code>, and <code>cloudScheduler3</code>, plus three <code>if-else</code> statements to check their values:</p>
<pre class="source-code">
void loop() {
  ArduinoCloud.update();
  // Your code here
  //Cloud Scheduler 1 Code
  if(cloudScheduler1.isActive()){
    digitalWrite(LED1,HIGH);
  }else{
    digitalWrite(LED1,LOW);
  }
    //Cloud Scheduler 2 Code
  if(cloudScheduler2.isActive()){
    digitalWrite(LED2,HIGH);
  }else{
    digitalWrite(LED2,LOW);
  }
    //Cloud Scheduler 3 Code
  if(cloudScheduler3.isActive()){
    digitalWrite(LED3,HIGH);
  }else{
    digitalWrite(LED3,LOW);
  }
}</pre> <p>The Scheduler<a id="_idIndexMarker908"/> widget is very complex in configuration with lots of options, but its code is very simple and straightforward. You just need to verify whether the Scheduler state is <code>true</code> or <code>false</code>, and if it’s <code>true</code>, then proceed with the task; otherwise, stop the task. So, in the <code>loop()</code> method, we have three <code>if-else</code> statements, which check different cloud Schedulers’/timers’ states. If a specific Scheduler is active, then a specific LED will be turned on; otherwise, it will be turned off.</p>
<p>I attached the LED in <em class="italic">Pin #8</em> to <code>cloudScheduler1</code>, the LED in <em class="italic">Pin #7</em> to <code>cloudScheduler2</code>, and the LED in <em class="italic">Pin #6</em> to <code>cloudScheduler3</code>. Now, set the first widget’s time to 5 seconds for every minute, the second widget to 10 seconds for every minute, and 15 seconds for every minute for the third widget. All the LEDs will turn on at the same time, but the first LED will be on for 5 seconds, the second LED will be on for 10 seconds, and the third will turn off after 15 seconds. In this example project, we have used three different Schedulers to demonstrate how we can use multiple Schedulers/timers to automate our tasks on a single development board.</p>
<p class="callout-heading">Important note</p>
<p class="callout">If you used different <em class="italic">naming</em> in the variable declaration, then update the code according to your naming scheme. However, it’s better at first if you follow all the steps according to the book and later change the cloud variable names and modify your code, respectively.</p>
<p class="callout">Also, don’t put the code at the end of the <code>loop()</code> method, as it will create a delay with pulse sensor readings.</p>
<p>In this section, we discussed<a id="_idIndexMarker909"/> code and how it works with the Arduino IoT Cloud Scheduler to turn the LEDs on and off. In the following section, we will set up a dashboard, where we will place the Scheduler widget and attach it to our cloud variables.</p>
<h1 id="_idParaDest-241"><a id="_idTextAnchor241"/>Dashboard creation and a deep dive into the Scheduler widget</h1>
<p>After uploading the code<a id="_idIndexMarker910"/> to the device, it’s time to set up a dashboard for web and mobile to insert the multiple Scheduler widgets that will be linked to the Scheduler variables, for further controls and operations. The following figure shows the visualization Scheduler with different timer options:</p>
<div><div><img alt="Figure 11.8 – The Thing dashboard" src="img/B19752_11_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – The Thing dashboard</p>
<p>We have three Scheduler variables. To visualize all of them, three Scheduler widgets will be linked<a id="_idIndexMarker911"/> to each cloud variable, respectively. The purpose of the three widgets and variables is to demonstrate how we can set different types of timers. The first widget demonstrates how to use a timer that will be executed every minute for 30 seconds, the second widget demonstrates how to use a timer that will be activated every hour for five minutes, and the third widget demonstrates that we can set the timer for a long period, such as specific days at a specific time. Here, I have set it to be activated on Monday, Wednesday, and Friday for five minutes.</p>
<p>We just set the different widgets<a id="_idIndexMarker912"/> with different timer settings. One of the example settings of the Scheduler widget is shown in <em class="italic">Figure 11</em><em class="italic">.9</em>, and we will explore in depth how to set these settings. This control widget has multiple options for configuration, so I think it’s necessary to discuss it in detail for proper guidance.</p>
<div><div><img alt="Figure 11.9 – The Scheduler widget options" src="img/B19752_11_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – The Scheduler widget options</p>
<p>When you click on the Scheduler<a id="_idIndexMarker913"/> widget, a popup will appear with options, just like in the preceding figure. Here, I have divided the screenshot into four different numbered sections. From this popup, you can adjust your time settings from seconds to years and set the start and end date, or choose to execute without any date limitation. Let’s look at each section:</p>
<ol>
<li>Here, we have two input controls – one is for the starting date and the other is for the starting time, as indicated by the control headings.</li>
<li>Next, we have the <strong class="bold">Duration</strong> setting, in which we have three drop-down boxes – <strong class="bold">HOURS</strong>, <strong class="bold">MINUTES</strong>, and <strong class="bold">SECONDS</strong>. This will define how long the timer will be executed on the machine. For example, if you want to perform an operation for 30 seconds, then just select <strong class="bold">30</strong> seconds and leave the other fields, or if you want to perform an operation for 5 minutes, then select <strong class="bold">5</strong> minutes and leave the other fields, and so on.</li>
<li>Then, we have the <strong class="bold">Repeat every</strong> setting, which is only applicable for <strong class="bold">Week</strong>, <strong class="bold">Month</strong>, and <strong class="bold">Year</strong>; there is no predefined setting for minutes and hours. I have selected <strong class="bold">Week</strong>. Under that, the days are shown (by their first letter), and there, you can select on which day/days you can perform an operation. There are different options for <strong class="bold">Month</strong> and <strong class="bold">Year</strong>, which will be discussed in a moment.</li>
<li>Finally, we have the <strong class="bold">End recurrence</strong> setting. Here, we have two options – <strong class="bold">Never</strong> and <strong class="bold">On</strong>. When you click on <strong class="bold">On</strong>, you will need to enter the date and time when your operation will be stopped. If you want to execute it indefinitely, then just select the <strong class="bold">Never</strong> option.</li>
</ol>
<p>For <strong class="bold">Year</strong> and <strong class="bold">Month</strong> in the <strong class="bold">Repeat every</strong> section, we have different<a id="_idIndexMarker914"/> options in the Scheduler. The following figures show all the details regarding both options. First, let’s look at <strong class="bold">Month</strong>:</p>
<div><div><img alt="Figure 11.10 – The Month option in the Scheduler" src="img/B19752_11_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – The Month option in the Scheduler</p>
<p>Here is the <strong class="bold">Year</strong> option:</p>
<div><div><img alt="Figure 11.11 – The Year option in the Scheduler" src="img/B19752_11_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – The Year option in the Scheduler</p>
<p>For <strong class="bold">Month</strong>, we have a dropdown<a id="_idIndexMarker915"/> that allows us to select the day (such as <strong class="bold">1st</strong>), while in the case of <strong class="bold">Year</strong>, we have two dropdowns – one for the day and one for the month (such as <strong class="bold">1st</strong> <strong class="bold">January</strong>).</p>
<p>In this section, we set up the dashboard with three different Scheduler widgets and assigned them Boolean-type cloud variables, which will be used in our code to check the Scheduler state and whether the Scheduler is active or not. In the following section, you have an assignment to use the Scheduler according to the specified requirements, giving you a proper idea of how you can use the scheduler functionality in your projects to enhance your product development.</p>
<h1 id="_idParaDest-242"><a id="_idTextAnchor242"/>The task at hand – an assignment</h1>
<p>Continuing from the previous project where you connected three LEDs to the MKR Wi-Fi 1010 and set<a id="_idIndexMarker916"/> up the Arduino IoT Cloud Scheduler, complete the following assignment tasks:</p>
<ul>
<li>Attach three relays to control any electrical/electronic appliance, such as a fan, light, or heater, using the Scheduler.</li>
<li>Implement the Scheduler to turn your home’s outside/indoor lights on/off.</li>
<li>Attach a buzzer instead of LEDs, and create an alarm device for your room/classroom.</li>
<li>Turn on surprise lighting with the Scheduler for a birthday or anniversary. Use the same light strip with multiple Schedulers to turn the light strips on/off for different occasions.</li>
<li>Control the water solenoid valve for your garden/tunnel farm using the Scheduler (this is optional, and if you have a smart agriculture facility).</li>
</ul>
<p>In this section, we outlined<a id="_idIndexMarker917"/> an assignment that will test your skills with different scenarios and help you explore the usage of the Scheduler feature in different environments. In the following section, we will start to explore the benefits of OTA, the Arduino IoT Cloud's OTA features, supported development boards for OTA, and how to use OTA features in the Arduino IoT Cloud. And, of, course you will also learn about the pros and cons of the Arduino IoT Cloud OTA.</p>
<h1 id="_idParaDest-243"><a id="_idTextAnchor243"/>Exploring OTA updates in IoT</h1>
<p>OTA is a term<a id="_idIndexMarker918"/> that refers to the wireless distribution of software or firmware<a id="_idIndexMarker919"/> updates, or other updates to devices. This technology allows updates to be delivered and installed on devices without the need for physical connections or manual intervention. OTA is widely utilized across various industries, including telecommunications, automotive, consumer electronics, and IoT. Here are a few examples<a id="_idIndexMarker920"/> of OTA usage:</p>
<ul>
<li><strong class="bold">Mobile devices</strong>: OTA updates are commonly employed to distribute operating system updates, security patches, and feature enhancements to smartphones and tablets. Users receive notifications, prompting them to download and install the updates wirelessly.</li>
<li><strong class="bold">Automotive industry</strong>: Many modern vehicles are equipped with OTA capabilities, enabling manufacturers to remotely update the vehicle software, infotainment systems, navigation maps, and other features. OTA updates can improve vehicle performance, introduce new functionalities, and address security vulnerabilities.</li>
<li><strong class="bold">IoT devices</strong>: IoT devices, such as smart home devices, wearables, and industrial sensors, often rely on OTA updates to deliver firmware updates, bug fixes, and new features. This enables manufacturers to enhance device performance, address vulnerabilities, and introduce new functionalities without the need for physical access to the devices.</li>
<li><strong class="bold">Set-top boxes and smart TVs</strong>: OTA updates are utilized to deliver firmware updates and software patches to set-top boxes and smart TVs. This ensures that these devices remain up to date with the latest features, security enhancements, and bug<a id="_idIndexMarker921"/> fixes.</li>
</ul>
<p>OTA updates offer numerous<a id="_idIndexMarker922"/> benefits, including convenience, cost-effectiveness, and the ability to quickly address security vulnerabilities or software<a id="_idIndexMarker923"/> issues. However, ensuring the integrity and security of OTA updates is crucial to prevent unauthorized access or malicious activities that could compromise the devices or data.</p>
<p>In this section, we explored what OTA is and how it offers benefits in today’s world. In the following section, we will discuss in detail the Arduino IoT Cloud OTA feature, which includes compatible devices that are supported by the Arduino IoT Cloud for OTA, and how to use the OTA feature in the Arduino IoT Cloud to send firmware updates to devices.</p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor244"/>Leveraging the Arduino IoT Cloud for OTA updates</h1>
<p><strong class="bold">Arduino IoT Cloud OTA</strong> is a feature available in the Arduino IoT Cloud<a id="_idIndexMarker924"/> platform, designed to facilitate the remote monitoring and control of Arduino-based IoT devices. This functionality allows users to wirelessly update the firmware of their deployed Arduino IoT devices.</p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor245"/>The Arduino IoT Cloud pros</h2>
<p>The Arduino IoT Cloud OTA feature<a id="_idIndexMarker925"/> offers the following capabilities:</p>
<ul>
<li><strong class="bold">Firmware updates</strong>: Users can remotely update the firmware of their Arduino IoT devices as well as ESP-series devices using Arduino IoT Cloud OTA. This enables the deployment of bug fixes, security patches, feature enhancements, and new versions of code without the need for physical access to the devices.</li>
<li><strong class="bold">Code synchronization</strong>: The OTA feature ensures that the code running on Arduino/ESP-series IoT devices remains synchronized with the latest version stored on the cloud. It eliminates the necessity of manually updating each device individually, thereby maintaining consistency across the entire fleet of IoT devices.</li>
<li><strong class="bold">OTA configuration</strong>: In addition to firmware updates and code synchronization, Arduino IoT Cloud OTA enables users to remotely configure the parameters or settings of their Arduino/ESP-series IoT devices. This means device behavior can be modified, thresholds can be adjusted, and variables can be changed without the need for physical intervention.</li>
<li><strong class="bold">Security and integrity</strong>: Arduino IoT Cloud OTA ensures the security and integrity of firmware updates through authentication and encryption mechanisms. This safeguards against unauthorized access or tampering during the transmission process, enhancing the security of IoT devices and preventing potential<a id="_idIndexMarker926"/> vulnerabilities.</li>
</ul>
<p>By providing a convenient and secure method to remotely update firmware and configure devices, the Arduino IoT Cloud OTA simplifies the management and maintenance of Arduino-based IoT deployments. It enhances efficiency, reduces costs, and enables users to keep their IoT devices up to date with the latest features, bug fixes, and security enhancements. In the following subsection, we will discuss the cons of the Arduino IoT Cloud OTA feature.</p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor246"/>Arduino IoT Cloud OTA cons</h2>
<p>The Arduino IoT Cloud OTA feature<a id="_idIndexMarker927"/> is a convenient tool to remotely update the firmware of your Arduino devices connected to the Arduino IoT Cloud platform. However, as with any technology, it has its drawbacks and limitations. Here are some cons of the Arduino IoT Cloud OTA feature:</p>
<ul>
<li><strong class="bold">Limited bandwidth</strong>: OTA updates require data transfer over the internet, which can be costly or problematic in areas with limited or expensive data bandwidth. Large firmware updates may consume a significant amount of data.</li>
<li><strong class="bold">Network stability</strong>: Reliable internet connectivity is essential for OTA updates. If a device loses connection during an update, it can result in failed or corrupt firmware, potentially rendering the device unusable.</li>
<li><strong class="bold">Version control</strong>: Managing different versions of firmware across multiple devices can become challenging. Keeping track of which devices are running which firmware versions and ensuring compatibility can be time-consuming.</li>
<li><strong class="bold">Compatibility issues</strong>: OTA updates may not work seamlessly with all types of devices and configurations. Ensuring that your hardware supports OTA updates and that you have the necessary libraries and code in place can be a complex task.</li>
<li><strong class="bold">Latency</strong>: Depending on the size of the firmware update and the speed of the internet connection, OTA updates can introduce latency, causing devices to be temporarily unavailable during the update process.</li>
<li><strong class="bold">Dependency on the Arduino IoT Cloud</strong>: To use the Arduino IoT Cloud OTA feature, you must rely on the Arduino IoT Cloud platform. If the platform experiences downtime or changes in its services, it can impact your ability to perform OTA updates.</li>
<li><strong class="bold">Limited rollback options</strong>: In some cases, if an OTA update fails or causes issues, rolling back to a previous firmware version can be challenging, especially if you didn’t plan for rollback<a id="_idIndexMarker928"/> mechanisms in advance.</li>
</ul>
<p>Despite these cons, OTA updates remain a valuable feature for many IoT projects. However, it’s essential to carefully assess your project’s specific requirements and constraints before implementing OTA updates and to address these challenges through proper planning and security measures.</p>
<p>In this section, we discussed the different benefits of the Arduino IoT Cloud OTA feature as well as its cons. In the following section, we will take a deeper look into which hardware development boards are compatible with the Arduino IoT Cloud OTA feature, as it is currently not supported by all hardware development boards. Therefore, it’s necessary for you to keep this point in mind during the product development stage if you need an OTA feature for your product.</p>
<h2 id="_idParaDest-247"><a id="_idTextAnchor247"/>A list of compatible development hardware for Arduino OTA</h2>
<p>Not all of the official Arduino (or other) development boards<a id="_idIndexMarker929"/> are ready for the OTA feature, but here are the ones that are compatible and ready. Go to this link to check out all the information<a id="_idIndexMarker930"/> regarding OTA-compatible development boards: https://docs.arduino.cc/arduino-cloud/features/ota-getting-started.</p>
<p>These are the official Arduino development boards that are ready for OTA:</p>
<ul>
<li>Arduino MKR Wi-Fi 1010</li>
<li>Arduino Nano 33 IoT</li>
<li>Arduino Nano RP2040 Connect</li>
<li>Portenta H7</li>
<li>Portenta Machine Control</li>
<li>Nicla Vision</li>
<li>Arduino Opta (PLC)</li>
</ul>
<p>These are the ESP32-series development boards that are ready for OTA:</p>
<ul>
<li>ESP32-S2-DevKitC</li>
<li>NodeMCU-32-S2</li>
<li>WeMos LOLIN D32</li>
<li>ESP32-S3-DevKitC</li>
<li>ESP32-CAM</li>
<li>NodeMCU-32S</li>
<li>Freenove ESP32 WROVER</li>
<li>ESP32-DevKitC-32E</li>
<li>DOIT ESP32 DevKit v1</li>
</ul>
<p>The good thing is that Arduino provides the latest features to ESP32-series development boards. These boards<a id="_idIndexMarker931"/> are very popular among students/researchers and professional developers, due to their cost and availability all around the world. I used the <strong class="bold">XIAO ESP32-C3 series</strong> development board for various projects and tested the OTA service for that board. From my personal experience, the OTA service works faster on official Arduino development boards as compared to the ESP32 series, but I hope in the future that the Arduino Cloud team will optimize the OTA feature for the ESP32 series board for a faster and better experience.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The Arduino IoT Cloud offers the OTA feature to Wi-Fi-enabled devices. This means that LoRaWAN is currently not compatible with the OTA feature.</p>
<p>In this section, we discussed the broad<a id="_idIndexMarker932"/> range of compatible boards that support the Arduino IoT Cloud OTA feature. In the following section, we will take a look at how we can use the OTA feature in the Arduino IoT Cloud to send firmware updates via the internet, without any device connection to the host computer.</p>
<h2 id="_idParaDest-248"><a id="_idTextAnchor248"/>Implementing the OTA update on the MKR Wi-Fi 1010</h2>
<p>Firstly, we will explore<a id="_idIndexMarker933"/> how we can use OTA, and then we will dive deep into how OTA<a id="_idIndexMarker934"/> works behind the scenes. We need to navigate to a Thing that uses an OTA-supported development board; we will choose a Thing that is already attached to the MKR Wi-Fi 1010 device. Navigate to the <strong class="bold">Sketch</strong> tab in the Thing. The following figure shows the OTA feature and port:</p>
<div><div><img alt="Figure 11.12 – The physical port connection with the OTA update feature" src="img/B19752_11_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – The physical port connection with the OTA update feature</p>
<p>My device is connected to my MacBook as well as to the Arduino IoT Cloud via Wi-Fi. That’s why you can see two options in the preceding figure for sketch uploading. The first one is the <strong class="bold">Port</strong> option, which is only available when your development board is directly connected to your laptop/computer, while the second option is <strong class="bold">Over-the-Air</strong>, which is available when your code is configured on your development board with network settings and successfully connected to the Arduino IoT Cloud over the internet.</p>
<p>Select the <strong class="bold">Over-the-Air</strong> option, and click<a id="_idIndexMarker935"/> on the <strong class="bold">Sketch Uploading</strong> (the green arrow icon) button; this will start uploading<a id="_idIndexMarker936"/> your updated code to the board via the internet without the intervention of a physical connection. However, how can you confirm that this works via the internet? Just unplug the development board from your computer and power it with any adapter, but make sure your device has access to a Wi-Fi router.</p>
<div><div><img alt="Figure 11.13 – The standalone Over-the-Air update option" src="img/B19752_11_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – The standalone Over-the-Air update option</p>
<p>After disconnecting from the computer and turning on the device via the power adapter, you will see only the <strong class="bold">Over-the-Air</strong> update option in your <strong class="bold">Sketch</strong> tab. Just modify your code or add some extra login details, and click on <strong class="bold">Sketch Uploading</strong> (the green arrow icon), and within a short time, your code will be on the development board without any hassle.</p>
<p>Based on my experience, I've often thought we should have an option by which we can modify/update the code of remote devices, such as devices for smart agriculture, warehouse monitoring, and industrial monitoring, because it’s very difficult to travel to remote places to update/modify the code. However, the Arduino IoT Cloud OTA feature makes our lives easier overall. With the OTA<a id="_idIndexMarker937"/> feature, we can save time and cost<a id="_idIndexMarker938"/> and provide the correct updates on time to our devices without any delay.</p>
<h2 id="_idParaDest-249"><a id="_idTextAnchor249"/>How OTA works</h2>
<p>Let’s talk about how OTA<a id="_idIndexMarker939"/> works behind the scenes. The Arduino IoT Cloud first compiles the code in a cloud<a id="_idIndexMarker940"/> environment, according to the selected device, and then stores these compiled files in <code>OTA_REQ</code> flag is <code>true</code>, it will start downloading the compiled files from the specified URL. After download completion, the development board verifies the downloaded files with a length/CRC check. After download verification, the board will start flashing with the latest firmware. The following figure illustrates the whole procedure that happens behind the scenes:</p>
<div><div><img alt="Figure 11.14 – The Arduino IoT Cloud OTA behind the scenes" src="img/B19752_11_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – The Arduino IoT Cloud OTA behind the scenes</p>
<p>The Arduino IoT Cloud team has simplified the complexity of this process and provides only a single-click option for developers for OTA. The purpose of this diagram is to give you an overview of how things work, which will hopefully provide you with new ideas for your future developments.</p>
<p>In this section, we learned <a id="_idIndexMarker941"/>how to implement the Arduino IoT Cloud OTA feature to send firmware OTA. We also discussed how the Arduino IoT Cloud sends firmware updates to devices using the Amazon S3 service.</p>
<h1 id="_idParaDest-250"><a id="_idTextAnchor250"/>Summary</h1>
<p>In this chapter, we explored the Scheduler and how we can use the Arduino IoT Cloud to automate tasks that have different patterns or random patterns of operation. We used simple LEDs with the MKR Wi-Fi 1010 to demonstrate multiple Scheduler/timer operations, which helped you to understand how to use this function in real-world projects, such as in smart agriculture and smart industry.</p>
<p>In the second part of the chapter, we explored OTA. Firstly, we discussed the pros and cons of OTA and how we can save time and costs with it. Then, we used OTA-enabled development boards to demonstrate the use of the OTA feature, and finally, we explored how OTA works behind the scenes.</p>
<p>In the following chapter, we will implement a healthcare project. You will learn how to use a heartbeat sensor as well as the Arduino IoT Cloud webhooks feature, which will send data to a third-party service (<strong class="bold">Zapier</strong>). We will use Zapier to set up a <em class="italic">Zap</em>, which will receive the heartbeat readings and send an email notification to a designated person if the reading is over or under the threshold.</p>
</div>
</body></html>