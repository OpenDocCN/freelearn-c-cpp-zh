# 第1章。简介

本书的目的在于学习如何在 Windows 中开发应用程序。为了做到这一点，我开发了 Small Windows，这是一个用于 Windows 图形应用程序的 C++ 面向对象类库。

想法是通过介绍使用 Small Windows 编写的越来越高级的应用程序来引导你进入 Windows 编程，从而隐藏 **Windows 32 位应用程序编程接口**（**Win32 API**）的技术细节，这是 Windows 开发的基础库。采用这种方法，我们可以专注于业务逻辑，而不必与底层的技术细节纠缠。如果你对了解 Win32 API 的工作原理感兴趣，本书的第二部分详细描述了 Small Windows 的实现方式。

这本书由两部分组成，第一部分描述了使用 Small Windows 开发的应用程序。虽然有些书包含许多示例，但本书只包括六个示例，其中最后四个相对较复杂：俄罗斯方块游戏、绘图程序、文字处理程序和电子表格程序。请注意，本书不仅是一本关于 Windows 编程的教程，也是一本关于如何开发面向对象的图形应用程序的教程。

第二部分详细描述了 Small Windows 在 Win32 API 中的实现。请注意，Win32 API 直到第二部分才介绍。有些人可能对 Small Windows 的高级特性感到满意，只想研究特定应用程序的问题，而其他人可能想阅读第二部分，以了解 Small Windows 的类、方法和宏如何在 Win32 API 中实现。

自然，我意识到现代面向对象的类库也存在于 Windows 中。然而，那些库的目的是通过隐藏架构的细节来简化开发者的工作，这也阻止了开发者充分利用 Windows 架构。尽管 Win32 API 已经存在了一段时间，但我认为它是开发专业 Windows 应用程序和了解 Windows 架构的最佳方式。

本书提供了所有源代码；它也可以作为 Visual Studio 解决方案提供。

# 库

本节介绍了 Small Windows。Small Windows 应用程序的第一部分是 `MainWindow` 函数。它对应于常规 C++ 中的 `main` 函数。其任务是设置应用程序的名称并创建应用程序的主窗口。

在本书中，我们讨论了 **定义** 和 **声明**。声明只是对编译器的通知，而定义则是定义特性的内容。下面是 `MainWindow` 函数的声明。其定义留给 Small Windows 的用户。

[PRE0]

简而言之，在 Windows 中，应用程序不会采取任何主动行动；相反，它等待消息，并在收到它们时做出反应。非正式地说，*你不是调用 Windows，而是 Windows 调用你*。

小窗口的核心部分是 `Application` 类。在 Windows 中，每个事件都会生成一个消息，该消息发送到当前具有输入焦点的窗口。`Application` 类实现了 `RunMessageLoop` 方法，确保每个消息都发送到正确的窗口。当发送特殊退出消息时，它还会关闭应用程序。

创建窗口分为两个步骤。在第一步中，`RegisterWindowClasses` 方法设置诸如样式、颜色和外观等特性。请注意，Windows 类不是 C++ 类：

[PRE1]

下一步是创建一个单独的窗口，这是通过 `Window` 类完成的。所有 `virtual` 方法都是空的，并旨在由以下子类覆盖：

[PRE2]

窗口可以是可见的或不可见的，可以是启用的或禁用的。当窗口被启用时，它接受鼠标、触摸和键盘输入：

[PRE3]

当窗口移动或调整大小时，会调用 `OnMove` 和 `OnSize` 方法。当用户按下 *F1* 键或消息框中的 **帮助** 按钮时，会调用 `OnHelp` 方法：

[PRE4]

**客户端区域**是窗口中可以绘制的部分。非正式地说，客户端区域是窗口减去其框架。客户端区域的内容可以缩放。默认缩放因子是 1.0：

[PRE5]

**计时器**可以设置为毫秒间隔。每隔一段时间就会调用 `OnTimer` 方法。只要它们有不同的身份号码，就可以设置多个计时器：

[PRE6]

当用户按下、释放或双击鼠标按钮时，会调用 `OnMouseDown`、`OnMouseUp` 和 `OnDoubleClick` 方法。当用户至少按下鼠标按钮移动鼠标时，会调用 `OnMouseMove` 方法。当用户滚动鼠标滚轮时，会调用 `OnMouseWheel` 方法：

[PRE7]

`OnTouchDown`、`OnTouchMove` 和 `OnTouchDown` 方法的工作方式与鼠标方法相同。然而，由于用户可以同时触摸多个点，因此方法接受点的列表而不是单个点：

[PRE8]

当用户按下或释放一个键时，会调用 `OnKeyDown` 和 `OnKeyUp` 方法。如果用户按下图形键（ASCII 值在 32 到 127 之间的键），则在之间调用 `OnChar` 方法：

[PRE9]

`Invalidate` 方法标记客户端区域的一部分（或整个客户端区域）需要重绘；该区域变为**无效**。如果 `clear` 为 `true`，则在绘制之前清除该区域。`UpdateWindow` 方法强制重绘无效区域。它最终会调用 `OnPaint` 方法：

[PRE10]

当客户端区域需要重新绘制时，会调用`OnPaint`方法，当它被发送到打印机时，会调用`OnPrint`方法。它们的默认行为是调用`OnDraw`方法，其中`drawMode`参数的值为`Paint`或`Print`：

[PRE11]

如果`TryClose`返回`true`，则`OnClose`方法会关闭窗口。当窗口正在关闭时，会调用`OnDestroy`方法：

[PRE12]

以下方法检查并修改窗口的大小和位置。请注意，我们无法直接设置客户端区域的大小；它只能通过调整窗口大小间接设置：

[PRE13]

在本书中的文字处理程序和电子表格程序中，我们处理文本并需要计算单个字符的大小。以下方法使用给定的字体计算字符的宽度。它们还计算字体的行高、上升和平均字符宽度：

[PRE14]

上升线分隔字母的上部和下部，如下所示：

![该库](img/B05475_01_01.jpg)

最后，`MessageBox`方法在窗口中显示一个简单的消息框：

[PRE15]

`Window`类还使用负责在窗口中绘制文本和几何对象的`Graphics`类。`Graphics`对象的引用被发送到`Window`类中的`OnPaint`、`OnPrint`和`OnDraw`方法。它可以用来绘制线条、矩形和椭圆以及写入文本：

[PRE16]

`Document`类通过一些功能扩展了`Window`类，这些功能对基于文档的应用程序来说是通用的。滚动滑块会自动设置为反映文档的可视部分。鼠标滚轮每次点击都会移动垂直滚动条一行的高度。行高由构造函数设置。它的代码片段如下所示：

[PRE17]

当用户在文档中进行了更改且需要保存时，**脏标志**会被设置为`true`。在`Document`中，脏标志是手动设置的，但在下面的`StandardDocument`子类中，它是由框架处理的：

[PRE18]

**光标**是闪烁的标记，指示用户应在何处输入下一个字符。键盘可以通过（使用插入键）设置为插入或覆盖模式。在插入模式下，光标通常是一个细长的垂直条，在覆盖模式下是一个宽度为平均字符宽度的块。

光标可以被设置或清除。例如，在文字处理程序中，当用户写入文本时，光标是可见的，当用户标记文本时，光标是不可见的。当窗口获得焦点时，如果之前已经设置了光标，则光标变为可见。当窗口失去焦点时，无论之前是否已设置，光标都变为不可见：

[PRE19]

文档可能包含一个菜单栏，该菜单栏是通过`SetMenuBar`方法设置的：

[PRE20]

当用户在窗口中拖放一个或多个文件时，会调用`OnDropFiles`方法。它们的路径存储在路径列表中：

[PRE21]

可以将文档的键盘模式设置为**插入**或**覆盖**，如下所示：

[PRE22]

当用户通过点击滚动条箭头或滚动条字段，或拖动滚动滑块来滚动条时，会调用`OnHorizontalScroll`和`OnVerticalScroll`方法。相应的代码片段如下所示：

[PRE23]

存在大量用于检查或更改滚动条设置的方法。行或页的大小由构造函数设置：

[PRE24]

`Menu`类处理文档中的菜单栏、菜单、菜单项或菜单项分隔符（水平条）。当用户选择菜单项时，会调用`selection`监听器。当项目即将可见时，会调用（除非它们为null）`enable`、`check`和`radio`监听器。如果它们返回`true`，则项目被启用或带有复选框或单选按钮的标注：

[PRE25]

**加速器**是一个快捷命令。例如，通常**文件**菜单中的**打开**项被标注为文本**Ctrl+O**。这意味着您可以同时按下**Ctrl**键和**O**键来获得相同的结果，就像选择了**打开**菜单项一样。在这两种情况下，都会显示打开对话框。

`Accelerator`类只包含`TextToAccelerator`方法。它解释菜单项文本，并将如果存在则添加加速器到加速器集合中：

[PRE26]

`StandardDocument`类扩展了`Document`类，并设置了一个框架，该框架负责处理所有传统任务，例如加载和保存，以及剪切、复制和粘贴，在基于文档的应用程序中：

[PRE27]

`StandardDocument`类配备了常见的**文件**、**编辑**和**帮助**菜单。**文件**菜单可以可选地（如果`print`参数为`true`）配备打印和打印预览的菜单项：

[PRE28]

当用户选择**新建**菜单项时，会调用`ClearDocument`方法；其任务是清除文档。当用户选择**保存**或**另存为**菜单项时，会调用`WriteDocumentToStream`方法；当用户选择**打开**菜单项时，会调用`ReadDocumentFromStream`方法：

[PRE29]

当用户选择**剪切**或**复制**菜单项并且相应的`ready`方法返回`true`时，会调用`CopyAscii`、`CopyUnicode`和`CopyGeneric`方法。相应的代码片段如下所示：

[PRE30]

同样，当用户选择**粘贴**菜单项并且相应的`ready`方法返回`true`时，会调用`PasteAscii`、`PasteUnicode`和`PasteGeneric`方法：

[PRE31]

`OnDropFile` 方法检查路径列表，如果恰好有一个文件具有应用程序（由构造函数设置）的文档类型后缀，则接受拖放操作：

[PRE32]

在小窗口中，我们不关心像素大小。相反，我们使用**逻辑单位**，这些单位保持不变，无论屏幕的物理分辨率如何。我们可以从以下三个坐标系中选择：

+   `LogicalWithScroll`：逻辑单位是毫米的一百分之一，同时考虑当前滚动条设置。绘图程序和文字处理程序使用这个系统。

+   `LogicalWithoutScroll`：在这种情况下，逻辑单位也是毫米的一百分之一，但当前滚动条设置被忽略。电子表格程序使用这个系统。

+   `PreviewCoordinate`：当窗口创建时，窗口的客户区域被设置为固定的逻辑大小。这意味着当用户改变窗口大小时，逻辑单位的大小也会改变。俄罗斯方块游戏和`PreviewDocument`类使用这个系统。

除了`StandardDocument`类之外，还有一个`PrintPreviewDocument`类，它也扩展了`Document`类。它显示标准文档的一页。用户可以通过使用箭头键和***向上翻页***和***向下翻页***键或使用垂直滚动条来更改页面：

[PRE33]

此外，还有一些简单的辅助类：

+   `Point`：它包含一个二维点（x和y）

+   `Size`：它包含二维的宽度和高度

+   `Rect`：它包含矩形的四个角

+   `DynamicList`：它包含一个动态列表

+   `Tree`：它包含一个树形结构

+   `InfoList`：它包含一个可以转换成内存块的通用信息列表

`Registry`类包含对**Windows注册表**的接口，这是Windows系统中我们可以用来在应用程序执行之间存储值的数据库。`Clipboard`类包含对**Windows剪贴板**的接口，这是Windows中用于短期数据存储的区域，我们可以用它来在应用程序之间存储剪切、复制和粘贴的信息。

`Dialog`类是为自定义对话框设计的。`Control`类是对话框控制的根类。`CheckBox`、`RadioButton`、`PushButton`、`ListBox`和`ComboBox`类是特定控制的类。`TextField`类包含一个可以被`Converter`类转换成不同类型的文本字段。最后，`PageSetupDialog`类扩展了`Dialog`类，并实现了一个带有控制和转换器的对话框。

# 摘要

本章介绍了小型窗口。在[第2章](ch02.html "第2章。你好，小型世界！")“你好，小型世界”中，我们将开始使用小型窗口开发应用程序。
