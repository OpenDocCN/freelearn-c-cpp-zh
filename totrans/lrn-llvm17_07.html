<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-89" class="chapter-number"><a id="_idTextAnchor091"/>5</h1>&#13;
			<h1 id="_idParaDest-90"><a id="_idTextAnchor092"/>IR Generation for High-Level Language Constructs</h1>&#13;
			<p>High-level languages today usually make use of aggregate data types and <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) constructs. LLVM IR has some support for aggregate data types, and OOP constructs such as classes must be implemented on their own. Adding aggregate types raises the question of how the parameters of an aggregate type are passed. Different platforms have different rules, and this is also reflected in the IR. Complying with the calling convention also ensures that system functions can be called.</p>&#13;
			<p>In this chapter, you will learn how to translate aggregate data types and pointers to LLVM IR and how to pass parameters to a function in a system-compliant way. You will also learn how to implement classes and virtual functions in LLVM IR.</p>&#13;
			<p>This chapter will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Working with arrays, structs, and pointers</li>&#13;
				<li>Getting the <strong class="bold">application binary interface</strong> <strong class="bold">(</strong><strong class="bold">ABI)</strong> right</li>&#13;
				<li>Creating IR code for classes and virtual functions</li>&#13;
			</ul>&#13;
			<p>By the end of the chapter, you will have acquired the knowledge to create LLVM IR for aggregate data types and OOP constructs. You will also know how to pass aggregate data types according to the rules of the platform.</p>&#13;
			<h1 id="_idParaDest-91"><a id="_idTextAnchor093"/>Technical requirements</h1>&#13;
			<p>The code used in this chapter can be found at <a href="https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter05">https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter05</a>.</p>&#13;
			<h1 id="_idParaDest-92"><a id="_idTextAnchor094"/>Working with arrays, structs, and pointers</h1>&#13;
			<p>For almost all applications, basic types such as <code>INTEGER</code> are not sufficient. For example, to represent mathematical objects such as a matrix or a complex number, you must construct new data types based on existing ones. These new data types are generally known as <strong class="bold">aggregate</strong> or <strong class="bold">composite</strong>.</p>&#13;
			<p><code>tinylang</code> type <code>ARRAY [10] OF INTEGER</code> or the C type <code>long[10]</code> is expressed in IR as follows:</p>&#13;
			<pre class="source-code">&#13;
[10 x i64]</pre>			<p>Structures are composites of different types. In programming languages, they are often expressed with named members. For example, in <code>tinylang</code>, a structure is written as <code>RECORD x: REAL; color: INTEGER; y: REAL; END;</code> and the same structure in C is <code>struct { float x; long color; float y; };</code>. In LLVM IR, only the type names are listed:</p>&#13;
			<pre class="source-code">&#13;
{ float, i64, float }</pre>			<p>To access a member, a numerical index is used. Like arrays, the first element has an index number of <code>0</code>.</p>&#13;
			<p>The members of this structure are arranged in memory according to the specification in the data layout string. For more information regarding the data layout string within LLVM, <a href="B19561_04.xhtml#_idTextAnchor068"><em class="italic">Chapter 4</em></a>, <em class="italic">Basics of IR Code Generation</em>, describes these details.</p>&#13;
			<p>Furthermore, if necessary, unused padding bytes are inserted. If you need to take control of the memory layout, then you can use a packed structure in which all elements have a 1-byte alignment. Within C, we utilize the <code>__packed__</code> attribute in the struct in the following way:</p>&#13;
			<p><code>struct __attribute__((__packed__)) { float x; long long color; float </code><code>y; }</code></p>&#13;
			<p>Likewise, the syntax within LLVM IR is slightly different and looks like the following:</p>&#13;
			<pre class="source-code">&#13;
&lt;{ float, i64, float }&gt;</pre>			<p>Loaded into a register, arrays, and structs are treated as a unit. It is not possible to refer to a single element of array-valued register <code>%x</code> as <code>%x[3]</code>, for example. This is due to the SSA form because it is not possible to tell if <code>%x[i]</code> and <code>%x[j]</code> refer to the same element or not. Instead, we need special instructions to extract and insert single-element values into an array. To read the second element, we use the following:</p>&#13;
			<pre class="source-code">&#13;
%el2 = extractvalue [10 x i64] %x, 1</pre>			<p>We can also update an element such as the first one:</p>&#13;
			<pre class="source-code">&#13;
%xnew = insertvalue [10 x i64] %x, i64 %el2, 0</pre>			<p>Both instructions work on structures, too. For example, to access the <code>color</code> member from register <code>%pt</code>, you write the following:</p>&#13;
			<pre class="source-code">&#13;
%color = extractvalue { float, float, i64 } %pt, 2</pre>			<p>There exists an important limitation on both instructions: the index must be a constant. For structures, this is easily explainable. The index number is only a substitute for the name, and languages such as C have no notion of dynamically computing the name of a struct member. For arrays, it is simply that it can’t be implemented efficiently. Both instructions have value in specific cases when the number of elements is small and known. For example, a complex number could be modeled as an array of two floating-point numbers. It’s reasonable to pass this array around, and it is always clear which part of the array must be accessed during a computation.</p>&#13;
			<p>For general use in the front end, we have to resort to pointers to memory. All global values in LLVM are expressed as pointers. Let’s declare a <code>@arr</code> global variable as an array of eight <code>i64</code> elements. This is the equivalent of the <code>long arr[8]</code> C declaration:</p>&#13;
			<pre class="source-code">&#13;
@arr = common global [8 x i64] zeroinitializer</pre>			<p>To access the second element of the array, an address calculation must be performed to determine the address of the indexed element. Then the value can then be loaded from that address and put into a function <code>@second</code>, this looks like this:</p>&#13;
			<pre class="source-code">&#13;
define i64 @second() {&#13;
  %1 = load i64, ptr getelementptr inbounds ([8 x i64], ptr @arr, i64 0, i64 1)&#13;
  ret i64 %1&#13;
}</pre>			<p>The <code>getelementptr</code> instruction is the workhorse for address calculations. As such, it needs some more explanation. The first operand, <code>[8 x i64]</code>, is the base type the instruction is operating on. The second operand, <code>ptr @arr</code>, specifies the base pointer. Please note the subtle difference here: we declared an array of eight elements, but because all global values are treated as pointers, we have a pointer to the array. In C syntax, we really work with <code>long (*arr)[8]</code>! The consequence is that we first have to dereference the pointer before we can index the element, such as <code>arr[0][1]</code> in C. The third operand, <code>i64 0</code>, dereferences the pointer, and the fourth operand, <code>i64 1</code>, is the element index. The result of this computation is the address of the indexed element. Please note that no memory is touched by this instruction.</p>&#13;
			<p>Except for structs, the index parameters do not need to be constant. Therefore, the <code>getelementptr</code> instruction can be used in a loop to retrieve the elements of an array. Structs are treated differently here: only constants can be used, and the type must be <code>i32</code>.</p>&#13;
			<p>With this knowledge, arrays are easily integrated into the code generator from <a href="B19561_04.xhtml#_idTextAnchor068"><em class="italic">Chapter 4</em></a>, <em class="italic">Basics of IR Code Generation</em>. The <code>convertType()</code> method must be extended to create the type. If the <code>Arr</code> variable holds the type denoter of an array, and assuming the number of elements within an array is an integer literal, we then can add the following to the <code>convertType()</code> method to handle arrays:</p>&#13;
			<pre class="source-code">&#13;
 if (auto *ArrayTy =&#13;
                 llvm::dyn_cast&lt;ArrayTypeDeclaration&gt;(Ty)) {&#13;
    llvm::Type *Component =&#13;
        convertType(ArrayTy-&gt;getType());&#13;
    Expr *Nums = ArrayTy-&gt;getNums();&#13;
    uint64_t NumElements =&#13;
        llvm::cast&lt;IntegerLiteral&gt;(Nums)&#13;
            -&gt;getValue()&#13;
            .getZExtValue();&#13;
    llvm::Type *T =&#13;
        llvm::ArrayType::get(Component, NumElements);&#13;
    // TypeCache is a mapping between the original&#13;
    // TypeDeclaration (Ty) and the current Type (T).&#13;
    return TypeCache[Ty] = T;&#13;
}</pre>			<p>This type can be used to declare global variables. For local variables, we need to allocate memory for the array. We do this in the first basic block of the procedure:</p>&#13;
			<pre class="source-code">&#13;
  for (auto *D : Proc-&gt;getDecls()) {&#13;
    if (auto *Var =&#13;
            llvm::dyn_cast&lt;VariableDeclaration&gt;(D)) {&#13;
      llvm::Type *Ty = mapType(Var);&#13;
      if (Ty-&gt;isAggregateType()) {&#13;
        llvm::Value *Val = Builder.CreateAlloca(Ty);&#13;
        // The following method requires a BasicBlock (Curr),&#13;
        // a VariableDeclation (Var), and an llvm::Value (Val)&#13;
        writeLocalVariable(Curr, Var, Val);&#13;
      }&#13;
    }&#13;
  }</pre>			<p>To read and write an element, we have to generate the <code>getelementptr</code> instruction. This is added to the <code>emitExpr()</code> (reading a value) and <code>emitStmt()</code> (writing a value) methods. To read an element of an array, the value of the variable is read first. Then, the selectors of the variable are processed. For each index, the expression is evaluated and the value is stored. Based on this list, the address of the referenced element is calculated and the value is loaded:</p>&#13;
			<pre class="source-code">&#13;
    auto &amp;Selectors = Var-&gt;getSelectors();&#13;
    for (auto I = Selectors.begin(), E = Selectors.end();&#13;
         I != E; ) {&#13;
      if (auto *IdxSel =&#13;
              llvm::dyn_cast&lt;IndexSelector&gt;(*I)) {&#13;
        llvm::SmallVector&lt;llvm::Value *, 4&gt; IdxList;&#13;
        while (I != E) {&#13;
          if (auto *Sel =&#13;
                  llvm::dyn_cast&lt;IndexSelector&gt;(*I)) {&#13;
            IdxList.push_back(emitExpr(Sel-&gt;getIndex()));&#13;
            ++I;&#13;
          } else&#13;
            break;&#13;
        }&#13;
        Val = Builder.CreateInBoundsGEP(Val-&gt;getType(), Val, IdxList);&#13;
        Val = Builder.CreateLoad(&#13;
            Val-&gt;getType(), Val);&#13;
      }&#13;
      // . . . Check for additional selectors and handle&#13;
      // appropriately by generating getelementptr and load.&#13;
      else {&#13;
        llvm::report_fatal_error("Unsupported selector");&#13;
      }&#13;
    }</pre>			<p>Writing to an array element uses the same code, with the exception that you do not generate a <code>load</code> instruction. Instead, you use the pointer as the target in a <code>store</code> instruction. For records, you use a similar approach. The selector for a record member contains the constant field index, named <code>Idx</code>. You convert this constant into a constant LLVM value:</p>&#13;
			<pre class="source-code">&#13;
llvm::Value *FieldIdx = llvm::ConstantInt::get(Int32Ty, Idx);</pre>			<p>Then you can use value in the <code>Builder.CreateGEP()</code> methods as in for arrays.</p>&#13;
			<p>Now, you should know how to translate aggregate data types to LLVM IR. Passing values of those types in a system-compliant way requires some care, and you will learn to implement it correctly in the next section.</p>&#13;
			<h1 id="_idParaDest-93"><a id="_idTextAnchor095"/>Getting the application binary interface right</h1>&#13;
			<p>With the addition of arrays and records to the code generator, you can note that sometimes, the generated code does not execute as expected. The reason is that we have ignored the calling conventions of the platform so far. Each platform defines its own rules on how one function can call another function in the same program or library. These rules are summarized in the ABI documentation. Typical information includes the following:</p>&#13;
			<ul>&#13;
				<li>Are machine registers used for parameter passing? If yes, which ones?</li>&#13;
				<li>How are aggregates such as arrays and structs passed to a function?</li>&#13;
				<li>How are return values handled?</li>&#13;
			</ul>&#13;
			<p>There is a wide variety in use. On some platforms, aggregates are always passed indirectly, meaning that a copy of the aggregate is placed on the stack and only a pointer to the copy is passed as a parameter. On other platforms, a small aggregate (say 128 or 256 bit wide) is passed in registers, and only above that threshold is indirect parameter passing used. Some platforms also use floating-point and vector registers for parameter passing, while others demand that floating-point values be passed in integer registers.</p>&#13;
			<p>Of course, this is all interesting low-level stuff. Unfortunately, it leaks into LLVM IR. At first, this is surprising. After all, we define the types of all parameters of a function in LLVM IR! It turns out that this is not enough. To understand this, let’s consider complex numbers. Some languages have built-in data types for complex numbers. For example, C99 has <code>float _Complex</code> (among others). Older versions of C do not have complex number types, but you can easily define <code>struct Complex { float re, im; }</code> and create arithmetic operations on this type. Both types can be mapped to the <code>{ float, float }</code> LLVM IR type.</p>&#13;
			<p>If the ABI now states that values of a built-in, complex-number type are passed in two floating-point registers, but user-defined aggregates are always passed indirectly, then the information given with the function is not enough for LLVM to decide how to pass this particular parameter. The unfortunate consequence is that we need to provide more information to LLVM, and this information is highly ABI-specific.</p>&#13;
			<p>There are two ways to specify this information to LLVM: parameter attributes and type rewriting. What you need to use depends on the target platform and the code generator. The most commonly used parameter attributes are the following:</p>&#13;
			<ul>&#13;
				<li><code>inreg</code> specifies that the parameter is passed in a register</li>&#13;
				<li><code>byval</code> specifies that the parameter is passed by value. The parameter must be a pointer type. A hidden copy is made of the pointed-to data, and this pointer is passed to the called function.</li>&#13;
				<li><code>zeroext</code> and <code>signext</code> specify that the passed integer value should be zero or sign extended.</li>&#13;
				<li><code>sret</code> specifies that this parameter holds a pointer to memory which is used to return an aggregate type from the function.</li>&#13;
			</ul>&#13;
			<p>While all code generators support <code>zeroext</code>, <code>signext</code>, and <code>sret</code> attributes, only some support <code>inreg</code> and <code>byval</code>. An attribute can be added to the argument of a function with the <code>addAttr()</code> method. For example, to set the <code>inreg</code> attribute on argument <code>Arg</code>, you call the following:</p>&#13;
			<pre class="source-code">&#13;
Arg-&gt;addAttr(llvm::Attribute::InReg);</pre>			<p>To set multiple attributes, you can use the <code>llvm::AttrBuilder</code> class.</p>&#13;
			<p>The other way to provide additional information is to use type rewriting. With this approach, you disguise the original types. You can do the following:</p>&#13;
			<ol>&#13;
				<li>Split the parameter. For example, instead of passing one complex argument, you can pass two floating-point arguments.</li>&#13;
				<li>Cast the parameter into a different representation, such as passing a floating-point value through an integer register.</li>&#13;
			</ol>&#13;
			<p>To cast between types without changing the bits of the value, you use the <code>bitcast</code> instruction. The <code>bitcast</code> instruction can operate on simple data types such as integers and floating-point values. When floating-point values are passed via an integer register, the floating-point value must be cast to an integer. In LLVM, a 32-bit floating-point value is expressed as <code>float</code>, and a 32-bit bit integer is expressed as <code>i32</code>. The floating point value can be bitcasted to an integer in the following way:</p>&#13;
			<pre class="source-code">&#13;
%intconv = bitcast float %fp to i32</pre>			<p>Additionally, the <code>bitcast</code> instruction requires that both types have the same size.</p>&#13;
			<p>Adding attributes to an argument or changing the type is not complicated. But how do you know what you need to implement? First of all, you should get an overview of the calling convention used on your target platform. For example, the ELF ABI on Linux is documented for each supported CPU platform, so you can look up the document and make yourself comfortable with it.</p>&#13;
			<p>There is also documentation about the requirements of the LLVM code generators. The source of information is the clang implementation, which you can find at <a href="https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp">https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp</a>. This single file contains the ABI-specific actions for all supported platforms, and it is also where all information is collected.</p>&#13;
			<p>In this section, you learned to generate the IR for function calls to be compliant with the ABI of your platform. The next section covers the different ways to create IR for classes and virtual functions.</p>&#13;
			<h1 id="_idParaDest-94"><a id="_idTextAnchor096"/>Creating IR code for classes and virtual functions</h1>&#13;
			<p>Many modern programming languages support object orientation using classes. A <strong class="bold">class</strong> is a high-level language construct, and in this section, we will explore how we can map a class construct into LLVM IR.</p>&#13;
			<h2 id="_idParaDest-95"><a id="_idTextAnchor097"/>Implementing single inheritance</h2>&#13;
			<p>A class is a collection of data and methods. A class can inherit from another class, potentially adding more data fields and methods, or overriding existing virtual methods. Let’s illustrate this with classes in Oberon-2, which is also a good model for <code>tinylang</code>. A <code>Shape</code> class defines an abstract shape with a color and an area:</p>&#13;
			<pre class="source-code">&#13;
TYPE Shape = RECORD&#13;
               color: INTEGER;&#13;
               PROCEDURE (VAR s: Shape) GetColor(): INTEGER;&#13;
               PROCEDURE (VAR s: Shape) Area(): REAL;&#13;
             END;</pre>			<p>The <code>GetColor</code> method only returns the color number:</p>&#13;
			<pre class="source-code">&#13;
PROCEDURE (VAR s: Shape) GetColor(): INTEGER;&#13;
BEGIN RETURN s.color; END GetColor;</pre>			<p>The area of an abstract shape cannot be calculated, so this is an abstract method:</p>&#13;
			<pre class="source-code">&#13;
PROCEDURE (VAR s: Shape) Area(): REAL;&#13;
BEGIN HALT; END;</pre>			<p>The <code>Shape</code> type can be extended to represent a <code>Circle</code> class:</p>&#13;
			<pre class="source-code">&#13;
TYPE Circle = RECORD (Shape)&#13;
                radius: REAL;&#13;
                PROCEDURE (VAR s: Circle) Area(): REAL;&#13;
              END;</pre>			<p>For a circle, the area can be calculated:</p>&#13;
			<pre class="source-code">&#13;
PROCEDURE (VAR s: Circle) Area(): REAL;&#13;
BEGIN RETURN 2 * radius * radius; END;</pre>			<p>The type can also be queried at runtime. If the shape is a variable of type <code>Shape</code>, then we can formulate a type test in this way:</p>&#13;
			<pre class="source-code">&#13;
IF shape IS Circle THEN (* … *) END;</pre>			<p>The different syntax aside, this works much like it does in C++. One notable difference to C++ is that the Oberon-2 syntax makes the implicit <code>this</code> pointer explicit, calling it the receiver of a method.</p>&#13;
			<p>The basic problems to solve are how to lay out a class in memory and how to implement the dynamic call of methods and run time-type checking. For the memory layout, this is quite easy. The <code>Shape</code> class has only one data member, and we can map it to a corresponding LLVM structure type:</p>&#13;
			<pre class="source-code">&#13;
@Shape = type { i64 }</pre>			<p>The <code>Circle</code> class adds another data member. The solution is to append the new data member at the end:</p>&#13;
			<pre class="source-code">&#13;
@Circle = type { i64, float }</pre>			<p>The reason is that a class can have many sub-classes. With this strategy, the data member of the common base class always has the same memory offset and also uses the same index to access the field via the <code>getelementptr</code> instruction.</p>&#13;
			<p>To implement the dynamic call of a method, we must further extend the LLVM structure. If the <code>Area()</code> function is called on a <code>Shape</code> object, then the abstract method is called, causing the application to halt. If it is called on a <code>Circle</code> object, then the corresponding method to calculate the area of a circle is called. On the other hand, the <code>GetColor()</code> function can be called for objects of both classes.</p>&#13;
			<p>The basic idea to implement this is to associate a table with function pointers with each object. Here, a table would have two entries: one for the <code>GetColor()</code> method and one for the <code>Area()</code> function. The <code>Shape</code> class and the <code>Circle</code> class each have such a table. The tables differ in the entry for the <code>Area()</code> function, which calls different code depending on the type of the object. This table is called the <strong class="bold">virtual method table</strong>, often abbreviated as <strong class="bold">vtable</strong>.</p>&#13;
			<p>The vtable alone is not useful. We must connect it with an object. To do so, we always add a pointer to the vtable as the first data member to the structure. At the LLVM level, this is what becomes of the <code>@</code><code>Shape</code> type:</p>&#13;
			<pre class="source-code">&#13;
@Shape = type { ptr, i64 }</pre>			<p>The <code>@Circle</code> type is similarly extended.</p>&#13;
			<p>The resulting memory structure is shown in <em class="italic">Figure 5</em><em class="italic">.1</em>:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B19561_05_1.jpg" alt="Figure 5.1 – Memory layout of the classes and the virtual method tables" width="1137" height="238"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Memory layout of the classes and the virtual method tables</p>&#13;
			<p>In terms of LLVM IR, the vtable for the <code>Shape</code> class can be visualized as the following, where the two pointers correspond to the <code>GetColor()</code> and <code>GetArea()</code> methods, as represented in <em class="italic">Figure 5</em><em class="italic">.1</em>:</p>&#13;
			<p><code>@ShapeVTable = constant { ptr, ptr } { GetColor(), </code><code>Area() }</code></p>&#13;
			<p>Furthermore, LLVM does not have void pointers. Pointers to bytes are used instead. With the introduction of the hidden <code>vtable</code> field, there is now also the need to have a way to initialize it. In C++, this is part of calling the constructor. In Oberon-2, the field is initialized automatically when the memory is allocated.</p>&#13;
			<p>A dynamic call to a method is then executed with the following steps:</p>&#13;
			<ol>&#13;
				<li>Calculate the offset of the vtable pointer via the <code>getelementptr</code> instruction.</li>&#13;
				<li>Load the pointer to the vtable.</li>&#13;
				<li>Calculate the offset of the function in the vtable.</li>&#13;
				<li>Load the function pointer.</li>&#13;
				<li>Indirectly call the function via the pointer with the <code>call</code> instruction.</li>&#13;
			</ol>&#13;
			<p>We can visualize the dynamic call to a virtual method, such as <code>Area()</code>, within LLVM IR, as well. First, we load a pointer from the corresponding designated location of the <code>Shape</code> class. The following load represents loading the pointer to the actual vtable for <code>Shape</code>:</p>&#13;
			<pre class="source-code">&#13;
  // Load a pointer from the corresponding location.&#13;
  %ptrToShapeObj = load ptr, ...&#13;
  // Load the first element of the Shape class.&#13;
  %vtable = load ptr, ptr %ptrToShapeObj, align 8</pre>			<p>Following this, a <code>getelementptr</code> gets to the offset to call the <code>Area()</code> method:</p>&#13;
			<pre class="source-code">&#13;
%offsetToArea = getelementptr inbounds ptr, ptr %vtable, i64 1</pre>			<p>Then, we load the function pointer to <code>Area()</code>:</p>&#13;
			<pre class="source-code">&#13;
%ptrToAreaFunction = load ptr, ptr %offsetToArea, align 8</pre>			<p>Finally, the <code>Area()</code> function is called through the pointer with the call, similar to the general steps that are highlighted previously:</p>&#13;
			<pre class="source-code">&#13;
  %funcCall = call noundef float %ptrToAreaFunction(ptr noundef nonnull align 8 dereferenceable(12) %ptrToShapeObj)</pre>			<p>As we can see, even in the case of a single inheritance, the LLVM IR that is generated can appear to be very verbose. Although the general procedure of generating a dynamic call to a method does not sound very efficient, most CPU architectures can perform this dynamic call with just two instructions.</p>&#13;
			<p>Moreover, to turn a function into a method, a reference to the object’s data is required. This is implemented by passing the pointer to the data as the first parameter of the method. In Oberon-2, this is the explicit receiver. In languages similar to C++, it is the implicit <code>this</code> pointer.</p>&#13;
			<p>With the vtable, we have a unique address in memory for each class. Does this help with the <em class="italic">runtime-type test</em>, too? The answer is that it helps only in a limited way. To illustrate the problem, let’s extend the class hierarchy with an <code>Ellipse</code> class, which inherits from the <code>Circle</code> class. This is not the classical <em class="italic">is-a</em> relationship in the mathematical sense.</p>&#13;
			<p>If we have a <code>shape</code> variable of the <code>Shape</code> type, then we could implement the <code>shape IS Circle</code> type test as a comparison of the vtable pointer stored in the <code>shape</code> variable with the vtable pointer of the <code>Circle</code> class. This comparison only results in true if <code>shape</code> has the exact <code>Circle</code> type. However, if <code>shape</code> is indeed of the <code>Ellipse</code> type, then the comparison returns false, even if an object of the <code>Ellipse</code> type can be used in all places where only an object of the <code>Circle</code> type is required.</p>&#13;
			<p>Clearly, we need to do more. The solution is to extend the virtual method table with runtime-type information. How much information you need to store depends on the source language. To support the runtime-type check, it is enough to store a pointer to the vtable of the base class, which then looks like in <em class="italic">Figure 5</em><em class="italic">.2</em>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B19561_05_2.jpg" alt="Figure 5.2 – Class and vtable layout supporting simple type tests" width="1497" height="402"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Class and vtable layout supporting simple type tests</p>&#13;
			<p>If the test fails as described earlier, then the test is repeated with the pointer to the vtable of the base class. This is repeated until the test yields true or, if there is no base class, false. In contrast to calling a dynamic function, the type test is a costly operation because, in the worst-case scenario, the inheritance hierarchy is walked up to the root class.</p>&#13;
			<p>If you know the whole class hierarchy, then an efficient approach is possible: you number each member of the class hierarchy in a depth-first order. Then, the type test becomes compare-against-a-number or an interval, which can be done in constant time. In fact, that is the approach of LLVM’s own runtime-type test, which we learned about in the previous chapter.</p>&#13;
			<p>To couple runtime-type information with the vtable is a design decision, either mandated by the source language or just as an implementation detail. For example, if you need detailed runtime-type information because the source language supports reflection at runtime, and you have data types without a vtable, then coupling both is not a good idea. In C++, the coupling results in the fact that a class with virtual functions (and therefore no vtable) has no runtime-type data attached to it.</p>&#13;
			<p>Often, programming languages support interfaces which are a collection of virtual methods. Interfaces are important because they add a useful abstraction. We will look at possible implementations of interfaces in the next section.</p>&#13;
			<h2 id="_idParaDest-96"><a id="_idTextAnchor098"/>Extending single inheritance with interfaces</h2>&#13;
			<p>Languages such as <strong class="bold">Java</strong> support interfaces. An interface is a collection of abstract methods, comparable to a base class with no data members and only abstract methods defined. Interfaces pose an interesting problem because each class implementing an interface can have the corresponding method at a different position in the vtable. The reason is simply that the order of function pointers in the vtable is derived from the order of the functions in the class definition in the source language. The definition of the interface is independent of this, and different orders are the norm.</p>&#13;
			<p>Because the methods defined in an interface can have a different order, we attach a table for each implemented interface to the class. For each method of the interface, this table can specify either the index of the method in the vtable or a copy of the function pointer stored in the vtable. If a method is called on the interface, then the corresponding vtable of the interface is searched, the pointer to the function is fetched, and the method is called. Adding two <code>I1</code> and <code>I2</code> interfaces to the <code>Shape</code> class results in the following layout:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B19561_05_3.jpg" alt="Figure 5.3 – Layout of vtables for interfaces" width="1523" height="335"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Layout of vtables for interfaces</p>&#13;
			<p>The caveat lies in the fact that we have to find the right vtable. We can use an approach similar to the runtime-type test: we can perform a linear search through the list of interface vtables. We can assign a unique number to each interface (for example, a memory address) and identify this vtable using this number. The disadvantage of this scheme is obvious: calling a method through an interface takes much more time than calling the same method on the class. There is no easy mitigation for this problem.</p>&#13;
			<p>A good approach is to replace the linear search with a hash table. At compilation time, the interface that a class implements is known. Therefore, we can construct a perfect hash function, which maps the interface number to the vtable for the interface. A known unique number identifying an interface may be needed for the construction, so memory does not help, but there are other ways to compute a unique number. If the symbol names in the source are unique, then it is always possible to compute a cryptographic hash such as <code>MD5</code> of the symbol, and use the hash as the number. The calculation occurs at compile time and therefore has no runtime cost.</p>&#13;
			<p>The result is much faster than the linear search and only takes constant time. Still, it involves several arithmetic operations on a number and is slower than the method call of a class type.</p>&#13;
			<p>Usually, interfaces also take part in runtime-type tests, making the list search even longer. Of course, if the hash-table approach is implemented, then it can also be used for the runtime-type test.</p>&#13;
			<p>Some languages allow for more than one parent class. This has some interesting challenges for the implementation, and we will master this in the next section.</p>&#13;
			<h2 id="_idParaDest-97"><a id="_idTextAnchor099"/>Adding support for multiple inheritance</h2>&#13;
			<p>Multiple inheritance adds another challenge. If a class inherits from two or more base classes, then we need to combine the data members in such a way that they are still accessible from the methods. Like in the single inheritance case, the solution is to append all data members, including the hidden vtable pointers.</p>&#13;
			<p>The <code>Circle</code> class is not only a geometric shape but also a graphic object. To model this, we let the <code>Circle</code> class inherit from the <code>Shape</code> class and the <code>GraphicObj</code> class. In the class layout, the fields from the <code>Shape</code> class come first. Then, we append all fields of the <code>GraphicObj</code> class, including the hidden vtable pointer. After that, we add the new data members of the <code>Circle</code> class, resulting in the overall structure shown in <em class="italic">Figure 5</em><em class="italic">.4</em>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B19561_05_4.jpg" alt="Figure 5.4 - Layout of classes and vtables with multiple inheritance" width="1142" height="857"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 - Layout of classes and vtables with multiple inheritance</p>&#13;
			<p>This approach has several implications. There can now be several pointers to the object. A pointer to the <code>Shape</code> or <code>Circle</code> class points to the top of the object, while a pointer to a <code>GraphicObj</code> class points to inside this object, the beginning of the embedded <code>GraphicObj</code> object. This has <a id="_idIndexMarker324"/>to be taken into account when comparing pointers.</p>&#13;
			<p>Calling a virtual method is also affected. If a method is defined in the <code>GraphicObj</code> class, then this method expects the class layout of the <code>GraphicObj</code> class. If this method is not overridden in the <code>Circle</code> class, then there a two possibilities. The easy case is if the method call is done with a pointer to a <code>GraphicObj</code> instance: in this case, you look up the address of the method in the vtable of the <code>GraphicObj</code> class and call the function. The more complicated case is if you call the method with a pointer to the <code>Circle</code> class. Again, you can look up the address of the method in the vtable of the <code>Circle</code> class. The called method expects a <code>this</code> pointer to be an instance of the <code>GraphicObj</code> class, so we have to adjust that pointer, too. We can do this because we know the offset of the <code>GraphicObj</code> class inside the <code>Circle</code> class.</p>&#13;
			<p>If a <code>GrapicObj</code> method is overridden in the <code>Circle</code> class, then nothing special needs to be done if the method is called through a pointer to the <code>Circle</code> class. However, if the method is called through a pointer to a <code>GraphicObj</code> instance, then we need to make another adjustment because the method needs a <code>this</code> pointer pointing to a <code>Circle</code> instance. At compilation time, we cannot compute this adjustment because we do not know whether or not this <code>GraphicObj</code> instance is part of a multiple inheritance hierarchy. To solve this, we store the adjustment we need to make to the <code>this</code> pointer before calling the method together with each function pointer in the vtable, as in <em class="italic">Figure 5</em><em class="italic">.5</em>:</p>&#13;
			<p>&#13;
				<div>&#13;
					<img src="img/B19561_05_5.jpg" alt="Figure 5.5 – vtable with adjustments to the this pointer" width="898" height="440"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – vtable with adjustments to the this pointer</p>&#13;
			<p>A method call now <a id="_idIndexMarker325"/>becomes the following:</p>&#13;
			<ol>&#13;
				<li>Look up the function pointer in the vtable.</li>&#13;
				<li>Adjust the <code>this</code> pointer.</li>&#13;
				<li>Call the method.</li>&#13;
			</ol>&#13;
			<p>This approach can also be used for implementing interfaces. As an interface only has methods, each implemented interface adds a new vtable pointer to the object. This is easier to implement and most likely faster, but it adds overhead to each object instance.</p>&#13;
			<p>In the worst case, if your class has a single 64-bit data field but implements 10 interfaces, then your object requires 96 bytes in memory: eight bytes for the vtable pointer of the class itself, eight bytes for the data member, and 10 * 8 bytes for the vtable pointers of each interface.</p>&#13;
			<p>To support meaningful comparisons to objects and to perform runtime-type tests, we need to normalize a pointer to an object first. If we add an additional field to the vtable, containing an offset to the top of the object, then we can always adjust the pointer to point to the real object. In the vtable of the <code>Circle</code> class, this offset is 0, but not in the vtable of the embedded <code>GraphicObj</code> class. Of course, whether this needs to be implemented depends on the semantics of the source language.</p>&#13;
			<p>LLVM itself does not favor a special implementation of object-oriented features. As seen in this section, we can implement all approaches with the available LLVM data types. Additionally, as we have seen an example of LLVM IR with single inheritance, it is also worth noting that the IR can become more verbose when multiple inheritance is involved. If you want to try a new approach, then a good way is to do a prototype in C first. The required pointer manipulations are quickly translated to LLVM IR, but reasoning about the functionality is easier in a higher-level language.</p>&#13;
			<p>With the knowledge acquired in this section, you can implement the lowering of all OOP constructs commonly found in programming languages into LLVM IR in your own code generator. You have recipes on how to represent single inheritance, single inheritance with interface, or <a id="_idIndexMarker326"/>multiple inheritance in memory, and also how to implement type tests and how to look up virtual functions, which are the core concepts of OOP languages.</p>&#13;
			<h1 id="_idParaDest-98"><a id="_idTextAnchor100"/>Summary</h1>&#13;
			<p>In this chapter, you learned how to translate aggregate data types and pointers to LLVM IR code. You also learned about the intricacies of the application binary interface. Finally, you learned about the different approaches to translating classes and virtual functions to LLVM IR. With the knowledge of this chapter, you will be able to create an LLVM IR code generator for most real programming languages.</p>&#13;
			<p>In the next chapter, you will learn some advanced techniques regarding IR generation. Exception handling is fairly common in modern programming languages, and LLVM has some support for it. Attaching type information to pointers can help with certain optimizations, so we will add this, too. Last but not least, the ability to debug an application is essential for many developers, so we will also add the generation of debugging metadata to our code generator.</p>&#13;
		</div>&#13;
	</div></body></html>