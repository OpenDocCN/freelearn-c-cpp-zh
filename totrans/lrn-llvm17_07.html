<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer020">&#13;
			<h1 id="_idParaDest-89" class="chapter-number"><a id="_idTextAnchor091"/>5</h1>&#13;
			<h1 id="_idParaDest-90"><a id="_idTextAnchor092"/>IR Generation for High-Level Language Constructs</h1>&#13;
			<p>High-level languages today usually make use of aggregate data types and <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) constructs. LLVM IR has some support for aggregate data types, and OOP constructs such as classes must be implemented on their own. Adding aggregate types raises the question of how the parameters of an aggregate type are passed. Different platforms have different rules, and this is also reflected in the IR. Complying with the calling convention also ensures that system functions can <span class="No-Break">be called.</span></p>&#13;
			<p>In this chapter, you will learn how to translate aggregate data types and pointers to LLVM IR and how to pass parameters to a function in a system-compliant way. You will also learn how to implement classes and virtual functions in <span class="No-Break">LLVM IR.</span></p>&#13;
			<p>This chapter will cover the <span class="No-Break">following topics:</span></p>&#13;
			<ul>&#13;
				<li>Working with arrays, structs, <span class="No-Break">and pointers</span></li>&#13;
				<li>Getting the <strong class="bold">application binary interface</strong> <strong class="bold">(</strong><span class="No-Break"><strong class="bold">ABI)</strong></span><span class="No-Break"> right</span></li>&#13;
				<li>Creating IR code for classes and <span class="No-Break">virtual functions</span></li>&#13;
			</ul>&#13;
			<p>By the end of the chapter, you will have acquired the knowledge to create LLVM IR for aggregate data types and OOP constructs. You will also know how to pass aggregate data types according to the rules of <span class="No-Break">the platform.</span></p>&#13;
			<h1 id="_idParaDest-91"><a id="_idTextAnchor093"/>Technical requirements</h1>&#13;
			<p>The code used in this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter05"><span class="No-Break">https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter05</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-92"><a id="_idTextAnchor094"/>Working with arrays, structs, and pointers</h1>&#13;
			<p>For almost all applications, basic types such as <strong class="source-inline">INTEGER</strong> are not sufficient. For example, to represent mathematical objects such as a matrix or a complex number, you must construct new data types based on existing ones. These new data types are generally known as <strong class="bold">aggregate</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="bold">composite</strong></span><span class="No-Break">.</span></p>&#13;
			<p><strong class="bold">Arrays</strong> are a sequence of elements of the same type. In LLVM, arrays are always static, which means that the number of elements is constant. The <strong class="source-inline">tinylang</strong> type <strong class="source-inline">ARRAY [10] OF INTEGER</strong> or the C type <strong class="source-inline">long[10]</strong> is expressed in IR <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">&#13;
[10 x i64]</pre>			<p>Structures are composites of different types. In programming languages, they are often expressed with named members. For example, in <strong class="source-inline">tinylang</strong>, a structure is written as <strong class="source-inline">RECORD x: REAL; color: INTEGER; y: REAL; END;</strong> and the same structure in C is <strong class="source-inline">struct { float x; long color; float y; };</strong>. In LLVM IR, only the type names <span class="No-Break">are listed:</span></p>&#13;
			<pre class="source-code">&#13;
{ float, i64, float }</pre>			<p>To access a member, a numerical index is used. Like arrays, the first element has an index number <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>&#13;
			<p>The members of this structure are arranged in memory according to the specification in the data layout string. For more information regarding the data layout string within LLVM, <a href="B19561_04.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Basics of IR Code Generation</em>, describes <span class="No-Break">these details.</span></p>&#13;
			<p>Furthermore, if necessary, unused padding bytes are inserted. If you need to take control of the memory layout, then you can use a packed structure in which all elements have a 1-byte alignment. Within C, we utilize the <strong class="source-inline">__packed__</strong> attribute in the struct in the <span class="No-Break">following way:</span></p>&#13;
			<p><strong class="source-inline">struct __attribute__((__packed__)) { float x; long long color; float </strong><span class="No-Break"><strong class="source-inline">y; }</strong></span></p>&#13;
			<p>Likewise, the syntax within LLVM IR is slightly different and looks like <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code">&#13;
&lt;{ float, i64, float }&gt;</pre>			<p>Loaded into a register, arrays, and structs are treated as a unit. It is not possible to refer to a single element of array-valued register <strong class="source-inline">%x</strong> as <strong class="source-inline">%x[3]</strong>, for example. This is due to the SSA form because it is not possible to tell if <strong class="source-inline">%x[i]</strong> and <strong class="source-inline">%x[j]</strong> refer to the same element or not. Instead, we need special instructions to extract and insert single-element values into an array. To read the second element, we use <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code">&#13;
%el2 = extractvalue [10 x i64] %x, 1</pre>			<p>We can also update an element such as the <span class="No-Break">first one:</span></p>&#13;
			<pre class="source-code">&#13;
%xnew = insertvalue [10 x i64] %x, i64 %el2, 0</pre>			<p>Both instructions work on structures, too. For example, to access the <strong class="source-inline">color</strong> member from register <strong class="source-inline">%pt</strong>, you write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code">&#13;
%color = extractvalue { float, float, i64 } %pt, 2</pre>			<p>There exists an important limitation on both instructions: the index must be a constant. For structures, this is easily explainable. The index number is only a substitute for the name, and languages such as C have no notion of dynamically computing the name of a struct member. For arrays, it is simply that it can’t be implemented efficiently. Both instructions have value in specific cases when the number of elements is small and known. For example, a complex number could be modeled as an array of two floating-point numbers. It’s reasonable to pass this array around, and it is always clear which part of the array must be accessed during <span class="No-Break">a computation.</span></p>&#13;
			<p>For general use in the front end, we have to resort to pointers to memory. All global values in LLVM are expressed as pointers. Let’s declare a <strong class="source-inline">@arr</strong> global variable as an array of eight <strong class="source-inline">i64</strong> elements. This is the equivalent of the <strong class="source-inline">long arr[8]</strong> <span class="No-Break">C declaration:</span></p>&#13;
			<pre class="source-code">&#13;
@arr = common global [8 x i64] zeroinitializer</pre>			<p>To access the second element of the array, an address calculation must be performed to determine the address of the indexed element. Then the value can then be loaded from that address and put into a function <strong class="source-inline">@second</strong>, this looks <span class="No-Break">like this:</span></p>&#13;
			<pre class="source-code">&#13;
define i64 @second() {&#13;
  %1 = load i64, ptr getelementptr inbounds ([8 x i64], ptr @arr, i64 0, i64 1)&#13;
  ret i64 %1&#13;
}</pre>			<p>The <strong class="source-inline">getelementptr</strong> instruction is the workhorse for address calculations. As such, it needs some more explanation. The first operand, <strong class="source-inline">[8 x i64]</strong>, is the base type the instruction is operating on. The second operand, <strong class="source-inline">ptr @arr</strong>, specifies the base pointer. Please note the subtle difference here: we declared an array of eight elements, but because all global values are treated as pointers, we have a pointer to the array. In C syntax, we really work with <strong class="source-inline">long (*arr)[8]</strong>! The consequence is that we first have to dereference the pointer before we can index the element, such as <strong class="source-inline">arr[0][1]</strong> in C. The third operand, <strong class="source-inline">i64 0</strong>, dereferences the pointer, and the fourth operand, <strong class="source-inline">i64 1</strong>, is the element index. The result of this computation is the address of the indexed element. Please note that no memory is touched by <span class="No-Break">this instruction.</span></p>&#13;
			<p>Except for structs, the index parameters do not need to be constant. Therefore, the <strong class="source-inline">getelementptr</strong> instruction can be used in a loop to retrieve the elements of an array. Structs are treated differently here: only constants can be used, and the type must <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">i32</strong></span><span class="No-Break">.</span></p>&#13;
			<p>With this knowledge, arrays are easily integrated into the code generator from <a href="B19561_04.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Basics of IR Code Generation</em>. The <strong class="source-inline">convertType()</strong> method must be extended to create the type. If the <strong class="source-inline">Arr</strong> variable holds the type denoter of an array, and assuming the number of elements within an array is an integer literal, we then can add the following to the <strong class="source-inline">convertType()</strong> method to <span class="No-Break">handle arrays:</span></p>&#13;
			<pre class="source-code">&#13;
 if (auto *ArrayTy =&#13;
                 llvm::dyn_cast&lt;ArrayTypeDeclaration&gt;(Ty)) {&#13;
    llvm::Type *Component =&#13;
        convertType(ArrayTy-&gt;getType());&#13;
    Expr *Nums = ArrayTy-&gt;getNums();&#13;
    uint64_t NumElements =&#13;
        llvm::cast&lt;IntegerLiteral&gt;(Nums)&#13;
            -&gt;getValue()&#13;
            .getZExtValue();&#13;
    llvm::Type *T =&#13;
        llvm::ArrayType::get(Component, NumElements);&#13;
    // TypeCache is a mapping between the original&#13;
    // TypeDeclaration (Ty) and the current Type (T).&#13;
    return TypeCache[Ty] = T;&#13;
}</pre>			<p>This type can be used to declare global variables. For local variables, we need to allocate memory for the array. We do this in the first basic block of <span class="No-Break">the procedure:</span></p>&#13;
			<pre class="source-code">&#13;
  for (auto *D : Proc-&gt;getDecls()) {&#13;
    if (auto *Var =&#13;
            llvm::dyn_cast&lt;VariableDeclaration&gt;(D)) {&#13;
      llvm::Type *Ty = mapType(Var);&#13;
      if (Ty-&gt;isAggregateType()) {&#13;
        llvm::Value *Val = Builder.CreateAlloca(Ty);&#13;
        // The following method requires a BasicBlock (Curr),&#13;
        // a VariableDeclation (Var), and an llvm::Value (Val)&#13;
        writeLocalVariable(Curr, Var, Val);&#13;
      }&#13;
    }&#13;
  }</pre>			<p>To read and write an element, we have to generate the <strong class="source-inline">getelementptr</strong> instruction. This is added to the <strong class="source-inline">emitExpr()</strong> (reading a value) and <strong class="source-inline">emitStmt()</strong> (writing a value) methods. To read an element of an array, the value of the variable is read first. Then, the selectors of the variable are processed. For each index, the expression is evaluated and the value is stored. Based on this list, the address of the referenced element is calculated and the value <span class="No-Break">is loaded:</span></p>&#13;
			<pre class="source-code">&#13;
    auto &amp;Selectors = Var-&gt;getSelectors();&#13;
    for (auto I = Selectors.begin(), E = Selectors.end();&#13;
         I != E; ) {&#13;
      if (auto *IdxSel =&#13;
              llvm::dyn_cast&lt;IndexSelector&gt;(*I)) {&#13;
        llvm::SmallVector&lt;llvm::Value *, 4&gt; IdxList;&#13;
        while (I != E) {&#13;
          if (auto *Sel =&#13;
                  llvm::dyn_cast&lt;IndexSelector&gt;(*I)) {&#13;
            IdxList.push_back(emitExpr(Sel-&gt;getIndex()));&#13;
            ++I;&#13;
          } else&#13;
            break;&#13;
        }&#13;
        Val = Builder.CreateInBoundsGEP(Val-&gt;getType(), Val, IdxList);&#13;
        Val = Builder.CreateLoad(&#13;
            Val-&gt;getType(), Val);&#13;
      }&#13;
      // . . . Check for additional selectors and handle&#13;
      // appropriately by generating getelementptr and load.&#13;
      else {&#13;
        llvm::report_fatal_error("Unsupported selector");&#13;
      }&#13;
    }</pre>			<p>Writing to an array element uses the same code, with the exception that you do not generate a <strong class="source-inline">load</strong> instruction. Instead, you use the pointer as the target in a <strong class="source-inline">store</strong> instruction. For records, you use a similar approach. The selector for a record member contains the constant field index, named <strong class="source-inline">Idx</strong>. You convert this constant into a constant <span class="No-Break">LLVM value:</span></p>&#13;
			<pre class="source-code">&#13;
llvm::Value *FieldIdx = llvm::ConstantInt::get(Int32Ty, Idx);</pre>			<p>Then you can use value in the <strong class="source-inline">Builder.CreateGEP()</strong> methods as in <span class="No-Break">for arrays.</span></p>&#13;
			<p>Now, you should know how to translate aggregate data types to LLVM IR. Passing values of those types in a system-compliant way requires some care, and you will learn to implement it correctly in the <span class="No-Break">next section.</span></p>&#13;
			<h1 id="_idParaDest-93"><a id="_idTextAnchor095"/>Getting the application binary interface right</h1>&#13;
			<p>With the addition of arrays and records to the code generator, you can note that sometimes, the generated code does not execute as expected. The reason is that we have ignored the calling conventions of the platform so far. Each platform defines its own rules on how one function can call another function in the same program or library. These rules are summarized in the ABI documentation. Typical information includes <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li>Are machine registers used for parameter passing? If yes, <span class="No-Break">which ones?</span></li>&#13;
				<li>How are aggregates such as arrays and structs passed to <span class="No-Break">a function?</span></li>&#13;
				<li>How are return <span class="No-Break">values handled?</span></li>&#13;
			</ul>&#13;
			<p>There is a wide variety in use. On some platforms, aggregates are always passed indirectly, meaning that a copy of the aggregate is placed on the stack and only a pointer to the copy is passed as a parameter. On other platforms, a small aggregate (say 128 or 256 bit wide) is passed in registers, and only above that threshold is indirect parameter passing used. Some platforms also use floating-point and vector registers for parameter passing, while others demand that floating-point values be passed in <span class="No-Break">integer registers.</span></p>&#13;
			<p>Of course, this is all interesting low-level stuff. Unfortunately, it leaks into LLVM IR. At first, this is surprising. After all, we define the types of all parameters of a function in LLVM IR! It turns out that this is not enough. To understand this, let’s consider complex numbers. Some languages have built-in data types for complex numbers. For example, C99 has <strong class="source-inline">float _Complex</strong> (among others). Older versions of C do not have complex number types, but you can easily define <strong class="source-inline">struct Complex { float re, im; }</strong> and create arithmetic operations on this type. Both types can be mapped to the <strong class="source-inline">{ float, float }</strong> LLVM <span class="No-Break">IR type.</span></p>&#13;
			<p>If the ABI now states that values of a built-in, complex-number type are passed in two floating-point registers, but user-defined aggregates are always passed indirectly, then the information given with the function is not enough for LLVM to decide how to pass this particular parameter. The unfortunate consequence is that we need to provide more information to LLVM, and this information is <span class="No-Break">highly ABI-specific.</span></p>&#13;
			<p>There are two ways to specify this information to LLVM: parameter attributes and type rewriting. What you need to use depends on the target platform and the code generator. The most commonly used parameter attributes are <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li><strong class="source-inline">inreg</strong> specifies that the parameter is passed in <span class="No-Break">a register</span></li>&#13;
				<li><strong class="source-inline">byval</strong> specifies that the parameter is passed by value. The parameter must be a pointer type. A hidden copy is made of the pointed-to data, and this pointer is passed to the <span class="No-Break">called function.</span></li>&#13;
				<li><strong class="source-inline">zeroext</strong> and <strong class="source-inline">signext</strong> specify that the passed integer value should be zero or <span class="No-Break">sign extended.</span></li>&#13;
				<li><strong class="source-inline">sret</strong> specifies that this parameter holds a pointer to memory which is used to return an aggregate type from <span class="No-Break">the function.</span></li>&#13;
			</ul>&#13;
			<p>While all code generators support <strong class="source-inline">zeroext</strong>, <strong class="source-inline">signext</strong>, and <strong class="source-inline">sret</strong> attributes, only some support <strong class="source-inline">inreg</strong> and <strong class="source-inline">byval</strong>. An attribute can be added to the argument of a function with the <strong class="source-inline">addAttr()</strong> method. For example, to set the <strong class="source-inline">inreg</strong> attribute on argument <strong class="source-inline">Arg</strong>, you call <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code">&#13;
Arg-&gt;addAttr(llvm::Attribute::InReg);</pre>			<p>To set multiple attributes, you can use the <span class="No-Break"><strong class="source-inline">llvm::AttrBuilder</strong></span><span class="No-Break"> class.</span></p>&#13;
			<p>The other way to provide additional information is to use type rewriting. With this approach, you disguise the original types. You can do <span class="No-Break">the following:</span></p>&#13;
			<ol>&#13;
				<li>Split the parameter. For example, instead of passing one complex argument, you can pass two <span class="No-Break">floating-point arguments.</span></li>&#13;
				<li>Cast the parameter into a different representation, such as passing a floating-point value through an <span class="No-Break">integer register.</span></li>&#13;
			</ol>&#13;
			<p>To cast between types without changing the bits of the value, you use the <strong class="source-inline">bitcast</strong> instruction. The <strong class="source-inline">bitcast</strong> instruction can operate on simple data types such as integers and floating-point values. When floating-point values are passed via an integer register, the floating-point value must be cast to an integer. In LLVM, a 32-bit floating-point value is expressed as <strong class="source-inline">float</strong>, and a 32-bit bit integer is expressed as <strong class="source-inline">i32</strong>. The floating point value can be bitcasted to an integer in the <span class="No-Break">following way:</span></p>&#13;
			<pre class="source-code">&#13;
%intconv = bitcast float %fp to i32</pre>			<p>Additionally, the <strong class="source-inline">bitcast</strong> instruction requires that both types have the <span class="No-Break">same size.</span></p>&#13;
			<p>Adding attributes to an argument or changing the type is not complicated. But how do you know what you need to implement? First of all, you should get an overview of the calling convention used on your target platform. For example, the ELF ABI on Linux is documented for each supported CPU platform, so you can look up the document and make yourself comfortable <span class="No-Break">with it.</span></p>&#13;
			<p>There is also documentation about the requirements of the LLVM code generators. The source of information is the clang implementation, which you can find at <a href="https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp">https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp</a>. This single file contains the ABI-specific actions for all supported platforms, and it is also where all information <span class="No-Break">is collected.</span></p>&#13;
			<p>In this section, you learned to generate the IR for function calls to be compliant with the ABI of your platform. The next section covers the different ways to create IR for classes and <span class="No-Break">virtual functions.</span></p>&#13;
			<h1 id="_idParaDest-94"><a id="_idTextAnchor096"/>Creating IR code for classes and virtual functions</h1>&#13;
			<p>Many modern programming languages support object orientation using classes. A <strong class="bold">class</strong> is a high-level language construct, and in this section, we will explore how we can map a class construct into <span class="No-Break">LLVM IR.</span></p>&#13;
			<h2 id="_idParaDest-95"><a id="_idTextAnchor097"/>Implementing single inheritance</h2>&#13;
			<p>A class is a collection of data and methods. A class can inherit from another class, potentially adding more data fields and methods, or overriding existing virtual methods. Let’s illustrate this with classes in Oberon-2, which is also a good model for <strong class="source-inline">tinylang</strong>. A <strong class="source-inline">Shape</strong> class defines an abstract shape with a color and <span class="No-Break">an area:</span></p>&#13;
			<pre class="source-code">&#13;
TYPE Shape = RECORD&#13;
               color: INTEGER;&#13;
               PROCEDURE (VAR s: Shape) GetColor(): INTEGER;&#13;
               PROCEDURE (VAR s: Shape) Area(): REAL;&#13;
             END;</pre>			<p>The <strong class="source-inline">GetColor</strong> method only returns the <span class="No-Break">color number:</span></p>&#13;
			<pre class="source-code">&#13;
PROCEDURE (VAR s: Shape) GetColor(): INTEGER;&#13;
BEGIN RETURN s.color; END GetColor;</pre>			<p>The area of an abstract shape cannot be calculated, so this is an <span class="No-Break">abstract method:</span></p>&#13;
			<pre class="source-code">&#13;
PROCEDURE (VAR s: Shape) Area(): REAL;&#13;
BEGIN HALT; END;</pre>			<p>The <strong class="source-inline">Shape</strong> type can be extended to represent a <span class="No-Break"><strong class="source-inline">Circle</strong></span><span class="No-Break"> class:</span></p>&#13;
			<pre class="source-code">&#13;
TYPE Circle = RECORD (Shape)&#13;
                radius: REAL;&#13;
                PROCEDURE (VAR s: Circle) Area(): REAL;&#13;
              END;</pre>			<p>For a circle, the area can <span class="No-Break">be calculated:</span></p>&#13;
			<pre class="source-code">&#13;
PROCEDURE (VAR s: Circle) Area(): REAL;&#13;
BEGIN RETURN 2 * radius * radius; END;</pre>			<p>The type can also be queried at runtime. If the shape is a variable of type <strong class="source-inline">Shape</strong>, then we can formulate a type test in <span class="No-Break">this way:</span></p>&#13;
			<pre class="source-code">&#13;
IF shape IS Circle THEN (* … *) END;</pre>			<p>The different syntax aside, this works much like it does in C++. One notable difference to C++ is that the Oberon-2 syntax makes the implicit <strong class="source-inline">this</strong> pointer explicit, calling it the receiver of <span class="No-Break">a method.</span></p>&#13;
			<p>The basic problems to solve are how to lay out a class in memory and how to implement the dynamic call of methods and run time-type checking. For the memory layout, this is quite easy. The <strong class="source-inline">Shape</strong> class has only one data member, and we can map it to a corresponding LLVM <span class="No-Break">structure type:</span></p>&#13;
			<pre class="source-code">&#13;
@Shape = type { i64 }</pre>			<p>The <strong class="source-inline">Circle</strong> class adds another data member. The solution is to append the new data member at <span class="No-Break">the end:</span></p>&#13;
			<pre class="source-code">&#13;
@Circle = type { i64, float }</pre>			<p>The reason is that a class can have many sub-classes. With this strategy, the data member of the common base class always has the same memory offset and also uses the same index to access the field via the <span class="No-Break"><strong class="source-inline">getelementptr</strong></span><span class="No-Break"> instruction.</span></p>&#13;
			<p>To implement the dynamic call of a method, we must further extend the LLVM structure. If the <strong class="source-inline">Area()</strong> function is called on a <strong class="source-inline">Shape</strong> object, then the abstract method is called, causing the application to halt. If it is called on a <strong class="source-inline">Circle</strong> object, then the corresponding method to calculate the area of a circle is called. On the other hand, the <strong class="source-inline">GetColor()</strong> function can be called for objects of <span class="No-Break">both classes.</span></p>&#13;
			<p>The basic idea to implement this is to associate a table with function pointers with each object. Here, a table would have two entries: one for the <strong class="source-inline">GetColor()</strong> method and one for the <strong class="source-inline">Area()</strong> function. The <strong class="source-inline">Shape</strong> class and the <strong class="source-inline">Circle</strong> class each have such a table. The tables differ in the entry for the <strong class="source-inline">Area()</strong> function, which calls different code depending on the type of the object. This table is called the <strong class="bold">virtual method table</strong>, often abbreviated <span class="No-Break">as </span><span class="No-Break"><strong class="bold">vtable</strong></span><span class="No-Break">.</span></p>&#13;
			<p>The vtable alone is not useful. We must connect it with an object. To do so, we always add a pointer to the vtable as the first data member to the structure. At the LLVM level, this is what becomes of the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Shape</strong></span><span class="No-Break"> type:</span></p>&#13;
			<pre class="source-code">&#13;
@Shape = type { ptr, i64 }</pre>			<p>The <strong class="source-inline">@Circle</strong> type is <span class="No-Break">similarly extended.</span></p>&#13;
			<p>The resulting memory structure is shown in <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer015" class="IMG---Figure">&#13;
					<img src="Images/B19561_05_1.jpg" alt="Figure 5.1 – Memory layout of the classes and the virtual method tables" width="1137" height="238"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Memory layout of the classes and the virtual method tables</p>&#13;
			<p>In terms of LLVM IR, the vtable for the <strong class="source-inline">Shape</strong> class can be visualized as the following, where the two pointers correspond to the <strong class="source-inline">GetColor()</strong> and <strong class="source-inline">GetArea()</strong> methods, as represented in <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>&#13;
			<p><strong class="source-inline">@ShapeVTable = constant { ptr, ptr } { GetColor(), </strong><span class="No-Break"><strong class="source-inline">Area() }</strong></span></p>&#13;
			<p>Furthermore, LLVM does not have void pointers. Pointers to bytes are used instead. With the introduction of the hidden <strong class="source-inline">vtable</strong> field, there is now also the need to have a way to initialize it. In C++, this is part of calling the constructor. In Oberon-2, the field is initialized automatically when the memory <span class="No-Break">is allocated.</span></p>&#13;
			<p>A dynamic call to a method is then executed with the <span class="No-Break">following steps:</span></p>&#13;
			<ol>&#13;
				<li>Calculate the offset of the vtable pointer via the <span class="No-Break"><strong class="source-inline">getelementptr</strong></span><span class="No-Break"> instruction.</span></li>&#13;
				<li>Load the pointer to <span class="No-Break">the vtable.</span></li>&#13;
				<li>Calculate the offset of the function in <span class="No-Break">the vtable.</span></li>&#13;
				<li>Load the <span class="No-Break">function pointer.</span></li>&#13;
				<li>Indirectly call the function via the pointer with the <span class="No-Break"><strong class="source-inline">call</strong></span><span class="No-Break"> instruction.</span></li>&#13;
			</ol>&#13;
			<p>We can visualize the dynamic call to a virtual method, such as <strong class="source-inline">Area()</strong>, within LLVM IR, as well. First, we load a pointer from the corresponding designated location of the <strong class="source-inline">Shape</strong> class. The following load represents loading the pointer to the actual vtable <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Shape</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code">&#13;
  // Load a pointer from the corresponding location.&#13;
  %ptrToShapeObj = load ptr, ...&#13;
  // Load the first element of the Shape class.&#13;
  %vtable = load ptr, ptr %ptrToShapeObj, align 8</pre>			<p>Following this, a <strong class="source-inline">getelementptr</strong> gets to the offset to call the <span class="No-Break"><strong class="source-inline">Area()</strong></span><span class="No-Break"> method:</span></p>&#13;
			<pre class="source-code">&#13;
%offsetToArea = getelementptr inbounds ptr, ptr %vtable, i64 1</pre>			<p>Then, we load the function pointer <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Area()</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code">&#13;
%ptrToAreaFunction = load ptr, ptr %offsetToArea, align 8</pre>			<p>Finally, the <strong class="source-inline">Area()</strong> function is called through the pointer with the call, similar to the general steps that are <span class="No-Break">highlighted previously:</span></p>&#13;
			<pre class="source-code">&#13;
  %funcCall = call noundef float %ptrToAreaFunction(ptr noundef nonnull align 8 dereferenceable(12) %ptrToShapeObj)</pre>			<p>As we can see, even in the case of a single inheritance, the LLVM IR that is generated can appear to be very verbose. Although the general procedure of generating a dynamic call to a method does not sound very efficient, most CPU architectures can perform this dynamic call with just <span class="No-Break">two instructions.</span></p>&#13;
			<p>Moreover, to turn a function into a method, a reference to the object’s data is required. This is implemented by passing the pointer to the data as the first parameter of the method. In Oberon-2, this is the explicit receiver. In languages similar to C++, it is the implicit <span class="No-Break"><strong class="source-inline">this</strong></span><span class="No-Break"> pointer.</span></p>&#13;
			<p>With the vtable, we have a unique address in memory for each class. Does this help with the <em class="italic">runtime-type test</em>, too? The answer is that it helps only in a limited way. To illustrate the problem, let’s extend the class hierarchy with an <strong class="source-inline">Ellipse</strong> class, which inherits from the <strong class="source-inline">Circle</strong> class. This is not the classical <em class="italic">is-a</em> relationship in the <span class="No-Break">mathematical sense.</span></p>&#13;
			<p>If we have a <strong class="source-inline">shape</strong> variable of the <strong class="source-inline">Shape</strong> type, then we could implement the <strong class="source-inline">shape IS Circle</strong> type test as a comparison of the vtable pointer stored in the <strong class="source-inline">shape</strong> variable with the vtable pointer of the <strong class="source-inline">Circle</strong> class. This comparison only results in true if <strong class="source-inline">shape</strong> has the exact <strong class="source-inline">Circle</strong> type. However, if <strong class="source-inline">shape</strong> is indeed of the <strong class="source-inline">Ellipse</strong> type, then the comparison returns false, even if an object of the <strong class="source-inline">Ellipse</strong> type can be used in all places where only an object of the <strong class="source-inline">Circle</strong> type <span class="No-Break">is required.</span></p>&#13;
			<p>Clearly, we need to do more. The solution is to extend the virtual method table with runtime-type information. How much information you need to store depends on the source language. To support the runtime-type check, it is enough to store a pointer to the vtable of the base class, which then looks like in <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer016" class="IMG---Figure">&#13;
					<img src="Images/B19561_05_2.jpg" alt="Figure 5.2 – Class and vtable layout supporting simple type tests" width="1497" height="402"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Class and vtable layout supporting simple type tests</p>&#13;
			<p>If the test fails as described earlier, then the test is repeated with the pointer to the vtable of the base class. This is repeated until the test yields true or, if there is no base class, false. In contrast to calling a dynamic function, the type test is a costly operation because, in the worst-case scenario, the inheritance hierarchy is walked up to the <span class="No-Break">root class.</span></p>&#13;
			<p>If you know the whole class hierarchy, then an efficient approach is possible: you number each member of the class hierarchy in a depth-first order. Then, the type test becomes compare-against-a-number or an interval, which can be done in constant time. In fact, that is the approach of LLVM’s own runtime-type test, which we learned about in the <span class="No-Break">previous chapter.</span></p>&#13;
			<p>To couple runtime-type information with the vtable is a design decision, either mandated by the source language or just as an implementation detail. For example, if you need detailed runtime-type information because the source language supports reflection at runtime, and you have data types without a vtable, then coupling both is not a good idea. In C++, the coupling results in the fact that a class with virtual functions (and therefore no vtable) has no runtime-type data attached <span class="No-Break">to it.</span></p>&#13;
			<p>Often, programming languages support interfaces which are a collection of virtual methods. Interfaces are important because they add a useful abstraction. We will look at possible implementations of interfaces in the <span class="No-Break">next section.</span></p>&#13;
			<h2 id="_idParaDest-96"><a id="_idTextAnchor098"/>Extending single inheritance with interfaces</h2>&#13;
			<p>Languages such as <strong class="bold">Java</strong> support interfaces. An interface is a collection of abstract methods, comparable to a base class with no data members and only abstract methods defined. Interfaces pose an interesting problem because each class implementing an interface can have the corresponding method at a different position in the vtable. The reason is simply that the order of function pointers in the vtable is derived from the order of the functions in the class definition in the source language. The definition of the interface is independent of this, and different orders are <span class="No-Break">the norm.</span></p>&#13;
			<p>Because the methods defined in an interface can have a different order, we attach a table for each implemented interface to the class. For each method of the interface, this table can specify either the index of the method in the vtable or a copy of the function pointer stored in the vtable. If a method is called on the interface, then the corresponding vtable of the interface is searched, the pointer to the function is fetched, and the method is called. Adding two <strong class="source-inline">I1</strong> and <strong class="source-inline">I2</strong> interfaces to the <strong class="source-inline">Shape</strong> class results in the <span class="No-Break">following layout:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer017" class="IMG---Figure">&#13;
					<img src="Images/B19561_05_3.jpg" alt="Figure 5.3 – Layout of vtables for interfaces" width="1523" height="335"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Layout of vtables for interfaces</p>&#13;
			<p>The caveat lies in the fact that we have to find the right vtable. We can use an approach similar to the runtime-type test: we can perform a linear search through the list of interface vtables. We can assign a unique number to each interface (for example, a memory address) and identify this vtable using this number. The disadvantage of this scheme is obvious: calling a method through an interface takes much more time than calling the same method on the class. There is no easy mitigation for <span class="No-Break">this problem.</span></p>&#13;
			<p>A good approach is to replace the linear search with a hash table. At compilation time, the interface that a class implements is known. Therefore, we can construct a perfect hash function, which maps the interface number to the vtable for the interface. A known unique number identifying an interface may be needed for the construction, so memory does not help, but there are other ways to compute a unique number. If the symbol names in the source are unique, then it is always possible to compute a cryptographic hash such as <strong class="source-inline">MD5</strong> of the symbol, and use the hash as the number. The calculation occurs at compile time and therefore has no <span class="No-Break">runtime cost.</span></p>&#13;
			<p>The result is much faster than the linear search and only takes constant time. Still, it involves several arithmetic operations on a number and is slower than the method call of a <span class="No-Break">class type.</span></p>&#13;
			<p>Usually, interfaces also take part in runtime-type tests, making the list search even longer. Of course, if the hash-table approach is implemented, then it can also be used for the <span class="No-Break">runtime-type test.</span></p>&#13;
			<p>Some languages allow for more than one parent class. This has some interesting challenges for the implementation, and we will master this in the <span class="No-Break">next section.</span></p>&#13;
			<h2 id="_idParaDest-97"><a id="_idTextAnchor099"/>Adding support for multiple inheritance</h2>&#13;
			<p>Multiple inheritance adds another challenge. If a class inherits from two or more base classes, then we need to combine the data members in such a way that they are still accessible from the methods. Like in the single inheritance case, the solution is to append all data members, including the hidden <span class="No-Break">vtable pointers.</span></p>&#13;
			<p>The <strong class="source-inline">Circle</strong> class is not only a geometric shape but also a graphic object. To model this, we let the <strong class="source-inline">Circle</strong> class inherit from the <strong class="source-inline">Shape</strong> class and the <strong class="source-inline">GraphicObj</strong> class. In the class layout, the fields from the <strong class="source-inline">Shape</strong> class come first. Then, we append all fields of the <strong class="source-inline">GraphicObj</strong> class, including the hidden vtable pointer. After that, we add the new data members of the <strong class="source-inline">Circle</strong> class, resulting in the overall structure shown in <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer018" class="IMG---Figure">&#13;
					<img src="Images/B19561_05_4.jpg" alt="Figure 5.4 - Layout of classes and vtables with multiple inheritance" width="1142" height="857"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 - Layout of classes and vtables with multiple inheritance</p>&#13;
			<p>This approach has several implications. There can now be several pointers to the object. A pointer to the <strong class="source-inline">Shape</strong> or <strong class="source-inline">Circle</strong> class points to the top of the object, while a pointer to a <strong class="source-inline">GraphicObj</strong> class points to inside this object, the beginning of the embedded <strong class="source-inline">GraphicObj</strong> object. This has <a id="_idIndexMarker324"/>to be taken into account when <span class="No-Break">comparing pointers.</span></p>&#13;
			<p>Calling a virtual method is also affected. If a method is defined in the <strong class="source-inline">GraphicObj</strong> class, then this method expects the class layout of the <strong class="source-inline">GraphicObj</strong> class. If this method is not overridden in the <strong class="source-inline">Circle</strong> class, then there a two possibilities. The easy case is if the method call is done with a pointer to a <strong class="source-inline">GraphicObj</strong> instance: in this case, you look up the address of the method in the vtable of the <strong class="source-inline">GraphicObj</strong> class and call the function. The more complicated case is if you call the method with a pointer to the <strong class="source-inline">Circle</strong> class. Again, you can look up the address of the method in the vtable of the <strong class="source-inline">Circle</strong> class. The called method expects a <strong class="source-inline">this</strong> pointer to be an instance of the <strong class="source-inline">GraphicObj</strong> class, so we have to adjust that pointer, too. We can do this because we know the offset of the <strong class="source-inline">GraphicObj</strong> class inside the <span class="No-Break"><strong class="source-inline">Circle</strong></span><span class="No-Break"> class.</span></p>&#13;
			<p>If a <strong class="source-inline">GrapicObj</strong> method is overridden in the <strong class="source-inline">Circle</strong> class, then nothing special needs to be done if the method is called through a pointer to the <strong class="source-inline">Circle</strong> class. However, if the method is called through a pointer to a <strong class="source-inline">GraphicObj</strong> instance, then we need to make another adjustment because the method needs a <strong class="source-inline">this</strong> pointer pointing to a <strong class="source-inline">Circle</strong> instance. At compilation time, we cannot compute this adjustment because we do not know whether or not this <strong class="source-inline">GraphicObj</strong> instance is part of a multiple inheritance hierarchy. To solve this, we store the adjustment we need to make to the <strong class="source-inline">this</strong> pointer before calling the method together with each function pointer in the vtable, as in <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer019" class="IMG---Figure">&#13;
					<img src="Images/B19561_05_5.jpg" alt="Figure 5.5 – vtable with adjustments to the this pointer" width="898" height="440"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – vtable with adjustments to the this pointer</p>&#13;
			<p>A method call now <a id="_idIndexMarker325"/>becomes <span class="No-Break">the following:</span></p>&#13;
			<ol>&#13;
				<li>Look up the function pointer in <span class="No-Break">the vtable.</span></li>&#13;
				<li>Adjust the <span class="No-Break"><strong class="source-inline">this</strong></span><span class="No-Break"> pointer.</span></li>&#13;
				<li>Call <span class="No-Break">the method.</span></li>&#13;
			</ol>&#13;
			<p>This approach can also be used for implementing interfaces. As an interface only has methods, each implemented interface adds a new vtable pointer to the object. This is easier to implement and most likely faster, but it adds overhead to each <span class="No-Break">object instance.</span></p>&#13;
			<p>In the worst case, if your class has a single 64-bit data field but implements 10 interfaces, then your object requires 96 bytes in memory: eight bytes for the vtable pointer of the class itself, eight bytes for the data member, and 10 * 8 bytes for the vtable pointers of <span class="No-Break">each interface.</span></p>&#13;
			<p>To support meaningful comparisons to objects and to perform runtime-type tests, we need to normalize a pointer to an object first. If we add an additional field to the vtable, containing an offset to the top of the object, then we can always adjust the pointer to point to the real object. In the vtable of the <strong class="source-inline">Circle</strong> class, this offset is 0, but not in the vtable of the embedded <strong class="source-inline">GraphicObj</strong> class. Of course, whether this needs to be implemented depends on the semantics of the <span class="No-Break">source language.</span></p>&#13;
			<p>LLVM itself does not favor a special implementation of object-oriented features. As seen in this section, we can implement all approaches with the available LLVM data types. Additionally, as we have seen an example of LLVM IR with single inheritance, it is also worth noting that the IR can become more verbose when multiple inheritance is involved. If you want to try a new approach, then a good way is to do a prototype in C first. The required pointer manipulations are quickly translated to LLVM IR, but reasoning about the functionality is easier in a <span class="No-Break">higher-level language.</span></p>&#13;
			<p>With the knowledge acquired in this section, you can implement the lowering of all OOP constructs commonly found in programming languages into LLVM IR in your own code generator. You have recipes on how to represent single inheritance, single inheritance with interface, or <a id="_idIndexMarker326"/>multiple inheritance in memory, and also how to implement type tests and how to look up virtual functions, which are the core concepts of <span class="No-Break">OOP languages.</span></p>&#13;
			<h1 id="_idParaDest-98"><a id="_idTextAnchor100"/>Summary</h1>&#13;
			<p>In this chapter, you learned how to translate aggregate data types and pointers to LLVM IR code. You also learned about the intricacies of the application binary interface. Finally, you learned about the different approaches to translating classes and virtual functions to LLVM IR. With the knowledge of this chapter, you will be able to create an LLVM IR code generator for most real <span class="No-Break">programming languages.</span></p>&#13;
			<p>In the next chapter, you will learn some advanced techniques regarding IR generation. Exception handling is fairly common in modern programming languages, and LLVM has some support for it. Attaching type information to pointers can help with certain optimizations, so we will add this, too. Last but not least, the ability to debug an application is essential for many developers, so we will also add the generation of debugging metadata to our <span class="No-Break">code generator.</span></p>&#13;
		</div>&#13;
	</div></body></html>