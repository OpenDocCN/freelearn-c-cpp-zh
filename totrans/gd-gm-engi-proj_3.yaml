- en: Escape the Maze
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逃离迷宫
- en: In the previous chapter, you learned how Godot's node system works, allowing
    you to build a complex scene out of smaller building blocks, each providing different
    functionalities for your game's objects. This process will continue as you move
    up to larger and more complex projects. However, sometimes you'll find yourself
    duplicating the same nodes and/or code in more than one different object, and
    this project will introduce some techniques for reducing the amount of repeated
    code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了 Godot 的节点系统如何工作，允许您使用更小的构建块构建复杂的场景，每个构建块都为您的游戏对象提供不同的功能。随着您进入更大、更复杂的项目，这个过程将继续。然而，有时您可能会在多个不同的对象中重复相同的节点和/或代码，本项目将介绍一些减少重复代码的技术。
- en: 'In this chapter, you''ll build a game called **Escape the Maze**. In this game,
    you will be trying to navigate a maze to find the exit while avoiding the roaming
    enemies:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将构建一个名为 **逃离迷宫** 的游戏。在这个游戏中，您将尝试在迷宫中导航以找到出口，同时避开游走的敌人：
- en: '![](img/00042.jpeg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00042.jpeg)'
- en: 'You will learn about the following key topics in this project:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，您将学习以下关键主题：
- en: Inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Grid-based movement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于网格的移动
- en: Spritesheet animation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spritesheet 动画
- en: Using TileMaps for level design
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TileMaps 进行关卡设计
- en: Transitioning between scenes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景之间的转换
- en: Project setup
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: Create a new project and download the project assets from [https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目，并从 [https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases)
    下载项目资源。
- en: As you've seen previously, Godot, by default, includes a number of input actions
    mapped to various keyboard inputs. For example, you used `ui_left` and `ui_right`
    for arrow key movement in the first project. Often, however, you need a different
    input from the defaults provided, or you'd like to customize the actions' names.
    You might also wish to add actions for mouse or gamepad inputs. You can do this
    in the Project Settings window.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所见，Godot 默认包含了一系列映射到各种键盘输入的动作。例如，在第一个项目中，您使用了 `ui_left` 和 `ui_right` 来进行箭头键移动。然而，通常您需要不同的输入，或者您想自定义动作的名称。您可能还希望添加鼠标或游戏手柄的输入动作。您可以在项目设置窗口中完成这些操作。
- en: 'Click on the Input Map tab and add four new input actions (left, right, up,
    and down) by typing the names into the Action: box and clicking Add. Then, for
    each new action, click the + button to add a Key action and choose the corresponding
    arrow key. You can also add WASD controls, if you wish:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '点击 Input Map 选项卡，通过在 Action: 框中输入名称并点击 Add 添加四个新的输入动作（左、右、上、下）。然后，对于每个新动作，点击
    + 按钮添加一个键动作并选择相应的箭头键。如果您愿意，还可以添加 WASD 控制：'
- en: '![](img/00043.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00043.jpeg)'
- en: This game will have a variety of objects on the screen. Some of them should
    detect collisions (the player against the walls, for example), while others should
    ignore one another (like the enemies versus coins). You can solve this by setting
    the objects' physics layer and physics layer mask properties. To make these layers
    easier to work with, Godot allows you to give the game's physics layers custom
    names.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏将在屏幕上显示各种对象。其中一些对象应该检测碰撞（例如玩家与墙壁之间的碰撞），而其他对象应该相互忽略（例如敌人与金币之间的碰撞）。您可以通过设置对象的物理层和物理层掩码属性来解决此问题。为了使这些层更容易操作，Godot
    允许您为游戏物理层指定自定义名称。
- en: 'Click on the General tab and find the Layer Names/2D Physics section. Name
    the first four layers as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 General 选项卡，找到 Layer Names/2D Physics 部分。将前四个层命名为以下内容：
- en: '![](img/00044.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00044.jpeg)'
- en: You'll see how the collision layer system works with the various objects in
    the game later in the project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在项目后期看到碰撞层系统如何与游戏中的各种对象协同工作。
- en: 'Next, in the Display/Window section, set the Mode to viewport and the Aspect
    to keep. This will enable you to resize the game window while keeping the display''s
    proportions unchanged. Refer to the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 Display/Window 部分，将 Mode 设置为 viewport，将 Aspect 设置为 keep。这将使您能够在保持显示比例不变的情况下调整游戏窗口的大小。请参考以下截图：
- en: '![](img/00045.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00045.jpeg)'
- en: 'Finally, in the Rendering/Quality section, set Use Pixel Snap to On. This setting
    is useful, especially for pixel art-styled games, as it ensures that all objects
    are drawn at whole-number pixel values. Note that this does not affect movement,
    physics, or other properties; it only applies to the rendering of objects. Refer
    to the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 渲染/质量 部分，将 使用像素捕捉 设置为开启。此设置非常有用，特别是对于像素艺术风格的游戏，因为它确保所有对象都以整数像素值绘制。请注意，这 不会影响移动、物理或其他属性；它仅适用于对象的渲染。请参考以下截图：
- en: '![](img/00046.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00046.jpeg)'
- en: Project organization
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目组织
- en: As your projects become larger and more involved, you'll find that saving all
    of your scenes and scripts in the same folder becomes unwieldy.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的项目变得更大、更复杂，你会发现将所有场景和脚本保存在同一个文件夹中变得难以管理。
- en: A common response to this by Godot beginners is to make a `scenes` folder and
    a `scripts` folder, and to save each type of file in the respective folder. This
    isn't very effective. Soon, you find yourself hunting through the `scripts` folder,
    looking for the script you need because it's jumbled up with all the other scripts
    of your game.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 初学者通常对此的反应是创建一个 `scenes` 文件夹和一个 `scripts` 文件夹，并将每种类型的文件保存在相应的文件夹中。这并不很有效。很快，你就会发现自己正在
    `scripts` 文件夹中寻找需要的脚本，因为它与其他所有游戏脚本混在一起。
- en: 'A more logical organization is to create a folder for each type of object.
    A `player` folder, for example, will hold the player''s scene file, script(s),
    and any other resources that it needs. Organizing your project in this way is
    much more scalable and can be extended even further if you have a very large number
    of objects. For example, refer to the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更合理的组织方式是为每种类型的对象创建一个文件夹。例如，一个 `player` 文件夹将包含玩家的场景文件、脚本（们）以及它需要的任何其他资源。以这种方式组织你的项目更具可扩展性，如果你有大量对象，还可以进一步扩展。例如，请参考以下截图：
- en: '![](img/00047.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00047.jpeg)'
- en: Throughout this project, the examples will assume that each new scene type is
    being saved in a folder of that type, along with its script. The `Player.tscn`
    and `Player.gd` files, for example, will be saved in a `player` folder.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个项目中，示例将假设每个新的场景类型都保存在该类型的文件夹中，包括其脚本。例如，`Player.tscn` 和 `Player.gd` 文件将保存在一个
    `player` 文件夹中。
- en: Inheritance
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: In **Object-Oriented Programming** (**OOP**), inheritance is a powerful tool.
    Put briefly, you can define a class that *inherits* from another class. An object
    created using the first class will contain all of the methods and member variables
    of the master class as well as its own.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **面向对象编程**（**OOP**）中，继承是一个强大的工具。简要来说，你可以定义一个从另一个类继承的类。使用第一个类创建的对象将包含主类的所有方法和成员变量，以及它自己的。
- en: Godot is strongly object-oriented, and this gives you the opportunity to use
    inheritance not just with objects (scripts) but also with scenes, allowing you
    a great deal of flexibility when designing your game's architecture. It also removes
    the need to duplicate code—if two objects need to share a set of methods and variables,
    for example, you can create a common script and let both objects inherit from
    it. If you make a change to that code, it will apply to both objects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 是强面向对象的，这给了你使用继承的机会，不仅限于对象（脚本），还可以用于场景，这在你设计游戏架构时提供了很大的灵活性。它还消除了代码重复的需要——如果两个对象需要共享一组方法和变量，例如，你可以创建一个公共脚本，并让两个对象从它继承。如果你修改了那段代码，它将应用到两个对象上。
- en: 'In this project, the player''s character will be controlled by key events,
    while the mobs will wander around the maze randomly. However, both types of character
    need to have a number of properties and functions in common:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，玩家的角色将由按键事件控制，而怪物将在迷宫中随机游荡。然而，这两种类型的角色都需要一些共同的属性和功能：
- en: A spritesheet containing the four directional movement animations
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含四个方向移动动画的精灵图集
- en: An `AnimationPlayer` to play the movement animations
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于播放动作动画的 `AnimationPlayer`
- en: Grid-based movement (the character can only move one full *tile* at a time)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于网格的移动（角色每次只能移动一个完整的 *方块*）
- en: Collision detection (the character can't move through walls)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测（角色不能穿过墙壁）
- en: By using inheritance, you can create a generic `Character` scene containing
    the nodes that all characters need. The player and mob scenes can inherit the
    shared nodes from that scene. Similarly, the actual movement code (though not
    the controls) will be identical between player and mob, so they can both inherit
    from the same script to handle movement.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用继承，您可以创建一个包含所有角色所需的节点的通用`Character`场景。玩家和怪物场景可以从中继承共享节点。同样，实际的运动代码（尽管不是控制）在玩家和怪物之间将是相同的，因此它们都可以从相同的脚本中继承以处理运动。
- en: Character scene
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色场景
- en: Start creating the `Character` scene by adding an `Area2D` and naming it `Character`.
    `Area2D` is a good choice for this type of character because its main function
    will be to detect overlaps—when it moves onto an item or enemy, for example.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个名为`Character`的`Area2D`并命名它来开始创建`Character`场景。`Area2D`是这类角色的好选择，因为其主要功能将是检测重叠——例如，当它移动到物品或敌人上时。
- en: 'Add the following children:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下子项：
- en: '`Sprite`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite`'
- en: '`CollisionShape2D`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollisionShape2D`'
- en: '`Tween` (named `MoveTween`)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tween`（命名为`MoveTween`）'
- en: '`AnimationPlayer`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnimationPlayer`'
- en: Leave the `Sprite` without a texture, but in the Inspector, under the Animation
    section of the `Sprite`, set its Vframes and Hframes properties to `4` and `5`,
    respectively. This tells Godot to slice the texture into a 5 x 4 grid of individual
    images.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Sprite`上不添加纹理，但在检查器中，在`Sprite`的动画部分，将Vframes和Hframes属性分别设置为`4`和`5`。这告诉Godot将纹理切割成5
    x 4个单独图像的网格。
- en: 'The spritesheets you''ll use for the player and the enemy are arranged in exactly
    this pattern, with each row containing the animation frames for a single direction
    of movement:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您将用于玩家和敌人的精灵表将按照完全相同的模式排列，每一行包含一个移动方向的动画帧：
- en: '![](img/00048.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00048.jpeg)'
- en: 'When a spritesheet has been sliced using the Vframes and Hframes properties,
    you can use the Frame property to set which individual frame to use. In the preceding
    player sheet, the left-facing animation would use frames 5 through 9 (counting
    from frame 0 in the upper-left corner). You''ll use an `AnimationPlayer` to change
    the Frame property below. Refer to the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Vframes和Hframes属性切割了精灵表后，您可以使用Frame属性来设置要使用的单个帧。在上面的玩家表中，面向左侧的动画将使用从左上角开始的第5帧到第9帧（从0开始计数）。您将使用`AnimationPlayer`来更改下面的Frame属性。参考以下截图：
- en: '![](img/00049.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00049.jpeg)'
- en: Next, create a new `RectangleShape2D` in the collision shape's Shape. Click
    on the new <RectangleShape2D> and set its Extents property in the Inspector to
    `(16, 16)`. Note that Extents measures the distance from the center in each direction,
    so this results in a collision shape that is 32 by 32 pixels.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在碰撞形状的Shape中创建一个新的`RectangleShape2D`。点击新的`RectangleShape2D`，并在检查器中将它的Extents属性设置为`(16,
    16)`。请注意，Extents测量每个方向从中心点的距离，因此这会产生一个32 x 32像素的碰撞形状。
- en: Because all the characters are drawn to the same scale, we can be confident
    that the same sized collision shape will work for all characters. If this isn’t
    the case with the art you’re using, you can skip setting the collision shape here
    and configure it later for the individual inherited scenes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有角色都以相同的比例绘制，我们可以确信相同大小的碰撞形状适用于所有角色。如果使用您使用的艺术作品中这种情况不成立，您可以在此处跳过设置碰撞形状，并在稍后为单个继承场景进行配置。
- en: Animations
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画
- en: 'Create four new animations in the `AnimationPlayer` node. Name them to match
    the four directions you used in the input actions (left, right, up, and down).
    It''s important that the spelling matches here: the names of the input actions
    must have the same spelling and capitalization as the animation names. If you
    are inconsistent in naming, it will make things much more difficult when you get
    to the scripting stage. Take a look at the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AnimationPlayer`节点中创建四个新的动画。将它们命名为与输入动作中使用的四个方向（左、右、上和下）相匹配。在这里拼写非常重要：输入动作的名称必须与动画名称具有相同的拼写和大小写。如果您在命名上不一致，当您到达脚本阶段时，这会使事情变得困难得多。请参考以下截图：
- en: '![](img/00050.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00050.jpeg)'
- en: 'For each animation, set the Length to `1` and the Step to `0.2`. These properties
    are located at the bottom of the Animation panel:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个动画，将`Length`设置为`1`，将`Step`设置为`0.2`。这些属性位于动画面板的底部：
- en: '![](img/00051.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00051.jpeg)'
- en: 'Starting with the down animation, click on the `Sprite` node and set its Frame
    property to `0`. Click the key icon next to the Frame property and confirm that
    you want to add a new track for the Frame property:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 'Starting with the down animation, click on the `Sprite` node and set its Frame
    property to `0`. Click the key icon next to the Frame property and confirm that
    you want to add a new track for the Frame property:'
- en: '![](img/00052.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00052.jpeg)'
- en: 'The Frame property will automatically be incremented by one and the animation
    track will be advanced by one step (0.2 seconds). Click the key again until you''ve
    reached frame 4\. You should now have five keyframes on the animation track. If
    you drag the bar back and forth, you''ll see the Frame property change as you
    reach each keyframe:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'The Frame property will automatically be incremented by one and the animation
    track will be advanced by one step (0.2 seconds). Click the key again until you''ve
    reached frame 4\. You should now have five keyframes on the animation track. If
    you drag the bar back and forth, you''ll see the Frame property change as you
    reach each keyframe:'
- en: '![](img/00053.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.jpeg)'
- en: If, for some reason, you find that the frames aren't correct, you can delete
    any of the keyframes by clicking on the dot and pressing *Delete* on your keyboard,
    or right-clicking on the dot and choosing Remove Selection. Remember, whatever
    value you set Frame to, that will be the value of the keyframe when you press
    the Add Keyframe button. You can also click and drag keyframes to change their
    order in the timeline.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: If, for some reason, you find that the frames aren't correct, you can delete
    any of the keyframes by clicking on the dot and pressing *Delete* on your keyboard,
    or right-clicking on the dot and choosing Remove Selection. Remember, whatever
    value you set Frame to, that will be the value of the keyframe when you press
    the Add Keyframe button. You can also click and drag keyframes to change their
    order in the timeline.
- en: 'Repeat the process for the other animations, using the following table to guide
    you on which keyframes to use for each direction:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'Repeat the process for the other animations, using the following table to guide
    you on which keyframes to use for each direction:'
- en: '| **Animation** | **Frames** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **动画** | **帧** |'
- en: '| Down | `0, 1, 2, 3, 4` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 下 | `0, 1, 2, 3, 4` |'
- en: '| Left | `5, 6, 7, 8, 9` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 左 | `5, 6, 7, 8, 9` |'
- en: '| Right | `10, 11, 12, 13, 14` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 右 | `10, 11, 12, 13, 14` |'
- en: '| Up | `15, 16, 17, 18, 19` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 上 | `15, 16, 17, 18, 19` |'
- en: As long as the spritesheet for a character follows the same 5 x 4 arrangement,
    this `AnimationPlayer` configuration will work, and you won't need to create separate
    animations for each character. In larger projects, it can be a huge time-saver
    to create all your spritesheet animations while following a common pattern.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: As long as the spritesheet for a character follows the same 5 x 4 arrangement,
    this `AnimationPlayer` configuration will work, and you won't need to create separate
    animations for each character. In larger projects, it can be a huge time-saver
    to create all your spritesheet animations while following a common pattern.
- en: Collision detection
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: Because the characters are moving on a grid, they need to either move the full
    distance to the next tile or not at all. This means that, before moving, the character
    needs to check to see if the move is possible. One way to test if an adjacent
    square has anything in it is by using a *raycast*. **Raycasting** means extending
    a ray from the character's position to a given destination. If the ray encounters
    any object along the way, it will report that contact. By adding four rays to
    the character, it can *look* at the squares around it to see if they are unoccupied.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Because the characters are moving on a grid, they need to either move the full
    distance to the next tile or not at all. This means that, before moving, the character
    needs to check to see if the move is possible. One way to test if an adjacent
    square has anything in it is by using a *raycast*. **光线投射**意味着从角色的位置向一个指定的目的地发射一条光线。如果光线在途中遇到任何物体，它将报告接触。通过向角色添加四个光线，它可以*观察*周围的方块，以查看它们是否被占用。
- en: 'Add four `RayCast2D` nodes and set their names and **Cast To** properties as
    follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 'Add four `RayCast2D` nodes and set their names and **投射到** properties as follows:'
- en: '| **Name** | **Cast To** |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **投射到** |'
- en: '| RayCastRight | `(64, 0)` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| RayCastRight | `(64, 0)` |'
- en: '| RayCastLeft | `(-64, 0)` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| RayCastLeft | `(-64, 0)` |'
- en: '| RayCastDown | `(0, 64)` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| RayCastDown | `(0, 64)` |'
- en: '| RayCastUp | `(0, -64)` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| RayCastUp | `(0, -64)` |'
- en: 'Make sure to set the Enabled property on each one (`RayCast2D` options are
    disabled by default). Your final node setup should look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'Make sure to set the Enabled property on each one (`RayCast2D` options are
    disabled by default). Your final node setup should look like this:'
- en: '![](img/00054.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00054.jpeg)'
- en: Character script
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Character script
- en: 'Now, add a script to the `Character` node (make sure you''ve saved the scene
    first, and the script will automatically be named `Character.gd`). First, define
    the class variables:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'Now, add a script to the `Character` node (make sure you''ve saved the scene
    first, and the script will automatically be named `Character.gd`). First, define
    the class variables:'
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`speed` will control the movement and animation speed of the character, allowing
    you to customize the movement speed. As you learned in [Chapter 1](part0022.html#KVCC0-5809b3bef8d2453086d97dfad17b2ee2),
    *Introduction*, using `export` allows you to set the value of a variable via the
    Inspector. Save the script and set the Speed property to `3` in the Inspector.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`speed`将控制角色的移动和动画速度，允许你自定义移动速度。正如你在[第1章](part0022.html#KVCC0-5809b3bef8d2453086d97dfad17b2ee2)“简介”中学习的，使用`export`可以通过检查器设置变量的值。保存脚本，并在检查器中将速度属性设置为`3`。'
- en: '`can_move` is a flag that will track whether the character is allowed to move
    during the current frame. It will be set to `false` while the movement is underway,
    preventing a second movement from being started before the previous one has finished.
    `facing` is a string denoting the current direction of movement (again, spelled
    and capitalized exactly like the input actions you created at the beginning of
    the project). The `moves` dictionary contains vectors describing the four directions,
    while the `raycasts` dictionary contains references to the four raycast nodes.
    Note that both dictionaries'' keys match the input action names.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`can_move`是一个标志，用于跟踪角色在当前帧期间是否允许移动。在移动进行时，它将被设置为`false`，以防止在上一移动完成之前启动第二次移动。`facing`是一个表示当前移动方向的字符串（再次强调，拼写和首字母大小写必须与项目开始时创建的输入动作完全一致）。`moves`字典包含描述四个方向的向量，而`raycasts`字典包含四个射线投射节点的引用。请注意，这两个字典的键与输入动作名称匹配。'
- en: 'When referencing another node during variable declaration, you must use `onready` to
    ensure that the variable isn''t set before the referenced node is ready. You can
    think of it as a shortcut to writing the code in the `_ready()` function. This
    line:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量声明期间引用另一个节点时，必须使用`onready`以确保在引用的节点准备好之前变量没有被设置。你可以将其视为在`_ready()`函数中编写代码的快捷方式。这一行：
- en: '`onready var sprite = $Sprite`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`onready var sprite = $Sprite`'
- en: 'Is equivalent to writing this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于以下写法：
- en: '`var sprite`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`var sprite`'
- en: '`func _ready():`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`func _ready():`'
- en: '`    sprite = $Sprite`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`    sprite = $Sprite`'
- en: 'The following is the code that will execute a movement from one square to another:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将执行从一个方块到另一个方块的移动：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`move()` takes a direction as an argument. If the `RayCast2D` for the given
    direction detects a collision, the move is canceled and the function returns without
    executing further (note that the return value will be `null`). Otherwise, it changes
    `facing` to the new direction, disables additional movement with `can_move`, and
    starts playing the matching animation. To actually perform the movement, the `Tween`
    node interpolates the `position` property from its current value to its current
    value plus a tile-sized movement in the given direction. The duration (`1.0 /
    speed` seconds) is set to match the length of the animation.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`move()`函数接受一个方向作为参数。如果给定方向的`RayCast2D`检测到碰撞，则移动将被取消，函数将返回而不执行进一步操作（注意，返回值将为`null`）。否则，它将`facing`更改为新方向，使用`can_move`禁用额外的移动，并开始播放匹配的动画。为了实际执行移动，`Tween`节点将`position`属性从当前值插值到当前值加上给定方向一个方块大小的移动。持续时间（`1.0
    / speed`秒）设置为与动画长度相匹配。'
- en: Using the `Tween.TRANS_SINE` transition type results in a pleasing, smooth movement
    that accelerates up and then down to the final position. Feel free to try other
    transition types here to alter the movement style.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Tween.TRANS_SINE`过渡类型会产生令人愉悦、平滑的移动，先加速然后减速到最终位置。你可以自由尝试其他过渡类型来改变移动风格。
- en: 'Finally, to enable movement again, you need to reset `can_move` when the movement
    has finished. Connect the `tween_completed` signal from `MoveTween` and add the
    following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了再次启用移动，需要在移动完成后重置`can_move`。将`MoveTween`的`tween_completed`信号连接并添加以下代码：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Player scene
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家场景
- en: The player scene needs to contain all the same nodes we gave to `Character`.
    This is where you'll take advantage of the power of inheritance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家场景需要包含我们给`Character`的所有相同节点。这是你将利用继承的强大功能的地方。
- en: 'Start by making a new scene. However, instead of making a new empty scene,
    click on Scene | New Inherited Scene in the menu. In the Open Base Scene window,
    select `res://character/Character.tscn`, as shown in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的场景。然而，不要创建一个新的空场景，而是在菜单中点击“场景”|“新建继承场景”。在“打开基础场景”窗口中，选择`res://character/Character.tscn`，如下截图所示：
- en: '![](img/00055.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.jpeg)'
- en: Rename the root node of this new scene from `Character` to `Player` and save
    the new scene. Note that all the `Character` nodes are also present. If you make
    a change to `Character.tscn` and save it, the changes will also take effect in
    the `Player` scene.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个新场景的根节点从`Character`重命名为`Player`并保存新场景。注意，所有的`Character`节点也都存在。如果你更改了`Character.tscn`并保存它，这些更改也会在`Player`场景中生效。
- en: 'Now, you need to set the Player''s physics layers, so find the Collision section
    in the Inspector and set the Layer and Mask properties. Layer should be set to
    player only, while Mask should show walls, enemies, and items. Refer to the following
    screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要设置玩家的物理层，所以在检查器中找到碰撞部分，并设置层和掩码属性。层应设置为仅玩家，而掩码应显示墙壁、敌人和物品。参考以下截图：
- en: '![](img/00056.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00056.jpeg)'
- en: The collision layers system is a powerful tool that allows you to customize
    which objects can detect each other. The Layer property places the object in one
    or more collision layers, while the Mask property defines what layers the object
    can *see*. If another object is not in one of its mask layers, it will not be
    detected or collided with.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞层系统是一个强大的工具，它允许你自定义哪些对象可以检测彼此。层属性将对象放置在一个或多个碰撞层中，而掩码属性定义了对象可以看到哪些层。如果另一个对象不在其掩码层之一中，它将不会被检测或碰撞。
- en: 'The only other node that needs to be changed is the `Sprite`, where you need
    to set the texture. Drag the player spritesheet from the `res://assets` folder
    and drop it in the Texture property of the `Sprite`. Go ahead and test out the
    animations in the `AnimationPlayer` and make sure they''re showing the correct
    directions. If you find a problem with any of the animations, make sure you fix
    it in the `Character` scene, and it will automatically be fixed in the `Player`
    scene as well:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更改的唯一其他节点是`Sprite`，在那里你需要设置纹理。从`res://assets`文件夹拖动玩家精灵表单，并将其放入`Sprite`的纹理属性中。接下来，测试`AnimationPlayer`中的动画，确保它们显示正确的方向。如果你发现任何动画有问题，确保你在`Character`场景中修复它，它也会自动在`Player`场景中修复：
- en: '![](img/00057.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00057.jpeg)'
- en: Add a `Camera` node as a child of `Player` and check its Current property to
    On. Godot will automatically render whatever the current camera sees in the game
    window. This will allow you to make maps of any size, and the camera will scroll
    the map as the player walks around on it. Note that when you add the camera, a
    purplish box appears, which is centered on the player. This represents the camera's
    visible region, and because it's a child of the player, it follows the player's
    movement. If you look at the camera's properties in the Inspector, you'll see
    four Limit properties. These are used to stop the camera from scrolling past a
    certain point; the edge of your map, for example. Try adjusting them and see how
    the box stops following the `Player` as you drag it around the screen (make sure
    you're moving the `Player` node itself and not one of its children). Later, the
    limits will be set automatically by the level itself so that the camera won't
    scroll "outside" the level.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Camera`节点作为`Player`的子节点添加，并检查其当前属性是否为On。Godot将自动在游戏窗口中渲染当前相机看到的任何内容。这将允许你制作任何大小的地图，并且相机会随着玩家在地图上移动而滚动。注意，当你添加相机时，会出现一个紫色的框，它位于玩家的中心。这代表相机的可见区域，因为它作为玩家的子节点，所以会跟随玩家的移动。如果你查看检查器中的相机属性，你会看到四个限制属性。这些属性用于阻止相机滚动过某个点；例如，地图的边缘。尝试调整它们，看看当你拖动它时，框是如何停止跟随`Player`的（确保你移动的是`Player`节点本身，而不是其子节点）。稍后，这些限制将由关卡本身自动设置，这样相机就不会滚动到“关卡之外”。
- en: Player script
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家脚本
- en: 'The player''s script also needs to extend the character''s. Remove the attached
    script (`Character.gd`) by selecting the `Player` node and clicking the Clear
    script button:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家脚本也需要扩展角色的。通过选择`Player`节点并点击清除脚本按钮来删除附加的脚本（`Character.gd`）：
- en: '![](img/00058.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00058.jpeg)'
- en: 'Now, click the button again to attach a new script. In the Attach Node Script
    dialog, click the folder icon next to the Inherits option and select `Character.gd`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次点击按钮以附加新的脚本。在附加节点脚本对话框中，点击继承选项旁边的文件夹图标，并选择`Character.gd`：
- en: '![](img/00059.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00059.jpeg)'
- en: 'Here is the player script (note that it `extends` the character script):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是玩家脚本（注意它`extends`角色脚本）：
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because it inherits all the behavior from `Character.gd`, the player will also
    have the `move()` function. You just need to extend it with code to call `move()`
    based on the input events. As you've seen before, you can use the `process()`
    function to check the input state each frame. However, only if `can_move` allows
    it do you actually check the inputs and call `move()`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它继承了 `Character.gd` 中的所有行为，玩家也将拥有 `move()` 函数。你只需要用代码扩展它，根据输入事件调用 `move()`。正如你之前看到的，你可以使用
    `process()` 函数来检查每一帧的输入状态。然而，只有当 `can_move` 允许时，你才实际上检查输入并调用 `move()`。
- en: Because you used the names `up`, `down`, `left`, and `right` for the input actions
    as well as the keys to the `moves` and `raycasts` dictionaries, you can loop through
    those keys and check each one as an input as well.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你在输入动作以及 `moves` 和 `raycasts` 字典的键中使用了 `up`、`down`、`left` 和 `right` 这些名称，你可以遍历这些键并检查每个键作为输入。
- en: Recall that `move()` returns `true` if it succeeds. If it does, the player emits
    the `moved` signal, which you'll be able to use later with the enemies.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`move()` 函数在成功时返回 `true`。如果成功，玩家会发出 `moved` 信号，你可以在以后与敌人一起使用这个信号。
- en: Run the scene and try moving the player character around the screen.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 运行场景并尝试在屏幕上移动玩家角色。
- en: 'The player doesn''t have a level to walk around on yet, but you can go ahead
    and add the code the player will need later. As the player moves around the level,
    it will encounter various objects and needs to respond to them. By using signals,
    you can add the code for this before you''ve even created the level. Add three
    more signals to the script:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家还没有可以行走的关卡，但你可以继续添加玩家稍后需要的代码。当玩家在关卡中移动时，它会遇到各种对象并需要对其做出响应。通过使用信号，你可以在创建关卡之前就添加相应的代码。向脚本中添加三个额外的信号：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, connect the `area_entered` signal of the `Player` and add this code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，连接 `Player` 的 `area_entered` 信号并添加以下代码：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Whenever the player encounters another `Area2D`, this function will run. If
    the object is an enemy, the player loses the game. Note the use of `has_method()`.
    This allows you to identify collectible objects by checking whether they have
    a `pickup()` method and only call the method if it exists.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家遇到另一个 `Area2D` 时，此函数将运行。如果该对象是敌人，玩家将输掉游戏。注意 `has_method()` 的使用。这允许你通过检查是否有
    `pickup()` 方法来识别可收集的对象，并且只有在方法存在时才调用该方法。
- en: Enemy scene
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人场景
- en: Hopefully, you're seeing how inheritance works by now. You'll create the `Enemy`
    scene using the same procedure. Make a new scene inheriting from `Character.tscn`
    and name it `Enemy`. Drag the mob spritesheet, `res://assets/slime.png`, to the
    `Sprite`'s Texture.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在已经看到了继承是如何工作的。你将使用相同的步骤创建 `Enemy` 场景。创建一个新的场景，从 `Character.tscn` 继承，并命名为
    `Enemy`。将怪物精灵图集 `res://assets/slime.png` 拖到 `Sprite` 的纹理上。
- en: In the Collision section of the Inspector, set the Layer and Mask properties. Layer should
    be set to enemies, while Mask should show walls and player.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器的碰撞部分，设置 `Layer` 和 `Mask` 属性。`Layer` 应该设置为敌人，而 `Mask` 应该显示墙壁和玩家。
- en: 'As you did with the `Player`, remove the existing script and attach a new script
    inheriting from `Character.gd`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Player` 一样，移除现有的脚本并附加一个新的脚本，从 `Character.gd` 继承：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code in the `_ready()` function serves an important purpose: because the
    enemies are added to the tree *below* the `TileMap` nodes, they''ll be processed
    first. You don''t want the enemies to start moving before the walls have been
    processed, or they could step onto a wall tile and get stuck. You need to have
    a small delay before they start, which also serves to give the player a moment
    to prepare. To do this, rather than add a `Timer` node to the scene, you can use
    the `create_timer()` function of the `SceneTree` to make a one-off timer, yielding
    execution until its timeout signal fires.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`_ready()` 函数中的代码起着重要的作用：因为敌人被添加到树形结构中 `TileMap` 节点之下，它们会被首先处理。你不想让敌人在墙壁被处理之前开始移动，否则它们可能会踩到墙壁的瓦片上而卡住。在它们开始之前需要有一个小的延迟，这也有助于给玩家准备的时间。为此，你不需要在场景中添加一个
    `Timer` 节点，而是可以使用 `SceneTree` 的 `create_timer()` 函数创建一个一次性定时器，直到超时信号触发才执行。'
- en: GDScript's `yield()` function provides a way to *pause* execution of a function
    until a later time, while allowing the rest of the game to continue running. When
    passed an object and a named signal, execution will resume when that object emits
    the given signal.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: GDScript 的 `yield()` 函数提供了一种方法，可以在稍后时间暂停函数的执行，同时允许游戏的其他部分继续运行。当传递一个对象和一个命名信号时，执行将在该对象发出给定信号时恢复。
- en: Every frame, the enemy will move if it is able to. If it runs into a wall (that
    is, when `move()` returns `null`), or sometimes just randomly, it changes direction.
    The result will be an unpredictable (and hard to dodge!) enemy movement. Remember
    that you can adjust the `Player` and `Enemy` speeds independently in their scenes,
    or change `speed` in the `Character` scene and it will affect them both.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每一帧，如果敌人能够移动，它就会移动。如果它撞到墙壁（即当`move()`返回`null`时），或者有时是随机地，它会改变方向。结果将是一个不可预测的（并且难以躲避！）敌人移动。记住，你可以独立地在它们的场景中调整`Player`和`Enemy`的速度，或者改变`Character`场景中的`speed`，这将影响它们两个。
- en: Optional – turn-based movement
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选 - 轮流移动
- en: For a different style of game, you could put the `_process()` movement code
    in a function called `_on_Player_moved()` instead, and connect it to the player's `moved` signal.
    This would make the enemies move only when the player does, giving the game more
    of a strategic feel, rather than one of fast-paced action.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同风格的游戏，你可以将`_process()`移动代码放入一个名为`_on_Player_moved()`的函数中，并将其连接到玩家的`moved`信号。这将使敌人只在玩家移动时移动，使游戏更具策略感，而不是快节奏的动作。
- en: Creating the level
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建关卡
- en: In this section, you'll create the map where all the action will take place.
    As the name implies, you'll probably want to make a maze-like level with lots
    of twists and turns.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建所有动作将发生的地图。正如其名所示，你可能想要制作一个迷宫般的关卡，有很多转弯和曲折。
- en: 'Here is a sample level:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例关卡：
- en: '![](img/00060.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00060.jpeg)'
- en: The player's goal is to reach the star. Locked doors can only be opened by picking
    up the key. The green dots mark the spawn locations of enemies, while the red
    dot marks the player's start location. The coins are extra items that can be picked
    up along the way for bonus points. Note that the entire level is larger than the
    display window. The `Camera` will scroll the map as the player moves around it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的目标是到达星星。锁着的门只能通过捡起钥匙才能打开。绿色圆点标记着敌人的出生位置，而红色圆点标记着玩家的起始位置。金币是可以在路上捡到的额外物品，可以用来获得额外分数。请注意，整个关卡比显示窗口要大。当玩家在地图周围移动时，`Camera`会滚动地图。
- en: You'll use the `TileMap` node to create the map. There are several benefits
    to using a `TileMap` for your level design. First, they make it possible to draw
    the level's layout by *painting* the tiles onto a grid, which is much faster than
    placing individual `Sprite` nodes one by one. Secondly, they allow for much larger
    levels because they are optimized for drawing large numbers of tiles efficiently
    by batching them together and only drawing the *chunks* of the map that are visible
    at a given time. Finally, you can add collision shapes to individual tiles and
    the entire map will act as a single collider, simplifying your collision code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`TileMap`节点来创建地图。使用`TileMap`进行关卡设计有几个好处。首先，它们通过在网格上*绘制*瓦片来绘制关卡布局，这比逐个放置`Sprite`节点要快得多。其次，它们允许创建更大的关卡，因为它们通过将瓦片批处理在一起并只绘制给定时间可见的地图的*块*来优化绘制大量瓦片。最后，你可以向单个瓦片和整个地图添加碰撞形状，这样整个地图将作为一个单独的碰撞体，简化你的碰撞代码。
- en: Once you've completed this section, you'll be able to create as many of these
    maps as you wish. You can put them in order to give a progression from level to
    level.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一部分后，你将能够创建你想要的任意数量的这些地图。你可以按顺序放置它们，以实现关卡到关卡的发展。
- en: Items
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目
- en: 'First, create a new scene for the collectable objects that the player can pick
    up. These items will be spawned by the map when the game is run. Here is the scene
    tree:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为玩家可以捡起的可收集对象创建一个新的场景。这些物品将在游戏运行时由地图生成。以下是场景树：
- en: '![](img/00061.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00061.jpeg)'
- en: Leave the `Sprite` Texture blank. Since you're using this object for multiple
    items, the texture can be set in the item's script when it's created.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 留下`Sprite`纹理为空。由于你正在使用这个对象来表示多个项目，纹理可以在创建项目时在项目的脚本中设置。
- en: Set the `Pickup` Collision Layer to items and its Mask to player. You don't
    want the enemies collecting the coins before you get there (although that might
    make for a fun variation on the game where you race to get as many coins as you
    can before the bad guys gobble them up).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Pickup`的碰撞层设置为项目，并将其掩码设置为玩家。你不想在到达之前敌人就收集金币（尽管这可能会让游戏有一个有趣的变体，即你需要在坏人吞掉它们之前尽可能多地收集金币）。
- en: Give the `CollisionShape2D` node a rectangle shape and set its extents to `(32,
    32)` (strictly speaking, you can use any shape, as the player will move all the
    way onto the tile and completely overlap the item anyway).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 给`CollisionShape2D`节点赋予矩形形状，并将其范围设置为`(32, 32)`（严格来说，你可以使用任何形状，因为玩家无论如何都会完全移动到瓦片上并完全覆盖物品）。
- en: 'Here is the script for the `Pickup`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`Pickup`的脚本：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `type` variable will be set when the item is created and used to determine
    what texture the object should use. Using `_type` as the variable name in the
    function argument lets you use the name without conflicting with `type`, which
    is already in use.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当物品创建并使用时，`type`变量将被设置，并用于确定对象应使用哪种纹理。在函数参数中使用`_type`作为变量名称允许你使用该名称而不与已使用的`type`冲突。
- en: Some programming languages use the notion of *private* functions or variables,
    meaning they are only used locally. The `_` naming convention in GDScript is used
    to visually designate variables or functions that should be regarded as private.
    Note that they aren't actually any different from any other name; it is merely
    a visual indication for the programmer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言使用**私有**函数或变量的概念，这意味着它们仅用于本地。GDScript中的`_`命名约定用于视觉上指定应被视为私有的变量或函数。请注意，它们实际上与其他名称没有任何不同；这仅仅是对程序员的一种视觉指示。
- en: 'The pickup effect using `Tween` is similar to the one you used for the coins
    in Coin Dash—animating the scale and opacity of `Sprite`. Connect the `tween_completed`
    signal of `Tween` so that the item can be deleted when the effect has finished:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Tween`的拾取效果与你在Coin Dash中用于硬币的效果相似——动画`Sprite`的缩放和透明度。将`Tween`的`tween_completed`信号连接起来，以便在效果完成后删除物品：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: TileSets
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TileSets
- en: In order to draw a map using a `TileMap`, it must have a `TileSet` assigned
    to it. The `TileSet` contains all of the individual tile textures, along with
    any collision shapes they may have.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`TileMap`绘制地图，它必须分配一个`TileSet`。`TileSet`包含所有单个瓦片纹理以及它们可能具有的碰撞形状。
- en: Depending on how many tiles you have, it can be time-consuming to create a `TileSet`,
    especially the first time. For that reason, there is a pre-generated `TileSet`
    included in the `assets` folder titled `tileset.tres`. Feel free to use that instead,
    but please don't skip the following section. It contains useful information to
    help you understand how the `TileSet` works.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你有多少瓦片，创建`TileSet`可能很耗时，尤其是第一次。因此，`assets`文件夹中包含了一个预先生成的`TileSet`，标题为`tileset.tres`。你可以自由使用它，但请不要跳过以下部分。它包含有关`TileSet`如何工作的有用信息。
- en: Creating a TileSet
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建TileSet
- en: A `TileSet` in Godot is a type of `Resource`. Examples of other resources include
    Textures, Animations, and Fonts. They are containers that hold a certain type
    of data, and are typically saved as `.tres` files.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在Godot中，`TileSet`是一种`Resource`类型。其他资源的例子包括纹理、动画和字体。它们是包含特定类型数据的容器，通常保存为`.tres`文件。
- en: By default, Godot saves files in text-based formats, indicated by the `t` in
    `.tscn` or `.tres`, for example. Text-based files are preferred over binary formats
    because they are human-readable. They are also more friendly for **Version Control
    Systems** (**VCS**), which allow you to track file changes over the course of
    building your project.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Godot以基于文本的格式保存文件，例如`.tscn`或`.tres`文件中的`t`表示。与二进制格式相比，基于文本的文件更受欢迎，因为它们是可读的。它们对**版本控制系统**（**VCS**）也更加友好，这允许你在构建项目的过程中跟踪文件更改。
- en: To make a `TileSet`, you create a scene with a set of `Sprite` nodes containing
    the textures from your art assets. You can then add collisions and other properties
    to those `Sprite` tiles. Once you've created all the tiles, you export the scene
    as a `TileSet` resource, which can then be loaded by the `TileMap` node.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`TileSet`，你需要创建一个包含来自你的艺术资产的纹理的`Sprite`节点的场景。然后你可以向这些`Sprite`瓦片添加碰撞和其他属性。一旦创建了所有瓦片，你就可以将场景导出为`TileSet`资源，然后由`TileMap`节点加载。
- en: 'Here is a screenshot of the `TileSetMaker.tscn` scene, containing the tiles
    you''ll be using to build this game''s levels:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`TileSetMaker.tscn`场景的截图，其中包含你将用于构建游戏关卡所需的瓦片：
- en: '![](img/00062.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00062.jpeg)'
- en: 'Start by adding a `Sprite` node and setting its texture to `res://assets/sokoban_tilesheet.png`.
    To select a single tile, set the Region/Enabled property to On and click Texture
    Region at the bottom of the editor window to open the panel. Set Snap Mode to
    Grid Snap and the Step to 64px in both *x* and *y*. Now, when you click and drag
    in the texture, it will only allow you to select 64 x 64 sections of the texture:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先添加一个 `Sprite` 节点，并将其纹理设置为 `res://assets/sokoban_tilesheet.png`。要选择单个瓦片，将区域/启用属性设置为开启，并在编辑器窗口底部点击纹理区域以打开面板。将捕捉模式设置为网格捕捉，并在
    *x* 和 *y* 方向上将步长设置为 64px。现在，当你点击并拖动纹理时，它只会允许你选择 64 x 64 的纹理区域：
- en: '![](img/00063.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00063.jpeg)'
- en: Give the Sprite an appropriate name (`crate_brown` or `wall_red`, for example)—this
    name will appear as the tile's name in the `TileSet`. Add a `StaticBody2D` as
    a child, and then add a `CollisionPolygon2D` to that. It is important that the
    collision polygon be sized properly so that it aligns with the tiles placed next
    to it. The easiest way to do this is to turn on grid snapping in the editor window.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 给精灵一个合适的名称（例如 `crate_brown` 或 `wall_red`）——这个名称将作为瓦片名称出现在 `TileSet` 中。添加一个 `StaticBody2D`
    作为子节点，然后向其中添加一个 `CollisionPolygon2D`。确保碰撞多边形的大小适当，以便与放置在其旁边的瓦片对齐。在编辑器窗口中开启网格捕捉是最简单的方法。
- en: 'Click the Use Snap button (it looks like a magnet) and then open the snap menu
    by clicking on the three dots next to it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 点击使用捕捉按钮（看起来像一块磁铁），然后通过点击其旁边的三个点打开捕捉菜单：
- en: '![](img/00064.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00064.jpeg)'
- en: 'Choose Configure Snap... and set the Grid Step to `64` by `64`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 选择配置捕捉... 并将网格步长设置为 `64` x `64`：
- en: '![](img/00065.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00065.jpeg)'
- en: 'Now, with the `CollisionPolygon2D` selected, you can click in the four corners
    of the tile one by one to create a closed square (it will appear as a reddish
    orange):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当选择 `CollisionPolygon2D` 时，你可以逐个点击瓦片的四个角来创建一个闭合的方形（它将显示为红色橙色）：
- en: '![](img/00066.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00066.jpeg)'
- en: This tile is now complete. You can duplicate it (*Ctrl* + *D*) and make another,
    and you only need to change the texture region. Note that collision bodies are
    only needed on the wall tiles. The ground and item tiles should not have them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个瓦片现在已完成。你可以复制它（*Ctrl* + *D*）并创建另一个，你只需要更改纹理区域。请注意，只有墙壁瓦片需要碰撞体。地面和物品瓦片不应包含它们。
- en: 'When you''ve created all your tiles, click Scene | Convert To | TileSet and
    save it with an appropriate name, such as `tileset.tres`. If you come back and
    edit the scene again, you''ll need to redo the conversion. Pay special attention
    to the Merge With Existing option. If this is set to On, the current scene''s
    tiles will be *merged* with the ones already in the `tileset` file. Sometimes,
    this can result in changes to the tile indices and change your map in unwanted
    ways. Take a look at the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建完所有瓦片后，点击场景 | 转换为 | 瓦片集，并以适当的名称保存，例如 `tileset.tres`。如果你回来再次编辑场景，你需要重新进行转换。特别注意合并现有选项。如果设置为开启，当前场景的瓦片将与
    `tileset` 文件中的瓦片合并。有时，这可能会导致瓦片索引发生变化，并以不希望的方式更改你的地图。请查看以下截图：
- en: '![](img/00067.jpeg)`tres` stands for text resource and is the most common format
    Godot stores its resource files in. Compare this with `tscn`, which is the text
    scene storage format.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00067.jpeg)`tres` 代表文本资源，是 Godot 存储其资源文件的最常见格式。将其与 `tscn` 进行比较，这是文本场景存储格式。'
- en: Your `TileSet` resource is ready to use!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `TileSet` 资源现在可以使用了！
- en: TileMaps
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瓦片图
- en: Now, let's make a new scene for the game level. The level will be a self-contained
    scene, and will include the map and the player, and will handle spawning any items
    and enemies in the level. For the root, use a `Node2D` and name it `Level1` (later,
    you can duplicate this node setup to create more levels).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为游戏关卡创建一个新的场景。这个关卡将是一个独立的场景，包括地图和玩家，并处理在关卡中生成任何物品和敌人。对于根节点，使用 `Node2D`
    并将其命名为 `Level1`（稍后，你可以复制此节点设置以创建更多关卡）。
- en: You can open the `Level1.tscn` file from the assets folder to see the completed
    level scene from this section, although you're encouraged to create your own levels.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从资产文件夹中打开 `Level1.tscn` 文件，以查看本节中完成的关卡场景，尽管鼓励你创建自己的关卡。
- en: When using `TileMap`, you will often want more than one tile object to appear
    in a given location. You might want to place a tree, for example, but also have
    a ground tile appear below it. This can be done by using `TileMap` as many times
    as you like to create layers of data. For your level, you'll make three layers
    to display the ground, which the player can walk on; the walls, which are obstacles;
    and the collectible items, which are markers for spawning items like coins, keys,
    and enemies.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `TileMap` 时，你可能会希望在一个给定位置出现多个瓦片对象。例如，你可能想要放置一棵树，但也希望在它下面有一个地面瓦片。这可以通过多次使用
    `TileMap` 来创建数据层来实现。对于你的关卡，你将创建三个层来显示玩家可以行走的地面；墙壁，它们是障碍物；以及可收集的物品，它们是生成如硬币、钥匙和敌人的标记。
- en: 'Add a `TileMap` and name it `Ground`. Drag the `tileset.tres` into the Tile
    Set property and you''ll see the tiles appear, ready to be used, on the right-hand
    side of the editor window:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `TileMap` 并将其命名为 `Ground`。将 `tileset.tres` 拖放到瓦片集属性中，你将在编辑器窗口的右侧看到瓦片出现，准备使用：
- en: '![](img/00068.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00068.jpeg)'
- en: It's very easy to accidentally click and drag in the editor window and move
    your whole tile map. To prevent this, make sure you select the `Ground` node and
    click the Lock button: ![](img/00069.jpeg).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器窗口中不小心点击并拖动很容易移动整个瓦片图。为了防止这种情况，确保你选择了 `Ground` 节点并点击锁定按钮： ![](img/00069.jpeg)。
- en: Duplicate this `TileMap` twice and name the new `TileMap` nodes `Walls` and
    `Items`. Remember that Godot draws objects in the order listed in the node tree,
    from top to bottom, so `Ground` should be at the top, with `Walls` and `Items`
    underneath it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将此 `TileMap` 复制两次，并将新的 `TileMap` 节点命名为 `Walls` 和 `Items`。记住，Godot 按照节点树中从上到下的顺序绘制对象，所以
    `Ground` 应该在顶部，`Walls` 和 `Items` 在其下方。
- en: As you're drawing your level, be careful to note which layer you're drawing
    on! You should only place the item markers on the Items layer, for example, because
    that's where the code is going to look for objects to create. Don't place any
    other objects there, though, because the layer itself will be invisible during
    gameplay.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在绘制你的关卡时，请注意你正在绘制哪个层！你应该只在物品层放置物品标记，例如，因为代码将在这里查找要创建的对象。不过，不要在该层放置任何其他对象，因为在游戏过程中该层本身将是不可见的。
- en: 'Finally, add an instance of the `Player` scene. Make sure the `Player` node
    is below the three `TileMap` nodes, so it will be drawn on top. The final scene
    tree should look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加一个 `Player` 场景的实例。确保 `Player` 节点位于三个 `TileMap` 节点之下，这样它就会被绘制在最上面。最终的场景树应该看起来像这样：
- en: '![](img/00070.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00070.jpeg)'
- en: Level script
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关卡脚本
- en: 'Now that the level is complete, attach a script to create the level behavior.
    This script will first scan the `Items` map to spawn any enemies and collectibles.
    It will also serve to monitor for events that occur during gameplay, such as picking
    up a key or running into an enemy:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关卡已经完成，附加一个创建关卡行为的脚本。此脚本将首先扫描 `Items` 映射以生成任何敌人和可收集物品。它还将用于监控游戏过程中发生的事件，例如捡起钥匙或遇到敌人：
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first two variables contain references to the scenes that will need to be
    instanced from the `Items` map. Since that particular map node will be referenced
    frequently, you can cache the `$Items` lookup in a variable to save some time.
    Finally, an array called `doors` will contain the door location(s) found on the
    map.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个变量包含了对从 `Items` 映射中实例化的场景的引用。由于该特定映射节点将被频繁引用，你可以将 `$Items` 查找缓存到一个变量中以节省一些时间。最后，一个名为
    `doors` 的数组将包含地图上找到的门的位置。
- en: Save the script and drag the `Enemy.tscn` and `Pickup.tscn` files into their
    respective properties in the Inspector.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并将 `Enemy.tscn` 和 `Pickup.tscn` 文件拖放到检查器中相应的属性。
- en: 'Now, add the following code for `_ready()`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加以下代码到 `_ready()` 中：
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The function starts by ensuring that the `Items` tilemap is hidden. You don't
    want the player to see those tiles; they exist so the script can detect where
    to spawn items.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先确保 `Items` 瓦片图是隐藏的。你不希望玩家看到这些瓦片；它们的存在是为了让脚本检测物品的生成位置。
- en: Next, the camera limits must be set, ensuring that it can't scroll past the
    edges of the map. You'll create a function to handle that (see the following code).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要设置摄像机的限制，确保它不能滚动到地图的边缘。你需要创建一个函数来处理这个问题（见下面的代码）。
- en: When the player finds a key, the door(s) need to be opened, so the next part
    searches the `Walls` map for any `door_red` tiles and stores them in an array.
    Note that you must first find the tile's `id` from the `TileSet`, because the
    cells of the `TileMap` only contain ID numbers that refer to the tile set.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家找到钥匙时，门需要打开，所以下一部分会在`Walls`地图中搜索任何`door_red`瓦片并将它们存储在数组中。请注意，你必须首先从`TileSet`中找到瓦片的`id`，因为`TileMap`的单元格只包含指向瓦片集的ID数字。
- en: More on the `spawn_items()` function follows.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`spawn_items()`函数的更多内容将在后面介绍。
- en: Finally, the `Player` signals are all connected to functions that will process
    their results.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Player`信号都连接到将处理其结果的函数。
- en: 'Here''s how to set the camera limits to match the size of the map:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何设置相机限制以匹配地图大小的：
- en: '[PRE11]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`get_used_rect()` returns a `Vector2` containing the size of the `Ground` layer
    in cells. Multiplying this by the `cell_size` gives the total map size in pixels,
    which is used to set the four limit values on the `Camera` node. Setting these
    limits ensures you won''t see any *dead* space outside the map when you move near
    the edge.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_used_rect()`返回一个包含`Ground`层大小的`Vector2`。将其乘以`cell_size`给出整个地图的像素大小，这用于在`Camera`节点上设置四个限制值。设置这些限制确保当你靠近边缘时，你不会看到地图外的任何*死区*。'
- en: 'Now, add the `spawn_items()` function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加`spawn_items()`函数：
- en: '[PRE12]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function looks for the tiles in the `Items` layer, returned by `get_used_cells()`.
    Each cell has an `id` that maps to a name in the `TileSet` (the names that were
    assigned to each tile when the `TileSet` was made). If you made your own tile
    set, make sure you use the names that match your tiles in this function. The names
    used in the preceding code match the tile set that was included in the asset download.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在`Items`层中查找瓦片，由`get_used_cells()`返回。每个单元格都有一个`id`，它映射到`TileSet`中的一个名称（在创建`TileSet`时分配给每个瓦片的名称）。如果你创建了自定义瓦片集，请确保在这个函数中使用与你的瓦片匹配的名称。前面代码中使用的名称与包含在资产下载中的瓦片集相匹配。
- en: '`map_to_world()` converts the tile map position to pixel coordinates. This
    gives you the upper-left corner of the tile, so then you must add one half-size
    tile to find the center of the tile. Then, depending on what tile was found, the
    matching item object is instanced.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`map_to_world()`将瓦片地图位置转换为像素坐标。这给出了瓦片的左上角，因此你必须添加半个瓦片大小以找到瓦片的中心。然后，根据找到的瓦片，实例化匹配的项目对象。'
- en: 'Finally, add the three functions for the player signals:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加玩家信号的相关三个函数：
- en: '[PRE13]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The player signals `dead` and `win` should end the game and go to a Game Over
    screen (which you haven't created yet). Since you can't write the code for those
    functions yet, use `pass` for the time being. The key pickup signal should remove
    any door tiles (by setting their tile index to `-1`, which means an empty tile).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家信号`dead`和`win`应结束游戏并转到游戏结束屏幕（你尚未创建）。由于你目前还不能编写这些函数的代码，暂时使用`pass`。拾取钥匙的信号应移除任何门瓦片（通过将它们的瓦片索引设置为`-1`，这意味着空瓦片）。
- en: Adding more levels
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多关卡
- en: If you want to make another level, you just need to duplicate this scene tree
    and attach the same script to it. The easiest way to do this is to use Scene |
    Save As and save the level as `Level2.tscn`. Then, you can use some of the existing
    tiles or draw a whole new level layout.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建另一个关卡，你只需要复制这个场景树并将其相同的脚本附加到它上面。这样做最简单的方法是使用“场景”|“另存为”并将关卡保存为`Level2.tscn`。然后，你可以使用一些现有的瓦片或绘制一个全新的关卡布局。
- en: Feel free to do this with as many levels as you like, making sure to save them
    all in the `levels` folder. In the next section, you'll see how to link them together
    so that each level will lead to the next. Don't worry if you number them incorrectly;
    you'll be able to put them in whatever order you like.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 随意使用你喜欢的关卡数量，确保将它们全部保存在`levels`文件夹中。在下一节中，你将看到如何将它们链接起来，以便每个关卡都将引导到下一个关卡。如果你编号错误，不用担心；你可以将它们按照你喜欢的任何顺序排列。
- en: Game flow
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏流程
- en: 'Now that you have the basic building blocks completed, you need to tie everything
    together. In this section, you''ll create:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了基本构建块，你需要将所有这些内容结合起来。在本节中，你将创建：
- en: The Start and Game Over screens
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始和游戏结束屏幕
- en: A global script to manage persistent data
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个全局脚本用于管理持久数据
- en: 'The basic flow of the game follows the following chart:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的基本流程遵循以下图表：
- en: '![](img/00071.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00071.jpeg)'
- en: The player is sent to the end screen whenever he/she dies, or when they reach
    and complete the last level. After a brief time, the end screen returns the player
    to the start screen so that a new game can be played.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家死亡或完成最后一个关卡时，他们会被发送到结束屏幕。经过短暂的时间后，结束屏幕会将玩家返回到起始屏幕，以便可以开始新游戏。
- en: Start and end screens
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始和结束屏幕
- en: 'You need two scenes for this part: a start or title screen that shows before
    the game (and lets the player start the game), and a game over screen to notify
    the player that the game has ended.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要两个场景来完成这部分：一个在游戏开始前显示的起始或标题屏幕（并允许玩家开始游戏），以及一个游戏结束屏幕，以通知玩家游戏已经结束。
- en: Make a new scene and add a `Control` node named `StartScreen`. Add a Label as
    a child and add `res://assets/Unique.ttf` as a new `DynamicFont` with a font size
    of `64`. Set the Align and Valign properties to Center and the Text to `Escape
    the Maze!`. In the Layout menu, select Full Rect. Now, duplicate this node and
    set the second label's Text to Press <space>.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景并添加一个名为`StartScreen`的`Control`节点。添加一个子标签，并添加`res://assets/Unique.ttf`作为新的`DynamicFont`，字体大小为`64`。将“对齐”和“垂直对齐”属性设置为居中，并将文本设置为“逃离迷宫！”。在布局菜单中，选择“全矩形”。现在，复制此节点并将第二个标签的文本设置为按空格。
- en: For this demonstration, the `StartScreen` is being kept very plain. Once you
    have it working, feel free to add decorations, or even an `AnimationPlayer` to
    make a player Sprite run across the screen.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，`StartScreen`被保持得很简单。一旦它开始工作，你可以自由地添加装饰，甚至添加一个`AnimationPlayer`来让玩家精灵在屏幕上跑动。
- en: Choose Scene | Save As to save another copy of this scene and name it `EndScreen`.
    Delete the second `Label` (the one that says Press <space>) and add a `Timer`
    node. Set the Autostart property to On, One Shot to On, and Wait Time to `3`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“场景”|“另存为”来保存此场景的另一个副本，并将其命名为`EndScreen`。删除第二个`Label`（显示“按空格”的标签）并添加一个`Timer`节点。将“自动启动”属性设置为开启，将“单次启动”设置为开启，并将“等待时间”设置为`3`。
- en: The `Timer` will send the game back to the `StartScreen` after it expires.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Timer`在到期后会将游戏送回`StartScreen`。
- en: However, before you can connect these other scenes together, you need to understand
    how to work with persistent data and *Autoloads*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在你可以连接这些其他场景之前，你需要了解如何处理持久数据和*自动加载*。
- en: Globals
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局变量
- en: It is a very common scenario in game development that you have some data that
    needs to persist across multiple scenes. Data that is part of a scene is lost
    when the scene is switched, so persistent data must reside somewhere outside the
    current scene.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，有一个非常常见的场景，你需要一些需要在多个场景中持久存在的数据。当场景切换时，场景中的数据会丢失，因此持久数据必须存在于当前场景之外。
- en: Godot solves this problem with the use of AutoLoads. These are scripts or nodes
    that are automatically loaded in every scene. Because Godot does not support global
    variables, an autoload acts like a *Singleton.* This is a node (with attached
    script) that is automatically loaded in *every* scene. Common uses for AutoLoads
    include storing global data (score, player data, and so on), handling scene switching
    functions, or any other functions that need to be independent of the currently
    running scene.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Godot通过使用自动加载来解决此问题。这些是每个场景都会自动加载的脚本或节点。因为Godot不支持全局变量，所以自动加载就像一个*单例*。这是一个（带有附加脚本的）节点，它会在*每个*场景中自动加载。自动加载的常见用途包括存储全局数据（得分、玩家数据等）、处理场景切换函数，或任何需要独立于当前运行场景的函数。
- en: '**Singleton** is a well-known pattern in programming which describes a class
    that only allows for a single instance of itself, and provides direct access to
    its member variables and functions. In game development, it is often used for
    persistent data that needs to be accessible by various parts of the game.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**单例**是编程中一个著名的模式，它描述了一个只能允许自身存在一个实例的类，并提供对其成员变量和函数的直接访问。在游戏开发中，它通常用于需要被游戏各个部分访问的持久数据。'
- en: When deciding if you need a singleton, ask yourself whether the object or data
    needs to *always* exist and if there will always be *only one* instance of that
    object.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定是否需要单例时，问问自己这个对象或数据是否需要*始终*存在，并且是否将始终只有一个该对象的实例。
- en: Global script
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局脚本
- en: 'First, make a new script by clicking File | New in the Script window. Make
    sure it inherits from `Node` (this is the default), and in the `Path` field, set
    the name to `Global.gd`. Click Create and add the following code to the new script:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在脚本窗口中点击“文件”|“新建”来创建一个新的脚本。确保它从`Node`继承（这是默认设置），并在“路径”字段中设置名称为`Global.gd`。点击创建，并将以下代码添加到新脚本中：
- en: '[PRE15]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This script provides a number of functions you'll need.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本提供了一些你需要的功能。
- en: Most of the work is done by the `change_scene()` method of the `SceneTree`.
    The `SceneTree` represents the foundation of the currently running scene. When
    a scene is loaded or a new node is added, it becomes a member of the `SceneTree`.
    `change_scene()` replaces the current scene with a given one.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作是由`SceneTree`的`change_scene()`方法完成的。`SceneTree`代表当前正在运行的场景的基础。当一个场景被加载或添加新节点时，它成为`SceneTree`的一个成员。`change_scene()`用给定的场景替换当前场景。
- en: The `next_level()` function progresses through the list of levels you've made,
    which are listed in the `levels` array. If you reach the end of the list, the
    game ends.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`next_level()`函数遍历你制作的关卡列表，这些列表在`levels`数组中列出。如果你到达列表的末尾，游戏结束。'
- en: 'To add this script as an autoload, open Project Settings and click on the AutoLoad
    tab. Click the .. button next to Path and select your `Global.gd` script. The node
    Name will automatically be set to Global (this is the name you''ll use to reference
    the node in your scripts, as shown in the following screenshot):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此脚本作为自动加载，打开项目设置并点击自动加载选项卡。点击路径旁边的..按钮，选择你的`Global.gd`脚本。节点名称将自动设置为Global（这是你在脚本中引用节点的名称，如以下截图所示）：
- en: '![](img/00072.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00072.jpeg)'
- en: Now, you can access any of the global script's properties by using its name
    in any script across your whole game, for example, `Global.current_level`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过在任何脚本中使用其名称来访问全局脚本的所有属性，例如，`Global.current_level`。
- en: 'Attach the following script to the `StartScreen`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下脚本附加到`StartScreen`：
- en: '[PRE16]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This script waits for the spacebar to be pressed and then calls the `new_game()`
    function of `Global`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本等待空格键被按下，然后调用`Global`的`new_game()`函数。
- en: 'Add this one to `EndScreen`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将此添加到`EndScreen`：
- en: '[PRE17]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You'll also need to connect the `timeout` signal of `Timer`. To do this, you
    have to create the script first, then the `Connect` button will create the new
    function for you.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要连接`Timer`的`timeout`信号。为此，你必须首先创建脚本，然后`Connect`按钮会为你创建新的函数。
- en: 'In the `Level.gd` script, you can now fill in the remaining two functions:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Level.gd`脚本中，你现在可以填写剩下的两个函数：
- en: '[PRE18]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Score
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分数
- en: The global singleton is a great place to keep the player's score so that it
    will be persistent from level to level. Start by adding a `var score` variable
    at the top of the file, and then in `new_game()`, add `score = 0`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 全局单例是一个很好的地方来保存玩家的分数，以便它在关卡之间保持持久。首先在文件顶部添加一个`var score`变量，然后在`new_game()`中添加`score
    = 0`。
- en: 'Now, you need to add a point whenever a coin is collected. Go to `Pickup.gd`
    and add `signal coin_pickup` at the top. You can emit this signal in the `pickup()`
    function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次收集硬币时都需要添加一个点。转到`Pickup.gd`并添加`signal coin_pickup`在顶部。你可以在`pickup()`函数中发出此信号：
- en: '[PRE19]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The value of `1` is included here in case you want to later change the number
    of points that coins are worth, or add other objects that add different point
    amounts. This signal will be used to update the display, so now you can create
    the `HUD`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这里包含`1`的值，以防你以后想更改硬币的价值数量，或者添加其他增加不同分数的对象。这个信号将用于更新显示，因此现在你可以创建`HUD`。
- en: Make a new scene with a `CanvasLayer` named `HUD` and save the scene. Add a
    `MarginContainer` node as a child, and under that, a `Label` named `ScoreLabel`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，命名为`HUD`的`CanvasLayer`并保存场景。添加一个`MarginContainer`节点作为子节点，并在其下添加一个名为`ScoreLabel`的`Label`。
- en: 'Set the `MarginContainer` Layout to Top Wide and its four margin properties
    (found under Custom Constants) all to `20`. Add the same Custom Font properties
    you used before for the start and end screens, then attach a script:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将`MarginContainer`布局设置为顶部宽，并设置其四个边距属性（在自定义常量下找到）均为`20`。然后添加与之前开始和结束屏幕相同的自定义字体属性，接着附加一个脚本：
- en: '[PRE20]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Add an instance of the `HUD` to the `Level` scene. Remember from the previous
    project that the `CanvasLayer` node will remain on top of the rest of the game.
    It will also ignore any camera movement, so the display will remain fixed in place
    as the player moves around the level.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将`HUD`实例添加到`Level`场景中。记得从上一个项目中，`CanvasLayer`节点将保持在游戏其他部分之上。它还将忽略任何相机移动，因此显示将保持在玩家在关卡中移动时固定位置。
- en: 'Finally, in the `Level.gd` script, when you spawn a new collectible object,
    connect the signal to the `HUD` function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Level.gd`脚本中，当你生成一个新的可收集对象时，将信号连接到`HUD`函数：
- en: '[PRE21]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run the game and collect a few coins to confirm that the score is updating.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并收集一些硬币以确认分数正在更新。
- en: Saving the High Score
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存高分
- en: Many games require you to save some kind of information between play sessions.
    This is information that you want to remain available, even when the application
    itself has quit. Examples include saved games, user-created content, or downloadable
    resource packs. For this game, you'll save a High Score value that will persist
    across game sessions.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏需要你在游戏会话之间保存某种信息。这是你希望保持可用的信息，即使应用程序本身已经退出。例如包括保存的游戏、用户创建的内容或可下载的资源包。对于这个游戏，你将保存一个高分值，该值将在游戏会话之间持续存在。
- en: Reading and writing files
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入文件
- en: As you've seen before, Godot keeps all resources stored as files in the project
    folder. From code, these are accessible under the `res://` folder path. For example, `res://project.godot`
    will always point to the current project's configuration file, no matter where
    on your computer the project is actually stored.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如你之前所见，Godot将所有资源存储为项目文件夹中的文件。从代码中，这些资源可以通过`res://`文件夹路径访问。例如，`res://project.godot`将始终指向当前项目的配置文件，无论项目实际上存储在电脑上的哪个位置。
- en: However, the `res://` filesystem is set as read-only for safety when the project
    is run. It is also read-only when the project is exported. Any data that needs
    to be retained by the user is placed in the `user://` file path. Where this folder
    physically exists will vary depending on what platform the game is running on.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当项目运行时，`res://`文件系统被设置为只读以保障安全。当项目导出时，它也是只读的。任何需要用户保留的数据都放置在`user://`文件路径中。这个文件夹的物理位置将根据游戏运行的平台而有所不同。
- en: You can find the current platform's user-writable data folder using `OS.get_user_data_dir()`.
    Add a `print()` statement to the `ready()` function of one of your scripts to
    see what the location is on your system.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`OS.get_user_data_dir()`找到当前平台的用户可写数据文件夹。将一个`print()`语句添加到你的脚本中的一个`ready()`函数中，以查看系统上的位置。
- en: Reading and writing to files is accomplished using a `File` object. This object
    is used to open the file in read and/or write mode, and can also be used to test
    for a file's existence.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`File`对象来读取和写入文件。此对象用于以读取和/或写入模式打开文件，也可以用于检查文件是否存在。
- en: 'Add the following code to `Global.gd`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Global.gd`中：
- en: '[PRE22]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You first need to test whether the file exists. If it does, you can read the
    value, which is being stored as human-readable text, and assign it to the `highscore`
    variable. Binary data can also be stored in files, if needed, but text will allow
    you to look at the file yourself and check that everything is working.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要测试文件是否存在。如果存在，你可以读取存储为可读文本的值，并将其分配给`highscore`变量。如果需要，文件中也可以存储二进制数据，但文本将允许你自己查看文件并检查一切是否正常工作。
- en: 'Add the following code to check if the player has beat the previous high score:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加以检查玩家是否打破了之前的高分：
- en: '[PRE23]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `save_score()` function opens the file to write the new value. Note that
    if the file doesn't exist, opening in `WRITE` mode will automatically create it.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`save_score()`函数用于打开文件以写入新值。请注意，如果文件不存在，以`WRITE`模式打开将自动创建它。'
- en: 'Next, you need to call the `setup()` function when the game starts, so add
    this to `Global.gd`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当游戏开始时，你需要调用`setup()`函数，所以将以下内容添加到`Global.gd`中：
- en: '[PRE24]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, to display the high score, add another `Label` node to the `StartScreen`
    scene (you can duplicate one of the existing ones). Arrange it below the other
    Labels (or in whatever order you like) and name it `ScoreNotice`. Add the following
    to the script:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了显示高分，将另一个`Label`节点添加到`StartScreen`场景中（你可以复制现有的一个）。将其安排在其他的标签下面（或按你喜欢的任何顺序）并命名为`ScoreNotice`。将以下内容添加到脚本中：
- en: '[PRE25]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run the game and check that your high score is increasing (when you beat it)
    and persisting when you quit and start the game again.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并检查你的高分是否在击败它时增加，并在退出并重新开始游戏时持续存在。
- en: Finishing touches
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成细节
- en: Now that the main functionality of the game is complete, you can add a few more
    features to polish it up a little bit.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏的主要功能已经完成，你可以添加一些更多功能来稍微润色一下。
- en: Death animation
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死亡动画
- en: When the enemy hits the player, you can add a small animation rather than just
    ending the game. The effect will spin the character around while shrinking its
    scale property.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当敌人击中玩家时，你可以添加一个小动画而不是直接结束游戏。效果将使角色围绕旋转并缩小其缩放属性。
- en: Start by selecting the `AnimationPlayer` node of the `Player` and clicking the
    New Animation button: ![](img/00073.jpeg). Name the new animation `die`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，选择`Player`中的`AnimationPlayer`节点，然后点击新建动画按钮：![](img/00073.jpeg)。将新动画命名为`die`。
- en: In this animation, you'll be animating the Sprite's Rotation Degrees and Scale properties.
    Find the Rotation Degrees property in the Inspector and click the key, ![](img/00074.jpeg), to
    add a track. Move the scrubber to the end of the animation, change Rotation Degrees
    to 360, and click the key again. Try playing the animation to see the character
    spin.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个动画中，你将动画 Sprite 的旋转角度和缩放属性。在检查器中找到旋转角度属性，点击 ![](img/00074.jpeg) 添加一个轨道。将刮擦器移动到动画的末尾，将旋转角度更改为
    360，然后再次点击键。尝试播放动画以查看角色旋转。
- en: Keep in mind that while degrees are typically used for Inspector properties,
    when writing code most Godot functions expect angles to be measured in *radians*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，虽然通常使用度数来表示检查器属性，但在编写代码时，大多数 Godot 函数期望角度以 *弧度* 来度量。
- en: Now, do the same thing with the *Scale* property. Add a keyframe (at the beginning!)
    for `(1, 1)` and then another at the end with the scale set to `(0.2, 0.2)`. Try
    playing the animation again to see the results.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用相同的操作处理 *缩放* 属性。在开始处添加一个关键帧 `(1, 1)`，然后在结束时添加另一个关键帧，将缩放设置为 `(0.2, 0.2)`。再次尝试播放动画以查看结果。
- en: 'The new animation needs to be triggered when the player hits an enemy. Add
    the following code to the player''s `_on_Player_area_entered()` function:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家击中敌人时，需要触发新的动画。将以下代码添加到玩家的 `_on_Player_area_entered()` 函数中：
- en: '[PRE26]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The added code takes care of a few things that need to happen. First, hiding
    the enemy that was hit makes sure that it doesn't cover the player and prevent
    you from seeing our new animation. Next, you use `set_process(false)` to stop
    the `_process()` function from running so that the player can't keep moving during
    the animation. You also need to disable the player's collision detection so that
    it doesn't detect another enemy if it happens to wander by.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的代码处理了一些需要发生的事情。首先，隐藏被击中的敌人确保它不会遮挡玩家并阻止你看到我们新的动画。接下来，使用 `set_process(false)`
    停止 `_process()` 函数的运行，这样玩家在动画期间就不能继续移动。你还需要禁用玩家的碰撞检测，这样它就不会检测到另一个敌人，如果它恰好经过的话。
- en: After starting the `die` animation, you need to let it finish before emitting
    the `dead` signal, so `yield` is used to wait for the signal from `AnimationPlayer`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始 `die` 动画后，你需要让它完成，然后再发出 `dead` 信号，因此使用 `yield` 等待 `AnimationPlayer` 的信号。
- en: 'Try running the game and getting hit by an enemy to see the animation. If everything
    works fine, you''ll notice something wrong on the next playthrough: the player
    is tiny! The animation ends with the Sprite''s Scale set to `(0.2, 0.2)` and nothing
    is setting it back to normal size. Add the following to the Player''s script so
    that the scale will always start at the right value:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行游戏并让敌人攻击你以查看动画。如果一切正常，你会在下一次播放时注意到一些问题：玩家变得很小！动画结束时，Sprite 的缩放设置为 `(0.2,
    0.2)`，没有任何东西将其设置回正常大小。向玩家的脚本中添加以下内容，以便缩放始终从正确的值开始：
- en: '[PRE27]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Sound effects
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音效
- en: 'There are six sound effects in the `res://assets/audio` folder for you to use
    in the game. These audio files are in OGG format. By default, Godot sets OGG files
    to loop when imported. Select the OGG files in the FileSystem tab (you can use
    *Shift* + Click to select multiple files) and click the Import tab on the right-hand
    side of the editor window. Uncheck Loop and click the Reimport button:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `res://assets/audio` 文件夹中有六个音效可供你在游戏中使用。这些音频文件是 OGG 格式。默认情况下，Godot 在导入时将 OGG
    文件设置为循环。在 FileSystem 选项卡中选择 OGG 文件（你可以使用 *Shift* + 点击来选择多个文件），然后在编辑器窗口的右侧点击 Import
    选项卡。取消选择 Loop 并点击 Reimport 按钮：
- en: '![](img/00075.jpeg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00075.jpeg)'
- en: First, add the pickup sounds for the items. Add two `AudioStreamPlayer` nodes
    to the `Pickup` scene and name them `KeyPickup` and `CoinPickup`. Drag the corresponding
    audio file into the Stream property of each node.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加物品的拾取声音。在 `Pickup` 场景中添加两个 `AudioStreamPlayer` 节点，分别命名为 `KeyPickup` 和 `CoinPickup`。将相应的音频文件拖动到每个节点的
    Stream 属性中。
- en: 'You can also adjust the sound''s volume via its Volume Db property, as shown
    in the following screenshot:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过其 Volume Db 属性调整音量，如图所示：
- en: '![](img/00076.jpeg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00076.jpeg)'
- en: 'Add the following code to the beginning of the `pickup()` function:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `pickup()` 函数的开始部分：
- en: '[PRE28]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The other sound effects will be added to the `Player` scene. Add three of the `AudioStreamPlayer` and
    name them `Win`, `Lose`, and `Footsteps`, adding the matching sound file to each
    node''s Stream. Update the `_on_Player_area_entered()` function as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 其他音效将添加到 `Player` 场景中。添加三个 `AudioStreamPlayer` 节点，分别命名为 `Win`、`Lose` 和 `Footsteps`，并将匹配的音频文件添加到每个节点的
    Stream 中。更新 `_on_Player_area_entered()` 函数如下：
- en: '[PRE29]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You need to disable the collision and `yield` for the sound to finish, or else
    it would be instantly terminated by the next level loading. This way, the player
    has time to hear the sound before moving on.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要禁用碰撞和 `yield` 以确保声音播放完成，否则它会被下一个关卡加载时立即终止。这样，玩家在继续前进之前有足够的时间听到声音。
- en: 'To play the footsteps, add `$Footsteps.play()` after `if move(dir):` in the
    `_process()` function. Note: you may want to reduce the sound of the footsteps
    so that they don''t overwhelm everything; they should be subtle background sounds.
    In the `Footsteps` node, set the Volume Db property to `-30`.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放脚步声，在 `_process()` 函数中的 `if move(dir):` 后面添加 ``$Footsteps.play()``。注意：你可能想要降低脚步声的音量，以免它们压过其他所有声音；它们应该是微妙的背景声音。在
    `Footsteps` 节点中，将 Volume Db 属性设置为 `-30`。
- en: 'Finally, to play the `Lose` sound, add it to the enemy collision code here:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了播放 `Lose` 声音，将其添加到敌人碰撞代码中：
- en: '[PRE30]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that you need to change the yield function. Since the sound is slightly
    longer than the animation, it will get cut off if you end it on the animation's
    completion. Alternatively, you could adjust the duration of the animation to match
    the length of the sound.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要更改 `yield` 函数。由于声音比动画稍长，如果你在动画完成时结束它，它会被截断。或者，你可以调整动画的持续时间以匹配声音的长度。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this project, you have learned how to take advantage of Godot''s inheritance
    system to organize and share code between different objects in your game. This
    is a very powerful tool that you should keep in mind whenever you start building
    a new game. If you start making multiple objects that repeat the same properties
    and/or code, you should probably stop and think about what you''re doing. Ask
    yourself: *can I use inheritance here to share what these objects have in common?*
    In a bigger game with many more objects, this can save you a large amount of time.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你学习了如何利用 Godot 的继承系统来组织和共享游戏中的不同对象之间的代码。这是一个非常强大的工具，每次你开始构建新游戏时都应该记住。如果你开始创建多个具有相同属性和/或代码的对象，你可能应该停下来思考一下你在做什么。问问自己：*我是否可以使用继承来共享这些对象共有的内容？*
    在一个包含更多对象的大游戏中，这可以为你节省大量时间。
- en: You saw how the `TileMap` node works and how it allows you to quickly design
    maps and spawn new objects. They have many uses across many game genres. As you'll
    see later in this book, TileMaps are also ideal for designing platform game levels
    as well.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了 `TileMap` 节点的工作原理以及它如何让你快速设计地图和生成新对象。它们在许多游戏类型中都有很多用途。正如你将在本书后面看到的那样，TileMaps
    也非常适合设计平台游戏关卡。
- en: You were also introduced to the *AutoLoad* feature, which allows you to create
    a global script that contains persistent data used across multiple scenes. You
    also learned how to implement grid-based movement and used the `AnimationPlayer`
    to work with spritesheet animations.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你还介绍了 *AutoLoad* 功能，它允许你创建一个包含跨多个场景使用的持久数据的全局脚本。你还学习了如何实现基于网格的移动，并使用 `AnimationPlayer`
    来处理精灵图动画。
- en: 'In the next chapter, you''ll learn about Godot''s powerful physics body: the
    `RigidBody2D`. You''ll use it to create a game in a classic genre: the space shooter.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于 Godot 强大的物理体：`RigidBody2D`。你将使用它来创建一个经典类型的游戏：太空射击游戏。
