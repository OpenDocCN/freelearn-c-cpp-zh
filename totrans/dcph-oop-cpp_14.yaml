- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding STL Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue our pursuit of increasing your C++ programming repertoire
    beyond OOP concepts by delving into a core C++ library that has become thoroughly
    integrated into the common usage of the language. We will explore the **Standard
    Template Library** (**STL**) in C++ by examining a subset of this library, representing
    common utilities that can both simplify our programming and make our code more
    easily understood by others who are undoubtedly familiar with the STL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Surveying the contents and purpose of the STL in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to use essential STL containers – `list`, `iterator`, `vector`,
    `deque`, `stack`, `queue`, `priority_queue`, `map`, and `map` using a functor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing STL containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to utilize core STL classes to
    enhance your programming skills. Because you already understand the essential
    C++ language and OOP features in which libraries are built, you will see that
    you now have the ability to navigate and understand nearly any C++ class library,
    including the STL. By gaining familiarity with the STL, you will be able to enhance
    your programming repertoire significantly and become a more savvy and valuable
    programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s increase our C++ toolkit by examining a very heavily utilized class library,
    the STL.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter14](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter14).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter14` in a file named `Chp14-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3PCL5IJ](https://bit.ly/3PCL5IJ).'
  prefs: []
  type: TYPE_NORMAL
- en: Surveying the contents and purpose of the STL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Standard Template Library** in C++ is a library of standard classes and
    utilities that extend the C++ language. The use of the STL is so pervasive that
    it is as though the STL is a part of the language itself; it is an essential and
    integral part of C++. The STL in C++ has four key components comprising the library:
    **containers**, **iterators**, **functions**, and **algorithms**.'
  prefs: []
  type: TYPE_NORMAL
- en: The STL has additionally influenced the C++ Standard Library in providing a
    set of programming standards; the two libraries actually share common features
    and components, most notably containers and iterators. We’ve already utilized
    components from the Standard Library, namely `<iostream>` for IOStreams, `<exception>`
    for exception handling, and `<new>` for operators `new()` and `delete()`. In this
    chapter, we will explore many overlapping components between the STL and the Standard
    Library in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'The STL has a full line of **container** classes. These classes encapsulate
    traditional data structures to allow similar items to be collected together and
    uniformly processed. There are several categories of container classes – sequential,
    associative, and unordered. Let’s summarize these categories and provide a few
    examples of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '`list`, `queue`, or `stack`. It is interesting to note that `queue` and `stack`
    can be thought of as a customized or adaptive interface for a more basic container,
    such as a `list`. Nonetheless, a `queue` and `stack` still provide sequential
    access to their elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set` or `map`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unordered_set` or `unordered_map`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order for these container classes to be potentially used for any data type
    (and to preserve strong type checking), templates are utilized to abstract and
    genericize the data types of the collected items. In fact, we built our own container
    classes using templates in [*Chapter 13*](B19087_13.xhtml#_idTextAnchor561), *Working
    with Templates*, including `LinkList` and `Array`, so we already have a basic
    understanding of templatized container classes!
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the STL provides a full complement of **iterators**, which allow
    us to *walk through* or traverse containers. Iterators keep track of our current
    place without corrupting the content or ordering of the respective collections
    of objects. We will see how iterators allow us to process container classes more
    safely within the STL.
  prefs: []
  type: TYPE_NORMAL
- en: The STL also contains a plentiful supply of useful **algorithms**. Examples
    include sorting, counting the number of elements in a collection that may satisfy
    a condition, searching for particular elements or subsequences within elements,
    or copying elements in a variety of manners. Additional examples of algorithms
    include modifying a sequence of objects (replacing, swapping, and removing values),
    partitioning sets into ranges, or merging sets back together. Moreover, the STL
    contains many other useful algorithms and utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the STL includes functions. Actually, it would be more correct to say
    that the STL includes `operator()` (the function call operator), and by doing
    so, allow us to achieve parameterized flexibility through a function pointer.
    Though this is not an elementary feature of the STL we will immediately (or often)
    use, we will see one small, simple example of a functor in this chapter coupled
    with an STL container class, in the upcoming section *Examining STL map using
    a functor*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the container class section of the STL. Though
    we won’t examine every STL container class in the STL, we will review a healthy
    assortment of these classes. We will notice that some of these container classes
    are similar to classes that we have built together in previous chapters of this
    book. Incidentally, during the incremental chapter progressions of this book,
    we have also built up our C++ language and OOP skills, which are necessary to
    decode a C++ class library such as STL.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move forward to take a look at selective STL classes and test our C++
    knowledge as we interpret each class.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to use essential STL containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will put our C++ skills to the test by decoding various
    STL container classes. We will see that language features we have mastered, from
    core C++ syntax to OOP skills, have put us in a position to easily interpret the
    various components of STL we will now examine. Most notably, we will put our knowledge
    of templates to use! Our knowledge of encapsulation and inheritance, for example,
    will guide us to understand how to use various methods in STL classes. However,
    we will notice that virtual functions and abstract classes are extremely rare
    in the STL. The best way to gain competence with a new class within the STL will
    be to embrace the documentation detailing each class. With knowledge of C++, we
    can easily navigate through a given class to decode how to use it successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The container classes in the C++ STL implement various `list`, `iterator`, `vector`,
    `deque`, `stack`, `queue`, `priority_queue`, and `map`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by examining how to utilize a very basic STL container, `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `list` class encapsulates the data structures necessary to implement
    a linked list. We can say that `list` implements the Abstract Data Type of a linked
    list. Recall that we have made our own linked list by creating `LinkedListElement`
    and `LinkedList` classes in [*Chapter 6*](B19087_06.xhtml#_idTextAnchor314), *Implementing
    Hierarchies with Inheritance*. STL `list` allows for easy insertion, deletion,
    and sorting of elements. Direct access to individual elements (known as *random
    access*) is not supported. Rather, you must iteratively traverse past a prior
    item in the linked list until you reach the desired item. STL `list` is a good
    example of a sequential container.
  prefs: []
  type: TYPE_NORMAL
- en: STL `list` actually supports bidirectional sequential access to its elements
    (it is implemented using a doubly-linked list). The STL additionally offers `forward_list`,
    allowing unidirectional sequential access to its elements with a smaller footprint
    than `list`; `forward_list` is implemented using a singly-linked list (much like
    our `LinkedList` class).
  prefs: []
  type: TYPE_NORMAL
- en: The STL `list` class has an assortment of member functions; we’ll start by taking
    a look at a few popular methods in this example to get familiar with basic STL
    container class usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at how we can utilize the STL `list` class. This example
    can be found, as a full working program with necessary class definitions, in our
    GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s examine the aforementioned program segment, where we create and utilize
    an STL `list`. First, we `#include <list>` to include the appropriate STL header
    file. We also add `using std::list;` to include `list` from the standard namespace.
    Now, in `main()`, we can instantiate a list using `list<Student> studentBody;`.
    Our list will contain `Student` instances. Then, we create `Student s1` on the
    stack and `Student *s2` on the heap using an allocation with `new()`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use `list::push_back()` to add both `s1` and `*s2` to the list. Notice
    that we are passing objects to `push_back()`. As we add `Student` instances to
    the `studentBody` list, the list will make copies of the objects internally and
    will properly clean up these objects when they are no longer members of the list.
    We need to keep in mind that if any of our instances have been allocated on the
    heap, such as `*s2`, we must delete our copy of that instance when we are done
    with it at the end of `main()`. Looking ahead to the end of `main()`, we can see
    that we appropriately `delete s2;`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add three more students to the list. These `Student` instances do not
    have local identifiers. These students are instantiated within the call to `push_back()`,
    for example, `studentBody.push_back(Student("Hana", "Sato", 'U', "Dr.", 3.8, "C++",
    "178PSU"));`. Here, we are instantiating an *anonymous (stack) object* that will
    be properly popped off the stack and destructed once the call to `push_back()`
    concludes. Keep in mind, `push_back()` will also create its own local copy for
    these instances for their life expectancy within the `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in a while loop, we repeatedly check whether the list is `empty()` and
    if not, we examine the `front()` item and call our `Student::Print()` method.
    We then use `pop_front()` to remove that item from the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have deciphered a simple STL `list` class, let us move forward to
    understand the idea of an `iterator` to complement a container such as `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL iterator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quite often, we will need a non-destructive way to iterate through a collection
    of objects. For example, it is important to maintain the first, last, and current
    position in a given container, especially if the set may be accessed by more than
    one method, class, or thread. Using an **iterator**, the STL provides a common
    means to traverse any container class.
  prefs: []
  type: TYPE_NORMAL
- en: The use of iterators has definite benefits. A class can create an `iterator`
    that points to the first member in a collection. Iterators can then be moved to
    successive next members of the collection. Iterators can provide access to elements
    pointed to by the `iterator`.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the state information of a container can be maintained by an `iterator`.
    Iterators provide a safe means for interleaved access by abstracting the state
    information away from the container and instead into the iterator class.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of an iterator as a bookmark within a book that two or more people
    are referencing. The first person reads the book sequentially, leaving the bookmark
    neatly where they expect to continue reading. While they step away, another person
    looks up an important item in the book and moves the bookmark to another location
    in the book to save their spot. When the first person returns, they find that
    they have lost their current location and are not where they expect to be. Each
    user should have had their own bookmark or iterator. The analogy is that an iterator
    (ideally) allows safe interleaved access to a resource that may be handled by
    multiple components within an application. Without an iterator, you may unintentionally
    modify a container without another user’s knowledge. STL iterators mostly, but
    not always, live up to this ideal goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at how we can utilize an STL `iterator`. This example can
    be found as a complete program in our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at our previously defined code segment. Here, we include both
    the `<list>` and `<iterator>` headers from the STL. We also add `using std::list;`
    and `using std::iterator;` to include `list` and `iterator` from the standard
    namespace. As in our previous `main()` function, we instantiate a `list` that
    can contain `Student` instances using `list<Student> studentbody;`. We then instantiate
    several `Student` instances and add them to the list using `push_back()`. Again,
    notice that several `Student` instances are *anonymous objects*, having no local
    identifier in `main()`. These instances will be popped off the stack when `push_back()`
    completes. This is no problem, as `push_back()` will create local copies for the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can sort the list using `studentBody.sort();`. It is important to note
    that this `list` method required us to overload `operator<` to provide a means
    of comparison between two `Student` instances. Luckily, we have! We have chosen
    to implement `operator<` by comparing `gpa`, but it could also have used `studentId`
    for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a `list`, we can create an `iterator` and establish it to refer
    to the first item of the `list`. We do so by declaring `list <Student>::iterator
    listIter = studentBody.begin();`. With the iterator established, we can use it
    to safely loop through the `list` from start (as it is initialized) to `end()`.
    We assign a local reference variable `temp` to the loop iteration’s current first
    element in the list with `Student &temp = *listIter;`. We then call a method on
    this instance with `temp.EarnPhD();`, and then we increment our iterator by one
    element using `++listIter;`.
  prefs: []
  type: TYPE_NORMAL
- en: In the subsequent loop, we simplify our declaration of the iterator using `auto`.
    The `auto` keyword allows the type of the iterator to be determined by its initial
    usage. Within this loop, we also eliminate the usage of `temp` – we simply deference
    the iterator first within parentheses and then invoke `Print()` by using `(*autoIter).Print()`.
    Using `++autoIter` simply advances to the next item in our list for processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the sorted output for this program (sorted by `gpa`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen an `iterator` class in action, let’s investigate a variety
    of additional STL container classes, starting with `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `vector` class implements the Abstract Data Type of a dynamic array.
    Recall that we have made our own dynamic array by creating an `Array` class in
    [*Chapter 13*](B19087_13.xhtml#_idTextAnchor561), *Working with Templates*. The
    STL version, however, will be far more extensive.
  prefs: []
  type: TYPE_NORMAL
- en: The `vector` (dynamic or resizable array) will expand as necessary to accommodate
    additional elements beyond its initial size. The `vector` class allows direct
    (that is, *random access*) to elements by overloading `operator[]`. A `vector`
    allows elements to be accessed in constant time through direct access. It is not
    necessary to walk past all prior elements to access an element at a specific index.
  prefs: []
  type: TYPE_NORMAL
- en: However, adding elements in the middle of a `vector` is time-consuming. That
    is, adding to any location other than the end of the `vector` requires all elements
    past the insertion point to be internally shuffled; it may also require an internal
    resizing of the `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, `list` and `vector`, by comparison, have different strengths and weaknesses.
    Each is geared to different requirements of a collection of data. We can choose
    the one that best fits our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an assortment of common `vector` member functions. This
    is far from a complete list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_14.1_B19087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The STL `vector` class additionally includes overloaded `operator=` (assignment
    replaces destination vector with source vector), `operator==` (comparison of vectors,
    element by element), and `operator[]` (returns a reference to the requested location,
    that is, writable memory).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at how we can utilize the STL `vector` class with some of
    its basic operations. This example can be found, as a full working program, in
    our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the previously listed code segment, we `#include <vector>` to include the
    appropriate STL header file. We also add `using std::vector;` to include `vector`
    from the standard namespace. Now, in `main()`, we can instantiate two vectors
    using `vector<Student> studentBody1, studentBody2;`. We can then use the `vector::push_back()`
    method to add several `Student` instances in succession to our first `vector`.
    Again, notice that the `Student` instances are *anonymous objects* in `main()`.
    That is, there is no local identifier that references them – they are created
    only to be placed into our vector, which makes a local copy of each instance upon
    insertion. Once we have elements in our vector, we then loop through our first
    `vector`, printing each `Student` using `studentBody1[i].Print();`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we demonstrate the overloaded assignment operator for `vector` by assigning
    one vector to another using `studentBody1 = studentBody2;`. Here, we make a deep
    copy from right to left in the assignment. We can then test whether the two vectors
    are equal using the overloaded comparison operator within a conditional statement,
    that is, `if (studentBody1 == studentBody2)`.
  prefs: []
  type: TYPE_NORMAL
- en: We then apply `EarnPhD()` to the contents of the second vector in a `for` loop
    using an iterator specified with `auto iter = studentBody2.begin();`. The `auto`
    keyword allows the type of the iterator to be determined by its initial usage.
    We then print out the contents of our second vector using a preferred range-for
    loop (as well as using `auto` to simplify the variable type in the range-for loop).
    Finally, we look through our first `vector`, testing whether it is `empty()`,
    and then clear elements one by one using `studentBody1.clear();`. We have now
    seen a sampling of the `vector` methods and their capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s investigate the STL `deque` class to further our knowledge of STL
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL deque
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `deque` class (pronounced *deck*) implements the Abstract Data Type
    of a double-ended queue. This ADT extends the notion that a queue is first in,
    first out. Instead, the `deque` class allows greater flexibility. Adding elements
    at either end of a `deque` is quick. Adding elements in the middle of a `deque`
    is time-consuming. A `deque` is a sequential container, though more flexible than
    a `list`.
  prefs: []
  type: TYPE_NORMAL
- en: You might imagine that a `deque` is a specialization of a `queue`; it is not.
    Instead, the flexible `deque` class will serve as a basis to implement other container
    classes, which we will see shortly. In these cases, private inheritance will allow
    us to conceal `deque` as an underlying implementation (with vast functionality)
    for more restrictive, specialized classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an assortment of common `deque` member functions. This
    is far from a complete list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_14.2_B19087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The STL `deque` class additionally includes overloaded `operator=` (assignment
    of the source to destination deque) and `operator[]` (returns a reference to requested
    location – writable memory).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at how we can utilize the STL `deque` class. This example
    can be found, as a full working program, in our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex4.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the previously listed code segment, we `#include <deque>` to include the
    appropriate STL header file. We also add `using std::deque;` to include `deque`
    from the standard namespace. Now, in `main()`, we can instantiate a `deque` to
    contain `Student` instances using `deque<Student> studentBody;`. We then call
    either `deque::push_back()` or `deque::push_front()` to add several `Student`
    instances (some anonymous objects) to our `deque`. We are getting the hang of
    this! Now, we insert a `Student` one position past the front of our deque using
    `studentBody.insert(std::next(studentBody.begin()), Student("Anne", "Brennan",
    'B', "Ms.", 3.9, "C++", "299CU"));`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we take advantage of overloaded `operator[]` to insert a `Student` into
    our deque using `studentBody[0] = s1;`. Please be warned that `operator[]` does
    not do any bounds checking on our deque! In this statement, we insert `Student`
    `s1` into the 0th position in the `deque`, instead of the `Student` that once
    occupied that position. A safer bet is to use the `deque::at()` method, which
    will incorporate bounds checking. Regarding the aforementioned assignment, we
    also want to ensure that `operator=` has been overloaded for both `Person` and
    `Student`, as each class has dynamically allocated data members.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we loop through until our `deque` is `empty()`, extracting and printing
    the front element of the deque using `studentBody.front().Print();`. With each
    iteration, we also pop the front item from our `deque` using `studentBody.pop_front();`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a feel for a `deque`, let’s next investigate the STL `stack`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `stack` class implements the Abstract Data Type of a stack. The stack
    ADT supports the `stack` includes a public interface that does not advertise its
    underlying implementation. After all, a stack might change its implementation;
    the ADTs usage should not depend in any manner on its underlying implementation.
    The STL `stack` is considered an adaptive interface of a basic sequential container.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that we have made our own `Stack` class in [*Chapter 6*](B19087_06.xhtml#_idTextAnchor314),
    *Implementing Hierarchies with Inheritance*, using a private base class of `LinkedList`.
    The STL version will be more extensive; interestingly, it is implemented using
    `deque` as its underlying private base class. With `deque` as a private base class
    of the STL `stack`, the more versatile underlying capabilities of `deque` are
    hidden; only the applicable methods are used to implement the stack’s public interface.
    Also, because the means of implementation is hidden, a `stack` may be implemented
    using another container class at a later date without impacting its usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an assortment of common `stack` member functions. This
    is far from a complete list. It is important to note that the public interface
    for `stack` is far smaller than that of its private base class, `deque`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_14.3_B19087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The STL `stack` class additionally includes overloaded `operator=` (assignment
    of source to destination stack), `operator==` and `operator!=` (equality/inequality
    of two stacks), and `operator<` , `operator>`, `operator<=`, and `operator>=`
    (comparison of stacks).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at how we can utilize the STL `stack` class. This example
    can be found, as a full working program, in our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex5.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code segment, we `#include <stack>` to include the appropriate
    STL header file. We also add `using std::stack;` to include `stack` from the standard
    namespace. Now, in `main()`, we can instantiate a `stack` to contain `Student`
    instances using `stack<Student> studentBody;`. We then call `stack::push()` to
    add several `Student` instances to our `stack`. Notice that we are using the traditional
    `push()` method, which contributes to the ADT of a stack.
  prefs: []
  type: TYPE_NORMAL
- en: We then loop through our `stack` while it is not `empty()`. Our goal is to access
    and print the top element using `studentBody.top().Print();`. We then neatly pop
    our top element off the stack using `studentBody.pop();`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s investigate the STL `queue` class to further increase our STL container
    repertoire.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `queue` class implements the ADT of a queue. As the stereotypical queue
    class, STL’s `queue` class supports the **first in, first out** (**FIFO**) order
    of insertion and removal of members.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that we made our own `Queue` class in [*Chapter 6*](B19087_06.xhtml#_idTextAnchor314),
    *Implementing Hierarchies with Inheritance*; we derived our `Queue` from our `LinkedList`
    class using private inheritance. The STL version will be more extensive; the STL
    `queue` class is implemented using `deque` as its underlying implementation (also
    using private inheritance). Remember, because the means of implementation are
    hidden with private inheritance, a `queue` may be implemented using another data
    type at a later date without impacting its public interface. The STL `queue` class
    is another example of an adaptive interface for a basic sequential container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an assortment of common `queue` member functions. This
    is far from a complete list. It is important to note that the public interface
    of `queue` is far smaller than that of its private base class, `deque`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_14.4_B19087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The STL `queue` class additionally includes overloaded `operator=` (assignment
    of source to destination queue), `operator==` and `operator!=` (equality/inequality
    of two queues), and `operator<` , `operator>`, `operator<=`, and `operator>=`
    (comparison of queues).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at how we can utilize the STL `queue` class. This example
    can be found, as a full working program, in our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex6.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code segment, we first `#include <queue>` to include the appropriate
    STL header file. We also add `using std::queue;` to include `queue` from the standard
    namespace. Now, in `main()`, we can instantiate a `queue` to contain `Student`
    instances using `queue<Student> studentBody;`. We then call `queue::push()` to
    add several `Student` instances to our `queue`. Recall that with the queue ADT,
    `push()` implies that we are adding an element at the end of the queue. Some programmers
    prefer the term *enqueue* to describe this operation; however, the STL has selected
    to name this operation `push()`. With the `queue` ADT, `pop()` will remove an
    item from the front of the queue; a better term is *dequeue*, however, that is
    not what the STL has chosen. We can adapt.
  prefs: []
  type: TYPE_NORMAL
- en: We then loop through our `queue` while it is not `empty()`. Our goal is to access
    and print the front element using `studentBody.front().Print();`. We then neatly
    pop our front element off the `queue` using `studentBody.pop();`. Our work is
    complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have tried a `queue`, let’s investigate the STL `priority_queue`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL priority queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `priority_queue` class implements the Abstract Data Type of a priority
    queue. The priority queue ADT supports a modified FIFO order of insertion and
    removal of members; the elements are *weighted*. The front element is of the largest
    value (determined by overloaded `operator<`) and the rest of the elements follow
    in sequence from the next greatest to the least. The STL `priority_queue` class
    is considered an adaptive interface for a sequential container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that we implemented our own `PriorityQueue` class in [*Chapter 6*](B19087_06.xhtml#_idTextAnchor314),
    *Implementing Hierarchies with Inheritance*. We used public inheritance to allow
    our `PriorityQueue` to specialize our `Queue` class, adding additional methods
    to support the priority (weighted) enqueuing scheme. The underlying implementation
    of `Queue` (with private base class `LinkedList`) was hidden. By using public
    inheritance, we allowed our `PriorityQueue` to be able to be generalized as a
    `Queue` through upcasting (which we understood once we learned about polymorphism
    and virtual functions in [*Chapter 7*](B19087_07.xhtml#_idTextAnchor366), *Utilizing
    Dynamic Binding through Polymorphism*). We made an acceptable design choice: *PriorityQueue
    Is-A* (specialization of) *Queue* and at times may be treated in its more general
    form. We also recall that neither a `Queue` nor a `PriorityQueue` could be upcast
    to their underlying implementation of a `LinkedList`, as `Queue` was derived privately
    from `LinkedList`; we cannot upcast past a non-public inheritance boundary.'
  prefs: []
  type: TYPE_NORMAL
- en: Contrastingly, the STL version of `priority_queue` is implemented using the
    STL `vector` as its underlying implementation. Recall that because the means of
    implementation is hidden, a `priority_queue` may be implemented using another
    data type at a later date without impacting its public interface.
  prefs: []
  type: TYPE_NORMAL
- en: An STL `priority_queue` allows an inspection, but not a modification, of the
    top element. The STL `priority_queue` does not allow insertion through its elements.
    That is, elements may only be added resulting in an order from greatest to least.
    Accordingly, the top element may be inspected, and the top element may be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an assortment of common `priority_queue` member functions.
    This is not a complete list. It is important to note that the public interface
    of `priority_queue` is far smaller than that of its private base class, `vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_14.5_B19087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unlike the previously examined container classes, the STL `priority_queue` does
    not overload operators, including `operator=`, `operator==`, and `operator<`.
  prefs: []
  type: TYPE_NORMAL
- en: The most interesting method of `priority_queue` is that of `void emplace(args);`.
    This is the member function that allows the priority enqueuing mechanism to add
    items to this ADT. We also notice that `top()` must be used to return the top
    element (versus `front()`, which a `queue` utilizes). But then again, an STL `priority_queue`
    is not implemented using a `queue`). To utilize `priority_queue`, we `#include
    <queue>`, just as we would for a `queue`.
  prefs: []
  type: TYPE_NORMAL
- en: Because the usage of `priority_queue` is so similar to `queue`, we will instead
    explore it further, programming-wise, in our question set at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen many examples of sequential container types in STL (including
    adaptive interfaces), let’s next investigate the STL `map` class, an associative
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Examining STL map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `map` class implements the Abstract Data Type of a hash table. The class
    `map` allows for elements in the hash table or map to be stored and retrieved
    quickly using a `multimap` can be used instead should there be more than one piece
    of data that needs to be associated with a single key.
  prefs: []
  type: TYPE_NORMAL
- en: Hash tables (maps) are fast for storage and lookup of data. The performance
    is a guaranteed *O(log(n))*. The STL `map` is considered an associative container,
    as it associates a key to a value to quickly retrieve a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an assortment of common `map` member functions. This is
    not a complete list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_14.6_B19087.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The STL class map additionally includes overloaded operator `operator==` (comparison
    of maps, element by element) implemented as a global function. STL map also includes
    overloaded `operator[]` (returns a reference to the map element associated with
    a key that is used as an index; this is writable memory).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at how we can utilize the STL `map` class. This example can
    be found, as a full working program, in our GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex7.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let’s examine the preceding code segments. Again, we include the applicable
    header file with `#include <map>`. We also add `using std::map;` and `using std::pair;`
    to include `map` and `pair` from the standard namespace. Next, we instantiate
    four `Student` instances. Next, we create three `pair` instances to associate
    a grouping between each Student and its key (that is, with their respective `studentId`)
    using the declaration `pair<string, Student> studentPair1 (s1.GetStudentId(),
    s1);`. This may seem confusing to read, but let’s break this declaration down
    into its components. Here, the instance’s data type is `pair<string, Student>`,
    the variable name is `studentPair1`, and `(s1.GetStudentId(), s1)` are the arguments
    passed to the specific `pair` instance’s constructor.
  prefs: []
  type: TYPE_NORMAL
- en: We will be making a hash table (`map`) of `Student` instances to be indexed
    by a key (which is their `studentId`). Next, we declare a `map` to hold the collection
    of `Student` instances with `map<string, Student> studentBody;`. Here, we indicate
    that the association between the key and element will be between a `string` and
    a `Student`. We then declare a map iterator with `map<string, Student>::iterator
    mapIter;` using the same data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we simply insert the three `pair` instances into the `map`. An example
    of this insertion is `studentBody.insert(studentPair1);`. We then insert a fourth
    `Student`, `s4`, into the `map` using the map’s overloaded `operator[]` with the
    following statement: `studentBody[s4.GetStudentId()] = s4;`. Notice that the `studentId`
    is used as the index value in `operator[]`; this value will become the key value
    for the `Student` in the hash table.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare and establish the map iterator to the beginning of the `map`
    and then process the `map` while it is not at the `end()`. Within the loop, we
    set a variable, `temp`, to the `pair` at the front of the map, indicated by the
    map iterator. We also set `tempS` as a temporary reference to a `Student` in the
    `map`, which is indicated by `temp.second` (the second value in the current `pair`
    managed by the map iterator). We now can print out each `Student` instance’s `studentId`
    (the key, which is a `string`) using `temp.first` (the first item in the current
    `pair`). In the same statement, we can then print out each `Student` instance’s
    `firstName` using `temp.second.GetFirstName()` (since the `Student` corresponding
    to the key is the second item in the current `pair`). Similarly, we could also
    use `tempS.GetLastName()` to print a student’s `lastName`, as `tempS` was previously
    initialized to the second element in the current `pair` at the beginning of each
    loop iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as an alternative to the more tedious approach demonstrated previously
    used to iterate through the `map` (taking apart the `pair` manually), let’s examine
    the final loop in our program. Here, we utilize a range-for loop to process the
    `map`. The use of `auto` with `&[id, student]` will specify the type of data that
    we will iterate. The brackets (`[]`) will decompose the `pair`, binding the iterative
    elements to `id` and `student`, respectively, as identifiers. Notice the ease
    at which we can now iterate over the `studentBody` map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s take a look at an alternative with an STL `map`, which will introduce
    us to the STL `functor` concept.
  prefs: []
  type: TYPE_NORMAL
- en: Examining STL map using a functor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The STL `map` class has great flexibility, like many STL classes. In our past
    `map` example, we assumed that a means for comparison was present in our `Student`
    class. We had, after all, overloaded `operator<` for two `Student` instances.
    What happens, however, if we cannot revise a class that has not provided this
    overloaded operator and we also choose not to overload `operator<` as an external
    function?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we may specify a third data type for the template type expansion
    when instantiating a `map` or map iterator. This additional data type will be
    a specific type of class, known as a functor. A `operator()`. It is within overloaded
    `operator()` that we will provide a means of comparison for the objects in question.
    A functor essentially simulates encapsulating a function pointer by overloading
    `operator()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at how we might revise our `map` example to utilize a simple
    functor. This example can be found, as a full working program, in our GitHub as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex8.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter14/Chp14-Ex8.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the previously mentioned code fragment, we first introduce a user defined
    type of `comparison`. This can be a `class` or a `struct`. Within this structure
    definition, we have overloaded the function call operator (`operator()`) and provided
    a means of comparison between two `string` keys for `Student` instances. This
    comparison will allow `Student` instances to be inserted in an order determined
    by the comparison functor.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we instantiate our `map` and map iterators, we specify as the third
    parameter for the template type expansion our `comparison` type (the functor).
    And, neatly embedded within this type is the overloaded function call operator,
    `operator()`, which will provide our needed comparison. The remaining code will
    be similar to our original `map` program.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, functors may be used in additional, more advanced ways beyond what
    we have seen here with the container class `map`. Nonetheless, you now have a
    flavor for how a functor can apply to the STL.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to utilize a variety of STL container classes, let’s
    consider why we may want to customize an STL class, and how to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing STL containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most classes in C++ can be customized in some fashion, including classes in
    the STL. However, we must be aware of design decisions made within the STL that
    will limit how we may customize these components. Because the STL container classes
    purposely do not include virtual destructors or other virtual functions, we should
    not use specialization via public inheritance to extend these classes. Note that
    C++ will not stop us, but we know from [*Chapter 7*](B19087_07.xhtml#_idTextAnchor366),
    *Using Dynamic Binding through Polymorphism*, that we should never override non-virtual
    functions. STL’s choice to not include virtual destructors and other virtual functions
    to allow further specialization of these classes was a solid design choice made
    long ago when STL containers were crafted.
  prefs: []
  type: TYPE_NORMAL
- en: We could, however, use private or protected inheritance, or the concepts of
    containment or association to use an STL container class as a building block.
    That is, to hide the underlying implementation of a new class, where the STL provides
    a solid, yet hidden implementation for the new class. We would simply provide
    our own public interface for the new class and, under the hood, delegate the work
    to our underlying implementation (whether that be a private or protected base
    class, or a contained or associated object).
  prefs: []
  type: TYPE_NORMAL
- en: Extreme care and caution must be taken when extending any template class, including
    those in the STL using private or protected base classes. This caution will also
    apply to containing or associating to other template classes. Template classes
    are generally not compiled (or syntax checked) until an instance of the template
    class with a specific type is created. This means that any derived or wrapper
    classes that are created can only be fully tested when instances of specific types
    are created.
  prefs: []
  type: TYPE_NORMAL
- en: Appropriate overloaded operators will need to be put in place for new classes
    so that these operators will work automatically with customized types. Keep in
    mind that some operator functions, such as `operator=`, are not explicitly inherited
    from base to derived class and need to be written with each new class. This is
    appropriate since derived classes will likely have more work to accomplish than
    found in the generalized versions of `operator=`. Remember, if you cannot modify
    the class definition of a class requiring a selected overloaded operator, you
    must implement that operator function as an external function.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to customizing containers, we may also choose to augment an algorithm
    based on an existing algorithm within the STL. In this case, we would use one
    of the many STL functions as part of a new algorithm’s underlying implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing classes from existing libraries comes up routinely in programming.
    For example, consider how we extended the Standard Library `exception` class to
    create customized exceptions in [*Chapter 11*](B19087_11.xhtml#_idTextAnchor488),
    *Handling Exceptions* (though that scenario utilized public inheritance, which
    will not apply to customizing STL classes). Keep in mind that the STL offers a
    very full complement of container classes. Rarely will you find the need to augment
    STL classes – perhaps only with a very domain-specific class need. Nonetheless,
    you now know the caveats involved in customizing STL classes. Remember, care and
    caution must always be used when augmenting a class. We can now see the need to
    employ proper OO component testing for any classes we create.
  prefs: []
  type: TYPE_NORMAL
- en: We have now considered how to potentially customize STL container classes and
    algorithms within our programs. We have also seen quite a few STL container class
    examples in action. Let us now briefly recap these concepts before moving forward
    to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have furthered our C++ knowledge beyond OOP language features
    to gain familiarity with the C++ Standard Template Library. As this library is
    used so commonly in C++, it is essential that we understand both the scope and
    breadth of the classes it contains. We are now prepared to utilize these useful,
    well-tested classes in our code.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at quite a few STL examples; by examining selective STL classes,
    we should feel empowered to understand the remainder of the STL (or any C++ library)
    on our own.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to use common and essential STL classes such as `list`, `iterator`,
    `vector`, `deque`, `stack`, `queue`, `priority_queue`, and `map`. We have also
    seen how to utilize a functor in conjunction with a container class. We have been
    reminded that we now have the tools to potentially customize any class, even those
    from class libraries such as STL through private or protected inheritance, or
    with containment or association.
  prefs: []
  type: TYPE_NORMAL
- en: We have additionally seen through examining selected STL classes that we have
    the skills to understand the remaining depth and breadth of the STL, as well as
    decode many additional class libraries that are available to us. As we navigate
    the prototypes of each member function, we notice key language concepts, such
    as the use of `const`, or that a method returns a reference to an object representing
    writable memory. Each prototype reveals the mechanics for the usage of the new
    class. It is very exciting to have come this far with our programming endeavors!
  prefs: []
  type: TYPE_NORMAL
- en: We have now added additional, useful features to our C++ repertoire through
    browsing the STL in C++. Usage of the STL (to encapsulate traditional data structures)
    will ensure that our code can easily be understood by other programmers who are
    also undoubtedly using the STL. Relying on the well-tested STL for these common
    containers and utilities ensures that our code remains more bug-free.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to continue forward with [*Chapter 15*](B19087_15.xhtml#_idTextAnchor655),
    *Testing Classes and Components*. We want to complement our C++ programming skills
    with useful OO component testing skills. Testing skills will help us understand
    whether we have created, extended, or augmented classes in a robust fashion. These
    skills will make us better programmers. Let’s continue onward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Replace your template `Array` class from your exercise from [*Chapter 13*](B19087_13.xhtml#_idTextAnchor561),
    *Working with Templates*, with an STL `vector`. Create a `vector` of `Student`
    instances. Use `vector` operations to insert, retrieve, print, compare, and remove
    objects from the vector. Alternatively, utilize an STL `list`. Use this opportunity
    to utilize the STL documentation to navigate the full set of operations available
    for these classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Consider what operators, if any, you will need to overload. Consider whether
    you will need an `iterator` to provide safe interleaved access to your collection.
  prefs: []
  type: TYPE_NORMAL
- en: b. Create a second `vector` of `Student` instances. Assign one to another. Print
    both vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Modify the `map` from this chapter to index the hash table (map) of `Student`
    instances based on `lastName` rather than `studentId`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `queue` example from this chapter to instead utilize `priority_queue`.
    Be sure to make use of the priority enqueueing mechanism `priority_queue::emplace()`
    to add elements into the `priority_queue`. You will also need to utilize `top()`
    instead of `front()`. Note that `priority_queue` can be found in the `<queue>`
    header file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try out an STL algorithm using `sort()`. Be sure to `#include <algorithm>`.
    Sort an array of integers. Keep in mind that many containers have sorting mechanisms
    built in, but native collection types, such as a language-supplied array, will
    not (which is why you should use a basic array of integers).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
