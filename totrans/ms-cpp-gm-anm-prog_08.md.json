["```cpp\nfloat rdViewAzimuth = 330.0f;\nfloat rdViewElevation = -20.0f;\nglm::vec3 rdCameraWorldPosition =\n  glm::vec3(2.0f, 5.0f, 7.0f); \n```", "```cpp\nstruct ModelInstanceCamData {\n  ...\n  std::vector<std::shared_ptr<Camera>> micCameras{};\n  int micSelectedCamera = 0;\n  ... \n```", "```cpp\nstruct CameraSettings{\n  std::string csCamName = \"Camera\";\n  glm::vec3 csWorldPosition = glm::vec3(0.0f);\n  float csViewAzimuth = 0.0f;\n  float csViewElevation = 0.0f\n}; \n```", "```cpp\n std::shared_ptr<Camera> cam =\n    mModelInstCamData.micCameras.at(\n      mModelInstCamData.micSelectedCamera);\n  CameraSettings camSettings = cam->getCameraSettings(); \n```", "```cpp\n cam->setCameraSettings(camSettings); \n```", "```cpp\n **mRenderData.rdViewAzimuth** += mouseMoveRelX / 10.0; \n```", "```cpp\n **camSettings.csViewAzimuth** += mouseMoveRelX / 10.0f; \n```", "```cpp\n **mCamera.**updateCamera(mRenderData, deltaTime); \n```", "```cpp\n **cam->**updateCamera(mRenderData, deltaTime); \n```", "```cpp\n mProjectionMatrix = glm::perspective(\n    glm::radians(static_cast<float>(\n      **camSettings.**csFieldOfView)),\n    static_cast<float>(mRenderData.rdWidth) /\n    static_cast<float>(mRenderData.rdHeight),\n  0.01f, 500.0f); \n```", "```cpp\n mViewMatrix = **cam->**getViewMatrix(); \n```", "```cpp\n **mCamera.**moveCameraTo(...); \n```", "```cpp\n**mModelInstCamData.micCameras.****at****(**\n **mModelInstCamData.micSelectedCamera)->**moveCameraTo(...); \n```", "```cpp\nvoid OGLRenderer::loadDefaultFreeCam() {\n  mModelInstCamData.micCameras.clear(); \n```", "```cpp\n std::shared_ptr<Camera> freeCam =\n    std::make_shared<Camera>();\n  CameraSettings freeCamSettings{};\n  freeCamSettings.csCamName = \"FreeCam\";\n  freeCamSettings.csWorldPosition = glm::vec3(5.0f);\n  freeCamSettings.csViewAzimuth = 310.0f;\n  freeCamSettings.csViewElevation = -15.0f;\n  freeCam->setCameraSettings(freeCamSettings);\n  mModelInstCamData.micCameras.emplace_back(freeCam);\n  mModelInstCamData.micSelectedCamera = 0;\n} \n```", "```cpp\n std::string camName = camBaseName;\n  std::string matches(\"01234567890\");\n  while (checkCameraNameUsed(camName)) { \n```", "```cpp\n const auto iter = std::find_first_of(camName.begin(),\n    camName.end(), matches.begin(), matches.end());\n if (iter == camName.end()) {\n      camName.append(\"1\");\n    } else { \n```", "```cpp\n std::string cameraNameString = camName.substr(0,\n        std::distance(camName.begin(), iter));\n      std::string cameraNumString = camName.substr(\n        std::distance(camName.begin(), iter));\n      int cameraNumber = std::stoi(cameraNumString);\n      camName = cameraNameString +\n        std::to_string(++cameraNumber);\n    }\n  } \n```", "```cpp\nbool OGLRenderer::checkCameraNameUsed(std::string\n    cameraName) {\n  for (const auto& cam : mModelInstCamData.micCameras) {\n    if (cam->getCameraSettings().csCamName == cameraName) {\n      return true;\n    }\n  }\n  return false;\n} \n```", "```cpp\nTemplate<>\n  struct convert<CameraSettings> {\n  static bool decode(const Node& node,\n      CameraSettings& rhs) {\n    CameraSettings defaultSettings = CameraSettings{};\n    rhs.csCamName =\n        node[\"camera-name\"].as<std::string>();\n     try {\n      rhs.csWorldPosition =\n         node[\"position\"].as<glm::vec3>();\n    } catch (...) {\n       rhs.csWorldPosition =\n         defaultSettings.csWorldPosition;\n    }\n     try {\n      rhs.csViewAzimuth =\n          node[\"view-azimuth\"].as<float>();\n      } catch (...) {\n        rhs.csViewAzimuth = defaultSettings.csViewAzimuth;\n     }\n    try {\n        rhs.csViewElevation =\n          node[\"view-elevation\"].as<float>();\n     } catch (...) {\n        rhs.csViewElevation =\n          defaultSettings.csViewElevation;\n     } \n```", "```cpp\n... camNode.as<CameraSettings>(); \n```", "```cpp\n ...\n  mYamlEmit << YAML::BeginMap;\n  mYamlEmit << YAML::Key << \"cameras\";\n  mYamlEmit << YAML::Value;\n  mYamlEmit << YAML::BeginSeq;\n  for (const auto& cam : modInstCamData.micCameras) {\n    CameraSettings settings = cam->getCameraSettings();\n    mYamlEmit << YAML::BeginMap;\n    mYamlEmit << YAML::Key << \"camera-name\";\n    mYamlEmit << YAML::Value << settings.csCamName;\n   ...\n  }\n  mYamlEmit << YAML::EndSeq;\n  mYamlEmit << YAML::EndMap; \n```", "```cpp\ncameras:\n  - camera-name: FreeCam\n    position: [2.9061296, 11.1587305, 64.1114578]\n    view-azimuth: 289.300262\n    view-elevation: -34.4999695 \n```", "```cpp\nenum class cameraType {\n  free = 0,\n  firstPerson,\n  thirdPerson,\n  stationary,\n  stationaryFollowing\n}; \n```", "```cpp\n cameraType csCamType = cameraType::free; \n```", "```cpp\n bool csFirstPersonLockView = true;\n  int csFirstPersonBoneToFollow = 0;\n  std::vector<std::string> csFirstPersonBoneNames{};\n  glm::mat4 csFirstPersonBoneMatrix = glm::mat4(1.0f);\n  glm::vec3 csFirstPersonOffsets = glm::vec3(0.0f); \n```", "```cpp\n std::weak_ptr<AssimpInstance> csInstanceToFollow{}; \n```", "```cpp\nglm::mat4 boneMatrix =\n  mShaderBoneMatrixBuffer.getSsboDataMat4(\n  selectedInstance * numberOfBones + selectedBone, 1).at(0); \n```", "```cpp\nglm::mat4 offsetMatrix = glm::translate(glm::mat4(1.0f),\n  camSettings.csFirstPersonOffsets); \n```", "```cpp\ncam->setBoneMatrix(\n  mWorldPosMatrices.at(selectedInstance) *\n  boneMatrix * offsetMatrix *\n  glm::inverse(modelType.second.at(0)\n    ->getModel()->getBoneList().at(selectedBone)\n    ->getOffsetMatrix())); \n```", "```cpp\n cam->updateCamera(mRenderData, deltaTime);\n      mViewMatrix = cam->getViewMatrix();\n     std::vector<glm::mat4> matrixData;\n     matrixData.emplace_back(mViewMatrix);\n     matrixData.emplace_back(mProjectionMatrix);\n     mUniformBuffer.uploadUboData(matrixData, 0); \n```", "```cpp\n    mCamSettings.csWorldPosition = mFirstPersonBoneMatrix[3]; \n    ```", "```cpp\n    glm::vec3 elevationVector =\n      glm::mat3(mFirstPersonBoneMatrix) * mSideVector; \n    ```", "```cpp\n    mCamSettings.csViewElevation =\n      glm::degrees(std::atan2(glm::length(\n      glm::cross(elevationVector, mWorldUpVector)),\n      glm::dot(elevationVector, -mWorldUpVector))) - 90.0f \n    ```", "```cpp\n    glm::vec3 azimuthVector =\n      glm::mat3(mFirstPersonBoneMatrix) * mSideVector; \n    ```", "```cpp\n    mCamSettings.csViewAzimuth =\n      glm::degrees(\n        glm::acos(\n          glm::dot(\n            glm::normalize(\n              glm::vec3(\n                azimuthVector.x, 0.0f, azimuthVector.z)),\n              -mSideVector\n            )\n         )\n      ); \n    ```", "```cpp\n     if (azimuthVector.x < 0.0f) {\n                mCamSettings.csViewAzimuth =\n                  360.0f - mCamSettings.csViewAzimuth;\n              } \n    ```", "```cpp\n updateCameraView(renderData, deltaTime); \n```", "```cpp\nfloat rotationAngle = 180.0f -\n  instSettings.isWorldRotation.y; \n```", "```cpp\nglm::vec3 offset = glm::vec3(\n  -glm::sin(glm::radians(rotationAngle)),\n   1.0f,\n   glm::cos(glm::radians(rotationAngle))\n) * mCamSettings.csThirdPersonDistance; \n```", "```cpp\noffset.y += mCamSettings.csThirdPersonHeightOffset;\nmCamSettings.csWorldPosition =\n  instSettings.isWorldPosition + offset; \n```", "```cpp\nglm::vec3 viewDirection =\n  instSettings.isWorldPosition -\n  mCamSettings.csWorldPosition;\nmCamSettings.csViewElevation = (90.0f -\n  glm::degrees(\n    glm::acos(\n      glm::dot(\n        glm::normalize(viewDirection), mWorldUpVector\n      )\n    )\n  )) / 2.0f; \n```", "```cpp\n if (!(camSettings.csCamType ==\n      cameraType::thirdPerson ||\n    (camSettings.csCamType == cameraType::firstPerson &&\n    camSettings.csFirstPersonLockView)) &&\n    camSettings.csInstanceToFollow.lock()) {\n  ... \n```", "```cpp\n... && camSettings.csCamType != cameraType::stationary ... \n```", "```cpp\n if (mCamSettings.csCamType == cameraType::stationary) {\n    return;\n  } \n```", "```cpp\nif (!((camSettings.csCamType ==\n  cameraType::stationaryFollowing \n```", "```cpp\nstd::shared_ptr<AssimpInstance> instance =\n  mCamSettings.csInstanceToFollow.lock();\nglm::vec3 viewDirection = instance->getWorldPosition() -\n  mCamSettings.csWorldPosition; \n```", "```cpp\nmCamSettings.csViewElevation = 90.0f -\n  glm::degrees(\n    glm::acos(\n      glm::dot(\n        glm::normalize(viewDirection), mWorldUpVector\n      )\n    )\n  ); \n```", "```cpp\nfloat rotateAngle =\nglm::degrees(\n  glm::acos(\n    glm::dot(\n      glm::normalize(\n        glm::vec3(viewDirection.x, 0.0f, viewDirection.z)),\n      glm::vec3(0.0f, 0.0f, -1.0f)\n    )\n  )\n); \n```", "```cpp\nif (viewDirection.x < 0.0f) {\n  rotateAngle = 360.0f â€“ rotateAngle;\n}\nmCamSettings.csViewAzimuth = rotateAngle \n```", "```cpp\n if (glfwGetKey(mRenderData.rdWindow,\n      GLFW_KEY_LEFT_BRACKET) == GLFW_PRESS) {\n    if (mModelInstCamData.micSelectedCamera > 0) {\n      mModelInstCamData.micSelectedCamera--;\n    }\n  }\n  if (glfwGetKey(mRenderData.rdWindow,\n      GLFW_KEY_RIGHT_BRACKET) == GLFW_PRESS) {\n    if (mModelInstCamData.micSelectedCamera <\n        mModelInstCamData.micCameras.size() - 1) {\n      mModelInstCamData.micSelectedCamera++;\n    }\n  } \n the number keys *1* to *9*).\n```", "```cpp\nenum class cameraProjection {\n  perspective = 0,\n  orthogonal\n}; \n```", "```cpp\n cameraProjection csCamProjection =\n    cameraProjection::perspective;\n  float csOrthoScale = 20.0f; \n```", "```cpp\n if (camSettings.csCamProjection ==\n    cameraProjection::perspective) {\n ...\n  } else { \n```", "```cpp\n float orthoScaling = camSettings.csOrthoScale;\n    float aspect = static_cast<float>(mRenderData.rdWidth)/\n      static_cast<float>(mRenderData.rdHeight) *\n      orthoScaling;\n    float leftRight = 1.0f * orthoScaling;\n    float nearFar = 75.0f * orthoScaling; \n```", "```cpp\n mProjectionMatrix = glm::ortho(-aspect, aspect,\n      -leftRight, leftRight, -nearFar, nearFar); \n```", "```cpp\n ImGui::Text(\"Projection:      \");\n      ImGui::SameLine();\n      if (ImGui::RadioButton(\"Perspective\",\n          settings.csCamProjection ==\n          cameraProjection::perspective)) {\n        settings.csCamProjection =\n          cameraProjection::perspective;\n      } \n```", "```cpp\n ImGui::SameLine();\n      if (ImGui::RadioButton(\"Orthogonal\",\n          settings.csCamProjection ==\n          cameraProjection::orthogonal)) {\n        settings.csCamProjection =\n         cameraProjection::orthogonal;\n     } \n```", "```cpp\n ImGui::Text(\"Ortho Scaling:   \");\n      ImGui::SameLine();\n      ImGui::SliderFloat(\"##CamOrthoScale\",\n        &settings.csOrthoScale, 1.0f, 50.0f, \"%.3f\", flags); \n```"]