- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: An Introduction to Collision Detection
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测简介
- en: Welcome to *Chapter 8*! In the previous chapter, we extended the instance animation
    system. We started by adding lookup tables for the animation transforms and moved
    the computations to the GPU. Next, we added movement states and UI controls to
    the application to create mappings between states and animation clips. As the
    last step, we updated the YAML parser to save and restore the animation clip mappings.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到**第8章**！在前一章中，我们扩展了实例动画系统。我们首先为动画转换添加了查找表，并将计算移动到GPU上。接下来，我们向应用程序中添加了运动状态和UI控件，以创建状态和动画片段之间的映射。最后一步，我们更新了YAML解析器以保存和恢复动画片段映射。
- en: In this chapter, we will implement a two-tier collision detection for the instances.
    We will start with an exploration of the complexity of collision detection, and
    how to lower the complexity by removing instances based on their distance and
    by simplifying the representation of the instances. Then, we will discuss methods
    to simplify the instances to minimize the number of intersection checks even more.
    Next, we will implement a quadtree to limit the number of instances to check,
    and finally, we will add bounding spheres to the instances to create the two tiers
    of collision detection.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为实例实现双层碰撞检测。我们将从探索碰撞检测的复杂性以及如何通过根据实例的距离移除实例和简化实例表示来降低复杂性开始。然后，我们将讨论简化实例的方法，以最大限度地减少交点检查的数量。接下来，我们将实现四叉树以限制要检查的实例数量，最后，我们将向实例添加边界球体以创建碰撞检测的两层。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The complexities of collision detection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测的复杂性
- en: Using spatial partitioning to reduce complexity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空间分区来降低复杂性
- en: Simplifying the instances for faster collision checks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化实例以加快碰撞检测
- en: Adding a quadtree to store nearby model instances
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加四叉树以存储附近的模型实例
- en: Implementing bounding spheres
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现边界球体
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example code is in the `chapter08` folder, in the subfolders `01_opengl_collisions`
    for OpenGL and `02_vulkan_collisions` for Vulkan.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码位于`chapter08`文件夹中，子文件夹`01_opengl_collisions`用于OpenGL，`02_vulkan_collisions`用于Vulkan。
- en: The complexities of collision detection
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测的复杂性
- en: We already talked about the complexity of finding a collision in [*Chapter 3*](Chapter_3.xhtml)
    when deciding how to implement a visual selection, either using ray shooting or
    buffer drawing. We’ve chosen to draw the instances into a separate buffer, avoiding
    collision detection entirely.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定如何实现视觉选择时，我们已经在[*第3章*](Chapter_3.xhtml)中讨论了找到碰撞的复杂性，无论是使用光线投射还是缓冲区绘制。我们选择将实例绘制到单独的缓冲区中，从而完全避免碰撞检测。
- en: Now is the right time to do a short reprise of the complex topic and to present
    solutions to accelerate finding collisions between instances.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是回顾这个复杂主题并展示加速实例间碰撞查找解决方案的合适时机。
- en: Avoiding the naive way
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免天真方法
- en: If we would check every triangle of every instance against all triangles of
    all other instances for collisions in the virtual world, this would come with
    immense processing costs. These simple, brute-force collision checks would grow
    exponentially, making it impossible to keep up a reasonable frame time when adding
    more and more instances.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在虚拟世界中检查每个实例的每个三角形与所有其他实例的所有三角形之间的碰撞，这将带来巨大的处理成本。这些简单、蛮力的碰撞检查将以指数级增长，使得在添加更多实例时保持合理的帧时间变得不可能。
- en: Instead of using the naive solution, we should take a step back and think about
    possible types of simplification before implementing any kind of collision detection.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现任何类型的碰撞检测之前，我们应该退一步思考可能的简化类型，而不是使用天真解决方案。
- en: One idea is to reduce the number of instances we have to check against. Why
    bother with instances in distant parts of the virtual world? Even if our object
    is some kind of bullet, rocket, or other flying entity, all we can possibly hit
    needs to be “less than an arm’s length” away from us. All other objects can be
    safely ignored.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个想法是减少我们必须检查的实例数量。为什么要在虚拟世界的遥远部分检查实例呢？即使我们的物体是某种子弹、火箭或其他飞行实体，我们可能击中的所有东西都需要在我们“一臂之长”以内。所有其他物体都可以安全忽略。
- en: To achieve this reduction, we can split the world into different areas. And
    suddenly, we only have to check the area we are in. Maybe we have to check adjacent
    areas too, depending on the algorithm we use, but the total number of instances
    we have to check against can be reduced by a large amount.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种减少，我们可以将世界划分为不同的区域。突然之间，我们只需要检查我们所在的区域。也许我们还需要检查相邻的区域，这取决于我们使用的算法，但我们需要检查的实例总数可以大幅减少。
- en: On the other hand, we can lower the computational work for collision detection
    by reducing the amount of surface elements to test if we are even close to any
    of the triangles of the instance. Any kind of simplification will become handy;
    the fewer intersections to test, the better.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以通过减少需要测试的表面元素数量来降低碰撞检测的计算工作量，前提是我们接近实例中的任何三角形。任何简化方法都将变得方便；需要测试的交点越少，效果越好。
- en: Representing an instance as a box or sphere may produce a lot of false results,
    but if the collision check against the box or sphere around the instance already
    fails, we can immediately sort out this instance from our list of possible collision
    targets.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将实例表示为盒子或球体可能会产生许多错误结果，但如果与实例周围的盒子或球体的碰撞检查已经失败，我们就可以立即从这个可能发生碰撞的目标列表中排除这个实例。
- en: Both ideas combined – reducing the number of instances to check and lowering
    the complexity of the instance checks – help to do collision checks in real time,
    even with larger numbers of detailed models.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 结合两种想法——减少需要检查的实例数量和降低实例检查的复杂性——有助于在实时中进行碰撞检测，即使是有更多详细模型的情况。
- en: Let’s start with the spatial partitioning of the virtual world.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从虚拟世界的空间分区开始。
- en: Using spatial partitioning to reduce complexity
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用空间分区来降低复杂性
- en: In this section, we will take a look at some methods to split our world space
    into different parts, lowering the number of instances in each of the parts. We
    start with the simplest variant of spatial partitioning in two or three dimensions,
    the grid.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些方法来将我们的世界空间划分为不同的部分，降低每个部分中的实例数量。我们从二维或三维空间分区最简单的变体，即网格开始。
- en: Grid
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格
- en: In a **grid**, the virtual lines divide the virtual world into equally sized
    squares or rectangles, or equally sized cubes and cuboids.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在**网格**中，虚拟线将虚拟世界划分为等大小的正方形或矩形，或者等大小的立方体和长方体。
- en: '![](img/B22428_08_01.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_08_01.png)'
- en: 'Figure 8.1: 2D and 3D grids'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：2D和3D网格
- en: While grids are easy to create, *Figure 8.1* already shows some of the problems.
    Objects larger than the grid spacing must be placed into all overlapping grid
    fields, requiring checking all affected fields for other instances.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然网格易于创建，但*图8.1*已经显示了其中的一些问题。大于网格间距的对象必须放置在所有重叠的网格字段中，需要检查所有受影响的字段以确定其他实例。
- en: And while the vast majority of the grid will remain empty, “crowded places”
    inside the virtual world can lead to many instances inside a single field of the
    grid. Many instances mean many checks, and an uneven distribution of instances
    may cause slowdowns due to the number of calculations.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然网格的大部分将保持空置，但虚拟世界内的“拥挤区域”可能导致单个网格字段内存在许多实例。许多实例意味着许多检查，实例的不均匀分布可能会导致由于计算数量增加而导致的减速。
- en: A sort of successor to the grid is the quadtree. A quadtree addresses the uneven
    distribution problem of the grid.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 四叉树是网格的一种继承形式。四叉树解决了网格的不均匀分布问题。
- en: Quadtree
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 四叉树
- en: The basic element of a **quadtree** is a single cell, being either a square
    or a rectangle. We will only use square cells for the description, but all holds
    true for rectangle-shaped cells, too. Objects are inserted with their position
    and sizes into the root cell, usually by using a two-dimensional bounding box
    covering the extents of the object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**四叉树**的基本元素是一个单独的单元格，可以是正方形或矩形。我们将仅使用正方形单元格进行描述，但所有内容也适用于矩形形状的单元格。对象通过其位置和大小插入到根单元格中，通常使用一个二维边界框来覆盖对象的范围。'
- en: 'The magic part of a quadtree starts when a configurable threshold of objects
    per cell has been hit. The affected cell is subdivided into four equally sized
    child cells. Any object overlapping one or more children could be either kept
    in the parent cell or added to all affected child cells, depending on the implementation.
    All other objects are moved into the respective child cell. See *Figure 8.2* for
    an example of a quadtree:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 四叉树的神奇之处在于当每个单元格中对象的配置阈值被达到时开始。受影响的单元格被细分为四个大小相等的子单元格。任何重叠一个或多个子单元格的对象可以保留在父单元格中，或者根据实现方式添加到所有受影响的子单元格中。所有其他对象都移动到相应的子单元格中。参见*图8.2*，了解四叉树的示例：
- en: '![](img/Image3907.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image3907.png)'
- en: 'Figure 8.2: A quadtree with different subdivisions'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：具有不同细分结构的四叉树
- en: Dividing the squares into four child cells and moving the objects from the parent
    cell into the child cells reduces the number of objects per cell to be less than
    the configured threshold, minimizing the number of objects to test for collisions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将正方形划分为四个子单元格，并将父单元格中的对象移动到子单元格中，可以减少每个单元格中的对象数量，使其低于配置的阈值，从而最小化需要测试碰撞的对象数量。
- en: If the sum of all objects inside the four child cells falls below the threshold,
    all objects are moved to the parent cell again, and the now empty child cells
    are deleted. This dynamic behavior helps to keep the number of objects in each
    cell between zero and the threshold, independent of the size, number of parents,
    or location of a cell.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果四个子单元格中所有对象的和低于阈值，则所有对象再次移动到父单元格中，现在为空的子单元格被删除。这种动态行为有助于保持每个单元格中对象的数量在零和阈值之间，独立于单元格的大小、父单元格的数量或位置。
- en: A quadtree can hold only two-dimensional information about the object’s position
    and size. To extend the same logic into three dimensions, an octree can be used.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 四叉树只能存储关于对象位置和大小的二维信息。要将相同的逻辑扩展到三维，可以使用八叉树。
- en: Octree
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Octree
- en: 'The basic functionality of a quadtree and an **octree** is identical. The only
    difference is the number of dimensions used for the element of the tree itself.
    While a quadtree uses squares or rectangles as cells, an octree is made of cubes
    or cuboids. In *Figure 8.3*, a simple octree is shown:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 四叉树和**八叉树**的基本功能相同。唯一的区别是树元素使用的维度数量。四叉树使用正方形或矩形作为单元格，而八叉树由立方体或长方体组成。在*图8.3*中，显示了一个简单的八叉树：
- en: '![](img/Image3914.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image3914.png)'
- en: 'Figure 8.3: An octree with subdivisions'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：具有细分结构的八叉树
- en: The inserted objects are internally maintained as three-dimensional axis-aligned
    bounding boxes, representing the extents of the object. A split operation when
    reaching the threshold results in creating eight sub-cubes as child cells (or
    eight sub-cuboids).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 插入的对象内部以三维轴对齐的边界框形式维护，表示对象的范围。当达到阈值时，分割操作会导致创建八个子立方体作为子单元（或八个子长方体）。
- en: An octree is an effective way to remove large parts of the three-dimensional
    space when checking for possible collisions. Another data structure to handle
    two- and three-dimensional space partitioning is **binary space partitioning**
    (**BSP**).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 八叉树是检查可能碰撞时有效移除三维空间大部分区域的方法。另一种处理二维和三维空间划分的数据结构是**二叉空间划分**（**BSP**）。
- en: Binary space partitioning
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二叉空间划分
- en: You may have heard of the three letters BSP from older games. One of the first
    games using BSP trees to maintain level data was the 1993 game **Doom** from **Id
    Software**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过来自老游戏的三个字母BSP。第一个使用BSP树来维护关卡数据的游戏是1993年由**Id Software**开发的**Doom**游戏。
- en: Although the level data in Doom was only two-dimensional, the game engine created
    the illusion of a fully three-dimensional game.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Doom中的关卡数据只有二维，但游戏引擎创造了一个完全三维游戏的错觉。
- en: A BSP tree is created by recursively dividing the world space by using lines
    (2D) or planes (3D) as hyperplanes, creating a front side and a back side. The
    division into front and back sides continues until the remaining partition fulfills
    some exit condition; for games, this condition is usually when the partition is
    either completely filled or empty.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: BSP树是通过递归地使用线（2D）或平面（3D）作为超平面来划分世界空间创建的，创建前后两个面。前后面的划分会继续进行，直到剩余的分区满足某些退出条件；对于游戏来说，这个条件通常是分区完全填满或为空。
- en: If any other lines or planes are hit by the subdivision, these lines or planes
    are split into two parts, one residing on the front side and the other on the
    back side.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果细分时遇到任何其他线或平面，这些线或平面将被分割成两部分，一部分位于前方，另一部分位于后方。
- en: '*Figure 8.4* shows the subdivision of a space and the resulting BSP tree:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.4* 展示了空间的细分和由此产生的BSP树：'
- en: '![](img/Image3922.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image3922.png)'
- en: 'Figure 8.4: An example object and the resulting BSP tree'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：一个示例对象及其生成的BSP树
- en: In *Figure 8.4*, line A is used as the starting point, with the front side pointing
    downward. Splitting the space into two halves also splits lines B and C, resulting
    in lines B1, B2, C1, and C2\. Line B1 lies on the back side of A and will be added
    as the left child to A, and B2, on the back of A, as the right child of A. Both
    lines C1 and C3 are on the back sides of B1 and B2, so they are added as the left
    children to B1 respective to B2.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.4*中，线A用作起点，前端向下。将空间分成两半也分割了线B和C，从而产生了线B1、B2、C1和C2。线B1位于A的后方，将被添加为A的左子节点，而B2位于A的后方，作为A的右子节点。线C1和C2都位于B1和B2的后方，因此它们被添加为B1和B2的左子节点。
- en: While parsing a BSP tree to find a partition is really fast, generating the
    same BSP tree is a time-consuming task. The tree generation is done offline in
    most cases, and the precalculated tree is shipped with the game or application.
    Checking all lines or planes against all other lines or planes is the same type
    of problem we have with collision detection.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 解析BSP树以找到分区确实非常快，但生成相同的BSP树是一个耗时的任务。大多数情况下，树生成是在离线完成的，预计算的树与游戏或应用程序一起分发。检查所有线或平面与所有其他线或平面的过程与碰撞检测中遇到的问题相同。
- en: The inability to quickly change or update the elements of a BSP tree makes such
    a tree only suitable for static data (i.e., for level data of a game). Dynamic
    game elements, like doors or players, require using a different data structure,
    for instance, an octree.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: BSP树元素无法快速更改或更新的能力使得这种树仅适用于静态数据（即，用于游戏的关卡数据）。像门或玩家这样的动态游戏元素需要使用不同的数据结构，例如八叉树。
- en: Similar to BSP trees, a k-d tree is fast for searching elements but slow for
    creation or updates.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与BSP树类似，k-d树在搜索元素时速度快，但在创建或更新时速度慢。
- en: K-d tree
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: K-d树
- en: A **k-d tree** stores information about objects in a k-dimensional space. The
    algorithm is a bit more complex compared to the previous trees. At every data
    point insertion, the remaining space gets split into two parts, and after the
    split, the affected dimension is changed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**k-d树**存储k维空间中对象的信息。与之前的树相比，该算法要复杂一些。在每次数据点插入时，剩余空间被分成两部分，分割后，受影响的维度会改变。'
- en: 'For a two-dimensional k-d tree, the split dimensions alternate between the
    X and Y axes; for a three-dimensional k-d tree, it alternates in the order X,
    Y, and Z; and so on. *Figure 8.5* shows what a k-d tree in two and three dimensions
    looks like:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二维k-d树，分割维度在X轴和Y轴之间交替；对于三维k-d树，它按照X、Y、Z的顺序交替；依此类推。*图8.5* 展示了二维和三维k-d树的外观：
- en: '![](img/Image3930.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image3930.png)'
- en: 'Figure 8.5: A two- and a three-dimensional k-d tree'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：二维和三维k-d树
- en: 'The red lines and the respective blue lines are for the split dimension in
    2D: red stands for an X split and blue for a Y split. In three dimensions, the
    same pattern applies, and we use the “next” dimension upon consecutive splits.
    Due to the removal of parts of the remaining space, searching in a k-d tree for
    an element is fast. The main uses for k-d trees are point clouds and searching
    for the nearest neighbors of a given point.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 红线和相应的蓝线是二维中的分割维度：红色代表X分割，蓝色代表Y分割。在三维中，相同的模式适用，我们在连续分割时使用“下一个”维度。由于剩余空间的部分被移除，在k-d树中搜索元素是快速的。k-d树的主要用途是点云和搜索给定点的最近邻。
- en: A slightly different method for space partitioning is by using a bounding volume
    hierarchy.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 空间分割的另一种方法是使用边界体积层次结构。
- en: Bounding volume hierarchy
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边界体积层次结构
- en: 'In contrast to the previous tree variants, a **bounding volume hierarchy**
    can be achieved by different types of geometrical representations. As an example,
    we are using two-dimensional bounding circles, as shown in *Figure 8.6*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的树变体相比，**边界体积层次结构**可以通过不同类型的几何表示来实现。例如，我们使用二维边界圆，如*图8.6*所示：
- en: '![](img/Image3937.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image3937.png)'
- en: 'Figure 8.6: A bounding volume hierarchy made of circles'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：由圆组成的边界体积层次结构
- en: By enclosing two or more bounding circles into a larger bounding circle, the
    number of collision tests can be lowered. If the possible colliding object does
    not hit the outer circle, there is no need to check any of the inner circles for
    possible collisions. The inner circles are impossible to reach for the colliding
    object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将两个或多个边界圆包围在一个更大的边界圆中，可以降低碰撞测试的数量。如果可能发生碰撞的对象没有击中外部圆，则不需要检查任何内部圆以确定可能的碰撞。对于碰撞对象来说，内部圆是无法到达的。
- en: Only if we hit the outer circle is a deeper check required. Similar to the other
    trees, a bounding volume hierarchy can remove larger parts of the world space
    from further collision checks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当我们击中外部圆圈时，才需要进行更深入的检查。与其他树类似，边界体积层次结构可以移除世界空间中更大的一部分，从而减少进一步的碰撞检查。
- en: 'Before we start the implementation of a spatial partitioning algorithm, we
    need to explore the second way of accelerating collision detection: using simplified
    representations of the instances for faster checks.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现空间划分算法之前，我们需要探索加速碰撞检测的第二种方法：使用实例的简化表示以进行更快的检查。
- en: Simplifying the instances for faster collision checks
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化实例以进行更快的碰撞检查
- en: Instead of checking every triangle of the instances after reducing the overall
    number, we can greatly improve the performance of collision checks if we use **model
    abstractions**. These abstractions are made of only a few geometrical elements,
    like boxes, cuboids, or circles, enclosing the instance. If these abstractions
    don’t intersect, the instances cannot have a collision, and we can remove the
    instance already from our list of candidates.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在减少整体数量后，我们不必检查实例的每个三角形，如果我们使用**模型抽象**，可以大大提高碰撞检查的性能。这些抽象仅由几个几何元素组成，如盒子、长方体或圆，它们包围着实例。如果这些抽象不相交，实例之间不可能发生碰撞，我们可以从我们的候选列表中移除该实例。
- en: One of the fastest abstractions for an object is the axis-aligned bounding box.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对象最快的抽象之一是轴对齐边界框。
- en: Axis-aligned bounding box
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轴对齐边界框
- en: 'An **axis-aligned bounding box** (**AABB**) is a rectangle or cuboid, just
    large enough to contain the object, and all lines of the rectangle or planes of
    the cuboid are aligned with the axes of the Cartesian coordinate system. We will
    use the two-dimensional variant of an AABB during the implementation of the quadtree,
    the bounding box. *Figure 8.7* shows a two-dimensional bounding box:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**轴对齐边界框**（**AABB**）是一个矩形或长方体，大小刚好足以包含对象，并且矩形的所有线或长方体的所有平面都与笛卡尔坐标系中的轴对齐。在实现四叉树时，我们将使用AABB的二维变体，即边界框。*图8.7*展示了二维边界框：'
- en: '![](img/Image3945.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image3945.png)'
- en: 'Figure 8.7: A two-dimensional bounding box'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：二维边界框
- en: AABBs are best suited for objects shaped close to squares, rectangles, cubes,
    or cuboids. For round objects, AABBs will produce a lot of space between the object
    and the box extents, leading to more “false positives” when checking for a possible
    collision.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: AABB最适合形状接近正方形、矩形、立方体或长方体的对象。对于圆形对象，AABB将在对象和箱体范围之间产生很多空间，导致在检查可能的碰撞时出现更多的“假阳性”。
- en: Checking intersections between AABBs is a quick and easy task. Since all four
    lines or six sides are aligned to axes, only one dimension per line or plane needs
    to be checked against the opposite line or plane of the second instance.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 检查AABB之间的交集是一个快速且简单的工作。由于所有四条线或六个侧面都与轴对齐，因此只需检查每条线或每个平面与第二个实例的对应线或平面的一个维度。
- en: For instance, the bottom plane of instance one and the top plane of instance
    two can be checked by just comparing the Y values (if the Y axis points upward).
    If this check signals that the instances are not colliding (namely, the top plane
    of the second instance is not above the bottom plane of instance one), the collision
    check can be ended immediately – these two instances cannot intersect at all.
    So, we can do a fast preflight check by using AABBs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，实例一的底部平面和实例二的顶部平面可以通过仅比较Y值（如果Y轴向上）来检查。如果这个检查表明实例没有发生碰撞（即，第二个实例的顶部平面不在第一个实例的底部平面之上），则可以立即结束碰撞检查——这两个实例根本不可能相交。因此，我们可以通过使用AABB进行快速预检。
- en: When we rotate an AABB with the object, an **oriented bounding box** (**OBB**)
    will be created.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们旋转AABB与对象一起时，将创建一个**定向边界框**（**OBB**）。
- en: Oriented bounding box
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定向边界框
- en: 'Just rotating the AABB with the object may be tempting, since we still have
    a good ratio between the object data and the extra space of the box. See *Figure
    8.8* for an example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image3952.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: An oriented bounding box'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: But be aware that OBBs are not just AABBs in disguise! Rotating the planes will
    no longer allow us to do simple coordinate checks, and we now need to solve a
    lot of plane equations or use advanced methods like the so-called **Separating
    Axis Theorem** to check if the side planes of the two OBBs intersect. Plus, the
    creation and rotation of OOBs can be complex and ambiguous. So, the tip here is
    to stay away from OBBs; in most cases, they are not worth the additional complexity.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: For round(ish) objects, bounding circles and spheres are a good simplification
    type.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Bounding circles and spheres
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A bounding circle in two dimensions, or a bounding sphere in three dimensions,
    is rather simple. We just need a center point and a radius, and we are done. *Figure
    8.9* shows a bounding circle around an object:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image3959.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: A bounding circle around an object'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Checking against a bounding circle or sphere is also fast and simple. The Pythagorean
    theorem helps us to calculate the distance to the center of the sphere from any
    point in the world. Only if the calculated distance is smaller than the radius
    will a collision hit occur.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Please keep in mind that the Pythagorean theorem includes calculating a square
    root, a quite expensive operation if you don’t use modern **Single Instruction,
    Multiple Data** (**SIMD**) CPU extensions like **Streaming SIMD Extensions** (**SSE**)
    or **Advanced Vector Extensions** (**AVX**). One possible optimization here is
    using the square of the radius and skipping the square root when calculating the
    distance. Since both results are squared now, the outcome of the comparison is
    identical to the square root version.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: An interesting adaptation of the bounding circle or bounding sphere is a capsule.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Capsule
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Capsules** look like a stretched version of a circle or a sphere, where the
    middle part is shaped like a rectangle or cylinder. Capsules are used for human
    bodies since the overall form of a capsule comes closer to the body shape compared
    to spheres or rectangular bounding boxes. *Figure 8.10* shows an example of a
    capsule:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image3972.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: A capsule around a simple character'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: When using the same values for the radius of the ending circles or spheres,
    and the central rectangle or cylinder, we need to store only the central line
    of the capsule and the radius. Calculating the distances of a possible collision
    point is not much more expensive than the calculations for bounding circles or
    spheres.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: On the high end of the costs for collision checks comes the convex hull.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Convex hull
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **convex hull** is defined as the smallest **convex** volume containing the
    object. Emphasizing the convex property of the hull is done on purpose since this
    property allows algorithmic optimizations to some extent. However, the number
    of planes for the complex hull can become high, and the construction may be not
    trivial. See *Figure 8.11* for a convex hull:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**凸包**被定义为包含对象的**最小凸**体积。强调凸包的凸性是有意为之，因为这种属性在一定程度上允许算法优化。然而，复杂凸包的平面数量可能会很高，构建可能并不简单。参见*图8.11*中的凸包：'
- en: '![](img/Image3981.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image3981.png)'
- en: 'Figure 8.11: A convex hull around an object'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：围绕对象的一个凸包
- en: Checking a convex hull for collisions needs a lot of tests, possibly lowering
    the effect we wanted to achieve with our model simplification. As long as you
    don’t have models with lots of triangles, a convex hull may be out of scope.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 检查凸包的碰撞需要大量测试，这可能会降低我们通过模型简化想要实现的效果。只要你的模型没有很多三角形，凸包可能就不在考虑范围内。
- en: On the other hand, if small collision errors can be tolerated, the convex hull
    can be used as a replacement for a high-poly model, and all collision checks can
    be done only against the convex hull.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果可以容忍小的碰撞错误，凸包可以用作高多边形模型的替代品，并且所有碰撞检查都可以仅针对凸包进行。
- en: As the last method, the bounding volume hierarchy can be used. The hierarchy
    model is not just suitable for space partitioning but also for model simplification.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一种方法，可以使用边界体积层次结构。层次模型不仅适用于空间划分，也适用于模型简化。
- en: Bounding volume hierarchy
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边界体积层次结构
- en: 'The general idea of the **bounding volume hierarchy** for space partitioning
    also holds true to simplify the instances. But here, the model parts are enclosed
    in larger and larger volumes. *Figure 8.12* shows a simplified example of the
    bounding volume hierarchy around a character model:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 空间划分的**边界体积层次结构**的一般思想也适用于简化实例。但在这里，模型部分被包含在越来越大的体积中。*图8.12*显示了围绕角色模型的边界体积层次结构的简化示例：
- en: '![](img/Image3988.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image3988.png)'
- en: 'Figure 8.12: Bounding spheres in a hierarchy around an object'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：围绕对象的一组边界球体
- en: A failing check on one of the larger volumes allows us to discard the body part(s)
    inside the volume completely. By using a carefully crafted configuration, only
    a small number of tests are needed to decide if the instance should stay on the
    list for deeper checks, or if it can be ignored.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对较大体积中的一个失败检查使我们能够完全丢弃体积内的身体部分。通过使用精心设计的配置，只需要少量测试就可以决定实例是否应该保留在列表中进行更深入的检查，或者是否可以忽略。
- en: For details about collision checking between convex objects, you can look at
    the **Gilbert–Johnson–Keerthi** (**GJK**) distance algorithm. The GJK algorithm
    reduces the collision detection complexity by using the so-called Minkowski difference.
    A link to a web page explaining the principle of the GJK algorithm is available
    in the *Additional resources* section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于凸对象之间碰撞检查的详细信息，你可以查看**吉尔伯特-约翰逊-基尔蒂**（**GJK**）距离算法。GJK算法通过使用所谓的Minkowski差来降低碰撞检测的复杂性。在*附加资源*部分有一个解释GJK算法原理的网页链接。
- en: For the sake of simplicity, because of the fast updates, and also based on setting
    a limit to the number of instances to check, we will implement a quadtree into
    the application and bounding spheres for the instances. The quadtree will allow
    us to do the first step of collision detection much faster than the “brute-force”
    pairwise comparisons of all models in the naive approach. The bounding spheres
    are great for a balance between the number of collision checks and the number
    of false positives due to the free space between the sphere and the instance triangles.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，由于更新速度快，以及基于对要检查的实例数量的限制，我们将实现一个四叉树到应用程序中，并为实例使用边界球体。四叉树将使我们能够比原始方法中所有模型之间的“蛮力”成对比较更快地完成碰撞检测的第一步。边界球体在碰撞检查的数量和由于球体与实例三角形之间的自由空间而产生的假阳性数量之间提供了很好的平衡。
- en: Next, let’s jump into the implementation of the quadtree.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们跳入四叉树的实现。
- en: Adding a quadtree to store nearby model instances
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加四叉树以存储附近的模型实例
- en: 'Getting complex code right is hard, so using an open-source implementation
    of a quadtree is a viable option. The best fitting version of a quadtree I’ve
    found is from **Pierre Vigier** and can be found on GitHub here: [https://github.com/pvigier/Quadtree](https://github.com/pvigier/Quadtree).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正确编写复杂代码很难，因此使用四叉树的开源实现是一个可行的选择。我找到的最佳四叉树版本来自 **Pierre Vigier**，可以在 GitHub 上找到：[https://github.com/pvigier/Quadtree](https://github.com/pvigier/Quadtree)。
- en: The code from Pierre is based on C++ templating to have great flexibility on
    the data one stores in the quadtree. Also, he uses a custom-templated two-dimensional
    vector type for storing positions and sizes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Pierre 的代码基于 C++ 模板，以在四叉树中存储的数据上具有极大的灵活性。此外，他使用自定义模板化的二维向量类型来存储位置和大小。
- en: We don’t need this kind of flexibility as we will store only an `int` containing
    the instance index position in the quadtree. And since we are using GLM for all
    other cases where we need a two-dimensional vector type, we will change the bounding
    box implementation to use `glm::vec2` to store box position and size.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要这种灵活性，因为我们将在四叉树中仅存储一个包含实例索引位置的 `int`。由于我们在所有其他需要二维向量类型的情况下都使用 GLM，我们将更改边界框实现以使用
    `glm::vec2` 来存储框的位置和大小。
- en: Adjusting the bounding box code
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整边界框代码
- en: As the first step for the new and shiny quadtree, we need to adjust the code
    for the bounding box. Instead of storing the top and left positions and width
    plus height as single values, we use a `vec2` for position and size. Transforming
    the templated C++ code from the `Box.h` file in the `include` folder of the GitHub
    repository is done fairly easily, and we end up with constructors, a couple of
    getters, and the two methods `contains()` and `intersects()` in the `BoundingBox2D.h`
    and `BoundingBox2D.cpp` files in the newly created `quadtree` folder.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 作为新而闪亮的四叉树的第一步，我们需要调整边界框的代码。我们不再存储顶部和左边的位置以及宽度和高度作为单个值，而是使用 `vec2` 来存储位置和大小。将
    GitHub 仓库 `include` 文件夹中的 `Box.h` 文件中的模板化 C++ 代码转换为四叉树相对容易，最终我们在新创建的 `quadtree`
    文件夹中的 `BoundingBox2D.h` 和 `BoundingBox2D.cpp` 文件中得到了构造函数、几个获取器以及 `contains()`
    和 `intersects()` 这两个方法。
- en: 'The most complex method is `intersects()` to check if two bounding boxes intersect
    each other:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最复杂的方法是 `intersects()`，用于检查两个边界框是否相交：
- en: '[PRE0]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `AssimpInstance` class, a new `private` member named `mBoundingBox`
    will be added, storing the bounding box of the instance:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AssimpInstance` 类中，将添加一个名为 `mBoundingBox` 的新 `private` 成员，用于存储实例的边界框：
- en: '[PRE1]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We don’t need to load or save the bounding box, so it can be stored directly
    in the `AssimpClass`, outside of the `InstanceSettings` struct.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要加载或保存边界框，因此它可以直接存储在 `AssimpClass` 中，在 `InstanceSettings` 结构体之外。
- en: 'We need two trivial `public` methods to store and retrieve the bounding box:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个简单的 `public` 方法来存储和检索边界框：
- en: '[PRE2]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As the last step for the bounding box implementation, we must add the new `quadtree`
    folder to the `CMakeLists.txt` file in the `project root` folder in two places,
    to be able to use the bounding box and the quadtree in other classes. First, add
    the folder with a wildcard for all `.cpp` files to the `SOURCES` file search:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为边界框实现的最后一步，我们必须在项目根文件夹中的 `CMakeLists.txt` 文件中添加新的 `quadtree` 文件夹，以便在其他类中使用边界框和四叉树。首先，将包含所有
    `.cpp` 文件的文件夹添加到 `SOURCES` 文件搜索中：
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, append the `quadtree` folder to the include directory list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 `quadtree` 文件夹追加到包含目录列表中：
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After recreating the CMake files, which should be done automatically by Visual
    Studio and other IDEs after saving the changes in `CMakeLists.txt`, we can continue
    with the implementation of the quadtree.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新创建 CMake 文件后，这应该在保存 `CMakeLists.txt` 中的更改后由 Visual Studio 和其他 IDE 自动完成，我们可以继续进行四叉树的实现。
- en: Rewriting the quadtree code to fit our needs
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写四叉树代码以适应我们的需求
- en: We will store the new `Quadtree` class in the `Quadtree.h` and `Quadtree.cpp`
    files in the `quadtree` folder. The transformation from the quadtree C++ template
    to a C++ class needs some extra steps compared to the bounding box code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将新的 `Quadtree` 类存储在 `quadtree` 文件夹中的 `Quadtree.h` 和 `Quadtree.cpp` 文件中。将四叉树的
    C++ 模板转换为 C++ 类与边界框代码相比需要一些额外的步骤。
- en: 'We will need to make the following adjustments while translating the C++ template
    code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在翻译 C++ 模板代码时，我们需要进行以下调整：
- en: Replace the custom `Vector2` type with `glm::vec2`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将自定义的 `Vector2` 类型替换为 `glm::vec2`。
- en: Replace the custom `Box` type with the `BoundingBox2D` type and change the parameters
    to `glm::vec2`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将自定义的 `Box` 类型替换为 `BoundingBox2D` 类型，并将参数更改为 `glm::vec2`。
- en: Replace the `assert()` checks with log outputs.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`assert()`检查替换为日志输出。
- en: Add a `clear()` method that removes all contents of the quadtree.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个`clear()`方法来移除四叉树的所有内容。
- en: Add code to clean up the pairs of colliding instances with swapped IDs.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加代码以清理具有交换ID的碰撞实例对。
- en: Use return values for results instead of output parameters.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用返回值作为结果，而不是输出参数。
- en: Use a callback function instead of the `GetBox` function parameter.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用回调函数而不是`GetBox`函数参数。
- en: 'For the callback function, we add another callback to the `Callbacks.h` file,
    taking an `int` as the only parameter and returning a `BoundingBox2D`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于回调函数，我们在`Callbacks.h`文件中添加另一个回调，它只接受一个`int`参数并返回一个`BoundingBox2D`：
- en: '[PRE5]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The quadtree will be added to the renderer as a `private` member variable named
    `mQuadtree`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 四叉树将作为名为`mQuadtree`的`private`成员变量添加到渲染器中：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'During the initialization in the `initQuadTree()` method, we will bind the
    callback function to the `getBoundingBox()` method, using the instance index as
    the parameter:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initQuadTree()`方法的初始化过程中，我们将回调函数绑定到`getBoundingBox()`方法上，使用实例索引作为参数：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Filling the quadtree will happen in the `draw()` call of the renderer while
    iterating over the instances of the models. For each instance, we create the bounding
    box and add the instance to the quadtree:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器的`draw()`调用中，在遍历模型实例时填充四叉树。对于每个实例，我们创建边界框并将实例添加到四叉树中：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating the bounding box for every instance will be handled in the section
    *Calculating the instance bounding boxes*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个实例创建边界框将在*计算实例边界框*这一节中处理。
- en: 'One important question for the quadtree usage remains: Should we update the
    instance positions in the tree in every frame, or should we clear the entire quadtree
    and add all instances again?'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于四叉树的使用，还有一个重要问题：我们应该在每一帧更新树中的实例位置，还是应该清除整个四叉树并再次添加所有实例？
- en: Updating an object inside a quadtree needs to be done by deleting and re-adding.
    So, if we have mostly static objects in the quadtree, updates would be fine. But
    since our plan is to have many instances moving around and/or playing animations,
    the position and/or bounding box will change in almost every frame. In such an
    environment, instance removal and addition will be more expensive than clearing
    the quadtree and adding all instances with fresh data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 更新四叉树内的对象需要通过删除和重新添加来实现。因此，如果我们四叉树中大部分是静态对象，更新将是可行的。但鉴于我们的计划是要有多个实例在移动和/或播放动画，位置和/或边界框几乎在每一帧都会改变。在这种环境中，实例的删除和添加将比清除四叉树并使用新鲜数据添加所有实例更昂贵。
- en: 'Starting over with a fresh quadtree in the `draw()` call of the renderer is
    easy. Right before going into the instance loop, clear the contents of the quadtree:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器的`draw()`调用中重新开始使用一个全新的四叉树很容易。在进入实例循环之前，清除四叉树的内容：
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After the quadtree is ready, we have to solve the question of how to generate
    the bounding boxes for the instances. The answer may be surprising: We need to
    split the work between the GPU and the CPU.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 四叉树准备就绪后，我们必须解决如何为实例生成边界框的问题。答案可能令人惊讶：我们需要在GPU和CPU之间分配工作。
- en: Calculating the instance bounding boxes
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算实例边界框
- en: The first idea when it comes to a large number of calculations for all instances
    will most probably be “I will use a compute shader!”, especially after we have
    solved some compute-intense problems by offloading the work to the GPU. But in
    this case, the CPU must do a part of the job.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到所有实例的大量计算时，第一个想法很可能是“我将使用计算着色器！”，尤其是在我们通过将工作卸载到GPU来解决了一些计算密集型问题之后。但在这个案例中，CPU必须完成部分工作。
- en: While compute shaders are great for calculating independent results in a massively
    parallel way, they aren’t well suited for simple tasks like creating a bounding
    box. To calculate the bounding box of an instance, we need to store the minimum
    and maximum coordinates of all nodes for every instance in the virtual world,
    combining the intermediate results to create the final bounding box. On the CPU,
    we can easily grab the vertex positions from the data structures one by one, do
    the required calculations, and store the final AABB back in memory.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然计算着色器在以大规模并行方式计算独立结果方面很出色，但它们并不适合像创建边界框这样的简单任务。为了计算实例的边界框，我们需要存储虚拟世界中每个实例的所有节点的最小和最大坐标，结合中间结果以创建最终的边界框。在CPU上，我们可以轻松地从数据结构中逐个获取顶点位置，进行必要的计算，并将最终的AABB存储回内存中。
- en: But if we would like to compute the AABB coordinates inside a shader, we may
    end up overwriting the results of other shader invocations if the AABB results
    use the same buffer positions. Or we will have a huge list of coordinates that
    must be sorted afterward. Sorting the coordinates could be done in another computer
    shader too, but parallel sorting algorithms tend to be complex because they face
    the same constraints of not being able to write data to the same buffer positions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想在着色器内部计算AABB坐标，我们可能会覆盖其他着色器调用的结果，如果AABB结果使用相同的缓冲区位置。或者我们将有一个巨大的坐标列表，之后必须对其进行排序。排序坐标也可以在另一个计算机着色器中完成，但并行排序算法通常很复杂，因为它们面临着相同的约束，即不能写入相同的缓冲区位置。
- en: 'So, instead of worrying about data synchronization issues in compute shaders,
    we use them for what they can do very fast: creating lookup tables.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不必担心计算着色器中的数据同步问题，我们使用它们来做它们能非常快速完成的事情：创建查找表。
- en: Adding a three-dimensional bounding cube class
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加三维边界框类
- en: To store the generated lookup data, we will add a C++ class for a three-dimensional
    AABB. Using AABBs here has the advantage of having data to draw debug lines in
    the renderer, but the third set of coordinates adds only a little overhead to
    storage and generation time. Also, a possible upgrade to an octree for a fast
    collision check in all three dimensions will be simple.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储生成的查找数据，我们将添加一个用于三维AABB的C++类。在这里使用AABB的优势是可以在渲染器中绘制调试线条，但第三组坐标只增加了很少的存储和生成时间开销。此外，升级到八叉树以在三个维度上快速进行碰撞检测将是简单的。
- en: The new class is called `AABB` and will reside in the `tools` folder. Next to
    the constructor, some `public` getters and setters, and the two `private` floats
    `mMinPos` and `mMaxPos`, the `AABB` class has two `public` methods called `create()`
    and `addPoint()`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类称为`AABB`，并将位于`tools`文件夹中。除了构造函数外，还有一些`public`的获取器和设置器，以及两个`private`的浮点数`mMinPos`和`mMaxPos`，`AABB`类还有两个`public`方法，称为`create()`和`addPoint()`。
- en: 'By using the `create()` method, we add a point at the position given as the
    `glm::vec3` parameter as the minimum and maximum extents for the bounding box.
    And with `addPoint()`, we extend the bounding box to include the new point:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`create()`方法，我们在`glm::vec3`参数指定的位置添加一个点，作为边界框的最小和最大范围。使用`addPoint()`方法，我们可以扩展边界框以包含新点：
- en: '[PRE10]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the new point is inside the bounding box, nothing happens. But if the point
    is outside of the bounding box, the box will be expanded in one, two, or three
    dimensions to include the new point. In the end, we will have a box around all
    the points we added, defined by the minimum and maximum values of the three dimensions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新点在边界框内，则不会发生任何事情。但如果点在边界框外，则框将在一个、两个或三个维度上扩展以包含新点。最终，我们将有一个围绕我们添加的所有点的框，由三个维度的最小和最大值定义。
- en: 'For generating debug lines to draw in the renderer, the `public` method `getAABBlines()`
    is used. In `getAABBLines()`, we create the 12 lines between the 8 possible combinations
    of the minimum and maximum positions of the `x`, `y`, and `z` elements of `mMinPos`
    and `mMaxPos`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在渲染器中绘制调试线条，使用`public`方法`getAABBlines()`。在`getAABBLines()`中，我们创建`mMinPos`和`mMaxPos`的`x`、`y`和`z`元素的最小和最大位置之间可能的8种组合的12条线：
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating the AABB lookup tables
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建AABB查找表
- en: The general idea of the AABB lookup tables is to precalculate the AABB for a
    fixed number of frames of every animation clip for every model. Having the bounding
    boxes in a lookup table allows us to retrieve a good approximation of the model’s
    AABB in a frame of an animation clip.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: AABB查找表的一般思想是为每个模型中每个动画剪辑的固定帧数预先计算AABB。在查找表中拥有边界框允许我们在动画剪辑的帧中检索模型AABB的良好近似值。
- en: By blending between AABB coordinates of the same frame number in two different
    clips plus transforming the final AABB according to the model’s transformations,
    we can calculate a well-fitting AABB for the instance at low computing costs,
    even if the instance is in the middle of an animation blending.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在两个不同剪辑中同一帧号的AABB坐标之间进行混合，并根据模型的变换转换最终的AABB，我们可以在低计算成本下计算出适合实例的AABB，即使实例处于动画混合的中间。
- en: 'Creating the lookup table is a mix of a compute shader and CPU work, done in
    the `createAABBLookup()` method of the renderer. The lookup table is generated
    in the renderer class for two reasons:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 创建查找表是计算着色器和CPU工作的混合，在渲染器的`createAABBLookup()`方法中完成。查找表在渲染器类中生成，有两个原因：
- en: The main method to load the models is placed in the renderer, and we also expose
    the model loading method to the user interface via callback.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载模型的主要方法放在渲染器中，我们还通过回调将模型加载方法暴露给用户界面。
- en: The renderer already has the compute shaders loaded. We can use the shaders
    directly, instead of using another set of the same shaders in the `AssimpModel`
    class.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染器已经加载了计算着色器。我们可以直接使用着色器，而不是在`AssimpModel`类中使用另一组相同的着色器。
- en: For the compute shader part, we can reuse the code from the instance loop of
    the `draw()` call of the renderer we made back in [*Chapter 2*](Chapter_2.xhtml).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于计算着色器部分，我们可以重用我们在[*第2章*](Chapter_2.xhtml)中制作的渲染器`draw()`调用实例循环中的代码。
- en: To find the maximum extents of the model, we will use the nodes. To calculate
    the nodes per instance, the two compute shaders `assimp_instance_transform.comp`
    and `assimp_instance_matrix_mult.comp` can be used. In the translation part of
    the calculated matrices containing translation, rotation, and scale of the node,
    the location of each node is stored. The only difference here is the node offset
    matrices.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到模型的最大范围，我们将使用节点。为了计算每个实例的节点数，可以使用两个计算着色器`assimp_instance_transform.comp`和`assimp_instance_matrix_mult.comp`。在包含节点平移、旋转和缩放的矩阵的计算部分，存储了每个节点的位置。这里唯一的区别是节点偏移矩阵。
- en: While these offset matrices are required for vertex skinning, they would give
    the wrong results for node positions. We can remove the offset matrices in the
    calculations by binding an SSBO full of identity matrices, giving us only the
    node’s TRS matrices.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些偏移矩阵对于顶点皮肤变形是必需的，但它们会对节点位置给出错误的结果。我们可以通过绑定一个充满单位矩阵的SSBO来从计算中移除偏移矩阵，这样我们只有节点的TRS矩阵。
- en: By extracting the node positions per instance and creating a per-node AABB from
    the positions, we have an easy way to calculate the data we need for the quadtree
    and the debug display. For the 2D bounding box, we simply extract the `x` and
    `z` elements of the AABB, generating a “top-down” view of the AABB.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提取每个实例的节点位置并从位置创建每个节点的AABB，我们有一个简单的方法来计算我们需要的用于四叉树和调试显示的数据。对于2D边界框，我们只需提取AABB的`x`和`z`元素，生成AABB的“从上到下”视图。
- en: The AABB calculations are done per animation clip and per node of the model.
    The resulting `std::vector` will be stored in the `AssimpModel` data of the model
    we just loaded. To retrieve the correct AABB data for a time position in an animation
    clip, we use the same logic we already have for generating the vertex skinning
    matrices and take the scaled time position as an index into the lookup data. If
    we blend between two animations, we can even blend between the AABBs of the two
    animations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: AABB计算是按动画剪辑和模型节点进行的。生成的`std::vector`将存储在我们刚刚加载的模型的`AssimpModel`数据中。为了检索动画剪辑中时间位置的正确AABB数据，我们使用我们已有的生成顶点皮肤变形矩阵的逻辑，并将缩放的时间位置作为查找数据的索引。如果我们混合两个动画，我们甚至可以在两个动画的AABB之间进行混合。
- en: Using the AABB in the model and renderer
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在模型和渲染器中使用AABB
- en: 'When iterating over the instances in the `draw()` call of the renderer, we
    can now retrieve the AABB data for the animation clip and time position by calling
    `getAABB()`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当在渲染器的`draw()`调用中遍历实例时，现在可以通过调用`getAABB()`来检索动画剪辑和时间位置的AABB数据：
- en: '[PRE12]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Inside `getAABB()`, the data from animation and instance translation, rotation,
    and scale are used to create an AABB fitting the instance. In detail, `getAABB()`
    will:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getAABB()`内部，动画和实例平移、旋转和缩放的数据被用来创建适合实例的AABB。具体来说，`getAABB()`将：
- en: Look up the AABBs of the first and second animation clip
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找第一和第二个动画剪辑的AABB
- en: Blend between the two AABBs according to the animation blend factor
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据动画混合因子在两个AABB之间进行混合
- en: Scale the resulting AABB by the instance scale factor
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果AABB按实例缩放因子缩放
- en: Rotate the AABB in case the axis swap of the model is activated
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模型激活了轴交换，则旋转AABB
- en: Rotate the AABB according to the instance rotation (which is an OBB now)
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据实例旋转（现在是一个OBB）旋转AABB
- en: Generate a new AABB from the rotated ABB
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从旋转的ABB生成一个新的AABB
- en: Translate the AABB to the instance position
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将AABB平移到实例位置
- en: At this point, the AABB encloses the instance.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，AABB包围了实例。
- en: Since blending and rotations are still expensive operations that may harm performance
    in scenes with many instances, a speed-up can be achieved by parallelizing the
    computations with SIMD operations of modern processors, like SSE or AVX. But even
    keeping the AABB lookup data on the GPU may be beneficial. Calculating the bounding
    boxes of all instances with a compute shader and downloading the results could
    be still faster than pure CPU calculation, despite the additional download of
    the results.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于混合和旋转仍然是昂贵的操作，可能会在具有许多实例的场景中损害性能，通过使用现代处理器的 SIMD 操作（如 SSE 或 AVX）并行化计算可以加快速度。但即使将
    AABB 查找数据保留在 GPU 上也可能有益。使用计算着色器计算所有实例的边界框并将结果下载下来可能比纯 CPU 计算更快，尽管有额外的结果下载。
- en: To achieve the best possible performance, you might want to implement different
    versions of the `getAABB()` method and profile the application with various scene
    sizes and complexities.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到最佳性能，你可能想要实现 `getAABB()` 方法的不同版本，并使用各种场景大小和复杂度来分析应用程序。
- en: 'After the AABB is adjusted for the instance, we calculate the position and
    size of the two-dimensional bounding box for the quadtree:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在对实例的 AABB 进行调整后，我们计算四叉树中二维边界框的位置和大小：
- en: '[PRE13]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we have all the data to insert the instance into the quadtree:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了所有数据来将实例插入到四叉树中：
- en: '[PRE14]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To make sure we create a working quadtree, we will add a new ImGui window containing
    the quadtree, including all subdivisions and instances. Seeing the quadtree in
    action helps a lot to find any implementation bugs.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们创建了一个工作的四叉树，我们将添加一个新的 ImGui 窗口，包含四叉树及其所有子分区和实例。看到四叉树的实际运行情况对于发现任何实现错误非常有帮助。
- en: Creating a window to show the quadtree plus contents
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个窗口来显示四叉树及其内容
- en: For the ImGui window, we create a new method called `createPositionsWindow()`
    in the `UserInterface` class. Inside this method, we create a new window by using
    `ImGui::Begin()`. Next, we retrieve the world boundaries to have the origin, size,
    and center point to draw.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ImGui 窗口，我们在 `UserInterface` 类中创建了一个名为 `createPositionsWindow()` 的新方法。在这个方法内部，我们使用
    `ImGui::Begin()` 创建一个新的窗口。接下来，我们检索世界边界以获取原点、大小和中心点进行绘制。
- en: Then, we iterate over all instances, using the position and size of the bounding
    box to draw ImGui rectangles at the 2D world positions of the instances. We also
    use the pairs of the `micInstanceCollisions` variable to draw non-colliding and
    colliding instances in different colors.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历所有实例，使用边界框的位置和大小在实例的二维世界位置处绘制 ImGui 矩形。我们还使用 `micInstanceCollisions`
    变量的成对信息以不同颜色绘制非碰撞和碰撞实例。
- en: Finally, we retrieve the bounding boxes of the quadtree and all the subdivisions.
    To get the bounding boxes of all levels of the quadtree, we add a pair of `public`
    and `private` methods to the `Quadtree` class called `getTreeBoxes()`. The `getTreeBoxes()`
    method recursively iterates over the quadtree nodes and child nodes, storing the
    bounding boxes in a `std::vector` of `BoundingBox2D` elements. We draw all quadtree
    boxes by using white lines.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检索四叉树及其所有子分区的边界框。为了获取四叉树所有级别的边界框，我们在 `Quadtree` 类中添加了一对 `public` 和 `private`
    方法，称为 `getTreeBoxes()`。`getTreeBoxes()` 方法递归遍历四叉树节点及其子节点，将边界框存储在 `std::vector`
    的 `BoundingBox2D` 元素中。我们使用白色线条绘制所有四叉树框。
- en: '*Figure 8.13* shows an example of the quadtree window:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.13* 展示了四叉树窗口的一个示例：'
- en: '![](img/Image4098.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image4098.png)'
- en: 'Figure 8.13: A quadtree with subdivisions, instances, and detected collisions'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13：包含子分区、实例和检测到的碰撞的四叉树
- en: In *Figure 8.13*, the quadtree and all its subdivisions are drawn in white.
    The bounding boxes of a normal instance are drawn as yellow lines and colliding
    instances are drawn as red lines.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 8.13* 中，四叉树及其所有子分区都以白色绘制。正常实例的边界框以黄色线条绘制，碰撞实例以红色线条绘制。
- en: Filling the quadtree and drawing the result on the screen is only the first
    half of the collision detection; we also need to do something with the information
    of instances colliding in the virtual world.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 填充四叉树并在屏幕上绘制结果只是碰撞检测的第一步；我们还需要对虚拟世界中碰撞的实例信息进行处理。
- en: Retrieving the colliding instances and reacting to collisions
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取碰撞实例并响应碰撞
- en: 'Getting the list of all colliding instances out of the quadtree is done by
    calling `findAllIntersections()` of the `mQuadtree` object:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从四叉树中获取所有碰撞实例的列表是通过调用 `mQuadtree` 对象的 `findAllIntersections()` 实现的：
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We store the result in the new variable `micInstanceCollisions` in the `ModelInstanceCamData`
    struct to make the instance collisions available for other parts of the code (i.e.,
    for debug drawing lines). The colliding instances are given to us as pairs of
    instances.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结果存储在`ModelInstanceCamData`结构体中的新变量`micInstanceCollisions`中，以便其他部分的代码（即，用于调试绘制线条）可以使用实例碰撞。碰撞的实例以实例对的形式提供给我们。
- en: 'To see the results of a collision in the screen, we can iterate over the pairs
    of instances and rotate one or both instances:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕上看到碰撞的结果，我们可以遍历实例的对，并旋转一个或两个实例：
- en: '[PRE16]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Walking or running into another instance should now rotate your instance, or
    your instance and the colliding instance. Even though the angle is small, it will
    be incremented for every frame where a collision between those instances is detected.
    At a normal frame rate of 60 or 75 FPS, you will see yourself instantly rotated
    away from the other instance, suddenly running in a different direction.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 走进或跑进另一个实例现在应该旋转你的实例，或者你的实例和碰撞实例。尽管角度很小，但它将在检测到这些实例之间的碰撞的每一帧中增加。在正常的60或75 FPS帧率下，你会立刻看到自己远离其他实例，突然朝不同的方向跑去。
- en: If you don’t like having the instances just rotating on collisions, you can
    try to implement more complex reactions to collisions. Check out the *Practical
    sessions* section for a task about adding collision resolution and the *Additional
    resources* section for links to resources about collision avoidance.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢实例在碰撞时只是旋转，你可以尝试实现更复杂的碰撞反应。查看*实践课程*部分有关添加碰撞解决的任务，以及*附加资源*部分有关避免碰撞的资源链接。
- en: Drawing the AABB debug lines
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制AABB调试线条
- en: In the case that your instance or the other instance does not rotate and you
    can still walk right through other instances, drawing the AABB lines to the screen
    will become helpful.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的实例或另一个实例没有旋转，你仍然可以穿过其他实例，此时在屏幕上绘制AABB线条将变得很有帮助。
- en: 'To draw the debug lines in the renderer, we can use the pairs in `micInstanceCollisions`,
    retrieve the AABB lines from both affected instances, and add the vertices of
    the lines to a `private` variable called `mAABBMesh`. Then, we upload the vertex
    data to the line vertex buffer, and by using the line shader, we draw the AABBs
    to the screen:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器中绘制调试线条，我们可以使用`micInstanceCollisions`中的配对，从受影响的实例中检索AABB线条，并将线条的顶点添加到名为`mAABBMesh`的`private`变量中。然后，我们将顶点数据上传到线条顶点缓冲区，并通过使用线条着色器，将AABB绘制到屏幕上：
- en: '[PRE17]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As an alternative solution, we can iterate over all instances and use the instance
    indices in the pairs in `micInstanceCollisions` to switch the color of the AABB
    to draw.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一种解决方案，我们可以遍历所有实例，并使用`micInstanceCollisions`中对中的实例索引来切换AABB的绘制颜色。
- en: 'For more control over the AABB lines, a separate section in the ImGui **Control**
    window will be created. Combined with a new `enum` class called `collisionDebugDraws`
    and a bit more code in the `drawAABBs()` method in the renderer, you can switch
    between three different drawing modes:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对AABB线条有更多的控制，将在ImGui **控制**窗口中创建一个单独的部分。结合名为`collisionDebugDraws`的新`enum`类和渲染器中`drawAABBs()`方法中的更多代码，你可以在三种不同的绘制模式之间切换：
- en: No AABBs
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有AABB
- en: Only the colliding AABBs in red
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有碰撞的AABB用红色表示
- en: All colliding AABBs in red and all other AABBs in yellow
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有碰撞的AABB用红色表示，所有其他AABB用黄色表示
- en: '*Figure 8.14* shows an example of a detected collision, using yellow lines
    around non-colliding instances and red lines around the two colliding instances:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.14*展示了检测到的碰撞示例，使用黄色线条围绕非碰撞实例，红色线条围绕两个碰撞实例：'
- en: '![](img/Image4158.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image4158.png)'
- en: 'Figure 8.14: Two colliding instances among other non-colliding instances'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：在非碰撞实例中的两个碰撞实例
- en: Don’t be alarmed if some of the instances behave strangely, like constantly
    rotating around themselves. The reaction to collisions with other instances and
    the world boundaries is still very basic (just a rotation). We will enhance the
    collision handling in [*Chapter 9*](Chapter_9.xhtml).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一些实例的行为异常，例如不断围绕自身旋转，请不要惊慌。与其他实例和世界边界的碰撞反应仍然非常基础（只是旋转）。我们将在[*第9章*](Chapter_9.xhtml)中增强碰撞处理。
- en: 'After the quadtree is working and reduces the number of instances to check
    to a configurable minimum, we will start the implementation of one of the listed
    simplifications: By utilizing the nodes of the game character models as anchor
    points, bounding spheres have a good trade-off between creation and checking complexity.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在四叉树工作并减少需要检查的实例数量到可配置的最小值后，我们将开始实施列表中列出的简化之一：通过利用游戏角色模型的节点作为锚点，边界球体在创建和检查复杂度之间有一个良好的权衡。
- en: So, let’s go and add some spheres to the models.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们去给模型添加一些球体。
- en: Implementing bounding spheres
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现边界球体
- en: 'Bounding spheres as abstractions of higher detailed models can be used in different
    ways. One possible way is shown in *Figure 8.9*, where the sphere encloses the
    entire model. But as you can see in *Figure 8.9*, we would have a lot of empty
    space around the model, resulting in more false positives. Plus, we already have
    a method to do a broader check for possible collisions: the bounding boxes.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 边界球体作为更详细模型的抽象可以用不同的方式使用。一种可能的方式在*图8.9*中显示，其中球体包围了整个模型。但是，正如*图8.9*中所示，我们会在模型周围有大量的空空间，导致更多的错误肯定。此外，我们已经有了一种方法来进行更广泛的碰撞检查：边界框。
- en: Instead, we will use the spheres to simplify the instances at a more detailed
    level by adding configurable bounding spheres to the model’s nodes. Even though
    we would have to now check several dozens of spheres against the spheres of another
    instance, we are still way below the computational power we would need to check
    every single triangle of both models against each other.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用球体在更详细的级别上简化实例，通过向模型的节点添加可配置的边界球体。尽管我们现在需要检查几十个球体与另一个实例的球体，但我们仍然远远低于检查两个模型中每个三角形的计算能力。
- en: The number of false positives will also remain at an acceptable level. As stated
    broadly in the *Simplifying the instances for faster collision checks* section,
    choosing between a higher detailed simplification and more computations or simpler
    abstractions and more false positive collision detections is a tradeoff we have
    to live with, but we can make the decision strategically.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 错误肯定的数量也将保持在可接受的水平。正如在*简化实例以加快碰撞检查*部分中广泛陈述的那样，在更详细的简化与更多计算或更简单的抽象和更多错误肯定碰撞检测之间进行权衡是我们必须接受的，但我们可以战略性地做出决定。
- en: Creating the data for the bounding spheres
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建边界球体的数据
- en: To create the sphere data, we use the same first step as in the bounding box
    calculations. We use the compute shaders `assimp_instance_transform.comp` and
    `assimp_instance_matrix_mult.comp`, combined with replacing the bone offset matrices
    with identity matrices. The result of this shader run is an SSBO containing the
    node positions of all instances we want to equip with bounding spheres.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建球体数据，我们使用与边界框计算相同的第一个步骤。我们使用计算着色器`assimp_instance_transform.comp`和`assimp_instance_matrix_mult.comp`，结合用单位矩阵替换骨骼偏移矩阵。这个着色器运行的结果是一个SSBO，包含我们想要装备边界球体的所有实例的节点位置。
- en: But, in contrast to the bounding boxes, we can use another compute shader to
    calculate the bounding spheres for the nodes. The third compute shader, called
    `assimp_instance_bounding_spheres.comp`, uses the TRS matrices of the nodes created
    by the previous compute shaders, the world position matrices from the instances,
    and the parent node indices to create a bounding sphere for every node of every
    instance.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，与边界框不同，我们可以使用另一个计算着色器来计算节点的边界球体。第三个计算着色器，称为`assimp_instance_bounding_spheres.comp`，使用先前计算着色器创建的节点的TRS矩阵、实例的世界位置矩阵以及父节点索引来为每个实例的每个节点创建一个边界球体。
- en: Another SSBO called `SphereAdjustment` is used, containing a `vec4` for every
    node. These sphere adjustments can be set by a UI extension that maps the node
    names of the model to one `SliderFloat` and one `SliderFloat3`, allowing us to
    resize and move around the bounding spheres created by the shader. By carefully
    placing the bounding spheres, we can make sure to have as little empty space around
    the model that would be detected as collision.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个名为`SphereAdjustment`的SSBO也被使用，每个节点包含一个`vec4`。这些球体调整可以通过一个UI扩展来设置，该扩展将模型的节点名称映射到一个`SliderFloat`和一个`SliderFloat3`，允许我们调整和移动由着色器创建的边界球体。通过仔细放置边界球体，我们可以确保模型周围尽可能少的空空间被检测为碰撞。
- en: '*Figure 8.15* shows the new UI section:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.15*显示了新的UI部分：'
- en: '![](img/Image4167.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image4167.png)'
- en: 'Figure 8.15: Fine-tuning the bounding spheres of a model'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：微调模型的边界球体
- en: The `SphereAdjustments` SSBO is backed by a `std::vector` of `glm::vec4` elements
    called `msBoundingSphereAdjustments`, placed in the `ModelSettings` struct. In
    the adjustments vector, each `vec4` is split, using the first three elements for
    the position and the last element for the radius of each sphere.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`SphereAdjustments` SSBO 由一个名为 `msBoundingSphereAdjustments` 的 `glm::vec4`
    元素 `std::vector` 支持，放置在 `ModelSettings` 结构体中。在调整向量中，每个 `vec4` 被分割，使用前三个元素作为每个球体的位置，最后一个元素作为球体的半径。'
- en: And since it’s a good idea to not have to tune the bounding spheres on every
    application restart, the contents of the `msBoundingSphereAdjustments` buffer
    are added to the `YamlParser` class to be able to save and restore the adjustments.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在每次应用程序重启时都不必调整边界球体是一个好主意，因此将 `msBoundingSphereAdjustments` 缓冲区的内容添加到 `YamlParser`
    类中，以便能够保存和恢复调整：
- en: Both the addition to the user interface and to the YAML parser are more or less
    trivial, copied from already existing ImGui and YAML parsing code parts. You can
    explore the `UserInterface` and `YamlParser` classes to check out the code changes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户界面和 YAML 解析器添加的功能更多或更少是平凡的，复制自已经存在的 ImGui 和 YAML 解析代码部分。您可以探索 `UserInterface`
    和 `YamlParser` 类来检查代码更改：
- en: 'Our third compute shader, `assimp_instance_bounding_spheres.comp`, also reuses
    parts of other shaders. The top of the `main()` method is identical to the matrix
    multiplication compute shader:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个计算着色器 `assimp_instance_bounding_spheres.comp` 也重用了其他着色器的一部分。`main()` 方法的顶部与矩阵乘法计算着色器相同：
- en: '[PRE18]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We select the node and instance to work on based on the invocation IDs of the
    shader, while the number of nodes in the model comes from the X dimension of the
    number of work groups we use when dispatching the compute shader.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据着色器的调用 ID 选择要处理的节点和实例，而模型中的节点数量来自我们在调度计算着色器时使用的组数的 X 维度：
- en: 'Next, we get the node position by extracting the translational part from the
    TRS matrix of the specific node of the instance and adding the position from the
    sphere adjustment buffer:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过从实例特定节点的 TRS 矩阵中提取平移部分并添加来自球体调整缓冲区的位置来获取节点位置：
- en: '[PRE19]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We also declare the sphere radius and initialize it with a default value.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了球体半径，并用默认值初始化它：
- en: 'Then, we extract the parent node ID of the current node from the parent index
    buffer:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从父索引缓冲区中提取当前节点的父节点 ID：
- en: '[PRE20]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The parent node is used to switch between nodes that have a parent and the
    parent or unconnected, standalone nodes. If we find a valid parent, we calculate
    the world position of the parent node, including the position adjustment:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 父节点用于在具有父节点和父节点或未连接的独立节点之间切换。如果我们找到一个有效的父节点，我们将计算父节点的世界位置，包括位置调整：
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By using the node and parent position, we calculate the middle point between
    the node and its parent. We calculate the radius of the sphere – again, adjustable
    by the sphere adjustment value:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用节点和父节点位置，我们计算节点与其父节点之间的中点。我们计算球体的半径——同样，可以通过球体调整值进行调整：
- en: '[PRE22]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the root node, we set the radius of the sphere to the adjustable value:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于根节点，我们将球体的半径设置为可调整的值：
- en: '[PRE23]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At the end of the `main()` method, we add a small check to disable small spheres
    already in the shader:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 方法的末尾，我们添加了一个小的检查来禁用已经在着色器中的小球体：
- en: '[PRE24]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we need to run the three compute shaders from several different places in
    the renderer code, we make our lives easier by adding the code to fill and run
    the shaders to a new method called `runBoundingSphereComputeShaders`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要在渲染器代码的几个不同位置运行三个计算着色器，我们通过将填充和运行着色器的代码添加到名为 `runBoundingSphereComputeShaders`
    的新方法中来简化我们的工作：
- en: Drawing bounding spheres
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制边界球体
- en: The second usage of the compute shaders for the bounding spheres is a debug
    display, similar to the AABBs. After running the compute shaders, we can use another
    new vertex and fragment shader pair to draw the spheres to the screen.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于边界球体的计算着色器的第二次使用是调试显示，类似于AABB。在运行计算着色器之后，我们可以使用另一对新的顶点和片段着色器来将球体绘制到屏幕上：
- en: 'In the `main()` method of the new sphere-drawing vertex shader called `sphere_instanced.vert`,
    we extract the center and radius of the sphere:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为 `sphere_instanced.vert` 的新球体绘制顶点着色器的 `main()` 方法中，我们提取球体的中心和半径：
- en: '[PRE25]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To speed up the drawing, we will use an instanced drawing call for the rendering
    API, so we can use the special variable `gl_InstanceID` here (the variable `gl_InstanceID`
    was renamed to `gl_InstanceIndex` in Vulkan). Both OpenGL and Vulkan are internally
    incrementing the values of the variable `gl_InstanceID` respective `gl_InstanceIndex`
    for every instance, allowing us to draw thousands of bounding spheres from a single
    set of vertices.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快绘图速度，我们将使用渲染API的实例化绘图调用，这样我们就可以在这里使用特殊变量`gl_InstanceID`（在Vulkan中将变量`gl_InstanceID`重命名为`gl_InstanceIndex`）。OpenGL和Vulkan在内部递增变量`gl_InstanceID`和`gl_InstanceIndex`的值，每增加一个实例，这样我们就可以从单个顶点集中绘制成千上万的边界球体。
- en: 'Resizing the spheres to the correct radius is done by a small GLSL function
    called `createScaleMatrix()` in the shader, essentially creating a scaling matrix
    with the `radius` value in the main diagonal elements:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在着色器中调用名为`createScaleMatrix()`的小GLSL函数来调整球体的大小到正确的半径，该函数实际上是在主对角线元素中创建一个具有`radius`值的缩放矩阵：
- en: '[PRE26]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we scale the original position of the sphere vertex by the scaling matrix,
    add the sphere adjustment, create the final shader matrix by multiplication with
    `view` and `projection` matrices, and set the line color:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将球体顶点的原始位置通过缩放矩阵进行缩放，添加球体调整，通过乘以`view`和`projection`矩阵创建最终的着色器矩阵，并设置线条颜色：
- en: '[PRE27]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Running the sphere shader is done by calling an instanced version of the `Shader`
    class drawing command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`Shader`类的实例化版本绘图命令来运行球体着色器：
- en: '[PRE28]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For the Vulkan renderer, the equivalent drawing calls are used (`vkCmdBindPipeline()`,
    `vkCmdBindVertexBuffers()`, `vkCmdBindDescriptorSets()`, and `VkCmdDraw()`).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vulkan渲染器，使用等效的绘图调用（`vkCmdBindPipeline()`、`vkCmdBindVertexBuffers()`、`vkCmdBindDescriptorSets()`和`VkCmdDraw()`）。
- en: Since the bounding spheres for collision detection may not be identical to the
    bounding spheres we want to draw on the screen, we use separate methods for drawing
    debug spheres. The main difference between our debug draw methods is the creation
    of the list of instances to feed the compute shaders with.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用于碰撞检测的边界球体可能与我们想要在屏幕上绘制的边界球体不完全相同，因此我们使用单独的方法来绘制调试球体。我们调试绘图方法之间的主要区别是创建一个实例列表，以供计算着色器使用。
- en: We could draw bounding spheres only on the selected instance by calling `drawSelectedBoundingSpheres()`,
    show the bounding boxes for instances with collisions by calling `drawCollidingBoundingSpheres()`,
    or create “fluffy white snowballs” around all instances in the screen, as in *Figure
    8.16*, by calling `drawAllBoundingSpheres()`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`drawSelectedBoundingSpheres()`仅绘制所选实例的边界球体，通过调用`drawCollidingBoundingSpheres()`显示发生碰撞的实例的边界框，或者通过调用`drawAllBoundingSpheres()`在屏幕上的所有实例周围创建“蓬松的白色雪球”，如图8.16所示。
- en: '![](img/Image4175.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image4175.png)'
- en: 'Figure 8.16: Adjusted bounding spheres on the nodes of the woman’s model'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16：女性模型节点上的调整后的边界球体
- en: Now that we are able to calculate and draw bounding spheres for the models,
    let’s add the spheres as a second tier to the collision detection code.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够计算和绘制模型边界球体，让我们将球体作为第二层添加到碰撞检测代码中。
- en: Using the bounding spheres for collision detection
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用边界球体进行碰撞检测
- en: 'The colliding instances from the quadtree are collected in the renderer by
    calling `findAllIntersections()` and saved to `micInstanceCollisions`, as already
    stated in the *Retrieving the colliding instances and reacting to the collision*
    section:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如在*检索碰撞实例并响应碰撞*部分所述，通过调用`findAllIntersections()`收集来自四叉树的碰撞实例，并保存到`micInstanceCollisions`中：
- en: '[PRE29]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To make the collision detection code easier to maintain, we move the intersection
    extraction call to a new method called `checkForInstanceCollisions()`. This new
    method will be the starting point for all code related to collision detection
    and handling.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使碰撞检测代码更容易维护，我们将交集提取调用移动到一个名为`checkForInstanceCollisions()`的新方法中。这个新方法将成为所有与碰撞检测和处理相关的代码的起点。
- en: Our first step to extend collision detection is done by calling the above `findAllIntersections()`
    method to get all colliding instances from the quadtree. Then, we split up the
    instances by model into separate sets of `int`. Using separate lists of colliding
    instances per model is needed because different models may have a different number
    of nodes.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展碰撞检测的第一步是通过调用上述的`findAllIntersections()`方法来从四叉树中获取所有碰撞实例。然后，我们根据模型将这些实例分成单独的`int`集合。对每个模型使用单独的碰撞实例列表是必要的，因为不同的模型可能有不同数量的节点。
- en: Then, for every set of instances, we create the SSBO with the bounding spheres
    and extract the sphere data to a map of `glm::ve4` vectors. We will use the instance
    index position as the key for the map, splitting up the SSBO into a map containing
    all spheres per instance as values.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每一组实例，我们使用边界球创建SSBO，并将球体数据提取到`glm::ve4`向量的映射中。我们将使用实例索引位置作为映射的键，将SSBO分割成一个包含每个实例所有球体的映射值。
- en: The real collision check for the bounding spheres is done by comparing all spheres
    from one colliding instance with all spheres of the second colliding instance.
    We already reduced the number of these checks by a lot, since we only have the
    instance pairs left that were delivered by the quadtree.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，边界球的碰撞检查是通过比较一个碰撞实例的所有球体与第二个碰撞实例的所有球体来完成的。我们已经通过只保留由四叉树提供的实例对来大量减少了这些检查的数量。
- en: But even if checking the spheres for collisions is an easy task and we just
    have to compare the distance between the centers with the sum of the radii of
    both spheres, the number of comparisons will make this check slow.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 即使检查球体碰撞是一个简单的任务，我们只需要比较两个球体中心的距离与两个球体半径之和，比较的数量也会使这个检查变得缓慢。
- en: Even with a shortcut to remove all spheres with a radius of zero and stopping
    to compare when a collision has been detected, a check between two just-not-colliding
    instances with 30 active spheres per model will need 900 such comparisons.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 即使通过移除所有半径为零的球体并停止比较以检测到碰撞来简化操作，两个刚刚未发生碰撞的实例之间，每个模型有30个活动球体，也需要900次这样的比较。
- en: Speeding up the sphere compare operations with a compute shader is possible,
    but problems like different node counts for each instance in a pair to check will
    raise the complexity and lower the efficiency of a compute shader.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算着色器加快球体比较操作是可能的，但像每个实例对中每个实例的不同节点数这样的问题会增加计算着色器的复杂度并降低其效率。
- en: While the parallel computation on the GPU may be fast, uploading and downloading
    the data and running the shader for a single pair of instances may add a significant
    delay, nullifying the acceleration of the compute shader.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在GPU上的并行计算可能很快，但上传和下载数据以及为单个实例对运行着色器可能会增加显著的延迟，从而抵消了计算着色器的加速效果。
- en: So, we stick with the CPU-based solution to calculate the second tier of the
    collisions between bounding boxes. Unless we have thousands of instances in a
    very small virtual world or many instances in a small part of the world, the overall
    number of collision checks will remain low.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们继续使用基于CPU的解决方案来计算边界框之间的第二层碰撞。除非我们在一个非常小的虚拟世界中拥有数千个实例，或者在世界的某个小部分中有许多实例，否则碰撞检查的总数将保持较低。
- en: '*Figure 8.17* shows an example of a collision detected by the bounding boxes
    (drawn with red lines), and an additional collision of any of the bounding spheres
    (also in red):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.17*展示了通过边界框（用红色线条绘制）检测到的碰撞示例，以及任何边界球的附加碰撞（也用红色表示）：'
- en: '![](img/Image4186.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image4186.png)'
- en: 'Figure 8.17: A collision was detected by the bounding spheres of the instances'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：检测到实例的边界球发生了碰撞
- en: Handling collision remains identical to the reaction of collisions with bounding
    boxes in the *Retrieving the colliding instances and reacting to collisions* section
    – we simply rotate the colliding instances about a fixed angle in every frame.
    We will enhance the reaction to collisions in [*Chapter 9*](Chapter_9.xhtml) and
    [*Chapter 12*](Chapter_12.xhtml).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 处理碰撞与*检索碰撞实例并响应碰撞*部分中处理边界框碰撞的反应相同——我们只需在每一帧中围绕一个固定角度旋转碰撞实例。我们将在[*第9章*](Chapter_9.xhtml)和[*第12章*](Chapter_12.xhtml)中增强对碰撞的反应。
- en: Collision detection is a complex topic with many algorithms and choices based
    on your application’s specific needs. We need to know what kind of objects we
    need to check to select a good shape of an abstraction, and depending on the complexity
    of the abstraction, we may need to adjust the algorithm (or algorithms) to use
    when trying to find collisions. We did not even touch the collision resolution
    part that resolves the collision by moving the instances apart after an intersection
    was detected. If you want to dive deeper into the world of game physics, collision
    detection, and collision resolution, check out the books in the *Additional resources*
    section.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞检测是一个复杂的话题，有许多算法和选择，这些选择基于你应用程序的具体需求。我们需要知道我们需要检查哪些类型的对象来选择一个抽象的好形状，并且根据抽象的复杂性，我们可能需要调整在尝试找到碰撞时使用的算法（或算法）。我们甚至没有触及到碰撞解决部分，该部分在检测到交点后通过移动实例来解决问题。如果你想深入了解游戏物理、碰撞检测和碰撞解决的世界，请查看*附加资源*部分中的书籍。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored collision detection and created a two-tier collision
    detection for the application. We started by discussing the shortcomings of a
    naive solution, then we explored spatial partitioning methods and model simplifications
    to lower the number of checks we have to do until we are quite sure which instances
    really have some collisions. Finally, we implemented a quadtree with bounding
    boxes and bounding spheres to find out which instances collide.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了碰撞检测并为应用程序创建了两级碰撞检测。我们首先讨论了简单解决方案的不足，然后探讨了空间划分方法和模型简化以减少我们必须进行的检查次数，直到我们非常确定哪些实例确实发生了碰撞。最后，我们实现了带有边界框和边界球的四叉树以找出哪些实例发生了碰撞。
- en: In the next chapter, we will create “real” **non-player characters** (**NPCs**)
    and let the instances come to life by adding configurable behavior. We will start
    by exploring the nature of behavior trees and their relation to the decision-making
    of NPCs, and we will implement code to support behavior trees for our instances.
    As the last step, we will look at the interaction between models as a specialized
    set of the general behavior.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建“真实”的**非玩家角色**（NPCs）并通过添加可配置的行为让实例变得生动。我们将从探索行为树的本质及其与NPC决策的关系开始，并实现支持行为树代码以供我们的实例使用。作为最后一步，我们将研究模型之间的交互，将其视为一般行为的专用集合。
- en: Practical sessions
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践课程
- en: 'Here are some additions you could make to the code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些你可以添加到代码中的改进：
- en: Add UI controls for the quadtree configuration.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加用于四叉树配置的用户界面控件。
- en: Currently, the quadtree is statically initialized during the renderer `init()`
    call. Add UI controls and a setter callback function to adjust the maximum number
    of instances before splitting up the box and the maximum depth of the tree.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，四叉树在渲染器`init()`调用期间静态初始化。添加用户界面控件和设置回调函数来调整在分割盒子之前实例的最大数量和树的最大深度。
- en: Add UI controls to configure the world borders.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加用户界面控件来配置世界边界。
- en: The instances are running around in the virtual world, and if one instance reaches
    the virtual border set in `mWorldBoundaries`, it will be rotated to stay inside
    the boundaries. Add some sliders and callbacks to control the origin and size
    of the virtual world, and make sure the **Instance Positions** window will be
    updated, too.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 实例在虚拟世界中四处移动，如果一个实例达到在`mWorldBoundaries`中设置的虚拟边界，它将被旋转以保持在边界内。添加一些滑块和回调函数来控制虚拟世界的原点和大小，并确保**实例位置**窗口也会更新。
- en: Implement an octree plus three-dimensional AABB checks.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现八叉树加上三维轴对齐包围盒（AABB）检查。
- en: Right now, we are using only two-dimensional bounding boxes for the instances,
    just as if the instances were seen top-down. Extend the quadtree to become an
    octree and add three-dimensional intersection checks between the AABBs of the
    instances.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只为实例使用二维边界框，就像实例是从上方看到的。将四叉树扩展为八叉树，并在实例的AABB之间添加三维交点检查。
- en: Speed up the bounding sphere collision check.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速边界球碰撞检测。
- en: Due to the general complexity of the checks – we have to check every sphere
    of the first instance against every sphere of the second instance – the collision
    check is quite slow. Maybe a compute shader can help here. In contrast to the
    bounding box generation, we need only a single yes/no answer per instance to signal
    if a collision occurred. Using an atomic counter per sphere or instance could
    help avoid lengthy post-processing work after the computer shader has done its
    job.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 由于检查的复杂性——我们必须将第一个实例的每个球体与第二个实例的每个球体进行比较——碰撞检查相当慢。也许计算着色器可以在这里有所帮助。与边界框生成不同，我们只需要对每个实例给出一个是/否的答案来表示是否发生了碰撞。使用每个球体或实例的原子计数器可以帮助避免计算着色器工作完成后进行长时间的后处理工作。
- en: Add a simple bounding volume hierarchy.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个简单的边界体积层次结构。
- en: Instead of checking all spheres of both instances, you could add some unused
    nodes to the models and add bigger bounding spheres to these nodes, enclosing
    some of the smaller spheres. Check the spheres by starting with the largest spheres
    for both instances. If these large spheres don’t collide, all spheres inside the
    larger sphere can never have a collision, and the entire part of the body could
    be skipped for the next collision checks.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是检查两个实例的所有球体，你可以在模型中添加一些未使用的节点，并将更大的边界球体添加到这些节点上，包围一些较小的球体。从两个实例中最大的球体开始检查球体。如果这些大球体没有发生碰撞，那么大球体内部的球体永远不会发生碰撞，因此整个身体部分可以跳过下一次碰撞检查。
- en: 'Enhanced difficulty: Do a real triangle-to-triangle check between the instances.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加难度：在实例之间进行真正的三角形到三角形的检查。
- en: This is the ultimate goal in collision detection. By checking the instances
    for real intersections, not just some AABBs or bounding spheres, natural-looking
    collision behavior could be achieved. Also, make note of the benefits of this
    method and see whether the extra precision benefits the runtime behavior.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是碰撞检测的最终目标。通过检查实例的真实交点，而不仅仅是某些AABB或边界球体，可以实现自然的外观碰撞行为。同时，注意这种方法的好处，并看看额外的精度是否有利于运行时行为。
- en: 'Enhanced difficulty: Add collision resolution.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加难度：添加碰撞解决。
- en: When the collision check signals a collision between two instances, it’s already
    too late – the instances are partially intersected. Good collision detection comes
    with collision resolution where the instances are moved apart when a collision
    is found. Several books have been written about collision detection and collision
    resolution; see the *Additional resources* section for some well-known titles.
    There are still many caveats on the path to “making it right.”
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当碰撞检查信号表示两个实例之间发生碰撞时，已经太晚了——实例已经部分相交。良好的碰撞检测伴随着碰撞解决，当发现碰撞时，实例会被分开。已经有许多关于碰撞检测和碰撞解决的书籍被撰写；请参阅“其他资源”部分中的一些知名标题。在“做得正确”的道路上仍然存在许多注意事项。
- en: Additional resources
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'Separating Axis Theorem: [https://dyn4j.org/2010/01/sat/](https://dyn4j.org/2010/01/sat/)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离轴定理：[https://dyn4j.org/2010/01/sat/](https://dyn4j.org/2010/01/sat/)
- en: 'Gilbert–Johnson–Keerthi distance algorithm: [https://cse442-17f.github.io/Gilbert-Johnson-Keerthi-Distance-Algorithm/](https://cse442-17f.github.io/Gilbert-Johnson-Keerthi-Distance-Algorithm/)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 吉尔伯特-约翰逊-基尔蒂距离算法：[https://cse442-17f.github.io/Gilbert-Johnson-Keerthi-Distance-Algorithm/](https://cse442-17f.github.io/Gilbert-Johnson-Keerthi-Distance-Algorithm/)
- en: 'Template-based quadtree implementation: [https://github.com/pvigier/Quadtree](https://github.com/pvigier/Quadtree)'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于模板的四叉树实现：[https://github.com/pvigier/Quadtree](https://github.com/pvigier/Quadtree)
- en: 'Collision Detection in Interactive 3D Environments: ISBN 978-1558608016'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式3D环境中的碰撞检测：ISBN 978-1558608016
- en: 'Real-Time Collision Detection: ISBN 978-1558607323'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时碰撞检测：ISBN 978-1558607323
- en: 'Game Physics Engine Development: ISBN 978-0123819765'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏物理引擎开发：ISBN 978-0123819765
- en: 'Game Physics: ISBN 978-0123749031'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏物理：ISBN 978-0123749031
- en: 'Collision Avoidance: [https://code.tutsplus.com/understanding-steering-behaviors-collision-avoidance--gamedev-7777t](https://code.tutsplus.com/understanding-steering-behaviors-collision-avoidance--gamedev-7777t)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞避免：[https://code.tutsplus.com/understanding-steering-behaviors-collision-avoidance--gamedev-7777t](https://code.tutsplus.com/understanding-steering-behaviors-collision-avoidance--gamedev-7777t)
- en: 'More about Collision Avoidance: [https://www.gameaipro.com/GameAIPro2/GameAIPro2_Chapter19_Guide_to_Anticipatory_Collision_Avoidance.pdf](https://www.gameaipro.com/GameAIPro2/GameAIPro2_Chapter19_Guide_to_Anticipatory_Collision_Avoidance.pdf)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于碰撞避免的内容：[https://www.gameaipro.com/GameAIPro2/GameAIPro2_Chapter19_Guide_to_Anticipatory_Collision_Avoidance.pdf](https://www.gameaipro.com/GameAIPro2/GameAIPro2_Chapter19_Guide_to_Anticipatory_Collision_Avoidance.pdf)
