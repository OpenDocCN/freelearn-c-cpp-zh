- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Temporal Anti-Aliasing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间抗锯齿
- en: In this chapter, we will expand on a concept touched on in the previous one
    when we talked about temporal reprojection. One of the most common ways to improve
    image quality is to sample more data (super-sampling) and filter it down to the
    needed sampling frequency.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展在前一章中提到的概念，当时我们讨论了时间重投影。提高图像质量最常见的方法是采样更多数据（超采样），并将其过滤到所需的采样频率。
- en: The primary technique used in rendering is **Multi-Sample Anti-Aliasing**, or
    **MSAA**. Another technique used for super-sampling is temporal super-sampling
    or using the samples from two or more frames to reconstruct a higher-quality image.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染过程中使用的主要技术是**多样本抗锯齿**，或称为**MSAA**。另一种用于超采样的技术是时间超采样，或使用两个或更多帧的样本来重建更高品质的图像。
- en: In the Volumetric Fog technique, a similar approach is used to remove banding
    given by the low resolution of the Volume Texture in a very effective way. We
    will see how we can achieve better image quality using **Temporal** **Anti-Aliasing**
    (**TAA**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在体积雾技术中，采用类似的方法以非常有效的方式消除由体积纹理低分辨率引起的带状条纹。我们将看到如何通过使用**时间****抗锯齿**（**TAA**）来实现更好的图像质量。
- en: This technique has become widely used in recent years after more and more games
    started using Deferred Rendering at their core and because of the difficulty in
    applying MSAA on it. There were various attempts to make MSAA and Deferred Rendering
    work together, but performance (both time- and memory-wise) has always been proven
    to not be feasible at the time and thus alternative solutions started to be developed.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在近年来被广泛采用，因为越来越多的游戏开始在核心中使用延迟渲染，并且由于在延迟渲染上应用MSAA的困难。有各种尝试使MSAA和延迟渲染协同工作，但当时在时间和内存性能方面始终证明是不可行的，因此开始开发替代解决方案。
- en: Enter **Post-Process Anti-Aliasing** and its plethora of acronyms. The first
    one to be widely used was **Morphological Anti-Aliasing**, or **MLAA**, developed
    by Alexander Reshetov, working at Intel at the time, and presented at High-Performance
    Graphics in 2009.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 进入**后处理抗锯齿**及其众多缩写。第一个被广泛使用的是**形态学抗锯齿**，或称为**MLAA**，由当时在Intel工作的亚历山大·雷什托夫开发，并在2009年的高性能图形会议上展示。
- en: The algorithm was developed to work on the CPU using Intel’s **Streaming SIMD
    Extensions** (**SSE**) instructions and introduced some interesting solutions
    to find and improve geometrical edge rendering, which fueled successive implementations.
    Later, Sony Santa Monica adopted MLAA for God of War III using the Cell **Synergisic
    Processing Unit** (**SPUs**) to be performed with real-time performances.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法是为了在CPU上使用Intel的**流式单指令多数据扩展**（**SSE**）指令而开发的，并提出了一些有趣的解决方案来寻找和改进几何边缘渲染，这推动了后续的实现。后来，索尼圣莫尼卡在《战神III》中采用了MLAA，使用Cell
    **协同处理单元**（**SPUs**）以实时性能执行。
- en: Post-Process Anti-Aliasing finally found a GPU implementation developed by Jorge
    Jimenez and others in 2011, opening a new rendering research field. Various other
    game studios started developing custom Post Process Anti-Aliasing techniques and
    sharing their details.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 后处理抗锯齿终于在2011年由豪尔赫·吉梅内斯和其他人开发出了GPU实现，开辟了一个新的渲染研究领域。各种其他游戏工作室开始开发定制的后处理抗锯齿技术并分享他们的细节。
- en: All those techniques were based on geometrical edge recognition and image enhancement.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些技术都是基于几何边缘识别和图像增强。
- en: Another aspect that started to emerge was the reuse of information from previous
    frames to further enhance visual quality, such as in **Sharp Morphological Anti-Aliasing**,
    or **SMAA**, which started adding a temporal component to enhance the final image.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个开始出现的新方面是重用前帧的信息以进一步增强视觉效果，例如在**锐化形态学抗锯齿**，或称为**SMAA**中，它开始添加时间组件以增强最终图像。
- en: The most adopted anti-aliasing technique is TAA, which comes with its own set
    of challenges but fits nicely within the rendering pipeline and lets other techniques
    (such as Volumetric Fog) increase their visual quality by reducing banding with
    the introduction of animated dithering.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛采用的抗锯齿技术是TAA，它带来了一系列挑战，但非常适合渲染管线，并允许其他技术（如体积雾）通过引入动画抖动来减少带状条纹，从而提高视觉效果。
- en: TAA is now the standard in most game engines, both commercial and private. It
    comes with its own challenges, such as handling transparent objects and image
    blurriness, but we will see how to tackle those problems as well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: TAA现在已成为大多数游戏引擎的标准，无论是商业的还是私人的。它带来了一些挑战，例如处理透明物体和图像模糊，但我们将看到如何解决这些问题。
- en: In the rest of the chapter, we will first see an overview of the algorithm and
    then dive into the implementation. We will also create an initial, incredibly
    simple implementation just to show the basic building blocks of the algorithm,
    allowing you to understand how to write a custom TAA implementation from scratch.
    Finally, we will see the different areas of improvement within the algorithm.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将首先看到算法概述，然后深入到实现。我们还将创建一个初始的、极其简单的实现，仅为了展示算法的基本构建块，让您了解如何从头开始编写自定义
    TAA 实现。最后，我们将看到算法中的不同改进区域。
- en: 'Let’s see an example scene and highlight the TAA improvements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例场景并突出 TAA 的改进：
- en: '![Figure 11.1 – Temporally anti-aliased scene](img/B18395_11_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 时间反走样场景](img/B18395_11_01.jpg)'
- en: Figure 11.1 – Temporally anti-aliased scene
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 时间反走样场景
- en: The following are a couple of screenshots of the final result, with and without
    TAA enabled.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些最终结果的截图，有和没有启用 TAA。
- en: '![Figure 11.2 – Details of Figure 11.1 without (left) and with (right) TAA](img/B18395_11_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 图 11.1 无（左）和有（右）TAA 的细节](img/B18395_11_02.jpg)'
- en: Figure 11.2 – Details of Figure 11.1 without (left) and with (right) TAA
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 图 11.1 无（左）和有（右）TAA 的细节
- en: 'In this chapter, we will have a look at the following topics:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Creating the simplest TAA implementation
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建最简单的 TAA 实现
- en: Step-by-step improvement of the technique
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术的逐步改进
- en: Overview of image-sharpening techniques outside of TAA
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TAA之外图像锐化技术概述
- en: Improving banding in different image areas with noise and TAA
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用噪声和TAA改善不同图像区域的带状
- en: Technical requirements
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter11](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter11).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下网址找到：[https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter11](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter11)。
- en: Overview
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this section, we will see the algorithm overview of the TAA rendering technique.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到 TAA 渲染技术的算法概述。
- en: 'TAA is based on the collection of samples over time by applying small offsets
    to the camera projection matrix and applying some filters to generate the final
    image, like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: TAA 基于通过应用小的偏移到相机投影矩阵并应用一些过滤器来生成最终图像的样本集合，如下所示：
- en: '![Figure 11.3 – Frustum jitter](img/B18395_11_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 楔形抖动](img/B18395_11_03.jpg)'
- en: Figure 11.3 – Frustum jitter
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 楔形抖动
- en: There are various numerical sequences that can be used to offset the camera,
    as we will see in the implementation section. Moving the camera is called **jittering**,
    and by jittering the camera, we gather additional data that we can use to enhance
    the image.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种数值序列可以用来偏移相机，正如我们在实现部分将看到的。移动相机被称为 **抖动**，通过抖动相机，我们可以收集额外的数据来增强图像。
- en: 'The following is an overview of the TAA shader:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 TAA 着色器的概述：
- en: '![Figure 11.4 – TAA algorithm overview](img/B18395_11_04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – TAA 算法概述](img/B18395_11_04.jpg)'
- en: Figure 11.4 – TAA algorithm overview
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – TAA 算法概述
- en: Based on *Figure 11**.4*, we’ve separated the algorithm into steps (blue rectangles)
    and texture reads (yellow ellipses:.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 *图 11**.4*，我们将算法分为步骤（蓝色矩形）和纹理读取（黄色椭圆）。
- en: We calculate the coordinates to read the velocity from, represented by the **Velocity**
    **Coordinates** block.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算读取速度的坐标，表示为 **速度坐标** 块。
- en: This is normally done by reading a neighborhood of 3x3 pixels around the current
    pixel position and finding the closest pixel, using the current frame’s **Depth
    Texture**. Reading from a 3x3 neighborhood has been proven to decrease ghosting
    and improve edge quality.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是通过读取当前像素位置周围的 3x3 像素邻域并找到最近的像素，使用当前帧的 **深度纹理** 来完成的。从 3x3 邻域读取已被证明可以减少鬼影并提高边缘质量。
- en: We read the velocity using the newly found coordinates from the **Velocity Texture**
    block, paying attention to use a linear sampler, as velocity is not just in increments
    of pixels, but can be in-between pixels.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用从 **速度纹理** 块中找到的新坐标读取速度，注意使用线性采样器，因为速度不仅仅是像素的增量，还可以在像素之间。
- en: We read the color information from the **History Texture** block. This is basically
    the last frame’s TAA output. We can optionally apply a filter to read the texture
    to further enhance the quality.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从**历史纹理**块读取颜色信息。这基本上是上一帧的TAA输出。我们可以选择应用一个过滤器来读取纹理，以进一步提高质量。
- en: We will read the current scene color. In this step, we will also cache information
    again by reading a neighborhood around the current pixel position to constrain
    the history color we read previously and guide the final resolve phase.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将读取当前场景的颜色。在这个步骤中，我们还将通过读取当前像素位置周围的邻域来缓存信息，以约束我们之前读取的历史颜色，并引导最终的解决阶段。
- en: History constraint. We try to limit the previous frame color inside an area
    of the current color to reject invalid samples coming from occlusion or disocclusion.
    Without doing that there would be a lot of ghosting.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 历史约束。我们试图将前一帧的颜色限制在当前颜色的一个区域内，以拒绝来自遮挡或去遮挡的无效样本。如果不这样做，会有很多幽灵效果。
- en: The sixth and final step is **Resolve**. We combine the current color and the
    constraint history color to generate the final pixel color by applying some additional
    filters.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第六步和最后一步是**解决**。我们将当前颜色和约束历史颜色结合，通过应用一些额外的过滤器来生成最终的像素颜色。
- en: The result of the current frame’s TAA will be the next frame history texture,
    so we simply switch the textures (history and TAA result) every frame without
    the need to copy the results over, as seen in some implementations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当前帧的TAA结果将是下一帧的历史纹理，所以我们只需每帧简单地切换纹理（历史和TAA结果），无需像某些实现那样复制结果。
- en: Now that we have seen an overview of the algorithm, we can start by implementing
    an initial TAA shader.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了算法的概述，我们可以开始实现一个初始的TAA着色器。
- en: The simplest TAA implementation
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最简单的TAA实现
- en: The best way to understand this technique is to build a basic implementation
    missing some important steps and to have a blurry or jittery rendering as it is
    easy to do.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种技术的最好方法是构建一个缺少一些重要步骤的基本实现，并且渲染模糊或抖动，因为这很容易做到。
- en: The basic ingredients for this technique are simple if done correctly, but each
    must be done in a precise way. We will first add jittering to the camera so that
    we can render slightly different points of view of the scene and gather additional
    data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正确执行，这种技术的基本成分很简单，但每个都必须以精确的方式进行。我们首先给相机添加抖动，这样我们就可以渲染场景的不同视角并收集额外的数据。
- en: We will then add motion vectors so that we can read the previous frame color
    information in the right place. Finally, we will reproject, or simply put, read
    the history frame color data and combine it with current frame data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加运动矢量，以便我们可以在正确的位置读取前一帧的颜色信息。最后，我们将重新投影，或者说，读取历史帧的颜色数据并将其与当前帧的数据结合。
- en: Let us see the different steps.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不同的步骤。
- en: Jittering the camera
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抖动相机
- en: The objective of this step is to translate the projection camera by a small
    amount in both the *x* and *y* axes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步的目标是通过`x`和`y`轴将投影相机平移一个小量。
- en: 'We have added some utility code in the `GameCamera` class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`GameCamera`类中添加了一些实用代码：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Every step is important and error prone, so be careful.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步都很重要且容易出错，所以请小心。
- en: We first want to reset the projection matrix, as we will manually modify it.
    We then build a translation matrix with the jittering values in `x` and `y`, and
    we will see later how to calculate them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想要重置投影矩阵，因为我们将会手动修改它。然后我们构建一个包含`x`和`y`抖动值的平移矩阵，我们稍后会看到如何计算它们。
- en: Finally, we multiply the projection matrix by the jittering matrix and calculate
    the new view-projection matrix. Beware of multiplication order, as if this is
    wrong you will see a jittery blurry mess even when not moving the camera!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将投影矩阵乘以抖动矩阵，并计算新的视图投影矩阵。注意乘法顺序，因为如果顺序错误，即使不移动相机，你也会看到一个模糊的、抖动的混乱！
- en: 'Having this working, we can optimize the code by removing the matrix construction
    and multiplication, having cleaner and less error-prone code, like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个功能正常工作后，我们可以通过移除矩阵构建和乘法来优化代码，得到更干净且错误更少的代码，如下所示：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Choosing jittering sequences
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择抖动序列
- en: 'We will now build a sequence of `x` and `y` values to jitter the camera. Normally
    there are different sequences that are used:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将构建一个`x`和`y`值的序列来抖动相机。通常有不同序列被使用：
- en: Halton
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Halton
- en: Hammersley
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hammersley
- en: Martin Robert’s R2
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马丁·罗伯特的R2
- en: Interleaved gradients
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交错梯度
- en: There are all the implementations for the preceding sequences in the code, and
    each can give a slightly different look to the image, as it changes how we collect
    samples over time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中包含了前面序列的所有实现，每个实现都可以让图像呈现出略微不同的外观，因为它改变了我们随时间收集样本的方式。
- en: There is plenty of material on using the different sequences that we will provide
    links to at the end of the chapter; right now what is important is to know that
    we have a sequence of two numbers that we repeat after a few frames to jitter
    the camera.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用我们将提供的不同序列的丰富材料，我们将在本章末尾提供链接；现在重要的是要知道我们有一个重复几次帧后抖动相机的两个数字的序列。
- en: 'Let us say that we choose the Halton sequence. We first want to calculate the
    values for `x` and `y`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们选择了Halton序列。我们首先想要计算`x`和`y`的值：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These values are in the `[0,1]` range, but we want to jitter in both directions,
    so we map it to the `[-``1.1]` range:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值在`[0,1]`范围内，但我们想要在两个方向上抖动，因此我们将其映射到`[-1.1]`范围：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We now apply them to the apply `jitter` method, with a caveat: we want to add
    sub-pixel jittering, thus we need to divide these offsets by the screen resolution:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将它们应用到`apply jitter`方法中，但有一个注意事项：我们想要添加亚像素抖动，因此我们需要将这些偏移量除以屏幕分辨率：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we have a jitter period to choose after how many frames we repeat
    the jittering numbers, updated like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要选择一个抖动周期，在重复抖动数字后经过多少帧，更新如下：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A good period is normally four frames, but in the accompanying code, there is
    the possibility to change this number and see the effect on the rendering image.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通常一个好的周期是四帧，但在附带的代码中，有改变这个数字并查看对渲染图像影响的可能性。
- en: Another fundamental thing to do is to cache previous and current jittering values
    and send them to the GPU, so that motion vectors take into consideration the full
    movement.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个基本的事情是要缓存先前和当前的抖动值并将它们发送到GPU，这样运动向量就可以考虑完整的移动。
- en: We’ve added `jitter_xy` and `previous_jitter_xy` as variables in the scene uniforms
    to be accessed in all shaders.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在场景统一变量中添加了`jitter_xy`和`previous_jitter_xy`作为变量，以便在所有着色器中访问。
- en: Adding motion vectors
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加运动向量
- en: 'Now that we correctly jittered the camera and saved the offsets, it is time
    to add motion vectors to properly read the color data from the previous frame.
    There are two sources of motion: camera motion and dynamic object motion.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正确地抖动了相机并保存了偏移量，是时候添加运动向量以正确读取前一帧的颜色数据了。有两个运动来源：相机运动和动态对象运动。
- en: We added a velocity texture with R16G16 format to store the per-pixel velocity.
    For each frame, we clear that to `(0,0)` and we calculate the different motions.
    For camera motion, we will calculate the current and previous screen space position,
    considering the jitter and the motion vector.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个R16G16格式的速度纹理来存储每个像素的速度。对于每一帧，我们将它清除到`(0,0)`并计算不同的运动。对于相机运动，我们将计算当前和先前的屏幕空间位置，考虑到抖动和运动向量。
- en: 'We will perform this in a compute shader:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在计算着色器中执行以下操作：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Dynamic meshes need an additional output to be written in the vertex or mesh
    shaders, with similar calculations done in the camera motion shader:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 动态网格需要在顶点着色器或网格着色器中写入额外的输出，并在相机运动着色器中进行类似的计算：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And after this, just writing the velocity to its own render target will be all
    that is needed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需将速度写入其自己的渲染目标即可。
- en: Now that we have the motion vectors, we can finally see the implementation of
    an extremely basic TAA shader.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了运动向量，我们终于可以看到一个极其基本的TAA着色器的实现。
- en: First implementation code
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首次实现代码
- en: 'We again run a compute shader to calculate TAA. The implementation of the simplest
    possible shader is the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次运行计算着色器来计算TAA。最简单可能的着色器实现如下：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Going through the code, the steps are simple:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，步骤很简单：
- en: Sample the velocity at the pixel position.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在像素位置采样速度。
- en: Sample the current color at the pixel position.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在像素位置采样当前颜色。
- en: Sample the history color at the previous pixel position, calculated using the
    motion vectors.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用运动向量在先前的像素位置采样历史颜色。
- en: Mix the colors, taking something like 10% of the current frame colors.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 混合颜色，取当前帧颜色的10%左右。
- en: Before moving on to any improvement it is paramount to have this working perfectly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行任何改进之前，确保这一点完美运行至关重要。
- en: 'You should see a blurrier image with a big problem: ghosting when moving the
    camera or an object. If the camera and the scene are static, there should be no
    pixel movement. This is fundamental to knowing that jittering and reprojection
    are working properly.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个模糊度更大的图像，但存在一个大问题：在移动相机或物体时会出现鬼影。如果相机和场景是静态的，则不应该有像素移动。这是判断抖动和重投影是否正常工作的基本依据。
- en: With this implementation working, we are now ready to see the different improvement
    areas to have a more solid TAA.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这种实现方式的工作，我们现在可以查看不同的改进区域，以获得更稳固的TAA。
- en: Improving TAA
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进TAA
- en: 'There are five areas to improve TAA: reprojection, history sampling, scene
    sampling, history constraint, and resolve.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有五个方面可以改进TAA：重投影、历史采样、场景采样、历史约束和解决。
- en: Each one has different parameters to be tweaked that can suit the rendering
    needs of a project – TAA is not exact or perfect, thus some extra care from a
    visual perspective needs to be taken into account.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都有不同的参数需要调整，以满足项目的渲染需求——TAA并不精确或完美，因此从视觉角度来看需要额外注意。
- en: Let’s see the different areas in detail so that the accompanying code will be
    clearer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看不同的区域，以便使伴随的代码更清晰。
- en: Reprojection
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重投影
- en: The first thing to do is to improve reprojection and thus calculate the coordinates
    to read the velocity to drive the *History* *sampling* section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是改进重投影，从而计算读取速度的坐标来驱动*历史* *采样*部分。
- en: 'To calculate the history texture pixel coordinates, the most common solution
    is to get the closest pixel in a 3x3 square around the current pixel, as an idea
    by Brian Karis. We will read the depth texture and use the depth value as a way
    to determine the closest pixel, and cache the `x` and `y` position of that pixel:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算历史纹理像素坐标，最常见的方法是获取当前像素周围3x3正方形中的最近像素，这是Brian Karis的一个想法。我们将读取深度纹理，并使用深度值作为确定最近像素的方法，并缓存该像素的`x`和`y`位置：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By just using the found pixel position as the read coordinate for the motion
    vectors, ghosting will be much less visible, and edges will be smoother:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用找到的像素位置作为运动向量的读取坐标，鬼影将变得不那么明显，边缘将更加平滑：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There can be other ways of reading the velocity, but this has proven to be the
    best trade-off between quality and performance. Another way to experiment would
    be to use the maximum velocity in a similar 3x3 neighborhood of pixels.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有其他读取速度的方法，但这种方法已经在质量和性能之间证明了最佳权衡。另一种实验方法是在类似的3x3像素邻域中使用最大速度。
- en: There is no perfect solution, and thus experimentation and parametrization of
    the rendering technique are highly encouraged. After we have calculated the pixel
    position of the history texture to read, we can finally sample it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 没有完美的解决方案，因此强烈鼓励进行实验和渲染技术的参数化。在我们计算出读取历史纹理的像素位置后，我们最终可以对其进行采样。
- en: History sampling
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 历史采样
- en: In this case, the simplest thing to do is to just read the history texture at
    the calculated position. The reality is that we can apply a filter to enhance
    the visual quality of the read as well.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最简单的事情就是直接在计算的位置读取历史纹理。现实情况是，我们还可以应用一个过滤器来增强读取的视觉效果。
- en: 'In the code, we’ve added options to try different filters, and the standard
    choice here is to use a Catmull-Rom filter to enhance the sampling:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们添加了尝试不同过滤器的选项，这里的标准选择是使用Catmull-Rom过滤器来增强采样：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After we have the history color, we will sample the current scene color and
    cache information needed for both the history constraint and the final resolve
    phase.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们得到历史颜色后，我们将采样当前场景颜色，并缓存历史约束和最终解决阶段所需的信息。
- en: Using the history color without further processing would result in ghosting.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不进行进一步处理就使用历史颜色，会导致鬼影效果。
- en: Scene sampling
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景采样
- en: At this point, ghosting is less noticeable but still present, so with a similar
    mentality to searching for the closest pixel, we can search around the current
    pixel to calculate color information and apply a filter to it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，鬼影效果不那么明显但仍存在，因此我们可以用类似寻找最近像素的心态，在当前像素周围搜索以计算颜色信息并对其应用过滤器。
- en: Basically, we are treating a pixel like a signal instead of a simple color.
    The subject can be quite long and interesting and at the end of the chapter, there
    will be resources to dive deeper into this. Also, in this step, we will cache
    information used for the history boundaries used to constrain the color coming
    from the previous frames.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们将像素视为信号而不是简单的颜色。这个主题可以相当长且有趣，在章节末尾，将提供资源以深入了解这一点。此外，在这一步中，我们将缓存用于约束来自前一帧的颜色的历史边界所需的信息。
- en: What we need to know is that we sample another 3x3 area around the current pixel
    and calculate the information necessary for the constraint to happen. The most
    valuable information is the minimum and maximum color in this area, and Variance
    Clipping (which we will look at later on) also requires mean color and square
    mean color (known as **moments**) to be calculated to aid history constraint.
    Finally, we will also apply some filtering to the sampling of the color.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道的是，我们将围绕当前像素采样另一个3x3区域，并计算约束发生所需的信息。最有价值的信息是此区域中的最小和最大颜色，方差裁剪（我们将在稍后查看）还需要计算平均颜色和平方平均颜色（称为**矩**）以帮助历史约束。最后，我们还将对颜色采样应用一些过滤。
- en: 'Let’s see the code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What all this code does is sample color, filter it, and cache information for
    the history constraint, and thus we are ready to move on to the next phase.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些代码所做的就是采样颜色，过滤它，并为历史约束缓存信息，因此我们可以继续到下一阶段。
- en: The history constraint
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 历史约束
- en: Finally, we arrived at the constraint of the history sampled color. Based on
    previous steps we have created a range of possible color values that we consider
    valid. If we think of each color channel as a value, we basically created an area
    of valid colors that we will constraint against.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达了历史采样颜色的约束。基于前面的步骤，我们创建了一个我们认为有效的可能颜色值范围。如果我们认为每个颜色通道都是一个值，我们基本上创建了一个有效的颜色区域，我们将对其进行约束。
- en: A constraint is a way of accepting or discarding color information coming from
    the history texture, reducing ghosting to almost nothing. Over time, different
    ways to constrain history sampled color were developed in search of better criteria
    to discard colors.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 约束是一种接受或丢弃来自历史纹理的颜色信息的方式，可以减少鬼影到几乎为零。随着时间的推移，为了寻找更好的标准来丢弃颜色，人们开发了不同的约束历史采样颜色的方法。
- en: Some implementations also tried relying on depth or velocity differences, but
    this seems to be the more robust solution.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实现也尝试依赖于深度或速度差异，但这似乎是更稳健的解决方案。
- en: 'We have added four constraints to test:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了四个约束来测试：
- en: RGB clamp
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB夹紧
- en: RGB clip
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RGB裁剪
- en: Variance clip
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方差裁剪
- en: Variance clip with clamped RGB
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有夹紧RGB的方差裁剪
- en: The best quality is given by variance clip with the clamped RGB, but it is interesting
    to see the other ones, as they are the ones that were employed in the first implementations.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的质量是由带有夹紧RGB的方差裁剪提供的，但看到其他选项也很有趣，因为它们是首次实现中使用的。
- en: 'Here is the code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `clip_aabb` function is the method that constrains the sampled history color
    within minimum and maximum color values.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`clip_aabb`函数是限制采样历史颜色在最小和最大颜色值之间的方法。'
- en: In brief, we are trying to build an AABB in colorspace to limit the history
    color to be within that range, so that the final color is more plausible compared
    to the current one.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们试图在颜色空间中构建一个AABB来限制历史颜色位于该范围内，从而使最终颜色与当前颜色相比更可信。
- en: The last step in the TAA shader is resolve, or combining current and history
    colors and applying some filters to generate the final pixel color.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: TAA着色器的最后一步是解析，即结合当前和历史颜色，并应用一些过滤器以生成最终的像素颜色。
- en: Resolve
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析
- en: Once again, we will apply some additional filters to decide whether the previous
    pixel is usable or not and by how much.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将应用一些额外的过滤器来决定前一个像素是否可用以及可用程度。
- en: 'By default, we start with using just 10% of the current frame pixel and rely
    on history, so without any of those filters the image will be quite blurry:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们开始只使用当前帧像素的10%，并依赖于历史信息，因此如果没有这些过滤器，图像将会相当模糊：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first filter we will see is the temporal one, which uses the cached neighborhood
    minimum and maximum colors to calculate how much to blend the current and previous
    colors:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到的第一个过滤器是时间过滤器，它使用缓存的邻域最小和最大颜色来计算当前和先前颜色混合的程度：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The next two filters are linked; thus, we have them together.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个过滤器是相关的；因此，我们将它们放在一起。
- en: 'They both work with luminance, with one used to suppress so-called **fireflies**,
    or very bright single pixels that can exist in images when there is a strong source
    of light, while the second uses the difference in luminance to further steer the
    weight toward either the current or previous colors:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 他们两者都使用亮度，一个用于抑制所谓的**萤火虫**，即当有强烈光源时图像中可能存在的非常亮的单个像素，而另一个则使用亮度差异来进一步引导权重，使其偏向当前或之前的颜色：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We combine the result using the newly calculated weights, and finally, we output
    the color:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用新计算出的权重组合结果，最后输出颜色：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At this point, the shader is complete and ready to be used. In the accompanying
    demo, there will be many tweaking parameters to learn the differences between
    the different filters and steps involved.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，着色器已经完成，准备好使用。在附带的演示中，将有许多调整参数来学习不同过滤器以及涉及的步骤之间的差异。
- en: One of the most common complaints about TAA is the blurriness of the image.
    We will see a couple of ways to improve that next.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 关于TAA最常见的抱怨之一是图像的模糊。接下来我们将看到几种改善这一问题的方法。
- en: Sharpening the image
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锐化图像
- en: One thing that can be noticed in the most basic implementation, and a problem
    often linked to TAA, is a decrease in the sharpness of the image.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本实现中可以注意到的一件事，以及与TAA经常相关的问题，是图像锐度的降低。
- en: We have already improved it by using a filter when sampling the scene, but we
    can work on the final image appearance outside of TAA in different ways. We will
    briefly discuss three different ways to improve the sharpening of the image.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过在采样场景时使用过滤器来改进了它，但我们可以在TAA之外以不同的方式处理最终图像的外观。我们将简要讨论三种不同的方法来提高图像的锐化。
- en: Sharpness post-processing
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锐化后处理
- en: One of the ways to improve the sharpness of the image is to add a simple sharpening
    shader in the post-process chain.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 提高图像锐度的方法之一是在后处理链中添加一个简单的锐化着色器。
- en: 'The code is simple, and it is luminance based:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单，它是基于亮度的：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Based on this code, when the sharpening amount is `0` the image is not sharpened.
    The standard value is `1`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这段代码，当锐化量为`0`时，图像不会被锐化。标准值是`1`。
- en: Negative mip bias
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负MIP偏差
- en: A global way to reduce blurriness is to modify the `mipLodBias` field in the
    `VkSamplerCreateInfo` structure to be a negative number, such as `–0.25`, thus
    shifting the texture **mip,** the pyramid of progressively smaller images of a
    texture to higher values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一种全局减少模糊的方法是修改`VkSamplerCreateInfo`结构中的`mipLodBias`字段，使其为负数，例如`-0.25`，从而将纹理**MIP**，即纹理的逐渐缩小的图像金字塔，移动到更高的值。
- en: This should be done by considering the performance difference, as we are sampling
    at a higher MIP level, and if the level is too high, we could re-introduce aliasing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该通过考虑性能差异来完成，因为我们正在更高MIP级别上进行采样，如果级别太高，我们可能会重新引入走样。
- en: A global engine option to tweak would be a great solution to this.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个全局引擎选项来调整将是一个很好的解决方案。
- en: Unjitter texture UVs
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解除纹理UV抖动
- en: 'Another possible fix to sample sharper textures is to calculate the UVs as
    the camera was without any jittering, like so:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的解决方案来采样更锐利的纹理是像这样计算UVs，就像相机没有任何抖动时一样：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I personally did not try this method but found it interesting and something
    to experiment with. It was written about by Emilio Lopez in his TAA article, linked
    in the *Reference* section, also citing a colleague named Martin Sobek who came
    up with the idea.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人没有尝试这种方法，但觉得它很有趣，值得实验。它被Emilio Lopez在他的TAA文章中提到，该文章链接在*参考*部分，并引用了一位名叫Martin
    Sobek的同事，他想出了这个主意。
- en: The combination of TAA and sharpening drastically improves the edges of the
    image while retaining the details inside the objects.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: TAA和锐化的结合极大地改善了图像的边缘，同时保留了物体内部的细节。
- en: 'We need to look at one last aspect of the image: banding.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要关注图像的最后一个方面：带状效应。
- en: Improving banding
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改善带状效应
- en: Banding is a problem affecting various steps in the rendering of a frame. It
    affects Volumetric Fog and lighting calculations, for example.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 带状效应是影响帧渲染各个步骤的问题。例如，它会影响体积雾和光照计算。
- en: '![Figure 11.5 – Banding problem detail in Volumetric Fog](img/B18395_11_05.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5 – 体积雾中带状问题细节](img/B18395_11_05.jpg)'
- en: Figure 11.5 – Banding problem detail in Volumetric Fog
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – 体积雾中带状问题细节
- en: We can see in *Figure 11**.5* how this can be present in Volumetric Fog if no
    solution is implemented. A solution to remove banding in visuals is to add some
    dithering to various passes of the frame, but that also adds visual noise to the
    image.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图11.5*中看到，如果没有实施解决方案，这可以在体积雾中存在。解决视觉中带状效应的方法是在帧的各个通道中添加一些随机抖动，但这也会向图像添加视觉噪声。
- en: Dithering is defined as the intentional addition of noise specifically to remove
    banding. Different type of noises can be used, as we will see in the accompaining
    code. Adding temporal reprojection smoothens the noise added, thus becoming one
    of the best ways to improve the visual quality of the image.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 随机抖动（Dithering）被定义为有意添加噪声以消除带状效应。可以使用不同类型的噪声，正如我们将在随附的代码中看到的那样。添加时间重投影可以平滑添加的噪声，因此成为提高图像视觉质量的最佳方法之一。
- en: 'In [*Chapter 10*](B18395_10.xhtml#_idTextAnchor152), *Adding Volumetric Fog*,
    we saw a very simple temporal reprojection scheme, and we have also added noise
    to various steps of the algorithm. We have now seen a more complex implementation
    of a temporal reprojection scheme to enhance the image, and it should be clearer
    on reasoning behind animated dithering: animating dithering gives effectively
    more samples, and thanks to temporal reprojection, uses them effectively. Dithering
    is linked to its own temporal reprojection, thus in the Volumetric Fog steps,
    the dithering scale can be too large to be cleaned up by TAA.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B18395_10.xhtml#_idTextAnchor152)“添加体积雾”中，我们看到了一个非常简单的时间重投影方案，并且我们也向算法的各个步骤添加了噪声。我们现在已经看到了一个更复杂的时间重投影方案的实施，以增强图像，并且它应该更清楚地解释了动画抖动背后的原理：动画抖动有效地提供了更多的样本，并且由于时间重投影，有效地使用了它们。抖动与其自己的时间重投影相关联，因此在体积雾步骤中，抖动比例可能太大，无法被TAA清理。
- en: When applying Volumetric Fog to the scene though, we can add a small, animated
    dithering that increases the fog visuals while being cleaned up by TAA. Another
    dithering application is in the lighting shader, again at the per-pixel level
    and thus eligible to be cleaned up by TAA.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当将体积雾（Volumetric Fog）应用于场景时，我们可以添加一个小型的、动态的随机抖动，以增强雾的视觉效果，同时通过TAA进行清理。另一个随机抖动的应用是在光照着色器中，同样是在像素级别，因此有资格被TAA清理。
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Trying to get a noise-free image is hard as the temporal reprojection uses more
    than one frame, thus it is not possible to show here in an image what appears
    banding-free in the accompanying application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试获得无噪声的图像很困难，因为时间重投影使用了多个帧，因此不可能在这里通过图像展示在随附的应用程序中出现的无带状效果。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the TAA rendering technique.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了TAA渲染技术。
- en: 'We gave an overview of the algorithm by trying to highlight the different shader
    steps involved. We then moved on to create the simplest possible TAA shader: an
    exercise to give us a deeper understanding of the technique itself.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过尝试突出涉及的不同着色器步骤来概述了算法。然后我们继续创建最简单的TAA着色器：一个练习，以让我们更深入地理解这项技术本身。
- en: Following that, we started enhancing the various steps using filters and information
    taken from the current scene. We encourage you to add custom filters and tweak
    parameters and different scenes to understand and develop the technique further.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们开始使用过滤器以及从当前场景中获取的信息来增强各个步骤。我们鼓励您添加自定义过滤器，调整参数以及不同场景，以进一步理解和开发这项技术。
- en: An idea to experiment with could also be to apply the history constraint to
    the temporal reprojection phase of the Volumetric Fog, as suggested by my friend
    Marco Vallario a few months ago.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以尝试的想法是将历史约束应用于体积雾的时间重投影阶段，这是我的朋友Marco Vallario几个月前建议的。
- en: In the next chapter, we will add support for ray tracing to the Raptor Engine,
    a recent technological advancement that unlocks high-quality illumination techniques,
    which we will cover in the following chapters.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向Raptor Engine添加对光线追踪的支持，这是一项最近的技术进步，它解锁了高质量的光照技术，我们将在接下来的章节中介绍。
- en: Further reading
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: We touched on several topics in this chapter, from the history of post-process
    anti-aliasing to implementations of TAA, to banding and noise.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了多个主题，从后处理抗锯齿的历史到TAA的实现，再到带状和噪声。
- en: Thanks to the graphics community, which shares a lot of information on their
    findings, it is possible to sharpen our knowledge on this subject.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了图形社区，他们分享了大量的发现信息，我们才能在这个主题上加深我们的知识。
- en: 'The following are some links to read:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些阅读链接：
- en: 'For an index of the evolution of Post-Process Anti-Aliasing techniques: [http://www.iryoku.com/research-impact-retrospective-mlaa-from-2009-to-2017](http://www.iryoku.com/research-impact-retrospective-mlaa-from-2009-to-2017).'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于后处理反走样技术演变的索引：[http://www.iryoku.com/research-impact-retrospective-mlaa-from-2009-to-2017](http://www.iryoku.com/research-impact-retrospective-mlaa-from-2009-to-2017)。
- en: 'The first MLAA paper: [https://www.intel.com/content/dam/develop/external/us/en/documents/z-shape-arm-785403.pdf](https://www.intel.com/content/dam/develop/external/us/en/documents/z-shape-arm-785403.pdf).'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一篇 MLAA 论文：[https://www.intel.com/content/dam/develop/external/us/en/documents/z-shape-arm-785403.pdf](https://www.intel.com/content/dam/develop/external/us/en/documents/z-shape-arm-785403.pdf)。
- en: 'An MLAA GPU implementation: [http://www.iryoku.com/mlaa/](http://www.iryoku.com/mlaa/).'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MLAA 的 GPU 实现：[http://www.iryoku.com/mlaa/](http://www.iryoku.com/mlaa/)。
- en: 'SMAA, an evolution of MLAA: [http://www.iryoku.com/smaa/](http://www.iryoku.com/smaa/).'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SMAA，MLAA 的一种演变：[http://www.iryoku.com/smaa/](http://www.iryoku.com/smaa/)。
- en: 'The best article on signal processing and anti-aliasing by Matt Pettineo: [https://therealmjp.github.io/posts/msaa-resolve-filters/](https://therealmjp.github.io/posts/msaa-resolve-filters/).'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matt Pettineo 关于信号处理和反走样的最佳文章：[https://therealmjp.github.io/posts/msaa-resolve-filters/](https://therealmjp.github.io/posts/msaa-resolve-filters/)。
- en: 'Temporal Reprojection Anti-Aliasing in Inside, containing the first full documentation
    of a TAA technique. Includes information about history constraints and AABB clipping:
    [http://s3.amazonaws.com/arena-attachments/655504/c5c71c5507f0f8bf344252958254fb7d.pdf?1468341463](http://s3.amazonaws.com/arena-attachments/655504/c5c71c5507f0f8bf344252958254fb7d.pdf?1468341463).'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Inside 中的时间重投影反走样技术，包含了对 TAA 技术的首次全面文档记录。包括历史约束和 AABB 剪裁的信息：[http://s3.amazonaws.com/arena-attachments/655504/c5c71c5507f0f8bf344252958254fb7d.pdf?1468341463](http://s3.amazonaws.com/arena-attachments/655504/c5c71c5507f0f8bf344252958254fb7d.pdf?1468341463)。
- en: 'High-Quality Temporal Supersampling, Unreal Engine TAA implementation: [https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf](https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf).'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高质量时间超采样，虚幻引擎 TAA 实现：[https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf](https://de45xmedrsdbp.cloudfront.net/Resources/files/TemporalAA_small-59732822.pdf)。
- en: 'An excursion in temporal super-sampling, introducing variance clipping: [https://developer.download.nvidia.com/gameworks/events/GDC2016/msalvi_temporal_supersampling.pdf](https://developer.download.nvidia.com/gameworks/events/GDC2016/msalvi_temporal_supersampling.pdf).'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间超采样的一次探索，介绍了方差剪裁：[https://developer.download.nvidia.com/gameworks/events/GDC2016/msalvi_temporal_supersampling.pdf](https://developer.download.nvidia.com/gameworks/events/GDC2016/msalvi_temporal_supersampling.pdf)。
- en: 'A TAA article, with tips, such as UV unjittering and Mip bias: [https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/](https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/).'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一篇包含提示的 TAA 文章，例如 UV 解抖动和 Mip 偏置：[https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/](https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/)。
- en: 'Another great TAA article with a full implementation: [https://alextardif.com/TAA.xhtml](https://alextardif.com/TAA.xhtml).'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一篇优秀的 TAA 文章，包含完整实现：[https://alextardif.com/TAA.xhtml](https://alextardif.com/TAA.xhtml)。
- en: 'Banding in games: [https://loopit.dk/banding_in_games.pdf](https://loopit.dk/banding_in_games.pdf).'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中的带状现象：[https://loopit.dk/banding_in_games.pdf](https://loopit.dk/banding_in_games.pdf)。
