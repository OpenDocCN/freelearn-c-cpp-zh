["```cpp\nclass LineInfo; \nclass Paragraph; \n\nclass CharInfo { \n  public: \n    CharInfo(Paragraph* paragraphPtr = nullptr, \n             TCHAR tChar = TEXT('\\0'), \n             Font font = SystemFont, Rect rect = ZeroRect); \n\n    CharInfo(const CharInfo& charInfo); \n    CharInfo& operator=(const CharInfo& charInfo); \n\n    bool WriteCharInfoToStream(ostream& outStream) const; \n    bool ReadCharInfoFromStream(istream& inStream); \n\n    void WriteCharInfoToClipboard(InfoList& infoList) const; \n    void ReadCharInfoFromClipboard(InfoList& infoList); \n\n```", "```cpp\n    TCHAR Char() const {return tChar;} \n    Font CharFont() const {return charFont;} \n    Rect CharRect() const {return charRect;} \n    LineInfo* LineInfoPtr() const {return lineInfoPtr;} \n    Paragraph* ParagraphPtr() const {return paragraphPtr;} \n\n    TCHAR& Char() {return tChar;} \n    Font& CharFont() {return charFont;} \n    Rect& CharRect() {return charRect;} \n    LineInfo*& LineInfoPtr() {return lineInfoPtr;} \n    Paragraph*& ParagraphPtr() {return paragraphPtr;} \n\n```", "```cpp\n  private: \n    TCHAR tChar; \n    Font charFont; \n    Rect charRect; \n    Paragraph* paragraphPtr; \n    LineInfo* lineInfoPtr; \n};\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\"\n#include \"CharInfo.h\"\n```", "```cpp\nCharInfo::CharInfo(Paragraph* paragraphPtr /* = nullptr */, \n                   TCHAR tChar /* = TEXT('\\0') */, \n                   Font font/* = SystemFont */,  \n                   Rect rect /* = ZeroRect */) \n :lineInfoPtr(nullptr), \n  paragraphPtr(paragraphPtr), \n  tChar(tChar), \n  charFont(font), \n  charRect(rect) { \n  // Empty. \n} \n\n```", "```cpp\nCharInfo::CharInfo(const CharInfo& charInfo) \n :lineInfoPtr(charInfo.lineInfoPtr), \n  paragraphPtr(charInfo.paragraphPtr), \n  tChar(charInfo.tChar), \n  charFont(charInfo.charFont), \n  charRect(charInfo.charRect) { \n  // Empty. \n} \n\nCharInfo& CharInfo::operator=(const CharInfo& charInfo) { \n  lineInfoPtr = charInfo.lineInfoPtr; \n  paragraphPtr = charInfo.paragraphPtr; \n  tChar = charInfo.tChar; \n  charFont = charInfo.charFont; \n  charRect = charInfo.charRect; \n  return *this; \n} \n\n```", "```cpp\nbool CharInfo::WriteCharInfoToStream(ostream& outStream) const { \n  outStream.write((char*) &tChar, sizeof tChar); \n  charFont.WriteFontToStream(outStream); \n  charRect.WriteRectToStream(outStream); \n  return ((bool) outStream); \n} \n\nbool CharInfo::ReadCharInfoFromStream(istream& inStream) { \n  inStream.read((char*) &tChar, sizeof tChar); \n  charFont.ReadFontFromStream(inStream); \n  charRect.ReadRectFromStream(inStream); \n  return ((bool) inStream); \n} \n\n```", "```cpp\nvoid CharInfo::WriteCharInfoToClipboard(InfoList& infoList) const{ \n  infoList.AddValue<TCHAR>(tChar); \n  charFont.WriteFontToClipboard(infoList);  \n} \n\nvoid CharInfo::ReadCharInfoFromClipboard(InfoList& infoList) { \n  infoList.GetValue<TCHAR>(tChar); \n  charFont.ReadFontFromClipboard(infoList); \n} \n\n```", "```cpp\nclass LineInfo { \n  public: \n    LineInfo(); \n    LineInfo(int first, int last, int top, \n             int height, int ascent); \n\n    bool WriteLineInfoToStream(ostream& outStream) const; \n    bool ReadLineInfoFromStream(istream& inStream); \n\n```", "```cpp\n    int First() const {return first;} \n    int Last() const {return last;} \n    int Top() const {return top;} \n    int Height() const {return height;} \n    int Ascent() const {return ascent;} \n    int& First() {return first;} \n    int& Last() {return last;} \n    int& Top() {return top;} \n    int& Height() {return height;} \n    int& Ascent() {return ascent;} \n\n```", "```cpp\n  private: \n    int first, last, top, height, ascent; \n};\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\"\n#include \"LineInfo.h\"\n```", "```cpp\nLineInfo::LineInfo() { \n  // Empty. \n} \n\nLineInfo::LineInfo(int first, int last, int top, \n                   int height, int ascent) \n :first(first), \n  last(last), \n  top(top), \n  height(height), \n  ascent(ascent) { \n  // Empty. \n} \n\n```", "```cpp\nbool LineInfo::WriteLineInfoToStream(ostream& outStream) const { \n  outStream.write((char*) &first, sizeof first); \n  outStream.write((char*) &last, sizeof last); \n  outStream.write((char*) &ascent, sizeof ascent); \n  outStream.write((char*) &top, sizeof top); \n  outStream.write((char*) &height, sizeof height); \n  return ((bool) outStream); \n} \n\nbool LineInfo::ReadLineInfoFromStream(istream& inStream) { \n  inStream.read((char*) &first, sizeof first); \n  inStream.read((char*) &last, sizeof last); \n  inStream.read((char*) &ascent, sizeof ascent); \n  inStream.read((char*) &top, sizeof top); \n  inStream.read((char*) &height, sizeof height); \n  return ((bool) inStream); \n} \n\n```", "```cpp\nenum Alignment {Left, Center, Right, Justified}; \nclass WordDocument:\n\nclass Paragraph { \n  public: \n    Paragraph(); \n    Paragraph(int first, int last, \n              Alignment alignment, int index); \n\n    bool WriteParagraphToStream(ostream& outStream) const; \n    bool ReadParagraphFromStream(WordDocument* wordDocumentPtr, \n                                 istream& inStream); \n\n    void WriteParagraphToClipboard(InfoList& infoList) const; \n    void ReadParagraphFromClipboard(InfoList& infoList); \n\n    int& First() {return first;} \n    int& Last() {return last;} \n    int& Top() {return top;} \n    int& Index() {return index;} \n    int& Height() {return height;} \n    bool& PageBreak() {return pageBreak;} \n\n```", "```cpp\n    Alignment& AlignmentField() {return alignment;}\n    DynamicList<LineInfo*>& LinePtrList() {return linePtrList;}\n```", "```cpp\n    int first, last, top, height, index; \n    bool pageBreak; \n\n```", "```cpp\n    Alignment alignment; \n\n```", "```cpp\n    DynamicList<LineInfo*> linePtrList; \n};\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\"\n#include \"CharInfo.h\"\n#include \"LineInfo.h\"\n#include \"Paragraph.h\"\n#include \"WordDocument.h\"\nParagraph::Paragraph() { /* Empty. */ }\nParagraph::Paragraph(int first, int last, Alignment alignment, int index)\n:top(-1), first(first), last(last), index(index), pageBreak(false), alignment(alignment) { /* Empty. */ }\n```", "```cpp\nbool Paragraph::WriteParagraphToStream(ostream& outStream) const { \n  outStream.write((char*) &first, sizeof first); \n  outStream.write((char*) &last, sizeof last); \n  outStream.write((char*) &top, sizeof top); \n  outStream.write((char*) &height, sizeof height); \n  outStream.write((char*) &index, sizeof index); \n  outStream.write((char*) &pageBreak, sizeof pageBreak); \n  outStream.write((char*) &alignment, sizeof alignment); \n\n  { int linePtrListSize = linePtrList.Size(); \n    outStream.write((char*) &linePtrListSize, \n                    sizeof linePtrListSize); \n\n    for (const LineInfo* lineInfoPtr : linePtrList) { \n      lineInfoPtr->WriteLineInfoToStream(outStream); \n    } \n  } \n\n  return ((bool) outStream); \n} \n\nbool Paragraph::ReadParagraphFromStream \n                (WordDocument* wordDocumentPtr, istream& inStream){\n  inStream.read((char*) &first, sizeof first); \n  inStream.read((char*) &last, sizeof last); \n  inStream.read((char*) &top, sizeof top); \n  inStream.read((char*) &height, sizeof height); \n  inStream.read((char*) &index, sizeof index); \n  inStream.read((char*) &pageBreak, sizeof pageBreak); \n  inStream.read((char*) &alignment, sizeof alignment);\n```", "```cpp\n  for (int charIndex = first; charIndex <= last; ++charIndex) {\n    wordDocumentPtr->CharList()[charIndex].ParagraphPtr() = this;\n  }\n\n  { int linePtrListSize = linePtrList.Size(); \n    inStream.read((char*) &linePtrListSize, \n                  sizeof linePtrListSize); \n\n    for (int count = 0; count < linePtrListSize; ++count) { \n      LineInfo* lineInfoPtr = new LineInfo(); \n      assert(lineInfoPtr != nullptr); \n      lineInfoPtr->ReadLineInfoFromStream(inStream); \n      linePtrList.PushBack(lineInfoPtr);\n\n```", "```cpp\n      for (int charIndex = lineInfoPtr->First();\n           charIndex <= lineInfoPtr->Last(); ++charIndex) {\n        wordDocumentPtr->CharList()[first + charIndex].\n          LineInfoPtr() = lineInfoPtr;\n      }\n    }\n  }\n\n  return ((bool) inStream);\n}\n```", "```cpp\nvoid Paragraph::WriteParagraphToClipboard(InfoList& infoList) const { \n  infoList.AddValue<int>(first); \n  infoList.AddValue<int>(last); \n  infoList.AddValue<int>(top); \n  infoList.AddValue<int>(index); \n  infoList.AddValue<bool>(pageBreak); \n  infoList.AddValue<Alignment>(alignment); \n} \n\nvoid Paragraph::ReadParagraphFromClipboard(InfoList& infoList) { \n  infoList.GetValue<int>(first); \n  infoList.GetValue<int>(last); \n  infoList.GetValue<int>(top); \n  infoList.GetValue<int>(index); \n  infoList.GetValue<bool>(pageBreak); \n  infoList.GetValue<Alignment>(alignment); \n} \n\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n#include \"CharInfo.h\" \n#include \"LineInfo.h\" \n#include \"Paragraph.h\" \n#include \"WordDocument.h\" \n\nvoid MainWindow(vector<String> /* argumentList */, \n                WindowShow windowShow) { \n  Application::ApplicationName() = TEXT(\"Word\"); \n  Application::MainWindowPtr() = new WordDocument(windowShow); \n} \n\n```", "```cpp\nclass WordDocument : public StandardDocument { \n  public: \n    WordDocument(WindowShow windowShow); \n\n```", "```cpp\n    void InitDocument(); \n\n```", "```cpp\n    void OnKeyboardMode(KeyboardMode keyboardMode); \n    void UpdateCaret(); \n\n```", "```cpp\n    void OnMouseDown(MouseButton mouseButtons, Point mousePoint, \n                     bool shiftPressed, \n                     bool controlPressed); \n    void OnMouseMove(MouseButton mouseButtons, Point mousePoint, \n                     bool shiftPressed, \n                     bool controlPressed); \n    void OnMouseUp(MouseButton mouseButtons, Point mousePoint, \n                   bool shiftPressed, \n                   bool controlPressed); \n    int MousePointToIndex(Point mousePoint) const; \n    int MousePointToParagraphIndex(Paragraph* paragraphPtr, \n                                   Point mousePoint) const; \n    void InvalidateBlock(int firstIndex, int lastIndex); \n\n```", "```cpp\n    void OnDoubleClick(MouseButton mouseButtons, Point mousePoint, \n                       bool shiftPressed, bool controlPressed); \n    int GetFirstWordIndex(int charIndex) const; \n    int GetLastWordIndex(int charIndex) const; \n\n```", "```cpp\n    void OnTouchDown(vector<Point> pointList); \n    void OnTouchMove(vector<Point> pointList); \n\n```", "```cpp\n    void OnPageSetup(PageSetupInfo pageSetupInfo); \n    void CalculateDocument(); \n\n```", "```cpp\n    void OnPaint(Graphics& graphics) const; \n    void OnDraw(Graphics& graphics, DrawMode drawMode) const; \n\n```", "```cpp\n    void ClearDocument(); \n    bool WriteDocumentToStream(String name, ostream& outStream) \n                               const; \n    bool ReadDocumentFromStream(String name, istream& inStream); \n\n```", "```cpp\n    bool CopyEnable() const; \n    bool IsCopyAsciiReady() const; \n    bool IsCopyUnicodeReady() const; \n    bool IsCopyGenericReady(int format) const; \n\n    void CopyAscii(vector<String>& textList) const; \n    void CopyUnicode(vector<String>& textList) const; \n    void CopyGeneric(int format, InfoList& infoList) const; \n\n```", "```cpp\n    void PasteAscii(const vector<String>& textList); \n    void PasteUnicode(const vector<String>& textList); \n    void PasteGeneric(int format, InfoList& infoList); \n\n```", "```cpp\n    bool DeleteEnable() const; \n    void OnDelete(); \n    void Delete(int firstIndex, int lastIndex); \n\n```", "```cpp\n    DEFINE_BOOL_LISTENER(WordDocument, PageBreakEnable) \n    DEFINE_VOID_LISTENER(WordDocument, OnPageBreak) \n    DEFINE_VOID_LISTENER(WordDocument, OnFont) \n\n```", "```cpp\n    DEFINE_BOOL_LISTENER(WordDocument, LeftRadio) \n    DEFINE_VOID_LISTENER(WordDocument, OnLeft) \n    DEFINE_BOOL_LISTENER(WordDocument, CenterRadio) \n    DEFINE_VOID_LISTENER(WordDocument, OnCenter) \n    DEFINE_BOOL_LISTENER(WordDocument, RightRadio) \n    DEFINE_VOID_LISTENER(WordDocument, OnRight) \n    DEFINE_BOOL_LISTENER(WordDocument, JustifiedRadio) \n    DEFINE_VOID_LISTENER(WordDocument, OnJustified)     \n\n    bool IsAlignment(Alignment alignment) const; \n    void SetAlignment(Alignment alignment); \n\n```", "```cpp\n    void OnChar(TCHAR tChar); \n    void InsertChar(TCHAR tChar, Paragraph* paragraphPtr); \n    void OverwriteChar(TCHAR tChar, Paragraph* paragraphPtr);   \n    void ClearNextFont(); \n\n```", "```cpp\n    bool OnKeyDown(WORD key, bool shiftPressed, \n                   bool controlPressed); \n    void OnRegularKey(WORD key); \n    void EnsureEditStatus(); \n    void OnLeftArrowKey(); \n    void OnRightArrowKey(); \n    void OnUpArrowKey(); \n    void OnDownArrowKey(); \n    int MousePointToIndexDown(Point mousePoint) const; \n    void OnPageUpKey(); \n    void OnPageDownKey(); \n    void OnHomeKey(); \n    void OnEndKey(); \n\n```", "```cpp\n    void OnShiftKey(WORD key); \n    void EnsureMarkStatus(); \n    void OnShiftLeftArrowKey(); \n    void OnShiftRightArrowKey(); \n    void OnShiftUpArrowKey(); \n    void OnShiftDownArrowKey(); \n    void OnShiftPageUpKey(); \n    void OnShiftPageDownKey(); \n    void OnShiftHomeKey(); \n    void OnShiftEndKey(); \n\n```", "```cpp\n    DEFINE_VOID_LISTENER(WordDocument, OnControlHomeKey); \n    DEFINE_VOID_LISTENER(WordDocument, OnControlEndKey); \n    DEFINE_VOID_LISTENER(WordDocument, OnShiftControlHomeKey); \n    DEFINE_VOID_LISTENER(WordDocument, OnShiftControlEndKey); \n\n```", "```cpp\n    void OnNeutralKey(WORD key); \n    void OnReturnKey(); \n    void OnBackspaceKey(); \n\n```", "```cpp\n    void MakeVisible(); \n\n```", "```cpp\n    void GenerateParagraph(Paragraph* paragraphPtr); \n    void GenerateSizeAndAscentList(Paragraph* paragraphPtr, \n                                   DynamicList<Size>& sizeList, \n                                   DynamicList<int>& ascentList); \n    void GenerateLineList(Paragraph* paragraphPtr, \n                          DynamicList<Size>& sizeList, \n                          DynamicList<int>& ascentList); \n\n    void GenerateRegularLineRectList(Paragraph* paragraphPtr, \n                                     LineInfo* lineInfoPtr, \n                                     DynamicList<Size>& sizeList, \n                                     DynamicList<int>&ascentList); \n    void GenerateJustifiedLineRectList(Paragraph* paragraphPtr, \n                                  LineInfo* lineInfoPtr, \n                                  DynamicList<Size>& sizeList, \n                                  DynamicList<int>& ascentList); \n    void InvalidateRepaintSet(Paragraph* paragraphPtr, \n                            DynamicList<CharInfo>& prevRectList);\n    DynamicList<CharInfo>& CharList() {return charList;}\n```", "```cpp\n  private: \n    enum {WordEdit, WordMark} wordMode; \n\n    int totalPages; \n    DynamicList<CharInfo> charList; \n    DynamicList<Paragraph*> paragraphList; \n\n    int editIndex, firstMarkIndex, lastMarkIndex; \n    Font nextFont; \n\n    double initZoom, initDistance;  \n    static const unsigned int WordFormat = 1002; \n};\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\"\n#include \"CharInfo.h\"\n#include \"LineInfo.h\"\n#include \"Paragraph.h\"\n#include \"WordDocument.h\"\n```", "```cpp\nWordDocument::WordDocument(WindowShow windowShow) \n :StandardDocument(LogicalWithScroll, USLetterPortrait, \n                   TEXT(\"Word Files, wrd; Text Files, txt\"), \n                   nullptr, OverlappedWindow, windowShow, \n                   {WordFormat, UnicodeFormat, AsciiFormat}, \n                   {WordFormat, UnicodeFormat, AsciiFormat}) { \n\n```", "```cpp\n  Menu menuBar(this); \n  menuBar.AddMenu(StandardFileMenu(true)); \n  menuBar.AddMenu(StandardEditMenu()); \n\n  Menu formatMenu(this, TEXT(\"F&ormat\")); \n  formatMenu.AddItem(TEXT(\"&Font\\tCtrl+F\"), OnFont); \n  formatMenu.AddItem(TEXT(\"&Page Break\\tCtrl+B\"), \n                     OnPageBreak, PageBreakEnable); \n  menuBar.AddMenu(formatMenu); \n\n```", "```cpp\n  Menu alignmentMenu(this, TEXT(\"&Alignment\")); \n  alignmentMenu.AddItem(TEXT(\"&Left\\tCtrl+L\"), OnLeft, \n                        nullptr, nullptr, LeftRadio); \n  alignmentMenu.AddItem(TEXT(\"&Center\\tCtrl+E\"), OnCenter, \n                        nullptr, nullptr, CenterRadio); \n  alignmentMenu.AddItem(TEXT(\"&Right\\tCtrl+R\"), OnRight, \n                        nullptr, nullptr, RightRadio); \n  alignmentMenu.AddItem(TEXT(\"&Justified\\tCtrl+J\"), OnJustified, \n                        nullptr, nullptr, JustifiedRadio); \n  menuBar.AddMenu(alignmentMenu); \n\n  menuBar.AddMenu(StandardHelpMenu()); \n  SetMenuBar(menuBar); \n\n```", "```cpp\n  Menu extraMenu(this); \n  extraMenu.AddItem(TEXT(\"&A\\tCtrl+Home\"), OnControlHomeKey); \n  extraMenu.AddItem(TEXT(\"&B\\tCtrl+End\"), OnControlEndKey); \n  extraMenu.AddItem(TEXT(\"&C\\tShift+Ctrl+Home\"), \n                    OnShiftControlHomeKey); \n  extraMenu.AddItem(TEXT(\"&D\\tShift+Ctrl+End\"), \n                    OnShiftControlEndKey); \n\n```", "```cpp\n  InitDocument(); \n} \n\n```", "```cpp\nvoid WordDocument::InitDocument() { \n  wordMode = WordEdit; \n  editIndex = 0; \n  Paragraph* firstParagraphPtr = new Paragraph(0, 0, Left, 0); \n  assert(firstParagraphPtr != nullptr); \n  Font font(TEXT(\"Times New Roman\"), 36, false, true); \n  charList.PushBack(CharInfo(firstParagraphPtr, NewLine, font)); \n  GenerateParagraph(firstParagraphPtr); \n  paragraphList.PushBack(firstParagraphPtr); \n  CalculateDocument(); \n  UpdateCaret(); \n} \n\n```", "```cpp\nvoid WordDocument::OnKeyboardMode(KeyboardMode/*=KeyboardMode*/) { \n  UpdateCaret(); \n} \n\nvoid WordDocument::UpdateCaret() { \n  switch (wordMode) { \n    case WordEdit: { \n        CharInfo charInfo = charList[editIndex];\n        Rect caretRect = charList[editIndex].CharRect();\n```", "```cpp\n        if (nextFont != SystemFont) { \n          int width = GetCharacterAverageWidth(nextFont), \n              height = GetCharacterHeight(nextFont); \n          caretRect.Right() = caretRect.Left() + width; \n          caretRect.Top() = caretRect.Bottom() - height; \n        } \n\n```", "```cpp\n        else if ((GetKeyboardMode() == InsertKeyboard) && \n                 (charInfo.ParagraphPtr()->First() < editIndex)) { \n          Rect prevCharRect = charList[editIndex - 1].CharRect(); \n          caretRect.Top() = caretRect.Bottom() – prevCharRect.Height(); \n        }\n\n```", "```cpp\n        if (GetKeyboardMode() == InsertKeyboard) { \n          caretRect.Right() = caretRect.Left() + 1; \n        } \n\n```", "```cpp\n        if (caretRect.Right() >= PageInnerWidth()) { \n          caretRect.Right() = PageInnerWidth() - 1; \n        } \n\n```", "```cpp\n        Paragraph* paragraphPtr = \n          charList[editIndex].ParagraphPtr(); \n        Point topLeft = Point(0, paragraphPtr->Top()); \n        SetCaret(topLeft + caretRect); \n      } \n      break; \n\n```", "```cpp\n    case WordMark: \n      ClearCaret(); \n      break; \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnMouseDown(MouseButton mouseButtons, \n                          Point mousePoint, bool shiftPressed, \n                          bool controlPressed) { \n  if (mouseButtons == LeftButton) { \n    EnsureEditStatus(); \n    ClearNextFont(); \n    wordMode = WordMark; \n    firstMarkIndex = lastMarkIndex = \n      MousePointToIndex(mousePoint); \n    UpdateCaret(); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnMouseMove(MouseButton mouseButtons, \n                          Point mousePoint, bool shiftPressed, \n                          bool controlPressed) { \n  if (mouseButtons == LeftButton) { \n    int newLastMarkIndex = MousePointToIndex(mousePoint); \n\n    if (lastMarkIndex != newLastMarkIndex) { \n      InvalidateBlock(lastMarkIndex, newLastMarkIndex); \n      lastMarkIndex = newLastMarkIndex; \n    } \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnMouseUp(MouseButton mouseButtons, \n                             Point mousePoint, bool shiftPressed, \n                             bool controlPressed) { \n  if (mouseButtons == LeftButton) { \n    if (firstMarkIndex == lastMarkIndex) { \n      wordMode = WordEdit; \n      editIndex = min(firstMarkIndex, charList.Size() - 1); \n      UpdateCaret(); \n    } \n  } \n} \n\n```", "```cpp\nint WordDocument::MousePointToIndex(Point mousePoint) const{ \n  for (int parIndex = 1; parIndex < paragraphList.Size(); \n       ++parIndex) { \n    Paragraph* paragraphPtr = paragraphList[parIndex]; \n\n    if (mousePoint.Y() < paragraphPtr->Top()) { \n      return MousePointToParagraphIndex \n             (paragraphList[parIndex - 1], mousePoint); \n    } \n  } \n\n  return MousePointToParagraphIndex \n         (paragraphList[paragraphList.Size() - 1], mousePoint); \n} \n\n```", "```cpp\nint WordDocument::MousePointToParagraphIndex \n                          (Paragraph* paragraphPtr,Point mousePoint) const{ \n  mousePoint.Y() -= paragraphPtr->Top(); \n\n```", "```cpp\n  if (mousePoint.Y() >= paragraphPtr->Height()) { \n    mousePoint.Y() = paragraphPtr->Height() - 1; \n  } \n\n```", "```cpp\n  int firstChar = paragraphPtr->First();\n  for (LineInfo* lineInfoPtr : paragraphPtr->LinePtrList()) { \n    if (mousePoint.Y() < (lineInfoPtr->Top() + \n                          lineInfoPtr->Height())) { \n      Rect firstRect =\n              charList[firstChar +lineInfoPtr->First()].CharRect(),\n            lastRect =\n              charList[firstChar + lineInfoPtr->Last()].CharRect(); \n\n```", "```cpp\n      if (mousePoint.X() < firstRect.Left()) { \n        return paragraphPtr->First() + lineInfoPtr->First(); \n      } \n      else if (lastRect.Right() <= mousePoint.X()) { \n        return paragraphPtr->First() + lineInfoPtr->Last(); \n      } \n\n```", "```cpp\n      else { \n        for (int charIndex = lineInfoPtr->First(); \n             charIndex <= lineInfoPtr->Last(); ++charIndex) { \n          Rect charRect = charList[charIndex].CharRect(); \n\n          if (mousePoint.X() < charRect.Right()) { \n            int leftSize = mousePoint.X() - charRect.Left(), \n                rightSide = charRect.Right() - mousePoint.X(); \n\n            return paragraphPtr->First() + \n              ((leftSize < rightSide) ? charIndex \n                                      : (charIndex + 1)); \n          } \n        } \n      } \n    } \n  } \n\n```", "```cpp\n  assert(false); \n  return 0; \n} \n\nvoid WordDocument::InvalidateBlock(int firstIndex, int lastIndex){ \n  int minIndex = min(firstIndex, lastIndex), \n      maxIndex = min(max(firstIndex, lastIndex).\n                     charList.Size() - 1); \n\n  for (int charIndex = minIndex; charIndex <= maxIndex; \n       ++charIndex) { \n    CharInfo charInfo = charList[charIndex]; \n    Point topLeft(0, charInfo.ParagraphPtr()->Top()); \n    Invalidate(topLeft + charInfo.CharRect()); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnDoubleClick(MouseButton mouseButtons, \n                     Point mousePoint, bool shiftPressed, \n                     bool controlPressed) { \n  int firstIndex = GetFirstWordIndex(editIndex), \n      lastIndex = GetLastWordIndex(editIndex); \n\n  if (firstIndex < lastIndex) { \n    wordMode = WordMark; \n    firstMarkIndex = firstIndex; \n    lastMarkIndex = lastIndex; \n\n    UpdateCaret(); \n    InvalidateBlock(firstMarkIndex, lastMarkIndex); \n    UpdateWindow(); \n  } \n} \n\n```", "```cpp\nint WordDocument::GetFirstWordIndex(int charIndex) const{ \n  while ((charIndex >= 0) && \n         (isalpha(charList[charIndex].Char()))) { \n    --charIndex; \n  } \n  return (charIndex + 1); \n} \n\n```", "```cpp\nint WordDocument::GetLastWordIndex(int charIndex) const{ \n  while (isalpha(charList[charIndex].Char())) { \n    ++charIndex; \n  } \n  return charIndex; \n} \n\n```", "```cpp\nvoid WordDocument::OnTouchDown(vector<Point> pointList) { \n  if (pointList.size() == 2) { \n    initZoom = GetZoom(); \n    Point firstInitPoint = pointList[0], \n          secondInitPoint = pointList[1]; \n    double width = firstInitPoint.X() - secondInitPoint.X(), \n           height = firstInitPoint.Y() - secondInitPoint.Y(), \n    initDistance = sqrt((width * width) + (height * height)); \n  } \n  else { \n    Window::OnTouchDown(pointList); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnTouchMove(vector<Point> pointList) { \n  if (pointList.size() == 2) { \n    Point firstPoint = pointList[0], secondPoint = pointList[1]; \n\n    int width = firstPoint.X() - secondPoint.X(), \n        height = firstPoint.Y() - secondPoint.Y(); \n    double distance = sqrt((width * width) + (height * height)); \n\n    double factor = distance / initDistance; \n    double newZoom = factor * initZoom; \n    SetZoom(min(max(newZoom, 0.1), 10.0)); \n\n    UpdateCaret(); \n    Invalidate(); \n    UpdateWindow(); \n  } \n  else { \n    Window::OnTouchMove(pointList); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnPageSetup(PageSetupInfo pageSetupInfo) { \n  ClearNextFont(); \n\n  for (Paragraph* paragraphPtr : paragraphList) { \n    GenerateParagraph(paragraphPtr); \n  } \n\n  CalculateDocument(); \n  UpdateCaret(); \n  UpdateWindow(); \n} \n\n```", "```cpp\nvoid WordDocument::CalculateDocument() { \n  int pageInnerWidth = PageInnerWidth(), \n      pageInnerHeight = PageInnerHeight(), \n      documentHeight = 0, newTotalPages = 1; \n\n```", "```cpp\n  for (int parIndex = 0; parIndex < paragraphList.Size(); \n       ++parIndex) { \n    Paragraph* paragraphPtr = paragraphList[parIndex]; \n\n    if (paragraphPtr->Top() != documentHeight) { \n      paragraphPtr->Top() = documentHeight; \n      Invalidate(Rect(0, paragraphPtr->Top(), pageInnerWidth, \n                 paragraphPtr->Top() + paragraphPtr->Height())); \n    } \n\n```", "```cpp\n    bool pageBreak = paragraphPtr->PageBreak() && \n                     ((paragraphPtr->Top() % pageInnerHeight) != 0); \n\n```", "```cpp\n    bool notFitOnPage = \n      (documentHeight > 0) &&\n      ((paragraphPtr->Top() + paragraphPtr->Height()) > \n      (newTotalPages * pageInnerHeight)); \n\n```", "```cpp\n    if (pageBreak || notFitOnPage) { \n      Rect restOfPage(0, documentHeight, pageInnerWidth, \n                      newTotalPages * pageInnerHeight); \n      Invalidate(restOfPage); \n      paragraphPtr->Top() = (newTotalPages++) * pageInnerHeight;\n```", "```cpp\n      Invalidate(Rect(0, paragraphPtr->Top(), pageInnerWidth,\n                 paragraphPtr->Top() + paragraphPtr->Height()));\n      documentHeight = paragraphPtr->Top() + \n                       paragraphPtr->Height(); \n    } \n\n```", "```cpp\n    else { \n      documentHeight += paragraphPtr->Height(); \n    } \n  } \n\n```", "```cpp\n  Rect restOfPage(0, documentHeight, pageInnerWidth, \n                  newTotalPages * pageInnerHeight); \n  Invalidate(restOfPage); \n\n```", "```cpp\n  if (totalPages != newTotalPages) { \n    int minTotalPages = min(totalPages, newTotalPages), \n        maxTotalPages = max(totalPages, newTotalPages); \n    Invalidate(Rect(0, minTotalPages * pageInnerHeight, \n                    pageInnerWidth, maxTotalPages * pageInnerHeight));     \n    totalPages = newTotalPages; \n    SetVerticalScrollTotalHeight(totalPages * pageInnerHeight);\n  }\n} \n\n```", "```cpp\nvoid WordDocument::OnPaint(Graphics& graphics) const { \n  int pageInnerWidth = PageInnerWidth(), \n      pageInnerHeight = PageInnerHeight(); \n\n  int documentInnerHeight = totalPages * pageInnerHeight; \n  Size clientSize = GetClientSize(); \n\n  if (pageInnerWidth() < clientSize.Width()) {\n    int maxHeight = max(documentInnerHeight, clientSize.Height());\n    Rect rightRect(pageInnerWidth, 0,\n                   clientSize.Width(), maxHeight);\n    graphics.FillRectangle(rightRect, LightGray, LightGray); \n  } \n\n  if (documentInnerHeight() < clientSize.Height()) { \n    Rect bottomRect(0, documentInnerHeight(), \n                    pageInnerWidth(), clientSize.Height()); \n    graphics.FillRectangle(bottomRect, LightGray, LightGray); \n  } \n\n  OnDraw(graphics, Paint);\n\n  int breakWidth = min(clientSize.Width()), \n      breakHeight = GetCharacterHeight(SystemFont); \n  Size breakSize(breakWidth, breakHeight); \n\n  for (int pageIndex = 1; pageIndex < totalPages; ++pageIndex) { \n    int line = pageIndex * pageInnerHeight; \n    graphics.DrawLine(Point(0, line), Point(pageInnerWidth, line), \n                      Black); \n\n    Point topLeft(0, line - (breakHeight / 2)); \n    graphics.DrawText(Rect(topLeft, breakSize), \n                      TEXT(\"Page Break\"), SystemFont,Black,White); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::OnDraw(Graphics& graphics, DrawMode drawMode) const { \n  minCharIndex = min(firstMarkIndex, lastMarkIndex), \n  maxCharIndex = max(firstMarkIndex, lastMarkIndex); \n\n  for (int charIndex = 0; charIndex <= charList.Size() - 1; \n       ++charIndex) { \n    CharInfo charInfo = charList[charIndex]; \n    Point topLeft(0, charInfo.ParagraphPtr()->Top()); \n\n    Color textColor = charInfo.CharFont().GetColor(); \n    Color backColor = textColor.Inverse(); \n\n```", "```cpp\n    if ((wordMode == WordMark) && \n        (minCharIndex <= charIndex)&&(charIndex < maxCharIndex)) { \n      swap(textColor, backColor); \n    } \n\n```", "```cpp\n    TCHAR tChar = (charInfo.Char() == NewLine)\n                  ? Space: charInfo.Char(); \n    TCHAR text[] = {tChar, TEXT('\\0')}; \n\n```", "```cpp\n    Rect charRect = charList[charIndex].CharRect(); \n    if (charRect.Right() >= pageWidth) { \n      charRect.Right() = pageWidth - 1; \n    } \n\n```", "```cpp\n    graphics.DrawText(topLeft + charRect, text, \n                      charInfo.CharFont(), textColor, backColor); \n  } \n\n```", "```cpp\n  if (drawMode == Paint) { \n    for (Paragraph* paragraphPtr : paragraphList) { \n      if (paragraphPtr->PageBreak()) { \n        Point topLeft(0, paragraphPtr->Top()); \n        graphics.FillRectangle(Rect(topLeft, topLeft + \n                                    Size(200, 200)), Red, Red); \n      } \n    } \n  } \n} \n\n```", "```cpp\nvoid DeleteParagraph(Paragraph* paragraphPtr) { \n  for (LineInfo* lineInfoPtr : paragraphPtr->LinePtrList()) { \n    delete lineInfoPtr; \n  } \n\n  delete paragraphPtr; \n} \n\nvoid WordDocument::ClearDocument() { \n  nextFont = SystemFont; \n\n  for (Paragraph* paragraphPtr : paragraphList) { \n    DeleteParagraph(paragraphPtr); \n  } \n\n  charList.Clear(); \n  paragraphList.Clear(); \n  InitDocument(); \n} \n\n```", "```cpp\nbool WordDocument::WriteDocumentToStream(String name, \n                                         ostream& outStream)const{ \n  if (EndsWith(name, TEXT(\".wrd\")) && \n      WritePageSetupInfoToStream(outStream)){ \n    outStream.write((char*) &wordMode, sizeof wordMode); \n    outStream.write((char*) &editIndex, sizeof editIndex); \n\n    outStream.write((char*) &firstMarkIndex, \n                    sizeof firstMarkIndex); \n    outStream.write((char*) &lastMarkIndex, sizeof lastMarkIndex); \n    outStream.write((char*) &totalPages, sizeof totalPages); \n    nextFont.WriteFontToStream(outStream); \n\n    { int charInfoListSize = charList.Size(); \n      outStream.write((char*) &charInfoListSize, \n                      sizeof charInfoListSize); \n      for (CharInfo charInfo : charList) { \n        charInfo.WriteCharInfoToStream(outStream); \n      } \n    } \n\n    { int paragraphListSize = paragraphList.Size(); \n      outStream.write((char*) &paragraphListSize, \n                      sizeof paragraphListSize); \n\n      for (const Paragraph* paragraphPtr : paragraphList) { \n        paragraphPtr->WriteParagraphToStream(outStream); \n      } \n    } \n  } \n\n```", "```cpp\n  else if (EndsWith(name, TEXT(\".txt\"))) { \n    for (CharInfo charInfo : charList) { \n      char c = (char) charInfo.Char(); \n      outStream.write(&c, sizeof c); \n    } \n  } \n\n  return ((bool) outStream); \n} \n\n```", "```cpp\nbool WordDocument::ReadDocumentFromStream(String name, \n                                          istream& inStream) { \n  if (EndsWith(name, TEXT(\".wrd\")) && \n      ReadPageSetupInfoFromStream(inStream)){ \n    inStream.read((char*) &wordMode, sizeof wordMode); \n    inStream.read((char*) &editIndex, sizeof editIndex); \n    inStream.read((char*) &firstMarkIndex, sizeof firstMarkIndex); \n    inStream.read((char*) &lastMarkIndex, sizeof lastMarkIndex); \n    inStream.read((char*) &totalPages, sizeof totalPages); \n    nextFont.ReadFontFromStream(inStream); \n\n    { charList.Clear(); \n      int charInfoListSize; \n      inStream.read((char*) &charInfoListSize, \n                    sizeof charInfoListSize); \n\n      for (int count = 0; count < charInfoListSize; ++count) { \n        CharInfo charInfo; \n        charInfo.ReadCharInfoFromStream(inStream); \n        charList.PushBack(charInfo); \n      } \n    } \n\n    { paragraphList.Clear(); \n      int paragraphListSize; \n      inStream.read((char*) &paragraphListSize, \n                    sizeof paragraphListSize); \n\n      for (int count = 0; count < paragraphListSize; ++count) { \n        Paragraph* paragraphPtr = new Paragraph(); \n        assert(paragraphPtr != nullptr); \n        paragraphPtr->ReadParagraphFromStream(this, inStream); \n        paragraphList.PushBack(paragraphPtr); \n      } \n    } \n  } \n\n```", "```cpp\n  else if (EndsWith(name, TEXT(\".txt\"))) { \n    wordMode = WordEdit; \n    editIndex = 0; \n    firstMarkIndex = 0; \n    lastMarkIndex = 0; \n    totalPages = 0; \n    nextFont = SystemFont; \n\n    Paragraph* paragraphPtr = new Paragraph(0, 0, Left, 0); \n    int charIndex = 0, paragraphIndex = 0; \n    char c; \n\n    while (inStream >> c) { \n      CharInfo charInfo(paragraphPtr, (TCHAR) c, \n                        SystemFont, ZeroRect); \n      charList.PushBack(charInfo); \n\n      if (c == '\\n') { \n        paragraphPtr->Last() = charIndex;\n        for (int index = paragraphPtr->First();\n             index <= paragraphPtr->Last(); ++index) {\n          charList[index].ParagraphPtr() = paragraphPtr;\n        }\n\n        GenerateParagraph(paragraphPtr);\n        paragraphList.PushBack(paragraphPtr); \n        Paragraph* paragraphPtr = \n          new Paragraph(charIndex + 1, 0, Left, ++paragraphIndex); \n      } \n\n      ++charIndex; \n    } \n\n    paragraphPtr->Last() = charIndex;\n    for (int index = paragraphPtr->First();\n         index <= paragraphPtr->Last(); ++index) {\n      charList[index].ParagraphPtr() = paragraphPtr;\n    }\n\n    GenerateParagraph(paragraphPtr); \n    paragraphList.PushBack(paragraphPtr); \n    CalculateDocument(); \n  } \n\n  MakeVisible(); \n  return ((bool) inStream); \n} \n\n```", "```cpp\nbool WordDocument::CopyEnable() const { \n  return (wordMode == WordMark); \n} \n\n```", "```cpp\nbool WordDocument::IsCopyAsciiReady() const { \n  return true; \n} \n\nbool WordDocument::IsCopyUnicodeReady() const { \n  return true; \n} \n\nbool WordDocument::IsCopyGenericReady(int /* format */) const { \n  return true; \n} \n\n```", "```cpp\nvoid WordDocument::CopyAscii(vector<String>& textList) { \n  CopyUnicode(textList); \n} \n\nvoid WordDocument::CopyUnicode(vector<String>& textList) { \n  int minCharIndex = min(firstMarkIndex, lastMarkIndex), \n      maxCharIndex = max(firstMarkIndex, lastMarkIndex); \n\n  String text; \n  for (int charIndex = minCharIndex; charIndex < maxCharIndex; \n       ++charIndex) { \n    CharInfo charInfo = charList[charIndex]; \n    text.push_back(charInfo.Char()); \n\n    if (charInfo.Char() == NewLine) { \n      textList.push_back(text); \n      text.clear(); \n    } \n  } \n\n  textList.push_back(text); \n} \n\n```", "```cpp\nvoid WordDocument::CopyGeneric(int /* format */, \n                               InfoList& infoList) const { \n  int minCharIndex = min(firstMarkIndex, lastMarkIndex), \n      maxCharIndex = max(firstMarkIndex, lastMarkIndex); \n  int copySize = maxCharIndex - minCharIndex; \n  infoList.AddValue<int>(copySize); \n\n  for (int charIndex = minCharIndex; charIndex < maxCharIndex; \n       ++charIndex) { \n    CharInfo charInfo = charList[charIndex]; \n    charInfo.WriteCharInfoToClipboard(infoList); \n  } \n} \n\n```", "```cpp\nvoid WordDocument::PasteUnicode(const vector<String>& textList) { \n  if (wordMode == WordMark) { \n    Delete(firstMarkIndex, lastMarkIndex); \n    EnsureEditStatus(); \n  } \n\n  else { \n    ClearNextFont(); \n  } \n\n```", "```cpp\n  Paragraph* paragraphPtr = charList[editIndex].ParagraphPtr(); \n  paragraphList.Erase(paragraphPtr->Index()); \n\n```", "```cpp\n  Alignment alignment = paragraphPtr->AlignmentField(); \n  Font font = charList[editIndex].CharFont(); \n\n```", "```cpp\n  int restChars = paragraphPtr->Last() - editIndex, \n      prevEditIndex = editIndex, textListSize = textList.size(); \n\n```", "```cpp\n  for (int textIndex = 0; textIndex < textListSize; ++textIndex) { \n    for (TCHAR tChar : textList[textIndex]) { \n      charList.Insert(editIndex++, \n                      CharInfo(paragraphPtr, tChar, font)); \n    } \n\n```", "```cpp\n    if (textIndex < (textListSize - 1)) { \n      charList.Insert(editIndex++, \n                      CharInfo(paragraphPtr, NewLine)); \n      paragraphPtr->Last() = editIndex - 1;\n      for (int index = paragraphPtr->First();\n           index <= paragraphPtr->Last(); ++index) {\n        charList[index].ParagraphPtr() = paragraphPtr;\n      }\n\n      GenerateParagraph(paragraphPtr); \n      paragraphList.Insert(paragraphPtr->Index(), paragraphPtr); \n      paragraphPtr = new Paragraph(editIndex, 0, alignment, \n                                   paragraphPtr->Index() + 1); \n    } \n\n```", "```cpp\n    else { \n      paragraphPtr->Last() = editIndex + restChars;\n      for (int index = paragraphPtr->First();\n           index <= paragraphPtr->Last(); ++index) {\n        charList[index].ParagraphPtr() = paragraphPtr;\n      }\n\n      GenerateParagraph(paragraphPtr); \n      paragraphList.Insert(paragraphPtr->Index(), paragraphPtr); \n    } \n  } \n\n```", "```cpp\n  int totalAddedChars = editIndex - prevEditIndex; \n  for (int parIndex = paragraphPtr->Index() + 1; \n       parIndex < paragraphList.Size(); ++parIndex) { \n    Paragraph* paragraphPtr = paragraphList[parIndex]; \n    paragraphPtr->Index() = parIndex; \n    paragraphPtr->First() += totalAddedChars; \n    paragraphPtr->Last() += totalAddedChars; \n  } \n\n  CalculateDocument(); \n  UpdateCaret(); \n  UpdateWindow(); \n} \n\n```", "```cpp\nvoid WordDocument::PasteGeneric(int /* format */, \n                                InfoList& infoList) { \n  if (wordMode == WordMark) { \n    Delete(firstMarkIndex, lastMarkIndex); \n    EnsureEditStatus(); \n  } \n  else { \n    ClearNextFont(); \n  } \n\n```", "```cpp\n  Paragraph* paragraphPtr = charList[editIndex].ParagraphPtr(); \n  paragraphList.Erase(paragraphPtr->Index()); \n  Alignment alignment = paragraphPtr->AlignmentField(); \n\n```", "```cpp\n  int pasteSize, restChars = paragraphPtr->Last() - editIndex; \n  infoList.GetValue<int>(pasteSize); \n\n```", "```cpp\n  for (int pasteCount = 0; pasteCount < pasteSize; ++pasteCount) { \n    CharInfo charInfo(paragraphPtr); \n    charInfo.ReadCharInfoFromClipboard(infoList); \n    charList.Insert(editIndex++, charInfo); \n\n    if (charInfo.Char() == NewLine) { \n      paragraphPtr->Last() = editIndex - 1; \n      GenerateParagraph(paragraphPtr); \n      paragraphList.Insert(paragraphPtr->Index(), paragraphPtr); \n      paragraphPtr = new Paragraph(editIndex, 0, alignment, \n                                   paragraphPtr->Index() + 1); \n      assert(paragraphPtr != nullptr); \n    } \n  } \n\n  paragraphPtr->Last() = editIndex + restChars; \n  for (int charIndex = editIndex; \n       charIndex <= paragraphPtr->Last(); ++charIndex) { \n    charList[charIndex].ParagraphPtr() = paragraphPtr; \n  } \n\n```", "```cpp\n  GenerateParagraph(paragraphPtr); \n  paragraphList.Insert(paragraphPtr->Index(), paragraphPtr); \n\n```", "```cpp\n  for (int parIndex = paragraphPtr->Index() + 1; \n    parIndex < paragraphList.Size(); ++parIndex) { \n    Paragraph* paragraphPtr = paragraphList[parIndex]; \n    paragraphPtr->Index() = parIndex; \n    paragraphPtr->First() += pasteSize; \n    paragraphPtr->Last() += pasteSize; \n  } \n\n  CalculateDocument(); \n  UpdateCaret(); \n  UpdateWindow(); \n} \n\n```", "```cpp\nbool WordDocument::DeleteEnable() const { \n  switch (wordMode) { \n    case WordEdit: \n      return (editIndex < (charList.Size() - 1)); \n\n    case WordMark: \n      return true; \n  } \n\n  return false; \n} \n\n```", "```cpp\nvoid WordDocument::OnDelete() { \n  switch (wordMode) { \n    case WordEdit: \n      ClearNextFont(); \n      Delete(editIndex, editIndex + 1); \n      break; \n\n    case WordMark: \n      Delete(firstMarkIndex, lastMarkIndex); \n      editIndex = min(firstMarkIndex, lastMarkIndex); \n      wordMode = WordEdit; \n      break; \n  } \n\n  SetDirty(true); \n  CalculateDocument(); \n  UpdateCaret(); \n  UpdateWindow(); \n} \n\n```", "```cpp\nvoid WordDocument::Delete(int firstIndex, int lastIndex) { \n  int minCharIndex = min(firstIndex, lastIndex), \n      maxCharIndex = max(firstIndex, lastIndex); \n\n  Paragraph* minParagraphPtr = \n    charList[minCharIndex].ParagraphPtr(); \n  Paragraph* maxParagraphPtr = \n    charList[maxCharIndex].ParagraphPtr(); \n\n```", "```cpp\n  if (minParagraphPtr != maxParagraphPtr) {\n    for (int charIndex = maxParagraphPtr->First();\n         charIndex <= maxParagraphPtr->Last(); ++charIndex) {\n      CharInfo& charInfo = charList[charIndex];\n      charInfo.ParagraphPtr() = minParagraphPtr;\n      charInfo.CharRect() = ZeroRect;\n    }\n  }\n```", "```cpp\n  int deleteChars = maxCharIndex - minCharIndex; \n  minParagraphPtr->Last() = maxParagraphPtr->Last() - deleteChars;\n  charList.Remove(minCharIndex, maxCharIndex - 1);\n  GenerateParagraph(minParagraphPtr);\n```", "```cpp\n  int minParIndex = minParagraphPtr->Index(), \n      maxParIndex = maxParagraphPtr->Index(); \n\n  if (minParIndex < maxParIndex) {\n    for (int parIndex = minParIndex + 1; \n         parIndex <= maxParIndex; ++parIndex) { \n      DeleteParagraph(paragraphList[parIndex]); \n    } \n    paragraphList.Remove(minParIndex + 1, maxParIndex); \n  }\n\n```", "```cpp\n  int deleteParagraphs = maxParIndex - minParIndex;\n  for (int parIndex = minParagraphPtr->Index() + 1; \n       parIndex < paragraphList.Size(); ++parIndex) { \n    Paragraph* paragraphPtr = paragraphList[parIndex];\n    paragraphPtr->Index() -= deleteParagraphs;\n    paragraphPtr->First() -= deleteChars; \n    paragraphPtr->Last() -= deleteChars; \n  } \n\n```", "```cpp\n  wordMode = WordEdit; \n  editIndex = minCharIndex;\n} \n\n```", "```cpp\nbool WordDocument::PageBreakEnable() const { \n  return (wordMode == WordEdit); \n} \n\nvoid WordDocument::OnPageBreak() { \n  Paragraph* paragraphPtr = charList[editIndex].ParagraphPtr(); \n  paragraphPtr->PageBreak() = !paragraphPtr->PageBreak(); \n  CalculateDocument(); \n  UpdateCaret(); \n} \n\n```", "```cpp\nvoid WordDocument::OnFont() { \n  switch (wordMode) { \n    case WordEdit: { \n        Font font; \n\n        if (nextFont != SystemFont) { \n          font = nextFont; \n        } \n        else if (editIndex == \n                 charList[editIndex].ParagraphPtr()->First()) { \n          font = charList[editIndex].CharFont(); \n        } \n        else { \n          font = charList[editIndex - 1].CharFont(); \n        } \n\n```", "```cpp\n        if (StandardDialog::FontDialog(this, font)) { \n          nextFont = font; \n          Paragraph* paragraphPtr = \n            charList[editIndex].ParagraphPtr(); \n          GenerateParagraph(paragraphPtr); \n          SetDirty(true); \n          CalculateDocument(); \n          UpdateCaret(); \n          UpdateWindow(); \n        } \n      } \n      break; \n\n```", "```cpp\n    case WordMark: { \n        int minCharIndex = min(firstMarkIndex, lastMarkIndex), \n            maxCharIndex = max(firstMarkIndex, lastMarkIndex); \n        Font font = charList[minCharIndex].CharFont(); \n\n```", "```cpp\n        if (StandardDialog::FontDialog(this, font)) { \n          for (int charIndex = minCharIndex; \n               charIndex < maxCharIndex; ++charIndex) { \n            charList[charIndex].CharFont() = font; \n          } \n\n          int minParIndex = \n                charList[minCharIndex].ParagraphPtr()->Index(), \n              maxParIndex = \n                charList[maxCharIndex].ParagraphPtr()->Index(); \n\n          for (int parIndex = minParIndex; \n               parIndex <= maxParIndex; ++parIndex) { \n            Paragraph* paragraphPtr = paragraphList[parIndex]; \n            GenerateParagraph(paragraphPtr); \n          } \n\n          SetDirty(true); \n          CalculateDocument(); \n          UpdateCaret(); \n          UpdateWindow(); \n        } \n      } \n      break; \n  } \n} \n\n```", "```cpp\nbool WordDocument::LeftRadio() const { \n  return IsAlignment(Left); \n} \n\nvoid WordDocument::OnLeft() { \n  SetAlignment(Left); \n} \n\nbool WordDocument::CenterRadio() const { \n  return IsAlignment(Center); \n} \n\nvoid WordDocument::OnCenter() { \n  SetAlignment(Center); \n} \n\nbool WordDocument::RightRadio() const { \n  return IsAlignment(Right); \n} \n\nvoid WordDocument::OnRight() { \n  SetAlignment(Right); \n} \n\nbool WordDocument::JustifiedRadio() const { \n  return IsAlignment(Justified); \n} \n\nvoid WordDocument::OnJustified() { \n  SetAlignment(Justified); \n} \n\n```", "```cpp\nbool WordDocument::IsAlignment(Alignment alignment) const { \n  switch (wordMode) { \n    case WordEdit: { \n        Alignment editAlignment = \n          charList[editIndex].ParagraphPtr()->AlignmentField(); \n        return (editAlignment == alignment); \n      } \n\n    case WordMark: { \n        int minCharIndex = min(firstMarkIndex, lastMarkIndex), \n            maxCharIndex = max(firstMarkIndex, lastMarkIndex); \n\n        int minParIndex = \n              charList[minCharIndex].ParagraphPtr()->Index(), \n            maxParIndex = \n              charList[maxCharIndex].ParagraphPtr()->Index(); \n\n        for (int parIndex = minParIndex; parIndex < maxParIndex; \n             ++parIndex) { \n          Alignment markAlignment = \n            paragraphList[parIndex]->AlignmentField(); \n\n          if (markAlignment != alignment) { \n            return false; \n          } \n        } \n\n        return true; \n      } \n  } \n\n  assert(false); \n  return false; \n} \n\n```", "```cpp\nvoid WordDocument::SetAlignment(Alignment alignment) { \n  switch (wordMode) { \n    case WordEdit: { \n        Paragraph* paragraphPtr = \n          charList[editIndex].ParagraphPtr(); \n        paragraphPtr->AlignmentField() = alignment; \n        GenerateParagraph(paragraphPtr); \n        UpdateCaret(); \n      } \n      break; \n\n    case WordMark: { \n        int minCharIndex = min(firstMarkIndex, lastMarkIndex), \n            maxCharIndex = max(firstMarkIndex, lastMarkIndex); \n\n        int minParIndex = \n              charList[minCharIndex].ParagraphPtr()->Index(), \n            maxParIndex = \n              charList[maxCharIndex].ParagraphPtr()->Index(); \n\n        for (int parIndex = minParIndex; parIndex < maxParIndex; \n             ++parIndex) { \n          Paragraph* paragraphPtr = paragraphList[parIndex]; \n          paragraphPtr->AlignmentField() = alignment; \n          GenerateParagraph(paragraphPtr); \n        } \n      } \n      break; \n  } \n\n  UpdateWindow(); \n} \n\n```"]