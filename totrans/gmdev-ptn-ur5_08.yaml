- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Design Patterns – Singleton, Command, and State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whereas the previous chapter looked at a methodology of code architecture design,
    this chapter will look at three design patterns you can build yourself that have
    applications across many game genres.
  prefs: []
  type: TYPE_NORMAL
- en: 'The patterns being covered are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton pattern – understanding why it’s a Pandora’s box that often gets overused
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command pattern – how it has many uses beyond the obvious
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The many levels of state machine traveling down the rabbit hole and seeing how
    far we can push its concept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aim of this will be to make some base classes that can be imported into
    any future project to speed up development. By the end of the chapter, you should
    understand why so many online resources overuse the Singleton pattern, what a
    hidden gem the Command pattern is, and how deep customization can go with the
    humble state machine.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will be building on the `chapter8` branch on GitHub, which can
    be downloaded from [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter08](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter08)
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Singleton pattern – understanding why it’s a Pandora’s box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official point of the Singleton pattern is to ensure there is only one
    instance of a class in existence at any one time, hence the name “single”-ton.
    Unfortunately, this often gets packaged and confused with a public static variable
    to this one existing object. The actual idea of only having one object instance
    of a class makes sense. You might have a manager that needs to exist in every
    level, but if you don’t know the path the player took to get to this level, then
    you have no idea if one has been spawned yet. The solution is to make the manager
    a Singleton class and have a copy at every level. We can do this with the following
    code, using a static variable pointing to the one that exists:'
  prefs: []
  type: TYPE_NORMAL
- en: Example Singleton.h excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We then have a choice on whether we delete the new one if it is a second or
    if it should assume the position of the instance, deleting what was previously
    there . The body file therefore would be:'
  prefs: []
  type: TYPE_NORMAL
- en: Example Singleton.cpp excerpt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an innate question arising from this. Internally, our monologue could
    sound like: “If only one instance of this class will ever exist, then why does
    it need to be instanced in the first place? Surely, making the entire class static
    has the same effect and will take up less memory with the functions and variables
    only existing on the stack, negating the need for a Singleton pattern.” You could
    answer that with a situation. Perhaps there is a need to replace the object in
    the instance slot with every new level. That is one argument for a Singleton pattern,
    but the usage is limited and can usually be designed around using the pattern
    we discussed at great length in [*Chapter 7*](B18297_07.xhtml#_idTextAnchor090).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other issue is that most implementations of the Singleton pattern use a
    public static variable for tracking the instance. This has led many people to
    think the purpose of this pattern is for an easy communication link between a
    top-level system and any object that needs it. Doing this potentially couples
    every class with the Singleton pattern, which we have established in previous
    chapters is a thing to be avoided. The effect can be seen clearly in *Figure 8**.1*,
    where every class aggregates the **Singleton** class into its memory footprint
    because it has one or more references within:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.1 – UML\uFEFF diagram of a Singleton pattern being aggregated into\
    \ lots of classes](img/Figure_08.01_B18297.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – UML diagram of a Singleton pattern being aggregated into lots of
    classes
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct usage is a private static variable used to track the instance,
    as shown at the start of this section. Then, with the instance created by a manager,
    it fits into the hierarchical class tree shown in [*Chapter 7*](B18297_07.xhtml#_idTextAnchor090).
    This manager can then distribute the direct reference to any classes under it
    via the initialization chain. This is what we know as **dependency injection**.
    This does still create coupling, but the spread is much more controlled. An example
    custom initializer function for a unit in a grid-based game could have the dependency
    of the grid injected into it instead of making the grid a Singleton pattern that
    anything can access. Next, you can see an example of how this could be constructed
    and how little this method impacts the flow of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Overall, the actual concept and code for the Singleton pattern is relatively
    simple; the problem lies in how it is used. Even with the cleaner implementation,
    most – if not all – cases where a Singleton pattern has been used can be replaced
    with a different pattern to make the code easier to expand. Aggregation may mean
    that this functionality can become a component, or there may need to be a shift
    in the structure to something more like a subclass sandbox pattern (to be discussed
    later, in [*Chapter 9*](B18297_09.xhtml#_idTextAnchor130)) where the functionality
    is statically defined in a parent. Dependency injection takes most of the replacement
    duty, as the common use for a Singleton pattern will be a global utility class
    such as a **Fog of War** manager on a tiled grid. This is better sent through
    the initialization chain as a dependency injection so that other classes don’t
    also have access allowing other developers to incorrectly use the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the temptation of the Singleton pattern has been expunged from our
    minds, we can move on to patterns that are useful in multiple scenarios, such
    as the Command pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Command pattern for different use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Command pattern adds a layer of separation between the request for an action
    and that action being carried out. The implementation looks like what is shown
    in *Figure 8**.2*, where the `Command` class parent is abstract and only has a
    constructor, `execute()`, and `undo()` functions that all take no arguments. The
    idea is that the child classes are more specific and contain all the object references
    needed to execute properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – UML diagram showing the structure of a Command pattern base
    class](img/Figure_08.02_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – UML diagram showing the structure of a Command pattern base class
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of a command is to reify the abstract idea of an action so that
    we can store it in a list. This list can have many uses, but the most identified
    is the undo queue that Microsoft made synonymous with its keyboard shortcut, *Ctrl*
    + *Z*. When an action is performed, a Command object of the relevant type is created
    and added to the list. The command is executed and left in this list until it
    falls off the back; this keeps the list in chronological order. If the user presses
    the undo key, then the last command in the list has its undo function called,
    and a pointer for the most recent command moves back one. This is shown in *Figure
    8**.3,* where you can see that creating a new command after some have been undone
    chops the undone commands off and inserts the new command as the head of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Diagram showing the process of adding, undoing, and branching
    commands](img/Figure_08.03_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Diagram showing the process of adding, undoing, and branching commands
  prefs: []
  type: TYPE_NORMAL
- en: In games, we can use this functionality for a plethora of different scenarios.
    The most common are strategy games, where the player can queue up actions for
    their units to be executed in a certain order, each only executing after the last
    has finished. Surprisingly few strategy games make use of the Command pattern’s
    undo capabilities, but that may be because it would reduce the cost of actions.
    Undo is making more of an appearance in modern games in the form of a rewind mechanic;
    exploited in classics such as *Braid* and incorporated as a feature into AAA games
    such as the *Forza Horizon* series. This real-time application has varying methods
    of execution; it is likely that *Braid* simply records all moving objects’ positions
    on a timer as there is so little going on in the scene. This approach clearly
    wouldn’t work for a racing game with complex physics; instead, you could record
    each time the player’s input changes as a different command. The undo queue then
    has to run the game backward and understand when commands were added to the list
    to preserve momentum.
  prefs: []
  type: TYPE_NORMAL
- en: Saving each of the players’ input actions into a list can also work as a sort
    of replay-saving mechanic. This works for games such as the *Trials* series and
    fighting games such as *Super Smash Bros.* because there are no elements of randomness
    in the mechanics. If you input the same action at the same time, you will have
    the same result every time. This could lead to large replay files, with each input
    axis saving potentially a value every frame. There are potential ways around this,
    such as only saving the result of these inputs when an action is performed that
    relies on the state of the driven element. This could mean instead of saving every
    mouse movement in *World of Tanks*, the barrel rotation and time are saved every
    time a shell is fired and the barrel is hit. This way, all the little motions
    that add to zero are ignored from the replay file.
  prefs: []
  type: TYPE_NORMAL
- en: Command pattern for undo functionality in Blueprint Utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Unreal, we can make tools to use in the editor called **Blueprint Utilities**
    (formerly known as Blutilities during early development). Blueprint Utilities
    can be created as either right-click menu actions or as Utility Widgets that operate
    in a floating window or can be docked into the UI and can manipulate assets (the
    files in the content browser) or actors (elements within the world) to complete
    repeated actions, to reduce the impact of workflow steps or simply to remove the
    requirement for user input to reduce opportunities for mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Editor Utilities can hold any number of tools within them, with each tool being
    created as its own function, having its own graph or a custom event within the
    standard Blueprint Event Graph. Actor and Asset Utility Widgets require us to
    define which class of actor or asset the tools will interact with, known as the
    *Supported Class*, enabling them to be added contextually to the right-click menus.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to explore implementing the Command pattern using transaction nodes
    in Blueprint to add the ability to undo the process a tool does. To do this, we
    are going to create a simple tool that rotates the selected objects in the level
    by 45 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, let’s create a Utility Blueprint and define its *Supported Class*
    as `Actor` (so that we can use the tool on any actor in the world). To do this,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the content browser and navigate to **Editor Utilities** | **Editor**
    **Utility Blueprint**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the popup, expand the **All Classes** rollout, select **ActorActionUtility**,
    and click the **Select** button once it becomes available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the new Blueprint an appropriate name such as `EU_ActorTransformTools`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Blueprint, then on the left side, hover over the **Functions** section
    of the **My Blueprint** tab. This should reveal the **Override** dropdown; from
    this, select **Get** **Supported Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should have automatically opened the **Get Supported Class** function
    graph. From here, delete the **Parent: Get Supported Class** node and, using the
    dropdown on the **Return Node** node, select **Actor** as the supported class
    for any tools built in this Blueprint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The Get Supported Class function, overridden to set Actor as
    the supported class](img/Figure_08.04_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – The Get Supported Class function, overridden to set Actor as the
    supported class
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Blueprint set up, we can now add our tools to it. We can add tools
    either as functions or custom events, as mentioned earlier in this section. For
    this example, we will create our tool as a new function to keep the structure
    of the tools within the Utility Blueprint tidy:'
  prefs: []
  type: TYPE_NORMAL
- en: With the Utility Blueprint open, click the `RotateSelected45`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the **RotateSelected45** graph open (which should happen automatically)
    in the **Details** panel, set the **Call in Editor** checkbox to **On**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the function set up, let’s test that we’ve enabled the correct things
    and the function is appearing in the menus when we right-click on something in
    the viewport, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: Add some cubes to the level using the **Quickly Add to the Project** button,
    navigating to **Shapes** | **Cube**, and dragging one into the viewport.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the cube a few times by holding *Alt* and dragging the cube using
    the **Move** tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select all of the cubes and right-click on one of them. You should now be able
    to navigate to **Scripted Actor Actions** | **Rotate** **Selected 45**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, nothing will happen because we have not yet created any logic
    in the Blueprint function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will set up the functionality to rotate the actor (not worrying yet
    about implementing the Command pattern). The process here is to first identify
    which actors the user has selected, then use a **For Each Loop** node to rotate
    the actor in the world. To do this in Blueprint, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag from the pin on the `Get Selected` `Actors` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the `For Each` `Loop` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the output pin from the **Get Selected Actors** node to the **Exec**
    pin on the **For Each** **Loop** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the `Add Actor World` `Rotation` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `0`, `0`, and `45`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your function should now look this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The Rotate Selected 45 function without undo functionality](img/Figure_08.05_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – The Rotate Selected 45 function without undo functionality
  prefs: []
  type: TYPE_NORMAL
- en: With the functionality set up, test the function again with the same process
    as before when we tested that the function was appearing. You should now see that
    the box rotates.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you have **Realtime** turned off in the viewport, you will not see the box
    rotate until you move the viewport for it to update.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the functionality now working, we want to add the ability to undo the
    action by implementing the Command pattern using the **Transaction** system. To
    do this, we need to add three nodes: a **Begin Transaction** node, to start the
    process of recording the actions, a **Transact Object** node, which is used to
    identify objects that are about to have a property changed, and an **End Transaction**
    node, which stops the process of recording actions. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `Begin Transaction` node at the start of the function, between the **Rotate
    Selected 45** node and the **Get Selected** **Actors** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Transact Object` node as the first part of the for each loop, between
    the **For Each Loop** node and the **Add Actor World Rotation** node in the **Loop**
    **Body** chain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag out from the `End Transaction` node, completing the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your function should now look like this; we’ve added some reroute nodes to
    the link between the **For Each Loop** node’s **Array Element** pin and the **Target**
    pin on the **Add Actor World** **Rotation** node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – The completed Rotate Selected 45 function with Transaction nodes](img/Figure_08.06_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – The completed Rotate Selected 45 function with Transaction nodes
  prefs: []
  type: TYPE_NORMAL
- en: With the function now complete, it is time to test it again. Repeat the steps
    from before, and the box should still rotate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference now is you should be able to click **Edit** in the top toolbar
    and see that an option for **Undo Blutility Action** has become available in the
    **HISTORY** section. If you select it, you should be able to see that any actors
    that were rotated by the tool return to their previous state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Undo Blutility Action in the HISTORY section of the Edit menu](img/Figure_08.07_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Undo Blutility Action in the HISTORY section of the Edit menu
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see **Blutility Action** in the **Transactions** list when you
    select **Undo History** from the **Edit** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – The Transactions list in the Undo History window](img/Figure_08.08_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – The Transactions list in the Undo History window
  prefs: []
  type: TYPE_NORMAL
- en: With the **Blutility Action** appearing in the undo history and working correctly,
    the tool is now complete.
  prefs: []
  type: TYPE_NORMAL
- en: When creating tools using Blueprint Utilities, it is considered best practice
    to always include the ability for the user to undo the effect of the tool, so
    implementing the Command pattern is key to creating user-friendly solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Command pattern for gameplay in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Making our own version of the Command pattern for general use, let’s establish
    a class for our base command. Start by making a child of `UObject` inside your
    IDE. We are using `UObject` so that our class is visible to the engine, but it
    doesn’t need all the extra trappings of `AActor`, such as a transform. We mark
    it as `Abstract` in the `UCLASS()` macro to make sure no instance will ever be
    made of this object. This class only needs a virtual execute function as we won’t
    be supporting undo queueing, and initialization will be dealt with differently
    from standard C++ implementations due to the way Unreal deals with object spawning,
    let's set that up.
  prefs: []
  type: TYPE_NORMAL
- en: Command.h
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We only need to generate empty function definitions in the body file; there
    is no need to add any code to the functions as whatever is written there will
    never run. After creating the base command class, compile everything into the
    editor layer to make sure there are no errors. With it all compiled, right-click
    on the `Command` object in the project drawer and create a child C++ class called
    something like `Command_UnitMove`. This will be the first command linked with
    our framework. The definition and body are shown next and are simple. The `Init`
    function is made so that we can set up local variables for the command to execute
    with, and the `Execute` function is overridden to actually use those values by
    calling the interfaced function on the reference object. Setup the header file
    as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: Command_UnitMove.h
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see next, the `Init` function actually has no innards. Instead,
    we use C++ standard constructor overloading syntax to pass the arguments up to
    the constructors of the internal objects. This is not necessary as code in the
    body will still work, but it is considered better practice as it uses slightly
    less memory, but only fractionally. So, let''s add the `Init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: Command_UnitMove.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The next steps would be to augment the system for consuming input to distinguish
    when we want to add a command to the queue versus just overwriting what is there.
    This would be a couple of lines in many different classes, but we have provided
    the base for you. To inspect what has been made, you can head to the `PC_RTS`
    header and body and look at how the input is routed into the pawn via interface
    calls. The part we are working on next is the character being controlled. There
    is a function in the `AEliteUnit` class called `QueueMoveLocation_Implementation`,
    which is currently empty. As it stands, our player can right-click anywhere while
    holding left *shift* for this function to fire. What we would like is for this
    function to create a new move `Command` object, initialize it, and store it in
    a queue. For that, we need a queue, so in the header, add a protected or private
    `TQueue<TObjectPtr<UCommand>>` variable, autocompleting the `#include` instances
    where necessary, and name it something sensible; we have gone with `_commandQueue`.
    The `QueueMoveLocation_Implementation` function can now check if the character
    is in the process of moving, and if it is, do exactly what was detailed previously.
    Create a new command to reify the request, initialize it with values, and add
    it to the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: QueueMoveLocation_Implementation function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It is all well and good storing requests to move, but there needs to be a system
    for clearing the queue as commands are completed, making use of the `Dequeue`
    function. This is where the `MoveLocationReached_Implementation` callback function
    comes in. This needs to see if there are any commands, and if there are, remove
    them from the queue and call their `Execute` function. This is the reason we made
    sure the command has all its resources injected on creation: so that the `Execute`
    function can remain parameter-less and therefore useful, as set out in the code
    below.'
  prefs: []
  type: TYPE_NORMAL
- en: MoveLocationReached_Implementation function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With that, the system is functionally complete. There is, of course, no feedback
    to the user about what currently exists in the queue; that would require a lot
    more in the way of functions to peek values of commands, but if you wanted to
    expand this to include different types of move commands or actions, then all you’d
    need to do is make them from the `UCommand` base, create them somewhere, and add
    them to the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Our system uses a queue of commands for stacking player commands, but if you
    wanted an AI to be in control, you could preload it with a set of actions it can
    perform and let it loose with some form of **Goal-Oriented Action Planning** (**GOAP**).
    GOAP is an AI design method that abstracts individual interactions with the world
    from the purpose they fulfill. Stringing these actions together in a chain can
    create a strategy to achieve a goal. The Command pattern is a great way of implementing
    this as you can pre-generate a series of commands that make up all the actions
    an AI can take. Then, the AI strings them together into a queue, as we did previously
    for the action queue on the controllable unit, to plan its strategy. Executing
    the commands one by one then hopefully allows the AI to achieve its goal.
  prefs: []
  type: TYPE_NORMAL
- en: By the very nature of making games, there is always some use for the Command
    pattern, which makes it a good pattern to practice setting as a templated plugin,
    much as with our next pattern, the state machine, where the Command pattern is
    used to delay and record logic and the state machine segregates it by use.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the many levels of a state machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A state machine allows us to separate behavior based on the idea of a *state*
    – a simple concept, but it has wide-reaching applications from animation state
    machines to AI logic and contextual player actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest of state machines feature two elements: states and transitions.
    A state machine, at any moment, will either be in a single state or transitioning
    between two different states, which is why they are a significant part of animation
    systems, where blending improves the visual quality and feel of characters when
    receiving input from the player. Let’s look at this in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: A state defines a specific output and/or value of variables. In an animation
    state machine, the state defines which animation asset should be playing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A transition contains the logic that defines when a state machine can transition
    between two states. Transitions can be adjusted to control the duration as well
    as utilize curves to further refine the blend weighting between the two states
    throughout the duration of the transition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 8**.9* shows a simple state machine with three states and four transitions.
    Each transition has a start state and an end state. Transitions can exist in either
    direction, as shown in the example, with there being two transitions between **State
    1** and **State 3**, one from **State 3** to **State 1**, and another from **State
    1** to **State 3**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – A state machine with three states and four transitions](img/Figure_08.09_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – A state machine with three states and four transitions
  prefs: []
  type: TYPE_NORMAL
- en: Exploring animation state machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simple character animation state machine might look like the example provided
    in *Figure 8**.10*. This shows a character animation state machine that can stand
    still (idle), move (denoted by the run state), and jump (which uses three states).
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example to understand the use of transitions is the setup of a three-part
    jump animation system:'
  prefs: []
  type: TYPE_NORMAL
- en: The transition from **Idle** or **Run** into **JumpStart** is controlled by
    the player input (when the **Jump** button is pressed) or, more commonly, with
    physics (when the character is in the air)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second transition into **JumpLoop** occurs when the **JumpStart** animation
    is near completion, either controlled via logic within the transition or using
    the automatic option, which starts the transition purely based on the duration
    of the transition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third transition to **JumpEnd** (typically a landing animation) occurs when
    the character actor returns to contact with the floor – that is, when the character
    is *NOT* in the air
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final transitions, back to **Idle** or back to **Run**, are, then, similar
    to the second transition, based on the remaining time of the landing animation
    in the **JumpEnd** state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.10 – An animation state machine for a character](img/Figure_08.10_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – An animation state machine for a character
  prefs: []
  type: TYPE_NORMAL
- en: 'A single state can be connected to any number of other states via the use of
    lots of transitions in a one-to-many relationship; however, a state machine can
    be refined with the use of a conduit node that allows for a one-to-many, many-to-one,
    or many-to-many relationship within a single node. Conduits contain no state information
    (such as an animation); they simply act, as their name suggests, as a conduit
    between states, simplifying the need for an excessive number of transition lines
    between states to achieve the same many-to-many relationship, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – A more complex state machine including a conduit node](img/Figure_08.11_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – A more complex state machine including a conduit node
  prefs: []
  type: TYPE_NORMAL
- en: 'The system shown in *Figure 8**.11* includes a system to select different jumping
    and landing animations for when the character is standing still (idle) or when
    it is moving. A conduit is used to decide which of the two landing animations
    should be selected:'
  prefs: []
  type: TYPE_NORMAL
- en: The transition out of **JumpLoop** into the landing conduit remains the same
    as the previous system, based on when the character is no longer in the air
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transitions out of the conduit into `0`, the `0`, the **RunningLanding**
    state will be selected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this, at this point, doesn’t offer much more efficiency for the number
    of transitions, it does allow the separation of checks and simplifies the logic
    used to identify which transition to use. This makes the system much easier to
    expand, for example, by adding a different landing if the character has fallen
    a larger distance or if the character is traveling backward.
  prefs: []
  type: TYPE_NORMAL
- en: Animation state machines can become very complex and even include state machines
    within state machines, where a state utilizes its own state machine to determine
    its own output. The complexity of the system depends upon the required solution
    and how many different animations need to be considered.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create many styles of state machines that make them useful for different
    purposes. We’ll be starting the journey by looking at the simplest form: an enum/switch
    implementation where the state is determined by a simple variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Enum/switch implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If all you need to do is separate mutually exclusive logic, then an enum-style
    state machine is all you require. Creating an enum with a value for each state
    is the start. Unreal requires enum definitions to have specific tags to be usable
    in Blueprint, where you may want to visualize things to make debugging easier.
    The important thing is the `UENUM()` block. In the following code snippet, we
    can see that it includes the `BlueprintableType` property. This allows the editor
    layer to both serialize C++ variables of this type into details panels and also
    create Blueprint-level variables of this type. The enum is also defined as a class
    inheriting from an unsigned integer. This is different from standard C++ where
    an enum is its own type. Unreal naming convention would have you prefix your enum
    type name with `E`, but this is not a requirement for it to function. You will
    have to decide what size unsigned integer to inherit from. Here, we have shown
    a `uint8` type, which would give you 8 bits of size, meaning that you can either
    have 256 values as standard or 8 values if using the enum to pack Boolean values
    as flags. In most cases, `uint8` will provide the necessary space. Each value
    also has a `UMETA()` block that gives the flexibility of a different display name
    in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: UENUM example definition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Making an enum variable to track our current state allows us to segregate our
    logic into different case blocks of a `switch` statement. While an integer variable
    could be used for this same job, the enum only has a small additional cost and
    makes our code more human-readable. Anywhere we need to execute different logic
    based on the state, we can use a `switch` case, as in the following example. This
    is in place of many Boolean variables combined in complex amounts of `if` statements,
    instead setting it out like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Example state machine switch statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Helpful tip
  prefs: []
  type: TYPE_NORMAL
- en: Save yourself time by leveraging your IDE’s code autocomplete functionality
    to create the template `switch` statement followed by all the `case` statements
    with a few keyboard presses. In Visual Studio, this requires autocompleting the
    statement. Without clicking away, press *Enter* twice after adding the variable
    to the expression brackets; this should engage the autocomplete and paste in the
    template structure. Rider uses the *Alt* + *Enter* autocomplete tool to do this.
  prefs: []
  type: TYPE_NORMAL
- en: The `enum`/`switch` method works when all you need to segregate is logic. As
    soon as variables that only have use in some states get involved, we can enforce
    the `enum/switch` method, where states are pure logic and therefore stateless.
  prefs: []
  type: TYPE_NORMAL
- en: Static versus instanced states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using stateful states, there is a decision to make. We can define our states
    as either static or instanced. Static states only exist once in stack memory,
    helping with overall memory size if multiple machines have reference to the logic.
    This can be especially helpful for AI state machines being used by large numbers
    of actors. Instanced states must be created and likely exist in heap memory. Instanced
    states are necessary when the state of a state – that is to say, the current value
    of the variables it holds – matters to the actor running the state machine. Something
    such as a heavy attack charge level cares about which state machine it is running
    on and therefore must be in an instanced state; otherwise, all state machines
    running that state will share a charge level.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement states as separate classes, there must be a parent state class
    that has the basic functionality of a state. The following code shows instanced
    states, but a static state would be largely the same with the `static` keyword.
    In this example, we are using the `Update()` function to return an `EState` value
    that will inform the machine running this state when to change state and which
    one to change to. It also has other benefits of using separate classes for states,
    enter, and exit logic. Usage of this can vary wildly, but it gives gameplay programmers
    a hook for the moment a state starts and finishes to run extra logic. Lastly,
    marking all the functions as purely virtual will make the class abstract in nature
    and ensure all child states have these functions implemented in some capacity:'
  prefs: []
  type: TYPE_NORMAL
- en: Example state base class header
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual machine is very simple; it consists of a `State` variable to hold
    the current state being run and some kind of collection for the rest of the states
    to be created into and held in. This is where a static implementation may differ;
    states are still held as references, but they don’t need to be instantiated. Setup
    the header for the instanced state machine as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: Instanced state machine implementation header
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This code makes use of a `Map<>` collection. This doesn’t strictly exist in
    base C++ but it is analogous to Unreal’s `TMap<>` collection, which stores key-value
    pairs and indexes by key. The body therefore can be setup like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Instanced state machine implementation body
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In Unreal, making objects of base C++ classes can make your code faster as you
    are ignoring all the overhead of Unreal’s Editor layer, but if you want to make
    an instanced state machine that can be balanced by designers, it is a good idea
    to create your states as Actor components. That way, you could build the entire
    system to work through the editor using custom slate tools.
  prefs: []
  type: TYPE_NORMAL
- en: The next bottleneck in the system comes into play when multiple unconnected
    factors influence different parts of the behavior. This could mean the state machine
    is governing locomotion and world interaction. With the current system, a new
    state would be needed for each combination of possibilities, such as a running
    heavy attack and a crouched heavy attack. The heavy attack logic is likely to
    be duplicated between these states, which should be setting off alarm bells. There
    is a solution in concurrent state machines.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent state machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term *concurrent* simply means to be running at the same time as something
    else. It is a term thrown about a lot in the networking sphere, but here, it means
    something far simpler. When there are two or more areas of control that never
    cross, we can create a state machine for each area and run them at the same time.
    Expanding our implementation from the preceding section, the following code shows
    that each state machine exists and updates side by side. The rest of the setup
    will also need to be doubled. Only minor changes are needed to the `ChangeState()`
    function to accommodate the upgrade, making it machine-agnostic. The `State*&`
    argument here is used to pass the pointer by reference instead of the value being
    pointed to, as it is the pointer we need to retarget. This can be seen below.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent state machine implementation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The next area for improvement will be noticed most in state machines that govern
    variant behavior where multiple states might share some base functionality but
    differ slightly. An example of this could be that a crouching state has different
    state transitions from a running state but the logic for executing movement is
    the same. In this case, we can take advantage of the fact that all states inherit
    from a parent and add some more layers with a hierarchical state machine.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical state machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the name suggests, the state inheritance tree being pulled into a larger
    inheritance hierarchy with base behavior for groups of states creates a hierarchical
    state machine. Everything within this actually functions exactly the same as the
    base state machine; you just need to make sure that the implementations of each
    function call the base version. This is more of a code architecture principle
    to reduce memory footprint and speed up development. *Figure 8**.12* shows an
    example state inheritance tree for character locomotion and how we can use the
    grounded mid-level state to create several other states that implement grounded
    movement logic without needing to write it out a bunch of times. This improves
    maintainability as well since we are centralizing behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – UML diagram showing an example inheritance structure for a
    set of hierarchical states](img/Figure_08.12_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – UML diagram showing an example inheritance structure for a set
    of hierarchical states
  prefs: []
  type: TYPE_NORMAL
- en: The final step is not to do with the execution logic but the transitions. As
    it currently stands, each state transition must know which state it’s heading
    to. This can work for simple state machines, but as soon as you have an interrupt
    action that can be accessed from anywhere and must return execution to where it
    came from when finished, we have a problem. Storing the information on where the
    state was entered from doesn’t really solve the problem, because what if the state
    we were in had a state that must be preserved? The answer is the very fancy pushdown
    automata level of a state machine.
  prefs: []
  type: TYPE_NORMAL
- en: Pushdown automata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As just mentioned, pushdown automata aim to provide a way to enter states with
    a breadcrumb trail to follow back out if the need arises. We achieve this by storing
    the current path of states in a stack. The only code change here is that the tracker
    and state pointer variables get merged into a struct and stored in a single state
    stack instead. Execution is simply run the same way on whichever state happens
    to be on the top.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to push interrupt states from anywhere in the machine, then
    pop that state off and continue from where we were – another simple idea that
    provides a lot of utility. Prime example usage would be a state machine that governs
    animations on a character that can move and attack. Attacks take over the animation
    solver until they are finished. The character should then return to whichever
    state they were in, be that crouched or standing idle. *Figure 8**.13* shows how
    the stack changes as the interaction progresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Storyboard of a pushdown automata state stack over the course
    of an attack input](img/Figure_08.13_B18297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Storyboard of a pushdown automata state stack over the course
    of an attack input
  prefs: []
  type: TYPE_NORMAL
- en: The state machine, as we have covered, has many forms. The real silver bullet
    with this pattern is realizing that none of these forms is mutually exclusive.
    You can make a hierarchical pushdown automata state machine that runs concurrently
    with another. The flip side of that is noticing that if you are using a fully
    featured hierarchical pushdown automata state machine in earnest, there is probably
    a simpler pattern that solves the same problem in a much more elegant way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Altogether, we have covered three patterns that you can build into any future
    project: the Singleton pattern, which makes sure there is – and only ever will
    be – one instance of an object that exists, the Command pattern, which provides
    the utility of separation between the request for an action and that action happening,
    and finally, the State pattern, which separates our mutually exclusive logic.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should understand that Singleton does work in some cases,
    but it has its drawbacks. The Command pattern can be used for so many different
    things that you should probably make a version of it as a template library for
    use in all future projects, and the State pattern has so many layers that it can
    ruin its own usefulness with depth.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will explore some behavioral patterns that solidify the behavior
    of a class in different ways to improve the expandability of our systems – namely,
    the type object pattern, which we would posit as the most useful pattern in game
    development for content creation.
  prefs: []
  type: TYPE_NORMAL
