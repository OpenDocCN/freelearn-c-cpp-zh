- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Building Design Patterns – Singleton, Command, and State
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建设计模式——单例、命令和状态
- en: Whereas the previous chapter looked at a methodology of code architecture design,
    this chapter will look at three design patterns you can build yourself that have
    applications across many game genres.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 而上一章探讨了代码架构设计的方法，本章将探讨三种你可以自己构建的设计模式，这些模式在许多游戏类型中都有应用。
- en: 'The patterns being covered are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖的图案如下：
- en: Singleton pattern – understanding why it’s a Pandora’s box that often gets overused
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式——理解为什么它是一个经常被过度使用的潘多拉的盒子
- en: Command pattern – how it has many uses beyond the obvious
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式——它如何有超出明显用途的许多用途
- en: The many levels of state machine traveling down the rabbit hole and seeing how
    far we can push its concept
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态机的多层次探索，看看我们可以将其概念推进多远
- en: The aim of this will be to make some base classes that can be imported into
    any future project to speed up development. By the end of the chapter, you should
    understand why so many online resources overuse the Singleton pattern, what a
    hidden gem the Command pattern is, and how deep customization can go with the
    humble state machine.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的目标是创建一些基础类，这些类可以被导入到任何未来的项目中以加速开发。到本章结束时，你应该理解为什么许多在线资源过度使用单例模式，命令模式是一个隐藏的宝藏，以及如何通过谦逊的状态机进行深度定制。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will be building on the `chapter8` branch on GitHub, which can
    be downloaded from [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter08](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter08)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将在 GitHub 的 `chapter8` 分支上构建，可以从 [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter08](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter08)
    下载。
- en: Implementing a Singleton pattern – understanding why it’s a Pandora’s box
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现单例模式——理解为什么它是一个潘多拉的盒子
- en: 'The official point of the Singleton pattern is to ensure there is only one
    instance of a class in existence at any one time, hence the name “single”-ton.
    Unfortunately, this often gets packaged and confused with a public static variable
    to this one existing object. The actual idea of only having one object instance
    of a class makes sense. You might have a manager that needs to exist in every
    level, but if you don’t know the path the player took to get to this level, then
    you have no idea if one has been spawned yet. The solution is to make the manager
    a Singleton class and have a copy at every level. We can do this with the following
    code, using a static variable pointing to the one that exists:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式官方的目的是确保在任何时候只有一个类的实例存在，因此得名“单例”。不幸的是，这通常与指向这个唯一存在的对象的公共静态变量打包在一起，并造成混淆。只有一个对象实例的类的实际想法是有意义的。你可能有一个在每个级别都需要存在的管理者，但如果你不知道玩家到达这个级别的路径，那么你就不知道是否已经生成了一个实例。解决方案是将管理者做成单例类，并在每个级别都有一个副本。我们可以通过以下代码实现这一点，使用一个静态变量指向那个存在的实例：
- en: Example Singleton.h excerpt
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 Singleton.h 摘录
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then have a choice on whether we delete the new one if it is a second or
    if it should assume the position of the instance, deleting what was previously
    there . The body file therefore would be:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个选择，即是否删除新的一个，如果它是第二个，或者它应该假定实例的位置，删除之前存在的。因此，主体文件将是：
- en: Example Singleton.cpp excerpt
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 Singleton.cpp 摘录
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There is an innate question arising from this. Internally, our monologue could
    sound like: “If only one instance of this class will ever exist, then why does
    it need to be instanced in the first place? Surely, making the entire class static
    has the same effect and will take up less memory with the functions and variables
    only existing on the stack, negating the need for a Singleton pattern.” You could
    answer that with a situation. Perhaps there is a need to replace the object in
    the instance slot with every new level. That is one argument for a Singleton pattern,
    but the usage is limited and can usually be designed around using the pattern
    we discussed at great length in [*Chapter 7*](B18297_07.xhtml#_idTextAnchor090).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，一个内在的问题随之而来。我们的独白可能听起来像：“如果这个类的唯一实例将永远存在，那么为什么还需要实例化它呢？显然，将整个类做成静态的会产生相同的效果，并且会占用更少的内存，因为函数和变量只存在于栈上，从而消除了对单例模式的需求。”你可以用一个情况来回答这个问题。也许需要用每个新级别替换实例槽中的对象。这是单例模式的一个论点，但使用是有限的，通常可以通过我们详细讨论的图案来设计，如[*第7章*](B18297_07.xhtml#_idTextAnchor090)。
- en: 'The other issue is that most implementations of the Singleton pattern use a
    public static variable for tracking the instance. This has led many people to
    think the purpose of this pattern is for an easy communication link between a
    top-level system and any object that needs it. Doing this potentially couples
    every class with the Singleton pattern, which we have established in previous
    chapters is a thing to be avoided. The effect can be seen clearly in *Figure 8**.1*,
    where every class aggregates the **Singleton** class into its memory footprint
    because it has one or more references within:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是最多实现的单例模式使用公共静态变量来跟踪实例。这导致许多人认为这个模式的目的是为了在顶层系统和任何需要它的对象之间建立一个简单的通信链接。这样做可能会将每个类与单例模式耦合在一起，我们在前面的章节中已经确定这是要避免的事情。这种影响在*图
    8*.1*中可以清楚地看到，其中每个类都将**单例**类聚合到其内存足迹中，因为它在其中有一个或多个引用：
- en: "![Figure 8.1 – UML\uFEFF diagram of a Singleton pattern being aggregated into\
    \ lots of classes](img/Figure_08.01_B18297.jpg)"
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 单例模式被聚合到许多类中的 UML 图](img/Figure_08.01_B18297.jpg)'
- en: Figure 8.1 – UML diagram of a Singleton pattern being aggregated into lots of
    classes
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 单例模式被聚合到许多类中的 UML 图
- en: 'The correct usage is a private static variable used to track the instance,
    as shown at the start of this section. Then, with the instance created by a manager,
    it fits into the hierarchical class tree shown in [*Chapter 7*](B18297_07.xhtml#_idTextAnchor090).
    This manager can then distribute the direct reference to any classes under it
    via the initialization chain. This is what we know as **dependency injection**.
    This does still create coupling, but the spread is much more controlled. An example
    custom initializer function for a unit in a grid-based game could have the dependency
    of the grid injected into it instead of making the grid a Singleton pattern that
    anything can access. Next, you can see an example of how this could be constructed
    and how little this method impacts the flow of the code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的使用方式是使用私有静态变量来跟踪实例，如本节开头所示。然后，通过由管理器创建的实例，它适合到[*第 7 章*](B18297_07.xhtml#_idTextAnchor090)中显示的层次类树。然后，这个管理器可以通过初始化链将直接引用分配给其下的任何类。这就是我们所知道的**依赖注入**。这仍然会创建耦合，但分布要更加可控。一个基于网格的游戏中一个单位的自定义初始化函数的例子可以注入网格的依赖，而不是使网格成为任何人都可访问的单例模式。接下来，你可以看到如何构建这个例子以及这种方法对代码流程的影响有多小：
- en: Dependency injection example
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入示例
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Overall, the actual concept and code for the Singleton pattern is relatively
    simple; the problem lies in how it is used. Even with the cleaner implementation,
    most – if not all – cases where a Singleton pattern has been used can be replaced
    with a different pattern to make the code easier to expand. Aggregation may mean
    that this functionality can become a component, or there may need to be a shift
    in the structure to something more like a subclass sandbox pattern (to be discussed
    later, in [*Chapter 9*](B18297_09.xhtml#_idTextAnchor130)) where the functionality
    is statically defined in a parent. Dependency injection takes most of the replacement
    duty, as the common use for a Singleton pattern will be a global utility class
    such as a **Fog of War** manager on a tiled grid. This is better sent through
    the initialization chain as a dependency injection so that other classes don’t
    also have access allowing other developers to incorrectly use the functionality.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，单例模式的实际概念和代码相对简单；问题在于它的使用方式。即使有更干净的实现，大多数——如果不是所有——使用单例模式的场景都可以用不同的模式来替换，从而使代码更容易扩展。聚合可能意味着这个功能可以成为一个组件，或者可能需要将结构转变为更类似于子类沙盒模式（将在后面的[*第
    9 章*](B18297_09.xhtml#_idTextAnchor130)中讨论），其中功能在父类中静态定义。依赖注入承担了大部分替换任务，因为单例模式最常见的用途将是全局实用工具类，例如在瓦片网格上的**战争迷雾**管理器。这最好通过初始化链作为依赖注入来发送，这样其他类就不会也有访问权限，从而允许其他开发者错误地使用该功能。
- en: Now that the temptation of the Singleton pattern has been expunged from our
    minds, we can move on to patterns that are useful in multiple scenarios, such
    as the Command pattern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从脑海中清除了单例模式的诱惑，我们可以继续讨论在多种场景中都很有用的模式，例如命令模式。
- en: Implementing the Command pattern for different use cases
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现命令模式以适应不同的用例
- en: 'The Command pattern adds a layer of separation between the request for an action
    and that action being carried out. The implementation looks like what is shown
    in *Figure 8**.2*, where the `Command` class parent is abstract and only has a
    constructor, `execute()`, and `undo()` functions that all take no arguments. The
    idea is that the child classes are more specific and contain all the object references
    needed to execute properly:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式在请求动作和执行动作之间添加了一层分离。实现看起来如图 *图 8**.2* 所示，其中 `Command` 类的父类是抽象的，并且只包含一个构造函数、`execute()`
    和 `undo()` 函数，这些函数都不接受任何参数。想法是子类更具体，并包含执行所需的所有对象引用：
- en: '![Figure 8.2 – UML diagram showing the structure of a Command pattern base
    class](img/Figure_08.02_B18297.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 显示命令模式基类结构的 UML 图](img/Figure_08.02_B18297.jpg)'
- en: Figure 8.2 – UML diagram showing the structure of a Command pattern base class
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 显示命令模式基类结构的 UML 图
- en: 'The purpose of a command is to reify the abstract idea of an action so that
    we can store it in a list. This list can have many uses, but the most identified
    is the undo queue that Microsoft made synonymous with its keyboard shortcut, *Ctrl*
    + *Z*. When an action is performed, a Command object of the relevant type is created
    and added to the list. The command is executed and left in this list until it
    falls off the back; this keeps the list in chronological order. If the user presses
    the undo key, then the last command in the list has its undo function called,
    and a pointer for the most recent command moves back one. This is shown in *Figure
    8**.3,* where you can see that creating a new command after some have been undone
    chops the undone commands off and inserts the new command as the head of the list:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的目的在于将动作的抽象概念具体化，以便我们可以将其存储在列表中。这个列表可以有多种用途，但最显著的是微软将其与键盘快捷键 *Ctrl* + *Z*
    结合使用的撤销队列。当执行一个动作时，会创建一个相关类型的 Command 对象并将其添加到列表中。命令被执行并保留在这个列表中，直到它从末尾掉落；这保持了列表的时间顺序。如果用户按下撤销键，则列表中的最后一个命令会调用其撤销功能，并且最近命令的指针向后移动一位。这如图
    *图 8**.3* 所示。3，其中可以看到在撤销一些命令之后创建新的命令会切断撤销的命令并将新命令插入列表的头部：
- en: '![Figure 8.3 – Diagram showing the process of adding, undoing, and branching
    commands](img/Figure_08.03_B18297.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 显示添加、撤销和分支命令的过程的图](img/Figure_08.03_B18297.jpg)'
- en: Figure 8.3 – Diagram showing the process of adding, undoing, and branching commands
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 显示添加、撤销和分支命令的过程的图
- en: In games, we can use this functionality for a plethora of different scenarios.
    The most common are strategy games, where the player can queue up actions for
    their units to be executed in a certain order, each only executing after the last
    has finished. Surprisingly few strategy games make use of the Command pattern’s
    undo capabilities, but that may be because it would reduce the cost of actions.
    Undo is making more of an appearance in modern games in the form of a rewind mechanic;
    exploited in classics such as *Braid* and incorporated as a feature into AAA games
    such as the *Forza Horizon* series. This real-time application has varying methods
    of execution; it is likely that *Braid* simply records all moving objects’ positions
    on a timer as there is so little going on in the scene. This approach clearly
    wouldn’t work for a racing game with complex physics; instead, you could record
    each time the player’s input changes as a different command. The undo queue then
    has to run the game backward and understand when commands were added to the list
    to preserve momentum.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，我们可以使用这种功能来应对各种不同的场景。最常见的是策略游戏，玩家可以为他们的单位排队执行动作，以特定的顺序执行，每个动作只在最后一个完成后执行。令人惊讶的是，很少有策略游戏使用命令模式的撤销功能，但这可能是因为它可能会减少动作的成本。撤销功能在现代游戏中以回放机制的形式出现得越来越多；在经典游戏如
    *Braid* 中被利用，并被整合到如 *Forza Horizon* 系列等 AAA 游戏中。这种实时应用有各种执行方法；很可能是 *Braid* 通过计时器记录所有移动对象的位姿，因为场景中发生的事情很少。显然，这种方法不适用于具有复杂物理的赛车游戏；相反，你可以记录玩家输入变化的时间作为不同的命令。然后撤销队列必须运行游戏反向并理解何时将命令添加到列表以保持势头。
- en: Saving each of the players’ input actions into a list can also work as a sort
    of replay-saving mechanic. This works for games such as the *Trials* series and
    fighting games such as *Super Smash Bros.* because there are no elements of randomness
    in the mechanics. If you input the same action at the same time, you will have
    the same result every time. This could lead to large replay files, with each input
    axis saving potentially a value every frame. There are potential ways around this,
    such as only saving the result of these inputs when an action is performed that
    relies on the state of the driven element. This could mean instead of saving every
    mouse movement in *World of Tanks*, the barrel rotation and time are saved every
    time a shell is fired and the barrel is hit. This way, all the little motions
    that add to zero are ignored from the replay file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个玩家的输入动作保存到列表中也可以作为一种类似回放保存的机制。这对于像*Trials*系列游戏和像*超级 Smash Bros.*这样的格斗游戏有效，因为这些游戏在机制中没有随机元素。如果你在同一时间输入相同的动作，每次都会有相同的结果。这可能导致大型回放文件，每个输入轴可能每帧保存一个值。有绕过这种方法的潜在方法，例如，仅在执行依赖于驱动元素状态的动作时保存这些输入的结果。这意味着，在*坦克世界*中，不是保存每次鼠标移动，而是每次发射炮弹并击中炮管时保存炮管的旋转和时间。这样，所有加起来为零的小动作都会被忽略在回放文件中。
- en: Command pattern for undo functionality in Blueprint Utilities
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝图工具中的撤销功能的命令模式
- en: In Unreal, we can make tools to use in the editor called **Blueprint Utilities**
    (formerly known as Blutilities during early development). Blueprint Utilities
    can be created as either right-click menu actions or as Utility Widgets that operate
    in a floating window or can be docked into the UI and can manipulate assets (the
    files in the content browser) or actors (elements within the world) to complete
    repeated actions, to reduce the impact of workflow steps or simply to remove the
    requirement for user input to reduce opportunities for mistakes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，我们可以创建用于编辑器的工具，称为**蓝图工具**（在早期开发期间曾被称为Blutilities）。蓝图工具可以创建为右键菜单操作，或者作为在浮动窗口中操作或可以停靠到UI中的实用工具小部件，可以操作资产（内容浏览器中的文件）或演员（世界中的元素）以完成重复操作，以减少工作流程步骤的影响，或者简单地减少用户输入以减少出错的机会。
- en: Editor Utilities can hold any number of tools within them, with each tool being
    created as its own function, having its own graph or a custom event within the
    standard Blueprint Event Graph. Actor and Asset Utility Widgets require us to
    define which class of actor or asset the tools will interact with, known as the
    *Supported Class*, enabling them to be added contextually to the right-click menus.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器工具可以包含任意数量的工具，每个工具作为一个单独的功能创建，拥有自己的图表或标准蓝图事件图中的自定义事件。演员和资产工具小部件要求我们定义工具将与之交互的演员或资产类别，称为**支持类**，这样它们就可以根据上下文添加到右键菜单中。
- en: We are going to explore implementing the Command pattern using transaction nodes
    in Blueprint to add the ability to undo the process a tool does. To do this, we
    are going to create a simple tool that rotates the selected objects in the level
    by 45 degrees.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索在蓝图中使用事务节点实现命令模式，以添加撤销工具执行过程的能力。为此，我们将创建一个简单的工具，该工具将级别中选定的对象旋转45度。
- en: 'To begin with, let’s create a Utility Blueprint and define its *Supported Class*
    as `Actor` (so that we can use the tool on any actor in the world). To do this,
    follow these steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个实用工具蓝图，并定义其**支持类**为`Actor`（这样我们就可以在世界上使用这个工具）。为此，请按照以下步骤操作：
- en: Right-click in the content browser and navigate to **Editor Utilities** | **Editor**
    **Utility Blueprint**.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中右键点击并导航到**编辑器工具** | **编辑器实用工具蓝图**。
- en: From the popup, expand the **All Classes** rollout, select **ActorActionUtility**,
    and click the **Select** button once it becomes available.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出菜单中，展开**所有类**展开项，选择**ActorActionUtility**，并在它可用时点击**选择**按钮。
- en: Give the new Blueprint an appropriate name such as `EU_ActorTransformTools`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给新的蓝图起一个合适的名字，例如`EU_ActorTransformTools`。
- en: Open the Blueprint, then on the left side, hover over the **Functions** section
    of the **My Blueprint** tab. This should reveal the **Override** dropdown; from
    this, select **Get** **Supported Class**.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开蓝图，然后在左侧，将鼠标悬停在**我的蓝图**选项卡的**函数**部分上。这应该会显示**覆盖**下拉菜单；从该菜单中，选择**获取** **支持类**。
- en: 'This should have automatically opened the **Get Supported Class** function
    graph. From here, delete the **Parent: Get Supported Class** node and, using the
    dropdown on the **Return Node** node, select **Actor** as the supported class
    for any tools built in this Blueprint:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '这应该会自动打开**Get Supported Class**函数图。从这里，删除**Parent: Get Supported Class**节点，并使用**Return
    Node**节点的下拉菜单，将**Actor**设置为在此蓝图构建的任何工具的支持类：'
- en: '![Figure 8.4 – The Get Supported Class function, overridden to set Actor as
    the supported class](img/Figure_08.04_B18297.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 覆盖以设置Actor为支持类的“Get Supported Class”函数](img/Figure_08.04_B18297.jpg)'
- en: Figure 8.4 – The Get Supported Class function, overridden to set Actor as the
    supported class
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 覆盖以设置Actor为支持类的“Get Supported Class”函数
- en: 'With the Blueprint set up, we can now add our tools to it. We can add tools
    either as functions or custom events, as mentioned earlier in this section. For
    this example, we will create our tool as a new function to keep the structure
    of the tools within the Utility Blueprint tidy:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图设置完成后，我们现在可以将其添加到工具中。我们可以像之前本节中提到的那样，将工具添加为函数或自定义事件。对于这个例子，我们将创建一个新的函数来保持Utility蓝图内工具的结构整洁：
- en: With the Utility Blueprint open, click the `RotateSelected45`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Utility蓝图打开的情况下，点击`RotateSelected45`。
- en: With the **RotateSelected45** graph open (which should happen automatically)
    in the **Details** panel, set the **Call in Editor** checkbox to **On**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Details**面板中打开**RotateSelected45**图（这应该会自动发生），将**在编辑器中调用**复选框设置为**开启**。
- en: 'With the function set up, let’s test that we’ve enabled the correct things
    and the function is appearing in the menus when we right-click on something in
    the viewport, like so:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 函数设置完成后，让我们测试一下我们是否启用了正确的东西，并在我们在视口中右键单击某个东西时，函数出现在菜单中，如下所示：
- en: Add some cubes to the level using the **Quickly Add to the Project** button,
    navigating to **Shapes** | **Cube**, and dragging one into the viewport.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**快速添加到项目**按钮在级别中添加一些立方体，导航到**形状** | **立方体**，并将一个拖入视口。
- en: Duplicate the cube a few times by holding *Alt* and dragging the cube using
    the **Move** tool.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按住*Alt*并使用**移动**工具拖动立方体，重复几次复制立方体。
- en: Select all of the cubes and right-click on one of them. You should now be able
    to navigate to **Scripted Actor Actions** | **Rotate** **Selected 45**.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有立方体，并在其中一个上右键单击。现在你应该可以导航到**脚本角色动作** | **旋转** **选择45**。
- en: At this point, nothing will happen because we have not yet created any logic
    in the Blueprint function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，什么也不会发生，因为我们还没有在蓝图函数中创建任何逻辑。
- en: 'Next, we will set up the functionality to rotate the actor (not worrying yet
    about implementing the Command pattern). The process here is to first identify
    which actors the user has selected, then use a **For Each Loop** node to rotate
    the actor in the world. To do this in Blueprint, follow these steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将设置旋转角色的功能（目前还不必担心实现命令模式）。这里的步骤是首先识别用户选择了哪些角色，然后使用一个**For Each Loop**节点在世界中旋转角色。要在蓝图（Blueprint）中实现这一点，请按照以下步骤操作：
- en: Drag from the pin on the `Get Selected` `Actors` node.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Get Selected** **Actors**节点的引脚拖动。
- en: Drag from the `For Each` `Loop` node.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**For Each** **Loop**节点拖动。
- en: Connect the output pin from the **Get Selected Actors** node to the **Exec**
    pin on the **For Each** **Loop** node.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Get Selected Actors**节点的输出引脚连接到**For Each** **Loop**节点的**Exec**引脚。
- en: Drag from the `Add Actor World` `Rotation` node.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Add Actor World` `Rotation`节点拖动。
- en: Set the `0`, `0`, and `45`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`0`，`0`，和`45`。
- en: 'Your function should now look this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您的函数现在应该看起来像这样：
- en: '![Figure 8.5 – The Rotate Selected 45 function without undo functionality](img/Figure_08.05_B18297.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 没有撤销功能的“旋转选择45”函数](img/Figure_08.05_B18297.jpg)'
- en: Figure 8.5 – The Rotate Selected 45 function without undo functionality
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 没有撤销功能的“旋转选择45”函数
- en: With the functionality set up, test the function again with the same process
    as before when we tested that the function was appearing. You should now see that
    the box rotates.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 功能设置完成后，使用与之前测试函数是否出现在菜单中相同的过程再次测试该函数。现在你应该看到盒子旋转了。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you have **Realtime** turned off in the viewport, you will not see the box
    rotate until you move the viewport for it to update.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在视图中关闭了**实时**，您将不会看到盒子旋转，直到您移动视口以更新它。
- en: 'With the functionality now working, we want to add the ability to undo the
    action by implementing the Command pattern using the **Transaction** system. To
    do this, we need to add three nodes: a **Begin Transaction** node, to start the
    process of recording the actions, a **Transact Object** node, which is used to
    identify objects that are about to have a property changed, and an **End Transaction**
    node, which stops the process of recording actions. Follow these steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在功能已经正常工作，我们想要通过使用 **Transaction** 系统实现命令模式来添加撤销动作的能力。为此，我们需要添加三个节点：一个 **Begin
    Transaction** 节点，用于开始记录动作的过程；一个 **Transact Object** 节点，用于标识即将更改属性的物体；以及一个 **End
    Transaction** 节点，用于停止记录动作的过程。按照以下步骤操作：
- en: Add a `Begin Transaction` node at the start of the function, between the **Rotate
    Selected 45** node and the **Get Selected** **Actors** node.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数的开始处添加一个 `Begin Transaction` 节点，位于 **Rotate Selected 45** 节点和 **Get Selected
    Actors** 节点之间。
- en: Add a `Transact Object` node as the first part of the for each loop, between
    the **For Each Loop** node and the **Add Actor World Rotation** node in the **Loop**
    **Body** chain.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **循环体** 链中的 **For Each Loop** 节点和 **Add Actor World Rotation** 节点之间，将一个 `Transact
    Object` 节点作为循环的起始部分添加。
- en: Drag out from the `End Transaction` node, completing the function.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `End Transaction` 节点拖动出来，完成函数。
- en: 'Your function should now look like this; we’ve added some reroute nodes to
    the link between the **For Each Loop** node’s **Array Element** pin and the **Target**
    pin on the **Add Actor World** **Rotation** node:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你的函数现在应该看起来像这样；我们在 **For Each Loop** 节点的 **Array Element** 插针和 **Add Actor World
    Rotation** 节点的 **Target** 插针之间的链接中添加了一些重定向节点：
- en: '![Figure 8.6 – The completed Rotate Selected 45 function with Transaction nodes](img/Figure_08.06_B18297.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 使用事务节点完成的 Rotate Selected 45 函数](img/Figure_08.06_B18297.jpg)'
- en: Figure 8.6 – The completed Rotate Selected 45 function with Transaction nodes
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 使用事务节点完成的 Rotate Selected 45 函数
- en: With the function now complete, it is time to test it again. Repeat the steps
    from before, and the box should still rotate.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 函数现在已完成，是时候再次测试它了。重复之前的步骤，盒子应该仍然旋转。
- en: 'The difference now is you should be able to click **Edit** in the top toolbar
    and see that an option for **Undo Blutility Action** has become available in the
    **HISTORY** section. If you select it, you should be able to see that any actors
    that were rotated by the tool return to their previous state:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的区别是，你应该能够点击顶部工具栏中的 **编辑**，并看到在 **历史** 部分出现了一个 **撤销 Blutility 动作** 的选项。如果你选择它，你应该能够看到任何被工具旋转的演员都回到了它们之前的状态：
- en: '![Figure 8.7 – Undo Blutility Action in the HISTORY section of the Edit menu](img/Figure_08.07_B18297.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 在编辑菜单的历史部分撤销 Blutility 动作](img/Figure_08.07_B18297.jpg)'
- en: Figure 8.7 – Undo Blutility Action in the HISTORY section of the Edit menu
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 在编辑菜单的历史部分撤销 Blutility 动作
- en: 'You can also see **Blutility Action** in the **Transactions** list when you
    select **Undo History** from the **Edit** menu:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从 **编辑** 菜单中选择 **撤销历史** 时，你还可以在 **事务** 列表中看到 **Blutility 动作**：
- en: '![Figure 8.8 – The Transactions list in the Undo History window](img/Figure_08.08_B18297.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 在撤销历史窗口中的事务列表](img/Figure_08.08_B18297.jpg)'
- en: Figure 8.8 – The Transactions list in the Undo History window
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 在撤销历史窗口中的事务列表
- en: With the **Blutility Action** appearing in the undo history and working correctly,
    the tool is now complete.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当 **Blutility 动作** 出现在撤销历史中并且工作正常时，工具现在就完成了。
- en: When creating tools using Blueprint Utilities, it is considered best practice
    to always include the ability for the user to undo the effect of the tool, so
    implementing the Command pattern is key to creating user-friendly solutions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Blueprint Utilities 创建工具时，被认为是一种最佳实践，始终包括用户能够撤销工具效果的能力，因此实现命令模式对于创建用户友好的解决方案至关重要。
- en: Command pattern for gameplay in C++
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 中游戏玩法的命令模式
- en: Making our own version of the Command pattern for general use, let’s establish
    a class for our base command. Start by making a child of `UObject` inside your
    IDE. We are using `UObject` so that our class is visible to the engine, but it
    doesn’t need all the extra trappings of `AActor`, such as a transform. We mark
    it as `Abstract` in the `UCLASS()` macro to make sure no instance will ever be
    made of this object. This class only needs a virtual execute function as we won’t
    be supporting undo queueing, and initialization will be dealt with differently
    from standard C++ implementations due to the way Unreal deals with object spawning,
    let's set that up.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通用目的，让我们创建自己的命令模式版本，并为我们的基础命令创建一个类。首先，在您的IDE中创建`UObject`的子类。我们使用`UObject`是为了让我们的类对引擎可见，但它不需要像`AActor`那样的额外装饰，例如变换。我们在`UCLASS()`宏中将它标记为`Abstract`，以确保永远不会创建此对象的实例。这个类只需要一个虚拟执行函数，因为我们不会支持撤销队列，并且由于Unreal处理对象创建的方式，初始化将与标准C++实现不同，让我们设置一下。
- en: Command.h
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Command.h
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We only need to generate empty function definitions in the body file; there
    is no need to add any code to the functions as whatever is written there will
    never run. After creating the base command class, compile everything into the
    editor layer to make sure there are no errors. With it all compiled, right-click
    on the `Command` object in the project drawer and create a child C++ class called
    something like `Command_UnitMove`. This will be the first command linked with
    our framework. The definition and body are shown next and are simple. The `Init`
    function is made so that we can set up local variables for the command to execute
    with, and the `Execute` function is overridden to actually use those values by
    calling the interfaced function on the reference object. Setup the header file
    as shown below:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在主体文件中，我们只需要生成空函数定义；不需要向函数中添加任何代码，因为无论写入什么内容都不会运行。在创建基础命令类后，将所有内容编译到编辑器层以确保没有错误。编译完成后，在项目抽屉中的`Command`对象上右键单击，创建一个名为`Command_UnitMove`之类的子C++类。这将是我们框架的第一个命令。下面的定义和主体都很简单。`Init`函数被设计成可以设置命令执行所需的局部变量，而`Execute`函数被重写，通过调用引用对象的接口函数来实际使用这些值。按照以下方式设置头文件：
- en: Command_UnitMove.h
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Command_UnitMove.h
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see next, the `Init` function actually has no innards. Instead,
    we use C++ standard constructor overloading syntax to pass the arguments up to
    the constructors of the internal objects. This is not necessary as code in the
    body will still work, but it is considered better practice as it uses slightly
    less memory, but only fractionally. So, let''s add the `Init` function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您接下来所见，`Init`函数实际上没有任何内容。相反，我们使用C++标准构造函数重载语法将参数传递到内部对象的构造函数中。这并不是必需的，因为主体中的代码仍然可以工作，但这被认为是一种更好的实践，因为它使用略少的内存，但只是微不足道的。所以，让我们添加`Init`函数：
- en: Command_UnitMove.cpp
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Command_UnitMove.cpp
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next steps would be to augment the system for consuming input to distinguish
    when we want to add a command to the queue versus just overwriting what is there.
    This would be a couple of lines in many different classes, but we have provided
    the base for you. To inspect what has been made, you can head to the `PC_RTS`
    header and body and look at how the input is routed into the pawn via interface
    calls. The part we are working on next is the character being controlled. There
    is a function in the `AEliteUnit` class called `QueueMoveLocation_Implementation`,
    which is currently empty. As it stands, our player can right-click anywhere while
    holding left *shift* for this function to fire. What we would like is for this
    function to create a new move `Command` object, initialize it, and store it in
    a queue. For that, we need a queue, so in the header, add a protected or private
    `TQueue<TObjectPtr<UCommand>>` variable, autocompleting the `#include` instances
    where necessary, and name it something sensible; we have gone with `_commandQueue`.
    The `QueueMoveLocation_Implementation` function can now check if the character
    is in the process of moving, and if it is, do exactly what was detailed previously.
    Create a new command to reify the request, initialize it with values, and add
    it to the queue:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是对系统进行增强，以便在消费输入时区分我们是在队列中添加命令还是简单地覆盖现有内容。这将在许多不同的类中占用几行代码，但我们已经为你提供了基础。要检查已经创建的内容，你可以前往`PC_RTS`头文件和主体部分，查看输入是如何通过接口调用路由到实体的。我们接下来要处理的部分是受控的角色。在`AEliteUnit`类中有一个名为`QueueMoveLocation_Implementation`的函数，目前它是空的。目前来看，我们的玩家可以在按住左*shift*键的同时右击任何地方来触发这个函数。我们希望这个函数能够创建一个新的移动`Command`对象，初始化它，并将其存储在队列中。为此，我们需要一个队列，所以在头文件中添加一个受保护的或私有的`TQueue<TObjectPtr<UCommand>>`变量，并在必要时自动完成`#include`实例，并给它起一个有意义的名字；我们选择了`_commandQueue`。现在`QueueMoveLocation_Implementation`函数可以检查角色是否正在移动，如果是，就执行之前详细说明的操作。创建一个新的命令来具体化请求，用值初始化它，并将其添加到队列中：
- en: QueueMoveLocation_Implementation function
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueueMoveLocation_Implementation`函数'
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It is all well and good storing requests to move, but there needs to be a system
    for clearing the queue as commands are completed, making use of the `Dequeue`
    function. This is where the `MoveLocationReached_Implementation` callback function
    comes in. This needs to see if there are any commands, and if there are, remove
    them from the queue and call their `Execute` function. This is the reason we made
    sure the command has all its resources injected on creation: so that the `Execute`
    function can remain parameter-less and therefore useful, as set out in the code
    below.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 存储移动请求固然很好，但需要在命令完成后有一个系统来清除队列，利用`Dequeue`函数。这就是`MoveLocationReached_Implementation`回调函数发挥作用的地方。它需要检查是否有任何命令，如果有，则从队列中移除它们并调用它们的`Execute`函数。这就是我们确保在创建命令时注入所有资源的原因：这样`Execute`函数就可以保持无参数，因此有用，如以下代码所示。
- en: MoveLocationReached_Implementation function
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveLocationReached_Implementation`函数'
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With that, the system is functionally complete. There is, of course, no feedback
    to the user about what currently exists in the queue; that would require a lot
    more in the way of functions to peek values of commands, but if you wanted to
    expand this to include different types of move commands or actions, then all you’d
    need to do is make them from the `UCommand` base, create them somewhere, and add
    them to the queue.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，系统在功能上就完成了。当然，用户当然无法获得队列中当前存在的内容的反馈；这需要更多的函数来查看命令的值，但如果你想要扩展这个系统以包括不同类型的移动命令或动作，那么你只需要从`UCommand`基类创建它们，在某个地方创建它们，并将它们添加到队列中。
- en: Our system uses a queue of commands for stacking player commands, but if you
    wanted an AI to be in control, you could preload it with a set of actions it can
    perform and let it loose with some form of **Goal-Oriented Action Planning** (**GOAP**).
    GOAP is an AI design method that abstracts individual interactions with the world
    from the purpose they fulfill. Stringing these actions together in a chain can
    create a strategy to achieve a goal. The Command pattern is a great way of implementing
    this as you can pre-generate a series of commands that make up all the actions
    an AI can take. Then, the AI strings them together into a queue, as we did previously
    for the action queue on the controllable unit, to plan its strategy. Executing
    the commands one by one then hopefully allows the AI to achieve its goal.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统使用命令队列来堆叠玩家命令，但如果你想让AI控制，你可以预先加载一组它可以执行的操作，并让它通过某种形式的**目标导向动作规划**（**GOAP**）来释放。GOAP是一种AI设计方法，它将世界中的个体交互从它们所实现的目的中抽象出来。将这些动作串联成链可以创建一个实现目标的策略。命令模式是实现这一点的绝佳方式，因为你可以预先生成一系列组成AI可以采取的所有动作的命令。然后，AI将它们串联成一个队列，就像我们之前在可控制单元的动作队列中所做的那样，来规划其策略。逐个执行这些命令，然后希望AI能够实现其目标。
- en: By the very nature of making games, there is always some use for the Command
    pattern, which makes it a good pattern to practice setting as a templated plugin,
    much as with our next pattern, the state machine, where the Command pattern is
    used to delay and record logic and the state machine segregates it by use.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过制作游戏的本性，命令模式总是有它的用途，这使得它成为一个很好的模式，可以作为一个模板插件来练习设置，就像我们的下一个模式——状态机一样，其中命令模式用于延迟和记录逻辑，而状态机则根据用途将其分离。
- en: Creating the many levels of a state machine
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建状态机的多个层级
- en: A state machine allows us to separate behavior based on the idea of a *state*
    – a simple concept, but it has wide-reaching applications from animation state
    machines to AI logic and contextual player actions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机允许我们根据*状态*的概念来分离行为——这是一个简单的概念，但它有广泛的应用，从动画状态机到AI逻辑和上下文玩家动作。
- en: 'The simplest of state machines feature two elements: states and transitions.
    A state machine, at any moment, will either be in a single state or transitioning
    between two different states, which is why they are a significant part of animation
    systems, where blending improves the visual quality and feel of characters when
    receiving input from the player. Let’s look at this in more detail:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的状态机有两个元素：状态和转换。在任何时刻，状态机要么处于单个状态，要么在两个不同的状态之间转换，这就是为什么它们是动画系统的重要组成部分，在动画系统中，混合可以提高角色在接收到玩家输入时的视觉质量和感觉。让我们更详细地看看这一点：
- en: A state defines a specific output and/or value of variables. In an animation
    state machine, the state defines which animation asset should be playing.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态定义了特定的输出和/或变量的值。在动画状态机中，状态定义了应该播放哪个动画资源。
- en: A transition contains the logic that defines when a state machine can transition
    between two states. Transitions can be adjusted to control the duration as well
    as utilize curves to further refine the blend weighting between the two states
    throughout the duration of the transition.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个转换包含定义状态机何时可以在两个状态之间转换的逻辑。转换可以调整以控制持续时间，以及利用曲线在整个转换过程中进一步细化两个状态之间的混合权重。
- en: '*Figure 8**.9* shows a simple state machine with three states and four transitions.
    Each transition has a start state and an end state. Transitions can exist in either
    direction, as shown in the example, with there being two transitions between **State
    1** and **State 3**, one from **State 3** to **State 1**, and another from **State
    1** to **State 3**:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.9* 展示了一个具有三个状态和四个转换的简单状态机。每个转换都有一个起始状态和一个结束状态。转换可以双向存在，如示例所示，存在两个从**状态1**到**状态3**的转换，一个从**状态3**到**状态1**，另一个从**状态1**到**状态3**：'
- en: '![Figure 8.9 – A state machine with three states and four transitions](img/Figure_08.09_B18297.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – 具有三个状态和四个转换的状态机](img/Figure_08.09_B18297.jpg)'
- en: Figure 8.9 – A state machine with three states and four transitions
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 具有三个状态和四个转换的状态机
- en: Exploring animation state machines
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索动画状态机
- en: A simple character animation state machine might look like the example provided
    in *Figure 8**.10*. This shows a character animation state machine that can stand
    still (idle), move (denoted by the run state), and jump (which uses three states).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的角色动画状态机可能看起来像*图8.10*中提供的示例。这显示了一个角色动画状态机，它可以静止（空闲），移动（用跑步状态表示），并且可以跳跃（使用三个状态）。
- en: 'A good example to understand the use of transitions is the setup of a three-part
    jump animation system:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 理解过渡使用的一个好例子是设置一个三部分跳跃动画系统：
- en: The transition from **Idle** or **Run** into **JumpStart** is controlled by
    the player input (when the **Jump** button is pressed) or, more commonly, with
    physics (when the character is in the air)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**空闲**或**跑步**状态进入**JumpStart**的过渡由玩家输入（当按下**跳跃**按钮）或更常见的物理方式（当角色在空中时）控制
- en: The second transition into **JumpLoop** occurs when the **JumpStart** animation
    is near completion, either controlled via logic within the transition or using
    the automatic option, which starts the transition purely based on the duration
    of the transition
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当**JumpStart**动画接近完成时，第二次过渡到**JumpLoop**发生，这可以通过过渡中的逻辑控制或使用自动选项来实现，该选项纯粹基于过渡的持续时间来启动过渡
- en: The third transition to **JumpEnd** (typically a landing animation) occurs when
    the character actor returns to contact with the floor – that is, when the character
    is *NOT* in the air
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三次过渡到**JumpEnd**（通常是一个着陆动画）发生在角色演员返回与地面接触时——也就是说，当角色**不在**空中时
- en: 'The final transitions, back to **Idle** or back to **Run**, are, then, similar
    to the second transition, based on the remaining time of the landing animation
    in the **JumpEnd** state:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的过渡，回到**空闲**或回到**跑步**，与第二次过渡相似，基于**JumpEnd**状态中着陆动画剩余的时间：
- en: '![Figure 8.10 – An animation state machine for a character](img/Figure_08.10_B18297.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10 – 一个角色的动画状态机](img/Figure_08.10_B18297.jpg)'
- en: Figure 8.10 – An animation state machine for a character
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 一个角色的动画状态机
- en: 'A single state can be connected to any number of other states via the use of
    lots of transitions in a one-to-many relationship; however, a state machine can
    be refined with the use of a conduit node that allows for a one-to-many, many-to-one,
    or many-to-many relationship within a single node. Conduits contain no state information
    (such as an animation); they simply act, as their name suggests, as a conduit
    between states, simplifying the need for an excessive number of transition lines
    between states to achieve the same many-to-many relationship, as illustrated here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个状态可以通过使用大量的一对多关系中的过渡连接到任何数量的其他状态；然而，可以通过使用允许单个节点内一对一、一对多或多对多关系的管道节点来细化状态机。管道不包含状态信息（如动画）；它们简单地作为其名称所暗示的，在状态之间起一个管道的作用，简化了在状态之间需要大量过渡线以实现相同的多对多关系的需求，如图所示：
- en: '![Figure 8.11 – A more complex state machine including a conduit node](img/Figure_08.11_B18297.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – 包含管道节点的更复杂的状态机](img/Figure_08.11_B18297.jpg)'
- en: Figure 8.11 – A more complex state machine including a conduit node
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 包含管道节点的更复杂的状态机
- en: 'The system shown in *Figure 8**.11* includes a system to select different jumping
    and landing animations for when the character is standing still (idle) or when
    it is moving. A conduit is used to decide which of the two landing animations
    should be selected:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.11*中所示的系统包括一个系统，用于在角色站立（空闲）或移动时选择不同的跳跃和着陆动画。使用管道来决定应该选择两个着陆动画中的哪一个：'
- en: The transition out of **JumpLoop** into the landing conduit remains the same
    as the previous system, based on when the character is no longer in the air
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**JumpLoop**到着陆管道的过渡与之前的系统相同，基于当角色不再在空中时
- en: The transitions out of the conduit into `0`, the `0`, the **RunningLanding**
    state will be selected
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从管道到`0`，`0`，**RunningLanding**状态的过渡将被选择
- en: While this, at this point, doesn’t offer much more efficiency for the number
    of transitions, it does allow the separation of checks and simplifies the logic
    used to identify which transition to use. This makes the system much easier to
    expand, for example, by adding a different landing if the character has fallen
    a larger distance or if the character is traveling backward.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然到目前为止，这并没有为过渡的数量提供更多的效率，但它确实允许分离检查并简化了用于识别使用哪个过渡的逻辑。这使得系统更容易扩展，例如，如果角色下落距离更大或角色正在向后移动，可以添加不同的着陆。
- en: Animation state machines can become very complex and even include state machines
    within state machines, where a state utilizes its own state machine to determine
    its own output. The complexity of the system depends upon the required solution
    and how many different animations need to be considered.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 动画状态机可以变得非常复杂，甚至包括状态机中的状态机，其中某个状态利用其自己的状态机来确定其输出。系统的复杂性取决于所需的解决方案以及需要考虑多少不同的动画。
- en: 'We can create many styles of state machines that make them useful for different
    purposes. We’ll be starting the journey by looking at the simplest form: an enum/switch
    implementation where the state is determined by a simple variable.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建许多不同风格的有限状态机，使其适用于不同的目的。我们将从最简单的形式开始：一个枚举/开关实现，其中状态由一个简单的变量确定。
- en: Enum/switch implementation
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举/开关实现
- en: 'If all you need to do is separate mutually exclusive logic, then an enum-style
    state machine is all you require. Creating an enum with a value for each state
    is the start. Unreal requires enum definitions to have specific tags to be usable
    in Blueprint, where you may want to visualize things to make debugging easier.
    The important thing is the `UENUM()` block. In the following code snippet, we
    can see that it includes the `BlueprintableType` property. This allows the editor
    layer to both serialize C++ variables of this type into details panels and also
    create Blueprint-level variables of this type. The enum is also defined as a class
    inheriting from an unsigned integer. This is different from standard C++ where
    an enum is its own type. Unreal naming convention would have you prefix your enum
    type name with `E`, but this is not a requirement for it to function. You will
    have to decide what size unsigned integer to inherit from. Here, we have shown
    a `uint8` type, which would give you 8 bits of size, meaning that you can either
    have 256 values as standard or 8 values if using the enum to pack Boolean values
    as flags. In most cases, `uint8` will provide the necessary space. Each value
    also has a `UMETA()` block that gives the flexibility of a different display name
    in the editor:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要分离互斥的逻辑，那么一个枚举风格的有限状态机就足够了。创建一个包含每个状态的值的枚举是起点。虚幻引擎要求枚举定义具有特定的标签才能在蓝图（Blueprint）中使用，你可能希望可视化这些内容以使调试更容易。重要的是`UENUM()`块。在下面的代码片段中，我们可以看到它包括`BlueprintableType`属性。这允许编辑器层将此类C++变量序列化到详细面板中，并创建此类蓝图级别的变量。枚举也被定义为继承自无符号整数的类。这与标准C++中的枚举是它自己的类型不同。虚幻引擎的命名约定要求你在枚举类型名称前加上`E`前缀，但这不是必须的。你必须决定从哪个无符号整数继承。在这里，我们展示了`uint8`类型，这将提供8位大小，这意味着你可以有256个标准值，或者如果使用枚举作为标志打包布尔值，则有8个值。在大多数情况下，`uint8`将提供所需的空间。每个值还有一个`UMETA()`块，它提供了在编辑器中显示不同名称的灵活性：
- en: UENUM example definition
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: UENUM示例定义
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Making an enum variable to track our current state allows us to segregate our
    logic into different case blocks of a `switch` statement. While an integer variable
    could be used for this same job, the enum only has a small additional cost and
    makes our code more human-readable. Anywhere we need to execute different logic
    based on the state, we can use a `switch` case, as in the following example. This
    is in place of many Boolean variables combined in complex amounts of `if` statements,
    instead setting it out like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个枚举变量来跟踪我们的当前状态，使我们能够将逻辑分离到`switch`语句的不同案例块中。虽然整数变量也可以用于这项工作，但枚举只有微小的额外成本，并使我们的代码更易于阅读。在任何需要根据状态执行不同逻辑的地方，我们都可以使用`switch`案例，如下面的示例所示。这是替代许多布尔变量组合在复杂数量的`if`语句中的做法，而是这样设置：
- en: Example state machine switch statement
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 示例状态机开关语句
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Helpful tip
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有用提示
- en: Save yourself time by leveraging your IDE’s code autocomplete functionality
    to create the template `switch` statement followed by all the `case` statements
    with a few keyboard presses. In Visual Studio, this requires autocompleting the
    statement. Without clicking away, press *Enter* twice after adding the variable
    to the expression brackets; this should engage the autocomplete and paste in the
    template structure. Rider uses the *Alt* + *Enter* autocomplete tool to do this.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用你的IDE的代码自动完成功能，通过几次键盘操作创建模板`switch`语句，然后跟随所有`case`语句，可以节省你的时间。在Visual Studio中，这需要自动完成语句。在添加变量到表达式括号后，不点击离开，按两次*Enter*；这应该会激活自动完成并粘贴模板结构。Rider使用*Alt*
    + *Enter*自动完成工具来完成此操作。
- en: The `enum`/`switch` method works when all you need to segregate is logic. As
    soon as variables that only have use in some states get involved, we can enforce
    the `enum/switch` method, where states are pure logic and therefore stateless.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要隔离逻辑时，`enum`/`switch`方法有效。一旦只有某些状态中使用的变量被涉及，我们就可以强制使用`enum/switch`方法，其中状态是纯逻辑且无状态的。
- en: Static versus instanced states
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态状态与实例化状态
- en: When using stateful states, there is a decision to make. We can define our states
    as either static or instanced. Static states only exist once in stack memory,
    helping with overall memory size if multiple machines have reference to the logic.
    This can be especially helpful for AI state machines being used by large numbers
    of actors. Instanced states must be created and likely exist in heap memory. Instanced
    states are necessary when the state of a state – that is to say, the current value
    of the variables it holds – matters to the actor running the state machine. Something
    such as a heavy attack charge level cares about which state machine it is running
    on and therefore must be in an instanced state; otherwise, all state machines
    running that state will share a charge level.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用有状态的状态时，需要做出一个决定。我们可以将状态定义为静态或实例化。静态状态仅在栈内存中存在一次，有助于整体内存大小，如果多个机器引用逻辑，这特别有用。实例化状态必须创建，并且可能存在于堆内存中。当状态的状态——即它所持有的变量的当前值——对运行状态机的演员很重要时，实例化状态是必要的；例如，一个重攻击充能等级会关心它运行在哪个状态机上，因此必须处于实例化状态；否则，所有运行该状态的状态机将共享一个充能等级。
- en: 'To implement states as separate classes, there must be a parent state class
    that has the basic functionality of a state. The following code shows instanced
    states, but a static state would be largely the same with the `static` keyword.
    In this example, we are using the `Update()` function to return an `EState` value
    that will inform the machine running this state when to change state and which
    one to change to. It also has other benefits of using separate classes for states,
    enter, and exit logic. Usage of this can vary wildly, but it gives gameplay programmers
    a hook for the moment a state starts and finishes to run extra logic. Lastly,
    marking all the functions as purely virtual will make the class abstract in nature
    and ensure all child states have these functions implemented in some capacity:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要将状态实现为单独的类，必须有一个具有状态基本功能的父状态类。以下代码显示了实例化状态，但静态状态将使用`static`关键字，大体上相同。在这个例子中，我们使用`Update()`函数来返回一个`EState`值，这将通知运行此状态的状态机何时以及切换到哪个状态。它还有使用单独类进行状态、进入和退出逻辑的其他好处。这种使用的范围可能非常广泛，但它为游戏程序员提供了一个钩子，在状态开始和结束时运行额外的逻辑。最后，将所有函数标记为纯虚函数将使类在本质上成为抽象的，并确保所有子状态以某种形式实现了这些函数：
- en: Example state base class header
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 示例状态基类头文件
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The actual machine is very simple; it consists of a `State` variable to hold
    the current state being run and some kind of collection for the rest of the states
    to be created into and held in. This is where a static implementation may differ;
    states are still held as references, but they don’t need to be instantiated. Setup
    the header for the instanced state machine as shown below:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的机器非常简单；它由一个`State`变量来保存当前正在运行的状态，以及某种类型的集合来创建和保存其余的状态。这就是静态实现可能有所不同之处；状态仍然作为引用保存，但不需要实例化。以下是如何设置实例化状态机的头文件：
- en: Instanced state machine implementation header
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化状态机实现头文件
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code makes use of a `Map<>` collection. This doesn’t strictly exist in
    base C++ but it is analogous to Unreal’s `TMap<>` collection, which stores key-value
    pairs and indexes by key. The body therefore can be setup like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用了`Map<>`集合。这严格来说在基C++中并不存在，但它类似于Unreal的`TMap<>`集合，该集合存储键值对并通过键进行索引。因此，其主体可以设置如下：
- en: Instanced state machine implementation body
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化状态机实现主体
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In Unreal, making objects of base C++ classes can make your code faster as you
    are ignoring all the overhead of Unreal’s Editor layer, but if you want to make
    an instanced state machine that can be balanced by designers, it is a good idea
    to create your states as Actor components. That way, you could build the entire
    system to work through the editor using custom slate tools.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unreal中，创建基C++类的对象可以使你的代码运行更快，因为你忽略了Unreal编辑层所有的开销，但如果你想创建一个可以被设计师平衡的实例化状态机，将你的状态作为Actor组件创建是一个好主意。这样，你可以通过自定义slate工具在编辑器中构建整个系统。
- en: The next bottleneck in the system comes into play when multiple unconnected
    factors influence different parts of the behavior. This could mean the state machine
    is governing locomotion and world interaction. With the current system, a new
    state would be needed for each combination of possibilities, such as a running
    heavy attack and a crouched heavy attack. The heavy attack logic is likely to
    be duplicated between these states, which should be setting off alarm bells. There
    is a solution in concurrent state machines.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个未连接的因素影响行为的不同部分时，系统中的下一个瓶颈就会出现。这可能意味着状态机正在控制移动和世界交互。在当前系统中，需要为每种可能的组合创建一个新的状态，例如，跑步重攻击和蹲下重攻击。这些状态之间可能存在重复的重攻击逻辑，这应该会触发警报。在并发状态机中有一个解决方案。
- en: Concurrent state machines
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发状态机
- en: The term *concurrent* simply means to be running at the same time as something
    else. It is a term thrown about a lot in the networking sphere, but here, it means
    something far simpler. When there are two or more areas of control that never
    cross, we can create a state machine for each area and run them at the same time.
    Expanding our implementation from the preceding section, the following code shows
    that each state machine exists and updates side by side. The rest of the setup
    will also need to be doubled. Only minor changes are needed to the `ChangeState()`
    function to accommodate the upgrade, making it machine-agnostic. The `State*&`
    argument here is used to pass the pointer by reference instead of the value being
    pointed to, as it is the pointer we need to retarget. This can be seen below.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: “并发”这个术语简单地意味着与某物同时运行。在网络领域，这是一个经常被提及的术语，但在这里，它意味着更简单的东西。当有两个或更多控制区域永远不会交叉时，我们可以为每个区域创建一个状态机，并同时运行它们。扩展前一小节中的实现，以下代码显示每个状态机都是独立存在并更新的。其余的设置也需要加倍。只需对
    `ChangeState()` 函数进行少量修改，以适应升级，使其成为机器无关的。这里的 `State*&` 参数用于通过引用传递指针，而不是传递指针指向的值，因为我们需要重新定位这个指针。这可以在下面看到。
- en: Concurrent state machine implementation
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 并发状态机实现
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The next area for improvement will be noticed most in state machines that govern
    variant behavior where multiple states might share some base functionality but
    differ slightly. An example of this could be that a crouching state has different
    state transitions from a running state but the logic for executing movement is
    the same. In this case, we can take advantage of the fact that all states inherit
    from a parent and add some more layers with a hierarchical state machine.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个改进领域将在控制多种行为的状态机中最为明显，其中多个状态可能共享一些基本功能，但略有不同。这种情况的一个例子可能是蹲下状态与跑步状态具有不同的状态转换，但执行移动的逻辑是相同的。在这种情况下，我们可以利用所有状态都从父状态继承的事实，并使用分层状态机添加更多层次。
- en: Hierarchical state machines
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层状态机
- en: 'As the name suggests, the state inheritance tree being pulled into a larger
    inheritance hierarchy with base behavior for groups of states creates a hierarchical
    state machine. Everything within this actually functions exactly the same as the
    base state machine; you just need to make sure that the implementations of each
    function call the base version. This is more of a code architecture principle
    to reduce memory footprint and speed up development. *Figure 8**.12* shows an
    example state inheritance tree for character locomotion and how we can use the
    grounded mid-level state to create several other states that implement grounded
    movement logic without needing to write it out a bunch of times. This improves
    maintainability as well since we are centralizing behavior:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，将状态继承树拉入一个更大的继承层次结构，并为状态组提供基本行为，从而创建了一个分层状态机。实际上，这个结构中的所有内容都完全像基本状态机一样运行；你只需确保每个函数的实现都调用基本版本。这更多的是一种代码架构原则，旨在减少内存占用并加快开发速度。*图
    8.12* 展示了一个示例状态继承树，用于角色移动，以及我们如何使用基于中级的地面状态来创建其他几个实现地面移动逻辑的状态，而无需多次编写。这也提高了可维护性，因为我们正在集中行为：
- en: '![Figure 8.12 – UML diagram showing an example inheritance structure for a
    set of hierarchical states](img/Figure_08.12_B18297.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.12 – 展示一组分层状态示例继承结构的 UML 图](img/Figure_08.12_B18297.jpg)'
- en: Figure 8.12 – UML diagram showing an example inheritance structure for a set
    of hierarchical states
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 展示一组分层状态示例继承结构的 UML 图
- en: The final step is not to do with the execution logic but the transitions. As
    it currently stands, each state transition must know which state it’s heading
    to. This can work for simple state machines, but as soon as you have an interrupt
    action that can be accessed from anywhere and must return execution to where it
    came from when finished, we have a problem. Storing the information on where the
    state was entered from doesn’t really solve the problem, because what if the state
    we were in had a state that must be preserved? The answer is the very fancy pushdown
    automata level of a state machine.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步与执行逻辑无关，而是关于转换。就目前情况来看，每个状态转换都必须知道它将前往哪个状态。这对于简单的状态机来说是可以工作的，但一旦你有一个可以从任何地方访问的中断动作，并且在完成时必须返回到它原来的位置，我们就遇到了问题。存储状态进入位置的信息并不能真正解决问题，因为如果我们所在的状态有一个必须保留的状态怎么办？答案是状态机的非常花哨的下压自动机级别。
- en: Pushdown automata
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下压自动机
- en: As just mentioned, pushdown automata aim to provide a way to enter states with
    a breadcrumb trail to follow back out if the need arises. We achieve this by storing
    the current path of states in a stack. The only code change here is that the tracker
    and state pointer variables get merged into a struct and stored in a single state
    stack instead. Execution is simply run the same way on whichever state happens
    to be on the top.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如刚才提到的，下压自动机的目的是提供一个方法，以便在需要时可以通过面包屑路径返回状态。我们通过在栈中存储当前状态路径来实现这一点。这里唯一的代码更改是将跟踪器和状态指针变量合并到一个结构体中，并存储在单个状态栈中。执行简单地以任何状态在栈顶的方式运行。
- en: 'This allows us to push interrupt states from anywhere in the machine, then
    pop that state off and continue from where we were – another simple idea that
    provides a lot of utility. Prime example usage would be a state machine that governs
    animations on a character that can move and attack. Attacks take over the animation
    solver until they are finished. The character should then return to whichever
    state they were in, be that crouched or standing idle. *Figure 8**.13* shows how
    the stack changes as the interaction progresses:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们从机器的任何地方推送中断状态，然后弹出该状态并从我们之前的位置继续 – 另一个简单但非常有用的想法。主要用例是一个控制可以移动和攻击的角色动画的状态机。攻击会接管动画求解器，直到完成。然后角色应该返回到它们之前的状态，无论是蹲下还是站立空闲。*图8.13*显示了随着交互的进行栈如何变化：
- en: '![Figure 8.13 – Storyboard of a pushdown automata state stack over the course
    of an attack input](img/Figure_08.13_B18297.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13 – 攻击输入过程中下压自动机状态栈的故事板](img/Figure_08.13_B18297.jpg)'
- en: Figure 8.13 – Storyboard of a pushdown automata state stack over the course
    of an attack input
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 攻击输入过程中下压自动机状态栈的故事板
- en: The state machine, as we have covered, has many forms. The real silver bullet
    with this pattern is realizing that none of these forms is mutually exclusive.
    You can make a hierarchical pushdown automata state machine that runs concurrently
    with another. The flip side of that is noticing that if you are using a fully
    featured hierarchical pushdown automata state machine in earnest, there is probably
    a simpler pattern that solves the same problem in a much more elegant way.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，状态机有许多形式。这个模式的真正银弹在于意识到这些形式之间并不相互排斥。你可以创建一个可以与另一个并发运行的分层下压自动机状态机。另一方面，如果你认真使用一个功能齐全的分层下压自动机状态机，可能有一个更简单的模式可以以更优雅的方式解决相同的问题。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Altogether, we have covered three patterns that you can build into any future
    project: the Singleton pattern, which makes sure there is – and only ever will
    be – one instance of an object that exists, the Command pattern, which provides
    the utility of separation between the request for an action and that action happening,
    and finally, the State pattern, which separates our mutually exclusive logic.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们已经介绍了三种你可以构建到任何未来项目中的模式：单例模式，确保只有一个对象实例存在，命令模式，它提供了请求动作与动作发生的分离的实用功能，最后是状态模式，它分离了我们的互斥逻辑。
- en: At this point, you should understand that Singleton does work in some cases,
    but it has its drawbacks. The Command pattern can be used for so many different
    things that you should probably make a version of it as a template library for
    use in all future projects, and the State pattern has so many layers that it can
    ruin its own usefulness with depth.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该明白单例模式在某些情况下是有效的，但它也有其缺点。命令模式可以用于许多不同的事情，因此你可能需要将其版本作为一个模板库，用于所有未来的项目，而状态模式有如此多的层级，它可能会因为深度而损害其自身的实用性。
- en: The next chapter will explore some behavioral patterns that solidify the behavior
    of a class in different ways to improve the expandability of our systems – namely,
    the type object pattern, which we would posit as the most useful pattern in game
    development for content creation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨一些行为模式，这些模式以不同的方式巩固了类的行为，从而提高我们系统的可扩展性——即类型对象模式，我们将其定位为游戏开发中对于内容创作最有用的模式。
