- en: Standard Qt Widgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准Qt Widgets
- en: Qt Widgets are not the new kid on the block, but they still do have their place
    in applications that target mobile and embedded devices. They are well formed,
    predictable and have standard UI elements.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Widgets 不是新出现的，但它们在针对移动和嵌入式设备的应用程序中仍然有其位置。它们结构良好、可预测，并且具有标准 UI 元素。
- en: Recognizable UI elements are found in Qt Widgets and work great on laptops,
    which are simply mobile desktops. In this chapter, you will learn to design standard
    looking applications. Basic widgets such as menus, icons, and lists will be discussed
    with an emphasis on how to constrain the user interface to medium and small-sized
    displays. Topics we will discuss include how to use Qt's dynamic layouts to handle
    orientation changes. Classes such as `QGraphicsScene`, `QGraphicsView`, and `QGraphicsItem`
    will be used. Layout API such as `QVBoxLayout`, `QGridLayout`, and `QStackedLayout`
    will be discussed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 可识别的 UI 元素可以在 Qt Widgets 中找到，并且在笔记本电脑上运行得很好，笔记本电脑只是移动的桌面。在本章中，你将学习如何设计看起来标准的应用程序。基本控件，如菜单、图标和列表，将进行讨论，重点是如何将用户界面限制在中型和小型显示屏上。我们将讨论的主题包括如何使用
    Qt 的动态布局来处理方向变化。将使用 `QGraphicsScene`、`QGraphicsView` 和 `QGraphicsItem` 等类。还将讨论
    `QVBoxLayout`、`QGridLayout` 和 `QStackedLayout` 等布局 API。
- en: 'In this chapter we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Using Qt Creator and Qt Widgets to create a mobile app and run on the device
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Qt Creator 和 Qt Widgets 创建移动应用程序并在设备上运行
- en: Differences between desktop and mobile apps including screen size, memory, gestures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面应用程序和移动应用程序之间的差异，包括屏幕尺寸、内存、手势
- en: Using Qt Widgets in dynamic layouts for easy screen size and orientation changes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Qt Widgets 在动态布局中实现屏幕尺寸和方向变化的便捷性
- en: Using `QGraphicsView` for graphical apps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `QGraphicsView` 进行图形应用程序开发
- en: Hello mobile!
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嗨，移动世界！
- en: So you want to develop apps for mobile and embedded devices using Qt. Excellent
    choice, as Qt was made for cross-platform development. To get you started, we
    will run through the basic procedure of using Qt Creator to create, build and
    run an application. We will briefly examine different aspects to consider when
    creating mobile and embedded apps, such as how to use Qt Creator to add a menu.
    Adding a `QWidget` in the designer is not that difficult, and I will show you
    how.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你想使用 Qt 开发移动和嵌入式设备的应用程序，这是一个非常好的选择，因为 Qt 是为了跨平台开发而设计的。为了帮助你入门，我们将简要介绍使用 Qt Creator
    创建、构建和运行应用程序的基本步骤。我们将简要探讨在创建移动和嵌入式应用程序时需要考虑的不同方面，例如如何使用 Qt Creator 添加菜单。在设计师中添加
    `QWidget` 并不困难，我将向你展示如何操作。
- en: Qt has a long history of running on mobile devices, starting with Qt Embedded,
    which was initially released in 2000\. Qt Embedded was the base framework for
    the UI Qtopia, which was initially released on the Sharp Zaurus on the SL-5000D
    developer edition.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 在移动设备上运行有着悠久的历史，始于 2000 年首次发布的 Qt Embedded。Qt Embedded 是 UI Qtopia 的基础框架，最初在
    Sharp Zaurus 的 SL-5000D 开发版上发布。
- en: These days, you can develop an application using Qt and sell it in the iOS App
    Store, Android Google Play store, or other Linux mobile phones. Qt apps run on
    TVs and you can even see them running on entertainment systems in cars and planes.
    It runs on medical devices as well as industrial automation machines on factory
    floors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 Qt 开发应用程序，并在 iOS App Store、Android Google Play 商店或其他 Linux 移动手机上销售。Qt
    应用程序可以在电视上运行，你甚至可以看到它们在汽车和飞机的娱乐系统中运行。它还可以在医疗设备和工厂地面的工业自动化机器上运行。
- en: There are considerations for using Qt on mobile and embedded devices such as
    memory constraints and display size constraints. Mobiles have touchscreens, and
    embedded devices might not have screens at all.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动和嵌入式设备上使用 Qt 时需要考虑一些因素，例如内存限制和显示尺寸限制。手机有触摸屏，而嵌入式设备可能根本就没有屏幕。
- en: When you install Qt, you can use the Qt Creator IDE to edit, build and run your
    code. It's free and open source, so you can even customize it. I once had a patch
    that customized Qt Creator in a way that would allow me to print out all the keyboard
    commands that is was using, so I could have a quick reference sheet. Let's take
    a quick look at Qt Creator, that was once known as Workbench.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装 Qt 时，你可以使用 Qt Creator IDE 来编辑、构建和运行你的代码。它是免费和开源的，因此你可以对其进行自定义。我曾经有一个补丁，它以允许我打印出
    Qt Creator 所使用的所有键盘命令的方式自定义了 Qt Creator，这样我就可以有一个快速参考表。让我们快速了解一下 Qt Creator，它曾经被称为
    Workbench。
- en: Qt Creator
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Creator
- en: We are not going to go into any great detail about Qt Creator, but I thought
    I should mention it to demonstrate how we could go about using it to develop a
    cross-platform `QWidget` based application that runs on a desktop and mobile platform.
    Some differences between the two will be discussed. We'll then demonstrate how
    using dynamic layouts can help you target many different screen sizes and handle
    device orientation changes. You might already be familiar with Qt Creator, so
    we will refresh your memory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨 Qt Creator 的细节，但我认为应该提一下，以展示我们如何使用它来开发一个跨平台的基于 `QWidget` 的应用程序，该应用程序可以在桌面和移动平台上运行。我们将讨论两者之间的差异。然后，我们将演示如何使用动态布局来帮助您针对多种不同的屏幕尺寸并处理设备方向变化。您可能已经熟悉
    Qt Creator，所以我们将刷新您的记忆。
- en: Basic Qt Creator procedure
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本Qt Creator步骤
- en: 'The basic procedure for cross-compiling and building apps that run on a mobile
    device are straight forward after you get set up. The procedure that we would
    hypothetically follow is:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好环境后，跨编译和构建在移动设备上运行的应用程序的基本步骤是直接的。我们理论上会遵循以下步骤：
- en: File | New File or Project... | Qt Widgets Application, click the Choose...
    button
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件 | 新建文件或项目... | Qt Widgets 应用程序，点击选择...按钮
- en: Write some amazing code
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一些令人惊叹的代码
- en: Select the Projects icon on the left side of Qt Creator, then pick which target
    platform you want like Qt 5.12.0 for iOS
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Qt Creator 左侧选择“项目”图标，然后选择你想要的目标平台，例如为 iOS 选择 Qt 5.12.0。
- en: Hit *Ctrl* + *B*, or *Command* + *B* to build
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *B*，或 *Command* + *B* 构建
- en: Hit *Ctrl* + *R*, or *Command *+ *R* to run
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *R*，或 *Command* + *R* 运行
- en: Hit *F5*, or *Command* + *Y* to debug
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *F5*，或 *Command* + *Y* 调试
- en: For this first chapter, we will use Qt Widgets, which are UI elements that are
    more closely aligned to traditional desktop computer applications. They are still
    useful for mobile and embedded devices.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将使用 Qt Widgets，这些是更接近传统桌面计算机应用程序的 UI 元素。它们对移动和嵌入式设备仍然很有用。
- en: Qt Designer
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Designer
- en: Qt Creator comes with a design tool named Qt Designer. When you create a new
    template application, you will see a list of files on the left. It will open your
    application form in Qt Designer when you click on any `.ui` file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator 随附一个名为 Qt Designer 的设计工具。当您创建一个新的模板应用程序时，您将在左侧看到一个文件列表。当您点击任何 `.ui`
    文件时，它将在 Qt Designer 中打开您的应用程序表单。
- en: The source code can be found on the Git repository under the `Chapter01-a` directory,
    in the `cp1` branch.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在 Git 仓库的 `Chapter01-a` 目录下的 `cp1` 分支中找到。
- en: 'Navigate to Forms | mainwindow.ui and double click on that. This will open
    the UI file in Qt Creators Designer. A UI file is just a text file in the form
    of XML, and you can edit that file directly if you choose. The following image
    shows how it looks when opened in Qt Designer:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到表单 | mainwindow.ui 并双击。这将打开 UI 文件在 Qt Creator 的 Designer 中。UI 文件只是一个 XML
    格式的文本文件，如果您选择，可以直接编辑该文件。以下图片显示了在 Qt Designer 中打开时的样子：
- en: '![](img/1bead9f6-e9bb-419f-9340-5a7bcf8e06bb.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1bead9f6-e9bb-419f-9340-5a7bcf8e06bb.png)'
- en: Let's start with something just about every desktop application has—a Menu.
    Your mobile or embedded application might even need a Menu. As you can see, there
    is a template Menu that the Qt app wizard has produced for us. We need to customize
    this to make it usable. We can add some sub-menu items to demonstrate basic Qt
    Creator functionality.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从几乎每个桌面应用程序都有的菜单开始。您的移动或嵌入式应用程序可能也需要一个菜单。如您所见，Qt 应用程序向导已经为我们生成了一个模板菜单。我们需要对其进行自定义以使其可用。我们可以添加一些子菜单项来演示基本的
    Qt Creator 功能。
- en: Add a QMenu
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 QMenu
- en: 'Click on the application form where it says Menu to add menu items. Type in
    something like `Item1`, hit *Enter*. Add another menu item, as demonstrated in
    the following image:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 点击应用程序表单中标记为菜单的位置，添加菜单项。输入类似 `Item1` 的内容，按 *Enter*。添加另一个菜单项，如下图所示：
- en: '![](img/82d969a7-759d-4030-b93a-c91190d4a7c1.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82d969a7-759d-4030-b93a-c91190d4a7c1.png)'
- en: If you were to build this now, you would have an empty application with a Menu,
    so let's add more to demonstrate how to add widgets from the list of widgets that
    is on the left side of Qt Creator.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在构建它，您将得到一个带有菜单的空应用程序，所以让我们添加更多内容来演示如何从 Qt Creator 左侧的控件列表中添加控件。
- en: Add QListView
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 QListView
- en: Our UI form needs some content. We will build and run it for the desktop, then
    build and run it for the mobile simulator to compare the two. The procedure here
    is easy as drag and drop.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 UI 表单需要一些内容。我们将为桌面构建和运行它，然后为移动模拟器构建和运行它，以比较两者。这里的步骤很简单，就像拖放一样。
- en: 'On the left side of Qt Creator is a list of Widgets, Layouts and Spacers that
    you can simply drag and drop to place onto the template form and create your masterpiece
    Qt application. Let''s get started:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Creator的左侧是一个Widget、布局和间隔的列表，你可以简单地拖放它们到模板表单上，创建你的杰作Qt应用程序。让我们开始吧：
- en: Drag a ListView and drop it on the form.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动ListView并将其放置在表单上。
- en: '![](img/5406742a-752d-4b14-aef1-e23ed79bc91f.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5406742a-752d-4b14-aef1-e23ed79bc91f.png)'
- en: 'Select Desktop kit and build and run it by hitting the Run button. Qt Creator
    can build and run your application in the same step if you have made any changes
    to the form or source code. When you run it, the application should look similar
    to this image:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择桌面工具包，然后通过点击“运行”按钮来构建和运行它。如果你对表单或源代码进行了任何更改，Qt Creator可以在同一步骤中构建和运行你的应用程序。当你运行它时，应用程序应该看起来类似于以下图片：
- en: '![](img/fe198551-16f7-47ae-8020-da8a2b260b7f.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe198551-16f7-47ae-8020-da8a2b260b7f.png)'
- en: That's all fine and dandy, but it is not running on anything small like a phone.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切看起来都很完美，但它并没有在像手机这样的小设备上运行。
- en: Qt Creator comes with iOS and Android simulators, which you can use to see how
    your application will run on a small screened device. It is not an emulator, which
    is to say it does not try to emulate the device hardware, but simply simulates
    the machine. In effect, Qt Creator is building and running the target architectures.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator自带iOS和Android模拟器，你可以使用它们来查看你的应用程序在小型屏幕设备上的运行情况。它不是一个仿真器，也就是说，它并不试图模拟设备硬件，而只是模拟机器。实际上，Qt
    Creator正在构建和运行目标架构。
- en: 'Now select iOS Simulator kit, or `Android` from the Projects tool in green,
    as seen in the following image:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择iOS模拟器工具包，或在绿色项目工具中选择`Android`，如图所示：
- en: '![](img/72629807-bb30-405a-ab3a-2cbacfc573d0.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72629807-bb30-405a-ab3a-2cbacfc573d0.png)'
- en: Build and run it, which will start it in the simulator.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行它，这将启动它在模拟器中。
- en: 'Here is this app running on the iOS simulator:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个应用在iOS模拟器上的运行情况：
- en: '![](img/679053a5-fd4a-4a8c-8bfa-6bf647c0eae1.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/679053a5-fd4a-4a8c-8bfa-6bf647c0eae1.png)'
- en: There you go! You made a mobile app! Feels good, doesn't it? As you see, it
    looks slightly different in the simulator.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！你已经制作了一个移动应用！感觉不错，不是吗？正如你所见，它在模拟器中看起来略有不同。
- en: Going smaller, handling screen sizes
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整屏幕尺寸
- en: Porting applications which were developed for the desktop to run on smaller
    mobile devices can be a daunting task, depending on the application. Even creating
    new apps for mobiles, a few considerations need to be made, such as differences
    in screen resolution, memory constraints, and handling orientation changes. Touch
    screens add another fantastic way to offer touch gestures and can be challenging
    due to the differences in the size of a finger as point compared to a mouse pointer.
    Then there are sensors, GPS and networking to contemplate!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将为桌面开发的程序移植到较小的移动设备上可能是一项艰巨的任务，这取决于应用程序。即使是为移动设备创建新应用，也需要考虑一些因素，例如屏幕分辨率、内存限制以及处理方向变化。触摸屏增加了提供触摸手势的另一种奇妙方式，但由于手指点与鼠标指针大小的差异，可能会带来挑战！然后还有传感器、GPS和网络需要考虑！
- en: Screen resolution
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕分辨率
- en: As you can see in the previous images in the *Add QListView* section, the application
    paradigms are fairly different between desktop and mobile phones. When you move
    to an even smaller display, things start to get tricky in regards to fitting everything
    on the screen.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在“添加QListView”部分之前看到的图片所示，桌面和移动电话之间的应用程序范式相当不同。当你移动到一个更小的显示时，关于如何在屏幕上放置所有内容的问题开始变得棘手。
- en: Luckily, there are Qt Widgets that can help. The C++ classes `QScrollArea`,
    `QStackedWidget` and `QTabbedWidget` can show content more appropriately. Delegating
    your on-screen widgets to different pages will allow your users the same ease-of-navigation
    which a desktop application allows.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Qt Widgets可以帮助。C++类`QScrollArea`、`QStackedWidget`和`QTabbedWidget`可以更合适地显示内容。将你的屏幕小部件委托到不同的页面上，将允许你的用户享受到与桌面应用程序相同的导航便捷性。
- en: 'There might also be an issue on mobile devices while using `QMenu`. They can
    be long, unruly and have a menu tree that drills down too deeply for a small screen.
    Here''s a menu which works well on a desktop:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`QMenu`时，移动设备可能会有问题。它们可能很长、难以控制，并且菜单树对于小屏幕来说钻得太深。以下是一个在桌面上运行良好的菜单：
- en: '![](img/c1a1a823-53bb-46ab-a397-515e73f002b5.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c1a1a823-53bb-46ab-a397-515e73f002b5.png)'
- en: On a mobile device, the last items on this menu become unreachable and unusable.
    We need to redesign this!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动设备上，这个菜单的最后几项变得无法触及和无法使用。我们需要重新设计它！
- en: '![](img/d1788e62-d176-4bd3-a9c6-07fa94a416d6.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1788e62-d176-4bd3-a9c6-07fa94a416d6.png)'
- en: Menus can be fixed by eliminating them or refactoring them to reduce their depth,
    or by using something like a `QStackedWidget` to present the Menu options.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过消除菜单或重构以减少其深度，或者使用类似 `QStackedWidget` 的东西来展示菜单选项来固定菜单。
- en: Qt has support for high (**Dots Per Inch**) **DPI** displays. Newer versions
    of Qt automatically compensate for differences between high DPI and low DPI displays
    for iOS and the Wayland display server protocol. For Android, the environmental
    variable `QT_AUTO_SCALE_FACTOR` needs to be set to true. To test different scale
    factors, set `QT_SCALE_FACTOR`, which works best with an integer, typically 1
    or 2.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 支持高（**每英寸点数**）**DPI** 显示器。Qt 的新版本自动补偿 iOS 和 Wayland 显示服务器协议中高 DPI 和低 DPI
    显示器之间的差异。对于 Android，需要将环境变量 `QT_AUTO_SCALE_FACTOR` 设置为 true。要测试不同的缩放因子，设置 `QT_SCALE_FACTOR`，通常使用整数，通常是
    1 或 2。
- en: 'Let''s run through a few examples of widgets and how they can be better used
    on differing screens:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些小部件的例子和它们如何在不同的屏幕上更好地使用来运行一遍：
- en: Widgets like `QScrollBar` can be increased in size to better accommodate a finger
    as pointer, or better yet be hidden and use the widget itself to scroll. The UI
    usually needs to be simplified.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似 `QScrollBar` 的小部件可以增大尺寸，以便更好地适应手指作为指针，或者更好的是隐藏并使用小部件本身来滚动。UI通常需要简化。
- en: Long `QListViews` can present some challenges. You can try to filter or add
    a search feature for such long lists to make the data more accessible and eye
    pleasing on smaller displays.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长的 `QListViews` 可能会带来一些挑战。你可以尝试为这样的长列表添加筛选或搜索功能，以便在较小的显示上使数据更易于访问且更美观。
- en: Even `QStackedWidget` or `QTabbedWidget` can be too big. Don't make the user
    flick left or right more than a few pages. Anything more can be cumbersome and
    annoying for the user to be flicking endlessly to get at content.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使 `QStackedWidget` 或 `QTabbedWidget` 也可能太大。不要让用户左右翻页超过几页。更多内容可能会让用户感到繁琐和烦恼，不断翻页以获取内容。
- en: '`QStyleSheets` are a good way to scale for smaller display''s, allowing the
    developer to specify customizations to any widget. You can increase the padding
    and margins to make it easier for finger touch input. You can either set a style
    on a specific widget or apply it to the entire `QApplication` for a certain class
    of widget.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QStyleSheets` 是针对较小显示器的缩放的好方法，允许开发者对任何小部件进行自定义设置。你可以增加填充和边距，使其更容易进行手指触摸输入。你可以为特定的小部件设置样式，或者将其应用于整个
    `QApplication` 的某个类的小部件。'
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'or for one particular widget it would be:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于特定的小部件，可以这样：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s apply this only when there is a touch screen available on the device.
    It will make the button slightly bigger and easier to hit with a finger:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们只在设备上有触摸屏时应用这个样式。这将使按钮稍微大一些，更容易用手指点击：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you set one style with a style sheet, you will most likely need to customize
    the other properties and sub-controls as well. Applying one style sheet removes
    the default style.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用样式表设置了一个样式，你很可能还需要自定义其他属性和子控件。应用一个样式表会移除默认样式。
- en: 'Of course, it is also easy to set a style sheet in Qt Designer, just right
    click on the target widget and select, Change styleSheet from the context menu.
    As seen here on the Apple Mac:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在 Qt Designer 中设置样式表也很容易，只需在目标小部件上右键单击，并在上下文菜单中选择“更改样式表”。如下所示，在苹果 Mac 上：
- en: '![](img/97df5f88-44e3-4546-bdda-d93a8e20977a.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97df5f88-44e3-4546-bdda-d93a8e20977a.png)'
- en: Mobile phones and embedded devices have smaller displays, and they also have
    less RAM and storage.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 手机和嵌入式设备具有较小的显示屏，它们的RAM和存储空间也较少。
- en: Memory and storage
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存和存储
- en: Mobile phones and embedded devices usually have less memory than desktop machines. Especially
    for embedded devices both RAM and storage are limited.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 手机和嵌入式设备通常比桌面机器的内存要少。特别是对于嵌入式设备，RAM和存储空间都有限。
- en: The amount of storage space used can be lowered by optimizing images, compressing
    if needed. If different screen sizes are not used, the images can by manually
    resized instead of scaling at runtime.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过优化图像，如果需要则压缩，可以降低使用的存储空间。如果不使用不同的屏幕尺寸，可以手动调整图像大小，而不是在运行时缩放。
- en: There are also heap vs stack considerations which generally always pass arguments
    into functions by reference by using the `&` (ampersand) operator. You will notice
    this in the majority of Qt code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些堆栈考虑因素，通常总是通过使用 `&`（和号）运算符将参数按引用传递给函数。你将在大多数 Qt 代码中注意到这一点。
- en: Compiler optimizations can greatly effect both performance and the size of executables.
    In general, Qt's `qmake mkspec` build files are fairly good at using the correct
    optimizations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器优化可以极大地影响性能和可执行文件的大小。一般来说，Qt的`qmake mkspec`构建文件在正确使用优化方面做得相当不错。
- en: If storage space is a critical consideration, then building Qt yourself is a
    good idea. Configuring Qt using the `-no-feature-*` to configure out any Qt features
    you might not need is a good way to reduce it's footprint. For example, if a device
    has one static Ethernet cable connection and does not need network bearer management,
    simply configure Qt using `-no-feature-bearermanagement`. If you know you are
    not using SQL why ship those storage using libraries? Running configure with `--list-features`
    argument will list all the features available.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存储空间是一个关键考虑因素，那么自己构建Qt是一个好主意。使用`-no-feature-*`配置来排除可能不需要的任何Qt功能，这是一种减少其占用空间的好方法。例如，如果一个设备只有一个静态以太网连接并且不需要网络承载管理，只需使用`-no-feature-bearermanagement`配置Qt即可。如果你知道你不会使用SQL，为什么还要提供那些存储库？使用`--list-features`参数运行configure将列出所有可用的功能。
- en: Orientation
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方向
- en: Mobile devices move around (whodathunkit?) and sometimes it is better to view
    a particular app in landscape mode instead of portrait. On Android and iOS, responding
    to orientation changes are built in and occurs by default according to the users
    configuration. One thing you might need to do, is actually disable the orientation
    change.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备可以移动（谁会想到？）有时在横屏模式下查看特定应用程序比在竖屏模式下更好。在Android和iOS上，响应方向变化是内置的，并且默认根据用户的配置发生。你可能需要做的一件事，实际上是禁用方向变化。
- en: 'On **iOS**, you need to edit the `plist.info` file. For the key `UISupportedInterfaceOrientations`,
    you need to add the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在**iOS**上，你需要编辑`plist.info`文件。对于`UISupportedInterfaceOrientations`键，你需要添加以下内容：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On **Android**, edit the `AndroidManifest.xml` file `android:screenOrientation="landscape"`
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Android**上，编辑`AndroidManifest.xml`文件，将`android:screenOrientation="landscape"`设置为横向。
- en: If a picture frame device has a custom-built operating system, it might need
    it's photo viewing app to respond when the user switches orientations. That's
    where Qt Sensors can help out. More on that later in the first section of [Chapter
    7](0a6e358d-e771-458e-b68f-380149f259a0.xhtml), *Machines Talking*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个图片框架设备有一个定制的操作系统，它可能需要其照片查看应用程序在用户切换方向时做出响应。这就是Qt传感器能提供帮助的地方。关于这一点，稍后将在第7章的第一部分[机器对话](0a6e358d-e771-458e-b68f-380149f259a0.xhtml)中详细介绍。
- en: Gestures
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手势
- en: Touchscreen gestures are another way mobiles are different to desktops. Multi-touch
    screens have revolutionized the device world. `QPanGesture`, `QPinchGesture` and
    `QSwipeGesture` can be used to great effect on these devices, and Qt Quick has
    components build for this type of thing—`Flickable`, `SwipeView`, `PinchArea`
    and others. More on Qt Quick later.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 触屏手势是移动设备与桌面设备不同的另一种方式。多点触控屏幕彻底改变了设备世界。`QPanGesture`、`QPinchGesture`和`QSwipeGesture`可以在这类设备上发挥巨大作用，Qt
    Quick也为此类功能提供了组件——`Flickable`、`SwipeView`、`PinchArea`等。关于Qt Quick的更多内容将在稍后介绍。
- en: To use `QGestures`, first create a `QList` of containing the gestures you want
    to handle, and call the `grabGesture` function for the target widget.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`QGestures`，首先创建一个包含你想要处理的动作手势的`QList`，然后为目标小部件调用`grabGesture`函数。
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You will need to derive from and then override the widgets event loop to handle
    when the event happens.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从并覆盖小部件的事件循环来处理事件发生时的情况。
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To do something useful with the gesture, we could handle it like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要对手势进行有用的处理，我们可以这样处理：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Devices with sensors also have access to `QSensorGesture`, which enable motion
    gestures such as shake. More on that later, in [Chapter 7](0a6e358d-e771-458e-b68f-380149f259a0.xhtml), *Machines
    Talking*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 搭载传感器的设备还可以访问`QSensorGesture`，这允许实现如摇动等动作手势。关于这一点，稍后将在第7章[机器对话](0a6e358d-e771-458e-b68f-380149f259a0.xhtml)中详细介绍。
- en: Dynamic layouts
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态布局
- en: Considering that mobile phones come in all shapes and sizes, it would be ridiculous
    to need to provide a different package for every different screen resolution.
    Hence we will use dynamic layouts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到手机有各种各样的形状和大小，需要为每个不同的屏幕分辨率提供不同的包是荒谬的。因此，我们将使用动态布局。
- en: The source code can be found on the Git repository under the `Chapter01-layouts` directory,
    in the `cp1` branch.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在Git仓库的`Chapter01-layouts`目录下的`cp1`分支中找到。
- en: Qt Widgets have support for this using classes such as `QVBoxLayout` and `QGridLayout`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Qt小部件支持使用`QVBoxLayout`和`QGridLayout`等类来实现这一功能。
- en: Qt Creator's designer is the easiest way to develop dynamic layouts. Let's go
    through how we can do that.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator的设计器是开发动态布局的最简单方式。让我们看看我们如何做到这一点。
- en: 'To set up a layout, we position a widget on the application form, and press *Command*
    or *Control* on the keyboard while selecting the widgets that we want to put in
    a layout. Here are two `QPushButtons` selected for use:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置布局，我们在应用程序表单上放置一个小部件，然后在键盘上按住*Command*或*Control*键，同时选择我们想要放入布局中的小部件。这里有两个选定的`QPushButtons`用于使用：
- en: '![](img/2d581605-39ce-43db-a05a-0598e7abfd38.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d581605-39ce-43db-a05a-0598e7abfd38.png)'
- en: 'Next, click on the Horizontal Layout icon highlighted here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击此处突出显示的水平布局图标：
- en: '![](img/d41f07bf-9db4-4e1c-9ffe-45fb8867935f.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d41f07bf-9db4-4e1c-9ffe-45fb8867935f.png)'
- en: 'You will then see the two widgets enclosed by a thin red box as in the following
    screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到两个被薄红色框包围的小部件，如下面的截图所示：
- en: '![](img/dd780f36-b362-4146-9bb6-c1851af0f4dc.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd780f36-b362-4146-9bb6-c1851af0f4dc.png)'
- en: Now repeat this for the remaining widgets.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为剩余的小部件重复此操作。
- en: 'To make the widgets expand and resize with the form, click on the background
    and select Grid Layout:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要使小部件随着表单扩展和调整大小，请点击背景并选择网格布局：
- en: '![](img/5b78d085-2083-451f-9e1d-2802abe677df.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b78d085-2083-451f-9e1d-2802abe677df.png)'
- en: 'Save and build this, and this app will now be able to resize for orientation
    changes as well as being able to work on different sized screens. Notice how this
    looks like in portrait (vertical) orientation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并构建此应用程序，现在它将能够根据方向变化调整大小，并且能够在不同尺寸的屏幕上工作。注意在纵向（垂直）方向上的外观：
- en: '![](img/507a6a4b-2153-489e-9f71-eb2c6452e54b.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/507a6a4b-2153-489e-9f71-eb2c6452e54b.png)'
- en: 'Also note how this same application looks in landscape (horizontal) orientation:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意此应用程序在横向（水平）方向上的外观：
- en: '![](img/709eb346-27da-49b3-910a-e298d7bf7408.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/709eb346-27da-49b3-910a-e298d7bf7408.png)'
- en: As you can see, this application can change with orientation changes, but all
    the widgets are visible and usable. Using `QSpacer` will help guide the widgets
    and layouts positioning. They can push the widgets together, apart, or hold some
    to one side or another.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此应用程序可以随着方向的变化而变化，但所有小部件都可见且可使用。使用`QSpacer`可以帮助引导小部件和布局定位。它们可以将小部件推到一起，分开，或将一些小部件保持在一边或另一边。
- en: 'Of course, layouts can be used without touching Qt Designer. For example the
    following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以在不接触Qt Designer的情况下使用布局。例如以下代码：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`QLayout` and friends are the key to writing a cross-platform application that
    can accommodate the myriad screen resolutions and dynamically changing orientations
    of the target devices.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLayout`及其相关内容是编写能够适应目标设备众多屏幕分辨率和动态变化方向的跨平台应用程序的关键。'
- en: Graphics view
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形视图
- en: '`QGraphicsView`, `QGraphicScene` and `QGraphicsItem` provide a way for applications
    based on Qt Widgets to show 2D graphics.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGraphicsView`、`QGraphicScene`和`QGraphicsItem`为基于Qt Widgets的应用程序显示2D图形提供了一种方式。'
- en: The source code can be found on the Git repository under the `Chapter01-graphicsview` directory,
    in the `cp1` branch.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码可以在Git仓库的`Chapter01-graphicsview`目录下的`cp1`分支中找到。
- en: Every `QGraphicsView` needs a `QGraphicsScene`. Every `QGraphicsScene` needs
    one or more `QGraphicsItem`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`QGraphicsView`都需要一个`QGraphicsScene`。每个`QGraphicsScene`都需要一个或多个`QGraphicsItem`。
- en: '`QGraphicsItem` can be any of the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGraphicsItem`可以是以下任何一种：'
- en: '`QGraphicsEllipseItem`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGraphicsEllipseItem`'
- en: '`QGraphicsLineItem`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGraphicsLineItem`'
- en: '`QGraphicsLineItem`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGraphicsLineItem`'
- en: '`QGraphicsPathItem`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGraphicsPathItem`'
- en: '`QGraphicsPixmapItem`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGraphicsPixmapItem`'
- en: '`QGraphicsPolygonItem`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGraphicsPolygonItem`'
- en: '`QGraphicsRectItem`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGraphicsRectItem`'
- en: '`QGraphicsSimpleTextItem`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGraphicsSimpleTextItem`'
- en: '`QGraphicsTextItem`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGraphicsTextItem`'
- en: 'Qt Designer has support for adding `QGraphicsView` . You can follow these steps
    to do so:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Designer支持添加`QGraphicsView`。您可以按照以下步骤进行操作：
- en: Drag the `QGraphicsView` to a new application form and fill the form with a
    `QGridLayout` like we did before.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`QGraphicsView`拖动到新的应用程序表单中，并使用与之前相同的`QGridLayout`填充表单。
- en: '![](img/d3ee54ba-fcb9-4e35-8eb2-23bde797938a.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3ee54ba-fcb9-4e35-8eb2-23bde797938a.png)'
- en: Implement a `QGraphicsScene` in the source code and add it to the `QGraphicsView`
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源代码中实现`QGraphicsScene`并将其添加到`QGraphicsView`
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Define a rectangle which will be the extent of the `Scene`. Here it is smaller
    than the size of the graphics view so we can go on and define some collision detection.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个矩形，它将是`Scene`的范围。这里它比图形视图的大小小，因此我们可以继续定义一些碰撞检测。
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create a red rectangle to show the bounding rectangle. To make it a red color,
    create a `QPen` which will be used to paint the rectangle and then add the rectangle
    to the `Scene`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个红色矩形来显示边界矩形。为了使其呈现红色，创建一个 `QPen`，它将被用来绘制矩形，然后将矩形添加到 `Scene` 中。
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Build and run the application. You will notice an app with a red bordered square
    on it.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。你会注意到一个带有红色边框正方形的程序。
- en: As mentioned before, `QGraphicsView` shows `QGraphicsItems`. If we want to add
    some collision detection we need to subclass `QGraphicsSimpleTextItem`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`QGraphicsView` 显示 `QGraphicsItems`。如果我们想添加一些碰撞检测，我们需要从 `QGraphicsSimpleTextItem`
    中派生一个子类。
- en: 'The header file for this is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 该头文件的格式如下：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This custom class derived from `QGraphicsSimpleTextItem` will reimplement the
    `paint(..)` function, and use the `collidingItems(...)` function of `scene` to
    detect when something collides with our text object. Normally, `collidingItems`
    will return a `QList` of `QGraphicsItems`, but here it is just used to detect
    if any items are colliding.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个从 `QGraphicsSimpleTextItem` 派生的自定义类将重新实现 `paint(..)` 函数，并使用 `scene` 的 `collidingItems(...)`
    函数来检测何时有东西与我们的文本对象发生碰撞。通常，`collidingItems` 会返回一个 `QList` 的 `QGraphicsItems`，但在这里它只是用来检测是否有任何项目发生碰撞。
- en: Since this class holds only one item, it is known which item it is. If a collision
    is detected, the text changes. We don't need to check if the item's text is different
    before we change it, as the parent class's `setText(...)` does that for us.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个类只包含一个项目，因此我们知道它是哪个项目。如果检测到碰撞，文本会改变。在我们更改文本之前，我们不需要检查项目文本是否不同，因为父类的 `setText(...)`
    方法已经为我们做了这件事。
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now create our `TextGraphic` object and add it to the `Scene` to use.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建我们的 `TextGraphic` 对象，并将其添加到 `Scene` 中以使用。
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you build and run this, notice the `text` object will not move if we try
    to drag it around. `QGraphicsItems` have a `flag` property called `QGraphicsItem::ItemIsMovable`
    that can be set to allow it to be moved around, either by the user or programmatically:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建并运行此应用程序，请注意，如果我们尝试拖动它，`text` 对象将不会移动。`QGraphicsItems` 有一个名为 `QGraphicsItem::ItemIsMovable`
    的 `flag` 属性，可以设置为允许它被移动，无论是通过用户还是通过程序：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we build and run this, you can grab the `text` object and move it around.
    If it goes beyond our bounding rectangle, it will change text, only returning
    to the original text if it moves inside the red box again.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建并运行此应用程序时，你可以抓住 `text` 对象并四处移动。如果它超出我们的边界矩形，文本将改变，只有在它再次移动到红色框内时才会返回原始文本。
- en: If you wanted to animate this, just throw in a timer and change the `text` object's
    position when the timer fires.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对它进行动画处理，只需添加一个计时器，并在计时器触发时更改 `text` 对象的位置。
- en: Even with Qt Quick's software renderer, `QGraphicsView` is still a viable solution
    for graphics animation. If the target device's storage space is really tight,
    there might not be enough space to add Qt Quick libraries. Or a legacy app might
    be difficult to import to Qt Quick.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用 Qt Quick 的软件渲染器，`QGraphicsView` 仍然是一个可行的图形动画解决方案。如果目标设备的存储空间非常紧张，可能没有足够的空间来添加
    Qt Quick 库。或者，一个遗留应用程序可能难以导入到 Qt Quick 中。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter we covered some of the issues facing mobile and embedded developers
    when trying to develop for smaller display devices, and how  `QStyleSheets` can
    be used to change the interface at runtime to adapt itself for using touchscreen
    inputs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了移动和嵌入式开发者在尝试为较小显示设备开发时面临的一些问题，以及如何使用 `QStyleSheets` 在运行时更改界面以适应触摸屏输入。
- en: We discussed storage and memory space requirements, and the need to configure
    unneeded features out of Qt to make it have a smaller footprint.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了存储和内存空间需求，以及配置 Qt 中不必要的功能以使其具有更小占位符的需求。
- en: We went through handling orientation changes and discussed using screen gestures
    such as `Pinch` and `Swipe`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了处理方向变化，并讨论了使用屏幕手势，如 `Pinch` 和 `Swipe`。
- en: We learning how to use Qt Designer to add `QLayouts` to create dynamically resizing
    applications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用 Qt Designer 添加 `QLayouts` 来创建动态调整大小的应用程序。
- en: Finally, we discussed how to use `QGraphicsView` to utilize graphical elements
    such as graphical text and images.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了如何使用 `QGraphicsView` 来利用图形元素，例如图形文本和图像。
- en: Next, we will go through the next best thing since sliced bread for mobile and
    embedded development—Qt Quick and QML. Then we'll crack on with the real fancy
    stuff about graphical effects to spice up any interface!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨移动和嵌入式开发中继切片面包之后最好的东西——Qt Quick 和 QML。然后我们将深入探讨有关图形效果的真实精彩内容，以增强任何界面！
