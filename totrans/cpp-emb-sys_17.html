<html><head></head><body>
<div><h1 class="chapterNumber">13</h1>
<h1 class="chapterTitle" id="_idParaDest-180">Working with C Libraries</h1>
<p class="normal">In <a href="Chapter_06.xhtml"><em class="italic">Chapter 6</em></a>, we discussed interoperability between C and C++. We learned about language linkage and how to use it to include C libraries in a C++ project. From the technical standpoint, that’s all we need to use C in C++.</p>
<p class="normal">In this chapter, we’ll focus on software development techniques for integrating C libraries into a C++ project to enhance code flexibility. Since<a id="_idIndexMarker586"/> many C++ projects still rely on vendor-provided C <strong class="keyWord">hardware abstraction layers</strong> (<strong class="keyWord">HALs</strong>), we’ll concentrate on how to effectively incorporate these C libraries into our projects.</p>
<p class="normal">Additionally, this chapter will cover<a id="_idIndexMarker587"/> the <strong class="keyWord">Resource Acquisition is Initialization</strong> (<strong class="keyWord">RAII</strong>) paradigm and explain why it’s particularly beneficial in embedded systems. By automatically managing resource allocation and deallocation, RAII greatly reduces the risk of leaks and other resource misuse issues, which is especially important in resource-limited embedded environments.</p>
<p class="normal">In this chapter, we’re going to cover the following main topics: </p>
<ul>
<li class="bulletList">Using C HAL in C++ projects</li>
<li class="bulletList">Static classes</li>
<li class="bulletList">Using RAII for wrapping <code class="inlineCode">LittleFs</code> C library</li>
</ul>
<h1 class="heading-1" id="_idParaDest-181">Technical requirements</h1>
<p class="normal">The examples from this chapter are available on GitHub (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter13">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter13</a>). To get the most out of this chapter, run the examples in the Renode simulator.</p>
<h1 class="heading-1" id="_idParaDest-182">Using C HAL in C++ projects</h1>
<p class="normal">In <a href="Chapter_12.xhtml"><em class="italic">Chapter 12</em></a>, we <a id="_idIndexMarker588"/>explored the benefits of using C++ for HAL development. However, despite these advantages, target vendors provide HALs as C libraries. These libraries have been thoroughly tested on millions of devices worldwide, and vendors usually maintain them well, offering regular updates. Thus, it makes more sense to use them rather than re-implement the HAL in C++.</p>
<p class="normal">Next, we will create an interface-based design for the UART peripheral, which will provide us with a more flexible software design and allow us to decouple components that are using the UART interface from low-level details.</p>
<h2 class="heading-2" id="_idParaDest-183">UART interface for flexible software design</h2>
<p class="normal">In <a href="Chapter_05.xhtml"><em class="italic">Chapter 5</em></a>, we <a id="_idIndexMarker589"/>covered the importance of interfaces for flexible software design. There, we had an <code class="inlineCode">uart</code> interface class that was implemented by the <code class="inlineCode">uart_stm32</code> class. The <code class="inlineCode">gsm_lib</code> class depended on the <code class="inlineCode">uart</code> interface, meaning we can reuse it with different <code class="inlineCode">uart</code> interface implementations.</p>
<p class="normal">The <code class="inlineCode">uart_stm32</code> class from <a href="Chapter_05.xhtml"><em class="italic">Chapter 5</em></a> had a simple implementation for demo purposes. It used the <code class="inlineCode">printf</code> and <code class="inlineCode">putc</code> functions from the C standard library to write messages on standard output. We will now go through the actual implementation of the <code class="inlineCode">uart_stm32</code> class that’s already been used in all the examples in the book’s GitHub repo, enabling us to see the output in the Renode simulator. Let’s start from the <code class="inlineCode">uart</code> interface <code class="inlineCode">class</code> with the code shown here:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdint&gt;
#include &lt;span&gt;
namespace hal
{
class uart
{
  public:
    virtual void init(std::uint32_t baudrate) = 0;
    virtual void write(std::span&lt;const char&gt; data) = 0;
};
}; // namespace hal
</code></pre>
<p class="normal">The <code class="inlineCode">uart</code> interface<a id="_idIndexMarker590"/> is a simple class with two virtual methods:</p>
<ul>
<li class="bulletList"><code class="inlineCode">virtual void init(std::uint32_t baudrate)</code>: A method used to initialize the UART peripheral with a single parameter – <code class="inlineCode">baudrate</code>.</li>
<li class="bulletList"><code class="inlineCode">virtual void write(std::span&lt;const char&gt; data)</code>: A method used to send data over the UART peripheral. It has a <code class="inlineCode">std::span&lt;const char&gt;</code> parameter in contrast to the usual C approach with a pointer to the data buffer and length. Using <code class="inlineCode">std::span</code> increases the memory safety of the code.</li>
</ul>
<p class="normal">Next, let us go through the <code class="inlineCode">uart_stm32</code> class definition:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;span&gt;
#include &lt;cstdint&gt;
#include &lt;uart.hpp&gt;
#include &lt;stm32f0xx_hal.h&gt;
#include &lt;stm32f072xb.h&gt;
namespace hal
{
class uart_stm32 : public uart
{
  public:
    uart_stm32(USART_TypeDef *inst);
    void init(std::uint32_t baudrate = c_baudrate_default);
    void write(std::span&lt;const char&gt; data) override;
  private:
    UART_HandleTypeDef huart_;
    USART_TypeDef *instance_;
    std::uint32_t baudrate_;
    <code class="inlineCode">static</code> constexpr std::uint32_t c_baudrate_default = 115200;
};
}; // namespace hal
</code></pre>
<p class="normal">In the <code class="inlineCode">uart_stm32</code> class <a id="_idIndexMarker591"/>definition, we can notice the following:</p>
<ul>
<li class="bulletList">Overridden virtual methods <code class="inlineCode">init</code> and <code class="inlineCode">write</code> from the <code class="inlineCode">uart</code> interface.</li>
<li class="bulletList">A constructor accepting a pointer to <code class="inlineCode">USART_TypeDef</code>. This type is a <code class="inlineCode">struct</code> that describes the UART peripheral register layout in the CMSIS header <code class="inlineCode">stm32f072xb.h</code>.</li>
<li class="bulletList">Among the private members, we see <code class="inlineCode">UART_HandleTypeDef</code>, a type defined in ST HAL in the file <code class="inlineCode">stm32f0xx_hal_uart.h</code>.</li>
</ul>
<p class="normal">Next, let us go through the implementation of the constructor and methods from the <code class="inlineCode">uart_stm32</code> class in this code:</p>
<pre class="programlisting code"><code class="hljs-code">hal::uart_stm32::uart_stm32(USART_TypeDef *inst): instance_(inst)
{
}
</code></pre>
<p class="normal">In this code, we see the implementation of the <code class="inlineCode">uart_stm32</code> constructor. It just sets the private member <code class="inlineCode">USART_TypeDef *instance_</code> using the initializer list syntax. CMSIS defines the macros <code class="inlineCode">USART1</code>, <code class="inlineCode">USART2</code>, <code class="inlineCode">USART3</code>, and <code class="inlineCode">USART4</code>, which specify the addresses of these peripherals and which we can use to initialize the <code class="inlineCode">uart_stm32</code> object.</p>
<p class="normal">The <code class="inlineCode">uart</code> interface defines the <code class="inlineCode">init</code> method, as UART peripheral initialization depends on other hardware initializations (i.e., clock configuration). If we implemented the initialization within the constructor, we might run into issues if someone defines a <code class="inlineCode">global</code> or <code class="inlineCode">static</code> <code class="inlineCode">uart_stm32</code> object. The <code class="inlineCode">init</code> method is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">void hal::uart_stm32::init(std::uint32_t baudrate)
{
    huart_.Instance = instance_;
    huart_.Init.BaudRate = baudrate;
    huart_.Init.WordLength = UART_WORDLENGTH_8B;
    huart_.Init.StopBits = UART_STOPBITS_1;
    huart_.Init.Parity = UART_PARITY_NONE;
    huart_.Init.Mode = UART_MODE_TX_RX;
    huart_.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart_.Init.OverSampling = UART_OVERSAMPLING_16;
    huart_.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
    huart_.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
    huart_.MspInitCallback = nullptr;
    HAL_UART_Init(&amp;huart_);
}
</code></pre>
<p class="normal">In the <code class="inlineCode">init</code> method, we<a id="_idIndexMarker592"/> initialize the member <code class="inlineCode">UART_HandleTypeDef huart_</code> with the following configuration:</p>
<ul>
<li class="bulletList"><code class="inlineCode">instance_</code>: The address to the UART peripheral selected in the constructor</li>
<li class="bulletList"><code class="inlineCode">baudrate</code></li>
<li class="bulletList">8-bit word length</li>
<li class="bulletList">1 stop bit</li>
<li class="bulletList">Both TX and RX mode</li>
<li class="bulletList">No hardware control</li>
</ul>
<p class="normal">We also set <code class="inlineCode">MspInitCallback</code> to <code class="inlineCode">nullptr</code>. We make a call to the ST HAL <code class="inlineCode">HAL_UART_Init</code> function providing it<a id="_idIndexMarker593"/> with a pointer to <code class="inlineCode">huart_</code>. Please note that for the sake of example simplicity, there is no error handling. Error handling is an important step, and return codes from HAL should be appropriately handled in code.</p>
<p class="normal">Next, we will go through the implementation of the <code class="inlineCode">write</code> method shown here:</p>
<pre class="programlisting code"><code class="hljs-code">void hal::uart_stm32::write(std::span&lt;const char&gt; data)
{
    // we must cast away constness due to ST HAL’s API
char * data_ptr = const_cast&lt;char *&gt;(data.data());
    HAL_UART_Transmit(&amp;huart_,
                     reinterpret_cast&lt;uint8_t *(data_ptr),
                     data.size(),
                     HAL_MAX_DELAY);
}
</code></pre>
<p class="normal">In the <code class="inlineCode">write</code> method, we are making a call to <code class="inlineCode">HAL_UART_Transmit</code> from ST HAL, by passing the data pointer and data size from the <code class="inlineCode">std::span&lt;const char&gt; data</code> parameter. It’s worth noting that we need to cast away constness as the C <code class="inlineCode">HAL_UART_Transmit</code> function doesn’t accept the const pointer to data. This is only safe to do if we are sure that the function we are passing the pointer with cast away constness is not trying to modify its content.</p>
<p class="normal">Next, we will analyze this approach from the perspective of software design and patterns used.</p>
<h2 class="heading-2" id="_idParaDest-184">The UART interface in the Adapter pattern</h2>
<p class="normal">The<a id="_idIndexMarker594"/> relationship between <a id="_idIndexMarker595"/>all the software components in this example (the <code class="inlineCode">uart</code> interface, the <code class="inlineCode">uart_stm32</code> implementation of the interface, and the ST HAL) can be represented by the following UML diagram:</p>
<figure class="mediaobject"><img alt="Figure 13.1 – The uart_stm32 class diagram" src="img/B22402_13_01.png"/></figure>
<p class="packt_figref">Figure 13.1 – The uart_stm32 class diagram</p>
<p class="normal">In <em class="italic">Figure 13.1</em>, we see the UML class diagram of the <code class="inlineCode">uart_stm32</code> class. This class effectively implements the <strong class="keyWord">Adapter design pattern</strong>, which is a structural design pattern used to allow classes with <a id="_idIndexMarker596"/>incompatible interfaces to work together. The <a id="_idIndexMarker597"/>Adapter pattern involves creating an adapter class that wraps an existing class (or module) and provides a new interface that the client expects.</p>
<p class="normal">In our case, even though <code class="inlineCode">stm32f0xx_hal_uart</code> is a C module rather than a C++ class, the <code class="inlineCode">uart_stm32</code> class serves as an adapter by encapsulating the C-based HAL code and exposing it through the C++ <code class="inlineCode">uart</code> interface. This adaptation allows other classes or clients in the system, such as a <code class="inlineCode">GSM</code> library, to interact with the UART hardware using the standardized C++ interface, without needing to concern themselves with the underlying C implementation details.</p>
<p class="normal">Let us analyze this approach from the perspective of the <code class="inlineCode">uart</code> interface client, such as a <code class="inlineCode">GSM</code> library that is implemented in the <code class="inlineCode">gsm_lib</code> class, with this definition:</p>
<pre class="programlisting code"><code class="hljs-code">class gsm_lib{
    public:
        gsm_lib(hal::uart &amp;u) : uart_(u) {}
        // other methods
private:
        hal::uart &amp;uart_;
};
</code></pre>
<p class="normal">In this code, we see an example of a simple client of the <code class="inlineCode">uart</code> interface – <code class="inlineCode">gsm_lib</code> – with a constructor that initializes the reference <code class="inlineCode">hal::uart &amp;uart_</code>. This approach is called <strong class="keyWord">dependency injection</strong>. The <a id="_idIndexMarker598"/>dependency of the <code class="inlineCode">gsm_lib</code> class is constructed externally and supplied to the class as a reference through the constructor. Depending on the interface also enables loose coupling, which brings the following benefits:</p>
<ul>
<li class="bulletList"><code class="inlineCode">gsm_lib</code> is not interested in the implementation details of the <code class="inlineCode">uart</code> interface. It doesn’t need to know about baud rate, hardware settings, etc.</li>
<li class="bulletList"><code class="inlineCode">gsm_lib</code> is not tied to a particular target. We can reuse it on different platforms by implementing the <code class="inlineCode">uart</code> interface on those platforms.</li>
<li class="bulletList">Software<a id="_idIndexMarker599"/> testing of <code class="inlineCode">gsm_lib</code> is easy as we can mock the <code class="inlineCode">uart</code> interface and instantiate<a id="_idIndexMarker600"/> the <code class="inlineCode">gsm_lib</code> object with the mocked object used in tests.</li>
</ul>
<p class="normal">Instead of directly using the C HAL library in the <code class="inlineCode">uart_stm32</code> class, we can wrap the functions from the C library in a so-called <code class="inlineCode">static</code> class with the direct mapping of all parameters.</p>
<h1 class="heading-1" id="_idParaDest-185">Introducing static classes</h1>
<p class="normal">The <code class="inlineCode">static</code> class concept that we will <a id="_idIndexMarker601"/>discuss here doesn’t exist in the C++ language standard. We are borrowing it from languages such as C#, where it is defined as a class that contains only <code class="inlineCode">static</code> members and methods. It can’t be instantiated. In C#, a <code class="inlineCode">static</code> class is declared using the <code class="inlineCode">static</code> keyword.</p>
<p class="normal">In C++, a <code class="inlineCode">static</code> class can be created by defining a class with all <code class="inlineCode">static</code> methods and members and by deleting the default constructor. Deleting the constructor ensures that no instances of the class can be created, enforcing this at compile time. Disabling instantiation signals a clear intent to the user: <em class="italic">This is a </em><code class="inlineCode">static</code><em class="italic"> class. The functions you’re using don’t rely on any instance-specific states, as no instances exist. If there’s any internal state, it’s shared and will affect everyone using the class</em>.</p>
<p class="normal">We will modify the previous example and create a <code class="inlineCode">uart_c_hal</code> <code class="inlineCode">static</code> class to wrap UART C HAL functions, as shown in this code:</p>
<pre class="programlisting code"><code class="hljs-code"><code class="inlineCode">struct</code> uart_c_hal {
    uart_c_hal() = delete;
    static inline HAL_StatusTypeDef init(UART_HandleTypeDef *huart)
    {
        return HAL_UART_Init(huart);
    }
    static inline HAL_StatusTypeDef transmit(UART_HandleTypeDef *huart,
uint8_t *pData,
uint16_t Size,
uint32_t Timeout)
    {
        return HAL_UART_Transmit(huart, pData, Size, Timeout);
    }
};
</code></pre>
<p class="normal">In this code, we <a id="_idIndexMarker602"/>simply mapped C functions in <code class="inlineCode">static</code> methods of the class <code class="inlineCode">uart_c_hal</code>. Next, we will modify the <code class="inlineCode">uart_stm32</code> class to use <code class="inlineCode">uart_c_hal</code>, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename HalUart&gt;
class uart_stm32 : public uart
{
  public:
    uart_stm32(USART_TypeDef *inst) : instance_(inst) {}
    void init(std::uint32_t baudrate = c_baudrate_default) override {
      huart_.Instance = instance_;
      huart_.Init.BaudRate = baudrate;
      // ...
// init huart_ <code class="inlineCode">struct</code>
      HalUart::init(&amp;huart_);
    }
    void write(std::span&lt;const char&gt; data) override {
      // we must cast away costness due to ST HAL’s API
char * data_ptr = const_cast&lt;char *&gt;(data.data());
      HalUart::transmit(&amp;huart_,
  reinterpret_cast&lt;uint8_t *(data_ptr),
         data.size(),
   HAL_MAX_DELAY);
    }
  private:
    UART_HandleTypeDef huart_;
    USART_TypeDef *instance_;
    std::uint32_t baudrate_;
    static constexpr std::uint32_t c_baudrate_default = 115200;
};
</code></pre>
<p class="normal">In this code, we see <a id="_idIndexMarker603"/>that <code class="inlineCode">uart_stm32</code> is now a template class that uses the methods <code class="inlineCode">init</code> and <code class="inlineCode">transmit</code> from the template parameter <code class="inlineCode">HalUart</code>. Now we can use the class template, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">uart_stm32&lt;uart_c_hal&gt; uart(USART2);
uart.init();
gsm_lib gsm(uart);
</code></pre>
<p class="normal">The <code class="inlineCode">uart_stm32</code> class template still implements the <code class="inlineCode">uart</code> interface, meaning we can still use it with the <code class="inlineCode">gsm_lib</code> class. Wrapping C HAL functions in a <code class="inlineCode">static</code> class and adjusting <code class="inlineCode">uart_stm32</code> to use it through a template parameter decouples C HAL from the <code class="inlineCode">uart_stm32</code> implementation. This makes it possible to test the <code class="inlineCode">uart_stm32</code> class off-target, as it doesn’t depend on platform-specific code anymore.</p>
<p class="normal">Static classes are <a id="_idIndexMarker604"/>one way of using C libraries in C++ projects. They allow us to encapsulate functions from C libraries in types that can be passed to C++ classes through template arguments, making the code more flexible and easier to test.</p>
<p class="normal">Next, we will see how to apply the RAII technique to effectively wrap the <strong class="keyWord">little fail-safe</strong> (<code class="inlineCode">littlefs</code>) filesystem C library.</p>
<h1 class="heading-1" id="_idParaDest-186">Using RAII for wrapping the littlefs C library</h1>
<p class="normal">RAII is a<a id="_idIndexMarker605"/> simple yet powerful C++ technique used to manage resources through an object’s lifetime. Resources can represent different things. Resources are acquired when an object’s lifetime begins, and they are released when the object’s lifetime ends.</p>
<p class="normal">The technique is used to manage resources such as dynamically allocated memory. To ensure that the memory is released and avoid memory leaks, the recommendation is to use dynamic allocation only internally in classes. When an object is instantiated, the constructor will allocate memory, and when the object goes out of scope, the destructor will release the allocated memory.</p>
<p class="normal">The RAII technique can be applied to other resources beyond the dynamically allocated memory, such as files, and<a id="_idIndexMarker606"/> we will apply it to the <code class="inlineCode">littlefs</code> filesystem library (<a href="https://github.com/littlefs-project/littlefs">https://github.com/littlefs-project/littlefs</a>). We will start with a short overview of <code class="inlineCode">littlefs</code> – a filesystem designed for microcontrollers.</p>
<h2 class="heading-2" id="_idParaDest-187">LittleFS – a filesystem for microcontrollers</h2>
<p class="normal">The <code class="inlineCode">littlefs</code> filesystem<a id="_idIndexMarker607"/> is designed for microcontrollers featuring the following:</p>
<ul>
<li class="bulletList"><strong class="screenText">Power-loss resilience</strong>: It is built to handle unexpected power failures. In the case of power loss, it will fall back to the last known good state.</li>
<li class="bulletList"><strong class="screenText">Dynamic wear leveling</strong>: It is optimized for flash memory, offering wear leveling across dynamic blocks. It also includes mechanisms to detect and bypass bad blocks, ensuring reliable performance over time.</li>
<li class="bulletList"><strong class="screenText">Bounded RAM/ROM</strong>: It is optimized for low memory usage. RAM consumption remains constant, regardless of filesystem size, with no unbounded recursion. Dynamic memory is limited to configurable buffers, which can be set up as <code class="inlineCode">static</code>.</li>
</ul>
<p class="normal">We will first go through the basic <a id="_idIndexMarker608"/>usage of <code class="inlineCode">littlefs</code> and then see how we can apply RAII in a C++ wrapper class. We will go through an example of using <code class="inlineCode">littlefs</code> that will:</p>
<ul>
<li class="bulletList">Format and mount filesystem.</li>
<li class="bulletList">Create a file, write some content to it, and then close it.</li>
<li class="bulletList">Open a file, read content from it, and then close it.</li>
</ul>
<p class="normal">The full example is contained in <code class="inlineCode">Chapter13/lfs_raii/app/src/main.cpp</code>. Let us start with code that formats and mounts the filesystem, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">lfs_t lfs;
const lfs_config * lfs_ramfs_cfg = get_ramfs_lfs_config();
lfs_format(&amp;lfs, lfs_ramfs_cfg);
lfs_mount(&amp;lfs, lfs_ramfs_cfg);
</code></pre>
<p class="normal">This code performs the following steps:</p>
<ul>
<li class="bulletList">It declares a filesystem object named <code class="inlineCode">lfs</code> of type <code class="inlineCode">lfs_t</code>. This object will be used to interact with the <code class="inlineCode">littlefs</code> filesystem. It holds the state of the filesystem and is required for all subsequent filesystem operations.</li>
<li class="bulletList">The function <code class="inlineCode">get_ramfs_lfs_config()</code> returns a pointer to the <code class="inlineCode">lfs_config</code> structure that contains all the necessary configuration parameters for <code class="inlineCode">littlefs</code> to operate on a RAM storage medium. This includes function pointers for reading, writing, and erasing, as well as parameters like block size, block count, and cache size. In the project setup, we are using a portion of RAM as the storage medium. The RAM-based <code class="inlineCode">littlefs</code> configuration is defined in the C file <code class="inlineCode">Chapter13/lfs_raii/app/src/lfs_ramfs.c</code>.</li>
<li class="bulletList">It formats the storage medium to prepare it for use with <code class="inlineCode">littlefs</code>. The <code class="inlineCode">lfs_format</code> function initializes the filesystem structures on the storage medium. This process erases any existing data and sets up the necessary metadata structures. Formatting is typically done once before the first use of the filesystem or when resetting it.</li>
<li class="bulletList">It mounts the filesystem to make it ready for file operations. The <code class="inlineCode">lfs_mount</code> function initializes the filesystem state in RAM based on the existing structures on the storage medium. This step is necessary before performing any file operations like reading or writing.</li>
</ul>
<p class="normal">Next, let us go over<a id="_idIndexMarker609"/> creating a file and writing some data to it. The code is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">lfs_file_t file;
if(lfs_file_open(&amp;lfs, &amp;file, “song.txt”, LFS_O_WRONLY | LFS_O_CREAT) &gt;= 0)
{
 const char * file_content = “These are some lyrics!”;
 lfs_file_write(&amp;lfs,
 &amp;file,
 reinterpret_cast&lt;const void *&gt;(file_content),
 strlen(file_content));
    lfs_file_close(&amp;lfs, &amp;file);
}
</code></pre>
<p class="normal">This code performs<a id="_idIndexMarker610"/> the following steps:</p>
<ul>
<li class="bulletList">Declares a file object named <code class="inlineCode">file</code> of type <code class="inlineCode">lfs_file_t</code>. This object represents a file within the <code class="inlineCode">littlefs</code> filesystem. It holds the state of the file and is required for performing file operations like reading and writing.</li>
<li class="bulletList">Attempts to open a file named <code class="inlineCode">“song.txt”</code> for writing using the function <code class="inlineCode">lfs_file_open</code>. The function is provided with the following arguments:<ul>
<li class="bulletList"><code class="inlineCode">&amp;lfs</code>: A pointer to the filesystem object, initialized and mounted earlier.</li>
<li class="bulletList"><code class="inlineCode">&amp;file</code>: A pointer to the file object that will be associated with the opened file.</li>
<li class="bulletList"><code class="inlineCode">“song.txt”</code>: The name of the file to open.</li>
<li class="bulletList"><code class="inlineCode">LFS_O_WRONLY | LFS_O_CREAT</code>: Flags specifying to open the file in write-only mode, and to create a file if it doesn’t exist already.</li>
<li class="bulletList">If the <code class="inlineCode">lfs_file_open</code> function returns a non-negative value, the code attempts to write some data to it using the <code class="inlineCode">lfs_file_write</code> function.</li>
</ul>
</li>
<li class="bulletList">We declare the content to write as a <code class="inlineCode">file_content</code> string literal.</li>
<li class="bulletList">The function <code class="inlineCode">lfs_file_write</code> is provided with the following arguments:<ul>
<li class="bulletList"><code class="inlineCode">&amp;lfs</code>: A pointer to the filesystem object.</li>
<li class="bulletList"><code class="inlineCode">&amp;file</code>: A pointer to the file object associated with the opened file.</li>
<li class="bulletList"><code class="inlineCode">reinterpret_cast&lt;const void *&gt;(file_content)</code>: Casts the character string to a <code class="inlineCode">const void*</code> pointer as required by the function.</li>
<li class="bulletList"><code class="inlineCode">strlen(file_content)</code>: The number of bytes to write, calculated based on the length of the string.</li>
</ul>
</li>
<li class="bulletList">Closes the file <a id="_idIndexMarker611"/>after writing to ensure data integrity. <code class="inlineCode">lfs_file_close</code> flushes any pending writes to the storage medium and releases resources associated with the file.</li>
</ul>
<p class="normal">After writing data to a file, we will attempt to open the same file in read mode and read the data from it. The code for reading a file is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">if(lfs_file_open(&amp;lfs, &amp;file, “song.txt”, LFS_O_RDONLY)&gt;= 0) {
    std::array&lt;char, 64&gt; buff = {0};
 lfs_file_read(&amp;lfs,
               &amp;file,
               reinterpret_cast&lt;void *&gt;(buff.data()),
               buff.size() - 1);
    printf(“This is content from the file\r\n%s\r\n”, buff.data());
    lfs_file_close(&amp;lfs, &amp;file);
}
</code></pre>
<p class="normal">This code performs <a id="_idIndexMarker612"/>the following steps:</p>
<ul>
<li class="bulletList">Attempts to open the file <code class="inlineCode">“song.txt”</code> for read-only access using the function <code class="inlineCode">lfs_file_open</code> and providing it with the flag <code class="inlineCode">LFS_O_RDONLY</code>.</li>
<li class="bulletList">If the <code class="inlineCode">lfs_file_open</code> function returns a non-negative value, the code attempts to read data from the opened file.</li>
<li class="bulletList"><code class="inlineCode">std::array&lt;char, 64&gt; buff = {0}</code> declares an array named <code class="inlineCode">buff</code> with a fixed size of <code class="inlineCode">64</code> characters and initializes all elements to zero (<code class="inlineCode">‘\0’</code>), ensuring the buffer is null-terminated if treated as a C string.</li>
<li class="bulletList">Reads data from opened files in the <code class="inlineCode">buff</code> array using the function <code class="inlineCode">lfs_file_read</code>. The function is provided with the following arguments:<ul>
<li class="bulletList"><code class="inlineCode">&amp;lfs</code>: A pointer to the filesystem object.</li>
<li class="bulletList"><code class="inlineCode">&amp;file</code>: A pointer to the file object associated with the opened file.</li>
<li class="bulletList"><code class="inlineCode">reinterpret_cast&lt;const void *&gt;(buff.data())</code>: Casts the <code class="inlineCode">buff</code> underlying data array pointer to a const void* pointer as required by the function.</li>
</ul>
</li>
<li class="bulletList"><code class="inlineCode">buff.size() – 1</code>: The number of bytes to read from the file. Subtracting 1 reserves space for a null terminator (<code class="inlineCode">‘\0’</code>) at the end of the string.</li>
<li class="bulletList">Closes the file <a id="_idIndexMarker613"/>after reading to ensure data integrity.</li>
</ul>
<p class="normal">You can run the full example in the Renode simulator. Start Visual Studio Code, attach it to the running container, open the <code class="inlineCode">Chapter13/lfs_raii</code> project, as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ cd Chapter13/lfs_raii
$ cmake -B build
$ cmake --build build --target run_in_renode
</code></pre>
<h2 class="heading-2" id="_idParaDest-188">Introducing an RAII-based C++ wrapper</h2>
<p class="normal">Now, we will wrap<a id="_idIndexMarker614"/> the <code class="inlineCode">littlefs</code> functionality in a simple C++ wrapper applying the RAII technique. We will create an <code class="inlineCode">fs</code> namespace with types <code class="inlineCode">lfs</code> and <code class="inlineCode">file</code> in it. Let us start with the <code class="inlineCode">lfs</code> <code class="inlineCode">struct</code> code shown here:</p>
<pre class="programlisting code"><code class="hljs-code">namespace fs{
<code class="inlineCode">struct</code> lfs {
    lfs() = delete;
    static inline lfs_t fs_lfs;
    static void init() {
        const lfs_config * lfs_ramfs_cfg = get_ramfs_lfs_config();
        lfs_format(&amp;fs_lfs, lfs_ramfs_cfg);
        lfs_mount(&amp;fs_lfs, lfs_ramfs_cfg);
    }   
};
};
</code></pre>
<p class="normal">The purpose of the <code class="inlineCode">struct</code> <code class="inlineCode">lfs</code> is to:</p>
<ul>
<li class="bulletList">Hold an instance of a filesystem object named <code class="inlineCode">fs_lfs</code> of type <code class="inlineCode">lfs_t</code> used to interact with the <code class="inlineCode">littlefs</code> filesystem.</li>
<li class="bulletList">Implement the <code class="inlineCode">static</code> method <code class="inlineCode">init</code> used to initialize the filesystem by calling the <code class="inlineCode">lfs_format</code> and <code class="inlineCode">lfs_mount</code> functions. The <code class="inlineCode">init</code> method must be called before any file operations are performed.</li>
</ul>
<p class="normal">Next, let’s go over the <code class="inlineCode">file</code> class definition:</p>
<pre class="programlisting code"><code class="hljs-code">namespace fs{
class file {
public:
    file(const char * filename, int flags = LFS_O_RDONLY);
    ~file();
    [[nodiscard]] bool is_open() const;
    int read(std::span&lt;char&gt; buff);
    void write(std::span&lt;const char&gt; buff);
private:
    bool is_open_ = false;
    lfs_file_t file_;
};
};
</code></pre>
<p class="normal">This code<a id="_idIndexMarker615"/> shows methods and data members of the class file. Next, we will go through them, starting with the constructor shown here:</p>
<pre class="programlisting code"><code class="hljs-code">file(const char * filename, int flags = LFS_O_RDONLY) {
 if(lfs_file_open(&amp;lfs::fs_lfs, &amp;file_, filename, flags) &gt;= 0) {
 is_open_ = true;
 }
}
</code></pre>
<p class="normal">The <code class="inlineCode">file</code> constructor shown opens a file with the specified <code class="inlineCode">filename</code> and <code class="inlineCode">flags</code>. It sets <code class="inlineCode">is_open_</code> to true if the file opens successfully. Next, let’s go over the destructor shown here:</p>
<pre class="programlisting code"><code class="hljs-code">~file() {
if(is_open_) {
        printf(“Closing file in destructor.\r\n”);
        lfs_file_close(&amp;lfs::fs_lfs, &amp;file_);
 }
}
</code></pre>
<p class="normal">The destructor <a id="_idIndexMarker616"/>shown will close the file if it’s already opened. It calls <code class="inlineCode">lfs_file_close</code> to close the file and release resources. The constructor and destructor implement the RAII technique – creating an object will acquire resources, and when the object’s lifetime ends, the destructor will release them. Next, let’s go over the read and write methods:</p>
<pre class="programlisting code"><code class="hljs-code">int read(std::span&lt;char&gt; buff) {
return lfs_file_read(&amp;lfs::fs_lfs,
 &amp;file_,
                     reinterpret_cast&lt;void *&gt;(buff.data()),
 buff.size() - 1);
}
int write(std::span&lt;const char&gt; buff) {
return lfs_file_write(&amp;lfs::fs_lfs,
 &amp;file_,
                      reinterpret_cast&lt;const void *&gt;(buff.data()),
 buff.size());
}
</code></pre>
<p class="normal">The <code class="inlineCode">read</code> and <code class="inlineCode">write</code> methods are simple wrappers for the <code class="inlineCode">lfs_file_read</code> and <code class="inlineCode">lfs_file_write</code> functions. Both <code class="inlineCode">read</code> and <code class="inlineCode">write</code> use <code class="inlineCode">std::span</code> as function parameters for increased type safety and<a id="_idIndexMarker617"/> better flexibility, as we can simply provide it with <code class="inlineCode">std::array</code>.</p>
<h2 class="heading-2" id="_idParaDest-189">Cleaner file management with RAII</h2>
<p class="normal">Now, we will see how we can<a id="_idIndexMarker618"/> use the <code class="inlineCode">fs</code> and <code class="inlineCode">file</code> wrappers to <a id="_idIndexMarker619"/>work with the <code class="inlineCode">littlefs</code> filesystem. The code is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">fs::lfs::init();
{
    fs::file song_file(“song.txt”, LFS_O_WRONLY | LFS_O_CREAT);
 if(song_file.is_open()) {
 song_file.write(“These are some lyrics!”);
 // destructor is called on song_file object
 // ensuring the file is closed
}
</code></pre>
<p class="normal">We first initialize the filesystem by calling <code class="inlineCode">fs::lfs::init()</code>. Next, we introduce local scope to demonstrate a call to destructor and perform the next steps:</p>
<ul>
<li class="bulletList">Open <code class="inlineCode">“song.txt”</code> for writing (creating it if it doesn’t exist).</li>
<li class="bulletList">Write a string literal in the file if it was opened successfully.</li>
<li class="bulletList">Upon exit from the scope, the destructor is called, ensuring the file is closed.</li>
</ul>
<p class="normal">Next, we will open the file and read data from it. The code is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">fs::file song_file(“song.txt”);
std::array&lt;char, 64&gt; buff = {0};
if(song_file.is_open()) {
 song_file.read(buff);
 printf(“This is content from the file\r\n%s\r\n”,
 buff.data());
}
</code></pre>
<p class="normal">This code performs the next steps:</p>
<ul>
<li class="bulletList">Opens <code class="inlineCode">“song.txt”</code> for reading (default mode).</li>
<li class="bulletList">Declares <code class="inlineCode">std::array&lt;char, 64&gt; buff</code>, initialized to zeros.</li>
<li class="bulletList">Reads the data from the file in <code class="inlineCode">buff</code> if the file is opened successfully.</li>
</ul>
<p class="normal">You can run the <a id="_idIndexMarker620"/>full example in the <a id="_idIndexMarker621"/>Renode simulator. Start Visual Studio Code, attach it to the running container, open the <code class="inlineCode">Chapter13/lfs_raii</code> project, as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ cd Chapter13/lfs_raii
$ cmake -B build -DMAIN_CPP_FILE_NAME=main_lfs_raii.cpp
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">The simple C++ wrapper we wrote for the <code class="inlineCode">littlefs</code> library applies RAII principles, ensuring proper handling of resources as the destructor is called when an object’s lifetime ends. This ensures the file is closed even when there are multiple return paths from a code. It also simplifies the development experience as the code is less verbose and cleaner. The usage of <code class="inlineCode">std:span</code> increases safety.</p>
<h1 class="heading-1" id="_idParaDest-190">Summary</h1>
<p class="normal">In this chapter, we covered several techniques for using C libraries in C++ projects. By wrapping C code in C++ classes, we can organize our code better in loosely coupled software modules. C++ increases type safety and compile-time features allow us to easily organize C wrappers in <code class="inlineCode">static</code> classes.</p>
<p class="normal">Applying RAII is simple and provides us with a powerful mechanism that takes care of resource management, as we saw in the example of the <code class="inlineCode">littlefs</code> filesystem.</p>
<p class="normal">In the next chapter, we will go over super-loop in bare metal firmware and see how we can enhance it with mechanisms such as sequencer in C++.</p>
<h1 class="heading-1" id="_idParaDest-191">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/embeddedsystems">https://packt.link/embeddedsystems</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_code_Discord.png"/></p>
</div>
</body></html>