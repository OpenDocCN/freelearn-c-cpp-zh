<html><head></head><body>
<div id="_idContainer072">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">13</span></h1>
<h1 class="chapterTitle" id="_idParaDest-180"><span class="koboSpan" id="kobo.2.1">Working with C Libraries</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">In </span><a href="Chapter_06.xhtml"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.5.1">, we discussed interoperability between C and C++. </span><span class="koboSpan" id="kobo.5.2">We learned about language linkage and how to use it to include C libraries in a C++ project. </span><span class="koboSpan" id="kobo.5.3">From the technical standpoint, that’s all we need to use C in C++.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6.1">In this chapter, we’ll focus on software development techniques for integrating C libraries into a C++ project to enhance code flexibility. </span><span class="koboSpan" id="kobo.6.2">Since</span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.7.1"> many C++ projects still rely on vendor-provided C </span><strong class="keyWord"><span class="koboSpan" id="kobo.8.1">hardware abstraction layers</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.10.1">HALs</span></strong><span class="koboSpan" id="kobo.11.1">), we’ll concentrate on how to effectively incorporate these C libraries into our projects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.12.1">Additionally, this chapter will cover</span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.13.1"> the </span><strong class="keyWord"><span class="koboSpan" id="kobo.14.1">Resource Acquisition is Initialization</span></strong><span class="koboSpan" id="kobo.15.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.16.1">RAII</span></strong><span class="koboSpan" id="kobo.17.1">) paradigm and explain why it’s particularly beneficial in embedded systems. </span><span class="koboSpan" id="kobo.17.2">By automatically managing resource allocation and deallocation, RAII greatly reduces the risk of leaks and other resource misuse issues, which is especially important in resource-limited embedded environments.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.18.1">In this chapter, we’re going to cover the following main topics: </span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Using C HAL in C++ projects</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Static classes</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Using RAII for wrapping </span><code class="inlineCode"><span class="koboSpan" id="kobo.22.1">LittleFs</span></code><span class="koboSpan" id="kobo.23.1"> C library</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-181"><span class="koboSpan" id="kobo.24.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.25.1">The examples from this chapter are available on GitHub (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter13"><span class="url"><span class="koboSpan" id="kobo.26.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter13</span></span></a><span class="koboSpan" id="kobo.27.1">). </span><span class="koboSpan" id="kobo.27.2">To get the most out of this chapter, run the examples in the Renode simulator.</span></p>
<h1 class="heading-1" id="_idParaDest-182"><span class="koboSpan" id="kobo.28.1">Using C HAL in C++ projects</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.29.1">In </span><a href="Chapter_12.xhtml"><em class="italic"><span class="koboSpan" id="kobo.30.1">Chapter 12</span></em></a><span class="koboSpan" id="kobo.31.1">, we </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.32.1">explored the benefits of using C++ for HAL development. </span><span class="koboSpan" id="kobo.32.2">However, despite these advantages, target vendors provide HALs as C libraries. </span><span class="koboSpan" id="kobo.32.3">These libraries have been thoroughly tested on millions of devices worldwide, and vendors usually maintain them well, offering regular updates. </span><span class="koboSpan" id="kobo.32.4">Thus, it makes more sense to use them rather than re-implement the HAL in C++.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.33.1">Next, we will create an interface-based design for the UART peripheral, which will provide us with a more flexible software design and allow us to decouple components that are using the UART interface from low-level details.</span></p>
<h2 class="heading-2" id="_idParaDest-183"><span class="koboSpan" id="kobo.34.1">UART interface for flexible software design</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.35.1">In </span><a href="Chapter_05.xhtml"><em class="italic"><span class="koboSpan" id="kobo.36.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.37.1">, we </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.38.1">covered the importance of interfaces for flexible software design. </span><span class="koboSpan" id="kobo.38.2">There, we had an </span><code class="inlineCode"><span class="koboSpan" id="kobo.39.1">uart</span></code><span class="koboSpan" id="kobo.40.1"> interface class that was implemented by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.41.1">uart_stm32</span></code><span class="koboSpan" id="kobo.42.1"> class. </span><span class="koboSpan" id="kobo.42.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.43.1">gsm_lib</span></code><span class="koboSpan" id="kobo.44.1"> class depended on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.45.1">uart</span></code><span class="koboSpan" id="kobo.46.1"> interface, meaning we can reuse it with different </span><code class="inlineCode"><span class="koboSpan" id="kobo.47.1">uart</span></code><span class="koboSpan" id="kobo.48.1"> interface implementations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.49.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.50.1">uart_stm32</span></code><span class="koboSpan" id="kobo.51.1"> class from </span><a href="Chapter_05.xhtml"><em class="italic"><span class="koboSpan" id="kobo.52.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.53.1"> had a simple implementation for demo purposes. </span><span class="koboSpan" id="kobo.53.2">It used the </span><code class="inlineCode"><span class="koboSpan" id="kobo.54.1">printf</span></code><span class="koboSpan" id="kobo.55.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.56.1">putc</span></code><span class="koboSpan" id="kobo.57.1"> functions from the C standard library to write messages on standard output. </span><span class="koboSpan" id="kobo.57.2">We will now go through the actual implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.58.1">uart_stm32</span></code><span class="koboSpan" id="kobo.59.1"> class that’s already been used in all the examples in the book’s GitHub repo, enabling us to see the output in the Renode simulator. </span><span class="koboSpan" id="kobo.59.2">Let’s start from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.60.1">uart</span></code><span class="koboSpan" id="kobo.61.1"> interface </span><code class="inlineCode"><span class="koboSpan" id="kobo.62.1">class</span></code><span class="koboSpan" id="kobo.63.1"> with the code shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.64.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.65.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.66.1">&lt;cstdint&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.67.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.68.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.69.1">&lt;span&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.70.1">namespace</span></span><span class="koboSpan" id="kobo.71.1"> hal
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.72.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.73.1">uart</span></span><span class="koboSpan" id="kobo.74.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.75.1">public</span></span><span class="koboSpan" id="kobo.76.1">:
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.77.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.78.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.79.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.80.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.81.1">uint32_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.82.1"> baudrate)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.83.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.84.1">0</span></span><span class="koboSpan" id="kobo.85.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.86.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.87.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.88.1">write</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.89.1">(std::span&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.90.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.91.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.92.1">&gt; data)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.93.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.94.1">0</span></span><span class="koboSpan" id="kobo.95.1">;
};
}; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.96.1">// namespace hal</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.97.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.98.1">uart</span></code><span class="koboSpan" id="kobo.99.1"> interface</span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.100.1"> is a simple class with two virtual methods:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.101.1">virtual void init(std::uint32_t baudrate)</span></code><span class="koboSpan" id="kobo.102.1">: A method used to initialize the UART peripheral with a single parameter – </span><code class="inlineCode"><span class="koboSpan" id="kobo.103.1">baudrate</span></code><span class="koboSpan" id="kobo.104.1">.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.105.1">virtual void write(std::span&lt;const char&gt; data)</span></code><span class="koboSpan" id="kobo.106.1">: A method used to send data over the UART peripheral. </span><span class="koboSpan" id="kobo.106.2">It has a </span><code class="inlineCode"><span class="koboSpan" id="kobo.107.1">std::span&lt;const char&gt;</span></code><span class="koboSpan" id="kobo.108.1"> parameter in contrast to the usual C approach with a pointer to the data buffer and length. </span><span class="koboSpan" id="kobo.108.2">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.109.1">std::span</span></code><span class="koboSpan" id="kobo.110.1"> increases the memory safety of the code.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.111.1">Next, let us go through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.112.1">uart_stm32</span></code><span class="koboSpan" id="kobo.113.1"> class definition:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.114.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.115.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.116.1">&lt;span&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.117.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.118.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.119.1">&lt;cstdint&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.120.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.121.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.122.1">&lt;uart.hpp&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.123.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.124.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.125.1">&lt;stm32f0xx_hal.h&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.126.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.127.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.128.1">&lt;stm32f072xb.h&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.129.1">namespace</span></span><span class="koboSpan" id="kobo.130.1"> hal
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.131.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.132.1">uart_stm32</span></span><span class="koboSpan" id="kobo.133.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.134.1">public</span></span><span class="koboSpan" id="kobo.135.1"> uart
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.136.1">public</span></span><span class="koboSpan" id="kobo.137.1">:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.138.1">uart_stm32</span></span><span class="koboSpan" id="kobo.139.1">(USART_TypeDef *inst);
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.140.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.141.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.142.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.143.1">uint32_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.144.1"> baudrate = c_baudrate_default)</span></span><span class="koboSpan" id="kobo.145.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.146.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.147.1">write</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.148.1">(std::span&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.149.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.150.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.151.1">&gt; data)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.152.1">override</span></span><span class="koboSpan" id="kobo.153.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.154.1">private</span></span><span class="koboSpan" id="kobo.155.1">:
    UART_HandleTypeDef huart_;
    USART_TypeDef *instance_;
    std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.156.1">uint32_t</span></span><span class="koboSpan" id="kobo.157.1"> baudrate_;
    </span><code class="inlineCode"><span class="koboSpan" id="kobo.158.1">static</span></code> <span class="hljs-keyword"><span class="koboSpan" id="kobo.159.1">constexpr</span></span><span class="koboSpan" id="kobo.160.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.161.1">uint32_t</span></span><span class="koboSpan" id="kobo.162.1"> c_baudrate_default = </span><span class="hljs-number"><span class="koboSpan" id="kobo.163.1">115200</span></span><span class="koboSpan" id="kobo.164.1">;
};
}; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.165.1">// namespace hal</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.166.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.167.1">uart_stm32</span></code><span class="koboSpan" id="kobo.168.1"> class </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.169.1">definition, we can notice the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.170.1">Overridden virtual methods </span><code class="inlineCode"><span class="koboSpan" id="kobo.171.1">init</span></code><span class="koboSpan" id="kobo.172.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.173.1">write</span></code><span class="koboSpan" id="kobo.174.1"> from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.175.1">uart</span></code><span class="koboSpan" id="kobo.176.1"> interface.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.177.1">A constructor accepting a pointer to </span><code class="inlineCode"><span class="koboSpan" id="kobo.178.1">USART_TypeDef</span></code><span class="koboSpan" id="kobo.179.1">. </span><span class="koboSpan" id="kobo.179.2">This type is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.180.1">struct</span></code><span class="koboSpan" id="kobo.181.1"> that describes the UART peripheral register layout in the CMSIS header </span><code class="inlineCode"><span class="koboSpan" id="kobo.182.1">stm32f072xb.h</span></code><span class="koboSpan" id="kobo.183.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.184.1">Among the private members, we see </span><code class="inlineCode"><span class="koboSpan" id="kobo.185.1">UART_HandleTypeDef</span></code><span class="koboSpan" id="kobo.186.1">, a type defined in ST HAL in the file </span><code class="inlineCode"><span class="koboSpan" id="kobo.187.1">stm32f0xx_hal_uart.h</span></code><span class="koboSpan" id="kobo.188.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.189.1">Next, let us go through the implementation of the constructor and methods from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.190.1">uart_stm32</span></code><span class="koboSpan" id="kobo.191.1"> class in this code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.192.1">hal::uart_stm32::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.193.1">uart_stm32</span></span><span class="koboSpan" id="kobo.194.1">(USART_TypeDef *inst): </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.195.1">instance_</span></span><span class="koboSpan" id="kobo.196.1">(inst)
{
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.197.1">In this code, we see the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.198.1">uart_stm32</span></code><span class="koboSpan" id="kobo.199.1"> constructor. </span><span class="koboSpan" id="kobo.199.2">It just sets the private member </span><code class="inlineCode"><span class="koboSpan" id="kobo.200.1">USART_TypeDef *instance_</span></code><span class="koboSpan" id="kobo.201.1"> using the initializer list syntax. </span><span class="koboSpan" id="kobo.201.2">CMSIS defines the macros </span><code class="inlineCode"><span class="koboSpan" id="kobo.202.1">USART1</span></code><span class="koboSpan" id="kobo.203.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.204.1">USART2</span></code><span class="koboSpan" id="kobo.205.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.206.1">USART3</span></code><span class="koboSpan" id="kobo.207.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.208.1">USART4</span></code><span class="koboSpan" id="kobo.209.1">, which specify the addresses of these peripherals and which we can use to initialize the </span><code class="inlineCode"><span class="koboSpan" id="kobo.210.1">uart_stm32</span></code><span class="koboSpan" id="kobo.211.1"> object.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.212.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.213.1">uart</span></code><span class="koboSpan" id="kobo.214.1"> interface defines the </span><code class="inlineCode"><span class="koboSpan" id="kobo.215.1">init</span></code><span class="koboSpan" id="kobo.216.1"> method, as UART peripheral initialization depends on other hardware initializations (i.e., clock configuration). </span><span class="koboSpan" id="kobo.216.2">If we implemented the initialization within the constructor, we might run into issues if someone defines a </span><code class="inlineCode"><span class="koboSpan" id="kobo.217.1">global</span></code><span class="koboSpan" id="kobo.218.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.219.1">static</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.220.1">uart_stm32</span></code><span class="koboSpan" id="kobo.221.1"> object. </span><span class="koboSpan" id="kobo.221.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.222.1">init</span></code><span class="koboSpan" id="kobo.223.1"> method is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.224.1">void</span></span><span class="koboSpan" id="kobo.225.1"> hal::uart_stm32::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.226.1">init</span></span><span class="koboSpan" id="kobo.227.1">(std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.228.1">uint32_t</span></span><span class="koboSpan" id="kobo.229.1"> baudrate)
{
    huart_.Instance = instance_;
    huart_.Init.BaudRate = baudrate;
    huart_.Init.WordLength = UART_WORDLENGTH_8B;
    huart_.Init.StopBits = UART_STOPBITS_1;
    huart_.Init.Parity = UART_PARITY_NONE;
    huart_.Init.Mode = UART_MODE_TX_RX;
    huart_.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart_.Init.OverSampling = UART_OVERSAMPLING_16;
    huart_.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
    huart_.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
    huart_.MspInitCallback = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.230.1">nullptr</span></span><span class="koboSpan" id="kobo.231.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.232.1">HAL_UART_Init</span></span><span class="koboSpan" id="kobo.233.1">(&amp;huart_);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.234.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.235.1">init</span></code><span class="koboSpan" id="kobo.236.1"> method, we</span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.237.1"> initialize the member </span><code class="inlineCode"><span class="koboSpan" id="kobo.238.1">UART_HandleTypeDef huart_</span></code><span class="koboSpan" id="kobo.239.1"> with the following configuration:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.240.1">instance_</span></code><span class="koboSpan" id="kobo.241.1">: The address to the UART peripheral selected in the constructor</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.242.1">baudrate</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.243.1">8-bit word length</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.244.1">1 stop bit</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.245.1">Both TX and RX mode</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.246.1">No hardware control</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.247.1">We also set </span><code class="inlineCode"><span class="koboSpan" id="kobo.248.1">MspInitCallback</span></code><span class="koboSpan" id="kobo.249.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.250.1">nullptr</span></code><span class="koboSpan" id="kobo.251.1">. </span><span class="koboSpan" id="kobo.251.2">We make a call to the ST HAL </span><code class="inlineCode"><span class="koboSpan" id="kobo.252.1">HAL_UART_Init</span></code><span class="koboSpan" id="kobo.253.1"> function providing it</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.254.1"> with a pointer to </span><code class="inlineCode"><span class="koboSpan" id="kobo.255.1">huart_</span></code><span class="koboSpan" id="kobo.256.1">. </span><span class="koboSpan" id="kobo.256.2">Please note that for the sake of example simplicity, there is no error handling. </span><span class="koboSpan" id="kobo.256.3">Error handling is an important step, and return codes from HAL should be appropriately handled in code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.257.1">Next, we will go through the implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.258.1">write</span></code><span class="koboSpan" id="kobo.259.1"> method shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.260.1">void</span></span><span class="koboSpan" id="kobo.261.1"> hal::uart_stm32::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.262.1">write</span></span><span class="koboSpan" id="kobo.263.1">(std::span&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.264.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.265.1">char</span></span><span class="koboSpan" id="kobo.266.1">&gt; data)
{
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.267.1">// we must cast away constness due to ST HAL’s API</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.268.1">char</span></span><span class="koboSpan" id="kobo.269.1"> * data_ptr = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.270.1">const_cast</span></span><span class="koboSpan" id="kobo.271.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.272.1">char</span></span><span class="koboSpan" id="kobo.273.1"> *&gt;(data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.274.1">data</span></span><span class="koboSpan" id="kobo.275.1">());
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.276.1">HAL_UART_Transmit</span></span><span class="koboSpan" id="kobo.277.1">(&amp;huart_,
                     </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.278.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.279.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.280.1">uint8_t</span></span><span class="koboSpan" id="kobo.281.1"> *(data_ptr),
                     data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.282.1">size</span></span><span class="koboSpan" id="kobo.283.1">(),
                     HAL_MAX_DELAY);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.284.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">write</span></code><span class="koboSpan" id="kobo.286.1"> method, we are making a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.287.1">HAL_UART_Transmit</span></code><span class="koboSpan" id="kobo.288.1"> from ST HAL, by passing the data pointer and data size from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.289.1">std::span&lt;const char&gt; data</span></code><span class="koboSpan" id="kobo.290.1"> parameter. </span><span class="koboSpan" id="kobo.290.2">It’s worth noting that we need to cast away constness as the C </span><code class="inlineCode"><span class="koboSpan" id="kobo.291.1">HAL_UART_Transmit</span></code><span class="koboSpan" id="kobo.292.1"> function doesn’t accept the const pointer to data. </span><span class="koboSpan" id="kobo.292.2">This is only safe to do if we are sure that the function we are passing the pointer with cast away constness is not trying to modify its content.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.293.1">Next, we will analyze this approach from the perspective of software design and patterns used.</span></p>
<h2 class="heading-2" id="_idParaDest-184"><span class="koboSpan" id="kobo.294.1">The UART interface in the Adapter pattern</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.295.1">The</span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.296.1"> relationship between </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.297.1">all the software components in this example (the </span><code class="inlineCode"><span class="koboSpan" id="kobo.298.1">uart</span></code><span class="koboSpan" id="kobo.299.1"> interface, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">uart_stm32</span></code><span class="koboSpan" id="kobo.301.1"> implementation of the interface, and the ST HAL) can be represented by the following UML diagram:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.302.1"><img alt="Figure 13.1 – The uart_stm32 class diagram" src="../Images/B22402_13_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.303.1">Figure 13.1 – The uart_stm32 class diagram</span></p>
<p class="normal"><span class="koboSpan" id="kobo.304.1">In </span><em class="italic"><span class="koboSpan" id="kobo.305.1">Figure 13.1</span></em><span class="koboSpan" id="kobo.306.1">, we see the UML class diagram of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.307.1">uart_stm32</span></code><span class="koboSpan" id="kobo.308.1"> class. </span><span class="koboSpan" id="kobo.308.2">This class effectively implements the </span><strong class="keyWord"><span class="koboSpan" id="kobo.309.1">Adapter design pattern</span></strong><span class="koboSpan" id="kobo.310.1">, which is a structural design pattern used to allow classes with </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.311.1">incompatible interfaces to work together. </span><span class="koboSpan" id="kobo.311.2">The </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.312.1">Adapter pattern involves creating an adapter class that wraps an existing class (or module) and provides a new interface that the client expects.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.313.1">In our case, even though </span><code class="inlineCode"><span class="koboSpan" id="kobo.314.1">stm32f0xx_hal_uart</span></code><span class="koboSpan" id="kobo.315.1"> is a C module rather than a C++ class, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.316.1">uart_stm32</span></code><span class="koboSpan" id="kobo.317.1"> class serves as an adapter by encapsulating the C-based HAL code and exposing it through the C++ </span><code class="inlineCode"><span class="koboSpan" id="kobo.318.1">uart</span></code><span class="koboSpan" id="kobo.319.1"> interface. </span><span class="koboSpan" id="kobo.319.2">This adaptation allows other classes or clients in the system, such as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.320.1">GSM</span></code><span class="koboSpan" id="kobo.321.1"> library, to interact with the UART hardware using the standardized C++ interface, without needing to concern themselves with the underlying C implementation details.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.322.1">Let us analyze this approach from the perspective of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.323.1">uart</span></code><span class="koboSpan" id="kobo.324.1"> interface client, such as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.325.1">GSM</span></code><span class="koboSpan" id="kobo.326.1"> library that is implemented in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.327.1">gsm_lib</span></code><span class="koboSpan" id="kobo.328.1"> class, with this definition:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.329.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.330.1">gsm_lib</span></span><span class="koboSpan" id="kobo.331.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.332.1">public</span></span><span class="koboSpan" id="kobo.333.1">:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.334.1">gsm_lib</span></span><span class="koboSpan" id="kobo.335.1">(hal::uart &amp;u) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.336.1">uart_</span></span><span class="koboSpan" id="kobo.337.1">(u) {}
        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.338.1">// other methods</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.339.1">private</span></span><span class="koboSpan" id="kobo.340.1">:
        hal::uart &amp;uart_;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.341.1">In this code, we see an example of a simple client of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.342.1">uart</span></code><span class="koboSpan" id="kobo.343.1"> interface – </span><code class="inlineCode"><span class="koboSpan" id="kobo.344.1">gsm_lib</span></code><span class="koboSpan" id="kobo.345.1"> – with a constructor that initializes the reference </span><code class="inlineCode"><span class="koboSpan" id="kobo.346.1">hal::uart &amp;uart_</span></code><span class="koboSpan" id="kobo.347.1">. </span><span class="koboSpan" id="kobo.347.2">This approach is called </span><strong class="keyWord"><span class="koboSpan" id="kobo.348.1">dependency injection</span></strong><span class="koboSpan" id="kobo.349.1">. </span><span class="koboSpan" id="kobo.349.2">The </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.350.1">dependency of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.351.1">gsm_lib</span></code><span class="koboSpan" id="kobo.352.1"> class is constructed externally and supplied to the class as a reference through the constructor. </span><span class="koboSpan" id="kobo.352.2">Depending on the interface also enables loose coupling, which brings the following benefits:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.353.1">gsm_lib</span></code><span class="koboSpan" id="kobo.354.1"> is not interested in the implementation details of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.355.1">uart</span></code><span class="koboSpan" id="kobo.356.1"> interface. </span><span class="koboSpan" id="kobo.356.2">It doesn’t need to know about baud rate, hardware settings, etc.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.357.1">gsm_lib</span></code><span class="koboSpan" id="kobo.358.1"> is not tied to a particular target. </span><span class="koboSpan" id="kobo.358.2">We can reuse it on different platforms by implementing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.359.1">uart</span></code><span class="koboSpan" id="kobo.360.1"> interface on those platforms.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.361.1">Software</span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.362.1"> testing of </span><code class="inlineCode"><span class="koboSpan" id="kobo.363.1">gsm_lib</span></code><span class="koboSpan" id="kobo.364.1"> is easy as we can mock the </span><code class="inlineCode"><span class="koboSpan" id="kobo.365.1">uart</span></code><span class="koboSpan" id="kobo.366.1"> interface and instantiate</span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.367.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.368.1">gsm_lib</span></code><span class="koboSpan" id="kobo.369.1"> object with the mocked object used in tests.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.370.1">Instead of directly using the C HAL library in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.371.1">uart_stm32</span></code><span class="koboSpan" id="kobo.372.1"> class, we can wrap the functions from the C library in a so-called </span><code class="inlineCode"><span class="koboSpan" id="kobo.373.1">static</span></code><span class="koboSpan" id="kobo.374.1"> class with the direct mapping of all parameters.</span></p>
<h1 class="heading-1" id="_idParaDest-185"><span class="koboSpan" id="kobo.375.1">Introducing static classes</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.376.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.377.1">static</span></code><span class="koboSpan" id="kobo.378.1"> class concept that we will </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.379.1">discuss here doesn’t exist in the C++ language standard. </span><span class="koboSpan" id="kobo.379.2">We are borrowing it from languages such as C#, where it is defined as a class that contains only </span><code class="inlineCode"><span class="koboSpan" id="kobo.380.1">static</span></code><span class="koboSpan" id="kobo.381.1"> members and methods. </span><span class="koboSpan" id="kobo.381.2">It can’t be instantiated. </span><span class="koboSpan" id="kobo.381.3">In C#, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.382.1">static</span></code><span class="koboSpan" id="kobo.383.1"> class is declared using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.384.1">static</span></code><span class="koboSpan" id="kobo.385.1"> keyword.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.386.1">In C++, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.387.1">static</span></code><span class="koboSpan" id="kobo.388.1"> class can be created by defining a class with all </span><code class="inlineCode"><span class="koboSpan" id="kobo.389.1">static</span></code><span class="koboSpan" id="kobo.390.1"> methods and members and by deleting the default constructor. </span><span class="koboSpan" id="kobo.390.2">Deleting the constructor ensures that no instances of the class can be created, enforcing this at compile time. </span><span class="koboSpan" id="kobo.390.3">Disabling instantiation signals a clear intent to the user: </span><em class="italic"><span class="koboSpan" id="kobo.391.1">This is a </span></em><code class="inlineCode"><span class="koboSpan" id="kobo.392.1">static</span></code><em class="italic"><span class="koboSpan" id="kobo.393.1"> class. </span><span class="koboSpan" id="kobo.393.2">The functions you’re using don’t rely on any instance-specific states, as no instances exist. </span><span class="koboSpan" id="kobo.393.3">If there’s any internal state, it’s shared and will affect everyone using the class</span></em><span class="koboSpan" id="kobo.394.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.395.1">We will modify the previous example and create a </span><code class="inlineCode"><span class="koboSpan" id="kobo.396.1">uart_c_hal</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.397.1">static</span></code><span class="koboSpan" id="kobo.398.1"> class to wrap UART C HAL functions, as shown in this code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><code class="inlineCode"><span class="koboSpan" id="kobo.399.1">struct</span></code> <span class="hljs-title"><span class="koboSpan" id="kobo.400.1">uart_c_hal</span></span><span class="koboSpan" id="kobo.401.1"> {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.402.1">uart_c_hal</span></span><span class="koboSpan" id="kobo.403.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.404.1">delete</span></span><span class="koboSpan" id="kobo.405.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.406.1">static</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.407.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.408.1"> HAL_StatusTypeDef </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.409.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.410.1">(UART_HandleTypeDef *huart)</span></span><span class="koboSpan" id="kobo.411.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.412.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.413.1">HAL_UART_Init</span></span><span class="koboSpan" id="kobo.414.1">(huart);
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.415.1">static</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.416.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.417.1"> HAL_StatusTypeDef </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.418.1">transmit</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.419.1">(UART_HandleTypeDef *huart,</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.420.1">uint8_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.421.1"> *pData,</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.422.1">uint16_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.423.1"> Size,</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.424.1">uint32_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.425.1"> Timeout)</span></span><span class="koboSpan" id="kobo.426.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.427.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.428.1">HAL_UART_Transmit</span></span><span class="koboSpan" id="kobo.429.1">(huart, pData, Size, Timeout);
    }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.430.1">In this code, we </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.431.1">simply mapped C functions in </span><code class="inlineCode"><span class="koboSpan" id="kobo.432.1">static</span></code><span class="koboSpan" id="kobo.433.1"> methods of the class </span><code class="inlineCode"><span class="koboSpan" id="kobo.434.1">uart_c_hal</span></code><span class="koboSpan" id="kobo.435.1">. </span><span class="koboSpan" id="kobo.435.2">Next, we will modify the </span><code class="inlineCode"><span class="koboSpan" id="kobo.436.1">uart_stm32</span></code><span class="koboSpan" id="kobo.437.1"> class to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.438.1">uart_c_hal</span></code><span class="koboSpan" id="kobo.439.1">, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.440.1">template</span></span><span class="koboSpan" id="kobo.441.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.442.1">typename</span></span><span class="koboSpan" id="kobo.443.1"> HalUart&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.444.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.445.1">uart_stm32</span></span><span class="koboSpan" id="kobo.446.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.447.1">public</span></span><span class="koboSpan" id="kobo.448.1"> uart
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.449.1">public</span></span><span class="koboSpan" id="kobo.450.1">:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.451.1">uart_stm32</span></span><span class="koboSpan" id="kobo.452.1">(USART_TypeDef *inst) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.453.1">instance_</span></span><span class="koboSpan" id="kobo.454.1">(inst) {}
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.455.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.456.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.457.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.458.1">uint32_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.459.1"> baudrate = c_baudrate_default)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.460.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.461.1">{
      huart_.Instance = instance_;
      huart_.Init.BaudRate = baudrate;
      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.462.1">// ...</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.463.1">// init huart_ </span></span><code class="inlineCode"><span class="koboSpan" id="kobo.464.1">struct</span></code><span class="koboSpan" id="kobo.465.1">
      HalUart::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.466.1">init</span></span><span class="koboSpan" id="kobo.467.1">(&amp;huart_);
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.468.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.469.1">write</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.470.1">(std::span&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.471.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.472.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.473.1">&gt; data)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.474.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.475.1">{
      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.476.1">// we must cast away costness due to ST HAL’s API</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.477.1">char</span></span><span class="koboSpan" id="kobo.478.1"> * data_ptr = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.479.1">const_cast</span></span><span class="koboSpan" id="kobo.480.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.481.1">char</span></span><span class="koboSpan" id="kobo.482.1"> *&gt;(data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.483.1">data</span></span><span class="koboSpan" id="kobo.484.1">());
      HalUart::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.485.1">transmit</span></span><span class="koboSpan" id="kobo.486.1">(&amp;huart_,
</span><span class="hljs-keyword"> </span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.487.1">reinterpret_cast</span></span><span class="koboSpan" id="kobo.488.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.489.1">uint8_t</span></span><span class="koboSpan" id="kobo.490.1"> *(data_ptr),
</span><span class="hljs-keyword"> </span><span class="koboSpan" id="kobo.491.1">        data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.492.1">size</span></span><span class="koboSpan" id="kobo.493.1">(),
</span><span class="hljs-keyword"> </span> <span class="hljs-keyword"> </span><span class="koboSpan" id="kobo.494.1">HAL_MAX_DELAY);
    }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.495.1">private</span></span><span class="koboSpan" id="kobo.496.1">:
    UART_HandleTypeDef huart_;
    USART_TypeDef *instance_;
    std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.497.1">uint32_t</span></span><span class="koboSpan" id="kobo.498.1"> baudrate_;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.499.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.500.1">constexpr</span></span><span class="koboSpan" id="kobo.501.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.502.1">uint32_t</span></span><span class="koboSpan" id="kobo.503.1"> c_baudrate_default = </span><span class="hljs-number"><span class="koboSpan" id="kobo.504.1">115200</span></span><span class="koboSpan" id="kobo.505.1">;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.506.1">In this code, we see </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.507.1">that </span><code class="inlineCode"><span class="koboSpan" id="kobo.508.1">uart_stm32</span></code><span class="koboSpan" id="kobo.509.1"> is now a template class that uses the methods </span><code class="inlineCode"><span class="koboSpan" id="kobo.510.1">init</span></code><span class="koboSpan" id="kobo.511.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.512.1">transmit</span></code><span class="koboSpan" id="kobo.513.1"> from the template parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.514.1">HalUart</span></code><span class="koboSpan" id="kobo.515.1">. </span><span class="koboSpan" id="kobo.515.2">Now we can use the class template, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.516.1">uart_stm32&lt;uart_c_hal&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.517.1">uart</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.518.1">(USART2)</span></span><span class="koboSpan" id="kobo.519.1">;
uart.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.520.1">init</span></span><span class="koboSpan" id="kobo.521.1">();
</span><span class="hljs-function"><span class="koboSpan" id="kobo.522.1">gsm_lib </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.523.1">gsm</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.524.1">(uart)</span></span><span class="koboSpan" id="kobo.525.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.526.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.527.1">uart_stm32</span></code><span class="koboSpan" id="kobo.528.1"> class template still implements the </span><code class="inlineCode"><span class="koboSpan" id="kobo.529.1">uart</span></code><span class="koboSpan" id="kobo.530.1"> interface, meaning we can still use it with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">gsm_lib</span></code><span class="koboSpan" id="kobo.532.1"> class. </span><span class="koboSpan" id="kobo.532.2">Wrapping C HAL functions in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.533.1">static</span></code><span class="koboSpan" id="kobo.534.1"> class and adjusting </span><code class="inlineCode"><span class="koboSpan" id="kobo.535.1">uart_stm32</span></code><span class="koboSpan" id="kobo.536.1"> to use it through a template parameter decouples C HAL from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.537.1">uart_stm32</span></code><span class="koboSpan" id="kobo.538.1"> implementation. </span><span class="koboSpan" id="kobo.538.2">This makes it possible to test the </span><code class="inlineCode"><span class="koboSpan" id="kobo.539.1">uart_stm32</span></code><span class="koboSpan" id="kobo.540.1"> class off-target, as it doesn’t depend on platform-specific code anymore.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.541.1">Static classes are </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.542.1">one way of using C libraries in C++ projects. </span><span class="koboSpan" id="kobo.542.2">They allow us to encapsulate functions from C libraries in types that can be passed to C++ classes through template arguments, making the code more flexible and easier to test.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.543.1">Next, we will see how to apply the RAII technique to effectively wrap the </span><strong class="keyWord"><span class="koboSpan" id="kobo.544.1">little fail-safe</span></strong><span class="koboSpan" id="kobo.545.1"> (</span><code class="inlineCode"><span class="koboSpan" id="kobo.546.1">littlefs</span></code><span class="koboSpan" id="kobo.547.1">) filesystem C library.</span></p>
<h1 class="heading-1" id="_idParaDest-186"><span class="koboSpan" id="kobo.548.1">Using RAII for wrapping the littlefs C library</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.549.1">RAII is a</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.550.1"> simple yet powerful C++ technique used to manage resources through an object’s lifetime. </span><span class="koboSpan" id="kobo.550.2">Resources can represent different things. </span><span class="koboSpan" id="kobo.550.3">Resources are acquired when an object’s lifetime begins, and they are released when the object’s lifetime ends.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.551.1">The technique is used to manage resources such as dynamically allocated memory. </span><span class="koboSpan" id="kobo.551.2">To ensure that the memory is released and avoid memory leaks, the recommendation is to use dynamic allocation only internally in classes. </span><span class="koboSpan" id="kobo.551.3">When an object is instantiated, the constructor will allocate memory, and when the object goes out of scope, the destructor will release the allocated memory.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.552.1">The RAII technique can be applied to other resources beyond the dynamically allocated memory, such as files, and</span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.553.1"> we will apply it to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.554.1">littlefs</span></code><span class="koboSpan" id="kobo.555.1"> filesystem library (</span><a href="https://github.com/littlefs-project/littlefs"><span class="url"><span class="koboSpan" id="kobo.556.1">https://github.com/littlefs-project/littlefs</span></span></a><span class="koboSpan" id="kobo.557.1">). </span><span class="koboSpan" id="kobo.557.2">We will start with a short overview of </span><code class="inlineCode"><span class="koboSpan" id="kobo.558.1">littlefs</span></code><span class="koboSpan" id="kobo.559.1"> – a filesystem designed for microcontrollers.</span></p>
<h2 class="heading-2" id="_idParaDest-187"><span class="koboSpan" id="kobo.560.1">LittleFS – a filesystem for microcontrollers</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.561.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.562.1">littlefs</span></code><span class="koboSpan" id="kobo.563.1"> filesystem</span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.564.1"> is designed for microcontrollers featuring the following:</span></p>
<ul>
<li class="bulletList"><strong class="screenText"><span class="koboSpan" id="kobo.565.1">Power-loss resilience</span></strong><span class="koboSpan" id="kobo.566.1">: It is built to handle unexpected power failures. </span><span class="koboSpan" id="kobo.566.2">In the case of power loss, it will fall back to the last known good state.</span></li>
<li class="bulletList"><strong class="screenText"><span class="koboSpan" id="kobo.567.1">Dynamic wear leveling</span></strong><span class="koboSpan" id="kobo.568.1">: It is optimized for flash memory, offering wear leveling across dynamic blocks. </span><span class="koboSpan" id="kobo.568.2">It also includes mechanisms to detect and bypass bad blocks, ensuring reliable performance over time.</span></li>
<li class="bulletList"><strong class="screenText"><span class="koboSpan" id="kobo.569.1">Bounded RAM/ROM</span></strong><span class="koboSpan" id="kobo.570.1">: It is optimized for low memory usage. </span><span class="koboSpan" id="kobo.570.2">RAM consumption remains constant, regardless of filesystem size, with no unbounded recursion. </span><span class="koboSpan" id="kobo.570.3">Dynamic memory is limited to configurable buffers, which can be set up as </span><code class="inlineCode"><span class="koboSpan" id="kobo.571.1">static</span></code><span class="koboSpan" id="kobo.572.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.573.1">We will first go through the basic </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.574.1">usage of </span><code class="inlineCode"><span class="koboSpan" id="kobo.575.1">littlefs</span></code><span class="koboSpan" id="kobo.576.1"> and then see how we can apply RAII in a C++ wrapper class. </span><span class="koboSpan" id="kobo.576.2">We will go through an example of using </span><code class="inlineCode"><span class="koboSpan" id="kobo.577.1">littlefs</span></code><span class="koboSpan" id="kobo.578.1"> that will:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.579.1">Format and mount filesystem.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.580.1">Create a file, write some content to it, and then close it.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.581.1">Open a file, read content from it, and then close it.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.582.1">The full example is contained in </span><code class="inlineCode"><span class="koboSpan" id="kobo.583.1">Chapter13/lfs_raii/app/src/main.cpp</span></code><span class="koboSpan" id="kobo.584.1">. </span><span class="koboSpan" id="kobo.584.2">Let us start with code that formats and mounts the filesystem, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.585.1">lfs_t</span></span><span class="koboSpan" id="kobo.586.1"> lfs;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.587.1">const</span></span><span class="koboSpan" id="kobo.588.1"> lfs_config * lfs_ramfs_cfg = get_ramfs_lfs_config();
lfs_format(&amp;lfs, lfs_ramfs_cfg);
lfs_mount(&amp;lfs, lfs_ramfs_cfg);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.589.1">This code performs the following steps:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.590.1">It declares a filesystem object named </span><code class="inlineCode"><span class="koboSpan" id="kobo.591.1">lfs</span></code><span class="koboSpan" id="kobo.592.1"> of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.593.1">lfs_t</span></code><span class="koboSpan" id="kobo.594.1">. </span><span class="koboSpan" id="kobo.594.2">This object will be used to interact with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.595.1">littlefs</span></code><span class="koboSpan" id="kobo.596.1"> filesystem. </span><span class="koboSpan" id="kobo.596.2">It holds the state of the filesystem and is required for all subsequent filesystem operations.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.597.1">The function </span><code class="inlineCode"><span class="koboSpan" id="kobo.598.1">get_ramfs_lfs_config()</span></code><span class="koboSpan" id="kobo.599.1"> returns a pointer to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.600.1">lfs_config</span></code><span class="koboSpan" id="kobo.601.1"> structure that contains all the necessary configuration parameters for </span><code class="inlineCode"><span class="koboSpan" id="kobo.602.1">littlefs</span></code><span class="koboSpan" id="kobo.603.1"> to operate on a RAM storage medium. </span><span class="koboSpan" id="kobo.603.2">This includes function pointers for reading, writing, and erasing, as well as parameters like block size, block count, and cache size. </span><span class="koboSpan" id="kobo.603.3">In the project setup, we are using a portion of RAM as the storage medium. </span><span class="koboSpan" id="kobo.603.4">The RAM-based </span><code class="inlineCode"><span class="koboSpan" id="kobo.604.1">littlefs</span></code><span class="koboSpan" id="kobo.605.1"> configuration is defined in the C file </span><code class="inlineCode"><span class="koboSpan" id="kobo.606.1">Chapter13/lfs_raii/app/src/lfs_ramfs.c</span></code><span class="koboSpan" id="kobo.607.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.608.1">It formats the storage medium to prepare it for use with </span><code class="inlineCode"><span class="koboSpan" id="kobo.609.1">littlefs</span></code><span class="koboSpan" id="kobo.610.1">. </span><span class="koboSpan" id="kobo.610.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.611.1">lfs_format</span></code><span class="koboSpan" id="kobo.612.1"> function initializes the filesystem structures on the storage medium. </span><span class="koboSpan" id="kobo.612.2">This process erases any existing data and sets up the necessary metadata structures. </span><span class="koboSpan" id="kobo.612.3">Formatting is typically done once before the first use of the filesystem or when resetting it.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.613.1">It mounts the filesystem to make it ready for file operations. </span><span class="koboSpan" id="kobo.613.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.614.1">lfs_mount</span></code><span class="koboSpan" id="kobo.615.1"> function initializes the filesystem state in RAM based on the existing structures on the storage medium. </span><span class="koboSpan" id="kobo.615.2">This step is necessary before performing any file operations like reading or writing.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.616.1">Next, let us go over</span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.617.1"> creating a file and writing some data to it. </span><span class="koboSpan" id="kobo.617.2">The code is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.618.1">lfs_file_t</span></span><span class="koboSpan" id="kobo.619.1"> file;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.620.1">if</span></span><span class="koboSpan" id="kobo.621.1">(lfs_file_open(&amp;lfs, &amp;file, </span><span class="hljs-string"><span class="koboSpan" id="kobo.622.1">“song.txt”</span></span><span class="koboSpan" id="kobo.623.1">, LFS_O_WRONLY | LFS_O_CREAT) &gt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.624.1">0</span></span><span class="koboSpan" id="kobo.625.1">)
{
</span><span class="hljs-keyword"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.626.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.627.1">char</span></span><span class="koboSpan" id="kobo.628.1"> * file_content = </span><span class="hljs-string"><span class="koboSpan" id="kobo.629.1">“These are some lyrics!”</span></span><span class="koboSpan" id="kobo.630.1">;
</span><span class="hljs-keyword"> </span><span class="koboSpan" id="kobo.631.1">lfs_file_write(&amp;lfs,
</span><span class="hljs-keyword"> </span><span class="koboSpan" id="kobo.632.1">&amp;file,
</span><span class="hljs-keyword"> </span><span class="koboSpan" id="kobo.633.1">reinterpret_cast&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.634.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.635.1">void</span></span><span class="koboSpan" id="kobo.636.1"> *&gt;(file_content),
</span><span class="hljs-keyword"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.637.1">strlen</span></span><span class="koboSpan" id="kobo.638.1">(file_content));
    lfs_file_close(&amp;lfs, &amp;file);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.639.1">This code performs</span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.640.1"> the following steps:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.641.1">Declares a file object named </span><code class="inlineCode"><span class="koboSpan" id="kobo.642.1">file</span></code><span class="koboSpan" id="kobo.643.1"> of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.644.1">lfs_file_t</span></code><span class="koboSpan" id="kobo.645.1">. </span><span class="koboSpan" id="kobo.645.2">This object represents a file within the </span><code class="inlineCode"><span class="koboSpan" id="kobo.646.1">littlefs</span></code><span class="koboSpan" id="kobo.647.1"> filesystem. </span><span class="koboSpan" id="kobo.647.2">It holds the state of the file and is required for performing file operations like reading and writing.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.648.1">Attempts to open a file named </span><code class="inlineCode"><span class="koboSpan" id="kobo.649.1">“song.txt”</span></code><span class="koboSpan" id="kobo.650.1"> for writing using the function </span><code class="inlineCode"><span class="koboSpan" id="kobo.651.1">lfs_file_open</span></code><span class="koboSpan" id="kobo.652.1">. </span><span class="koboSpan" id="kobo.652.2">The function is provided with the following arguments:</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.653.1">&amp;lfs</span></code><span class="koboSpan" id="kobo.654.1">: A pointer to the filesystem object, initialized and mounted earlier.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.655.1">&amp;file</span></code><span class="koboSpan" id="kobo.656.1">: A pointer to the file object that will be associated with the opened file.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.657.1">“song.txt”</span></code><span class="koboSpan" id="kobo.658.1">: The name of the file to open.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.659.1">LFS_O_WRONLY | LFS_O_CREAT</span></code><span class="koboSpan" id="kobo.660.1">: Flags specifying to open the file in write-only mode, and to create a file if it doesn’t exist already.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.661.1">If the </span><code class="inlineCode"><span class="koboSpan" id="kobo.662.1">lfs_file_open</span></code><span class="koboSpan" id="kobo.663.1"> function returns a non-negative value, the code attempts to write some data to it using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.664.1">lfs_file_write</span></code><span class="koboSpan" id="kobo.665.1"> function.</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.666.1">We declare the content to write as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.667.1">file_content</span></code><span class="koboSpan" id="kobo.668.1"> string literal.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.669.1">The function </span><code class="inlineCode"><span class="koboSpan" id="kobo.670.1">lfs_file_write</span></code><span class="koboSpan" id="kobo.671.1"> is provided with the following arguments:</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.672.1">&amp;lfs</span></code><span class="koboSpan" id="kobo.673.1">: A pointer to the filesystem object.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.674.1">&amp;file</span></code><span class="koboSpan" id="kobo.675.1">: A pointer to the file object associated with the opened file.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.676.1">reinterpret_cast&lt;const void *&gt;(file_content)</span></code><span class="koboSpan" id="kobo.677.1">: Casts the character string to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.678.1">const void*</span></code><span class="koboSpan" id="kobo.679.1"> pointer as required by the function.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.680.1">strlen(file_content)</span></code><span class="koboSpan" id="kobo.681.1">: The number of bytes to write, calculated based on the length of the string.</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.682.1">Closes the file </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.683.1">after writing to ensure data integrity. </span><code class="inlineCode"><span class="koboSpan" id="kobo.684.1">lfs_file_close</span></code><span class="koboSpan" id="kobo.685.1"> flushes any pending writes to the storage medium and releases resources associated with the file.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.686.1">After writing data to a file, we will attempt to open the same file in read mode and read the data from it. </span><span class="koboSpan" id="kobo.686.2">The code for reading a file is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.687.1">if</span></span><span class="koboSpan" id="kobo.688.1">(lfs_file_open(&amp;lfs, &amp;file, </span><span class="hljs-string"><span class="koboSpan" id="kobo.689.1">“song.txt”</span></span><span class="koboSpan" id="kobo.690.1">, LFS_O_RDONLY)&gt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.691.1">0</span></span><span class="koboSpan" id="kobo.692.1">) {
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.693.1">    std</span></span><span class="koboSpan" id="kobo.694.1">::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.695.1">array</span></span><span class="koboSpan" id="kobo.696.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.697.1">char</span></span><span class="koboSpan" id="kobo.698.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.699.1">64</span></span><span class="koboSpan" id="kobo.700.1">&gt; buff = {</span><span class="hljs-number"><span class="koboSpan" id="kobo.701.1">0</span></span><span class="koboSpan" id="kobo.702.1">};
</span><span class="hljs-built_in"> </span><span class="koboSpan" id="kobo.703.1">lfs_file_read(&amp;lfs,
   </span><span class="hljs-built_in"> </span><span class="koboSpan" id="kobo.704.1">           &amp;file,
    </span><span class="hljs-built_in"> </span><span class="koboSpan" id="kobo.705.1">          reinterpret_cast&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.706.1">void</span></span><span class="koboSpan" id="kobo.707.1"> *&gt;(buff.data()),
    </span><span class="hljs-built_in"> </span><span class="koboSpan" id="kobo.708.1">          buff.size() - </span><span class="hljs-number"><span class="koboSpan" id="kobo.709.1">1</span></span><span class="koboSpan" id="kobo.710.1">);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.711.1">printf</span></span><span class="koboSpan" id="kobo.712.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.713.1">“This is content from the file\r\n%s\r\n”</span></span><span class="koboSpan" id="kobo.714.1">, buff.data());
    lfs_file_close(&amp;lfs, &amp;file);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.715.1">This code performs </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.716.1">the following steps:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.717.1">Attempts to open the file </span><code class="inlineCode"><span class="koboSpan" id="kobo.718.1">“song.txt”</span></code><span class="koboSpan" id="kobo.719.1"> for read-only access using the function </span><code class="inlineCode"><span class="koboSpan" id="kobo.720.1">lfs_file_open</span></code><span class="koboSpan" id="kobo.721.1"> and providing it with the flag </span><code class="inlineCode"><span class="koboSpan" id="kobo.722.1">LFS_O_RDONLY</span></code><span class="koboSpan" id="kobo.723.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.724.1">If the </span><code class="inlineCode"><span class="koboSpan" id="kobo.725.1">lfs_file_open</span></code><span class="koboSpan" id="kobo.726.1"> function returns a non-negative value, the code attempts to read data from the opened file.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.727.1">std::array&lt;char, 64&gt; buff = {0}</span></code><span class="koboSpan" id="kobo.728.1"> declares an array named </span><code class="inlineCode"><span class="koboSpan" id="kobo.729.1">buff</span></code><span class="koboSpan" id="kobo.730.1"> with a fixed size of </span><code class="inlineCode"><span class="koboSpan" id="kobo.731.1">64</span></code><span class="koboSpan" id="kobo.732.1"> characters and initializes all elements to zero (</span><code class="inlineCode"><span class="koboSpan" id="kobo.733.1">‘\0’</span></code><span class="koboSpan" id="kobo.734.1">), ensuring the buffer is null-terminated if treated as a C string.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.735.1">Reads data from opened files in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.736.1">buff</span></code><span class="koboSpan" id="kobo.737.1"> array using the function </span><code class="inlineCode"><span class="koboSpan" id="kobo.738.1">lfs_file_read</span></code><span class="koboSpan" id="kobo.739.1">. </span><span class="koboSpan" id="kobo.739.2">The function is provided with the following arguments:</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.740.1">&amp;lfs</span></code><span class="koboSpan" id="kobo.741.1">: A pointer to the filesystem object.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.742.1">&amp;file</span></code><span class="koboSpan" id="kobo.743.1">: A pointer to the file object associated with the opened file.</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.744.1">reinterpret_cast&lt;const void *&gt;(buff.data())</span></code><span class="koboSpan" id="kobo.745.1">: Casts the </span><code class="inlineCode"><span class="koboSpan" id="kobo.746.1">buff</span></code><span class="koboSpan" id="kobo.747.1"> underlying data array pointer to a const void* pointer as required by the function.</span></li>
</ul>
</li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.748.1">buff.size() – 1</span></code><span class="koboSpan" id="kobo.749.1">: The number of bytes to read from the file. </span><span class="koboSpan" id="kobo.749.2">Subtracting 1 reserves space for a null terminator (</span><code class="inlineCode"><span class="koboSpan" id="kobo.750.1">‘\0’</span></code><span class="koboSpan" id="kobo.751.1">) at the end of the string.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.752.1">Closes the file </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.753.1">after reading to ensure data integrity.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.754.1">You can run the full example in the Renode simulator. </span><span class="koboSpan" id="kobo.754.2">Start Visual Studio Code, attach it to the running container, open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.755.1">Chapter13/lfs_raii</span></code><span class="koboSpan" id="kobo.756.1"> project, as described in </span><a href="Chapter_04.xhtml"><em class="italic"><span class="koboSpan" id="kobo.757.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.758.1">, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.759.1">$ cd Chapter13/lfs_raii
$ cmake -B build
$ cmake --build build --target run_in_renode
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-188"><span class="koboSpan" id="kobo.760.1">Introducing an RAII-based C++ wrapper</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.761.1">Now, we will wrap</span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.762.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.763.1">littlefs</span></code><span class="koboSpan" id="kobo.764.1"> functionality in a simple C++ wrapper applying the RAII technique. </span><span class="koboSpan" id="kobo.764.2">We will create an </span><code class="inlineCode"><span class="koboSpan" id="kobo.765.1">fs</span></code><span class="koboSpan" id="kobo.766.1"> namespace with types </span><code class="inlineCode"><span class="koboSpan" id="kobo.767.1">lfs</span></code><span class="koboSpan" id="kobo.768.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.769.1">file</span></code><span class="koboSpan" id="kobo.770.1"> in it. </span><span class="koboSpan" id="kobo.770.2">Let us start with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.771.1">lfs</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.772.1">struct</span></code><span class="koboSpan" id="kobo.773.1"> code shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.774.1">namespace</span></span><span class="koboSpan" id="kobo.775.1"> fs{
</span><code class="inlineCode"><span class="koboSpan" id="kobo.776.1">struct</span></code> <span class="hljs-title"><span class="koboSpan" id="kobo.777.1">lfs</span></span><span class="koboSpan" id="kobo.778.1"> {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.779.1">lfs</span></span><span class="koboSpan" id="kobo.780.1">() = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.781.1">delete</span></span><span class="koboSpan" id="kobo.782.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.783.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.784.1">inline</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.785.1">lfs_t</span></span><span class="koboSpan" id="kobo.786.1"> fs_lfs;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.787.1">static</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.788.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.789.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.790.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.791.1">{
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.792.1">const</span></span><span class="koboSpan" id="kobo.793.1"> lfs_config * lfs_ramfs_cfg = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.794.1">get_ramfs_lfs_config</span></span><span class="koboSpan" id="kobo.795.1">();
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.796.1">lfs_format</span></span><span class="koboSpan" id="kobo.797.1">(&amp;fs_lfs, lfs_ramfs_cfg);
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.798.1">lfs_mount</span></span><span class="koboSpan" id="kobo.799.1">(&amp;fs_lfs, lfs_ramfs_cfg);
    }   
};
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.800.1">The purpose of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.801.1">struct</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.802.1">lfs</span></code><span class="koboSpan" id="kobo.803.1"> is to:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.804.1">Hold an instance of a filesystem object named </span><code class="inlineCode"><span class="koboSpan" id="kobo.805.1">fs_lfs</span></code><span class="koboSpan" id="kobo.806.1"> of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.807.1">lfs_t</span></code><span class="koboSpan" id="kobo.808.1"> used to interact with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.809.1">littlefs</span></code><span class="koboSpan" id="kobo.810.1"> filesystem.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.811.1">Implement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.812.1">static</span></code><span class="koboSpan" id="kobo.813.1"> method </span><code class="inlineCode"><span class="koboSpan" id="kobo.814.1">init</span></code><span class="koboSpan" id="kobo.815.1"> used to initialize the filesystem by calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.816.1">lfs_format</span></code><span class="koboSpan" id="kobo.817.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.818.1">lfs_mount</span></code><span class="koboSpan" id="kobo.819.1"> functions. </span><span class="koboSpan" id="kobo.819.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.820.1">init</span></code><span class="koboSpan" id="kobo.821.1"> method must be called before any file operations are performed.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.822.1">Next, let’s go over the </span><code class="inlineCode"><span class="koboSpan" id="kobo.823.1">file</span></code><span class="koboSpan" id="kobo.824.1"> class definition:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.825.1">namespace</span></span><span class="koboSpan" id="kobo.826.1"> fs{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.827.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.828.1">file</span></span><span class="koboSpan" id="kobo.829.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.830.1">public</span></span><span class="koboSpan" id="kobo.831.1">:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.832.1">file</span></span><span class="koboSpan" id="kobo.833.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.834.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.835.1">char</span></span><span class="koboSpan" id="kobo.836.1"> * filename, </span><span class="hljs-type"><span class="koboSpan" id="kobo.837.1">int</span></span><span class="koboSpan" id="kobo.838.1"> flags = LFS_O_RDONLY);
    ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.839.1">file</span></span><span class="koboSpan" id="kobo.840.1">();
    [[nodiscard]] </span><span class="hljs-type"><span class="koboSpan" id="kobo.841.1">bool</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.842.1">is_open</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.843.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.844.1">const</span></span><span class="koboSpan" id="kobo.845.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.846.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.847.1">read</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.848.1">(std::span&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.849.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.850.1">&gt; buff)</span></span><span class="koboSpan" id="kobo.851.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.852.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.853.1">write</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.854.1">(std::span&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.855.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.856.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.857.1">&gt; buff)</span></span><span class="koboSpan" id="kobo.858.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.859.1">private</span></span><span class="koboSpan" id="kobo.860.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.861.1">bool</span></span><span class="koboSpan" id="kobo.862.1"> is_open_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.863.1">false</span></span><span class="koboSpan" id="kobo.864.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.865.1">lfs_file_t</span></span><span class="koboSpan" id="kobo.866.1"> file_;
};
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.867.1">This code</span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.868.1"> shows methods and data members of the class file. </span><span class="koboSpan" id="kobo.868.2">Next, we will go through them, starting with the constructor shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.869.1">file</span></span><span class="koboSpan" id="kobo.870.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.871.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.872.1">char</span></span><span class="koboSpan" id="kobo.873.1"> * filename, </span><span class="hljs-type"><span class="koboSpan" id="kobo.874.1">int</span></span><span class="koboSpan" id="kobo.875.1"> flags = LFS_O_RDONLY) {
</span><span class="hljs-built_in"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.876.1">if</span></span><span class="koboSpan" id="kobo.877.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.878.1">lfs_file_open</span></span><span class="koboSpan" id="kobo.879.1">(&amp;lfs::fs_lfs, &amp;file_, filename, flags) &gt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.880.1">0</span></span><span class="koboSpan" id="kobo.881.1">) {
</span><span class="hljs-built_in"> </span><span class="koboSpan" id="kobo.882.1">is_open_ = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.883.1">true</span></span><span class="koboSpan" id="kobo.884.1">;
</span><span class="hljs-built_in"> </span><span class="koboSpan" id="kobo.885.1">}
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.886.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.887.1">file</span></code><span class="koboSpan" id="kobo.888.1"> constructor shown opens a file with the specified </span><code class="inlineCode"><span class="koboSpan" id="kobo.889.1">filename</span></code><span class="koboSpan" id="kobo.890.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.891.1">flags</span></code><span class="koboSpan" id="kobo.892.1">. </span><span class="koboSpan" id="kobo.892.2">It sets </span><code class="inlineCode"><span class="koboSpan" id="kobo.893.1">is_open_</span></code><span class="koboSpan" id="kobo.894.1"> to true if the file opens successfully. </span><span class="koboSpan" id="kobo.894.2">Next, let’s go over the destructor shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.895.1">~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.896.1">file</span></span><span class="koboSpan" id="kobo.897.1">() {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.898.1">if</span></span><span class="koboSpan" id="kobo.899.1">(is_open_) {
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.900.1">        printf</span></span><span class="koboSpan" id="kobo.901.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.902.1">“Closing file in destructor.\r\n”</span></span><span class="koboSpan" id="kobo.903.1">);
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.904.1">        lfs_file_close</span></span><span class="koboSpan" id="kobo.905.1">(&amp;lfs::fs_lfs, &amp;file_);
</span><span class="hljs-built_in"> </span><span class="koboSpan" id="kobo.906.1">}
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.907.1">The destructor </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.908.1">shown will close the file if it’s already opened. </span><span class="koboSpan" id="kobo.908.2">It calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.909.1">lfs_file_close</span></code><span class="koboSpan" id="kobo.910.1"> to close the file and release resources. </span><span class="koboSpan" id="kobo.910.2">The constructor and destructor implement the RAII technique – creating an object will acquire resources, and when the object’s lifetime ends, the destructor will release them. </span><span class="koboSpan" id="kobo.910.3">Next, let’s go over the read and write methods:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.911.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.912.1">read</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.913.1">(std::span&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.914.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.915.1">&gt; buff)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.916.1">{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.917.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.918.1">lfs_file_read</span></span><span class="koboSpan" id="kobo.919.1">(&amp;lfs::fs_lfs,
</span><span class="hljs-built_in"> </span><span class="koboSpan" id="kobo.920.1">&amp;file_,
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.921.1">                     reinterpret_cast</span></span><span class="koboSpan" id="kobo.922.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.923.1">void</span></span><span class="koboSpan" id="kobo.924.1"> *&gt;(buff.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.925.1">data</span></span><span class="koboSpan" id="kobo.926.1">()),
</span><span class="hljs-built_in"> </span><span class="koboSpan" id="kobo.927.1">buff.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.928.1">size</span></span><span class="koboSpan" id="kobo.929.1">() - </span><span class="hljs-number"><span class="koboSpan" id="kobo.930.1">1</span></span><span class="koboSpan" id="kobo.931.1">);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.932.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.933.1">write</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.934.1">(std::span&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.935.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.936.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.937.1">&gt; buff)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.938.1">{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.939.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.940.1">lfs_file_write</span></span><span class="koboSpan" id="kobo.941.1">(&amp;lfs::fs_lfs,
</span><span class="hljs-built_in"> </span><span class="koboSpan" id="kobo.942.1">&amp;file_,
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.943.1">                      reinterpret_cast</span></span><span class="koboSpan" id="kobo.944.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.945.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.946.1">void</span></span><span class="koboSpan" id="kobo.947.1"> *&gt;(buff.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.948.1">data</span></span><span class="koboSpan" id="kobo.949.1">()),
</span><span class="hljs-built_in"> </span><span class="koboSpan" id="kobo.950.1">buff.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.951.1">size</span></span><span class="koboSpan" id="kobo.952.1">());
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.953.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.954.1">read</span></code><span class="koboSpan" id="kobo.955.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.956.1">write</span></code><span class="koboSpan" id="kobo.957.1"> methods are simple wrappers for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.958.1">lfs_file_read</span></code><span class="koboSpan" id="kobo.959.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.960.1">lfs_file_write</span></code><span class="koboSpan" id="kobo.961.1"> functions. </span><span class="koboSpan" id="kobo.961.2">Both </span><code class="inlineCode"><span class="koboSpan" id="kobo.962.1">read</span></code><span class="koboSpan" id="kobo.963.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.964.1">write</span></code><span class="koboSpan" id="kobo.965.1"> use </span><code class="inlineCode"><span class="koboSpan" id="kobo.966.1">std::span</span></code><span class="koboSpan" id="kobo.967.1"> as function parameters for increased type safety and</span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.968.1"> better flexibility, as we can simply provide it with </span><code class="inlineCode"><span class="koboSpan" id="kobo.969.1">std::array</span></code><span class="koboSpan" id="kobo.970.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-189"><span class="koboSpan" id="kobo.971.1">Cleaner file management with RAII</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.972.1">Now, we will see how we can</span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.973.1"> use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.974.1">fs</span></code><span class="koboSpan" id="kobo.975.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.976.1">file</span></code><span class="koboSpan" id="kobo.977.1"> wrappers to </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.978.1">work with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.979.1">littlefs</span></code><span class="koboSpan" id="kobo.980.1"> filesystem. </span><span class="koboSpan" id="kobo.980.2">The code is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.981.1">fs::lfs::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.982.1">init</span></span><span class="koboSpan" id="kobo.983.1">();
{
</span><span class="hljs-function"><span class="koboSpan" id="kobo.984.1">    fs::file </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.985.1">song_file</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.986.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.987.1">“song.txt”</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.988.1">, LFS_O_WRONLY | LFS_O_CREAT)</span></span><span class="koboSpan" id="kobo.989.1">;
</span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.990.1">if</span></span><span class="koboSpan" id="kobo.991.1">(song_file.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.992.1">is_open</span></span><span class="koboSpan" id="kobo.993.1">()) {
</span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.994.1">song_file.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.995.1">write</span></span><span class="koboSpan" id="kobo.996.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.997.1">“These are some lyrics!”</span></span><span class="koboSpan" id="kobo.998.1">);
</span><span class="hljs-function"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.999.1">// destructor is called on song_file object</span></span>
<span class="hljs-function"> </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1000.1">// ensuring the file is closed</span></span><span class="koboSpan" id="kobo.1001.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1002.1">We first initialize the filesystem by calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.1003.1">fs::lfs::init()</span></code><span class="koboSpan" id="kobo.1004.1">. </span><span class="koboSpan" id="kobo.1004.2">Next, we introduce local scope to demonstrate a call to destructor and perform the next steps:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1005.1">Open </span><code class="inlineCode"><span class="koboSpan" id="kobo.1006.1">“song.txt”</span></code><span class="koboSpan" id="kobo.1007.1"> for writing (creating it if it doesn’t exist).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1008.1">Write a string literal in the file if it was opened successfully.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1009.1">Upon exit from the scope, the destructor is called, ensuring the file is closed.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1010.1">Next, we will open the file and read data from it. </span><span class="koboSpan" id="kobo.1010.2">The code is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.1011.1">fs::file </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1012.1">song_file</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1013.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1014.1">“song.txt”</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1015.1">)</span></span><span class="koboSpan" id="kobo.1016.1">;
std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1017.1">char</span></span><span class="koboSpan" id="kobo.1018.1">, 64&gt; buff = {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1019.1">0</span></span><span class="koboSpan" id="kobo.1020.1">};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1021.1">if</span></span><span class="koboSpan" id="kobo.1022.1">(song_file.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1023.1">is_open</span></span><span class="koboSpan" id="kobo.1024.1">()) {
</span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1025.1">song_file.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1026.1">read</span></span><span class="koboSpan" id="kobo.1027.1">(buff);
</span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1028.1">printf</span></span><span class="koboSpan" id="kobo.1029.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1030.1">“This is content from the file\r\n%s\r\n”</span></span><span class="koboSpan" id="kobo.1031.1">,
</span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1032.1">buff.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1033.1">data</span></span><span class="koboSpan" id="kobo.1034.1">());
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1035.1">This code performs the next steps:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1036.1">Opens </span><code class="inlineCode"><span class="koboSpan" id="kobo.1037.1">“song.txt”</span></code><span class="koboSpan" id="kobo.1038.1"> for reading (default mode).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1039.1">Declares </span><code class="inlineCode"><span class="koboSpan" id="kobo.1040.1">std::array&lt;char, 64&gt; buff</span></code><span class="koboSpan" id="kobo.1041.1">, initialized to zeros.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1042.1">Reads the data from the file in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1043.1">buff</span></code><span class="koboSpan" id="kobo.1044.1"> if the file is opened successfully.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1045.1">You can run the </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.1046.1">full example in the </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.1047.1">Renode simulator. </span><span class="koboSpan" id="kobo.1047.2">Start Visual Studio Code, attach it to the running container, open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1048.1">Chapter13/lfs_raii</span></code><span class="koboSpan" id="kobo.1049.1"> project, as described in </span><a href="Chapter_04.xhtml"><em class="italic"><span class="koboSpan" id="kobo.1050.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.1051.1">, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"><span class="koboSpan" id="kobo.1052.1">$ </span></span><span class="hljs-con-built_in"><span class="koboSpan" id="kobo.1053.1">cd</span></span><span class="language-bash"><span class="koboSpan" id="kobo.1054.1"> Chapter13/lfs_raii</span></span>
<span class="hljs-con-meta"><span class="koboSpan" id="kobo.1055.1">$ </span></span><span class="language-bash"><span class="koboSpan" id="kobo.1056.1">cmake -B build -DMAIN_CPP_FILE_NAME=main_lfs_raii.cpp</span></span>
<span class="hljs-con-meta"><span class="koboSpan" id="kobo.1057.1">$ </span></span><span class="language-bash"><span class="koboSpan" id="kobo.1058.1">cmake --build build --target run_in_renode</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1059.1">The simple C++ wrapper we wrote for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1060.1">littlefs</span></code><span class="koboSpan" id="kobo.1061.1"> library applies RAII principles, ensuring proper handling of resources as the destructor is called when an object’s lifetime ends. </span><span class="koboSpan" id="kobo.1061.2">This ensures the file is closed even when there are multiple return paths from a code. </span><span class="koboSpan" id="kobo.1061.3">It also simplifies the development experience as the code is less verbose and cleaner. </span><span class="koboSpan" id="kobo.1061.4">The usage of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1062.1">std:span</span></code><span class="koboSpan" id="kobo.1063.1"> increases safety.</span></p>
<h1 class="heading-1" id="_idParaDest-190"><span class="koboSpan" id="kobo.1064.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1065.1">In this chapter, we covered several techniques for using C libraries in C++ projects. </span><span class="koboSpan" id="kobo.1065.2">By wrapping C code in C++ classes, we can organize our code better in loosely coupled software modules. </span><span class="koboSpan" id="kobo.1065.3">C++ increases type safety and compile-time features allow us to easily organize C wrappers in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1066.1">static</span></code><span class="koboSpan" id="kobo.1067.1"> classes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1068.1">Applying RAII is simple and provides us with a powerful mechanism that takes care of resource management, as we saw in the example of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1069.1">littlefs</span></code><span class="koboSpan" id="kobo.1070.1"> filesystem.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1071.1">In the next chapter, we will go over super-loop in bare metal firmware and see how we can enhance it with mechanisms such as sequencer in C++.</span></p>
<h1 class="heading-1" id="_idParaDest-191"><span class="koboSpan" id="kobo.1072.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1073.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="https://packt.link/embeddedsystems"><span class="url"><span class="koboSpan" id="kobo.1074.1">https://packt.link/embeddedsystems</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.1075.1"><img alt="" role="presentation" src="../Images/QR_code_Discord.png"/></span></p>
</div>
</body></html>