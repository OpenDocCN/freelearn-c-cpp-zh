- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project #1 – a Smarter Setup for Sensing the Environment'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter guides you through the reasons why a clean environment is necessary
    for human beings and how to implement air quality, temperature, and humidity monitoring
    by using low-cost **ESP-series boards**, with different open source sensors and
    the **Arduino IoT Cloud**. Moreover, you will learn how to visualize the relevant
    data and use the Arduino IoT Cloud features to expand the functionalities of your
    applications/projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will gain confidence in how to build real-world solutions
    as we demonstrate **Printed Circuit Board** (**PCB**) design, its implementation,
    and its deployment in the real world. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is air quality monitoring necessary?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware components – sensors and development boards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the **Thing**, network credentials, cloud variables, and code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a dashboard for web and mobile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s next?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following hardware components are required to understand this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WeMos D1** **MINI ESP8266**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **DHT11**/**DHT22** sensor/module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **MQ-135** air quality module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PCB (a link is available in the *PCB design and assembling hardware* *components*
    section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Female headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper cables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For coding, we will use the **Arduino Web Editor**, which includes a large collection
    of development boards and sensor libraries, and the **Arduino IoT Cloud** for
    Thing and dashboard setup. To develop hardware and sensor designs, we will need
    **Fritzing** desktop software.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter is available at the book’s official GitHub repository,
    or you can directly download the code by following this link: [https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers/tree/main/Chapter%234%20Project%231%20Sensing%20and%20Monitoring%20the%20Air%20for%20Clean%20Environment](https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers/tree/main/Chapter%234%20Project%231%20Sensing%20and%20Monitoring%20the%20Air%20for%20Clean%20Environment).'
  prefs: []
  type: TYPE_NORMAL
- en: Why is air quality monitoring necessary?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Air quality monitoring is necessary for human beings because air pollution can
    have significant negative effects on our health and well-being. Poor air quality
    can cause a variety of respiratory and cardiovascular problems, such as asthma,
    chronic bronchitis, lung cancer, and heart disease. It can also exacerbate existing
    health conditions and reduce our ability to fight off infections and illnesses.
  prefs: []
  type: TYPE_NORMAL
- en: Air pollution can also impact the environment, including ecosystems, wildlife,
    and plants. Polluted air can lead to **acid rain**, which can damage crops, forests,
    and bodies of water and harm wildlife. It can also lead to the depletion of the
    ozone layer, which protects us from harmful UV radiation.
  prefs: []
  type: TYPE_NORMAL
- en: By monitoring air quality, we can identify areas where pollution levels are
    high and take steps to reduce exposure. This can include reducing emissions from
    factories, power plants, and transportation, as well as encouraging the use of
    clean energy and transportation alternatives. By improving air quality, we can
    help to protect our health, support the environment, and promote sustainable development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Air quality monitoring is necessary to assess the level of pollutants present
    in the air we breathe. It helps to identify the sources of pollution and to track
    changes in air quality over time. There are several reasons why air quality monitoring
    is important:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Regulatory compliance**: Many countries have regulations in place to limit
    the amount of pollutants that can be released into the air. Air quality monitoring
    is necessary to ensure that these regulations are followed and to identify areas
    where additional regulations may be necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Economic concerns**: Poor air quality can have a negative impact on economic
    activity, including reduced productivity, increased healthcare costs, and decreased
    tourism. Monitoring air quality can help to identify areas where pollution levels
    are high and take steps to improve air quality and support economic growth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, air quality monitoring is an essential tool to protect public health,
    preserve the environment, and promote sustainable economic development. Now we’ve
    had a theoretical review of air quality monitoring, it’s time to explore the project
    practically. Firstly, we will start with the hardware, where we will explore all
    the required components such as development boards, sensors, design diagrams,
    and PCB design for implementation. Later, we will set up the Thing and cloud variables,
    upload code to the development board, and set up the dashboard for data visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the hardware requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before moving forward, we will first look at what types of development boards
    and sensors are required to accomplish the project. We aim to use a board that
    provides Wi-Fi connectivity, is small in size, and is low in cost. If we talk
    about Wi-Fi-enabled development boards, then there are a lot of organizations
    providing them, such as **Arduino**, the **ESP32 series**, and the **ESP8266**
    series. Arduino development boards such as **MKR Wi-Fi 1010** and **MKR Wi-Fi
    1000** are expensive compared to ESP32 and ESP8266\. Now, we have two options:
    we either go with ESP32 or ESP8266 and leave the Arduino development boards. In
    this project, we will be using the WeMos D1 Mini, which is part of the ESP8266
    series. Although the ESP32 series offers similar features, it is equipped with
    **Bluetooth Low Energy** (**BLE**) connectivity, which is not currently compatible
    with this project. Thus, we have opted for the ESP8266 series development boards,
    which are not only compact in size but also more affordable.'
  prefs: []
  type: TYPE_NORMAL
- en: Among the sensors, there is a diverse range of options for measuring temperature,
    humidity, and air quality. However, our primary goal is to provide sensors that
    are affordable and readily available to users worldwide. For temperature and humidity
    measurements, we rely on the widely available and reasonably priced DHT11/DHT22
    sensors. The MQ-135 sensor provides a wide detecting scope, fast response, and
    high sensitivity. It is a stable and long-life, simple drive circuit application.
    These sensors are used in air quality control equipment and are suitable for detecting
    NH3, NOx, alcohol, benzene, smoke, CO2, and more. They are easily obtainable on
    the market and well-suited for small-scale projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ESP8266 series has a wide collection of development boards that vary in
    size and pins. In this chapter, I’m using the WeMos D1 Mini development board,
    as it’s very compact compared to other boards and, of course, cheaper in cost,
    and it provides 5V as well as 3.3V pins. The following figure is the complete
    overview of the WeMos D1 Mini board, and demonstrates all the digital/analog Arduino-based
    pin numbers, ground and power pins, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – WeMos D1 Mini ESP8266](img/B19752_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – WeMos D1 Mini ESP8266
  prefs: []
  type: TYPE_NORMAL
- en: WeMos provides multiple pins for digital input/output, but there is only one
    analog pin for input/output operations. If you want to use multiple analog sensors,
    then **analog-to-digital converters** are available. One of the most famous analog-to-digital
    converters is the **ADS1115**/**ADS1015 module**, which provides four analog pins
    that help cater to the requirement of using multiple sensors.
  prefs: []
  type: TYPE_NORMAL
- en: However, for the current project, we need one digital pin for the **DHT11**/**DHT22
    sensor** and one analog pin for the **MQ-135 air quality sensor**. One of the
    best features of the WeMos D1 Mini development board is the 5V power pin, which
    is not available on most ESP8266 series development boards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will use the DHT11 sensor to sense temperature and humidity, but you
    can also use the DHT22 sensor, depending on your requirements. With regard to
    features, the DHT22 provides a broader range of sensing compared to the DHT11,
    but its cost is higher. The following diagram shows the pinout layout of both
    sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The DHT22 and DHT11 pinout layouts](img/B19752_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The DHT22 and DHT11 pinout layouts
  prefs: []
  type: TYPE_NORMAL
- en: 'Pin #1 is the **voltage common collector** (**VCC**) and works with both 3.3V
    and 5V. Pin #2 is a **data** pin that connects with any digital pin of a development
    board, and Pin #4 is a **ground** (**GND**) pin that connects with the GND pin
    of a development board. There is another pin in the sensor, Pin #3, which is **Not
    Connected** (**NC**) – this pin is not used by us during development.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table explains all the specification differences between DHT22
    and DHT11; the most notable things are the **sensing range** and the **sensing
    period**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Model** | **DHT22** | **DHT11** |'
  prefs: []
  type: TYPE_TB
- en: '| Power supply | 3.3–5V |'
  prefs: []
  type: TYPE_TB
- en: '| Output signal | A digital signal via a single bus |'
  prefs: []
  type: TYPE_TB
- en: '| Sensing element | Polymer capacitor |'
  prefs: []
  type: TYPE_TB
- en: '| Sensing range | Humidity: 0–100% RHTemperature: 40~80 Celsius | Humidity:
    20–90% RHTemperature: 0~50 Celsius |'
  prefs: []
  type: TYPE_TB
- en: '| Accuracy | Humidity: ± 2% RH (Max ±5% RH)Temperature: <±0.5 Celsius | Humidity:
    ±1% RH (Max ± 5% RH)Temperature: <±2 Celsius |'
  prefs: []
  type: TYPE_TB
- en: '| Sensing period | Average 2s | Average 1s |'
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – DHT11 vs DHT22 comparison
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will look at the main sensor for our project. The MQ-135 sensor
    is used to monitor the air quality of a specific area. It is a low-cost environment-monitoring
    sensor, and it monitors a wide range of parameters, such as smoke, carbon dioxide,
    ammonia, benzene, nitrogen oxides, and alcohol. The MQ-135 senses all these parameters
    and provides the value of air quality in **parts per million** (**ppm**). The
    following figure shows the MQ-135’s shape and its pin layout diagram as well as
    indicators for the LED and regulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – MQ-135 sensor and pinout](img/B19752_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – MQ-135 sensor and pinout
  prefs: []
  type: TYPE_NORMAL
- en: 'The MQ-135 sensor module consists of four pins, and each pin is marked with
    a code: **Analog Output** (**AO**), **Digital Output** (**DO**), GND, and VCC.
    The module provides readings on both analog and digital modes, but analog mode
    is best to get values in PPM. The sensor operates better with 5V power, but you
    can still use 3.3V, although I recommend the former. The MQ-135 requires 20 seconds
    of preheating to provide better readings, so make sure to get readings after an
    interval of every 20 seconds, or at least wait 20 seconds for the first-time boot
    of the development board.'
  prefs: []
  type: TYPE_NORMAL
- en: The module also contains a regulator to control the sensitivity of sensors,
    which could be adjusted according to the environment. Different indicator **Surface
    Mount Device** (**SMD**) LEDs are available to verify the module status, which
    includes **Logic Out LED** and **Power LED**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the project architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding sections, we discussed the sensors and development board in
    detail. Now, it’s time to cook the recipe. In hardware development, before getting
    to work with sensors and development boards, we need to develop design concepts
    to get a better understanding of how things will be connected. There is a lot
    of software available to design and develop design concepts regarding electronics
    projects, but we will opt for Fritzing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we will talk about the schematics and the design of
    the project, which explains how to connect the pins to the development board.
    In the subsection after that, we will talk about the PCB design and its implementation
    to make a product ready for deployment in the field.
  prefs: []
  type: TYPE_NORMAL
- en: Schematics and design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of our design is to get a clear understanding of how sensors will
    connect with the development board. It helps engineers develop a prototype on
    a **breadboard** or **Veroboard** by using our design files. The other major benefit
    of designing is that Fritzing builds hardware schematics and the PCB design in
    the background according to your design, which can be adjusted by designers according
    to system requirements. The following design provides a full overview of how you
    can connect sensors to a development board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – An air quality-monitoring system design](img/B19752_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – An air quality-monitoring system design
  prefs: []
  type: TYPE_NORMAL
- en: For better understanding we have developed the schematics diagram shown in *Figure
    4**.4* as well *Table 4.2* for easy understanding. The pin configuration will
    be discussed in detail in proceeding paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: '| **We Mos** **D1 mini** | **MQ-135** | **DHT22** |'
  prefs: []
  type: TYPE_TB
- en: '| 5V | VCC | VCC |'
  prefs: []
  type: TYPE_TB
- en: '| GND | GND | GND |'
  prefs: []
  type: TYPE_TB
- en: '| A0 | A0 | - |'
  prefs: []
  type: TYPE_TB
- en: '| D1 | - | Data |'
  prefs: []
  type: TYPE_TB
- en: Table 4.2 – Pin configuration table for sensors
  prefs: []
  type: TYPE_NORMAL
- en: According to the design (*Figure 4**.4* and *Table 4.2*), we have a common 5V
    output and GND from the development board to both sensors. The MQ-135 sensor is
    an analog sensor, so we connected its AO pin to the AO pin of the WeMos development
    board, while DHT11/DHT22 are digital sensors, and their Pin 2 is connected to
    the D1 pin of the development board.
  prefs: []
  type: TYPE_NORMAL
- en: PCB design and the assembly of hardware components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding subsection, we looked at a design that is ideal for creating
    a prototype using a breadboard or Veroboard, but what if we want to deploy that
    solution in the field? **Fritzing** is a great tool that provides the option to
    design the PCB, but when you develop the design, it automatically creates the
    PCB design in the backend, which is accessible via the **PCB Design** tab. Automatic
    PCB design is just a basic footprint and not suitable for direct production, so
    it’s mandatory to review and rearrange the design according to professional practices.
    The following diagram demonstrates the final PCB design of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – An air quality-monitoring system PCB design](img/B19752_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – An air quality-monitoring system PCB design
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to develop the PCB; just make sure that the connection line doesn’t
    intersect with other connection lines. There are many different tools available
    for PCB design, such as EasyEDA, CircuitMaker, and Altium, but it is thanks to
    Fritzing that I could create that design so easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the PCB design, you have two options. First, you can develop the PCB
    by yourself using a DIY method, which is good for learning purposes but not suitable
    for a large-scale product. The second method is to choose a professional organization
    that manufactures the PCB professionally. Many organizations in China provide
    PCB manufacturing and fabrication services, such as **Seeed Studio**, **JLCPCB**,
    and **PCBWay**. I have tried PCBWay and was impressed with their manufacturing
    and shipment delivery time. I have uploaded the PCB design to the PCBWay project
    repository; from there, you can select and order it easily: [https://www.pcbway.com/project/shareproject/Low_cost_Outdoor_Air_Quality_Monitoring_System_0157f1af.html](https://www.pcbway.com/project/shareproject/Low_cost_Outdoor_Air_Quality_Monitoring_System_0157f1af.html).'
  prefs: []
  type: TYPE_NORMAL
- en: After getting the PCB board, it’s time to solder the female headers for the
    development boards and sensors. Never solder the development board and sensors
    directly on the PCB, as if anything stops working, then it’s easy to detach and
    replace. So finally, here we have a product ready where the sensors and development
    board are soldered on the PCB for final deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – An air-quality monitoring system on the PCB](img/B19752_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – An air-quality monitoring system on the PCB
  prefs: []
  type: TYPE_NORMAL
- en: After the female headers are soldered onto the PCB, WeMos and the other sensors
    are plugged into the headers, as shown in the preceding diagram. In this section
    and the previous section, we explored what types of sensors and development boards
    will be used in our project, and the latter part of this section discussed design,
    which demonstrates the wiring system for connectivity between sensors and the
    WeMos D1 Mini. Finally, we explored PCB design and assembled all the components
    of the PCB. Next, we need to set up the Thing, code, and dashboard in the Arduino
    IoT Cloud to get ready for the final product.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Thing, network credentials, cloud variables, and code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After setting up the hardware, it’s time to set up the Thing in the Arduino
    IoT Cloud. For this project, we need three cloud variables to fetch the monitoring
    parameters from the device, and the Wi-Fi network settings will be different as
    compared to Arduino development boards, due to the ESP series-based development
    board. The following figure provides an overview of the Thing, including **Cloud
    Variables**, **Associating a device**, and **Network** settings with numbers,
    which will be discussed next step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – The air quality-monitoring system Thing setup](img/B19752_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – The air quality-monitoring system Thing setup
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up a new Thing with the name `Sense the Environment`. Follow the next steps
    to create variables, the associated device, the network configuration, and finally,
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we need to set up three cloud variables regarding air quality, humidity,
    and temperature. The complete details regarding cloud variables are available
    in the next subsection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we need to associate the device with the Thing. In the current project,
    we will use the WeMos D1 Mini so the wizard will be different from the Arduino
    boards. The complete details are available in the *Associating a* *device* subsection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to set up the network configuration for the device, but this
    time, we need to provide a security key for ESP series boards to make the connection
    secure. The Arduino-compatible boards are configured by the Arduino IoT Cloud
    automatically during the device setup wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the setup of cloud variables, device, and network settings, we will go
    through the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we have given an overview of the Thing and we also discussed the required
    steps that will be carried out to complete the Thing setup.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following table explains all the properties of the variable that we need
    to use when we create the cloud variable. An integer is a very famous data type,
    but we will use two new variable types for humidity (`CloudRelativeHumidity`)
    and temperature (`CloudTemperatureSensor`), which measure data in percentage and
    Celsius, respectively. Next, make sure to declare the variables exactly as stated
    in the given table, including case-sensitive names and variable types. If the
    example code does not match your naming, you will need to modify it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '| **S#** | **Variable name** | **Variable type** | **Declaration** | **Permission**
    | **Update policy** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `AirQuality` | `int` | `airQuality` | Read-only | **On change** |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `Humidity` | `CloudRelative Humidity` | `humidity` | Read-only | **On
    change** |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `Temperature` | `CloudTemperature Sensor` | `temperature` | Read-only
    | **On change** |'
  prefs: []
  type: TYPE_TB
- en: Table 4.3 – Cloud variables details
  prefs: []
  type: TYPE_NORMAL
- en: Here, we made the **permission** read-only; although we have a read/write option,
    in our project, we only want to receive data from the device instead of a dashboard
    modification. That’s why read-only mode is used to prevent issues in data consistency.
    **Update policy** is set to **On change**, as the device will send the data after
    five minutes, and this option is more appropriate compared to periodic updates.
  prefs: []
  type: TYPE_NORMAL
- en: Associating a device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After creating the variables, it’s time to add a device and associate it with
    the Thing. Before adding the device, connect the development board to the computer
    and open the **Arduino Create Agent** application. The following figure shows
    the different types of third-party boards that are supported by the Arduino IOT
    Cloud, and in that step, we will select the **ESP8266** series board.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The device selection wizard](img/B19752_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The device selection wizard
  prefs: []
  type: TYPE_NORMAL
- en: 'Please follow these steps to add the device to the Arduino IoT Cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Select Device** button under the **Associating a device** section
    on the Thing page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A popup will appear, where you can see all the devices that are already available.
    If you have already added your WeMos D1 Mini, select it. Otherwise, click on **SET
    UP** **NEW DEVICE**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on the **Third party** **device** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **ESP8266** and **LOLIN(WEMOS) D1 R2 mini** from the dropdown, and click
    on the **CONTINUE** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the device name and click on the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the final wizard, the device ID and secret key will be displayed. Copy the
    secret key to a safe place, as it will be used during the network configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After setting up the device and associating it with the Thing, it’s time to
    configure the device network settings. The following sections will cover all the
    steps to configure your device for a Wi-Fi network.
  prefs: []
  type: TYPE_NORMAL
- en: Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After associating the device with the Thing, it is time to configure the Wi-Fi
    settings for device communication. Fill in the form with **Wi-Fi Name** and **Password**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – The network configuration for the Thing](img/B19752_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – The network configuration for the Thing
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**.9*, you will find a new field for **Secret Key**. Paste the secret
    key that we received from the system during the device association process, which
    is explained in *step 6* in the preceding subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are done with the device association to the Thing as well as with network
    settings. The next step is to understand and upload the code. The following section
    will guide you through the code.
  prefs: []
  type: TYPE_NORMAL
- en: Coding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The chapter’s code is available at the book’s official GitHub repository, or
    you can directly download the code by following this link: [https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers/tree/main/Chapter%234%20Project%231%20Sensing%20and%20Monitoring%20the%20Air%20for%20Clean%20Environment/Sense_the_Environment_feb24a](https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers/tree/main/Chapter%234%20Project%231%20Sensing%20and%20Monitoring%20the%20Air%20for%20Clean%20Environment/Sense_the_Environment_feb24a)'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the code and put it into your Thing by navigating to the `delay`
    method, as it will block the `ArduinoCloud.update()` method and then call the
    `STHAM` method every five minutes. The following code is demonstrating how to
    fetch Temperature and Humidity values from `dht` object, and for `airQuality`
    we are simply using `analogRead()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet was taken from the `STHAM` method; here, we just
    modified the code to show you how we send values to the Arduino IoT Cloud after
    taking values from the sensors.
  prefs: []
  type: TYPE_NORMAL
- en: In a previous section, we created the cloud variables. Just recall the cloud
    variable declaration and assign the sensor readings to those variables. This cloud
    variable declaration is available in the `thingProperties.h` file. So, when you
    assign the values to these variables, the `ArduinoCloud.update()` method in the
    loop will automatically send data to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Upload the code to the device and verify the connectivity and readings. If you
    want to change the reading time, then just modify the `interval` variable value.
    Make sure you provide the time in milliseconds, where 1 second equals 1,000 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you used different naming in the variable declaration, then update the code
    according to your naming scheme. However, it’s better that you first follow all
    the steps according to the book and later change the cloud variable names and
    modify your code, in that order.
  prefs: []
  type: TYPE_NORMAL
- en: Never try to use `delay` method, which will create a block for the `ArduinoCloud.update()`
    method. Always use milliseconds to calculate the waiting time. Review the `loop()`
    method to understand how we call the method after 5 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Arduino IoT Cloud only updates the value on the dashboard whenever a variable
    value is changed. For example, if the temperature is 30 and is still the same
    after 5 minutes, then the Arduino IoT Cloud will not record the value, so don’t
    get confused if values don’t change on a graph. This is another benefit of the
    Arduino IoT Cloud: you will not get duplicated data when you export the content.'
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully set up the Thing, which includes cloud variables, device
    association, network configuration, and code, and uploaded it to the development
    board. Now, it’s time to explore the dashboard and sensor values visualization
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a dashboard for web and mobile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After uploading the code to the device, it’s time to set up a dashboard for
    web and mobile to visualize the data with different widgets. Complete details
    about widgets and their usage are available in [*Chapter 3*](B19752_03.xhtml#_idTextAnchor056).
    If you have directly skipped to this chapter, I recommend going back to [*Chapter
    3*](B19752_03.xhtml#_idTextAnchor056) to get a detailed overview of widgets and
    their usage as this will help you to understand how widgets work and their usage
    for different use cases. The following figure demonstrates the visualization of
    readings with different widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – The Thing dashboard](img/B19752_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – The Thing dashboard
  prefs: []
  type: TYPE_NORMAL
- en: We have three different readings, **Temperature**, **Humidity**, and **Air Quality**.
    For each reading, we use different widget controls to demonstrate how they all
    work, but for historical data, graphs are the best widgets.
  prefs: []
  type: TYPE_NORMAL
- en: The **Temperature** reading is visualized by **Gauge**, the **Humidity** reading
    is connected to the **Percentage** widget, and the **Air Quality** reading is
    connected to the **Value** widget. These widgets are only capable of displaying
    current readings of sensors. However, we also want to monitor the historical data,
    and graphs are the best widgets to display live as well as older data. Here, we
    have used three graphs, and each one is connected to a specific cloud variable.
  prefs: []
  type: TYPE_NORMAL
- en: What’s next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We still have a lot of options available to explore, but now it’s your turn
    to use different sensors and development boards to do some more experiments and
    learn from them. In this chapter, we have only used two sensors, which only offer
    three parameters, but there are a lot of sensors on the market that provide a
    wide variety of functionalities, such as air pressure and measurements for different
    gases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following sensors to enhance your practical knowledge and compare
    them with other sensors in terms of features, range, and cost:'
  prefs: []
  type: TYPE_NORMAL
- en: The **BMP280** (pressure and temperature) sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **MH-Z19C/D/E series** sensors for carbon dioxide monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **MQ series** sensors, which are designed to sense different specific gases,
    including MQ-2, MQ-3, MQ-4, MQ-5, MQ-7, MQ-8, and MQ-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seeed Studio SCD30** (temperature, humidity, and CO2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gravity**: **Analog Electrochemical Carbon Dioxide Sensor** (0–10,000 PPM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how to develop a low-cost air quality monitoring
    system using DHT11, MQ-135, and the WeMos D1 Mini development board. We set up
    the Thing, which involved creating cloud variables, associating the device, configuring
    the network, and coding the development board. Later, we created a dashboard to
    visualize the Thing’s sensor readings with different types of widgets, displaying
    the current readings as well as historical data with the help of graphs. Through
    this project, you will get the confidence to set up the Thing practically and
    deploy it in the field using a PCB. You have learned about new types of cloud
    variables for sensor readings and storage, as well as dealing with different types
    of dashboard widgets.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will study GSM technology for IoT. We will learn about
    different types of global IoT SIM cards and their usage. This project will also
    demonstrate a Smart Assets tracing example, where we will track the asset with
    a GPS module and send the data to the Arduino IoT Cloud via global IoT SIM cards.
    In the end, you will also learn about new widgets in the Arduino IoT Cloud to
    visualize the location of your assets on the basis of GPS coordinates.
  prefs: []
  type: TYPE_NORMAL
