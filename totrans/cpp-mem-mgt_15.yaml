- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Contemporary Issues
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当代问题
- en: We are reaching the end of our journey, dear reader. Over the course of this
    book, we have examined fundamental aspects of the C++ object model and discussed
    dangerous aspects of low-level programming. We have looked at the fundamentals
    of resource management in C++ through the RAII idiom, looked at how smart pointers
    are used, and explored how to write such a type. We also took control of the memory
    allocation functions at our disposal (and we did that in many ways!), and we wrote
    containers that manage memory themselves as well as through other objects or types,
    including allocators.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将结束这段旅程，亲爱的读者。在这本书的过程中，我们探讨了 C++ 对象模型的基本方面，并讨论了低级编程的危险之处。我们通过 RAII 习语研究了
    C++ 中资源管理的根本，了解了智能指针的使用方法，并探讨了如何编写此类类型。我们还掌握了可用的内存分配函数（我们以多种方式做到了这一点！），并编写了能够自行管理内存以及通过其他对象或类型（包括分配器）来管理内存的容器。
- en: That was quite an experience!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一次相当的经历！
- en: What do we still have to cover? Well, so much… but there’s a limit to what we
    can put in a single book. So, to conclude our discussion of memory management
    in C++, I thought we might have a chat (yes, dear reader, just you and I) about
    some of the interesting topics in contemporary memory management in C++. Yes,
    things that were so recently standardized (as of this writing) that most, if not
    all, libraries still do not implement them, and things the standards committee
    is actively working on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要讨论什么？嗯，很多……但是一本书能包含的内容是有限的。因此，为了总结我们对 C++ 内存管理的讨论，我想我们可以聊一聊（是的，亲爱的读者，就你和我）一些当代
    C++ 内存管理中的有趣话题。是的，一些最近才标准化（截至本书写作时）的事情，大多数（如果不是所有）库还没有实现它们，以及标准委员会正在积极工作的内容。
- en: 'It’s important to look at C++ as it is today and how it might be in the near
    future because the language continues to evolve, and at quite a quick pace: a
    new version of the C++ standard is issued every three years, and this has been
    the case since 2011\. The evolution of C++ is too slow for some and too quick
    for others, but it is unrelenting (we call this publishing rhythm the “train model”
    to highlight its sustained pace) and brings regular progress and innovation to
    this language that we love so much.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要看看 C++ 当前的样子以及它可能近期的样子，因为该语言仍在不断进化，而且速度相当快：每三年就会发布一个新的 C++ 标准版本，这种情况自 2011
    年以来一直如此。C++ 的进化对于一些人来说太慢，对于另一些人来说又太快，但它是不懈的（我们称这种发布节奏为“火车模型”，以强调其持续的步伐），并为我们所热爱的这种语言带来了定期的进步和创新。
- en: 'As of this writing, in the early weeks of 2025, C++23 is a freshly adopted
    standard, having been officialized in November 2024 (yes, I know: the ISO process
    does take some time), and the committee is discussing proposals meant for C++26
    (yes, already!) and C++29.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2025 年初，C++23 是一个新采用的标准，于 2024 年 11 月正式化（是的，我知道：ISO 流程确实需要一些时间），委员会正在讨论旨在
    C++26（是的，已经！）和 C++29 的提案。
- en: The memory management-related topics we will discuss in this chapter are either
    aspects of the C++23 standard that we have not discussed in this book yet or are
    some that, as this chapter is being written, are under discussion for upcoming
    standards. Be aware, dear reader, that what you will now read may become reality
    in the form you will read about, but it might also come along in another form
    after discussions and debates in the C++ standards committee… or it might, in
    the end, never come to be.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的与内存管理相关的话题，要么是 C++23 标准中我们尚未在本书中讨论的方面，要么是随着本章的编写正在进行讨论的，即将到来的标准中的某些话题。亲爱的读者，请注意，你现在将读到的内容可能会以你将读到的方式成为现实，但也可能在
    C++ 标准委员会的讨论和辩论后以另一种形式出现……或者最终可能永远不会出现。
- en: Even if these topics do not end up entering the C++ standard in the form in
    which they were initially discussed, you will know that they will have been discussed,
    along with the problems they were meant to solve, and that these features might
    become part of the language at some point. Who knows; maybe you will have an epiphany
    and find the words to turn one of these ideas into a proposal that the C++ standards
    committee will discuss, and then adopt.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这些话题最终没有以最初讨论的形式进入 C++ 标准，你也会知道它们已经被讨论过，以及它们旨在解决的问题，并且这些特性可能在某个时刻成为语言的一部分。谁知道呢；也许你会有顿悟，找到将这些想法中的一个转化为提案，然后
    C++ 标准委员会将讨论并采纳。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Explicitly starting the lifetime of one or many objects without resorting to
    their constructors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确地开始一个或多个对象的生命周期，而不使用它们的构造函数
- en: 'Trivial relocation: what it means and in what ways the standards committee
    is trying to address it'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单重定位：它的含义以及标准委员会试图以何种方式解决它
- en: 'Type-aware allocation and deallocation functions: what they would do and how
    to benefit from them'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型感知的分配和释放函数：它们会做什么以及如何从中受益
- en: Our approach in this chapter will be to present these new features (or features-to-be)
    through the perspective of the problems we are trying to solve. The intent behind
    this approach is to make it clear that these features address actual issues and
    will help real programmers do their jobs better.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将通过解决我们试图解决的问题的视角来介绍这些新特性（或即将推出的特性）。这种方法的意图是清楚地表明这些特性解决实际问题，并将帮助真正的程序员更好地完成工作。
- en: I hope this chapter will give you insights into an interesting (albeit non-exhaustive)
    set of contemporary issues in memory management and associated facilities as they
    pertain to C++.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这一章能给您提供一个有趣的（尽管不是详尽的）当代内存管理和相关设施问题的见解，这些问题与C++相关。
- en: A note on code examples for this chapter
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章代码示例的说明
- en: 'If you try to compile the examples in this chapter, esteemed reader, you might
    find yourself saddened by the fact that some will not compile yet and others might
    not compile for a while, or ever. This situation is normal for a chapter such
    as this one: we will be discussing a combination of features that have been very
    recently added to the C++ language (recently enough that they have not yet been
    implemented at the time of authoring this book) and features that are under discussion
    by the C++ standards committee. Take the examples as illustrations, then, and
    adjust them as the features take a more formal shape.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试编译本章的示例，尊敬的读者，您可能会因为一些示例无法编译而感到沮丧，而其他示例可能需要一段时间才能编译，或者永远无法编译。对于这样一个章节来说，这种情况是正常的：我们将讨论最近添加到C++语言中的特性组合（最近到以至于在撰写本书时尚未实现）以及C++标准委员会正在讨论的特性。因此，将这些示例作为说明，并根据特性的更正式形式进行调整。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code files for this chapter in the book’s GitHub repository:
    [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter15](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter15).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub仓库中找到本章的代码文件：[https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter15](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter15).
- en: Starting object lifetime without constructors
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不使用构造函数开始对象的生命周期
- en: 'Consider the case of a program that consumes serialized data from a stream
    and that seeks to make objects from that data. Here’s an example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个程序，它从流中消费序列化数据并试图从该数据中创建对象的情况。以下是一个示例：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, in this example, we have the `Point3D` class. An object of this
    type represents a set of *x,y,z* coordinates. We also have a `read_from_stream<N>()`
    function that consumes bytes from a file. The function then stores at most `N`
    bytes into argument `buf`, which is passed by reference and returns the number
    of bytes read (which might be zero but will never be more than `N`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这个例子中，我们有`Point3D`类。此类对象代表一组*x, y, z*坐标。我们还有一个`read_from_stream<N>()`函数，它从文件中读取字节。该函数然后将最多`N`字节存储到通过引用传递的参数`buf`中，并返回读取的字节数（可能为零，但永远不会超过`N`）。
- en: 'For the sake of this example, we will suppose that the file from which we plan
    to read is known to contain the binary form of serialized `Point3D` objects, equivalent
    to objects of type `float` serialized in binary format by groups of three. Now,
    consider the following program, which consumes the byte representation of at most
    four objects of type `Point3D` from a file named `some_file.dat`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个例子，我们将假设我们计划从中读取的文件已知包含序列化的`Point3D`对象的二进制形式，相当于按组三序列化的`float`类型对象。现在，考虑以下程序，它从名为`some_file.dat`的文件中消费最多四个`Point3D`类型对象的字节表示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This example program reads bytes from a file into a `std::array` object big
    enough to contain the bytes of four objects of type `Point3D`, having first ensured
    that this array would be aligned appropriately if it were to hold objects of that
    type. This alignment consideration is essential as we plan to treat the bytes
    as objects of that type once those bytes have been read.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例程序从文件中读取字节到足够容纳四个`Point3D`类型对象字节的`std::array`对象中，首先确保如果这个数组要容纳该类型的对象，其对齐方式是适当的。这种对齐考虑是至关重要的，因为我们计划在读取这些字节后将其作为该类型的对象来处理。
- en: The point of this example is that once the bytes have been read, the programmer
    is confident (well, as confident as one could be) that *all the bytes are correct*
    for some hypothetical `Point3D` objects but still cannot use these objects as
    *their lifetime has not* *yet started*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的目的是，一旦读取了字节，程序员可以确信（嗯，尽可能确信）对于一些假设的`Point3D`对象，所有的字节都是正确的，但仍然不能使用这些对象，因为它们的生命周期尚未开始。
- en: 'This sort of situation traditionally makes many C programmers smile and some
    C++ programmers cringe: the C++ object model imposes constraints on programs that
    make it **UB** (see [*Chapter 2*](B21071_02.xhtml#_idTextAnchor027)) to use objects
    outside of their lifetime, even if all the bytes are right and alignment constraints
    have been respected, whereas C is less restrictive. To use the contents of the
    buffer we just used to read from that file, our options are traditionally as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况通常会让许多C程序员微笑，而一些C++程序员则会皱眉：C++对象模型对程序施加了约束，使得程序在对象的生命周期之外使用对象成为**UB**（见[*第2章*](B21071_02.xhtml#_idTextAnchor027)），即使所有字节都是正确的，并且对齐约束得到了遵守，而C语言则不那么严格。为了使用我们刚才用来从该文件读取内容的缓冲区的内容，我们的传统选项如下：
- en: To loop through the array of bytes, write appropriately-sized subsets of those
    bytes into objects of type `float`, then call the constructors of `Point3D` objects
    and put them in another container.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要遍历字节数组，将适当大小的字节子集写入`float`类型的对象中，然后调用`Point3D`对象的构造函数并将它们放入另一个容器中。
- en: To `reinterpret_cast` the array of bytes into an array of `Point3D` objects
    and hope for the best, leading to code that might or might not work and, being
    UB, would not be portable anyway (not even between versions of a given compiler).
    With our `Point3D` objects, it will probably give the results one would hope for,
    but replace these with, say, `std::complex<float>` objects from the standard library
    (a type that probably has a similar inner structure as our `Point3D` type) and…
    well, who knows what might happen?
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字节数组`reinterpret_cast`为`Point3D`对象数组，并寄希望于最好，这可能导致可能或可能不工作的代码，并且由于是UB，因此无论如何都不具有可移植性（甚至不是在给定编译器的版本之间）。使用我们的`Point3D`对象，它可能会给出人们希望得到的结果，但将这些替换为，比如说，来自标准库的`std::complex<float>`对象（这种类型可能具有与我们的`Point3D`类型相似的内结构）……嗯，谁知道会发生什么呢？
- en: To `std::memcpy()` the array of bytes into itself, casting the return value
    to type `Point3D*` and using the resulting pointer as if it were an array of `Point3D`
    objects. That’s actually valid (the `std::memcpy()` function is part of a select
    set of functions that are allowed to start the lifetime of objects). There is,
    of course, the risk of creating an actual copy of the bytes (which would be wasted
    execution time); some standard libraries are said to recognize that pattern and
    just behave as if the call was a no-op, but a special kind of no-op that can start
    the lifetime of objects.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字节数组`std::memcpy()`到自身，将返回值转换为`Point3D*`类型，并使用得到的指针作为`Point3D`对象数组来使用。这实际上是有效的（`std::memcpy()`函数是允许启动对象生命周期的函数集的一部分）。当然，存在创建实际字节副本的风险（这将浪费执行时间）；据说某些标准库能够识别该模式，并且表现得就像调用是一个no-op一样，但这是一个可以启动对象生命周期的特殊类型的no-op。
- en: None of these options seems truly satisfactory, however, so a cleaner solution
    that does not rely on compiler-specific optimizations is needed. To that effect,
    the C++23 standard introduces a set of `constexpr` functions (accompanied by a
    number of overloads) that are called `std::start_lifetime_as_array<T>(p,n)` and
    `std::start_lifetime_as<T>(p)`. Both are portable forms of magical no-op functions
    that inform the compiler that the bytes are OK and to consider the lifetime of
    the pointees as having begun.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些选项似乎都不真正令人满意，因此需要一个更干净、不依赖于编译器特定优化的解决方案。为此，C++23标准引入了一组`constexpr`函数（附带一些重载），它们被称为`std::start_lifetime_as_array<T>(p,n)`和`std::start_lifetime_as<T>(p)`。这两个都是告知编译器字节是正确的，并且要考虑引用对象的生存期已开始的便携式魔法no-op函数。
- en: Of course, if for some reason the pointees have non-trivial destructors, you
    should make sure that your code calls these destructors when appropriate. Expect
    this situation to be rare and unusual. Since we consumed raw bytes from some source
    of data and turned these bytes into objects, the probability that the resulting
    objects own resources is somewhat slim. Of course, these objects can acquire resources
    once their lifetimes have begun. Let’s be honest, dear reader; C++ programmers
    are nothing if not creative!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果出于某种原因，指针的目标有非平凡的析构函数，你应该确保你的代码在适当的时候调用这些析构函数。预期这种情况很少见且不寻常。由于我们从某些数据源中消耗了原始字节并将这些字节转换成了对象，因此结果对象拥有资源的可能性相对较小。当然，一旦它们的生命周期开始，这些对象可以获取资源。让我们坦诚地说，亲爱的读者；如果C++程序员不是富有创造力的，那还有什么？
- en: This set of `std::start_lifetime_...` functions is expected to be a boon to
    network programmers everywhere, in particular. These individuals often receive
    data frames of well-formed byte sequences that they need to turn into objects
    for the purpose of further processing. These functions are also expected to be
    useful to programs that consume bytes from files in order to form aggregates.
    Many programmers think that just reading bytes into an array of bytes and casting
    that array to an intended type (or array thereof) suffices to get access to the
    (hypothetical) object (or objects) therein and are surprised when their C++ code
    starts behaving unexpectedly. C++ is a systems programming language, and the set
    made of these `std::start_lifetime_...` functions closes a gap where it could
    be said to be underperforming.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这套`std::start_lifetime_...`函数预计将成为网络程序员的福音，尤其是这些人。他们经常接收到格式良好的字节序列的数据帧，他们需要将其转换为对象以进行进一步处理。这些函数也预计将对从文件中消耗字节以形成聚合的程序有用。许多程序员认为，只需将字节读取到字节数组中并将该数组转换为预期的类型（或其数组）就足以访问其中的（假设的）对象（或对象），当他们的C++代码开始出现意外行为时感到惊讶。C++是一种系统编程语言，由这些`std::start_lifetime_...`函数组成的集合填补了可能表现不佳的空白。
- en: 'Of course, these functions form a very sharp toolset due to the risks involved:
    non-trivially destructible objects whose lifetime starts this way are especially
    suspicious, and you have to be highly trusting of whatever facility provided the
    bytes in which an object’s lifetime is manually and explicitly started. Thus,
    these facilities should be used with utmost care.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于涉及的风险，这些函数形成了一个非常锋利的工具集：以这种方式开始生命周期的非平凡可析构对象尤其可疑，你必须高度信任提供字节以手动和显式启动对象生命周期的任何设施。因此，这些设施应该非常小心地使用。
- en: 'A note to complete this section: as of this writing, no major compiler yet
    implements these functions, even though they have been standardized and are part
    of C++23\. Maybe they will be implemented by the time you get to read this, who
    knows?'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本节的注意事项：截至本文撰写时，还没有主要的编译器实现这些函数，尽管它们已经被标准化，并且是C++23的一部分。也许在你读到这篇文章的时候，它们已经被实现了，谁知道呢？
- en: Trivial relocation
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单重定位
- en: As you know, dear reader, C++ is known in the programming community as one of
    those languages that we use when we need to get the most out of our computer or
    whatever hardware platform interests us. Some of the language’s credos can be
    paraphrased as “you shall not pay for what you do not use” and “there shall be
    no room for a lower-level language (except for the occasional bit of assembly
    code)”, after all. The latter explains the importance of the `std::start_lifetime_...`
    functions of the previous section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，亲爱的读者，C++在编程社区中是那些我们需要从计算机或任何感兴趣的硬件平台上获取最大性能的语言之一。该语言的一些信条可以概括为“你不应为未使用的东西付费”和“不应有更低级语言的空间（除了偶尔的汇编代码）”，毕竟。后者解释了上一节中`std::start_lifetime_...`函数的重要性。
- en: That’s probably why, when it becomes evident that we could do even better than
    we are already doing in terms of execution speed, that becomes a subject of interest
    to the C++ programmer community in general, and more specifically to members of
    the C++ standards committee. We all take these core credos of the language to
    heart.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能就是为什么，当显而易见我们可以比现在做得更好，在执行速度方面，这成为C++程序员社区普遍感兴趣的话题，特别是C++标准委员会的成员。我们都把语言的这些核心信条铭记在心。
- en: 'One case where we could do better is when we encounter types for which moving
    a source object to a destination object, followed by destroying the original object,
    could in practice be replaced by a call to `std::memcpy()`: directly copying an
    array of bytes is faster than performing a series of moves and destructors (and
    if it isn’t, there’s probably some work required on your `std::memcpy()` implementation),
    even though move assignments and destructors make for a fast combination.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做得更好的一个例子是，当我们遇到可以实际用 `std::memcpy()` 调用替换将源对象移动到目标对象，然后销毁原始对象的类型时：直接复制字节数组比执行一系列移动和析构函数更快（即使它不是，可能需要在您的
    `std::memcpy()` 实现上做一些工作），尽管移动赋值和析构函数组合起来速度很快。
- en: It turns out that there are many types for which such an optimization could
    be considered, including `std::string`, `std::any`, and `std::optional<T>` (depending
    on what type `T` is), classes such as `Point3D` from the previous section, any
    type that does not define any of the six special member functions seen in [*Chapter
    1*](B21071_01.xhtml#_idTextAnchor016) (including fundamental types), and so on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，有许多类型可以考虑这种优化，包括 `std::string`、`std::any` 和 `std::optional<T>`（取决于 `T`
    的类型），例如前一部分中的 `Point3D` 类，任何未定义六个特殊成员函数的类型（包括基本类型），等等。
- en: 'To understand the impact, consider the following `resize()` free function,
    which mimics a `C::resize()` member function for some container, `C`, that manages
    contiguous memory such as our `Vector<T>` type in the various incarnations seen
    in this book. This function resizes `arr` from `old_cap` (the old capacity) to
    `new_cap` (the new capacity), filling the space at the end with default `T` objects.
    The highlighted lines of the function are what interests us here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解其影响，考虑以下名为 `resize()` 的自由函数，它模拟了某些容器 `C` 的 `C::resize()` 成员函数，该容器管理连续内存，例如本书中看到的各种形式的我们的
    `Vector<T>` 类型。此函数将 `arr` 从 `old_cap`（旧容量）调整大小到 `new_cap`（新容量），并在末尾填充默认的 `T` 对象。该函数中高亮显示的行是我们这里感兴趣的部分：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, we are ready to copy (or move) objects:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经准备好复制（或移动）对象：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Looking at the highlighted lines of that function, even though the combination
    of `std::uninitialized_move()` followed by `std::destroy()` makes for a fast path,
    we could be even faster than this and replace a linear number of move assignment
    operators followed by a linear number of destructor calls with a single call to
    `std::memcpy()`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 观察该函数中高亮显示的行，尽管 `std::uninitialized_move()` 后跟 `std::destroy()` 的组合提供了一条快速路径，但我们甚至可以比这更快，用一个
    `std::memcpy()` 调用替换一系列移动赋值运算符和一系列析构函数调用。
- en: 'How do we achieve this? Well, there are many competing proposals by Arthur
    O’Dwyer, Mingxin Wang, Alisdair Meredith, and Mungo Gill, among others. Each of
    these proposals has merits, but these proposals have in common the following factors:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现这一点？嗯，Arthur O’Dwyer、Mingxin Wang、Alisdair Meredith 和 Mungo Gill 等人提出了许多相互竞争的提案。每个提案都有其优点，但这些提案有以下共同因素：
- en: Providing a way to test a type for “trivial relocatability” at compile time,
    for example, a `std::is_trivially_relocatable_v<T>` trait.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时提供一种测试类型是否具有“简单可重新定位性”的方法，例如，一个 `std::is_trivially_relocatable_v<T>` 特性。
- en: Providing a function that actually relocates the objects, for example, `std::relocate()`
    or `std::trivially_relocate()`, which take a source pointer and a destination
    pointer as arguments and relocate the source object to the destination location,
    concluding the lifetime of the original object and then starting the lifetime
    of the new one
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个实际重新定位对象的函数，例如 `std::relocate()` 或 `std::trivially_relocate()`，该函数接受源指针和目标指针作为参数，并将源对象重新定位到目标位置，结束原始对象的生命周期，然后开始新对象的生命周期
- en: Providing a way to mark a type as being trivially relocatable, for example through
    a keyword or an attribute
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种方法在编译时标记类型为简单可重新定位，例如通过关键字或属性
- en: Providing rules to deduce trivial relocatability for a type at compile time
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供规则在编译时推断类型的简单可重新定位性
- en: 'The details can vary depending on the approach, but if we suppose these tools,
    the same `resize()` function could benefit from trivial relocation by a slight
    adjustment to the previously presented implementation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 具体细节可能因方法而异，但如果我们假设这些工具，相同的 `resize()` 函数可以通过对之前提出的实现进行轻微调整从简单的重新定位中受益：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This seemingly simple optimization has been reported to provide considerable
    benefits, with some having claimed up to 30% speedup in common cases, but this
    is experimental work, and more benchmarks are expected to come if proposals coalesce
    (as we expect them to) into something that will be integrated into the C++ standard.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种看似简单的优化已被报道提供了相当大的好处，有些人声称在常见情况下速度提高了高达30%，但这是一项实验性工作，如果提议（正如我们预期的那样）合并成将被集成到C++标准中的东西，我们预计会有更多的基准测试出现。
- en: 'Such potential speedups are part of what the C++ language aims to make possible,
    so we can reasonably expect trivial relocatability to become reality in the foreseeable
    future. The question is “how”: how should compilers detect the trivial relocatability
    property? How should programmers be able to indicate that property on their own
    types when the default trivial relocatability deduction rules are not met?'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种潜在的速度提升是C++语言旨在实现的目标的一部分，因此我们可以合理地预期微小的迁移性将在可预见的未来成为现实。问题是“如何”：编译器应该如何检测微小的迁移性属性？当默认的微小迁移性推导规则不适用时，程序员应该如何在自己的类型上表明这种属性？
- en: As of February 2025, the standard committee voted trivial relocation into what
    will become C++26 standard. This means we can expect that some programs that compiled
    with previous standards of the C++ language and are recompiled with C++26 could
    just run faster without changing a single line of source code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2025年2月，标准委员会投票将微小的迁移纳入将成为C++26标准的范畴。这意味着我们可以预期，一些用C++语言先前标准编译的程序，在用C++26重新编译后，可以仅通过不修改任何源代码行就能运行得更快。
- en: Type-aware allocation and deallocation functions
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型感知的分配和释放函数
- en: Our last topic for this chapter on new approaches to memory management and optimization
    opportunities that pertain to object lifetime is type-aware allocation and deallocation
    functions. This is a novel approach to allocation functions for cases where user
    code might want to somehow use information with respect to what type is undergoing
    allocation (and eventual construction) to guide the allocation process.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的最后讨论了关于内存管理和与对象生命周期相关的优化机会的新方法，即类型感知的分配和释放函数。这是一种针对用户代码可能希望以某种方式使用有关正在进行的分配（以及最终构建）的类型信息来指导分配过程的分配函数的新方法。
- en: We saw one facet of such features in [*Chapter 9*](B21071_09.xhtml#_idTextAnchor141)
    when describing the `T::operator delete()` is passed `T*` instead of the abstract
    `void*` as an argument, and is for that reason made responsible for both the finalization
    of the object and the deallocation of its underlying storage. We saw that there
    are cases where this reveals interesting optimization opportunities.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第9章*](B21071_09.xhtml#_idTextAnchor141)中描述`T::operator delete()`将`T*`作为参数传递而不是抽象的`void*`时，我们看到了这些特性的一个方面，这是因为它因此负责对象的最终化和其底层存储的释放。我们看到，在某些情况下，这揭示了有趣的优化机会。
- en: 'What is under discussion for C++26 is a new family of `operator new()` and
    `operator delete()` member functions, as well as free functions that take a `std::type_identity<T>`
    object as the first argument for some type `T`, guiding the selected operator
    towards some specialized behavior for that type `T`. Note that these type-aware
    allocation functions are really allocation functions: they do not perform construction,
    nor does their deallocation counterpart perform finalization.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++26正在讨论的是一组新的`operator new()`和`operator delete()`成员函数，以及接受`std::type_identity<T>`对象作为第一个参数的免费函数，对于某些类型`T`，这些函数将引导选定的操作符针对该类型`T`执行一些特殊行为。请注意，这些类型感知的分配函数实际上是分配函数：它们不执行构造，它们的释放对应函数也不执行最终化。
- en: What is the std::type_identity<T> trait?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::type_identity<T>`特性是什么？'
- en: The expression `typename std::type_identity<T>::type` corresponds to `T`. OK,
    that seems trivial enough. So, what role does this trait play in contemporary
    C++ programming? It happens that trait `std::type_identity<T>`, introduced with
    C++20, is a tool that is typically used to provide additional control over argument
    type deduction in generic functions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`typename std::type_identity<T>::type`对应于`T`。好吧，这似乎很简单。那么，这个特性在当代C++编程中扮演什么角色呢？实际上，特性`std::type_identity<T>`，自C++20引入以来，是一种通常用于在泛型函数中提供对参数类型推导额外控制的工具。
- en: For example, with the function signature `template <class T> void f(T,T)`, you
    could call `f(3,3)` as both arguments are of the same type, but not `f(3,3.0)`
    as `int` and `double` are distinct types. That being said, by replacing either
    argument type with `std::type_identity_t<T>`, you could call `f(3,3.0)`, and since
    `T` would be deduced with the other argument (the one of type `T`), that type
    would be used for the other (the argument for which the type is `std::type_identity_t<T>`).
    That would lead to both arguments being `int` or `double`, depending on which
    argument is of type `T`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，具有函数签名 `template <class T> void f(T,T)`，您可以调用 `f(3,3)`，因为两个参数都是同一类型，但不能调用
    `f(3,3.0)`，因为 `int` 和 `double` 是不同的类型。但话虽如此，通过将任一参数类型替换为 `std::type_identity_t<T>`，您可以调用
    `f(3,3.0)`，并且由于 `T` 将根据另一个参数（类型为 `T` 的参数）推导出来，因此该类型将用于另一个参数（类型为 `std::type_identity_t<T>`
    的参数）。这将导致两个参数都是 `int` 或 `double`，具体取决于哪个参数是 `T` 类型。
- en: The idea of using `std::type_identity<T>` (not `std::type_identity_t<T>`) instead
    of plain `T` as the type of the first argument in type-aware allocation functions
    is to make it clear that we are using this specific specialized overload of `operator
    new()` and that this is not an accident or a call to some other specialized form
    of this allocation function, such as those described in [*Chapter 9*](B21071_09.xhtml#_idTextAnchor141).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::type_identity<T>`（而不是 `std::type_identity_t<T>`）而不是 `T` 作为类型感知分配函数中第一个参数的类型，是为了清楚地表明我们正在使用这个特定的特殊重载的
    `operator new()`，并且这不是一个意外或调用此分配函数的其他特殊形式，例如在[*第9章*](B21071_09.xhtml#_idTextAnchor141)中描述的那些。
- en: 'This means that you could provide specialized allocation functions for a specific
    class, `X`, through the following function signatures:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以通过以下函数签名为特定类 `X` 提供专门的分配函数：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '#include <new>'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 `<new>`
- en: '#include <type_traits>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 `<type_traits>`
- en: template <class T> requires special_alloc_alg<T>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 模板 <class T> requires special_alloc_alg<T>
- en: void* operator new(std::type_identity<T>, std::size_t n);
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: void* operator new(std::type_identity<T>, std::size_t n);
- en: template <class T> requires special_alloc_alg<T>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 模板 <class T> requires special_alloc_alg<T>
- en: 'void operator delete(X and Y, but that algorithm does not apply to other classes,
    such as Z:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 'void operator delete(X and Y, but that algorithm does not apply to other classes,
    such as Z:'
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The type-aware allocation functions can also be member function overloads, leading
    to algorithms that apply to the class where these functions are defined, as well
    as to derived classes thereof.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类型感知分配函数也可以是成员函数重载，导致算法适用于定义这些函数的类，以及这些类的派生类。
- en: 'Consider the following example, inspired by a more complex example found in
    the proposal for the feature that is described at [https://wg21.link/p2719](https://wg21.link/p2719):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，该示例灵感来源于在[https://wg21.link/p2719](https://wg21.link/p2719)中找到的更复杂示例，该示例描述了该特性的提案：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As expressed, `i)` applies to `B` and its derived classes, but `ii)` applies
    to the specific case of the forward-declared class `D0` and will only be used
    if `D0` is indeed a derived class of `B`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如所述，`i)` 适用于 `B` 及其派生类，但 `ii)` 适用于已声明的类 `D0` 的特定情况，并且只有在 `D0` 确实是 `B` 的派生类时才会使用。
- en: 'Continuing this example, we now add three classes that each derive from `B`,
    with `D2` adding `iii)`, which is a non-type-aware member function overload of
    `operator new()`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 继续这个示例，我们现在添加三个从 `B` 派生的类，其中 `D2` 添加了 `iii)`，这是一个非类型感知的 `operator new()` 成员函数重载：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Given these overloads, here are some examples of expressions calling overloads
    `i)`, `ii)`, and `iii)`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些重载，以下是一些调用重载 `i)`、`ii)` 和 `iii)` 的表达式示例：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, dear reader, type-aware allocation functions will, if accepted
    into the C++ standard, provide new ways to control what memory allocation algorithm
    will be used (depending on the circumstances) while still leaving user code in
    control, leaving it able to defer to the global `operator new()` function if that
    is the preferred option, as the last line of the `f()` function in the previous
    example shows.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，亲爱的读者，如果类型感知分配函数被纳入C++标准，它们将提供新的方法来控制将使用哪种内存分配算法（根据情况而定），同时仍然让用户代码保持控制，使其能够根据需要推迟到全局
    `operator new()` 函数，正如前一个示例中 `f()` 函数的最后一行所示。
- en: Contrary to the destroying delete feature of C++20, which performs both the
    finalization of the object and the deallocation of the underlying storage, the
    type-aware versions of `operator new()` and `operator delete()` are only allocation
    functions, and as of this writing, there is no plan to provide a type-aware version
    of destroying delete.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++20的销毁删除功能相反，该功能同时执行对象的最终化和底层存储的分配，类型感知版本的`operator new()`和`operator delete()`只是分配函数，截至本文撰写时，没有计划提供销毁删除的类型感知版本。
- en: Summary
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have had a glimpse of the future with the `std::start_lifetime_...`
    functions that are part of C++23 but, as of this writing, have not been implemented
    by any major compiler. We have also looked at probable (but not yet official)
    parts of the future of C++ with the potential support of trivial relocatability
    and the possibility of introducing type-aware versions of `operator new()` and
    `operator delete()`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过`std::start_lifetime_...`函数窥见了C++23的未来，但这些函数尚未被任何主要编译器实现。我们还研究了C++未来的可能（但尚未官方）部分，包括对平凡可重定位性的潜在支持以及引入类型感知版本的`operator
    new()`和`operator delete()`的可能性。
- en: With every step, C++ becomes a richer and more versatile language with which
    we can do more and express our ideas in more precise ways. C++ is a language that
    provides ever more significant control over the behavior of our programs. As powerful
    as C++ is today, and as powerful as it makes programmers like us, this chapter
    shows we can still continue to get better.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每一步的迈进，C++成为了一个更丰富、更通用的语言，我们可以用它做更多的事情，并以更精确的方式表达我们的想法。C++是一种提供对我们程序行为更多控制的编程语言。尽管C++今天如此强大，它让像我们这样的程序员如此强大，但本章表明我们仍然可以继续进步。
- en: We are at the end of our journey, at least for now. I hope the trip was just
    eventful enough to be pleasant and entertaining to you, esteemed reader, and that
    you have learned a thing or two along the way. I also hope that some of the ideas
    discussed here will help you in your tasks and enrich your perspective of C++
    programming.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了旅程的终点，至少目前是这样。希望这次旅行对您来说既有趣又愉快，尊敬的读者，并且您在旅途中学到了一些东西。我还希望这里讨论的一些想法能帮助您完成任务，丰富您对C++编程的视角。
- en: Thanks for accompanying me. I hope the journeys ahead for you will be enjoyable,
    just as I hope this book will make your toolbox better and that you will continue
    exploring on your own. Safe travels.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您一直陪伴我。希望您未来的旅程愉快，就像我希望这本书能让您的工具箱更完善，并且您会继续独立探索。一路顺风。
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Annexure:'
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录：
- en: Things You Should Know
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您应该知道的事情
- en: This book supposes readers possess some technical background that some might
    not consider to be "common knowledge". In the following sections, you might find
    the complementary information that will help you get the most out of this book.
    Refer to it as needed, and enjoy!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设读者具备一些技术背景，这些背景可能不被一些人认为是“常识”。在以下章节中，您可能会找到有助于您充分利用本书的补充信息。根据需要参考，并享受阅读！
- en: Feel free to skim through the following sections if you think you know their
    contents well and take a closer look at those you’re less comfortable with. You
    could even skip this entire section and come back if you realize while reading
    this book that these topics are not things you know as well as you thought you
    did.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您认为您已经很好地了解了以下章节的内容，可以随意浏览，对于那些您不太熟悉的章节，可以仔细研究。您甚至可以跳过这个整个章节，在阅读本书时意识到这些主题并不是您想象中那么熟悉的情况下再回来。 '
- en: The overall goal is to get the most out of this book after all!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 总体目标是在阅读完这本书后获得最大收益！
- en: struct and class
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体和类
- en: 'In C++, the words `struct` and `class` essentially mean the same thing, and
    code such as the following is perfectly legal:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，`struct`和`class`这两个词基本上意味着相同的东西，以下代码是完全合法的：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here are some details to note:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的细节：
- en: C++ has no `abstract` keyword like some other languages do. An abstract member
    function in C++ is `virtual` and has `=0` instead of a definition. The `virtual`
    keyword means *can be specialized by derived classes* (the `=0` part essentially
    means *must be specialized…*). We often talk of `virtual` member function. Functions
    that must be overridden are said to be **pure** **virtual** functions.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++没有像其他一些语言那样的`abstract`关键字。C++中的抽象成员函数是`virtual`的，并且用`=0`代替定义。`virtual`关键字意味着*可以被派生类特化*（`=0`部分本质上意味着*必须被特化…*）。我们经常谈论`virtual`成员函数。必须被重写的函数被称为**纯****虚**函数。
- en: Providing a default implementation for a pure virtual function
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为纯虚函数提供默认实现
- en: 'One can provide a definition for an abstract member function: it’s not typical,
    but it’s possible. That can be useful in cases where the base class wants to provide
    a default implementation of a service but requires that the derived classes at
    least consider providing their own. Here is an example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为抽象成员函数提供一个定义：这不是典型情况，但这是可能的。这在基类想要提供一个服务的默认实现，但要求派生类至少考虑提供它们自己的情况下可能很有用。以下是一个示例：
- en: '`#``include <iostream>`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`#``include <iostream>`'
- en: '`struct X { virtual int f() const =` `0; };`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct X { virtual int f() const =` `0; };`'
- en: '`int X::f() const { return` `3; }`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`int X::f() const { return` `3; }`'
- en: '`struct D : X { int f() const` `override {`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct D : X { int f() const` `override {`'
- en: '`return X::f() +` `1; }`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`return X::f() +` `1; }`'
- en: '`};`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`};`'
- en: '`void g(X &x) { std::cout << x.f() << ''\``n''; }`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`void g(X &x) { std::cout << x.f() << ''\``n''; }`'
- en: '`int` `main() {`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`int` `main() {`'
- en: '`D d;`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`D d;`'
- en: '`// X x; // illegal: X has a pure virtual` `member function`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`// X x; // 非法：X 有一个纯虚成员函数`'
- en: '`g(d);`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`g(d);`'
- en: '`}`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: 'C++ classes have destructors that handle what happens when an object reaches
    the end of its lifetime. Contrary to many other popular languages, automatic and
    static objects in C++ have deterministic lifetimes, and using destructors efficiently
    is idiomatic in that language. In a `virtual` member function), it is customary
    to have a `virtual` destructor (here, `virtual ~Drawable()`) to indicate that
    in a situation such as the following, destroying an object used through an indirection
    such as `p` should effectively destroy the pointed-to object (`Painting`), not
    the one denoted by the pointer’s static type (`Drawable`):'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 类具有析构函数，用于处理对象生命周期结束时发生的情况。与许多其他流行的语言不同，C++ 中的自动和静态对象具有确定的生存期，并且在该语言中有效地使用析构函数是惯用的。在
    `virtual` 成员函数中，通常会有一个 `virtual` 析构函数（这里为 `virtual ~Drawable()`），以表明在以下情况中，通过间接方式（如
    `p`）使用的对象被销毁时，应该有效地销毁指向的对象（`Painting`），而不是指针静态类型表示的对象（`Drawable`）：
- en: '[PRE12]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A `class` can derive from a `struct` just as a `struct` can derive from a `class`
    as both are structurally equivalent. The main differences are that for a `struct`,
    inheritance is `public` by default (but that can be changed using `protected`
    or `private`) and the same goes for members, whereas for a `class`, inheritance
    and members are `private` by default (but again, that can be changed).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `class` 可以从 `struct` 继承，就像 `struct` 可以从 `class` 继承一样，因为它们在结构上是等效的。主要区别在于，对于
    `struct`，继承默认是 `public`（但可以使用 `protected` 或 `private` 来更改），成员也是如此，而对于 `class`，继承和成员默认是
    `private`（但同样，也可以更改）。
- en: Note, in passing, that it’s perfectly fine in C++ to have a member function
    with an access qualifier in the base class (for example, `Drawable::draw()`, which
    is `public`) and in a derived class (for example, `Painting::draw()`, which is
    `private`). Some other popular languages do not allow this.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，在 C++ 中，在基类（例如，`Drawable::draw()`，它是 `public`）和派生类（例如，`Painting::draw()`，它是
    `private`）中有一个具有访问限定符的成员函数是完全正常的。一些其他流行的语言不允许这样做。
- en: std::size_t
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::size_t
- en: Type `std::size_t` is an alias for some unsigned integral type, but the actual
    type can vary from compiler to compiler (it could be `unsigned int`, `unsigned
    long`, `unsigned long long`, and so on).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `std::size_t` 是某些无符号整型的一个别名，但实际类型可能因编译器而异（可能是 `unsigned int`、`unsigned long`、`unsigned
    long long` 等）。
- en: One frequently encounters type `std::size_t` when discussing container sizes
    and the space occupied in memory by an object as expressed by operator `sizeof`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论容器大小和对象在内存中占用的空间时，经常会遇到类型 `std::size_t`，这是通过 `sizeof` 运算符表示的。
- en: The sizeof operator
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sizeof 运算符
- en: 'The `sizeof` operator yields the size in bytes of an object or a type. It is
    evaluated at compile time and will be used extensively throughout this book as
    we will need that information to allocate properly sized blocks of memory:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: sizeof 运算符返回对象或类型的字节大小。它在编译时进行评估，并且在本书中将被广泛使用，因为我们需要这些信息来正确分配内存块：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Object size is one of the key components of memory management and influences
    the speed at which programs will execute. For that reason, it is a recurring theme
    throughout this book.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对象大小是内存管理的关键组成部分之一，它影响着程序执行的速度。因此，这一点在本书中反复出现。
- en: Assertions
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言
- en: '`int` *occupies four bytes of storage.*” In the latter case, we have a program
    that has been written based on a non-portable assumption and we have to live with
    this choice, but we do not want our code to compile on platforms where that assumption
    does not hold.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: “`int` 占用四个字节的存储空间。”在后一种情况下，我们有一个基于不可移植假设编写的程序，我们必须接受这个选择，但我们不希望我们的代码在那些假设不成立的平台上编译。
- en: 'For dynamic assertions, it is customary to use the `assert()` macro from the
    `<cassert>` header. That macro takes as argument a boolean expression and halts
    program execution if it evaluates to `false`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动态断言，通常使用 `<cassert>` 头文件中的 `assert()` 宏。该宏将布尔表达式作为参数，如果它评估为 `false`，则停止程序执行：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that many projects disable `assert()` from production code, something
    that can be done by defining the `NDEBUG` macro before compilation. As such, make
    sure never to put expressions with side effects in `assert()` as it might be removed
    by compiler options:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，许多项目在产品代码中禁用了 `assert()`，这可以通过在编译前定义 `NDEBUG` 宏来实现。因此，请确保不要在 `assert()` 中放置有副作用的表达式，因为它可能会被编译器选项移除：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Contrary to `assert()`, which is a library macro, `static_assert` is a language
    feature that prevents compilation if its condition is not met. Based on the example
    mentioned previously where a company might have built software based on a non-portable
    assumption such as `sizeof(int)==4`, we could make sure that code does not compile
    (and do bad things) for platforms that are not really supported:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与库宏 `assert()` 相反，`static_assert` 是一种语言特性，如果其条件不满足，则阻止编译。基于前面提到的例子，其中一家公司可能基于不可移植的假设（如
    `sizeof(int)==4`）构建了软件，我们可以确保代码在这些实际上不支持的平台上的编译（和做坏事）：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Fixing bugs before shipping a software product is significantly better for developers
    and users alike than fixing bugs after the software has been sent “in the wild.”
    Consequently, `static_assert` can be seen as a powerful tool for delivering higher-quality
    products.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布软件产品之前修复错误对于开发者和用户来说都远远优于软件发布到“野外”后修复错误。因此，`static_assert` 可以被视为交付更高品质产品的强大工具。
- en: 'In this book, we will use `static_assert` regularly: it has no runtime cost
    and documents our assertions in a verifiable manner. It’s the sort of feature
    that essentially has no downsides.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将经常使用 `static_assert`：它没有运行时成本，并以可验证的方式记录我们的断言。这是一种基本上没有缺点特性。
- en: Undefined behavior
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未定义行为
- en: '**Undefined behavior**, often abbreviated to **UB**, results from a situation
    in which the standard does not prescribe a specific behavior. In the C++ standard,
    UB is behavior for which no requirements are imposed. It can lead to the problem
    being ignored, just as it can lead to a diagnostic or program termination. The
    key idea is that if your program has undefined behavior, then it’s not playing
    by the rules of the language and is broken; its behavior is not guaranteed on
    your platform, it’s not portable between platforms or compilers, and it cannot
    be relied upon.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**未定义行为**，通常简称为 **UB**，是由于标准没有规定特定行为的情况。在 C++ 标准中，UB 是没有要求的行为。它可能导致问题被忽略，也可能导致诊断或程序终止。关键思想是，如果你的程序有未定义行为，那么它没有按照语言的规则行事，是错误的；它的行为在你的平台上没有保证，它不能在不同的平台或编译器之间移植，也不能依赖。'
- en: A correctly written C++ program has no undefined behavior. When faced with a
    function that contains undefined behavior, the compiler can do just about anything
    with the code in that function, which makes reasoning from source code essentially
    impossible.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正确编写的 C++ 程序没有未定义行为。当面对包含未定义行为的函数时，编译器可以对那个函数中的代码做几乎所有的事情，这使得从源代码中进行推理基本上是不可能的。
- en: 'Undefined behavior is one of the preeminent “things to be careful with” listed
    in [*Chapter 2*](B21071_02.xhtml#_idTextAnchor027). Strive to avoid undefined
    behavior: it always comes back to bite you if you leave it in.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 未定义行为是列在 [*第2章*](B21071_02.xhtml#_idTextAnchor027) 中需要小心处理的“事项”之一。努力避免未定义行为：如果你留下它，它总是会反过来咬你。
- en: Type traits
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型特性
- en: Over the years, C++ programmers have developed various techniques to reason
    about the properties of their types, mostly at compile time. Inferring such things
    as *“Is the* `T` *type const?*” or *“Is the* `T` *type trivially copyable?”* can
    be very useful, particularly in the context of generic code. The constructs resulting
    from these techniques are called `<``type_traits>` header.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，C++程序员已经开发出各种技术来推理他们类型的属性，大多数是在编译时。推断诸如*“类型`T`是`const`吗？”*或*“类型`T`是否可以平凡复制？”*等问题非常有用，尤其是在泛型代码的上下文中。这些技术产生的结构被称为`<type_traits>`头文件。
- en: The ways in which standard type traits are expressed have standardized over
    time, going from complex beasts such as `std::numeric_limits<T>`, which provide
    a lot of different services for type `T`, to more specific services such as `std::is_const<T>`
    (*Is the* `type T` *actually* `const`*?*) or `std::remove_const<T>` (*Please give
    me the type that’s like* `T` *but without the* `const` *qualification if there
    was one*), which yield either a single type or a single value. Practice has shown
    that small, unitary type traits that yield either a type (named `type`) or a compile-time-known
    value (named `value`) can be considered “best practices,” and most contemporary
    type traits (including standard ones) are written this way.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 标准类型特性表达的方式随着时间的推移而标准化，从像`std::numeric_limits<T>`这样的复杂野兽，它为类型`T`提供了许多不同的服务，到更具体的服务，如`std::is_const<T>`（*类型`T`实际上是`const`吗？*）或`std::remove_const<T>`（*请给我一个类似于`T`的类型，如果有的话，不要`const`修饰*），它们产生一个单一的类型或一个单一值。实践表明，产生类型（命名为`type`）或编译时已知值（命名为`value`）的小型、单一类型特性可以被认为是“最佳实践”，并且大多数当代类型特性（包括标准特性）都是这样编写的。
- en: Since C++14, the traits that yield types have aliases that end with `_t` (for
    example, instead of writing the rather painful `typename std::remove_const<T>::type`
    incantation, one can now write `std::remove_const_t<T>` instead) and since C++17,
    the traits that yield values have aliases that end with `_v` (for example, instead
    of writing `std::is_const<T>::value`, one can now write `std::is_const_v<T>`).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++14以来，产生类型的特性有了以`_t`结尾的别名（例如，不再需要写相当痛苦的`typename std::remove_const<T>::type`咒语，现在可以写`std::remove_const_t<T>`），而自C++17以来，产生值的特性有了以`_v`结尾的别名（例如，不再需要写`std::is_const<T>::value`，现在可以写`std::is_const_v<T>`）。
- en: What about concepts?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，概念呢？
- en: Type traits are a programming technique that’s been part of C++ for decades,
    but since C++20, we have had **concepts**, and concepts are sort of like traits
    (often, they are expressed *through* traits) but are stronger in the sense that
    they are part of the type system. This book does not use concepts much, but you
    (as a programmer) really should get acquainted with them. They are extremely powerful
    and extremely useful to contemporary C++ programming.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类型特性是一种C++几十年来就有的编程技术，但自从C++20以来，我们有了**概念**，概念有点像特性（通常，它们是通过特性表达的），但在意义上更强，因为它们是类型系统的一部分。这本书并没有大量使用概念，但你（作为一个程序员）真的应该熟悉它们。它们非常强大，对当代C++编程非常有用。
- en: The std::true_type and std::false_type traits
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::true_type和std::false_type特性
- en: 'When expressing type traits, the standard library applies the common practice
    of using the names `type` for types and `value` for values, as in this example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达类型特性时，标准库采用了使用`type`作为类型名称和`value`作为值名称的常见做法，如下例所示：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It happens that many type traits have Boolean values. To simplify the task of
    writing such traits and to ensure that the form of these traits is homogeneous,
    you will find types `std::true_type` and `std::false_type` in the `<type_traits>`
    header. These types can be seen as the type system counterparts of constants `true`
    and `false`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，许多类型特性都有布尔值。为了简化编写此类特性的任务并确保这些特性的形式是一致的，你将在`<type_traits>`头文件中找到`std::true_type`和`std::false_type`类型。这些类型可以被视为类型系统中的常量`true`和`false`的对应物。
- en: 'With these types, we can rewrite traits such as `is_const` as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些类型，我们可以将特性如`is_const`重写如下：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These types are both a convenience and a way to express ideas more clearly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型既是便利，也是更清晰地表达思想的方式。
- en: The std::conditional<B,T,F> trait
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::conditional<B,T,F>特性
- en: 'It’s sometimes useful to choose between two types based on a condition known
    at compile time. Consider the following example where we seek to implement a comparison
    between two values of some type `T` that behave differently for floating-point
    types and for “other” types such as `int` all grouped together for simplicity:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有时根据编译时已知的条件在两种类型之间进行选择是有用的。考虑以下示例，其中我们试图实现某种类型`T`的两个值的比较，该类型对于浮点类型和“其他”类型（如`int`）的行为不同，所有这些类型都为了简单起见而组合在一起：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You might notice that we did not name the arguments of type `exact` and `floating`
    in our `close_enough()` functions. That’s fine as we are not using these objects
    at all; the reason for these arguments is to ensure both functions have distinct
    signatures.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在我们的`close_enough()`函数中，我们没有为类型`exact`和`floating`命名参数。这没关系，因为我们根本没使用这些对象；这些参数的原因是确保两个函数具有不同的签名。
- en: 'There is a `std::is_floating_point<T>` trait in the `<type_traits>` header
    with the value of `true` for floating-point numbers, and `false` otherwise. If
    we did not have this trait, we could write our own:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`<type_traits>`头文件中有一个`std::is_floating_point<T>`特性，对于浮点数其值为`true`，否则为`false`。如果没有这个特性，我们可以自己编写：'
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can use this to make our decision. However, we do not want to make a runtime
    decision here since the nature of type `T` is fully known at compile time, and
    nobody wants to pay for a branch instruction when comparing integers!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个特性来做出决定。然而，我们不想在这里做出运行时决定，因为类型`T`的本质在编译时是完全已知的，而且没有人愿意为比较整数时的一条分支指令付费！
- en: 'The `std::conditional<B,T,F>` trait can be used to make such a decision. If
    we wrote our own, it could look like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`std::conditional<B,T,F>`特性来做出这样的决定。如果我们自己编写，它可能看起来像这样：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Given this trait, we can choose, at compile time, one of two types based on
    a compile-time Boolean value, which is exactly what we were trying to do:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个特性，我们可以在编译时根据编译时布尔值选择两种类型中的一种，这正是我们试图做到的：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The way to read this is that the third argument in the call to `close_enough()`
    (found within our two-argument, user-facing `close_enough()` function) will either
    be an object of type `floating` or an object of type `exact` , but the exact type
    will be picked at compile time based on the value of the `is_floating_point_v<T>`
    compile-time constant. The end result is that we instantiate an object of one
    of these two empty classes, call the appropriate algorithm, and let function inlining
    do the rest and optimize the entire scaffolding away.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这样理解这个调用：`close_enough()`调用中的第三个参数（在我们的双参数用户界面`close_enough()`函数中找到）将是一个`floating`类型的对象或一个`exact`类型的对象，但确切类型将在编译时根据`is_floating_point_v<T>`编译时常量的值来选择。最终结果是实例化这两个空类中的一个对象，调用适当的算法，让函数内联来完成其余工作并优化整个框架。
- en: Algorithms
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法
- en: 'The C++ standard library contains, among other gems, a set of algorithms. Each
    of these functions performs the tasks that a very well-written loop would do but
    with specific names, complexity guarantees, and optimizations. As such, let’s
    say we write the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库包含了许多精华，其中之一是一组算法。这些函数中的每一个都执行一个非常好的循环所能完成的任务，但具有特定的名称、复杂度保证和优化。因此，让我们说我们编写以下代码：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It is idiomatic in C++ to write the following instead:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，编写以下代码是惯例：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#include <iostream>'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <iostream>'
- en: '#include <algorithm>'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <algorithm>'
- en: '#include <iterator>'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <iterator>'
- en: using namespace std;
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: using namespace std;
- en: void display(int n) { cout << n << ' '; }
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: void display(int n) { cout << n << ' '; }
- en: int main() {
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: int vals[]{ 2,3,5,7,11 };
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: int vals[]{ 2,3,5,7,11 };
- en: for_each(begin(vals), end(vals), display);
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: for_each(begin(vals), end(vals), display);
- en: '}'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '#include <iostream>'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <iostream>'
- en: '#include <algorithm>'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <algorithm>'
- en: '#include <iterator>'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <iterator>'
- en: '#include <fstream>'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <fstream>'
- en: using namespace std;
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: using namespace std;
- en: class Display {
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: class Display {
- en: ostream &os;
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ostream &os;
- en: 'public:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: 'Display(ostream &os) : os{ os } {'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'Display(ostream &os) : os{ os } {'
- en: '}'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void operator()(int n) const { os << n << ' '; }
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: void operator()(int n) const { os << n << ' '; }
- en: '};'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: int main() {
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: int vals[]{ 2,3,5,7,11 };
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: int vals[]{ 2,3,5,7,11 };
- en: // display on the standard output
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: // 在标准输出上显示
- en: for_each(begin(vals), end(vals), Display{ cout });
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: for_each(begin(vals), end(vals), Display{ cout });
- en: ofstream out{"out.txt" };
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ofstream out{"out.txt"};
- en: // write to file out.txt
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: // 将内容写入文件out.txt
- en: for_each(begin(vals), end(vals), Display{ out });
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: for_each(begin(vals), end(vals), Display{ out });
- en: '}'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#include <iostream>'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <iostream>'
- en: '#include <algorithm>'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <algorithm>'
- en: '#include <iterator>'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <iterator>'
- en: '#include <fstream>'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <fstream>'
- en: using namespace std;
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: using namespace std;
- en: int main() {
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: int vals[]{ 2,3,5,7,11 };
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: int vals[]{ 2,3,5,7,11 };
- en: // display on the standard output
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: // 在标准输出上显示
- en: for_each(begin(vals), end(vals), [](int n) {
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: cout << n << ' ';
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: ofstream out{"out.txt" };
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: // write to file out.txt
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: for_each(begin(vals), end(vals), [&out](int n) {
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: out << n << ' ';
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: class thing {
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'thing(string_view); // note: private'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: // ... various interesting members
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: // thing_factory can access private members of
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: // class thing
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: friend class thing_factory;
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: // in case we read an incorrect file
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: class invalid_format{};
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: class thing_factory {
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: // ... various interesting things here too
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: string read_file(const string &name) const {
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: ifstream in{ name };
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: // consume the file in one fell swoop, returning
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: // the entire contents in a single string
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: return { istreambuf_iterator<char>{ in },
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: istreambuf_iterator<char>{ } };
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: bool is_valid_content(string_view) const;
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: thing create_thing_from(const string &name) const {
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: auto contents = read_file(name);
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: if(!is_valid_content(contents))
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: throw invalid_format{};
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '// note: calls private thing constructor'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: return { contents };
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: class A {
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: int n = 3;
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: friend class B;
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: void f(B);
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: class B {
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: int m = 4;
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: void f(A);
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: void A::f(B b) {
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: // int val = b.m; // no, A is not a friend of B
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: void B::f(A a) {
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: int val = a.n; // Ok, B is a friend of A
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: class A {
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: int n = 3;
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: friend class B;
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: class B {
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: friend class C;
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: void f(A a) {
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: int val = a.n; // Ok, B is a friend of A
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: class C {
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: void f(A a) {
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: // int val = a.n; // no, C is not a friend of A
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: class A {
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: int n = 3;
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: friend class B;
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: class B {
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: void f(A a) {
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: int val = a.n; // Ok, B is a friend of A
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'class C : B {'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: void f(A a) {
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: // int val = a.n; // no, C is not a friend of A
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: const int n = f();
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: auto m = n; // m is of type int
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: auto & r = m; // r is of type int&
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: const auto & cr0 = m; // cr0 is of type const int&
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: auto & cr1 = n; // cr1 is of type const int&
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: template <class T>
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: T& pass_thru(T &arg) {
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: return arg;
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: int main() {
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: int n = 3;
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: auto m = pass_thru(n); // m is an int
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: ++m;
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: cout << n << ' ' << m << '\n'; // 3 4
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: decltype(pass_thru(n)) r = pass_thru(n); // r is an int&
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: ++r;
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: cout << n << ' ' << r << '\n'; // 4 4
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '#include <string>'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: struct X {
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: X(int, const std::string&); // A
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: X(int, std::string&&); // B
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: // ... other constructors and various members
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: X x0{ 3, "hello" }; // calls A
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: string s = "hi!";
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: X x1{ 4, s }; // also calls A
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: X x2{ 5, string{ "there" } }; // calls B
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: X x3{ 5, "there too"s }; // also calls B
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: template <class ... Args>
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: X makeX(Args ... args) {
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: clog << "Creating a X object\n";
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: return X(args...); // <-- HERE
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: template <class ... Args>
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: X makeX(Args &... args) {
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: clog << "Creating a X object\n";
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: return X(args...); // <-- HERE
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: // v passed by movement (type vector<int> fully specified)
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: void f0(vector<int> &&v);
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: // v passed by movement (type vector<T> fully specified
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: // for some type T)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: template <class T>
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: void f1(vector<T> &&v);
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: // v is a forwarding reference (type discovered by
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: // the compiler)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: template <class T>
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'f2():'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: template <class ... Args>
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: X makeX(Args &&... args) {
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: clog << "Creating a X object\n";
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: clog << "Creating a X object\n";
- en: return X(args...); // <-- HERE (still incorrect)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: return X(args...); // <-- HERE (仍然不正确)
- en: '}'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE39]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: template <class ... Args>
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: template <class ... Args>
- en: X makeX(Args &&... args) {
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: X makeX(Args &&... args) {
- en: clog << "Creating a X object\n";
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: clog << "Creating a X object\n";
- en: return X(std::forward<Args>(args)...); // <-- HERE
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: return X(std::forward<Args>(args)...); // <-- HERE
- en: '}'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE40]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '#include <atomic>'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <atomic>'
- en: class SequentialIdProvider {
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: class SequentialIdProvider {
- en: // ...
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: std::atomic<long long> cur; // state (synchronized)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: std::atomic<long long> cur; // 状态（同步）
- en: // default constructor (private)
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: // 默认构造函数（私有）
- en: 'SequentialIdProvider() : cur{ 0LL } {'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 'SequentialIdProvider() : cur{ 0LL } {'
- en: '}'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'public:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: // service offered by the singleton (synchronized)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: // 单例提供的服务（同步）
- en: auto next() { return cur++; }
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: auto next() { return cur++; }
- en: // deleted copy operations
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: // 删除复制操作
- en: SequentialIdProvider(const SequentialIdProvider&)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: SequentialIdProvider(const SequentialIdProvider&)
- en: = delete;
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: = delete;
- en: SequentialIdProvider&
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: SequentialIdProvider&
- en: operator=(const SequentialIdProvider&) = delete;
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: operator=(const SequentialIdProvider&) = delete;
- en: // ...
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '};'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '[PRE41]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '#include <atomic>'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <atomic>'
- en: class SequentialIdProvider {
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: class SequentialIdProvider {
- en: // declaration (private)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: // 声明（私有）
- en: static SequentialIdProvider singleton;
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: static SequentialIdProvider singleton;
- en: std::atomic<long long> cur; // state (synchronized)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: std::atomic<long long> cur; // 状态（同步）
- en: // default constructor (private)
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: // 默认构造函数（私有）
- en: 'SequentialIdProvider() : cur{ 0LL } {'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 'SequentialIdProvider() : cur{ 0LL } {'
- en: '}'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'public:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: // static member function providing access to the object
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: // 提供对对象的静态成员函数访问
- en: static auto & get() { return singleton; }
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: static auto & get() { return singleton; }
- en: // service offered by the singleton (synchronized)
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: // 单例提供的服务（同步）
- en: auto next() { return cur++; }
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: auto next() { return cur++; }
- en: // deleted copy operations
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: // 删除复制操作
- en: SequentialIdProvider(const SequentialIdProvider&)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: SequentialIdProvider(const SequentialIdProvider&)
- en: = delete;
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: = delete;
- en: SequentialIdProvider&
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: SequentialIdProvider&
- en: operator=(const SequentialIdProvider&) = delete;
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: operator=(const SequentialIdProvider&) = delete;
- en: // ...
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: // ...
- en: '};'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: // in a source file somewhere, say SequentialIdProvider.cpp
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: // 在某个源文件中，例如SequentialIdProvider.cpp
- en: '#include "SequentialIdProvider.h"'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "SequentialIdProvider.h"'
- en: // definition (calls the default constructor)
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: // 定义（调用默认构造函数）
- en: SequentialIdProvider, we could run into trouble as C++ does not guarantee the
    order in which global objects from multiple files are instantiated.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: SequentialIdProvider，如果我们遇到麻烦，因为C++不保证来自多个文件的全局对象实例化的顺序。
- en: 'Possible client code for this implementation would be as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的客户端代码实现如下：
- en: '[PRE42]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This would display monotonically increasing integers, maybe consecutively (as
    long as there is no other thread concurrently calling the singleton’s services).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示单调递增的整数，可能是连续的（只要没有其他线程同时调用单例的服务）。
- en: Instantiation of the first call
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 首次调用的实例化
- en: Another way to instantiate a singleton is to create it the first time its services
    are solicited by making it a `static` variable of the function that provides access
    to the singleton. This way, as `static` local variables are created the first
    time the function is called and keep their state thereafter, a singleton could
    provide services to other singletons as long as this does not create cycles.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化单例的另一种方法是，在首次请求其服务时创建它，使其成为提供单例访问权限的函数的`static`变量。这样，由于`static`局部变量在函数首次调用时创建并保持其状态，单例可以为其他单例提供服务，只要这不会创建循环。
- en: 'A possible implementation would be the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的实现如下：
- en: '[PRE43]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Possible client code for this implementation would be as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的客户端代码实现如下：
- en: '[PRE44]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This would display monotonically increasing integers, maybe consecutively (as
    long as there is no other thread concurrently calling the singleton’s services).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示单调递增的整数，可能是连续的（只要没有其他线程同时调用单例的服务）。
- en: 'Note that this version has a hidden cost: `static` variables local to functions
    are called `static` variable involves some synchronization and that this synchronization
    is paid on every call to that function. The preceding client code alleviates that
    cost by calling `SequentialIdProvider::get()` once, then reusing the reference
    obtained through that call afterward; it’s the call to `get()` that introduces
    the synchronization cost.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个版本有一个隐藏的成本：函数本地的`static`变量被称为`static`变量涉及一些同步，并且这种同步在每次调用该函数时都会付出代价。前面的客户端代码通过一次调用`SequentialIdProvider::get()`来减轻这种成本，然后在该调用之后重用通过该调用获得的引用；是`get()`的调用引入了同步成本。
- en: The std::exchange() function
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: The std::exchange() function
- en: 'There are (at least) two very useful and fundamental functions hidden in the
    `<utility>` header file. One is well-known and has been there for a long time:
    `std::swap()`, which is used for many purposes throughout the standard library
    as well as throughout user code.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<utility>` 头文件中隐藏着（至少）两个非常有用且基本的功能。一个是众所周知的，并且已经存在很长时间：`std::swap()`，它在标准库的许多用途以及用户代码中都被使用。
- en: The other, more recent one is `std::exchange()`. Where `swap(a,b)` swaps the
    values of objects `a` and `b` , expression `a = exchange(b,c)` changes the value
    of `b` with the value of `c`, returning the old value of `b` (to assign it to
    `a`). This might look strange at first but it’s actually a very useful facility.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个较新的一个是 `std::exchange()`。其中 `swap(a,b)` 交换对象 `a` 和 `b` 的值，表达式 `a = exchange(b,c)`
    将 `b` 的值与 `c` 的值交换，并返回 `b` 的旧值（以便将其赋值给 `a`）。一开始这可能看起来有些奇怪，但实际上这是一个非常实用的功能。
- en: 'Consider the move constructor for the following simplified `fixed_size_array`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下简化版的 `fixed_size_array` 的移动构造函数：
- en: '[PRE45]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You might notice that this constructor does two things: it grabs the data members
    from `other`, and then replaces the members of `other` with default values. That’s
    the posterchild for `std::exchange()`, so this constructor can be simplified as
    follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到这个构造函数做了两件事：它从 `other` 中获取数据成员，然后使用默认值替换 `other` 的成员。这就是 `std::exchange()`
    的典型应用，因此这个构造函数可以简化如下：
- en: '[PRE46]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With `std::exchange()`, this common two-step operation can be reduced to a function
    call, simplifying code and making it more efficient (in this case, turning assignments
    into constructor calls).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::exchange()`，这个常见的两步操作可以简化为一个函数调用，简化代码并提高效率（在这种情况下，将赋值转换为构造函数调用）。
- en: '[PRE47]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
