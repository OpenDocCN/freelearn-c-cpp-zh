- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contemporary Issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are reaching the end of our journey, dear reader. Over the course of this
    book, we have examined fundamental aspects of the C++ object model and discussed
    dangerous aspects of low-level programming. We have looked at the fundamentals
    of resource management in C++ through the RAII idiom, looked at how smart pointers
    are used, and explored how to write such a type. We also took control of the memory
    allocation functions at our disposal (and we did that in many ways!), and we wrote
    containers that manage memory themselves as well as through other objects or types,
    including allocators.
  prefs: []
  type: TYPE_NORMAL
- en: That was quite an experience!
  prefs: []
  type: TYPE_NORMAL
- en: What do we still have to cover? Well, so much… but there’s a limit to what we
    can put in a single book. So, to conclude our discussion of memory management
    in C++, I thought we might have a chat (yes, dear reader, just you and I) about
    some of the interesting topics in contemporary memory management in C++. Yes,
    things that were so recently standardized (as of this writing) that most, if not
    all, libraries still do not implement them, and things the standards committee
    is actively working on.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to look at C++ as it is today and how it might be in the near
    future because the language continues to evolve, and at quite a quick pace: a
    new version of the C++ standard is issued every three years, and this has been
    the case since 2011\. The evolution of C++ is too slow for some and too quick
    for others, but it is unrelenting (we call this publishing rhythm the “train model”
    to highlight its sustained pace) and brings regular progress and innovation to
    this language that we love so much.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As of this writing, in the early weeks of 2025, C++23 is a freshly adopted
    standard, having been officialized in November 2024 (yes, I know: the ISO process
    does take some time), and the committee is discussing proposals meant for C++26
    (yes, already!) and C++29.'
  prefs: []
  type: TYPE_NORMAL
- en: The memory management-related topics we will discuss in this chapter are either
    aspects of the C++23 standard that we have not discussed in this book yet or are
    some that, as this chapter is being written, are under discussion for upcoming
    standards. Be aware, dear reader, that what you will now read may become reality
    in the form you will read about, but it might also come along in another form
    after discussions and debates in the C++ standards committee… or it might, in
    the end, never come to be.
  prefs: []
  type: TYPE_NORMAL
- en: Even if these topics do not end up entering the C++ standard in the form in
    which they were initially discussed, you will know that they will have been discussed,
    along with the problems they were meant to solve, and that these features might
    become part of the language at some point. Who knows; maybe you will have an epiphany
    and find the words to turn one of these ideas into a proposal that the C++ standards
    committee will discuss, and then adopt.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly starting the lifetime of one or many objects without resorting to
    their constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Trivial relocation: what it means and in what ways the standards committee
    is trying to address it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type-aware allocation and deallocation functions: what they would do and how
    to benefit from them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our approach in this chapter will be to present these new features (or features-to-be)
    through the perspective of the problems we are trying to solve. The intent behind
    this approach is to make it clear that these features address actual issues and
    will help real programmers do their jobs better.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this chapter will give you insights into an interesting (albeit non-exhaustive)
    set of contemporary issues in memory management and associated facilities as they
    pertain to C++.
  prefs: []
  type: TYPE_NORMAL
- en: A note on code examples for this chapter
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to compile the examples in this chapter, esteemed reader, you might
    find yourself saddened by the fact that some will not compile yet and others might
    not compile for a while, or ever. This situation is normal for a chapter such
    as this one: we will be discussing a combination of features that have been very
    recently added to the C++ language (recently enough that they have not yet been
    implemented at the time of authoring this book) and features that are under discussion
    by the C++ standards committee. Take the examples as illustrations, then, and
    adjust them as the features take a more formal shape.'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code files for this chapter in the book’s GitHub repository:
    [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter15](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter15).'
  prefs: []
  type: TYPE_NORMAL
- en: Starting object lifetime without constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the case of a program that consumes serialized data from a stream
    and that seeks to make objects from that data. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in this example, we have the `Point3D` class. An object of this
    type represents a set of *x,y,z* coordinates. We also have a `read_from_stream<N>()`
    function that consumes bytes from a file. The function then stores at most `N`
    bytes into argument `buf`, which is passed by reference and returns the number
    of bytes read (which might be zero but will never be more than `N`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of this example, we will suppose that the file from which we plan
    to read is known to contain the binary form of serialized `Point3D` objects, equivalent
    to objects of type `float` serialized in binary format by groups of three. Now,
    consider the following program, which consumes the byte representation of at most
    four objects of type `Point3D` from a file named `some_file.dat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This example program reads bytes from a file into a `std::array` object big
    enough to contain the bytes of four objects of type `Point3D`, having first ensured
    that this array would be aligned appropriately if it were to hold objects of that
    type. This alignment consideration is essential as we plan to treat the bytes
    as objects of that type once those bytes have been read.
  prefs: []
  type: TYPE_NORMAL
- en: The point of this example is that once the bytes have been read, the programmer
    is confident (well, as confident as one could be) that *all the bytes are correct*
    for some hypothetical `Point3D` objects but still cannot use these objects as
    *their lifetime has not* *yet started*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sort of situation traditionally makes many C programmers smile and some
    C++ programmers cringe: the C++ object model imposes constraints on programs that
    make it **UB** (see [*Chapter 2*](B21071_02.xhtml#_idTextAnchor027)) to use objects
    outside of their lifetime, even if all the bytes are right and alignment constraints
    have been respected, whereas C is less restrictive. To use the contents of the
    buffer we just used to read from that file, our options are traditionally as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To loop through the array of bytes, write appropriately-sized subsets of those
    bytes into objects of type `float`, then call the constructors of `Point3D` objects
    and put them in another container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To `reinterpret_cast` the array of bytes into an array of `Point3D` objects
    and hope for the best, leading to code that might or might not work and, being
    UB, would not be portable anyway (not even between versions of a given compiler).
    With our `Point3D` objects, it will probably give the results one would hope for,
    but replace these with, say, `std::complex<float>` objects from the standard library
    (a type that probably has a similar inner structure as our `Point3D` type) and…
    well, who knows what might happen?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To `std::memcpy()` the array of bytes into itself, casting the return value
    to type `Point3D*` and using the resulting pointer as if it were an array of `Point3D`
    objects. That’s actually valid (the `std::memcpy()` function is part of a select
    set of functions that are allowed to start the lifetime of objects). There is,
    of course, the risk of creating an actual copy of the bytes (which would be wasted
    execution time); some standard libraries are said to recognize that pattern and
    just behave as if the call was a no-op, but a special kind of no-op that can start
    the lifetime of objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of these options seems truly satisfactory, however, so a cleaner solution
    that does not rely on compiler-specific optimizations is needed. To that effect,
    the C++23 standard introduces a set of `constexpr` functions (accompanied by a
    number of overloads) that are called `std::start_lifetime_as_array<T>(p,n)` and
    `std::start_lifetime_as<T>(p)`. Both are portable forms of magical no-op functions
    that inform the compiler that the bytes are OK and to consider the lifetime of
    the pointees as having begun.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if for some reason the pointees have non-trivial destructors, you
    should make sure that your code calls these destructors when appropriate. Expect
    this situation to be rare and unusual. Since we consumed raw bytes from some source
    of data and turned these bytes into objects, the probability that the resulting
    objects own resources is somewhat slim. Of course, these objects can acquire resources
    once their lifetimes have begun. Let’s be honest, dear reader; C++ programmers
    are nothing if not creative!
  prefs: []
  type: TYPE_NORMAL
- en: This set of `std::start_lifetime_...` functions is expected to be a boon to
    network programmers everywhere, in particular. These individuals often receive
    data frames of well-formed byte sequences that they need to turn into objects
    for the purpose of further processing. These functions are also expected to be
    useful to programs that consume bytes from files in order to form aggregates.
    Many programmers think that just reading bytes into an array of bytes and casting
    that array to an intended type (or array thereof) suffices to get access to the
    (hypothetical) object (or objects) therein and are surprised when their C++ code
    starts behaving unexpectedly. C++ is a systems programming language, and the set
    made of these `std::start_lifetime_...` functions closes a gap where it could
    be said to be underperforming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, these functions form a very sharp toolset due to the risks involved:
    non-trivially destructible objects whose lifetime starts this way are especially
    suspicious, and you have to be highly trusting of whatever facility provided the
    bytes in which an object’s lifetime is manually and explicitly started. Thus,
    these facilities should be used with utmost care.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A note to complete this section: as of this writing, no major compiler yet
    implements these functions, even though they have been standardized and are part
    of C++23\. Maybe they will be implemented by the time you get to read this, who
    knows?'
  prefs: []
  type: TYPE_NORMAL
- en: Trivial relocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, dear reader, C++ is known in the programming community as one of
    those languages that we use when we need to get the most out of our computer or
    whatever hardware platform interests us. Some of the language’s credos can be
    paraphrased as “you shall not pay for what you do not use” and “there shall be
    no room for a lower-level language (except for the occasional bit of assembly
    code)”, after all. The latter explains the importance of the `std::start_lifetime_...`
    functions of the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: That’s probably why, when it becomes evident that we could do even better than
    we are already doing in terms of execution speed, that becomes a subject of interest
    to the C++ programmer community in general, and more specifically to members of
    the C++ standards committee. We all take these core credos of the language to
    heart.
  prefs: []
  type: TYPE_NORMAL
- en: 'One case where we could do better is when we encounter types for which moving
    a source object to a destination object, followed by destroying the original object,
    could in practice be replaced by a call to `std::memcpy()`: directly copying an
    array of bytes is faster than performing a series of moves and destructors (and
    if it isn’t, there’s probably some work required on your `std::memcpy()` implementation),
    even though move assignments and destructors make for a fast combination.'
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that there are many types for which such an optimization could
    be considered, including `std::string`, `std::any`, and `std::optional<T>` (depending
    on what type `T` is), classes such as `Point3D` from the previous section, any
    type that does not define any of the six special member functions seen in [*Chapter
    1*](B21071_01.xhtml#_idTextAnchor016) (including fundamental types), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the impact, consider the following `resize()` free function,
    which mimics a `C::resize()` member function for some container, `C`, that manages
    contiguous memory such as our `Vector<T>` type in the various incarnations seen
    in this book. This function resizes `arr` from `old_cap` (the old capacity) to
    `new_cap` (the new capacity), filling the space at the end with default `T` objects.
    The highlighted lines of the function are what interests us here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we are ready to copy (or move) objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the highlighted lines of that function, even though the combination
    of `std::uninitialized_move()` followed by `std::destroy()` makes for a fast path,
    we could be even faster than this and replace a linear number of move assignment
    operators followed by a linear number of destructor calls with a single call to
    `std::memcpy()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we achieve this? Well, there are many competing proposals by Arthur
    O’Dwyer, Mingxin Wang, Alisdair Meredith, and Mungo Gill, among others. Each of
    these proposals has merits, but these proposals have in common the following factors:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing a way to test a type for “trivial relocatability” at compile time,
    for example, a `std::is_trivially_relocatable_v<T>` trait.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a function that actually relocates the objects, for example, `std::relocate()`
    or `std::trivially_relocate()`, which take a source pointer and a destination
    pointer as arguments and relocate the source object to the destination location,
    concluding the lifetime of the original object and then starting the lifetime
    of the new one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a way to mark a type as being trivially relocatable, for example through
    a keyword or an attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing rules to deduce trivial relocatability for a type at compile time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The details can vary depending on the approach, but if we suppose these tools,
    the same `resize()` function could benefit from trivial relocation by a slight
    adjustment to the previously presented implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This seemingly simple optimization has been reported to provide considerable
    benefits, with some having claimed up to 30% speedup in common cases, but this
    is experimental work, and more benchmarks are expected to come if proposals coalesce
    (as we expect them to) into something that will be integrated into the C++ standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such potential speedups are part of what the C++ language aims to make possible,
    so we can reasonably expect trivial relocatability to become reality in the foreseeable
    future. The question is “how”: how should compilers detect the trivial relocatability
    property? How should programmers be able to indicate that property on their own
    types when the default trivial relocatability deduction rules are not met?'
  prefs: []
  type: TYPE_NORMAL
- en: As of February 2025, the standard committee voted trivial relocation into what
    will become C++26 standard. This means we can expect that some programs that compiled
    with previous standards of the C++ language and are recompiled with C++26 could
    just run faster without changing a single line of source code.
  prefs: []
  type: TYPE_NORMAL
- en: Type-aware allocation and deallocation functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our last topic for this chapter on new approaches to memory management and optimization
    opportunities that pertain to object lifetime is type-aware allocation and deallocation
    functions. This is a novel approach to allocation functions for cases where user
    code might want to somehow use information with respect to what type is undergoing
    allocation (and eventual construction) to guide the allocation process.
  prefs: []
  type: TYPE_NORMAL
- en: We saw one facet of such features in [*Chapter 9*](B21071_09.xhtml#_idTextAnchor141)
    when describing the `T::operator delete()` is passed `T*` instead of the abstract
    `void*` as an argument, and is for that reason made responsible for both the finalization
    of the object and the deallocation of its underlying storage. We saw that there
    are cases where this reveals interesting optimization opportunities.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is under discussion for C++26 is a new family of `operator new()` and
    `operator delete()` member functions, as well as free functions that take a `std::type_identity<T>`
    object as the first argument for some type `T`, guiding the selected operator
    towards some specialized behavior for that type `T`. Note that these type-aware
    allocation functions are really allocation functions: they do not perform construction,
    nor does their deallocation counterpart perform finalization.'
  prefs: []
  type: TYPE_NORMAL
- en: What is the std::type_identity<T> trait?
  prefs: []
  type: TYPE_NORMAL
- en: The expression `typename std::type_identity<T>::type` corresponds to `T`. OK,
    that seems trivial enough. So, what role does this trait play in contemporary
    C++ programming? It happens that trait `std::type_identity<T>`, introduced with
    C++20, is a tool that is typically used to provide additional control over argument
    type deduction in generic functions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, with the function signature `template <class T> void f(T,T)`, you
    could call `f(3,3)` as both arguments are of the same type, but not `f(3,3.0)`
    as `int` and `double` are distinct types. That being said, by replacing either
    argument type with `std::type_identity_t<T>`, you could call `f(3,3.0)`, and since
    `T` would be deduced with the other argument (the one of type `T`), that type
    would be used for the other (the argument for which the type is `std::type_identity_t<T>`).
    That would lead to both arguments being `int` or `double`, depending on which
    argument is of type `T`.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of using `std::type_identity<T>` (not `std::type_identity_t<T>`) instead
    of plain `T` as the type of the first argument in type-aware allocation functions
    is to make it clear that we are using this specific specialized overload of `operator
    new()` and that this is not an accident or a call to some other specialized form
    of this allocation function, such as those described in [*Chapter 9*](B21071_09.xhtml#_idTextAnchor141).
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that you could provide specialized allocation functions for a specific
    class, `X`, through the following function signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '#include <new>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <type_traits>'
  prefs: []
  type: TYPE_NORMAL
- en: template <class T> requires special_alloc_alg<T>
  prefs: []
  type: TYPE_NORMAL
- en: void* operator new(std::type_identity<T>, std::size_t n);
  prefs: []
  type: TYPE_NORMAL
- en: template <class T> requires special_alloc_alg<T>
  prefs: []
  type: TYPE_NORMAL
- en: 'void operator delete(X and Y, but that algorithm does not apply to other classes,
    such as Z:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The type-aware allocation functions can also be member function overloads, leading
    to algorithms that apply to the class where these functions are defined, as well
    as to derived classes thereof.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example, inspired by a more complex example found in
    the proposal for the feature that is described at [https://wg21.link/p2719](https://wg21.link/p2719):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As expressed, `i)` applies to `B` and its derived classes, but `ii)` applies
    to the specific case of the forward-declared class `D0` and will only be used
    if `D0` is indeed a derived class of `B`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing this example, we now add three classes that each derive from `B`,
    with `D2` adding `iii)`, which is a non-type-aware member function overload of
    `operator new()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Given these overloads, here are some examples of expressions calling overloads
    `i)`, `ii)`, and `iii)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, dear reader, type-aware allocation functions will, if accepted
    into the C++ standard, provide new ways to control what memory allocation algorithm
    will be used (depending on the circumstances) while still leaving user code in
    control, leaving it able to defer to the global `operator new()` function if that
    is the preferred option, as the last line of the `f()` function in the previous
    example shows.
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to the destroying delete feature of C++20, which performs both the
    finalization of the object and the deallocation of the underlying storage, the
    type-aware versions of `operator new()` and `operator delete()` are only allocation
    functions, and as of this writing, there is no plan to provide a type-aware version
    of destroying delete.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have had a glimpse of the future with the `std::start_lifetime_...`
    functions that are part of C++23 but, as of this writing, have not been implemented
    by any major compiler. We have also looked at probable (but not yet official)
    parts of the future of C++ with the potential support of trivial relocatability
    and the possibility of introducing type-aware versions of `operator new()` and
    `operator delete()`.
  prefs: []
  type: TYPE_NORMAL
- en: With every step, C++ becomes a richer and more versatile language with which
    we can do more and express our ideas in more precise ways. C++ is a language that
    provides ever more significant control over the behavior of our programs. As powerful
    as C++ is today, and as powerful as it makes programmers like us, this chapter
    shows we can still continue to get better.
  prefs: []
  type: TYPE_NORMAL
- en: We are at the end of our journey, at least for now. I hope the trip was just
    eventful enough to be pleasant and entertaining to you, esteemed reader, and that
    you have learned a thing or two along the way. I also hope that some of the ideas
    discussed here will help you in your tasks and enrich your perspective of C++
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for accompanying me. I hope the journeys ahead for you will be enjoyable,
    just as I hope this book will make your toolbox better and that you will continue
    exploring on your own. Safe travels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Annexure:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Things You Should Know
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book supposes readers possess some technical background that some might
    not consider to be "common knowledge". In the following sections, you might find
    the complementary information that will help you get the most out of this book.
    Refer to it as needed, and enjoy!
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to skim through the following sections if you think you know their
    contents well and take a closer look at those you’re less comfortable with. You
    could even skip this entire section and come back if you realize while reading
    this book that these topics are not things you know as well as you thought you
    did.
  prefs: []
  type: TYPE_NORMAL
- en: The overall goal is to get the most out of this book after all!
  prefs: []
  type: TYPE_NORMAL
- en: struct and class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++, the words `struct` and `class` essentially mean the same thing, and
    code such as the following is perfectly legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some details to note:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ has no `abstract` keyword like some other languages do. An abstract member
    function in C++ is `virtual` and has `=0` instead of a definition. The `virtual`
    keyword means *can be specialized by derived classes* (the `=0` part essentially
    means *must be specialized…*). We often talk of `virtual` member function. Functions
    that must be overridden are said to be **pure** **virtual** functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a default implementation for a pure virtual function
  prefs: []
  type: TYPE_NORMAL
- en: 'One can provide a definition for an abstract member function: it’s not typical,
    but it’s possible. That can be useful in cases where the base class wants to provide
    a default implementation of a service but requires that the derived classes at
    least consider providing their own. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#``include <iostream>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`struct X { virtual int f() const =` `0; };`'
  prefs: []
  type: TYPE_NORMAL
- en: '`int X::f() const { return` `3; }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`struct D : X { int f() const` `override {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return X::f() +` `1; }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`};`'
  prefs: []
  type: TYPE_NORMAL
- en: '`void g(X &x) { std::cout << x.f() << ''\``n''; }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`int` `main() {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`D d;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// X x; // illegal: X has a pure virtual` `member function`'
  prefs: []
  type: TYPE_NORMAL
- en: '`g(d);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ classes have destructors that handle what happens when an object reaches
    the end of its lifetime. Contrary to many other popular languages, automatic and
    static objects in C++ have deterministic lifetimes, and using destructors efficiently
    is idiomatic in that language. In a `virtual` member function), it is customary
    to have a `virtual` destructor (here, `virtual ~Drawable()`) to indicate that
    in a situation such as the following, destroying an object used through an indirection
    such as `p` should effectively destroy the pointed-to object (`Painting`), not
    the one denoted by the pointer’s static type (`Drawable`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `class` can derive from a `struct` just as a `struct` can derive from a `class`
    as both are structurally equivalent. The main differences are that for a `struct`,
    inheritance is `public` by default (but that can be changed using `protected`
    or `private`) and the same goes for members, whereas for a `class`, inheritance
    and members are `private` by default (but again, that can be changed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note, in passing, that it’s perfectly fine in C++ to have a member function
    with an access qualifier in the base class (for example, `Drawable::draw()`, which
    is `public`) and in a derived class (for example, `Painting::draw()`, which is
    `private`). Some other popular languages do not allow this.
  prefs: []
  type: TYPE_NORMAL
- en: std::size_t
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type `std::size_t` is an alias for some unsigned integral type, but the actual
    type can vary from compiler to compiler (it could be `unsigned int`, `unsigned
    long`, `unsigned long long`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: One frequently encounters type `std::size_t` when discussing container sizes
    and the space occupied in memory by an object as expressed by operator `sizeof`.
  prefs: []
  type: TYPE_NORMAL
- en: The sizeof operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `sizeof` operator yields the size in bytes of an object or a type. It is
    evaluated at compile time and will be used extensively throughout this book as
    we will need that information to allocate properly sized blocks of memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Object size is one of the key components of memory management and influences
    the speed at which programs will execute. For that reason, it is a recurring theme
    throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`int` *occupies four bytes of storage.*” In the latter case, we have a program
    that has been written based on a non-portable assumption and we have to live with
    this choice, but we do not want our code to compile on platforms where that assumption
    does not hold.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For dynamic assertions, it is customary to use the `assert()` macro from the
    `<cassert>` header. That macro takes as argument a boolean expression and halts
    program execution if it evaluates to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that many projects disable `assert()` from production code, something
    that can be done by defining the `NDEBUG` macro before compilation. As such, make
    sure never to put expressions with side effects in `assert()` as it might be removed
    by compiler options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Contrary to `assert()`, which is a library macro, `static_assert` is a language
    feature that prevents compilation if its condition is not met. Based on the example
    mentioned previously where a company might have built software based on a non-portable
    assumption such as `sizeof(int)==4`, we could make sure that code does not compile
    (and do bad things) for platforms that are not really supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Fixing bugs before shipping a software product is significantly better for developers
    and users alike than fixing bugs after the software has been sent “in the wild.”
    Consequently, `static_assert` can be seen as a powerful tool for delivering higher-quality
    products.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will use `static_assert` regularly: it has no runtime cost
    and documents our assertions in a verifiable manner. It’s the sort of feature
    that essentially has no downsides.'
  prefs: []
  type: TYPE_NORMAL
- en: Undefined behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Undefined behavior**, often abbreviated to **UB**, results from a situation
    in which the standard does not prescribe a specific behavior. In the C++ standard,
    UB is behavior for which no requirements are imposed. It can lead to the problem
    being ignored, just as it can lead to a diagnostic or program termination. The
    key idea is that if your program has undefined behavior, then it’s not playing
    by the rules of the language and is broken; its behavior is not guaranteed on
    your platform, it’s not portable between platforms or compilers, and it cannot
    be relied upon.'
  prefs: []
  type: TYPE_NORMAL
- en: A correctly written C++ program has no undefined behavior. When faced with a
    function that contains undefined behavior, the compiler can do just about anything
    with the code in that function, which makes reasoning from source code essentially
    impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Undefined behavior is one of the preeminent “things to be careful with” listed
    in [*Chapter 2*](B21071_02.xhtml#_idTextAnchor027). Strive to avoid undefined
    behavior: it always comes back to bite you if you leave it in.'
  prefs: []
  type: TYPE_NORMAL
- en: Type traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, C++ programmers have developed various techniques to reason
    about the properties of their types, mostly at compile time. Inferring such things
    as *“Is the* `T` *type const?*” or *“Is the* `T` *type trivially copyable?”* can
    be very useful, particularly in the context of generic code. The constructs resulting
    from these techniques are called `<``type_traits>` header.
  prefs: []
  type: TYPE_NORMAL
- en: The ways in which standard type traits are expressed have standardized over
    time, going from complex beasts such as `std::numeric_limits<T>`, which provide
    a lot of different services for type `T`, to more specific services such as `std::is_const<T>`
    (*Is the* `type T` *actually* `const`*?*) or `std::remove_const<T>` (*Please give
    me the type that’s like* `T` *but without the* `const` *qualification if there
    was one*), which yield either a single type or a single value. Practice has shown
    that small, unitary type traits that yield either a type (named `type`) or a compile-time-known
    value (named `value`) can be considered “best practices,” and most contemporary
    type traits (including standard ones) are written this way.
  prefs: []
  type: TYPE_NORMAL
- en: Since C++14, the traits that yield types have aliases that end with `_t` (for
    example, instead of writing the rather painful `typename std::remove_const<T>::type`
    incantation, one can now write `std::remove_const_t<T>` instead) and since C++17,
    the traits that yield values have aliases that end with `_v` (for example, instead
    of writing `std::is_const<T>::value`, one can now write `std::is_const_v<T>`).
  prefs: []
  type: TYPE_NORMAL
- en: What about concepts?
  prefs: []
  type: TYPE_NORMAL
- en: Type traits are a programming technique that’s been part of C++ for decades,
    but since C++20, we have had **concepts**, and concepts are sort of like traits
    (often, they are expressed *through* traits) but are stronger in the sense that
    they are part of the type system. This book does not use concepts much, but you
    (as a programmer) really should get acquainted with them. They are extremely powerful
    and extremely useful to contemporary C++ programming.
  prefs: []
  type: TYPE_NORMAL
- en: The std::true_type and std::false_type traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When expressing type traits, the standard library applies the common practice
    of using the names `type` for types and `value` for values, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It happens that many type traits have Boolean values. To simplify the task of
    writing such traits and to ensure that the form of these traits is homogeneous,
    you will find types `std::true_type` and `std::false_type` in the `<type_traits>`
    header. These types can be seen as the type system counterparts of constants `true`
    and `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these types, we can rewrite traits such as `is_const` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These types are both a convenience and a way to express ideas more clearly.
  prefs: []
  type: TYPE_NORMAL
- en: The std::conditional<B,T,F> trait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s sometimes useful to choose between two types based on a condition known
    at compile time. Consider the following example where we seek to implement a comparison
    between two values of some type `T` that behave differently for floating-point
    types and for “other” types such as `int` all grouped together for simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You might notice that we did not name the arguments of type `exact` and `floating`
    in our `close_enough()` functions. That’s fine as we are not using these objects
    at all; the reason for these arguments is to ensure both functions have distinct
    signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a `std::is_floating_point<T>` trait in the `<type_traits>` header
    with the value of `true` for floating-point numbers, and `false` otherwise. If
    we did not have this trait, we could write our own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can use this to make our decision. However, we do not want to make a runtime
    decision here since the nature of type `T` is fully known at compile time, and
    nobody wants to pay for a branch instruction when comparing integers!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::conditional<B,T,F>` trait can be used to make such a decision. If
    we wrote our own, it could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this trait, we can choose, at compile time, one of two types based on
    a compile-time Boolean value, which is exactly what we were trying to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The way to read this is that the third argument in the call to `close_enough()`
    (found within our two-argument, user-facing `close_enough()` function) will either
    be an object of type `floating` or an object of type `exact` , but the exact type
    will be picked at compile time based on the value of the `is_floating_point_v<T>`
    compile-time constant. The end result is that we instantiate an object of one
    of these two empty classes, call the appropriate algorithm, and let function inlining
    do the rest and optimize the entire scaffolding away.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ standard library contains, among other gems, a set of algorithms. Each
    of these functions performs the tasks that a very well-written loop would do but
    with specific names, complexity guarantees, and optimizations. As such, let’s
    say we write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It is idiomatic in C++ to write the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '#include <iostream>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <algorithm>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iterator>'
  prefs: []
  type: TYPE_NORMAL
- en: using namespace std;
  prefs: []
  type: TYPE_NORMAL
- en: void display(int n) { cout << n << ' '; }
  prefs: []
  type: TYPE_NORMAL
- en: int main() {
  prefs: []
  type: TYPE_NORMAL
- en: int vals[]{ 2,3,5,7,11 };
  prefs: []
  type: TYPE_NORMAL
- en: for_each(begin(vals), end(vals), display);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '#include <iostream>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <algorithm>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iterator>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <fstream>'
  prefs: []
  type: TYPE_NORMAL
- en: using namespace std;
  prefs: []
  type: TYPE_NORMAL
- en: class Display {
  prefs: []
  type: TYPE_NORMAL
- en: ostream &os;
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Display(ostream &os) : os{ os } {'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void operator()(int n) const { os << n << ' '; }
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: int main() {
  prefs: []
  type: TYPE_NORMAL
- en: int vals[]{ 2,3,5,7,11 };
  prefs: []
  type: TYPE_NORMAL
- en: // display on the standard output
  prefs: []
  type: TYPE_NORMAL
- en: for_each(begin(vals), end(vals), Display{ cout });
  prefs: []
  type: TYPE_NORMAL
- en: ofstream out{"out.txt" };
  prefs: []
  type: TYPE_NORMAL
- en: // write to file out.txt
  prefs: []
  type: TYPE_NORMAL
- en: for_each(begin(vals), end(vals), Display{ out });
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '#include <iostream>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <algorithm>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <iterator>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <fstream>'
  prefs: []
  type: TYPE_NORMAL
- en: using namespace std;
  prefs: []
  type: TYPE_NORMAL
- en: int main() {
  prefs: []
  type: TYPE_NORMAL
- en: int vals[]{ 2,3,5,7,11 };
  prefs: []
  type: TYPE_NORMAL
- en: // display on the standard output
  prefs: []
  type: TYPE_NORMAL
- en: for_each(begin(vals), end(vals), [](int n) {
  prefs: []
  type: TYPE_NORMAL
- en: cout << n << ' ';
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: ofstream out{"out.txt" };
  prefs: []
  type: TYPE_NORMAL
- en: // write to file out.txt
  prefs: []
  type: TYPE_NORMAL
- en: for_each(begin(vals), end(vals), [&out](int n) {
  prefs: []
  type: TYPE_NORMAL
- en: out << n << ' ';
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: class thing {
  prefs: []
  type: TYPE_NORMAL
- en: 'thing(string_view); // note: private'
  prefs: []
  type: TYPE_NORMAL
- en: // ... various interesting members
  prefs: []
  type: TYPE_NORMAL
- en: // thing_factory can access private members of
  prefs: []
  type: TYPE_NORMAL
- en: // class thing
  prefs: []
  type: TYPE_NORMAL
- en: friend class thing_factory;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: // in case we read an incorrect file
  prefs: []
  type: TYPE_NORMAL
- en: class invalid_format{};
  prefs: []
  type: TYPE_NORMAL
- en: class thing_factory {
  prefs: []
  type: TYPE_NORMAL
- en: // ... various interesting things here too
  prefs: []
  type: TYPE_NORMAL
- en: string read_file(const string &name) const {
  prefs: []
  type: TYPE_NORMAL
- en: ifstream in{ name };
  prefs: []
  type: TYPE_NORMAL
- en: // consume the file in one fell swoop, returning
  prefs: []
  type: TYPE_NORMAL
- en: // the entire contents in a single string
  prefs: []
  type: TYPE_NORMAL
- en: return { istreambuf_iterator<char>{ in },
  prefs: []
  type: TYPE_NORMAL
- en: istreambuf_iterator<char>{ } };
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: bool is_valid_content(string_view) const;
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: thing create_thing_from(const string &name) const {
  prefs: []
  type: TYPE_NORMAL
- en: auto contents = read_file(name);
  prefs: []
  type: TYPE_NORMAL
- en: if(!is_valid_content(contents))
  prefs: []
  type: TYPE_NORMAL
- en: throw invalid_format{};
  prefs: []
  type: TYPE_NORMAL
- en: '// note: calls private thing constructor'
  prefs: []
  type: TYPE_NORMAL
- en: return { contents };
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: class A {
  prefs: []
  type: TYPE_NORMAL
- en: int n = 3;
  prefs: []
  type: TYPE_NORMAL
- en: friend class B;
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void f(B);
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: class B {
  prefs: []
  type: TYPE_NORMAL
- en: int m = 4;
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void f(A);
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: void A::f(B b) {
  prefs: []
  type: TYPE_NORMAL
- en: // int val = b.m; // no, A is not a friend of B
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void B::f(A a) {
  prefs: []
  type: TYPE_NORMAL
- en: int val = a.n; // Ok, B is a friend of A
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: class A {
  prefs: []
  type: TYPE_NORMAL
- en: int n = 3;
  prefs: []
  type: TYPE_NORMAL
- en: friend class B;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: class B {
  prefs: []
  type: TYPE_NORMAL
- en: friend class C;
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void f(A a) {
  prefs: []
  type: TYPE_NORMAL
- en: int val = a.n; // Ok, B is a friend of A
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: class C {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void f(A a) {
  prefs: []
  type: TYPE_NORMAL
- en: // int val = a.n; // no, C is not a friend of A
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: class A {
  prefs: []
  type: TYPE_NORMAL
- en: int n = 3;
  prefs: []
  type: TYPE_NORMAL
- en: friend class B;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: class B {
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void f(A a) {
  prefs: []
  type: TYPE_NORMAL
- en: int val = a.n; // Ok, B is a friend of A
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: 'class C : B {'
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: void f(A a) {
  prefs: []
  type: TYPE_NORMAL
- en: // int val = a.n; // no, C is not a friend of A
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: const int n = f();
  prefs: []
  type: TYPE_NORMAL
- en: auto m = n; // m is of type int
  prefs: []
  type: TYPE_NORMAL
- en: auto & r = m; // r is of type int&
  prefs: []
  type: TYPE_NORMAL
- en: const auto & cr0 = m; // cr0 is of type const int&
  prefs: []
  type: TYPE_NORMAL
- en: auto & cr1 = n; // cr1 is of type const int&
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: template <class T>
  prefs: []
  type: TYPE_NORMAL
- en: T& pass_thru(T &arg) {
  prefs: []
  type: TYPE_NORMAL
- en: return arg;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: int main() {
  prefs: []
  type: TYPE_NORMAL
- en: int n = 3;
  prefs: []
  type: TYPE_NORMAL
- en: auto m = pass_thru(n); // m is an int
  prefs: []
  type: TYPE_NORMAL
- en: ++m;
  prefs: []
  type: TYPE_NORMAL
- en: cout << n << ' ' << m << '\n'; // 3 4
  prefs: []
  type: TYPE_NORMAL
- en: decltype(pass_thru(n)) r = pass_thru(n); // r is an int&
  prefs: []
  type: TYPE_NORMAL
- en: ++r;
  prefs: []
  type: TYPE_NORMAL
- en: cout << n << ' ' << r << '\n'; // 4 4
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '#include <string>'
  prefs: []
  type: TYPE_NORMAL
- en: struct X {
  prefs: []
  type: TYPE_NORMAL
- en: X(int, const std::string&); // A
  prefs: []
  type: TYPE_NORMAL
- en: X(int, std::string&&); // B
  prefs: []
  type: TYPE_NORMAL
- en: // ... other constructors and various members
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: X x0{ 3, "hello" }; // calls A
  prefs: []
  type: TYPE_NORMAL
- en: string s = "hi!";
  prefs: []
  type: TYPE_NORMAL
- en: X x1{ 4, s }; // also calls A
  prefs: []
  type: TYPE_NORMAL
- en: X x2{ 5, string{ "there" } }; // calls B
  prefs: []
  type: TYPE_NORMAL
- en: X x3{ 5, "there too"s }; // also calls B
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: template <class ... Args>
  prefs: []
  type: TYPE_NORMAL
- en: X makeX(Args ... args) {
  prefs: []
  type: TYPE_NORMAL
- en: clog << "Creating a X object\n";
  prefs: []
  type: TYPE_NORMAL
- en: return X(args...); // <-- HERE
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: template <class ... Args>
  prefs: []
  type: TYPE_NORMAL
- en: X makeX(Args &... args) {
  prefs: []
  type: TYPE_NORMAL
- en: clog << "Creating a X object\n";
  prefs: []
  type: TYPE_NORMAL
- en: return X(args...); // <-- HERE
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: // v passed by movement (type vector<int> fully specified)
  prefs: []
  type: TYPE_NORMAL
- en: void f0(vector<int> &&v);
  prefs: []
  type: TYPE_NORMAL
- en: // v passed by movement (type vector<T> fully specified
  prefs: []
  type: TYPE_NORMAL
- en: // for some type T)
  prefs: []
  type: TYPE_NORMAL
- en: template <class T>
  prefs: []
  type: TYPE_NORMAL
- en: void f1(vector<T> &&v);
  prefs: []
  type: TYPE_NORMAL
- en: // v is a forwarding reference (type discovered by
  prefs: []
  type: TYPE_NORMAL
- en: // the compiler)
  prefs: []
  type: TYPE_NORMAL
- en: template <class T>
  prefs: []
  type: TYPE_NORMAL
- en: 'f2():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: template <class ... Args>
  prefs: []
  type: TYPE_NORMAL
- en: X makeX(Args &&... args) {
  prefs: []
  type: TYPE_NORMAL
- en: clog << "Creating a X object\n";
  prefs: []
  type: TYPE_NORMAL
- en: return X(args...); // <-- HERE (still incorrect)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: template <class ... Args>
  prefs: []
  type: TYPE_NORMAL
- en: X makeX(Args &&... args) {
  prefs: []
  type: TYPE_NORMAL
- en: clog << "Creating a X object\n";
  prefs: []
  type: TYPE_NORMAL
- en: return X(std::forward<Args>(args)...); // <-- HERE
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '#include <atomic>'
  prefs: []
  type: TYPE_NORMAL
- en: class SequentialIdProvider {
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  prefs: []
  type: TYPE_NORMAL
- en: std::atomic<long long> cur; // state (synchronized)
  prefs: []
  type: TYPE_NORMAL
- en: // default constructor (private)
  prefs: []
  type: TYPE_NORMAL
- en: 'SequentialIdProvider() : cur{ 0LL } {'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: // service offered by the singleton (synchronized)
  prefs: []
  type: TYPE_NORMAL
- en: auto next() { return cur++; }
  prefs: []
  type: TYPE_NORMAL
- en: // deleted copy operations
  prefs: []
  type: TYPE_NORMAL
- en: SequentialIdProvider(const SequentialIdProvider&)
  prefs: []
  type: TYPE_NORMAL
- en: = delete;
  prefs: []
  type: TYPE_NORMAL
- en: SequentialIdProvider&
  prefs: []
  type: TYPE_NORMAL
- en: operator=(const SequentialIdProvider&) = delete;
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '#include <atomic>'
  prefs: []
  type: TYPE_NORMAL
- en: class SequentialIdProvider {
  prefs: []
  type: TYPE_NORMAL
- en: // declaration (private)
  prefs: []
  type: TYPE_NORMAL
- en: static SequentialIdProvider singleton;
  prefs: []
  type: TYPE_NORMAL
- en: std::atomic<long long> cur; // state (synchronized)
  prefs: []
  type: TYPE_NORMAL
- en: // default constructor (private)
  prefs: []
  type: TYPE_NORMAL
- en: 'SequentialIdProvider() : cur{ 0LL } {'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'public:'
  prefs: []
  type: TYPE_NORMAL
- en: // static member function providing access to the object
  prefs: []
  type: TYPE_NORMAL
- en: static auto & get() { return singleton; }
  prefs: []
  type: TYPE_NORMAL
- en: // service offered by the singleton (synchronized)
  prefs: []
  type: TYPE_NORMAL
- en: auto next() { return cur++; }
  prefs: []
  type: TYPE_NORMAL
- en: // deleted copy operations
  prefs: []
  type: TYPE_NORMAL
- en: SequentialIdProvider(const SequentialIdProvider&)
  prefs: []
  type: TYPE_NORMAL
- en: = delete;
  prefs: []
  type: TYPE_NORMAL
- en: SequentialIdProvider&
  prefs: []
  type: TYPE_NORMAL
- en: operator=(const SequentialIdProvider&) = delete;
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: // in a source file somewhere, say SequentialIdProvider.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '#include "SequentialIdProvider.h"'
  prefs: []
  type: TYPE_NORMAL
- en: // definition (calls the default constructor)
  prefs: []
  type: TYPE_NORMAL
- en: SequentialIdProvider, we could run into trouble as C++ does not guarantee the
    order in which global objects from multiple files are instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible client code for this implementation would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This would display monotonically increasing integers, maybe consecutively (as
    long as there is no other thread concurrently calling the singleton’s services).
  prefs: []
  type: TYPE_NORMAL
- en: Instantiation of the first call
  prefs: []
  type: TYPE_NORMAL
- en: Another way to instantiate a singleton is to create it the first time its services
    are solicited by making it a `static` variable of the function that provides access
    to the singleton. This way, as `static` local variables are created the first
    time the function is called and keep their state thereafter, a singleton could
    provide services to other singletons as long as this does not create cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible implementation would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Possible client code for this implementation would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This would display monotonically increasing integers, maybe consecutively (as
    long as there is no other thread concurrently calling the singleton’s services).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this version has a hidden cost: `static` variables local to functions
    are called `static` variable involves some synchronization and that this synchronization
    is paid on every call to that function. The preceding client code alleviates that
    cost by calling `SequentialIdProvider::get()` once, then reusing the reference
    obtained through that call afterward; it’s the call to `get()` that introduces
    the synchronization cost.'
  prefs: []
  type: TYPE_NORMAL
- en: The std::exchange() function
  prefs: []
  type: TYPE_NORMAL
- en: 'There are (at least) two very useful and fundamental functions hidden in the
    `<utility>` header file. One is well-known and has been there for a long time:
    `std::swap()`, which is used for many purposes throughout the standard library
    as well as throughout user code.'
  prefs: []
  type: TYPE_NORMAL
- en: The other, more recent one is `std::exchange()`. Where `swap(a,b)` swaps the
    values of objects `a` and `b` , expression `a = exchange(b,c)` changes the value
    of `b` with the value of `c`, returning the old value of `b` (to assign it to
    `a`). This might look strange at first but it’s actually a very useful facility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the move constructor for the following simplified `fixed_size_array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You might notice that this constructor does two things: it grabs the data members
    from `other`, and then replaces the members of `other` with default values. That’s
    the posterchild for `std::exchange()`, so this constructor can be simplified as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: With `std::exchange()`, this common two-step operation can be reduced to a function
    call, simplifying code and making it more efficient (in this case, turning assignments
    into constructor calls).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
