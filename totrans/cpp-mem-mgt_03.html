<html><head></head><body>
<div epub:type="chapter" id="_idContainer014">
<h1 class="chapter-number" id="_idParaDest-47"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.2.1">Casts and cv-qualifications</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We are progressing. </span><span class="koboSpan" id="kobo.3.2">In </span><a href="B21071_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.5.1">, we looked at what memory, objects, and pointers are, as we know we will need to understand these basic ideas if we are to take control of memory management mechanisms. </span><span class="koboSpan" id="kobo.5.2">Then, in </span><a href="B21071_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.7.1">, we looked at some low-level constructs that could get us in trouble if misused are essential to understand in certain situations to take control of how our programs manage memory. </span><span class="koboSpan" id="kobo.7.2">That’s a somewhat dry way to start, but that also means the fun parts of our work are still to come. </span><span class="koboSpan" id="kobo.7.3">I hope </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">that’s encouraging!</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">At the end of </span><a href="B21071_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.11.1">, we examined approaches to type punning, a way to subvert the type system, including some that are believed to work by some but actually do not. </span><span class="koboSpan" id="kobo.11.2">C++ offers a number of controlled and explicit ways to interact with the type system, informing the compiler that it should see the type of an expression as something different than </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.12.1">what it can otherwise infer from the source code. </span><span class="koboSpan" id="kobo.12.2">These tools, the </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">type casts</span></strong><span class="koboSpan" id="kobo.14.1"> (or simply </span><em class="italic"><span class="koboSpan" id="kobo.15.1">casts</span></em><span class="koboSpan" id="kobo.16.1">), are the subject of </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">We will first examine what casts are in the general sense, distinguishing the various fundamental reasons to perform casts and showing why C-style casts are mostly inappropriate (except for some specific cases) in a C++ program. </span><span class="koboSpan" id="kobo.18.2">Then, we will take a quick look at </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.19.1">a safety-related aspect of the C++ system, </span><strong class="bold"><span class="koboSpan" id="kobo.20.1">cv-qualifications</span></strong><span class="koboSpan" id="kobo.21.1">, and discuss the role of cv-qualifiers in the hygiene and overall quality of C++ code. </span><span class="koboSpan" id="kobo.21.2">After that, we will examine the six C++ casts at our disposal. </span><span class="koboSpan" id="kobo.21.3">Finally, we will return to the C casts to show the limited situations in which they might still </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">be appropriate.</span></span></p>
<p><span class="koboSpan" id="kobo.23.1">In this chapter, we will learn </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.25.1">What casts are and what they mean in </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">a program</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">What cv-qualifications are and how they interact </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">with casts</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">What C++ casts are, including the C cast, and when they should </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">be used</span></span></li>
</ul>
<h1 id="_idParaDest-49"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.31.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.32.1">You can find the code files for this chapter in the book’s GitHub repository </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">here: </span></span><a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter3"><span class="No-Break"><span class="koboSpan" id="kobo.34.1">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter3</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.35.1">.</span></span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.36.1">What is a cast?</span></h1>
<p><span class="koboSpan" id="kobo.37.1">You will use a cast to adjust the compiler’s view on the type of an expression. </span><span class="koboSpan" id="kobo.37.2">The thing is, the compiler </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.38.1">sees our source code and understands what we wrote and what other people’s code expresses. </span><span class="koboSpan" id="kobo.38.2">Most of the time (hopefully), this code will make sense, and the compiler will translate your sources into proper binaries </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">without complaining.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">Sometimes, of course, there will be (hopefully temporary) discrepancies between programmer intent and code, as expressed through the sources seen by the compiler. </span><span class="koboSpan" id="kobo.40.2">Most of the time, the compiler will be right, and the programmer will rewrite the source code, at least in part, in order to better express the intent, inspired by the error or warning messages that revealed (in their own poetic way) a problem. </span><span class="koboSpan" id="kobo.40.3">Sometimes, of course, the source code matches the programmer’s intent, but there are still disagreements with the compiler and adjustments required to attain some agreement with it. </span><span class="koboSpan" id="kobo.40.4">For example, suppose a programmer wants to allocate a buffer large enough to store </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">lots</span></strong><span class="koboSpan" id="kobo.42.1"> of integers (</span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">lots</span></strong><span class="koboSpan" id="kobo.44.1"> being a value that’s either too large to reasonably use the stack or one that’s not known at compile time); one (low-level and error-prone but legal nonetheless) way to achieve this would be to call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">std::malloc()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.46.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.47.1">
// ...
</span><span class="koboSpan" id="kobo.47.2">int *p = std::malloc(lots * sizeof(int)); // &lt;-- HERE
if(p) {
    // use p as an array of int objects
    std::free(p);
}
// ...</span></pre> <p><span class="koboSpan" id="kobo.48.1">This code excerpt, as you might know, is not valid C++ – </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">std::malloc()</span></strong><span class="koboSpan" id="kobo.50.1"> returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">void*</span></strong><span class="koboSpan" id="kobo.52.1"> (a pointer to a chunk of raw memory of at least the requested size, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">nullptr</span></strong><span class="koboSpan" id="kobo.54.1"> if the allocation failed), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">void*</span></strong><span class="koboSpan" id="kobo.56.1"> is not implicitly convertible to </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">int*</span></strong><span class="koboSpan" id="kobo.58.1"> in C++ (the reverse is, of course, true –</span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">int*</span></strong><span class="koboSpan" id="kobo.60.1"> is indeed implicitly convertible </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">void*</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">Note that we could have replaced </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">std::malloc(lots*sizeof(int))</span></strong><span class="koboSpan" id="kobo.66.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">new int[lots]</span></strong><span class="koboSpan" id="kobo.68.1"> in this (oversimplified) case, but things are not always so simple, and sometimes, we need to lie to the type system, if only for a moment. </span><span class="koboSpan" id="kobo.68.2">And that’s where casts </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">come in.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">So, what are casts? </span><span class="koboSpan" id="kobo.70.2">Casts are a controlled way to guide the compiler’s type system in understanding programmer intent. </span><span class="koboSpan" id="kobo.70.3">Casts also provide information in source code about the reasons behind </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.71.1">such temporary lies; they document what the programmer intended to do at the very moment when a lie was required. </span><span class="koboSpan" id="kobo.71.2">The C++ casts are very clear in the intent they are conveying and very precise in their effect; the C-style cast (also seen in other languages) is much more vague in matters of intent, as we will see later in this chapter, and can perform inappropriate transformations in a language with such a rich type system </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">as C++.</span></span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.73.1">Safety in the type system – cv-qualifications</span></h1>
<p><span class="koboSpan" id="kobo.74.1">C++ provides </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.75.1">two safety-related qualifiers in its type system. </span><span class="koboSpan" id="kobo.75.2">These are named </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">const</span></strong><span class="koboSpan" id="kobo.77.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">volatile</span></strong><span class="koboSpan" id="kobo.79.1">, and they are related in </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">many ways.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">const</span></strong><span class="koboSpan" id="kobo.83.1"> qualifier </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.84.1">means the object thus qualified is considered immutable in the current scope, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.86.1">
const int N = 3; // global constant
class X {
    int n; // note: not const
public:
    X(int n) : n{ n } {
    }
    int g() { // note: not const
      return n += N; // thus, n's state can be mutated
    }
    int f() const { // const applies to this, and
                    // transitively to its members
      // return g(); // illegal as g() is not const
      return n + 1;
    }
};
int f(const int &amp;n) { // f() will not mutate argument n
    return X{ n }.f() + 1; // X::X(int) takes its argument
                          // by value so n remains intact
}
int main() {
    int a = 4;
    a = f(a); // a is not const in main()
}</span></pre> <p><span class="koboSpan" id="kobo.87.1">Marking an object as </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">const</span></strong><span class="koboSpan" id="kobo.89.1"> means that in the context where it is marked as such, it cannot be mutated. </span><span class="koboSpan" id="kobo.89.2">In the case of class members, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">const</span></strong><span class="koboSpan" id="kobo.91.1"> guarantee is maintained transitively through </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">const</span></strong><span class="koboSpan" id="kobo.93.1"> member functions, in the sense that a </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">const</span></strong><span class="koboSpan" id="kobo.95.1"> member function cannot </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.96.1">modify the members of </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">*this</span></strong><span class="koboSpan" id="kobo.98.1">, and nor can it call a non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">const</span></strong><span class="koboSpan" id="kobo.100.1"> member function of the same object. </span><span class="koboSpan" id="kobo.100.2">In the preceding example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">X::f</span></strong><span class="koboSpan" id="kobo.102.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">const</span></strong><span class="koboSpan" id="kobo.104.1">, and as such, it could not call </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">X::g</span></strong><span class="koboSpan" id="kobo.106.1">, which does not offer that guarantee; allowing </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">X::f</span></strong><span class="koboSpan" id="kobo.108.1"> to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">X::g</span></strong><span class="koboSpan" id="kobo.110.1"> would effectively break the </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">const</span></strong><span class="koboSpan" id="kobo.112.1"> guarantee, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">X::g</span></strong><span class="koboSpan" id="kobo.114.1"> can mutate </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">*this</span></strong><span class="koboSpan" id="kobo.116.1"> but </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">X::f</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.118.1"> cannot.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">const</span></strong><span class="koboSpan" id="kobo.121.1"> qualifier is well-known and well-documented in C++. </span><span class="koboSpan" id="kobo.121.2">Being “</span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">const</span></strong><span class="koboSpan" id="kobo.123.1">-correct” is generally seen as good code hygiene and is something you should strive to do in practice; using </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">const</span></strong><span class="koboSpan" id="kobo.125.1"> wherever it makes sense is one of the strongest assets of the C++ language, and many languages claiming to be “type-safe” lack this essential feature, without which, correctness is so much harder </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">to achieve.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">volatile</span></strong><span class="koboSpan" id="kobo.129.1"> keyword is the counterpart to </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">const</span></strong><span class="koboSpan" id="kobo.131.1">; hence, the term </span><em class="italic"><span class="koboSpan" id="kobo.132.1">cv-qualifier</span></em><span class="koboSpan" id="kobo.133.1"> refers to both these terms. </span><span class="koboSpan" id="kobo.133.2">Woefully underdefined in the standard, </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">volatile</span></strong><span class="koboSpan" id="kobo.135.1"> has a </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">few meanings.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">When applied to a fundamental type (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">volatile int</span></strong><span class="koboSpan" id="kobo.139.1">), it means that the object it qualifies could be accessed through ways unknown to the compiler and not necessarily visible from the source code. </span><span class="koboSpan" id="kobo.139.2">As such, this term is mostly useful when writing device drivers where some action external to the program itself (such as the physical pressure of a key) could change the memory associated with the object, or when some hardware or software component external to the source code could observe changes in that </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">object’s state.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">Informally, if the source code states, </span><em class="italic"><span class="koboSpan" id="kobo.142.1">“Please read the value of that volatile object,”</span></em><span class="koboSpan" id="kobo.143.1"> the code that </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.144.1">will be generated should read that value even if the program does not seem to modify it in any way; likewise, if the source code states “</span><em class="italic"><span class="koboSpan" id="kobo.145.1">Please write to that </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">volatile</span></strong><em class="italic"><span class="koboSpan" id="kobo.147.1"> object,”</span></em><span class="koboSpan" id="kobo.148.1"> then a write to that memory location should occur, even if nothing in the program seems to read from that memory location subsequently. </span><span class="koboSpan" id="kobo.148.2">Thus, </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">volatile</span></strong><span class="koboSpan" id="kobo.150.1"> can be seen as something that prevents optimizations that the compiler would otherwise be allowed </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">to perform.</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">In C++’s abstract machine, accessing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">volatile</span></strong><span class="koboSpan" id="kobo.154.1">-qualified object is the moral equivalent of an I/O operation – it can change the state of the program. </span><span class="koboSpan" id="kobo.154.2">On an object of some class type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">volatile</span></strong><span class="koboSpan" id="kobo.156.1"> can be applied to a member function just as </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">const</span></strong><span class="koboSpan" id="kobo.158.1"> can. </span><span class="koboSpan" id="kobo.158.2">Indeed, a non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">static</span></strong><span class="koboSpan" id="kobo.160.1"> member function can be qualified </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">const</span></strong><span class="koboSpan" id="kobo.162.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">volatile</span></strong><span class="koboSpan" id="kobo.164.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">const volatile</span></strong><span class="koboSpan" id="kobo.166.1">, or none of these (among </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">other things).</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">The meaning of applying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">const</span></strong><span class="koboSpan" id="kobo.170.1"> qualifier on a member function was described earlier with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">X::f</span></strong><span class="koboSpan" id="kobo.172.1"> member function – </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">*this</span></strong><span class="koboSpan" id="kobo.174.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">const</span></strong><span class="koboSpan" id="kobo.176.1">; its non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">mutable</span></strong><span class="koboSpan" id="kobo.178.1">, non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">static</span></strong><span class="koboSpan" id="kobo.180.1"> data members are </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">const</span></strong><span class="koboSpan" id="kobo.182.1"> in that function, and the only non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">static</span></strong><span class="koboSpan" id="kobo.184.1"> member functions that can be called through </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">*this</span></strong><span class="koboSpan" id="kobo.186.1"> are those that are </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">const</span></strong><span class="koboSpan" id="kobo.188.1">-qualified. </span><span class="koboSpan" id="kobo.188.2">A non-</span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">static</span></strong><span class="koboSpan" id="kobo.190.1"> member function qualified as </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">volatile</span></strong><span class="koboSpan" id="kobo.192.1"> is, likewise, quite similar – </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">*this</span></strong><span class="koboSpan" id="kobo.194.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">volatile</span></strong><span class="koboSpan" id="kobo.196.1"> during that function’s execution, and so are all of its members, which impacts what operations you can perform with these objects. </span><span class="koboSpan" id="kobo.196.2">For example, taking the address of </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">volatile int</span></strong><span class="koboSpan" id="kobo.198.1"> yields </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">volatile int*</span></strong><span class="koboSpan" id="kobo.200.1">, which is not implicitly convertible to </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">int*</span></strong><span class="koboSpan" id="kobo.202.1">, since the conversion would drop some security guarantees. </span><span class="koboSpan" id="kobo.202.2">This is one of the reasons why we </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">have casts.</span></span></p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.204.1">The C++ casts</span></h1>
<p><span class="koboSpan" id="kobo.205.1">Traditionally, C++ has </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.206.1">supported four ways to perform those explicit type conversions we call casts – </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">static_cast</span></strong><span class="koboSpan" id="kobo.208.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">dynamic_cast</span></strong><span class="koboSpan" id="kobo.210.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">const_cast</span></strong><span class="koboSpan" id="kobo.212.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">reinterpret_cast</span></strong><span class="koboSpan" id="kobo.214.1">. </span><span class="koboSpan" id="kobo.214.2">C++11 has added a fifth one, </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">duration_cast</span></strong><span class="koboSpan" id="kobo.216.1">, which is tangentially related to this book but will sometimes show up in examples, particularly when we measure the execution time of a function. </span><span class="koboSpan" id="kobo.216.2">Finally, C++20 introduced a sixth case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">bit_cast</span></strong><span class="koboSpan" id="kobo.218.1">, which is of interest to our work in </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">The following sections give a brief overview of each C++ cast, along with a few examples of how and when they can </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">be useful.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.222.1">Your best friend (most of the time) – static_cast</span></h2>
<p><span class="koboSpan" id="kobo.223.1">The best, most efficient tool in our type-casting toolset is </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">static_cast</span></strong><span class="koboSpan" id="kobo.225.1">. </span><span class="koboSpan" id="kobo.225.2">It’s mostly safe, costs essentially </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.226.1">nothing in most cases, and can be used in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">constexpr</span></strong><span class="koboSpan" id="kobo.228.1"> context, which makes it amenable to </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">compile-time maneuvers.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">static_cast</span></strong><span class="koboSpan" id="kobo.232.1"> in situations involving potential risks, such as converting an </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">int</span></strong><span class="koboSpan" id="kobo.234.1"> to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">float</span></strong><span class="koboSpan" id="kobo.236.1"> or vice versa. </span><span class="koboSpan" id="kobo.236.2">In the latter case, it explicitly acknowledges the loss of the decimal part. </span><span class="koboSpan" id="kobo.236.3">You can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">static_cast</span></strong><span class="koboSpan" id="kobo.238.1"> to cast a pointer or a reference from a derived class </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.239.1">to one of its direct or indirect bases (as long as there’s no ambiguity), which is totally safe and could be done implicitly, as well as from a base to one of its derived classes. </span><span class="koboSpan" id="kobo.239.2">Casting from a base class to a derived class using </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">static_cast</span></strong><span class="koboSpan" id="kobo.241.1"> is highly efficient but extremely risky if the cast is incorrect, as it does not perform </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">runtime checks.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">Here are </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">some examples:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.245.1">
struct B { virtual ~B() = default; /* ... </span><span class="koboSpan" id="kobo.245.2">*/ };
struct D0 : B { /* ... </span><span class="koboSpan" id="kobo.245.3">*/ };
struct D1 : B { /* ... </span><span class="koboSpan" id="kobo.245.4">*/ };
class X {
public:
    X(int, double);
};
void f(D0&amp;);
void f(D1*);
int main() {
    const float x = 3.14159f;
    int n = static_cast&lt;int&gt;(x); // Ok, no warning
    X x0{ 3, 3.5 }; // Ok
    // compiles, probably warns (narrowing conversion)
    X x1(3.5,0);
    // does not compile, narrowing not allowed with braces
    // X x2{ 3.5, 0 };
    X x3{ static_cast&lt;int&gt;(x), 3 }; // Ok
    D0 d0;
    // illegal, no base-derived relationship with D0 and D1
    // D1* d1 = static_cast&lt;D1*&gt;(&amp;d0);
    // Ok, static_cast could be omitted
    B *b = static_cast&lt;B*&gt;(&amp;d0);
    // f(*b); // illegal
    f(*static_cast&lt;D0*&gt;(b)); // Ok
    f(static_cast&lt;D1*&gt;(b)); // compiles but very dangerous!
</span><span class="koboSpan" id="kobo.245.5">}</span></pre> <p><span class="koboSpan" id="kobo.246.1">Pay special </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.247.1">attention to the last use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">static_cast</span></strong><span class="koboSpan" id="kobo.249.1"> of the preceding example – converting from a base class to one of its derived classes is appropriately </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.250.1">done with </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">static_cast</span></strong><span class="koboSpan" id="kobo.252.1">. </span><span class="koboSpan" id="kobo.252.2">However, you must ensure that the conversion leads to an object of the chosen type, as there is no runtime verification made of the validity of that conversion; as the name implies, only compile-time checks are done with this cast. </span><span class="koboSpan" id="kobo.252.3">If you’re not sure of what you’re doing with a downcast, this is not the tool </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">for you.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">static_cast</span></strong><span class="koboSpan" id="kobo.255.1"> does not only change the perspective of the compiler to the type of an expression; it also can adjust the memory address being accessed to take into account the types involved in the conversion. </span><span class="koboSpan" id="kobo.255.2">For example, when a </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">D</span></strong><span class="koboSpan" id="kobo.257.1"> class has at least two non-empty base classes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">B0</span></strong><span class="koboSpan" id="kobo.259.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">B1</span></strong><span class="koboSpan" id="kobo.261.1">, these two parts of the derived class are not at the same address within a </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">D</span></strong><span class="koboSpan" id="kobo.263.1"> object (if they were, they would overlap!), so </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">static_cast</span></strong><span class="koboSpan" id="kobo.265.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">D*</span></strong><span class="koboSpan" id="kobo.267.1"> to one of its </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.268.1">bases might yield a different address than that of </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">D*</span></strong><span class="koboSpan" id="kobo.270.1"> itself. </span><span class="koboSpan" id="kobo.270.2">We will </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.271.1">return to this when discussing </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">reinterpret_cast</span></strong><span class="koboSpan" id="kobo.273.1">, for which the behavior is different (and </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">more dangerous).</span></span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.275.1">A sign something’s wrong – dynamic_cast</span></h2>
<p><span class="koboSpan" id="kobo.276.1">There will be cases where you have a pointer or a reference to an object of some class type, and that </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.277.1">type happens to be different from (but related to) the type needed. </span><span class="koboSpan" id="kobo.277.2">This often happens – for example, in game engines where most classes derive from some </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">Component</span></strong><span class="koboSpan" id="kobo.279.1"> base and functions tend to take </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">Component*</span></strong><span class="koboSpan" id="kobo.281.1"> arguments </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.282.1">but need to access members from an object of the derived class </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">they expect.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">The main problem here is, typically, that the function’s interface is wrong – it accepts arguments of types that are insufficiently precise. </span><span class="koboSpan" id="kobo.284.2">Still, we all have software to deliver, and sometimes, we need to make things work even though we made some choices along the way that we will probably want to revisit </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">later on.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">The safe way to do such casts is </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">dynamic_cast</span></strong><span class="koboSpan" id="kobo.288.1">. </span><span class="koboSpan" id="kobo.288.2">This cast lets you convert a pointer or a reference from one type to another, related type in a way that lets you test whether the conversion worked or not; with pointers, an incorrect conversion yields </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">nullptr</span></strong><span class="koboSpan" id="kobo.290.1">, whereas with references, an incorrect conversion throws </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">std::bad_cast</span></strong><span class="koboSpan" id="kobo.292.1">. </span><span class="koboSpan" id="kobo.292.2">The relatedness of types with </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">dynamic_cast</span></strong><span class="koboSpan" id="kobo.294.1"> is not limited to base-derived relationships and includes casting from one base to another base in a multiple inheritance design. </span><span class="koboSpan" id="kobo.294.2">However, note that, in most cases, </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">dynamic_cast</span></strong><span class="koboSpan" id="kobo.296.1"> requires that the expression that is cast to another type is of the polymorphic type, in the sense that it must have at least one </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">virtual</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.298.1">member function.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">Here are </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">some examples:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
struct B0 {
    virtual int f() const = 0;
    virtual ~B0() = default;
};
struct B1 {
    virtual int g() const = 0;
    virtual ~B1() = default;
};
class D0 : public B0 {
    public: int f() const override { return 3; }
};
class D1 : public B1 {
    public: int g() const override { return 4; }
};
class D : public D0, public D1 {};
int f(D *p) {
    return p? </span><span class="koboSpan" id="kobo.301.2">p-&gt;f() + p-&gt;g() : -1; // Ok
}
// g has the wrong interface: it accepts a D0&amp; but
// tries to use it as a D1&amp;, which makes sense if
// the referred object is publicly D0 and D1 (for
// example, class D
int g(D0 &amp;d0) {
    D1 &amp;d1 = dynamic_cast&lt;D1&amp;&gt;(d0); // throws if wrong
    return d1.g();
}
#include &lt;iostream&gt;
int main() {
    D d;
    f(&amp;d); // Ok
    g(d); // Ok, a D is a D0
    D0 d0;
    // calls f(nullptr) as &amp;d0 does not point to a D
    std::cout &lt;&lt; f(dynamic_cast&lt;D*&gt;(&amp;d0)) &lt;&lt; '\n'; // -1
    try {
      g(d0); // compiles but will throw bad_cast
    } catch(std::bad_cast&amp;) {
      std::cerr &lt;&lt; "Nice try\n";
    }
}</span></pre> <p><span class="koboSpan" id="kobo.302.1">Note that even though this example displays a message when </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">std::bad_cast</span></strong><span class="koboSpan" id="kobo.304.1"> is thrown, this is in </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.305.1">no way what we could call exception handling; we did not solve the “problem,” and code execution continues in a potentially corrupt state, which could </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.306.1">make things worse in more serious code. </span><span class="koboSpan" id="kobo.306.2">In a toy example such as this, just letting code fail and stop executing would also have been a </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">reasonable choice.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">In practice, the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">dynamic_cast</span></strong><span class="koboSpan" id="kobo.310.1"> should be rare, as it tends to be a sign that we chose our function interfaces in a perfectible manner. </span><span class="koboSpan" id="kobo.310.2">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">dynamic_cast</span></strong><span class="koboSpan" id="kobo.312.1"> requires binaries </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.313.1">to be compiled with </span><strong class="bold"><span class="koboSpan" id="kobo.314.1">runtime type information</span></strong><span class="koboSpan" id="kobo.315.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.316.1">RTTI</span></strong><span class="koboSpan" id="kobo.317.1">) included, leading to larger binaries. </span><span class="koboSpan" id="kobo.317.2">Unsurprisingly, due to these costs, some application domains will tend to avoid this cast, and so </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">will we.</span></span></p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.319.1">Playing tricks with safety – const_cast</span></h2>
<p><span class="koboSpan" id="kobo.320.1">Neither </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">static_cast</span></strong><span class="koboSpan" id="kobo.322.1"> nor </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">dynamic_cast</span></strong><span class="koboSpan" id="kobo.324.1"> (nor </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">reinterpret_cast</span></strong><span class="koboSpan" id="kobo.326.1">, for that matter) can change </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.327.1">the cv-qualifiers of an expression; to do this, you </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.328.1">need </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">const_cast</span></strong><span class="koboSpan" id="kobo.330.1">. </span><span class="koboSpan" id="kobo.330.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">const_cast</span></strong><span class="koboSpan" id="kobo.332.1">, you can add or remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">const</span></strong><span class="koboSpan" id="kobo.334.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">volatile</span></strong><span class="koboSpan" id="kobo.336.1"> qualifiers from an expression. </span><span class="koboSpan" id="kobo.336.2">As you might have guessed, this only makes sense on a pointer or on </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">a reference.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">Why would you do something such as remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">const</span></strong><span class="koboSpan" id="kobo.340.1">-ness from an expression? </span><span class="koboSpan" id="kobo.340.2">Surprisingly, there are many situations where this comes in handy, but a common one is allowing the </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.341.1">use of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">const</span></strong><span class="koboSpan" id="kobo.343.1">-correct type in a setting where </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">const</span></strong><span class="koboSpan" id="kobo.345.1">-ness was not </span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.346.1">used appropriately – for example, legacy code that did not use </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">const</span></strong><span class="koboSpan" id="kobo.348.1">, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.350.1">
#include &lt;vector&gt;
struct ResourceHandle { /* ... </span><span class="koboSpan" id="kobo.350.2">*/ };
// this function observes a resource without modifying it,
// but the type system is not aware of that fact (the
// argument is not const)
void observe_resource(ResourceHandle*);
class ResourceManager {
    std::vector&lt;ResourceHandle *&gt; resources;
    // ...
</span><span class="koboSpan" id="kobo.350.3">public:
    // note: const member function
    void observe_resources() const {
      // we want to observe each resource, for example
      // to collect data
      for(const ResourceHandle * h : resources) {
       // does not compile, h is const
       // observe_resource(h);
      // temporarily dismiss constness
          observe_resource(const_cast&lt;ResourceHandle*&gt;(h));
      }
    }
    // ...
</span><span class="koboSpan" id="kobo.350.4">};</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">const_cast</span></strong><span class="koboSpan" id="kobo.352.1"> is a tool to </span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.353.1">play with the security of the type system; it should </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.354.1">be used in specific, controlled situations and not to do unreasonable things such as changing the value of a mathematical constant, such as pi. </span><span class="koboSpan" id="kobo.354.2">If try something </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.355.1">like that, you’ll incur </span><strong class="bold"><span class="koboSpan" id="kobo.356.1">Undefined Behavior</span></strong><span class="koboSpan" id="kobo.357.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.358.1">UB</span></strong><span class="koboSpan" id="kobo.359.1">) – and </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">rightfully so.</span></span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.361.1">“Believe me, compiler” – reinterpret_cast</span></h2>
<p><span class="koboSpan" id="kobo.362.1">Sometimes, you just have to make the compiler believe you. </span><span class="koboSpan" id="kobo.362.2">For example, knowing </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">sizeof(int)==4</span></strong><span class="koboSpan" id="kobo.364.1"> on your platform, you might want to treat </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">int</span></strong><span class="koboSpan" id="kobo.366.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">char[4]</span></strong><span class="koboSpan" id="kobo.368.1"> to interoperate </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.369.1">with an existing API that expects that type. </span><span class="koboSpan" id="kobo.369.2">Note that you should ensure that this property holds (maybe through </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">static_assert</span></strong><span class="koboSpan" id="kobo.371.1">), rather than </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.372.1">relying on the belief that this property holds on all platforms (it </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">does not).</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">That’s what </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">reinterpret_cast</span></strong><span class="koboSpan" id="kobo.376.1"> gives you – the ability to cast a pointer of some type to a pointer of an unrelated type. </span><span class="koboSpan" id="kobo.376.2">This can be used in situations where you seek to benefit from pointer-interconvertibility, as we saw in </span><a href="B21071_02.xhtml#_idTextAnchor027"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.377.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.378.1">, just as this can be used to lie to the type system in several rather dangerous and </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">non-portable ways.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">Take the aforementioned conversion from an integer to an array of four bytes – if the aim is to facilitate addressing individual bytes, you have to be aware that the endianness of integers depends on the platform, as well as that the code written will probably be non-portable unless some careful measures </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">are taken.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">Also, note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">reinterpret_cast</span></strong><span class="koboSpan" id="kobo.384.1"> only changes the type associated with an expression – for example, it does not perform the slight address adjustments that </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">static_cast</span></strong><span class="koboSpan" id="kobo.386.1"> would make when converting from a derived class to a base class in multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">inheritance situations.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">The following example shows the difference between these </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">two casts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.390.1">
struct B0 { int n = 3; };
struct B1 { float f = 3.5f; };
// B0 is the first base subobject of D
class D : public B0, public B1 { };
int main() {
    D d;
    // b0 and &amp;d point to the same address
    // b1 and &amp;d do not point to the same address
    B0 *b0 = static_cast&lt;B0*&gt;(&amp;d);
    B1 *b1 = static_cast&lt;B1*&gt;(&amp;d);
    int n0 = b0-&gt;n; // Ok
    float f0 = b1-&gt;f; // Ok
    // r0 and &amp;d point to the same address
    // r1 and &amp;d also point to the same address... </span><span class="koboSpan" id="kobo.390.2">oops!
</span><span class="koboSpan" id="kobo.390.3">    B0 *r0 = reinterpret_cast&lt;B0*&gt;(&amp;d); // fragile
    B1 *r1 = reinterpret_cast&lt;B1*&gt;(&amp;d); // bad idea
    int nr0 = r0-&gt;n; // Ok but fragile
    float fr0 = r1-&gt;f; // UB
}</span></pre> <p><span class="koboSpan" id="kobo.391.1">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">reinterpret_cast</span></strong><span class="koboSpan" id="kobo.393.1"> sparingly. </span><span class="koboSpan" id="kobo.393.2">Relatively safe uses include converting a pointer to an integral </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.394.1">representation when given a sufficiently wide integral type (and vice versa), converting between null pointers of different types, and converting </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.395.1">between function pointer types – although in that case, the results of calling the function through the resulting pointer are undefined. </span><span class="koboSpan" id="kobo.395.2">The complete list of conversions that can be performed with this cast can be found at </span><a href="http://wg21.link/expr.reinterpret.cast"><span class="koboSpan" id="kobo.396.1">wg21.link/expr.reinterpret.cast</span></a><span class="koboSpan" id="kobo.397.1"> if you want to </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">know more.</span></span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.399.1">I know the bits are right – bit_cast</span></h2>
<p><span class="koboSpan" id="kobo.400.1">C++20 </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.401.1">introduced </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">bit_cast</span></strong><span class="koboSpan" id="kobo.403.1">, a new cast that can be used to copy bits from one object </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.404.1">to another of the same width, starting the lifetime of the destination object (and the objects enclosed therein, if any) along the way, as long as both the source and destination types are trivially copyable. </span><span class="koboSpan" id="kobo.404.2">This somewhat magical library function can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">&lt;bit&gt;</span></strong><span class="koboSpan" id="kobo.406.1"> header and </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">constexpr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.412.1">
#include &lt;bit&gt;
struct A { int a; double b; };
struct B { unsigned int c; double d; };
int main() {
    constexpr A a{ 3, 3.5 }; // ok
    constexpr B b = std::bit_cast&lt;B&gt;(a); // Ok
    static_assert(a.a == b.c &amp;&amp; a.b == b.d); // Ok
    static_assert((void*)&amp;a != (void*)&amp;b); // Ok
}</span></pre> <p><span class="koboSpan" id="kobo.413.1">As can be seen </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.414.1">in this example, both </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">A</span></strong><span class="koboSpan" id="kobo.416.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">B</span></strong><span class="koboSpan" id="kobo.418.1"> are constructed at compile time and are bitwise identical to one another, but their addresses are different, as they are </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.419.1">entirely different objects. </span><span class="koboSpan" id="kobo.419.2">Their data members are partially of different types but are of the same sizes, in the same order, and are all </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">trivially copyable.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">Also, note the use of a C-style cast on the last line of this example. </span><span class="koboSpan" id="kobo.421.2">As we will soon discuss, this is one of the few reasonable uses of C-style casts (we could have used </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">static_cast</span></strong><span class="koboSpan" id="kobo.423.1"> here too and it would have been just </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">as efficient).</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.425.1">Somewhat unrelated, but still – duration_cast</span></h2>
<p><span class="koboSpan" id="kobo.426.1">We won’t </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.427.1">dwell too long on </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">duration_cast</span></strong><span class="koboSpan" id="kobo.429.1">, as it is only tangentially related </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.430.1">to our topic of interest, but since it will be part of our toolset for micro-benchmarking in this book, it at least deserves </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">a mention.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">duration_cast</span></strong><span class="koboSpan" id="kobo.434.1"> library function can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">&lt;chrono&gt;</span></strong><span class="koboSpan" id="kobo.436.1"> header and is part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">std::chrono</span></strong><span class="koboSpan" id="kobo.438.1"> namespace. </span><span class="koboSpan" id="kobo.438.2">It is </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">constexpr</span></strong><span class="koboSpan" id="kobo.440.1"> and can be used to convert between expressions of different </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">measurement units.</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">For example, suppose that we want to measure the time it took to execute some function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">f()</span></strong><span class="koboSpan" id="kobo.444.1">, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">system_clock</span></strong><span class="koboSpan" id="kobo.446.1"> provided by our library vendor. </span><span class="koboSpan" id="kobo.446.2">We can read that clock using its </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">now()</span></strong><span class="koboSpan" id="kobo.448.1"> static member function before and after calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">f()</span></strong><span class="koboSpan" id="kobo.450.1">, which gives us two </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">time_point</span></strong><span class="koboSpan" id="kobo.452.1"> objects for that clock (two moments in time), and then compute the difference between them to get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">duration</span></strong><span class="koboSpan" id="kobo.454.1"> for that clock. </span><span class="koboSpan" id="kobo.454.2">We do not know what </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.455.1">measurement unit was used to represent that duration, but if we </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.456.1">want to use it expressed as, say, </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">microseconds</span></strong><span class="koboSpan" id="kobo.458.1">, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">duration_cast</span></strong><span class="koboSpan" id="kobo.460.1"> to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">than conversion:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.462.1">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
int f() { /* ... </span><span class="koboSpan" id="kobo.462.2">*/ }
int main() {
    using std::cout;
    using namespace std::chrono;
    auto pre = system_clock::now();
    int res = f();
    auto post = system_clock::now();
    cout &lt;&lt; "Computed " &lt;&lt; res &lt;&lt; " in "
        &lt;&lt; duration_cast&lt;microseconds&gt;(post - pre);
}</span></pre> <p><span class="koboSpan" id="kobo.463.1">We will systematize our benchmarking practices later in this book, showing a more formal way to measure the execution time of functions or code blocks, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">duration_cast</span></strong><span class="koboSpan" id="kobo.465.1"> will be our tool of choice to ensure that the format in which we present the results is appropriate for </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">our needs.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.467.1">The reviled one – the C cast</span></h2>
<p><span class="koboSpan" id="kobo.468.1">You might be tempted to use C-style casts when type conversions are needed, as the C syntax appears </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.469.1">in other languages and tends to be short to express – </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">(T)expr</span></strong><span class="koboSpan" id="kobo.471.1"> treats expression, </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">expr</span></strong><span class="koboSpan" id="kobo.473.1">, as being of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">T</span></strong><span class="koboSpan" id="kobo.475.1">. </span><span class="koboSpan" id="kobo.475.2">That terseness is actually a downside, not an upside, as we will see. </span><span class="koboSpan" id="kobo.475.3">Limit C-style casts to a minimum in </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">C++ code:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.477.1">The C-style casts </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.478.1">are harder to find when performing an automated search through source code text, since they look like arguments in a function call. </span><span class="koboSpan" id="kobo.478.2">Since casts are ways through which we lie to the type system, revisiting the decision to use them from time to time is worthwhile, so being able to find them is valuable. </span><span class="koboSpan" id="kobo.478.3">In comparison, the C++ casts are keywords, which makes them easier </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">to find.</span></span></li>
<li><span class="koboSpan" id="kobo.480.1">A C-style cast does not convey information about why a conversion occurred. </span><span class="koboSpan" id="kobo.480.2">When writing </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">(T)expr</span></strong><span class="koboSpan" id="kobo.482.1">, we are not saying whether we want to change cv-qualifiers, navigate a class hierarchy, simply change to type of a pointer, and so on. </span><span class="koboSpan" id="kobo.482.2">In particular, when converting between pointers to different types, a C-style cast will generally behave as </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">reinterpret_cast</span></strong><span class="koboSpan" id="kobo.484.1">, which, as we have seen, can lead to disastrous results in </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">some circumstances.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.486.1">You will sometimes see C-style casts in C++ code, mostly for situations where the intent is absolutely clear. </span><span class="koboSpan" id="kobo.486.2">We saw an example at the end of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">bit_cast</span></strong><span class="koboSpan" id="kobo.488.1"> section. </span><span class="koboSpan" id="kobo.488.2">Another example would be to silence compiler warnings – for example, when calling a function that’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">[[nodiscard]]</span></strong><span class="koboSpan" id="kobo.490.1"> but still really wanting to discard the results nonetheless for </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">some reason.</span></span></p>
<p><span class="koboSpan" id="kobo.492.1">In yet another example, consider the following </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">generic function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.494.1">
template &lt;class ItA, class ItB&gt;
    bool all_equal(ItA bA, ItA eA, ItB bB, ItB eB) {
      for(; bA != eA &amp;&amp; bB != eB; ++bA, </span><strong class="bold"><span class="koboSpan" id="kobo.495.1">(void)</span></strong><span class="koboSpan" id="kobo.496.1"> ++bB)
          if (*bA != bB)
            return false;
      return true;
    }</span></pre> <p><span class="koboSpan" id="kobo.497.1">This function iterates through two sequences that are delimited, respectively, by </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">[bA,eA)</span></strong><span class="koboSpan" id="kobo.499.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">[bB,eB)</span></strong><span class="koboSpan" id="kobo.501.1"> (making sure to stop as soon as the shortest sequence has been processed), compares the elements at the “same position” in these two sequences, and yields </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">true</span></strong><span class="koboSpan" id="kobo.503.1"> only if all comparisons between elements of those two sequences </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">are equal.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">Note that the cast to </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">void</span></strong><span class="koboSpan" id="kobo.507.1"> uses a C-style cast between the increments of </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">bA</span></strong><span class="koboSpan" id="kobo.509.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">bB</span></strong><span class="koboSpan" id="kobo.511.1"> in this code, which cast </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.512.1">the result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">++bB</span></strong><span class="koboSpan" id="kobo.514.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">void</span></strong><span class="koboSpan" id="kobo.516.1">. </span><span class="koboSpan" id="kobo.516.2">This may look strange, but this </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.517.1">is code that can be used in many situations by pretty much anyone, including hostile (or distracted) users. </span><span class="koboSpan" id="kobo.517.2">Suppose someone with a twisted mind had decided to overload the comma operator (yes, you can do that) between the types of </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">operator++(ItA)</span></strong><span class="koboSpan" id="kobo.519.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">operator++(ItB)</span></strong><span class="koboSpan" id="kobo.521.1">. </span><span class="koboSpan" id="kobo.521.2">That person could then essentially hijack our function to run unexpected code. </span><span class="koboSpan" id="kobo.521.3">By casting one of the arguments to </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">void</span></strong><span class="koboSpan" id="kobo.523.1">, we ensure that this is </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">not possible.</span></span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.525.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.526.1">That concludes our quick overview of casts and cv-qualifications in C++. </span><span class="koboSpan" id="kobo.526.2">Now that we’ve seen some ways to trick the type system and get in trouble, as well as know why we should do these things carefully (if at all), we can start building beautiful things with C++ and work toward safe, efficient abstractions in our endeavor to write correct programs that control how we </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">manage memory.</span></span></p>
<p><span class="koboSpan" id="kobo.528.1">In the next chapter, we will start by using one of the language’s defining features, the destructor, to automate the way our code handles resources, with an eye in particular on the way memory </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">is handled.</span></span></p>
</div>


<div class="Content" epub:type="part" id="_idContainer015">
<h1 id="_idParaDest-61" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.1.1">Part 2: Implicit Memory Management Techniques</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, we will examine some well-known approaches to implicit resource management (including memory management) in C++. </span><span class="koboSpan" id="kobo.2.2">These are all techniques you can use in your daily programming practices that will lead to simpler and safer programs than what you would get if you wanted to manage memory explicitly. </span><span class="koboSpan" id="kobo.2.3">You could say that the chapters in this part concern what people call “modern” or “</span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">contemporary” C++.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B21071_04.xhtml#_idTextAnchor062"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Using Destructors</span></em></li>
<li><a href="B21071_05.xhtml#_idTextAnchor079"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Using Standard Smart Pointers</span></em></li>
<li><a href="B21071_06.xhtml#_idTextAnchor096"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Writing Smart Pointers</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer016">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer017">
</div>
</div>
</body></html>