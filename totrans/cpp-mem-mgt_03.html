<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-47"><a id="_idTextAnchor047"/>3</h1>
<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/>Casts and cv-qualifications</h1>
<p>We are progressing. In <a href="B21071_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, we looked at what memory, objects, and pointers are, as we know we will need to understand these basic ideas if we are to take control of memory management mechanisms. Then, in <a href="B21071_02.xhtml#_idTextAnchor027"><em class="italic">Chapter 2</em></a>, we looked at some low-level constructs that could get us in trouble if misused are essential to understand in certain situations to take control of how our programs manage memory. That’s a somewhat dry way to start, but that also means the fun parts of our work are still to come. I hope that’s encouraging!</p>
<p>At the end of <a href="B21071_02.xhtml#_idTextAnchor027"><em class="italic">Chapter 2</em></a>, we examined approaches to type punning, a way to subvert the type system, including some that are believed to work by some but actually do not. C++ offers a number of controlled and explicit ways to interact with the type system, informing the compiler that it should see the type of an expression as something different than <a id="_idIndexMarker153"/>what it can otherwise infer from the source code. These tools, the <strong class="bold">type casts</strong> (or simply <em class="italic">casts</em>), are the subject of this chapter.</p>
<p>We will first examine what casts are in the general sense, distinguishing the various fundamental reasons to perform casts and showing why C-style casts are mostly inappropriate (except for some specific cases) in a C++ program. Then, we will take a quick look at <a id="_idIndexMarker154"/>a safety-related aspect of the C++ system, <strong class="bold">cv-qualifications</strong>, and discuss the role of cv-qualifiers in the hygiene and overall quality of C++ code. After that, we will examine the six C++ casts at our disposal. Finally, we will return to the C casts to show the limited situations in which they might still be appropriate.</p>
<p>In this chapter, we will learn the following:</p>
<ul>
<li>What casts are and what they mean in a program</li>
<li>What cv-qualifications are and how they interact with casts</li>
<li>What C++ casts are, including the C cast, and when they should be used</li>
</ul>
<h1 id="_idParaDest-49"><a id="_idTextAnchor049"/>Technical requirements</h1>
<p>You can find the code files for this chapter in the book’s GitHub repository here: <a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter3">https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter3</a>.</p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/>What is a cast?</h1>
<p>You will use a cast to adjust the compiler’s view on the type of an expression. The thing is, the compiler <a id="_idIndexMarker155"/>sees our source code and understands what we wrote and what other people’s code expresses. Most of the time (hopefully), this code will make sense, and the compiler will translate your sources into proper binaries without complaining.</p>
<p>Sometimes, of course, there will be (hopefully temporary) discrepancies between programmer intent and code, as expressed through the sources seen by the compiler. Most of the time, the compiler will be right, and the programmer will rewrite the source code, at least in part, in order to better express the intent, inspired by the error or warning messages that revealed (in their own poetic way) a problem. Sometimes, of course, the source code matches the programmer’s intent, but there are still disagreements with the compiler and adjustments required to attain some agreement with it. For example, suppose a programmer wants to allocate a buffer large enough to store <code>lots</code> of integers (<code>lots</code> being a value that’s either too large to reasonably use the stack or one that’s not known at compile time); one (low-level and error-prone but legal nonetheless) way to achieve this would be to call the <code>std::malloc()</code> function:</p>
<pre class="source-code">
// ...
int *p = std::malloc(lots * sizeof(int)); // &lt;-- HERE
if(p) {
    // use p as an array of int objects
    std::free(p);
}
// ...</pre> <p>This code excerpt, as you might know, is not valid C++ – <code>std::malloc()</code> returns <code>void*</code> (a pointer to a chunk of raw memory of at least the requested size, or <code>nullptr</code> if the allocation failed), and <code>void*</code> is not implicitly convertible to <code>int*</code> in C++ (the reverse is, of course, true –<code>int*</code> is indeed implicitly convertible to <code>void*</code>).</p>
<p>Note that we could have replaced <code>std::malloc(lots*sizeof(int))</code> with <code>new int[lots]</code> in this (oversimplified) case, but things are not always so simple, and sometimes, we need to lie to the type system, if only for a moment. And that’s where casts come in.</p>
<p>So, what are casts? Casts are a controlled way to guide the compiler’s type system in understanding programmer intent. Casts also provide information in source code about the reasons behind <a id="_idIndexMarker156"/>such temporary lies; they document what the programmer intended to do at the very moment when a lie was required. The C++ casts are very clear in the intent they are conveying and very precise in their effect; the C-style cast (also seen in other languages) is much more vague in matters of intent, as we will see later in this chapter, and can perform inappropriate transformations in a language with such a rich type system as C++.</p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/>Safety in the type system – cv-qualifications</h1>
<p>C++ provides <a id="_idIndexMarker157"/>two safety-related qualifiers in its type system. These are named <code>const</code> and <code>volatile</code>, and they are related in many ways.</p>
<p>The <code>const</code> qualifier <a id="_idIndexMarker158"/>means the object thus qualified is considered immutable in the current scope, such as the following:</p>
<pre class="source-code">
const int N = 3; // global constant
class X {
    int n; // note: not const
public:
    X(int n) : n{ n } {
    }
    int g() { // note: not const
      return n += N; // thus, n's state can be mutated
    }
    int f() const { // const applies to this, and
                    // transitively to its members
      // return g(); // illegal as g() is not const
      return n + 1;
    }
};
int f(const int &amp;n) { // f() will not mutate argument n
    return X{ n }.f() + 1; // X::X(int) takes its argument
                          // by value so n remains intact
}
int main() {
    int a = 4;
    a = f(a); // a is not const in main()
}</pre> <p>Marking an object as <code>const</code> means that in the context where it is marked as such, it cannot be mutated. In the case of class members, the <code>const</code> guarantee is maintained transitively through <code>const</code> member functions, in the sense that a <code>const</code> member function cannot <a id="_idIndexMarker159"/>modify the members of <code>*this</code>, and nor can it call a non-<code>const</code> member function of the same object. In the preceding example, <code>X::f</code> is <code>const</code>, and as such, it could not call <code>X::g</code>, which does not offer that guarantee; allowing <code>X::f</code> to call <code>X::g</code> would effectively break the <code>const</code> guarantee, as <code>X::g</code> can mutate <code>*this</code> but <code>X::f</code> cannot.</p>
<p>The <code>const</code> qualifier is well-known and well-documented in C++. Being “<code>const</code>-correct” is generally seen as good code hygiene and is something you should strive to do in practice; using <code>const</code> wherever it makes sense is one of the strongest assets of the C++ language, and many languages claiming to be “type-safe” lack this essential feature, without which, correctness is so much harder to achieve.</p>
<p>The <code>volatile</code> keyword is the counterpart to <code>const</code>; hence, the term <em class="italic">cv-qualifier</em> refers to both these terms. Woefully underdefined in the standard, <code>volatile</code> has a few meanings.</p>
<p>When applied to a fundamental type (for example, <code>volatile int</code>), it means that the object it qualifies could be accessed through ways unknown to the compiler and not necessarily visible from the source code. As such, this term is mostly useful when writing device drivers where some action external to the program itself (such as the physical pressure of a key) could change the memory associated with the object, or when some hardware or software component external to the source code could observe changes in that object’s state.</p>
<p>Informally, if the source code states, <em class="italic">“Please read the value of that volatile object,”</em> the code that <a id="_idIndexMarker160"/>will be generated should read that value even if the program does not seem to modify it in any way; likewise, if the source code states “<em class="italic">Please write to that </em><code>volatile</code><em class="italic"> object,”</em> then a write to that memory location should occur, even if nothing in the program seems to read from that memory location subsequently. Thus, <code>volatile</code> can be seen as something that prevents optimizations that the compiler would otherwise be allowed to perform.</p>
<p>In C++’s abstract machine, accessing a <code>volatile</code>-qualified object is the moral equivalent of an I/O operation – it can change the state of the program. On an object of some class type, <code>volatile</code> can be applied to a member function just as <code>const</code> can. Indeed, a non-<code>static</code> member function can be qualified <code>const</code>, <code>volatile</code>, <code>const volatile</code>, or none of these (among other things).</p>
<p>The meaning of applying the <code>const</code> qualifier on a member function was described earlier with the <code>X::f</code> member function – <code>*this</code> is <code>const</code>; its non-<code>mutable</code>, non-<code>static</code> data members are <code>const</code> in that function, and the only non-<code>static</code> member functions that can be called through <code>*this</code> are those that are <code>const</code>-qualified. A non-<code>static</code> member function qualified as <code>volatile</code> is, likewise, quite similar – <code>*this</code> is <code>volatile</code> during that function’s execution, and so are all of its members, which impacts what operations you can perform with these objects. For example, taking the address of <code>volatile int</code> yields <code>volatile int*</code>, which is not implicitly convertible to <code>int*</code>, since the conversion would drop some security guarantees. This is one of the reasons why we have casts.</p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor052"/>The C++ casts</h1>
<p>Traditionally, C++ has <a id="_idIndexMarker161"/>supported four ways to perform those explicit type conversions we call casts – <code>static_cast</code>, <code>dynamic_cast</code>, <code>const_cast</code>, and <code>reinterpret_cast</code>. C++11 has added a fifth one, <code>duration_cast</code>, which is tangentially related to this book but will sometimes show up in examples, particularly when we measure the execution time of a function. Finally, C++20 introduced a sixth case, <code>bit_cast</code>, which is of interest to our work in this book.</p>
<p>The following sections give a brief overview of each C++ cast, along with a few examples of how and when they can be useful.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/>Your best friend (most of the time) – static_cast</h2>
<p>The best, most efficient tool in our type-casting toolset is <code>static_cast</code>. It’s mostly safe, costs essentially <a id="_idIndexMarker162"/>nothing in most cases, and can be used in a <code>constexpr</code> context, which makes it amenable to compile-time maneuvers.</p>
<p>You can use <code>static_cast</code> in situations involving potential risks, such as converting an <code>int</code> to a <code>float</code> or vice versa. In the latter case, it explicitly acknowledges the loss of the decimal part. You can also use <code>static_cast</code> to cast a pointer or a reference from a derived class <a id="_idIndexMarker163"/>to one of its direct or indirect bases (as long as there’s no ambiguity), which is totally safe and could be done implicitly, as well as from a base to one of its derived classes. Casting from a base class to a derived class using <code>static_cast</code> is highly efficient but extremely risky if the cast is incorrect, as it does not perform runtime checks.</p>
<p>Here are some examples:</p>
<pre class="source-code">
struct B { virtual ~B() = default; /* ... */ };
struct D0 : B { /* ... */ };
struct D1 : B { /* ... */ };
class X {
public:
    X(int, double);
};
void f(D0&amp;);
void f(D1*);
int main() {
    const float x = 3.14159f;
    int n = static_cast&lt;int&gt;(x); // Ok, no warning
    X x0{ 3, 3.5 }; // Ok
    // compiles, probably warns (narrowing conversion)
    X x1(3.5,0);
    // does not compile, narrowing not allowed with braces
    // X x2{ 3.5, 0 };
    X x3{ static_cast&lt;int&gt;(x), 3 }; // Ok
    D0 d0;
    // illegal, no base-derived relationship with D0 and D1
    // D1* d1 = static_cast&lt;D1*&gt;(&amp;d0);
    // Ok, static_cast could be omitted
    B *b = static_cast&lt;B*&gt;(&amp;d0);
    // f(*b); // illegal
    f(*static_cast&lt;D0*&gt;(b)); // Ok
    f(static_cast&lt;D1*&gt;(b)); // compiles but very dangerous!
}</pre> <p>Pay special <a id="_idIndexMarker164"/>attention to the last use of <code>static_cast</code> of the preceding example – converting from a base class to one of its derived classes is appropriately <a id="_idIndexMarker165"/>done with <code>static_cast</code>. However, you must ensure that the conversion leads to an object of the chosen type, as there is no runtime verification made of the validity of that conversion; as the name implies, only compile-time checks are done with this cast. If you’re not sure of what you’re doing with a downcast, this is not the tool for you.</p>
<p><code>static_cast</code> does not only change the perspective of the compiler to the type of an expression; it also can adjust the memory address being accessed to take into account the types involved in the conversion. For example, when a <code>D</code> class has at least two non-empty base classes, <code>B0</code> and <code>B1</code>, these two parts of the derived class are not at the same address within a <code>D</code> object (if they were, they would overlap!), so <code>static_cast</code> from <code>D*</code> to one of its <a id="_idIndexMarker166"/>bases might yield a different address than that of <code>D*</code> itself. We will <a id="_idIndexMarker167"/>return to this when discussing <code>reinterpret_cast</code>, for which the behavior is different (and more dangerous).</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/>A sign something’s wrong – dynamic_cast</h2>
<p>There will be cases where you have a pointer or a reference to an object of some class type, and that <a id="_idIndexMarker168"/>type happens to be different from (but related to) the type needed. This often happens – for example, in game engines where most classes derive from some <code>Component</code> base and functions tend to take <code>Component*</code> arguments <a id="_idIndexMarker169"/>but need to access members from an object of the derived class they expect.</p>
<p>The main problem here is, typically, that the function’s interface is wrong – it accepts arguments of types that are insufficiently precise. Still, we all have software to deliver, and sometimes, we need to make things work even though we made some choices along the way that we will probably want to revisit later on.</p>
<p>The safe way to do such casts is <code>dynamic_cast</code>. This cast lets you convert a pointer or a reference from one type to another, related type in a way that lets you test whether the conversion worked or not; with pointers, an incorrect conversion yields <code>nullptr</code>, whereas with references, an incorrect conversion throws <code>std::bad_cast</code>. The relatedness of types with <code>dynamic_cast</code> is not limited to base-derived relationships and includes casting from one base to another base in a multiple inheritance design. However, note that, in most cases, <code>dynamic_cast</code> requires that the expression that is cast to another type is of the polymorphic type, in the sense that it must have at least one <code>virtual</code> member function.</p>
<p>Here are some examples:</p>
<pre class="source-code">
struct B0 {
    virtual int f() const = 0;
    virtual ~B0() = default;
};
struct B1 {
    virtual int g() const = 0;
    virtual ~B1() = default;
};
class D0 : public B0 {
    public: int f() const override { return 3; }
};
class D1 : public B1 {
    public: int g() const override { return 4; }
};
class D : public D0, public D1 {};
int f(D *p) {
    return p? p-&gt;f() + p-&gt;g() : -1; // Ok
}
// g has the wrong interface: it accepts a D0&amp; but
// tries to use it as a D1&amp;, which makes sense if
// the referred object is publicly D0 and D1 (for
// example, class D
int g(D0 &amp;d0) {
    D1 &amp;d1 = dynamic_cast&lt;D1&amp;&gt;(d0); // throws if wrong
    return d1.g();
}
#include &lt;iostream&gt;
int main() {
    D d;
    f(&amp;d); // Ok
    g(d); // Ok, a D is a D0
    D0 d0;
    // calls f(nullptr) as &amp;d0 does not point to a D
    std::cout &lt;&lt; f(dynamic_cast&lt;D*&gt;(&amp;d0)) &lt;&lt; '\n'; // -1
    try {
      g(d0); // compiles but will throw bad_cast
    } catch(std::bad_cast&amp;) {
      std::cerr &lt;&lt; "Nice try\n";
    }
}</pre> <p>Note that even though this example displays a message when <code>std::bad_cast</code> is thrown, this is in <a id="_idIndexMarker170"/>no way what we could call exception handling; we did not solve the “problem,” and code execution continues in a potentially corrupt state, which could <a id="_idIndexMarker171"/>make things worse in more serious code. In a toy example such as this, just letting code fail and stop executing would also have been a reasonable choice.</p>
<p>In practice, the use of <code>dynamic_cast</code> should be rare, as it tends to be a sign that we chose our function interfaces in a perfectible manner. Note that <code>dynamic_cast</code> requires binaries <a id="_idIndexMarker172"/>to be compiled with <strong class="bold">runtime type information</strong> (<strong class="bold">RTTI</strong>) included, leading to larger binaries. Unsurprisingly, due to these costs, some application domains will tend to avoid this cast, and so will we.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/>Playing tricks with safety – const_cast</h2>
<p>Neither <code>static_cast</code> nor <code>dynamic_cast</code> (nor <code>reinterpret_cast</code>, for that matter) can change <a id="_idIndexMarker173"/>the cv-qualifiers of an expression; to do this, you <a id="_idIndexMarker174"/>need <code>const_cast</code>. With <code>const_cast</code>, you can add or remove the <code>const</code> or <code>volatile</code> qualifiers from an expression. As you might have guessed, this only makes sense on a pointer or on a reference.</p>
<p>Why would you do something such as remove <code>const</code>-ness from an expression? Surprisingly, there are many situations where this comes in handy, but a common one is allowing the <a id="_idIndexMarker175"/>use of a <code>const</code>-correct type in a setting where <code>const</code>-ness was not <a id="_idIndexMarker176"/>used appropriately – for example, legacy code that did not use <code>const</code>, such as the following:</p>
<pre class="source-code">
#include &lt;vector&gt;
struct ResourceHandle { /* ... */ };
// this function observes a resource without modifying it,
// but the type system is not aware of that fact (the
// argument is not const)
void observe_resource(ResourceHandle*);
class ResourceManager {
    std::vector&lt;ResourceHandle *&gt; resources;
    // ...
public:
    // note: const member function
    void observe_resources() const {
      // we want to observe each resource, for example
      // to collect data
      for(const ResourceHandle * h : resources) {
       // does not compile, h is const
       // observe_resource(h);
      // temporarily dismiss constness
          observe_resource(const_cast&lt;ResourceHandle*&gt;(h));
      }
    }
    // ...
};</pre> <p><code>const_cast</code> is a tool to <a id="_idIndexMarker177"/>play with the security of the type system; it should <a id="_idIndexMarker178"/>be used in specific, controlled situations and not to do unreasonable things such as changing the value of a mathematical constant, such as pi. If try something <a id="_idIndexMarker179"/>like that, you’ll incur <strong class="bold">Undefined Behavior</strong> (<strong class="bold">UB</strong>) – and rightfully so.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/>“Believe me, compiler” – reinterpret_cast</h2>
<p>Sometimes, you just have to make the compiler believe you. For example, knowing <code>sizeof(int)==4</code> on your platform, you might want to treat <code>int</code> as <code>char[4]</code> to interoperate <a id="_idIndexMarker180"/>with an existing API that expects that type. Note that you should ensure that this property holds (maybe through <code>static_assert</code>), rather than <a id="_idIndexMarker181"/>relying on the belief that this property holds on all platforms (it does not).</p>
<p>That’s what <code>reinterpret_cast</code> gives you – the ability to cast a pointer of some type to a pointer of an unrelated type. This can be used in situations where you seek to benefit from pointer-interconvertibility, as we saw in <a href="B21071_02.xhtml#_idTextAnchor027"><em class="italic">Chapter 2</em></a>, just as this can be used to lie to the type system in several rather dangerous and non-portable ways.</p>
<p>Take the aforementioned conversion from an integer to an array of four bytes – if the aim is to facilitate addressing individual bytes, you have to be aware that the endianness of integers depends on the platform, as well as that the code written will probably be non-portable unless some careful measures are taken.</p>
<p>Also, note that <code>reinterpret_cast</code> only changes the type associated with an expression – for example, it does not perform the slight address adjustments that <code>static_cast</code> would make when converting from a derived class to a base class in multiple inheritance situations.</p>
<p>The following example shows the difference between these two casts:</p>
<pre class="source-code">
struct B0 { int n = 3; };
struct B1 { float f = 3.5f; };
// B0 is the first base subobject of D
class D : public B0, public B1 { };
int main() {
    D d;
    // b0 and &amp;d point to the same address
    // b1 and &amp;d do not point to the same address
    B0 *b0 = static_cast&lt;B0*&gt;(&amp;d);
    B1 *b1 = static_cast&lt;B1*&gt;(&amp;d);
    int n0 = b0-&gt;n; // Ok
    float f0 = b1-&gt;f; // Ok
    // r0 and &amp;d point to the same address
    // r1 and &amp;d also point to the same address... oops!
    B0 *r0 = reinterpret_cast&lt;B0*&gt;(&amp;d); // fragile
    B1 *r1 = reinterpret_cast&lt;B1*&gt;(&amp;d); // bad idea
    int nr0 = r0-&gt;n; // Ok but fragile
    float fr0 = r1-&gt;f; // UB
}</pre> <p>Use <code>reinterpret_cast</code> sparingly. Relatively safe uses include converting a pointer to an integral <a id="_idIndexMarker182"/>representation when given a sufficiently wide integral type (and vice versa), converting between null pointers of different types, and converting <a id="_idIndexMarker183"/>between function pointer types – although in that case, the results of calling the function through the resulting pointer are undefined. The complete list of conversions that can be performed with this cast can be found at <a href="http://wg21.link/expr.reinterpret.cast">wg21.link/expr.reinterpret.cast</a> if you want to know more.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>I know the bits are right – bit_cast</h2>
<p>C++20 <a id="_idIndexMarker184"/>introduced <code>bit_cast</code>, a new cast that can be used to copy bits from one object <a id="_idIndexMarker185"/>to another of the same width, starting the lifetime of the destination object (and the objects enclosed therein, if any) along the way, as long as both the source and destination types are trivially copyable. This somewhat magical library function can be found in the <code>&lt;bit&gt;</code> header and is <code>constexpr</code>.</p>
<p>Here’s an example:</p>
<pre class="source-code">
#include &lt;bit&gt;
struct A { int a; double b; };
struct B { unsigned int c; double d; };
int main() {
    constexpr A a{ 3, 3.5 }; // ok
    constexpr B b = std::bit_cast&lt;B&gt;(a); // Ok
    static_assert(a.a == b.c &amp;&amp; a.b == b.d); // Ok
    static_assert((void*)&amp;a != (void*)&amp;b); // Ok
}</pre> <p>As can be seen <a id="_idIndexMarker186"/>in this example, both <code>A</code> and <code>B</code> are constructed at compile time and are bitwise identical to one another, but their addresses are different, as they are <a id="_idIndexMarker187"/>entirely different objects. Their data members are partially of different types but are of the same sizes, in the same order, and are all trivially copyable.</p>
<p>Also, note the use of a C-style cast on the last line of this example. As we will soon discuss, this is one of the few reasonable uses of C-style casts (we could have used <code>static_cast</code> here too and it would have been just as efficient).</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/>Somewhat unrelated, but still – duration_cast</h2>
<p>We won’t <a id="_idIndexMarker188"/>dwell too long on <code>duration_cast</code>, as it is only tangentially related <a id="_idIndexMarker189"/>to our topic of interest, but since it will be part of our toolset for micro-benchmarking in this book, it at least deserves a mention.</p>
<p>The <code>duration_cast</code> library function can be found in the <code>&lt;chrono&gt;</code> header and is part of the <code>std::chrono</code> namespace. It is <code>constexpr</code> and can be used to convert between expressions of different measurement units.</p>
<p>For example, suppose that we want to measure the time it took to execute some function, <code>f()</code>, using the <code>system_clock</code> provided by our library vendor. We can read that clock using its <code>now()</code> static member function before and after calling <code>f()</code>, which gives us two <code>time_point</code> objects for that clock (two moments in time), and then compute the difference between them to get a <code>duration</code> for that clock. We do not know what <a id="_idIndexMarker190"/>measurement unit was used to represent that duration, but if we <a id="_idIndexMarker191"/>want to use it expressed as, say, <code>microseconds</code>, we use <code>duration_cast</code> to perform than conversion:</p>
<pre class="source-code">
#include &lt;chrono&gt;
#include &lt;iostream&gt;
int f() { /* ... */ }
int main() {
    using std::cout;
    using namespace std::chrono;
    auto pre = system_clock::now();
    int res = f();
    auto post = system_clock::now();
    cout &lt;&lt; "Computed " &lt;&lt; res &lt;&lt; " in "
        &lt;&lt; duration_cast&lt;microseconds&gt;(post - pre);
}</pre> <p>We will systematize our benchmarking practices later in this book, showing a more formal way to measure the execution time of functions or code blocks, but <code>duration_cast</code> will be our tool of choice to ensure that the format in which we present the results is appropriate for our needs.</p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/>The reviled one – the C cast</h2>
<p>You might be tempted to use C-style casts when type conversions are needed, as the C syntax appears <a id="_idIndexMarker192"/>in other languages and tends to be short to express – <code>(T)expr</code> treats expression, <code>expr</code>, as being of type <code>T</code>. That terseness is actually a downside, not an upside, as we will see. Limit C-style casts to a minimum in C++ code:</p>
<ul>
<li>The C-style casts <a id="_idIndexMarker193"/>are harder to find when performing an automated search through source code text, since they look like arguments in a function call. Since casts are ways through which we lie to the type system, revisiting the decision to use them from time to time is worthwhile, so being able to find them is valuable. In comparison, the C++ casts are keywords, which makes them easier to find.</li>
<li>A C-style cast does not convey information about why a conversion occurred. When writing <code>(T)expr</code>, we are not saying whether we want to change cv-qualifiers, navigate a class hierarchy, simply change to type of a pointer, and so on. In particular, when converting between pointers to different types, a C-style cast will generally behave as <code>reinterpret_cast</code>, which, as we have seen, can lead to disastrous results in some circumstances.</li>
</ul>
<p>You will sometimes see C-style casts in C++ code, mostly for situations where the intent is absolutely clear. We saw an example at the end of our <code>bit_cast</code> section. Another example would be to silence compiler warnings – for example, when calling a function that’s <code>[[nodiscard]]</code> but still really wanting to discard the results nonetheless for some reason.</p>
<p>In yet another example, consider the following generic function:</p>
<pre class="source-code">
template &lt;class ItA, class ItB&gt;
    bool all_equal(ItA bA, ItA eA, ItB bB, ItB eB) {
      for(; bA != eA &amp;&amp; bB != eB; ++bA, <strong class="bold">(void)</strong> ++bB)
          if (*bA != bB)
            return false;
      return true;
    }</pre> <p>This function iterates through two sequences that are delimited, respectively, by <code>[bA,eA)</code> and <code>[bB,eB)</code> (making sure to stop as soon as the shortest sequence has been processed), compares the elements at the “same position” in these two sequences, and yields <code>true</code> only if all comparisons between elements of those two sequences are equal.</p>
<p>Note that the cast to <code>void</code> uses a C-style cast between the increments of <code>bA</code> and <code>bB</code> in this code, which cast <a id="_idIndexMarker194"/>the result of <code>++bB</code> to <code>void</code>. This may look strange, but this <a id="_idIndexMarker195"/>is code that can be used in many situations by pretty much anyone, including hostile (or distracted) users. Suppose someone with a twisted mind had decided to overload the comma operator (yes, you can do that) between the types of <code>operator++(ItA)</code> and <code>operator++(ItB)</code>. That person could then essentially hijack our function to run unexpected code. By casting one of the arguments to <code>void</code>, we ensure that this is not possible.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/>Summary</h1>
<p>That concludes our quick overview of casts and cv-qualifications in C++. Now that we’ve seen some ways to trick the type system and get in trouble, as well as know why we should do these things carefully (if at all), we can start building beautiful things with C++ and work toward safe, efficient abstractions in our endeavor to write correct programs that control how we manage memory.</p>
<p>In the next chapter, we will start by using one of the language’s defining features, the destructor, to automate the way our code handles resources, with an eye in particular on the way memory is handled.</p>
</div>


<div><h1 id="_idParaDest-61" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor061"/>Part 2: Implicit Memory Management Techniques</h1>
<p>In this part, we will examine some well-known approaches to implicit resource management (including memory management) in C++. These are all techniques you can use in your daily programming practices that will lead to simpler and safer programs than what you would get if you wanted to manage memory explicitly. You could say that the chapters in this part concern what people call “modern” or “contemporary” C++.</p>
<p>This part has the following chapters:</p>
<ul>
<li><a href="B21071_04.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a>, <em class="italic">Using Destructors</em></li>
<li><a href="B21071_05.xhtml#_idTextAnchor079"><em class="italic">Chapter 5</em></a>, <em class="italic">Using Standard Smart Pointers</em></li>
<li><a href="B21071_06.xhtml#_idTextAnchor096"><em class="italic">Chapter 6</em></a>, <em class="italic">Writing Smart Pointers</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</body></html>