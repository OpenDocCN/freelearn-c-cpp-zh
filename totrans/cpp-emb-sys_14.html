<html><head></head><body>
<div id="_idContainer066">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 class="chapterTitle" id="_idParaDest-157"><span class="koboSpan" id="kobo.2.1">Compile-Time Computation</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.3.1">Compile-time computation</span></strong><span class="koboSpan" id="kobo.4.1"> refers </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.5.1">to the ability of a compiler to execute functions at compile time, instead of converting them to machine code. </span><span class="koboSpan" id="kobo.5.2">This means that the results of complex operations can be calculated by the compiler and stored in variables that are used at runtime. </span><span class="koboSpan" id="kobo.5.3">A compiler can execute a function at compile time only if all arguments of the function are known at compile time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.6.1">We can use compile-time computation in C++ firmware to calculate complex math operations, generate lookup tables and arrays in general, and use the generated values at runtime. </span><span class="koboSpan" id="kobo.6.2">Performing these operations at compile time will save valuable memory and processor (space and time) resources and make them available for other, more important operations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.7.1">The goal of this chapter is to learn how to use compile-time computation in C++ to shift complex operations at compile time and save valuable resources. </span><span class="koboSpan" id="kobo.7.2">In this chapter, we’re going to cover the following main topics: </span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Templates</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.10.1">constexpr</span></code><span class="koboSpan" id="kobo.11.1"> specifier</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">The consteval specifier</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-158"><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.14.1">To get the most out of this chapter, I strongly recommend using Compiler Explorer (</span><a href="https://godbolt.org/"><span class="url"><span class="koboSpan" id="kobo.15.1">https://godbolt.org/</span></span></a><span class="koboSpan" id="kobo.16.1">) as you read through the examples. </span><span class="koboSpan" id="kobo.16.2">Select GCC as your compiler for x86 architecture. </span><span class="koboSpan" id="kobo.16.3">This will allow you to see standard output (stdio) results and better observe the code’s behavior. </span><span class="koboSpan" id="kobo.16.4">As we are using a lot of modern C++ features, make sure to select the C++23 standard by adding </span><code class="inlineCode"><span class="koboSpan" id="kobo.17.1">-std=c++23</span></code><span class="koboSpan" id="kobo.18.1"> to the compiler options box.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.19.1">Compiler Explorer makes it easy to try out the code, tweak it, and immediately see how it affects the output and generated assembly code. </span><span class="koboSpan" id="kobo.19.2">Most of the examples can also be run in the Renode simulator on an ARM Cortex-M0 target and are available on GitHub (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter11"><span class="url"><span class="koboSpan" id="kobo.20.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter11</span></span></a><span class="koboSpan" id="kobo.21.1">).</span></p>
<h1 class="heading-1" id="_idParaDest-159"><span class="koboSpan" id="kobo.22.1">Templates</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.23.1">The first available mechanism </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.24.1">for compile-time computation in C++ was </span><strong class="keyWord"><span class="koboSpan" id="kobo.25.1">Template Meta-Programming (TMP)</span></strong><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">Using TMP, we</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.27.1"> can store the results of operations in types, as shown in the following example of computing the factorial:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.28.1">template</span></span><span class="koboSpan" id="kobo.29.1"> &lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.30.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.31.1">int</span></span><span class="koboSpan" id="kobo.32.1"> N&gt;
</span><code class="inlineCode"><span class="koboSpan" id="kobo.33.1">struct</span></code> <span class="hljs-title"><span class="koboSpan" id="kobo.34.1">factorial</span></span><span class="koboSpan" id="kobo.35.1"> {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.36.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.37.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.38.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.39.1">int</span></span><span class="koboSpan" id="kobo.40.1"> value = N * factorial&lt;N</span><span class="hljs-number"><span class="koboSpan" id="kobo.41.1">-1</span></span><span class="koboSpan" id="kobo.42.1">&gt;::value;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.43.1">template</span></span><span class="koboSpan" id="kobo.44.1"> &lt;&gt;
</span><code class="inlineCode"><span class="koboSpan" id="kobo.45.1">struct</span></code> <span class="hljs-title"><span class="koboSpan" id="kobo.46.1">factorial</span></span><span class="koboSpan" id="kobo.47.1">&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.48.1">0</span></span><span class="koboSpan" id="kobo.49.1">&gt; {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.50.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.51.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.52.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.53.1">int</span></span><span class="koboSpan" id="kobo.54.1"> value = </span><span class="hljs-number"><span class="koboSpan" id="kobo.55.1">1</span></span><span class="koboSpan" id="kobo.56.1">;
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.57.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.58.1">main</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.59.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.60.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.61.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.62.1">int</span></span><span class="koboSpan" id="kobo.63.1"> fact = factorial&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.64.1">5</span></span><span class="koboSpan" id="kobo.65.1">&gt;::value;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.66.1">return</span></span><span class="koboSpan" id="kobo.67.1"> fact;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.68.1">If you run this </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.69.1">example in Compiler Explorer (even without optimizations), you will see that it returns 120. </span><span class="koboSpan" id="kobo.69.2">The generated assembly code is short and does not contain any function calls. </span><span class="koboSpan" id="kobo.69.3">It simply places the value 120 in the return register in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.70.1">main</span></code><span class="koboSpan" id="kobo.71.1"> function, meaning the factorial computation was done at compile time. </span><span class="koboSpan" id="kobo.71.2">You can see the generated assembly code here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-symbol"><span class="koboSpan" id="kobo.72.1">main:</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.73.1">push</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.74.1">rbp</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.75.1">mov</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.76.1">rbp</span></span><span class="koboSpan" id="kobo.77.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.78.1">rsp</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.79.1">mov</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.80.1">DWORD</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.81.1">PTR</span></span><span class="koboSpan" id="kobo.82.1"> [</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.83.1">rbp</span></span><span class="koboSpan" id="kobo.84.1">-</span><span class="hljs-number"><span class="koboSpan" id="kobo.85.1">4</span></span><span class="koboSpan" id="kobo.86.1">], </span><span class="hljs-number"><span class="koboSpan" id="kobo.87.1">120</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.88.1">mov</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.89.1">eax</span></span><span class="koboSpan" id="kobo.90.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.91.1">120</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.92.1">pop</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.93.1">rbp</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.94.1">ret</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.95.1">We performed the following steps in the preceding example:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.96.1">We defined a class template factorial. </span><span class="koboSpan" id="kobo.96.2">It has an unsigned int, N, as the parameter and only one member: </span><code class="inlineCode"><span class="koboSpan" id="kobo.97.1">static const unsigned int value = N * factorial&lt;N-1&gt;::value</span></code><span class="koboSpan" id="kobo.98.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.99.1">In the assignment expression of the member </span><code class="inlineCode"><span class="koboSpan" id="kobo.100.1">value</span></code><span class="koboSpan" id="kobo.101.1">, we use recursion at the template level as we calculate it by multiplying </span><code class="inlineCode"><span class="koboSpan" id="kobo.102.1">N</span></code><span class="koboSpan" id="kobo.103.1"> by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.104.1">value</span></code><span class="koboSpan" id="kobo.105.1"> from the factorial instantiated with </span><code class="inlineCode"><span class="koboSpan" id="kobo.106.1">N – 1</span></code><span class="koboSpan" id="kobo.107.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.108.1">We define factorial template specialization for 0, making it a base type that will stop recursion, meaning that </span><code class="inlineCode"><span class="koboSpan" id="kobo.109.1">factorial&lt;0&gt;::value</span></code><span class="koboSpan" id="kobo.110.1"> will contain </span><code class="inlineCode"><span class="koboSpan" id="kobo.111.1">1</span></code><span class="koboSpan" id="kobo.112.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.113.1">To better understand the recursion at the template level, we will write down the entire recursion chain for the preceding example:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.114.1">factorial&lt;5&gt;::value = 5 * factorial&lt;4&gt;::value;</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.115.1">factorial&lt;4&gt;::value = 4 * factorial&lt;3&gt;::value;</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.116.1">factorial&lt;3&gt;::value = 3 * factorial&lt;2&gt;::value;</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.117.1">factorial&lt;2&gt;::value = 2 * factorial&lt;1&gt;::value;</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.118.1">factorial&lt;1&gt;::value = 1 * factorial&lt;0&gt;::value;</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.119.1">factorial&lt;0&gt;::value = 1;</span></code></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.120.1">If we substitute the base value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.121.1">factorial&lt;0&gt;</span></code><span class="koboSpan" id="kobo.122.1"> with </span><code class="inlineCode"><span class="koboSpan" id="kobo.123.1">1</span></code><span class="koboSpan" id="kobo.124.1">, back up the chain, we have the following:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.125.1">factorial&lt;1&gt;::value = 1 * 1 = 1</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.126.1">factorial&lt;2&gt;::value = 2 * 1 = 2</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.127.1">factorial&lt;3&gt;::value = 3 * 2 = 6</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.128.1">factorial&lt;4&gt;::value = 4 * 6 = 24</span></code></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.129.1">factorial&lt;5&gt;::value = 5 * 24 = 120</span></code></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.130.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.131.1">main</span></code><span class="koboSpan" id="kobo.132.1"> function </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.133.1">computes the factorial of </span><code class="inlineCode"><span class="koboSpan" id="kobo.134.1">5</span></code><span class="koboSpan" id="kobo.135.1"> by accessing </span><code class="inlineCode"><span class="koboSpan" id="kobo.136.1">factorial&lt;5&gt;::value</span></code><span class="koboSpan" id="kobo.137.1"> and returns it. </span><span class="koboSpan" id="kobo.137.2">The recursion is terminated by the specialized template for </span><code class="inlineCode"><span class="koboSpan" id="kobo.138.1">factorial&lt;0&gt;</span></code><span class="koboSpan" id="kobo.139.1">, which provides the base case. </span><span class="koboSpan" id="kobo.139.2">The final result is that the program returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.140.1">120</span></code><span class="koboSpan" id="kobo.141.1">, the factorial of </span><code class="inlineCode"><span class="koboSpan" id="kobo.142.1">5</span></code><span class="koboSpan" id="kobo.143.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.144.1">While TMP allows for compile-time computations, it often involves complex recursive patterns that can be difficult to read and maintain. </span><span class="koboSpan" id="kobo.144.2">To address these challenges, C++11 introduced the </span><code class="inlineCode"><span class="koboSpan" id="kobo.145.1">constexpr</span></code><span class="koboSpan" id="kobo.146.1"> specifier, which has become the preferred mechanism for compile-time computations.</span></p>
<h1 class="heading-1" id="_idParaDest-160"><span class="koboSpan" id="kobo.147.1">constexpr specifier</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.148.1">Using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.149.1">constexpr</span></code><strong class="keyWord"><span class="koboSpan" id="kobo.150.1"> specifier</span></strong><span class="koboSpan" id="kobo.151.1">, we </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.152.1">declare that it is possible to evaluate variables and functions at compile time. </span><span class="koboSpan" id="kobo.152.2">There are limitations to what can be evaluated at compile time. </span><span class="koboSpan" id="kobo.152.3">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.153.1">constexpr</span></code><span class="koboSpan" id="kobo.154.1"> variable must meet the following requirements:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.155.1">It needs to be of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.156.1">literal</span></code><span class="koboSpan" id="kobo.157.1"> type, any of the following:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.158.1">Scalar types such as arithmetic types, enumerations, and pointers</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.159.1">Reference types</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.160.1">An array of </span><code class="inlineCode"><span class="koboSpan" id="kobo.161.1">literal</span></code><span class="koboSpan" id="kobo.162.1"> types</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.163.1">Classes that meet specific requirements (such as a trivial </span><code class="inlineCode"><span class="koboSpan" id="kobo.164.1">constexpr</span></code><span class="koboSpan" id="kobo.165.1"> de</span><code class="inlineCode"><span class="koboSpan" id="kobo.166.1">struct</span></code><span class="koboSpan" id="kobo.167.1">or, all of its non-static data members are </span><code class="inlineCode"><span class="koboSpan" id="kobo.168.1">literal</span></code><span class="koboSpan" id="kobo.169.1"> types, or at least one </span><code class="inlineCode"><span class="koboSpan" id="kobo.170.1">constexpr</span></code><span class="koboSpan" id="kobo.171.1"> con</span><code class="inlineCode"><span class="koboSpan" id="kobo.172.1">struct</span></code><span class="koboSpan" id="kobo.173.1">or).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.174.1">It must be immediately initialized.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.175.1">The entire expression of its initialization needs to be a constant expression.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.176.1">Let’s go through the following example to better understand the requirements for </span><code class="inlineCode"><span class="koboSpan" id="kobo.177.1">constexpr</span></code><span class="koboSpan" id="kobo.178.1"> variables:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.179.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.180.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.181.1">&lt;cmath&gt;</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.182.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.183.1">main</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.184.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.185.1">{
    </span><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">constexpr</span></code> <span class="hljs-type"><span class="koboSpan" id="kobo.187.1">int</span></span><span class="koboSpan" id="kobo.188.1"> ret = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.189.1">round</span></span><span class="koboSpan" id="kobo.190.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.191.1">sin</span></span><span class="koboSpan" id="kobo.192.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.193.1">3.14</span></span><span class="koboSpan" id="kobo.194.1">));
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.195.1">return</span></span><span class="koboSpan" id="kobo.196.1"> ret;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.197.1">If you run this example in Compiler Explorer using </span><code class="inlineCode"><span class="koboSpan" id="kobo.198.1">x86-64 GCC 14.2</span></code><span class="koboSpan" id="kobo.199.1"> compiler, without optimization enabled, we can observe the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.200.1">The program returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">0</span></code><span class="koboSpan" id="kobo.202.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.203.1">The resulting assembly is small, and it just moves </span><code class="inlineCode"><span class="koboSpan" id="kobo.204.1">0</span></code><span class="koboSpan" id="kobo.205.1"> to return the register.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.206.1">If you change the initialization of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.207.1">ret</span></code><span class="koboSpan" id="kobo.208.1"> variable so that the sine function takes </span><code class="inlineCode"><span class="koboSpan" id="kobo.209.1">3.14/2</span></code><span class="koboSpan" id="kobo.210.1"> as the argument, the program will return </span><code class="inlineCode"><span class="koboSpan" id="kobo.211.1">1</span></code><span class="koboSpan" id="kobo.212.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.213.1">Now, if we try to change the compiler in Compiler Explorer to </span><code class="inlineCode"><span class="koboSpan" id="kobo.214.1">x86-64 clang 18.1.0</span></code><span class="koboSpan" id="kobo.215.1">, we will get the following compiler error:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.216.1">&lt;source&gt;:4:19: error: constexpr variable 'ret' must be initialized by a constant expression
    4 |     constexpr int ret = round(sin(3.14));
      |                   ^     ~~~~~~~~~~~~~~~~
&lt;source&gt;:4:31: note: non-constexpr function 'sin' cannot be used in a constant expression
    4 |     constexpr int ret = round(sin(3.14));
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.217.1">The compiler reports that we are violating the rule that says that the entire expression of its initialization needs to be a constant expression, as the function </span><code class="inlineCode"><span class="koboSpan" id="kobo.218.1">sin,</span></code><span class="koboSpan" id="kobo.219.1"> in the expression </span><code class="inlineCode"><span class="koboSpan" id="kobo.220.1">round(sin(3.14))</span></code><span class="koboSpan" id="kobo.221.1">, is non-</span><code class="inlineCode"><span class="koboSpan" id="kobo.222.1">constexpr</span></code><span class="koboSpan" id="kobo.223.1">. </span><span class="koboSpan" id="kobo.223.2">This is because Clang’s implementation of math functions is non-</span><code class="inlineCode"><span class="koboSpan" id="kobo.224.1">constexpr</span></code><span class="koboSpan" id="kobo.225.1">, while GCC implements them as </span><code class="inlineCode"><span class="koboSpan" id="kobo.226.1">constexpr</span></code><span class="koboSpan" id="kobo.227.1"> functions. </span><span class="koboSpan" id="kobo.227.2">Many math functions will be </span><code class="inlineCode"><span class="koboSpan" id="kobo.228.1">constexpr</span></code><span class="koboSpan" id="kobo.229.1"> functions in the new C++26 standard.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.230.1">Although the upcoming C++26 standard mandates that math functions should be </span><code class="inlineCode"><span class="koboSpan" id="kobo.231.1">constexpr</span></code><span class="koboSpan" id="kobo.232.1">, we will utilize the current GCC implementation because it is the compiler we are using for our STM32 target in the examples throughout this book. </span><span class="koboSpan" id="kobo.232.2">All </span><code class="inlineCode"><span class="koboSpan" id="kobo.233.1">constexpr</span></code><span class="koboSpan" id="kobo.234.1"> functions must meet the following </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.235.1">requirements:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.236.1">Its </span><code class="inlineCode"><span class="koboSpan" id="kobo.237.1">return</span></code><span class="koboSpan" id="kobo.238.1"> type must be of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.239.1">literal</span></code><span class="koboSpan" id="kobo.240.1"> type.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.241.1">Each of its parameters must be of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.242.1">literal</span></code><span class="koboSpan" id="kobo.243.1"> type.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.244.1">If a function is not a con</span><code class="inlineCode"><span class="koboSpan" id="kobo.245.1">struct</span></code><span class="koboSpan" id="kobo.246.1">or, it must have only one </span><code class="inlineCode"><span class="koboSpan" id="kobo.247.1">return</span></code><span class="koboSpan" id="kobo.248.1"> statement.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.249.1">To better understand </span><code class="inlineCode"><span class="koboSpan" id="kobo.250.1">constexpr</span></code><span class="koboSpan" id="kobo.251.1"> functions, let us implement the factorial algorithm as a </span><code class="inlineCode"><span class="koboSpan" id="kobo.252.1">constexpr</span></code><span class="koboSpan" id="kobo.253.1"> function in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.254.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.255.1">unsigned</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.256.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.257.1">factorial</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.258.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.259.1">unsigned</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.260.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.261.1"> n)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.262.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.263.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.264.1">int</span></span><span class="koboSpan" id="kobo.265.1"> prod = </span><span class="hljs-number"><span class="koboSpan" id="kobo.266.1">1</span></span><span class="koboSpan" id="kobo.267.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.268.1">while</span></span><span class="koboSpan" id="kobo.269.1">(n &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.270.1">0</span></span><span class="koboSpan" id="kobo.271.1">) {
        prod *= n;
        n--;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.272.1">return</span></span><span class="koboSpan" id="kobo.273.1"> prod;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.274.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.275.1">main</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.276.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.277.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.278.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.279.1">int</span></span><span class="koboSpan" id="kobo.280.1"> calc_val = </span><span class="hljs-number"><span class="koboSpan" id="kobo.281.1">5</span></span><span class="koboSpan" id="kobo.282.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.283.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.284.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.285.1">int</span></span><span class="koboSpan" id="kobo.286.1"> ret = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.287.1">factorial</span></span><span class="koboSpan" id="kobo.288.1">(calc_val);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.289.1">return</span></span><span class="koboSpan" id="kobo.290.1"> ret;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.291.1">In this example, we</span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.292.1"> implemented the </span><code class="inlineCode"><span class="koboSpan" id="kobo.293.1">factorial</span></code><span class="koboSpan" id="kobo.294.1"> algorithm as a simple </span><code class="inlineCode"><span class="koboSpan" id="kobo.295.1">constexpr</span></code><span class="koboSpan" id="kobo.296.1"> function. </span><span class="koboSpan" id="kobo.296.2">Comparing it to a TMP-based solution, this code looks familiar to many developers with a C background. </span><span class="koboSpan" id="kobo.296.3">There is no recursion at the template level and strange syntax. </span><span class="koboSpan" id="kobo.296.4">C++11 </span><code class="inlineCode"><span class="koboSpan" id="kobo.297.1">constexpr</span></code><span class="koboSpan" id="kobo.298.1"> functions still relied on recursion, but C++14 relaxed constraints on </span><code class="inlineCode"><span class="koboSpan" id="kobo.299.1">constexpr</span></code><span class="koboSpan" id="kobo.300.1"> functions and allowed using local variables and loops.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.301.1">If we run the preceding example in Compiler Explorer using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.302.1">x86-64 GCC 14.2</span></code><span class="koboSpan" id="kobo.303.1"> compiler, without optimization enabled, we can observe the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.304.1">The program returns 120.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.305.1">The resulting assembly is small, and it just moves 120 to the return register.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.306.1">There is no </span><code class="inlineCode"><span class="koboSpan" id="kobo.307.1">factorial</span></code><span class="koboSpan" id="kobo.308.1"> function in the resulting assembly code, meaning that the compiler executed this function at compile time. </span><span class="koboSpan" id="kobo.308.2">We supplied a factorial function with a constant expression argument and the compiler evaluated the function at compile time.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.309.1">If we remove the </span><code class="inlineCode"><span class="koboSpan" id="kobo.310.1">constexpr</span></code><span class="koboSpan" id="kobo.311.1"> specifier from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.312.1">calc_val</span></code><span class="koboSpan" id="kobo.313.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.314.1">ret</span></code><span class="koboSpan" id="kobo.315.1"> variables declarations, we will see the </span><code class="inlineCode"><span class="koboSpan" id="kobo.316.1">factorial</span></code><span class="koboSpan" id="kobo.317.1"> function in the resulting assembly call, and in </span><code class="inlineCode"><span class="koboSpan" id="kobo.318.1">main</span></code><span class="koboSpan" id="kobo.319.1">, we will see a call to this function, meaning that in this case, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.320.1">factorial</span></code><span class="koboSpan" id="kobo.321.1"> function is being executed at runtime, and in the case of firmware, it will be part of</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.322.1"> the binary.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.323.1">As we can see from this example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.324.1">constexpr</span></code><span class="koboSpan" id="kobo.325.1"> function can be executed at both compile time and runtime, depending on the arguments we supply it with. </span><span class="koboSpan" id="kobo.325.2">Next, we will go over practical examples to see how we can apply the </span><code class="inlineCode"><span class="koboSpan" id="kobo.326.1">constexpr</span></code><span class="koboSpan" id="kobo.327.1"> specifier in firmware development.</span></p>
<h2 class="heading-2" id="_idParaDest-161"><span class="koboSpan" id="kobo.328.1">Example 1 – MAC address parser</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.329.1">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.330.1">Medium Access Control</span></strong><span class="koboSpan" id="kobo.331.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.332.1">MAC</span></strong><span class="koboSpan" id="kobo.333.1">) address</span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.334.1"> is used in the MAC layer of different communication stacks, including Ethernet, Wi-Fi, and Bluetooth. </span><span class="koboSpan" id="kobo.334.2">Here, we will create a 48-bit MAC address compile-time parser that will help us convert a common format of a MAC address written as hex numbers separated by a colon into an array of </span><code class="inlineCode"><span class="koboSpan" id="kobo.335.1">uint8_t</span></code><span class="koboSpan" id="kobo.336.1">, which is usually used in software stacks. </span><span class="koboSpan" id="kobo.336.2">The code is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.337.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.338.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.339.1">&lt;array&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.340.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.341.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.342.1">&lt;cstdint&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.343.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.344.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.345.1">&lt;string_view&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.346.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.347.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.348.1">&lt;charconv&gt;</span></span>
<code class="inlineCode"><span class="koboSpan" id="kobo.349.1">struct</span></code> <span class="hljs-title"><span class="koboSpan" id="kobo.350.1">mac_address</span></span><span class="koboSpan" id="kobo.351.1"> {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.352.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.353.1">constexpr</span></span><span class="koboSpan" id="kobo.354.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.355.1">size_t</span></span><span class="koboSpan" id="kobo.356.1"> c_bytes_num = </span><span class="hljs-number"><span class="koboSpan" id="kobo.357.1">6</span></span><span class="koboSpan" id="kobo.358.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.359.1">static</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.360.1">constexpr</span></span><span class="koboSpan" id="kobo.361.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.362.1">size_t</span></span><span class="koboSpan" id="kobo.363.1"> c_mac_addr_str_size = </span><span class="hljs-number"><span class="koboSpan" id="kobo.364.1">17</span></span><span class="koboSpan" id="kobo.365.1">;
   
    std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.366.1">uint8_t</span></span><span class="koboSpan" id="kobo.367.1">, c_bytes_num&gt; bytes{};
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.368.1">bool</span></span><span class="koboSpan" id="kobo.369.1"> is_valid = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.370.1">false</span></span><span class="koboSpan" id="kobo.371.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.372.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.373.1">mac_address</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.374.1">(std::string_view str)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.375.1">{
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.376.1">if</span></span><span class="koboSpan" id="kobo.377.1"> (str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.378.1">size</span></span><span class="koboSpan" id="kobo.379.1">() != c_mac_addr_str_size) {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.380.1">return</span></span><span class="koboSpan" id="kobo.381.1">;
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.382.1">for</span></span><span class="koboSpan" id="kobo.383.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.384.1">size_t</span></span><span class="koboSpan" id="kobo.385.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.386.1">0</span></span><span class="koboSpan" id="kobo.387.1">; i &lt; c_bytes_num; ++i) {
            </span><span class="hljs-type"><span class="koboSpan" id="kobo.388.1">const</span></span><span class="koboSpan" id="kobo.389.1"> std::string_view byte_str = str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.390.1">substr</span></span><span class="koboSpan" id="kobo.391.1">(i * </span><span class="hljs-number"><span class="koboSpan" id="kobo.392.1">3</span></span><span class="koboSpan" id="kobo.393.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.394.1">2</span></span><span class="koboSpan" id="kobo.395.1">);
            </span><span class="hljs-type"><span class="koboSpan" id="kobo.396.1">uint8_t</span></span><span class="koboSpan" id="kobo.397.1"> value = </span><span class="hljs-number"><span class="koboSpan" id="kobo.398.1">0</span></span><span class="koboSpan" id="kobo.399.1">;
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.400.1">auto</span></span><span class="koboSpan" id="kobo.401.1"> result = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.402.1">from_chars</span></span><span class="koboSpan" id="kobo.403.1">(byte_str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.404.1">data</span></span><span class="koboSpan" id="kobo.405.1">(), byte_str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.406.1">data</span></span><span class="koboSpan" id="kobo.407.1">() 
</span><span class="hljs-keyword"> </span><span class="koboSpan" id="kobo.408.1">+ byte_str.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.409.1">size</span></span><span class="koboSpan" id="kobo.410.1">(), value, </span><span class="hljs-number"><span class="koboSpan" id="kobo.411.1">16</span></span><span class="koboSpan" id="kobo.412.1">);
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.413.1">if</span></span><span class="koboSpan" id="kobo.414.1"> (result.ec != std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.415.1">errc</span></span><span class="koboSpan" id="kobo.416.1">()) {
                </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.417.1">return</span></span><span class="koboSpan" id="kobo.418.1">;
            }
            bytes[i] = value;
        }
        is_valid = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.419.1">true</span></span><span class="koboSpan" id="kobo.420.1">;
    }
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.421.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.422.1">main</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.423.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.424.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.425.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.426.1"> mac_address </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.427.1">addr</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.428.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.429.1">"00:11:22:33:44:55"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.430.1">)</span></span><span class="koboSpan" id="kobo.431.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.432.1">static_assert</span></span><span class="koboSpan" id="kobo.433.1">(addr.is_valid);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.434.1">return</span></span><span class="koboSpan" id="kobo.435.1"> addr.bytes.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.436.1">at</span></span><span class="koboSpan" id="kobo.437.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.438.1">5</span></span><span class="koboSpan" id="kobo.439.1">);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.440.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.441.1">main</span></code><span class="koboSpan" id="kobo.442.1"> function, we </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.443.1">create an instance of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.444.1">struct</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.445.1">mac_address</span></code><span class="koboSpan" id="kobo.446.1">, by providing a con</span><code class="inlineCode"><span class="koboSpan" id="kobo.447.1">struct</span></code><span class="koboSpan" id="kobo.448.1">or with </span><code class="inlineCode"><span class="koboSpan" id="kobo.449.1">"00:11:22:33:44:55"</span></code><span class="koboSpan" id="kobo.450.1">. </span><span class="koboSpan" id="kobo.450.2">If we run the preceding example in Compiler Explorer using the x86-64 GCC 14.2 compiler, without optimization enabled, we can observe the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.451.1">The program returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.452.1">85</span></code><span class="koboSpan" id="kobo.453.1"> as a decimal number. </span><span class="koboSpan" id="kobo.453.2">Converting it to hex format, we will get 0x55, which corresponds to the last byte from the MAC address </span><code class="inlineCode"><span class="koboSpan" id="kobo.454.1">00:11:22:33:44:55</span></code><span class="koboSpan" id="kobo.455.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.456.1">The resulting assembly is small. </span><span class="koboSpan" id="kobo.456.2">It populates the stack with bytes from the MAC address we used in the con</span><code class="inlineCode"><span class="koboSpan" id="kobo.457.1">struct</span></code><span class="koboSpan" id="kobo.458.1">or. </span><span class="koboSpan" id="kobo.458.2">There are no calls to the con</span><code class="inlineCode"><span class="koboSpan" id="kobo.459.1">struct</span></code><span class="koboSpan" id="kobo.460.1">or, meaning it is executed at compile time.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.461.1">If we change the MAC address provided in the con</span><code class="inlineCode"><span class="koboSpan" id="kobo.462.1">struct</span></code><span class="koboSpan" id="kobo.463.1">or to </span><code class="inlineCode"><span class="koboSpan" id="kobo.464.1">"000:11:22:33:44:55"</span></code><span class="koboSpan" id="kobo.465.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.466.1">"G0:11:22:33:44:55"</span></code><span class="koboSpan" id="kobo.467.1">, the compiler will generate an error due to failed </span><code class="inlineCode"><span class="koboSpan" id="kobo.468.1">static_assert(addr.is_valid)</span></code><span class="koboSpan" id="kobo.469.1">.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.470.1">Let us now explain</span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.471.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.472.1">struct</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.473.1">mac_address</span></code><span class="koboSpan" id="kobo.474.1"> in more detail:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.475.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.476.1">struct</span></code><span class="koboSpan" id="kobo.477.1"> contains the members </span><code class="inlineCode"><span class="koboSpan" id="kobo.478.1">std::array&lt;uint8_t, c_bytes_num&gt; bytes</span></code><span class="koboSpan" id="kobo.479.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.480.1">bool is_valid</span></code><span class="koboSpan" id="kobo.481.1">. </span><span class="koboSpan" id="kobo.481.2">It doesn’t contain any methods except the con</span><code class="inlineCode"><span class="koboSpan" id="kobo.482.1">struct</span></code><span class="koboSpan" id="kobo.483.1">or.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.484.1">The con</span><code class="inlineCode"><span class="koboSpan" id="kobo.485.1">struct</span></code><span class="koboSpan" id="kobo.486.1">or accepts the </span><code class="inlineCode"><span class="koboSpan" id="kobo.487.1">std::string_view</span></code><span class="koboSpan" id="kobo.488.1"> class template, which encapsulates a pointer to the first element of the provided string literal, and its size.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.489.1">The con</span><code class="inlineCode"><span class="koboSpan" id="kobo.490.1">struct</span></code><span class="koboSpan" id="kobo.491.1">or creates substring views using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.492.1">susbstr</span></code><span class="koboSpan" id="kobo.493.1"> method on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.494.1">string_view</span></code><span class="koboSpan" id="kobo.495.1"> object and it uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.496.1">std::from_char</span></code><span class="koboSpan" id="kobo.497.1"> to convert them to </span><code class="inlineCode"><span class="koboSpan" id="kobo.498.1">uint8_t</span></code><span class="koboSpan" id="kobo.499.1"> values, which are stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.500.1">bytes</span></code><span class="koboSpan" id="kobo.501.1"> array.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.502.1">The con</span><code class="inlineCode"><span class="koboSpan" id="kobo.503.1">struct</span></code><span class="koboSpan" id="kobo.504.1">or sets the bool </span><code class="inlineCode"><span class="koboSpan" id="kobo.505.1">is_valid</span></code><span class="koboSpan" id="kobo.506.1"> to true if there are no errors. </span><span class="koboSpan" id="kobo.506.2">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.507.1">static_assert</span></code><span class="koboSpan" id="kobo.508.1">, we can validate at compile time that the provided MAC address string literal was converted successfully. </span><span class="koboSpan" id="kobo.508.2">We cannot use asserts in </span><code class="inlineCode"><span class="koboSpan" id="kobo.509.1">constexpr</span></code><span class="koboSpan" id="kobo.510.1"> functions. </span><span class="koboSpan" id="kobo.510.2">The alternative is to throw an exception, which would result in a compile-time error, but we decided not to use exceptions for our embedded target.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.511.1">You can also run the preceding example in the Renode simulator on the STM32 target. </span><span class="koboSpan" id="kobo.511.2">Start Visual Studio Code, attach it to the running container, and open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.512.1">Chapter11/compile_time</span></code><span class="koboSpan" id="kobo.513.1"> project, as described in </span><a href="Chapter_04.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.514.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.515.1">, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.516.1">$ cd Chapter11/compile_time
$ cmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel -DMAIN_CPP_FILE_NAME=main_constexpr_mac_address.cpp
$ cmake --build build --target run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.517.1">Here is part of </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.518.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.519.1">main</span></code><span class="koboSpan" id="kobo.520.1"> function from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.521.1">main_constexpr_mac_address.cpp</span></code><span class="koboSpan" id="kobo.522.1"> file:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.523.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.524.1"> mac_address </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.525.1">addr</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.526.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.527.1">"00:11:22:33:44:55"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.528.1">)</span></span><span class="koboSpan" id="kobo.529.1">;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.530.1">static_assert</span></span><span class="koboSpan" id="kobo.531.1">(addr.is_valid);
</span><span class="hljs-type"><span class="koboSpan" id="kobo.532.1">const</span></span><span class="koboSpan" id="kobo.533.1"> std::array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.534.1">uint8_t</span></span><span class="koboSpan" id="kobo.535.1">, 6&gt; addr_arr{</span><span class="hljs-number"><span class="koboSpan" id="kobo.536.1">0x00</span></span><span class="koboSpan" id="kobo.537.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.538.1">0x11</span></span><span class="koboSpan" id="kobo.539.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.540.1">0x22</span></span><span class="koboSpan" id="kobo.541.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.542.1">0x33</span></span><span class="koboSpan" id="kobo.543.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.544.1">0x44</span></span><span class="koboSpan" id="kobo.545.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.546.1">0x55</span></span><span class="koboSpan" id="kobo.547.1">};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.548.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.549.1">auto</span></span><span class="koboSpan" id="kobo.550.1"> &amp; mac_ref = addr.bytes;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.551.1">//const auto &amp; mac_ref = addr_arr;</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.552.1">printf</span></span><span class="koboSpan" id="kobo.553.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.554.1">"%02X:%02X:%02X:%02X:%02X:%02X\r\n"</span></span><span class="koboSpan" id="kobo.555.1">, mac_ref[</span><span class="hljs-number"><span class="koboSpan" id="kobo.556.1">0</span></span><span class="koboSpan" id="kobo.557.1">], mac_ref[</span><span class="hljs-number"><span class="koboSpan" id="kobo.558.1">1</span></span><span class="koboSpan" id="kobo.559.1">], mac_ref[</span><span class="hljs-number"><span class="koboSpan" id="kobo.560.1">2</span></span><span class="koboSpan" id="kobo.561.1">], mac_ref[</span><span class="hljs-number"><span class="koboSpan" id="kobo.562.1">3</span></span><span class="koboSpan" id="kobo.563.1">], mac_ref[</span><span class="hljs-number"><span class="koboSpan" id="kobo.564.1">4</span></span><span class="koboSpan" id="kobo.565.1">], mac_ref[</span><span class="hljs-number"><span class="koboSpan" id="kobo.566.1">5</span></span><span class="koboSpan" id="kobo.567.1">]);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.568.1">To confirm that all the work of converting a string literal to an array is performed at compile time, you can bind the reference </span><code class="inlineCode"><span class="koboSpan" id="kobo.569.1">mac_ref</span></code><span class="koboSpan" id="kobo.570.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.571.1">addr_arr</span></code><span class="koboSpan" id="kobo.572.1"> and compare binary sizes in both cases. </span><span class="koboSpan" id="kobo.572.2">They are both 6,564 bytes, meaning that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.573.1">constexpr</span></code><span class="koboSpan" id="kobo.574.1"> con</span><code class="inlineCode"><span class="koboSpan" id="kobo.575.1">struct</span></code><span class="koboSpan" id="kobo.576.1">or is not included in the binary as it is actually executed at compile time by the compiler.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.577.1">Next, we will go through an example of creating a lookup table for a temperature thermistor using </span><code class="inlineCode"><span class="koboSpan" id="kobo.578.1">constexpr</span></code><span class="koboSpan" id="kobo.579.1"> functions in C++.</span></p>
<h2 class="heading-2" id="_idParaDest-162"><span class="koboSpan" id="kobo.580.1">Example 2 – Generating a lookup table</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.581.1">Thermistors are resistors </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.582.1">whose resistance changes with temperature. </span><span class="koboSpan" id="kobo.582.2">They are commonly used in embedded systems. </span><span class="koboSpan" id="kobo.582.3">They usually have a non-linear curve. </span><span class="koboSpan" id="kobo.582.4">There are different methods to approximate an </span><strong class="keyWord"><span class="koboSpan" id="kobo.583.1">Analog-to-Digital Converter</span></strong><span class="koboSpan" id="kobo.584.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.585.1">ADC</span></strong><span class="koboSpan" id="kobo.586.1">) reading </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.587.1">from a thermistor into a temperature. </span><span class="koboSpan" id="kobo.587.2">One of the most used methods is </span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.588.1">the </span><strong class="keyWord"><span class="koboSpan" id="kobo.589.1">beta coefficient</span></strong><span class="koboSpan" id="kobo.590.1">. </span><span class="koboSpan" id="kobo.590.2">It is calculated by measuring the thermistor’s resistance at two temperature points. </span><span class="koboSpan" id="kobo.590.3">It is used to calculate temperature using the following equation:</span></p>
<p class="normal"><span class="koboSpan" id="kobo.591.1"><img alt="" role="presentation" src="../Images/B22402_11_001.png"/></span></p>
<p class="normal"><span class="koboSpan" id="kobo.592.1">In this equation, </span><em class="italic"><span class="koboSpan" id="kobo.593.1">T</span></em><sub class="italic"><span class="koboSpan" id="kobo.594.1">0</span></sub><span class="koboSpan" id="kobo.595.1"> is a room temperature of 25</span><sup class="superscript"><span class="koboSpan" id="kobo.596.1">o</span></sup><span class="koboSpan" id="kobo.597.1">C (298.15K) and </span><em class="italic"><span class="koboSpan" id="kobo.598.1">R</span></em><sub class="italic"><span class="koboSpan" id="kobo.599.1">0</span></sub><span class="koboSpan" id="kobo.600.1"> is the resistance of a thermistor at room temperature. </span><span class="koboSpan" id="kobo.600.2">Using the beta coefficient (a constant provided by the manufacturer) is a simplification of the thermistor’s curve as it relies on measuring the curve only at two points.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.601.1">The Steinhart-Hart equation provides a more accurate curve-fitting method as it relies on four coefficients calculated by measuring the thermistor at four temperature points. </span><span class="koboSpan" id="kobo.601.2">The equation is shown here:</span></p>
<p class="normal"><span class="koboSpan" id="kobo.602.1"><img alt="" role="presentation" src="../Images/B22402_11_002.png"/></span></p>
<p class="normal"><span class="koboSpan" id="kobo.603.1">Coefficients </span><em class="italic"><span class="koboSpan" id="kobo.604.1">A</span></em><span class="koboSpan" id="kobo.605.1">, </span><em class="italic"><span class="koboSpan" id="kobo.606.1">B</span></em><span class="koboSpan" id="kobo.607.1">, </span><em class="italic"><span class="koboSpan" id="kobo.608.1">C</span></em><span class="koboSpan" id="kobo.609.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.610.1">D</span></em><span class="koboSpan" id="kobo.611.1"> are calculated after measuring the thermistor’s temperature at four different temperature points – meaning these are constants that are given for a thermistor by the manufacturer. </span><span class="koboSpan" id="kobo.611.2">The calculated temperature from the Steinhart-Hart equation is in Kelvins. </span><span class="koboSpan" id="kobo.611.3">The drawback of the Steinhart-Hart equation is it is computationally heavy for small, embedded targets.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.612.1">In this example, we will create a lookup table using the Steinhart-Hart equation and rely on it to determine temperature by reading a value from the ADC in our embedded target. </span><span class="koboSpan" id="kobo.612.2">As we can see from the equation, temperature is a function of resistance and given constants. </span><span class="koboSpan" id="kobo.612.3">For a selected range of resistance, and with a selected resolution, we will generate a lookup table of temperature values. </span><span class="koboSpan" id="kobo.612.4">Then, we will simulate a reading of the thermistor resistance and search the lookup table to determine the temperature.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.613.1">We will select a range of resistance that we want to base the lookup table on, and the number of points we want to use. </span><span class="koboSpan" id="kobo.613.2">For this, we need functionality that will generate an array of numbers in the given range that are evenly spaced, also called linear space. </span><span class="koboSpan" id="kobo.613.3">Next, we will use that linear space </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.614.1">as an argument to a signal generator. </span><span class="koboSpan" id="kobo.614.2">Let’s start with implementing this as follows:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.615.1">Here is the code showing the linear space generator:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.616.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.617.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.618.1">&lt;array&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.619.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.620.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.621.1">&lt;cstdio&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.622.1">template</span></span><span class="koboSpan" id="kobo.623.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.624.1">typename</span></span><span class="koboSpan" id="kobo.625.1"> T, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.626.1">size_t</span></span><span class="koboSpan" id="kobo.627.1"> N&gt;
</span><code class="inlineCode"><span class="koboSpan" id="kobo.628.1">struct</span></code> <span class="hljs-title"><span class="koboSpan" id="kobo.629.1">signal</span></span><span class="koboSpan" id="kobo.630.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.631.1">public</span></span><span class="koboSpan" id="kobo.632.1"> std::array&lt;T, N&gt; {
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.633.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.634.1">signal</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.635.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.636.1">{}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.637.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.638.1">signal</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.639.1">(T begin, T end)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.640.1">{
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.641.1">static_assert</span></span><span class="koboSpan" id="kobo.642.1">(N &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.643.1">1</span></span><span class="koboSpan" id="kobo.644.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.645.1">"N must be bigger than 1"</span></span><span class="koboSpan" id="kobo.646.1">); 
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.647.1">float</span></span><span class="koboSpan" id="kobo.648.1"> step = (end - begin) / (N - </span><span class="hljs-number"><span class="koboSpan" id="kobo.649.1">1</span></span><span class="koboSpan" id="kobo.650.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.651.1">for</span></span><span class="koboSpan" id="kobo.652.1"> (std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.653.1">size_t</span></span><span class="koboSpan" id="kobo.654.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.655.1">0</span></span><span class="koboSpan" id="kobo.656.1">; i &lt; N; i++) {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.657.1">this</span></span><span class="koboSpan" id="kobo.658.1">-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.659.1">at</span></span><span class="koboSpan" id="kobo.660.1">(i) = begin + i * step;
    }
  }
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.661.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.662.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.663.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.664.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.665.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.666.1"> signal&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.667.1">float</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.668.1">, 10&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.669.1">x_axis</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.670.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.671.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.672.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.673.1">9</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.674.1">)</span></span><span class="koboSpan" id="kobo.675.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.676.1">for</span></span><span class="koboSpan" id="kobo.677.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.678.1">auto</span></span><span class="koboSpan" id="kobo.679.1"> elem: x_axis) {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.680.1">printf</span></span><span class="koboSpan" id="kobo.681.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.682.1">"%.2f, "</span></span><span class="koboSpan" id="kobo.683.1">, elem);
    }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.684.1">printf</span></span><span class="koboSpan" id="kobo.685.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.686.1">"\r\n"</span></span><span class="koboSpan" id="kobo.687.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.688.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.689.1">0</span></span><span class="koboSpan" id="kobo.690.1">;
}
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.691.1">If we run this program, it will print 10 numbers in the range of 0 to 10, as shown here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.692.1">0.00, 1.00, 2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00, 9.00,
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.693.1">The numbers </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.694.1">printed are generated at compile time by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.695.1">signal</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.696.1">struct</span></code><span class="koboSpan" id="kobo.697.1">. </span><span class="koboSpan" id="kobo.697.2">To connect this back to our example, imagine that these are the values of resistance for which we want to calculate the temperature using the Steinhart-Hart equation. </span><span class="koboSpan" id="kobo.697.3">Let’s go through the implementation in detail:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.698.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.699.1">signal</span></code><span class="koboSpan" id="kobo.700.1"> is a class template. </span><span class="koboSpan" id="kobo.700.2">Template parameters are </span><code class="inlineCode"><span class="koboSpan" id="kobo.701.1">typename T</span></code><span class="koboSpan" id="kobo.702.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.703.1">std::size_t N</span></code><span class="koboSpan" id="kobo.704.1">. </span><span class="koboSpan" id="kobo.704.2">They determine the array type that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.705.1">struct</span></code><span class="koboSpan" id="kobo.706.1"> is based on.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.707.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.708.1">struct</span></code><span class="koboSpan" id="kobo.709.1"> derives from </span><code class="inlineCode"><span class="koboSpan" id="kobo.710.1">std::array&lt;T, N&gt;</span></code><span class="koboSpan" id="kobo.711.1">. </span><span class="koboSpan" id="kobo.711.2">We based it on </span><code class="inlineCode"><span class="koboSpan" id="kobo.712.1">std::array</span></code><span class="koboSpan" id="kobo.713.1"> to be able to use range-based for loops easily and standard library algorithms.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.714.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.715.1">constexpr</span></code><span class="koboSpan" id="kobo.716.1"> con</span><code class="inlineCode"><span class="koboSpan" id="kobo.717.1">struct</span></code><span class="koboSpan" id="kobo.718.1">or, we use </span><code class="inlineCode"><span class="koboSpan" id="kobo.719.1">static_assert</span></code><span class="koboSpan" id="kobo.720.1"> to make sure that </span><code class="inlineCode"><span class="koboSpan" id="kobo.721.1">N</span></code><span class="koboSpan" id="kobo.722.1"> is greater than 1, and we populate the underlying array with evenly spaced points between </span><code class="inlineCode"><span class="koboSpan" id="kobo.723.1">begin</span></code><span class="koboSpan" id="kobo.724.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.725.1">end</span></code><span class="koboSpan" id="kobo.726.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.727.1">In </span><code class="inlineCode"><span class="koboSpan" id="kobo.728.1">main</span></code><span class="koboSpan" id="kobo.729.1">, we provide </span><code class="inlineCode"><span class="koboSpan" id="kobo.730.1">float</span></code><span class="koboSpan" id="kobo.731.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.732.1">10</span></code><span class="koboSpan" id="kobo.733.1"> as template arguments to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">struct signal</span></code><span class="koboSpan" id="kobo.735.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.736.1">0</span></code><span class="koboSpan" id="kobo.737.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.738.1">9</span></code><span class="koboSpan" id="kobo.739.1"> as </span><code class="inlineCode"><span class="koboSpan" id="kobo.740.1">begin</span></code><span class="koboSpan" id="kobo.741.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.742.1">end</span></code><span class="koboSpan" id="kobo.743.1"> points for the linear space to the con</span><code class="inlineCode"><span class="koboSpan" id="kobo.744.1">struct</span></code><span class="koboSpan" id="kobo.745.1">or. </span><span class="koboSpan" id="kobo.745.2">We use a range-based for loop to go through elements of the compile-time-generated object </span><code class="inlineCode"><span class="koboSpan" id="kobo.746.1">x_axis</span></code><span class="koboSpan" id="kobo.747.1"> and print its elements.</span></li>
</ul>
<ol>
<li class="numberedList" value="2"><span class="koboSpan" id="kobo.748.1">Next, we will expand the signal </span><code class="inlineCode"><span class="koboSpan" id="kobo.749.1">struct</span></code><span class="koboSpan" id="kobo.750.1"> with an additional con</span><code class="inlineCode"><span class="koboSpan" id="kobo.751.1">struct</span></code><span class="koboSpan" id="kobo.752.1">or that allows us to create a signal based on another signal and a lambda we will use to provide a math function to generate elements of a new signal. </span><span class="koboSpan" id="kobo.752.2">The code for a new con</span><code class="inlineCode"><span class="koboSpan" id="kobo.753.1">struct</span></code><span class="koboSpan" id="kobo.754.1">or is shown here:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.755.1">template</span></span><span class="koboSpan" id="kobo.756.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.757.1">typename</span></span><span class="koboSpan" id="kobo.758.1"> T, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.759.1">size_t</span></span><span class="koboSpan" id="kobo.760.1"> N&gt;
</span><code class="inlineCode"><span class="koboSpan" id="kobo.761.1">struct</span></code> <span class="hljs-title"><span class="koboSpan" id="kobo.762.1">signal</span></span><span class="koboSpan" id="kobo.763.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.764.1">public</span></span><span class="koboSpan" id="kobo.765.1"> std::array&lt;T, N&gt; {
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.766.1">// ...</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.767.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.768.1">signal</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.769.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.770.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.771.1"> signal &amp;sig, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.772.1">auto</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.773.1"> fun)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.774.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.775.1">for</span></span><span class="koboSpan" id="kobo.776.1"> (std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.777.1">size_t</span></span><span class="koboSpan" id="kobo.778.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.779.1">0</span></span><span class="koboSpan" id="kobo.780.1">; i &lt; N; i++) {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.781.1">this</span></span><span class="koboSpan" id="kobo.782.1">-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.783.1">at</span></span><span class="koboSpan" id="kobo.784.1">(i) = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.785.1">fun</span></span><span class="koboSpan" id="kobo.786.1">(sig.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.787.1">at</span></span><span class="koboSpan" id="kobo.788.1">(i));
    }
  }
};
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.789.1">In this con</span><code class="inlineCode"><span class="koboSpan" id="kobo.790.1">struct</span></code><span class="koboSpan" id="kobo.791.1">or, we </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.792.1">initialize elements of a new signal by calling the passed </span><code class="inlineCode"><span class="koboSpan" id="kobo.793.1">fun</span></code><span class="koboSpan" id="kobo.794.1"> on elements of the passed signal </span><code class="inlineCode"><span class="koboSpan" id="kobo.795.1">sig</span></code><span class="koboSpan" id="kobo.796.1">.</span></p>
<ol>
<li class="numberedList" value="3"><span class="koboSpan" id="kobo.797.1">Now we can create a new signal, as shown in this code:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.798.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.799.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.800.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.801.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.802.1">const</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.803.1">auto</span></span><span class="koboSpan" id="kobo.804.1"> print_signal = [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.805.1">auto</span></span><span class="koboSpan" id="kobo.806.1"> sig) {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.807.1">for</span></span><span class="koboSpan" id="kobo.808.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.809.1">auto</span></span><span class="koboSpan" id="kobo.810.1"> elem: sig) {
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.811.1">printf</span></span><span class="koboSpan" id="kobo.812.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.813.1">"%.2f, "</span></span><span class="koboSpan" id="kobo.814.1">, elem);
        }
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.815.1">printf</span></span><span class="koboSpan" id="kobo.816.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.817.1">"\r\n"</span></span><span class="koboSpan" id="kobo.818.1">);
    };
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.819.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.820.1"> signal&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.821.1">float</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.822.1">, 10&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.823.1">x_axis</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.824.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.825.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.826.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.827.1">9</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.828.1">)</span></span><span class="koboSpan" id="kobo.829.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.830.1">print_signal</span></span><span class="koboSpan" id="kobo.831.1">(x_axis);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.832.1">auto</span></span><span class="koboSpan" id="kobo.833.1"> sine = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.834.1">signal</span></span><span class="koboSpan" id="kobo.835.1">(x_axis, [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.836.1">float</span></span><span class="koboSpan" id="kobo.837.1"> x){ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.838.1">return</span></span><span class="koboSpan" id="kobo.839.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.840.1">sin</span></span><span class="koboSpan" id="kobo.841.1">(x);});
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.842.1">print_signal</span></span><span class="koboSpan" id="kobo.843.1">(sine);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.844.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.845.1">0</span></span><span class="koboSpan" id="kobo.846.1">;
}
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.847.1">If you are following the example using Compiler Explorer, make sure to include the </span><code class="inlineCode"><span class="koboSpan" id="kobo.848.1">&lt;cmath&gt;</span></code><span class="koboSpan" id="kobo.849.1"> header as we are using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.850.1">std::sin</span></code><span class="koboSpan" id="kobo.851.1"> function. </span><span class="koboSpan" id="kobo.851.2">Running it will give the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.852.1">0.00, 1.00, 2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00, 9.00,
0.00, 0.84, 0.91, 0.14, -0.76, -0.96, -0.28, 0.66, 0.99, 0.41,
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.853.1">In this code, we created a new signal named </span><code class="inlineCode"><span class="koboSpan" id="kobo.854.1">sine</span></code><span class="koboSpan" id="kobo.855.1"> by passing </span><code class="inlineCode"><span class="koboSpan" id="kobo.856.1">x_axis</span></code><span class="koboSpan" id="kobo.857.1"> and the lambda </span><code class="inlineCode"><span class="koboSpan" id="kobo.858.1">[](int x){return std::sin(x);}</span></code><span class="koboSpan" id="kobo.859.1"> to the newly created con</span><code class="inlineCode"><span class="koboSpan" id="kobo.860.1">struct</span></code><span class="koboSpan" id="kobo.861.1">or.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.862.1">To connect </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.863.1">this with the example, now we can generate a lookup table using simple math functions (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.864.1">std::sin</span></code><span class="koboSpan" id="kobo.865.1">) and linear space generated with the signal con</span><code class="inlineCode"><span class="koboSpan" id="kobo.866.1">struct</span></code><span class="koboSpan" id="kobo.867.1">or from </span><em class="italic"><span class="koboSpan" id="kobo.868.1">step 1</span></em><span class="koboSpan" id="kobo.869.1">.</span></p>
<h3 class="heading-3" id="_idParaDest-163"><span class="koboSpan" id="kobo.870.1">Generating a lookup table</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.871.1">To generate more complex </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.872.1">functions, we need to expand the </span><code class="inlineCode"><span class="koboSpan" id="kobo.873.1">signal</span></code><span class="koboSpan" id="kobo.874.1"> class with more functionality:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.875.1">First, we will overload the operators </span><code class="inlineCode"><span class="koboSpan" id="kobo.876.1">*</span></code><span class="koboSpan" id="kobo.877.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.878.1">/</span></code><span class="koboSpan" id="kobo.879.1">, to multiply signals by constants and divide constants by elements of signal. </span><span class="koboSpan" id="kobo.879.2">The code is shown here:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.880.1">template</span></span><span class="koboSpan" id="kobo.881.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.882.1">typename</span></span><span class="koboSpan" id="kobo.883.1"> T, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.884.1">size_t</span></span><span class="koboSpan" id="kobo.885.1"> N&gt;
</span><code class="inlineCode"><span class="koboSpan" id="kobo.886.1">struct</span></code> <span class="hljs-title"><span class="koboSpan" id="kobo.887.1">signal</span></span><span class="koboSpan" id="kobo.888.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.889.1">public</span></span><span class="koboSpan" id="kobo.890.1"> std::array&lt;T, N&gt; {
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.891.1">// ...</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.892.1">constexpr</span></span><span class="koboSpan" id="kobo.893.1"> signal </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.894.1">operator</span></span><span class="koboSpan" id="kobo.895.1">*(</span><span class="hljs-type"><span class="koboSpan" id="kobo.896.1">const</span></span><span class="koboSpan" id="kobo.897.1"> T &amp;t) </span><span class="hljs-type"><span class="koboSpan" id="kobo.898.1">const</span></span><span class="koboSpan" id="kobo.899.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.900.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.901.1">signal</span></span><span class="koboSpan" id="kobo.902.1">(*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.903.1">this</span></span><span class="koboSpan" id="kobo.904.1">, [&amp;](T elem)
                  { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.905.1">return</span></span><span class="koboSpan" id="kobo.906.1"> elem * t; });
  };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.907.1">constexpr</span></span><span class="koboSpan" id="kobo.908.1"> signal </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.909.1">operator</span></span><span class="koboSpan" id="kobo.910.1">/(</span><span class="hljs-type"><span class="koboSpan" id="kobo.911.1">const</span></span><span class="koboSpan" id="kobo.912.1"> T &amp;t) </span><span class="hljs-type"><span class="koboSpan" id="kobo.913.1">const</span></span><span class="koboSpan" id="kobo.914.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.915.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.916.1">signal</span></span><span class="koboSpan" id="kobo.917.1">(*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.918.1">this</span></span><span class="koboSpan" id="kobo.919.1">, [&amp;](T elem)
                  { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.920.1">return</span></span><span class="koboSpan" id="kobo.921.1"> elem / t; });
  };
 };
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.922.1">In this code, we </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.923.1">overloaded the operators </span><code class="inlineCode"><span class="koboSpan" id="kobo.924.1">*</span></code><span class="koboSpan" id="kobo.925.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.926.1">/</span></code><span class="koboSpan" id="kobo.927.1">, enabling multiplication and division of a signal with a scalar, as in:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.928.1">auto result = sig * 2.0f;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.929.1">The preceding code will create a new signal called </span><code class="inlineCode"><span class="koboSpan" id="kobo.930.1">result</span></code><span class="koboSpan" id="kobo.931.1">, which will be the result of the multiplication of every element of signal </span><code class="inlineCode"><span class="koboSpan" id="kobo.932.1">sig</span></code><span class="koboSpan" id="kobo.933.1"> by scalar </span><code class="inlineCode"><span class="koboSpan" id="kobo.934.1">2.0</span></code><span class="koboSpan" id="kobo.935.1">.</span></p>
<ol>
<li class="numberedList" value="2"><span class="koboSpan" id="kobo.936.1">Similarly, we can create a new signal by dividing the existing signal by a scalar, as shown here:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.937.1">auto</span></span><span class="koboSpan" id="kobo.938.1"> result = sig / </span><span class="hljs-number"><span class="koboSpan" id="kobo.939.1">2.0f</span></span><span class="koboSpan" id="kobo.940.1">;
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.941.1">This code will create a new signal called </span><code class="inlineCode"><span class="koboSpan" id="kobo.942.1">result</span></code><span class="koboSpan" id="kobo.943.1">, which will be the result of the division of every element of signal </span><code class="inlineCode"><span class="koboSpan" id="kobo.944.1">sig</span></code><span class="koboSpan" id="kobo.945.1"> by scalar </span><code class="inlineCode"><span class="koboSpan" id="kobo.946.1">2.0</span></code><span class="koboSpan" id="kobo.947.1">.</span></p>
<ol>
<li class="numberedList" value="3"><span class="koboSpan" id="kobo.948.1">To support scalars from the left side of operators </span><code class="inlineCode"><span class="koboSpan" id="kobo.949.1">*</span></code><span class="koboSpan" id="kobo.950.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.951.1">/</span></code><span class="koboSpan" id="kobo.952.1">, we need to implement the global operators </span><code class="inlineCode"><span class="koboSpan" id="kobo.953.1">operator*</span></code><span class="koboSpan" id="kobo.954.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.955.1">operator/</span></code><span class="koboSpan" id="kobo.956.1">. </span><span class="koboSpan" id="kobo.956.2">We will do so by declaring them as friends to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.957.1">struct signal</span></code><span class="koboSpan" id="kobo.958.1">, as shown here:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.959.1">template</span></span><span class="koboSpan" id="kobo.960.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.961.1">typename</span></span><span class="koboSpan" id="kobo.962.1"> T, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.963.1">size_t</span></span><span class="koboSpan" id="kobo.964.1"> N&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.965.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.966.1">signal</span></span><span class="koboSpan" id="kobo.967.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.968.1">public</span></span><span class="koboSpan" id="kobo.969.1"> std::array&lt;T, N&gt; {
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.970.1">// ...</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.971.1">friend</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.972.1">constexpr</span></span><span class="koboSpan" id="kobo.973.1"> signal </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.974.1">operator</span></span><span class="koboSpan" id="kobo.975.1">*(</span><span class="hljs-type"><span class="koboSpan" id="kobo.976.1">const</span></span><span class="koboSpan" id="kobo.977.1"> T &amp;t, </span><span class="hljs-type"><span class="koboSpan" id="kobo.978.1">const</span></span><span class="koboSpan" id="kobo.979.1"> signal &amp;sig)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.980.1">return</span></span><span class="koboSpan" id="kobo.981.1"> sig * t;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.982.1">friend</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.983.1">constexpr</span></span><span class="koboSpan" id="kobo.984.1"> signal </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.985.1">operator</span></span><span class="koboSpan" id="kobo.986.1">/(</span><span class="hljs-type"><span class="koboSpan" id="kobo.987.1">const</span></span><span class="koboSpan" id="kobo.988.1"> T &amp;t, </span><span class="hljs-type"><span class="koboSpan" id="kobo.989.1">const</span></span><span class="koboSpan" id="kobo.990.1"> signal &amp;sig)
  {
    signal ret;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.991.1">for</span></span><span class="koboSpan" id="kobo.992.1"> (std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.993.1">size_t</span></span><span class="koboSpan" id="kobo.994.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.995.1">0</span></span><span class="koboSpan" id="kobo.996.1">; i &lt; N; i++) {
      ret.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.997.1">at</span></span><span class="koboSpan" id="kobo.998.1">(i) = t / sig.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.999.1">at</span></span><span class="koboSpan" id="kobo.1000.1">(i);
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1001.1">return</span></span><span class="koboSpan" id="kobo.1002.1"> ret;
  }
};
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1003.1">The friend </span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.1004.1">function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1005.1">operator*</span></code><span class="koboSpan" id="kobo.1006.1"> in this code allows scalar multiplication when the scalar is on the left-hand side (scalar * signal), which is not possible with the member function alone. </span><span class="koboSpan" id="kobo.1006.2">As multiplication has a commutative property (</span><em class="italic"><span class="koboSpan" id="kobo.1007.1">a * b = b * a</span></em><span class="koboSpan" id="kobo.1008.1">), we simply call the member function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1009.1">operator*</span></code><span class="koboSpan" id="kobo.1010.1"> and return the result (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1011.1">return sig * t</span></code><span class="koboSpan" id="kobo.1012.1">).</span></p>
<ol>
<li class="numberedList" value="4"><span class="koboSpan" id="kobo.1013.1">In the friend function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1014.1">operator/</span></code><span class="koboSpan" id="kobo.1015.1">, we perform the following steps:</span><ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1016.1">Create a new signal, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1017.1">ret</span></code><span class="koboSpan" id="kobo.1018.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1019.1">Iterate over the elements of the signal </span><code class="inlineCode"><span class="koboSpan" id="kobo.1020.1">sig</span></code><span class="koboSpan" id="kobo.1021.1">, and for each element, the scalar </span><code class="inlineCode"><span class="koboSpan" id="kobo.1022.1">t</span></code><span class="koboSpan" id="kobo.1023.1"> is divided by the element.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1024.1">We return the signal </span><code class="inlineCode"><span class="koboSpan" id="kobo.1025.1">ret</span></code><span class="koboSpan" id="kobo.1026.1">.</span></li>
</ol>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.1027.1">By overloading the operators </span><code class="inlineCode"><span class="koboSpan" id="kobo.1028.1">*</span></code><span class="koboSpan" id="kobo.1029.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1030.1">/</span></code><span class="koboSpan" id="kobo.1031.1"> both as global and as member functions, we can now create signals as in the following example:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1032.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1033.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1034.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1035.1">{
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1036.1">// ...</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1037.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1038.1"> signal&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1039.1">float</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1040.1">, 10&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1041.1">x_axis</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1042.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1043.1">0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1044.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1045.1">9</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1046.1">)</span></span><span class="koboSpan" id="kobo.1047.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1048.1">print_signal</span></span><span class="koboSpan" id="kobo.1049.1">(x_axis);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1050.1">auto</span></span><span class="koboSpan" id="kobo.1051.1"> linear_fun = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1052.1">2.f</span></span><span class="koboSpan" id="kobo.1053.1"> * x_axis;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1054.1">print_signal</span></span><span class="koboSpan" id="kobo.1055.1">(linear_fun);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1056.1">auto</span></span><span class="koboSpan" id="kobo.1057.1"> linear_fun2 = linear_fun / </span><span class="hljs-number"><span class="koboSpan" id="kobo.1058.1">2.f</span></span><span class="koboSpan" id="kobo.1059.1">;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1060.1">print_signal</span></span><span class="koboSpan" id="kobo.1061.1">(linear_fun2);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1062.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1063.1">0</span></span><span class="koboSpan" id="kobo.1064.1">;
}
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1065.1">This code will</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.1066.1"> result in the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1067.1">0.00, 1.00, 2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00, 9.00,
0.00, 2.00, 4.00, 6.00, 8.00, 10.00, 12.00, 14.00, 16.00, 18.00,
0.00, 1.00, 2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00, 9.00,
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1068.1">As we can see from this output, the originally created </span><code class="inlineCode"><span class="koboSpan" id="kobo.1069.1">x_axis</span></code><span class="koboSpan" id="kobo.1070.1">, representing linear space from 0 to 9.00 with 10 points, is multiplied by 2.0 to create </span><code class="inlineCode"><span class="koboSpan" id="kobo.1071.1">linear_fun</span></code><span class="koboSpan" id="kobo.1072.1">. </span><span class="koboSpan" id="kobo.1072.2">Then we divide </span><code class="inlineCode"><span class="koboSpan" id="kobo.1073.1">linear_fun</span></code><span class="koboSpan" id="kobo.1074.1"> by 2.0 to create </span><code class="inlineCode"><span class="koboSpan" id="kobo.1075.1">linear_fun2</span></code><span class="koboSpan" id="kobo.1076.1">, which matches the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1077.1">x_axis</span></code><span class="koboSpan" id="kobo.1078.1">.</span></p>
<ol>
<li class="numberedList" value="6"><span class="koboSpan" id="kobo.1079.1">To be able to</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.1080.1"> write the full Steinhart-Hart equation, we also need to overload operators </span><code class="inlineCode"><span class="koboSpan" id="kobo.1081.1">+</span></code><span class="koboSpan" id="kobo.1082.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1083.1">-</span></code><span class="koboSpan" id="kobo.1084.1">, as shown here:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1085.1">template</span></span><span class="koboSpan" id="kobo.1086.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1087.1">typename</span></span><span class="koboSpan" id="kobo.1088.1"> T, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.1089.1">size_t</span></span><span class="koboSpan" id="kobo.1090.1"> N&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1091.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1092.1">signal</span></span><span class="koboSpan" id="kobo.1093.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1094.1">public</span></span><span class="koboSpan" id="kobo.1095.1"> std::array&lt;T, N&gt; {
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.1096.1">// ...</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1097.1">constexpr</span></span><span class="koboSpan" id="kobo.1098.1"> signal </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1099.1">operator</span></span><span class="koboSpan" id="kobo.1100.1">+(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1101.1">const</span></span><span class="koboSpan" id="kobo.1102.1"> T &amp;t) </span><span class="hljs-type"><span class="koboSpan" id="kobo.1103.1">const</span></span><span class="koboSpan" id="kobo.1104.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1105.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1106.1">signal</span></span><span class="koboSpan" id="kobo.1107.1">(*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1108.1">this</span></span><span class="koboSpan" id="kobo.1109.1">, [&amp;](T elem)
                  { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1110.1">return</span></span><span class="koboSpan" id="kobo.1111.1"> elem + t; });
  };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1112.1">constexpr</span></span><span class="koboSpan" id="kobo.1113.1"> signal </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1114.1">operator</span></span><span class="koboSpan" id="kobo.1115.1">-(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1116.1">const</span></span><span class="koboSpan" id="kobo.1117.1"> T &amp;t) </span><span class="hljs-type"><span class="koboSpan" id="kobo.1118.1">const</span></span><span class="koboSpan" id="kobo.1119.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1120.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1121.1">signal</span></span><span class="koboSpan" id="kobo.1122.1">(*</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1123.1">this</span></span><span class="koboSpan" id="kobo.1124.1">, [&amp;](T elem)
                  { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1125.1">return</span></span><span class="koboSpan" id="kobo.1126.1"> elem - t; });
  };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1127.1">constexpr</span></span><span class="koboSpan" id="kobo.1128.1"> signal </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1129.1">operator</span></span><span class="koboSpan" id="kobo.1130.1">+(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1131.1">const</span></span><span class="koboSpan" id="kobo.1132.1"> signal &amp;sig) </span><span class="hljs-type"><span class="koboSpan" id="kobo.1133.1">const</span></span><span class="koboSpan" id="kobo.1134.1"> {
    signal ret;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1135.1">for</span></span><span class="koboSpan" id="kobo.1136.1"> (std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.1137.1">size_t</span></span><span class="koboSpan" id="kobo.1138.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1139.1">0</span></span><span class="koboSpan" id="kobo.1140.1">; i &lt; N; i++)
    {
      ret.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1141.1">at</span></span><span class="koboSpan" id="kobo.1142.1">(i) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1143.1">this</span></span><span class="koboSpan" id="kobo.1144.1">-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1145.1">at</span></span><span class="koboSpan" id="kobo.1146.1">(i) + sig.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1147.1">at</span></span><span class="koboSpan" id="kobo.1148.1">(i);
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1149.1">return</span></span><span class="koboSpan" id="kobo.1150.1"> ret;
  };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1151.1">friend</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1152.1">constexpr</span></span><span class="koboSpan" id="kobo.1153.1"> signal </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1154.1">operator</span></span><span class="koboSpan" id="kobo.1155.1">+(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1156.1">const</span></span><span class="koboSpan" id="kobo.1157.1"> T &amp;t, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1158.1">const</span></span><span class="koboSpan" id="kobo.1159.1"> signal &amp;sig)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1160.1">return</span></span><span class="koboSpan" id="kobo.1161.1"> sig + t;
  }
};
</span></code></pre>
</li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1162.1">In this code, we overload the following operators:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1163.1">A member </span><code class="inlineCode"><span class="koboSpan" id="kobo.1164.1">constexpr signal operator+(const T &amp;t)</span></code><span class="koboSpan" id="kobo.1165.1">, allowing us to add a scalar to a signal (signal + scalar)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1166.1">A member </span><code class="inlineCode"><span class="koboSpan" id="kobo.1167.1">constexpr signal operator-(const T &amp;t)</span></code><span class="koboSpan" id="kobo.1168.1">, allowing us to subtract a scalar from a signal (signal - scalar)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1169.1">A member </span><code class="inlineCode"><span class="koboSpan" id="kobo.1170.1">constexpr signal operator+(const signal &amp;sig)</span></code><span class="koboSpan" id="kobo.1171.1">, allowing us to </span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.1172.1">add two signals, element by element (signal1 + signal2)</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1173.1">Global </span><code class="inlineCode"><span class="koboSpan" id="kobo.1174.1">constexpr signal operator+(const T &amp;t, const signal &amp;sig)</span></code><span class="koboSpan" id="kobo.1175.1">, allowing us to add a signal to a scalar (scalar + signal)</span></li>
</ul>
<h3 class="heading-3" id="_idParaDest-164"><span class="koboSpan" id="kobo.1176.1">Writing a signal representing the Steinhart-Hart equation</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1177.1">Now we have all the elements we need to write a</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.1178.1"> signal that represents the</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.1179.1"> Steinhart-Hart equation, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1180.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1181.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1182.1">()</span></span><span class="koboSpan" id="kobo.1183.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1184.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1185.1">float</span></span><span class="koboSpan" id="kobo.1186.1"> A = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1187.1">1.18090254918130e-3</span></span><span class="koboSpan" id="kobo.1188.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1189.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1190.1">float</span></span><span class="koboSpan" id="kobo.1191.1"> B = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1192.1">2.16884014794388e-4</span></span><span class="koboSpan" id="kobo.1193.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1194.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1195.1">float</span></span><span class="koboSpan" id="kobo.1196.1"> C = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1197.1">1.90058756197216e-6</span></span><span class="koboSpan" id="kobo.1198.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1199.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1200.1">float</span></span><span class="koboSpan" id="kobo.1201.1"> D = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1202.1">1.83161892641824e-8</span></span><span class="koboSpan" id="kobo.1203.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1204.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1205.1">int</span></span><span class="koboSpan" id="kobo.1206.1"> c_lut_points = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1207.1">50</span></span><span class="koboSpan" id="kobo.1208.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1209.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1210.1"> signal&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1211.1">float</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1212.1">, c_lut_points&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1213.1">resistance</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1214.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1215.1">1e3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1216.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1217.1">10e3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1218.1">)</span></span><span class="koboSpan" id="kobo.1219.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1220.1">constexpr</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1221.1">auto</span></span><span class="koboSpan" id="kobo.1222.1"> temperature_k =
  </span><span class="hljs-number"><span class="koboSpan" id="kobo.1223.1">1</span></span><span class="koboSpan" id="kobo.1224.1"> / (A +
  B * </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1225.1">signal</span></span><span class="koboSpan" id="kobo.1226.1">(resistance, [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.1227.1">float</span></span><span class="koboSpan" id="kobo.1228.1"> x)
                    { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1229.1">return</span></span><span class="koboSpan" id="kobo.1230.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1231.1">log</span></span><span class="koboSpan" id="kobo.1232.1">(x); }) +
  C * </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1233.1">signal</span></span><span class="koboSpan" id="kobo.1234.1">(resistance, [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.1235.1">float</span></span><span class="koboSpan" id="kobo.1236.1"> x)
                    { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1237.1">return</span></span><span class="koboSpan" id="kobo.1238.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1239.1">pow</span></span><span class="koboSpan" id="kobo.1240.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1241.1">log</span></span><span class="koboSpan" id="kobo.1242.1">(x), </span><span class="hljs-number"><span class="koboSpan" id="kobo.1243.1">2</span></span><span class="koboSpan" id="kobo.1244.1">); }) +
  D * </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1245.1">signal</span></span><span class="koboSpan" id="kobo.1246.1">(resistance, [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.1247.1">float</span></span><span class="koboSpan" id="kobo.1248.1"> x)
                    { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1249.1">return</span></span><span class="koboSpan" id="kobo.1250.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1251.1">pow</span></span><span class="koboSpan" id="kobo.1252.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1253.1">log</span></span><span class="koboSpan" id="kobo.1254.1">(x), </span><span class="hljs-number"><span class="koboSpan" id="kobo.1255.1">3</span></span><span class="koboSpan" id="kobo.1256.1">); }));
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1257.1">constexpr</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1258.1">auto</span></span><span class="koboSpan" id="kobo.1259.1"> temperature_celsius = temperature_k - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1260.1">273.15f</span></span><span class="koboSpan" id="kobo.1261.1">;
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.1262.1">std::ofstream </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1263.1">file</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1264.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1265.1">"out.csv"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1266.1">)</span></span><span class="koboSpan" id="kobo.1267.1">;
  file &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1268.1">"Resistance[Ohm], Temperature[Celsius]\n"</span></span><span class="koboSpan" id="kobo.1269.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1270.1">for</span></span><span class="koboSpan" id="kobo.1271.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.1272.1">int</span></span><span class="koboSpan" id="kobo.1273.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1274.1">0</span></span><span class="koboSpan" id="kobo.1275.1">; i &lt; c_lut_points; i++) {
    file &lt;&lt; resistance[i] &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1276.1">", "</span></span><span class="koboSpan" id="kobo.1277.1"> &lt;&lt; temperature_celsius[i] &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1278.1">"\n"</span></span><span class="koboSpan" id="kobo.1279.1">;
  }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1280.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1281.1">0</span></span><span class="koboSpan" id="kobo.1282.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1283.1">This code generates</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.1284.1"> points from the Steinhart-Hart equation through the following steps:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1285.1">Define the </span><em class="italic"><span class="koboSpan" id="kobo.1286.1">A</span></em><span class="koboSpan" id="kobo.1287.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1288.1">B</span></em><span class="koboSpan" id="kobo.1289.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1290.1">C</span></em><span class="koboSpan" id="kobo.1291.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.1292.1">D</span></em><span class="koboSpan" id="kobo.1293.1"> coefficients.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1294.1">Create values for resistance in the range 1 to 10 kOhms across 50 points.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1295.1">Calculate values of temperature in Kelvins using the Steinhart-Hart equation in points from the generated resistance signal. </span><span class="koboSpan" id="kobo.1295.2">We convert temperature to Celsius by subtracting 273.15.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1296.1">Save the values from the generated resistance and temperature signals into a CSV file (file operations require including the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1297.1">&lt;fstream&gt;</span></code><span class="koboSpan" id="kobo.1298.1"> header).</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1299.1">You can run the full example in a Docker container. </span><span class="koboSpan" id="kobo.1299.2">Start Visual Studio Code, attach it to the running container, and open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1300.1">Chapter11/signal_generator</span></code><span class="koboSpan" id="kobo.1301.1"> project, as described in </span><a href="Chapter_04.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1302.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.1303.1">, and then run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1304.1">$ cd Chapter11/signal_generator
$ cmake -B build
$ cmake --build build
$ ./build/signal_gen
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1305.1">Running the example </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.1306.1">will result in a CSV file being created (</span><code class="inlineCode"><span class="koboSpan" id="kobo.1307.1">out.csv</span></code><span class="koboSpan" id="kobo.1308.1">). </span><span class="koboSpan" id="kobo.1308.2">We can generate an image from the created CSV file using the following command in the terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1309.1">$ graph out.csv -o curve.png
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1310.1">We can transfer the generated image using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1311.1">docker cp</span></code><span class="koboSpan" id="kobo.1312.1"> command from the host machine:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1313.1">$ docker cp dev_env:/workspace/Cpp-in-Embedded-Systems/Chapter11/signal_generator/curve.png
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1314.1">This command will transfer the generated image </span><code class="inlineCode"><span class="koboSpan" id="kobo.1315.1">curve.png</span></code><span class="koboSpan" id="kobo.1316.1"> to the host machine. </span><span class="koboSpan" id="kobo.1316.2">We can also see the same image here:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1317.1"><img alt="Figure 11.1 – Steinhart-Hart curve" src="../Images/B22402_11_01.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.1318.1">Figure 11</span></span><span class="koboSpan" id="kobo.1319.1">.1 – Steinhart-Hart curve</span></p>
<p class="normal"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1320.1">Figure 11</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1321.1">.1</span></em><span class="koboSpan" id="kobo.1322.1"> depicts</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.1323.1"> the calculated Steinhart-Hart curve. </span><span class="koboSpan" id="kobo.1323.2">Values for resistance and temperature were generated at compile time using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1324.1">signal</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.1325.1">struct</span></code><span class="koboSpan" id="kobo.1326.1">. </span><span class="koboSpan" id="kobo.1326.2">Next, we will use the generated curve in Renode to read a temperature from a simulated thermistor using the ADC. </span><span class="koboSpan" id="kobo.1326.3">Here is an image of a circuit showing how the thermistor is connected to the microcontroller:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1327.1"><img alt="Figure 11.2 – Thermistor circuit" src="../Images/B22402_11_02.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.1328.1">Figure 11</span></span><span class="koboSpan" id="kobo.1329.1">.2 – Thermistor circuit</span></p>
<p class="normal"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1330.1">Figure 11</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1331.1">.2</span></em><span class="koboSpan" id="kobo.1332.1"> depicts a voltage divider with a thermistor. </span><span class="koboSpan" id="kobo.1332.2">If we measure the voltage on the ADC pin, we can calculate the thermistor’s resistance using the following equation:</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1333.1"><img alt="" role="presentation" src="../Images/B22402_11_003.png"/></span></p>
<p class="normal"><span class="koboSpan" id="kobo.1334.1">In the preceding equation:</span></p>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1335.1">R</span></em><sub class="italic"><span class="koboSpan" id="kobo.1336.1">T</span></sub><span class="koboSpan" id="kobo.1337.1"> is the </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.1338.1">calculated resistance of the thermistor.</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1339.1">R</span></em><sub class="italic"><span class="koboSpan" id="kobo.1340.1">2</span></sub><span class="koboSpan" id="kobo.1341.1"> is the resistance of a resistor with a known value.</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1342.1">V</span></em><sub class="italic"><span class="koboSpan" id="kobo.1343.1">CC</span></sub><span class="koboSpan" id="kobo.1344.1"> is the power supply voltage.</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1345.1">V</span></em><sub class="italic"><span class="koboSpan" id="kobo.1346.1">ADC</span></sub><span class="koboSpan" id="kobo.1347.1"> is the voltage measured by the ADC.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1348.1">We can model a voltage divider using a simple </span><code class="inlineCode"><span class="koboSpan" id="kobo.1349.1">struct</span></code><span class="koboSpan" id="kobo.1350.1"> in C++, shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1351.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1352.1">voltage_divider</span></span><span class="koboSpan" id="kobo.1353.1"> {
        units::resistance r2;
        units::voltage vcc;
        </span><span class="hljs-function"><span class="koboSpan" id="kobo.1354.1">units::resistance </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1355.1">get_r1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1356.1">(units::voltage vadc)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1357.1">{
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1358.1">return</span></span><span class="koboSpan" id="kobo.1359.1"> r2 * (vcc/vadc - </span><span class="hljs-number"><span class="koboSpan" id="kobo.1360.1">1</span></span><span class="koboSpan" id="kobo.1361.1">);
        }
    };
voltage_divider divider{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1362.1">10e3</span></span><span class="koboSpan" id="kobo.1363.1">_Ohm, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1364.1">3.3</span></span><span class="koboSpan" id="kobo.1365.1">_V};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1366.1">This code shows the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1367.1">struct</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.1368.1">voltage_divider</span></code><span class="koboSpan" id="kobo.1369.1">. </span><span class="koboSpan" id="kobo.1369.2">We will go through its details:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1370.1">It uses strong type resistance and voltage defined in namespace units. </span><span class="koboSpan" id="kobo.1370.2">You can check the implementation details for these strong types in the project folder, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1371.1">Chapter11/compile_time/util</span></code><span class="koboSpan" id="kobo.1372.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1373.1">We instantiate an object of voltage_divider using list initialization as in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1374.1">voltage_divider divider{10e3_Ohm, 3.3_V}</span></code><span class="koboSpan" id="kobo.1375.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1376.1">10e3_Ohm</span></code><span class="koboSpan" id="kobo.1377.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1378.1">3.3_V</span></code><span class="koboSpan" id="kobo.1379.1"> are user-defined literals for types </span><code class="inlineCode"><span class="koboSpan" id="kobo.1380.1">resistance</span></code><span class="koboSpan" id="kobo.1381.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1382.1">voltage</span></code><span class="koboSpan" id="kobo.1383.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1384.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1385.1">struct</span></code><span class="koboSpan" id="kobo.1386.1"> has a single method, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1387.1">units::resistance get_r1(units::voltage vadc)</span></code><span class="koboSpan" id="kobo.1388.1">. </span><span class="koboSpan" id="kobo.1388.2">It calculates the R1 value from a voltage divider circuit based on the provided </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.1389.1">voltage on ADC. </span><span class="koboSpan" id="kobo.1389.2">In our case, this is the thermistor’s resistance.</span></li>
</ul>
<h3 class="heading-3" id="_idParaDest-165"><span class="koboSpan" id="kobo.1390.1">Analyzing the usage example firmware code</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1391.1">Next, we </span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.1392.1">will go through the firmware code in a while loop in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1393.1">main</span></code><span class="koboSpan" id="kobo.1394.1"> function from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1395.1">Chapter11/compile_time/app/src/main_lookup_table.cpp</span></code><span class="koboSpan" id="kobo.1396.1">. </span><span class="koboSpan" id="kobo.1396.2">It is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1397.1">auto</span></span><span class="koboSpan" id="kobo.1398.1"> adc_val = adc.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1399.1">get_reading</span></span><span class="koboSpan" id="kobo.1400.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1401.1">if</span></span><span class="koboSpan" id="kobo.1402.1">(adc_val) {
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1403.1">auto</span></span><span class="koboSpan" id="kobo.1404.1"> adc_val_voltage = *adc_val;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1405.1">auto</span></span><span class="koboSpan" id="kobo.1406.1"> thermistor_r = divider.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1407.1">get_r1</span></span><span class="koboSpan" id="kobo.1408.1">(adc_val_voltage);
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1409.1">auto</span></span><span class="koboSpan" id="kobo.1410.1"> it = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1411.1">lower_bound</span></span><span class="koboSpan" id="kobo.1412.1">(resistance.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1413.1">begin</span></span><span class="koboSpan" id="kobo.1414.1">(),    
                resistance.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1415.1">end</span></span><span class="koboSpan" id="kobo.1416.1">(), thermistor_r.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1417.1">get</span></span><span class="koboSpan" id="kobo.1418.1">());
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1419.1">if</span></span><span class="koboSpan" id="kobo.1420.1">(it != resistance.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1421.1">end</span></span><span class="koboSpan" id="kobo.1422.1">()) {
     std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.1423.1">size_t</span></span><span class="koboSpan" id="kobo.1424.1"> pos = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1425.1">distance</span></span><span class="koboSpan" id="kobo.1426.1">(resistance.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1427.1">begin</span></span><span class="koboSpan" id="kobo.1428.1">(), it);
     </span><span class="hljs-type"><span class="koboSpan" id="kobo.1429.1">float</span></span><span class="koboSpan" id="kobo.1430.1"> temperature = temperature_celsius.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1431.1">at</span></span><span class="koboSpan" id="kobo.1432.1">(pos);
     </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1433.1">printf</span></span><span class="koboSpan" id="kobo.1434.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1435.1">"%d mV, %d Ohm, %d.%d C\r\n"</span></span><span class="koboSpan" id="kobo.1436.1">,
           </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1437.1">static_cast</span></span><span class="koboSpan" id="kobo.1438.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1439.1">int</span></span><span class="koboSpan" id="kobo.1440.1">&gt;(adc_val_voltage.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1441.1">get_mili</span></span><span class="koboSpan" id="kobo.1442.1">()),
           </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1443.1">static_cast</span></span><span class="koboSpan" id="kobo.1444.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1445.1">int</span></span><span class="koboSpan" id="kobo.1446.1">&gt;(thermistor_r.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1447.1">get</span></span><span class="koboSpan" id="kobo.1448.1">()),
           </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1449.1">static_cast</span></span><span class="koboSpan" id="kobo.1450.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1451.1">int</span></span><span class="koboSpan" id="kobo.1452.1">&gt;(temperature),
           </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1453.1">static_cast</span></span><span class="koboSpan" id="kobo.1454.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1455.1">int</span></span><span class="koboSpan" id="kobo.1456.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1457.1">10</span></span><span class="koboSpan" id="kobo.1458.1">*(temperature-std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1459.1">floor</span></span><span class="koboSpan" id="kobo.1460.1">(temperature))) );
    }
  }
hal::time::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1461.1">delay_ms</span></span><span class="koboSpan" id="kobo.1462.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1463.1">200</span></span><span class="koboSpan" id="kobo.1464.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1465.1">Let us analyze</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.1466.1"> this code in detail:</span></p>
<ol>
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1467.1">We are calling the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1468.1">get_reading</span></code><span class="koboSpan" id="kobo.1469.1"> method on the object </span><code class="inlineCode"><span class="koboSpan" id="kobo.1470.1">adc</span></code><span class="koboSpan" id="kobo.1471.1">. </span><span class="koboSpan" id="kobo.1471.2">It is of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1472.1">hal::adc_stm32</span></code><span class="koboSpan" id="kobo.1473.1">, and it returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.1474.1">std::expected&lt;units::voltage, adc::error&gt;</span></code><span class="koboSpan" id="kobo.1475.1">. </span><span class="koboSpan" id="kobo.1475.2">It is an error-handling technique that we covered in </span><a href="Chapter_07.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1476.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.1477.1">. </span><span class="koboSpan" id="kobo.1477.2">You can check the implementation details of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1478.1">adc_stm32</span></code><span class="koboSpan" id="kobo.1479.1"> class in the project folder, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1480.1">Chapter11/compile_time/hal/adc</span></code><span class="koboSpan" id="kobo.1481.1">.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1482.1">If the call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1483.1">get_reading</span></code><span class="koboSpan" id="kobo.1484.1"> was successful, we dereference the returned object to get access to the voltage, which we pass to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1485.1">voltage_divider</span></code><span class="koboSpan" id="kobo.1486.1">'s </span><code class="inlineCode"><span class="koboSpan" id="kobo.1487.1">get_r1</span></code><span class="koboSpan" id="kobo.1488.1"> method to calculate the thermistor’s value.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1489.1">Next, we use the algorithm </span><code class="inlineCode"><span class="koboSpan" id="kobo.1490.1">std::lower_bound</span></code><span class="koboSpan" id="kobo.1491.1"> to get an iterator to the first element in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1492.1">resistance</span></code><span class="koboSpan" id="kobo.1493.1"> signal that is not ordered before calculating the thermistor’s value. </span><span class="koboSpan" id="kobo.1493.2">If we find such an element, we calculate its position using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1494.1">std::distance</span></code><span class="koboSpan" id="kobo.1495.1">, and index </span><code class="inlineCode"><span class="koboSpan" id="kobo.1496.1">temperature_celsius</span></code><span class="koboSpan" id="kobo.1497.1"> to get the temperature value.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1498.1">Finally, we print the ADC’s voltage, the thermistor’s resistance, and the temperature value. </span><span class="koboSpan" id="kobo.1498.2">Note that we printed the float value of temperature using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1499.1">ints</span></code><span class="koboSpan" id="kobo.1500.1">, as printing floats increases the binary size of the firmware.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.1501.1">To run the firmware in the Renode simulator on the STM32 target, start Visual Studio Code, attach it to the running container, and open the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1502.1">Chapter11/compile_time</span></code><span class="koboSpan" id="kobo.1503.1"> project, as described in </span><a href="Chapter_04.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1504.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.1505.1">, then run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1506.1">$ cd Chapter11/compile_time
$ cmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel -DMAIN_CPP_FILE_NAME=main_lookup_table.cpp
$ cmake --build build --target run_in_renode
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1507.1">To simulate </span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.1508.1">voltage on the ADC, please enter the following command in the terminal running Renode:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1509.1">$ adc FeedVoltageSampleToChannel 0 1700 3
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1510.1">The preceding command will feed a voltage of 1700 mV to the ADC in three successive readings. </span><span class="koboSpan" id="kobo.1510.2">This will result in the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1511.1">1699 mV, 9412 Ohm, 26.2 C
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1512.1">This command shows that for a value of 1700 mV on the ADC, we calculated a thermistor value of 9412 Ohms, resulting in a temperature of 26.2</span><sup class="superscript"><span class="koboSpan" id="kobo.1513.1">0</span></sup><span class="koboSpan" id="kobo.1514.1">C. </span><span class="koboSpan" id="kobo.1514.2">As an exercise, feed the simulation with different ADC voltage values and compare the results with the curve graph from previous steps.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1515.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1516.1">constexpr</span></code><span class="koboSpan" id="kobo.1517.1"> specifier is a flexible tool in C++ allowing us to run a function at both compile time and runtime. </span><span class="koboSpan" id="kobo.1517.2">If we want to make sure that a function is evaluated only at compile time, we can use the consteval specifier.</span></p>
<h1 class="heading-1" id="_idParaDest-166"><span class="koboSpan" id="kobo.1518.1">consteval specifier</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1519.1">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.1520.1">consteval specifier</span></strong><span class="koboSpan" id="kobo.1521.1"> may be </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.1522.1">applied only to functions. </span><span class="koboSpan" id="kobo.1522.2">It specifies that a function is a so-called immediate function and that every call to it must result in a compile-time constant. </span><span class="koboSpan" id="kobo.1522.3">Let’s go through the following simple example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1523.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1524.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1525.1">square</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1526.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1527.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1528.1"> x)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1529.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1530.1">return</span></span><span class="koboSpan" id="kobo.1531.1"> x*x;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1532.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1533.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1534.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1535.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1536.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1537.1">int</span></span><span class="koboSpan" id="kobo.1538.1"> arg = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1539.1">2</span></span><span class="koboSpan" id="kobo.1540.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1541.1">int</span></span><span class="koboSpan" id="kobo.1542.1"> ret = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1543.1">square</span></span><span class="koboSpan" id="kobo.1544.1">(arg);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1545.1">return</span></span><span class="koboSpan" id="kobo.1546.1"> ret;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1547.1">If you run this example in Compiler Explorer using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1548.1">x86-64 GCC 14.2</span></code><span class="koboSpan" id="kobo.1549.1"> compiler, without optimization enabled, we can observe the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1550.1">The program returns 4.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1551.1">The resulting assembly is small, and it just moves 4 to the return register.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1552.1">Removing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1553.1">constexpr</span></code><span class="koboSpan" id="kobo.1554.1"> specifier from the variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.1555.1">arg</span></code><span class="koboSpan" id="kobo.1556.1"> will result in the function square being generated and a call to it in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1557.1">main</span></code><span class="koboSpan" id="kobo.1558.1"> function.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1559.1">Now, let’s change the function </span><code class="inlineCode"><span class="koboSpan" id="kobo.1560.1">square</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.1561.1">constexpr</span></code><span class="koboSpan" id="kobo.1562.1"> specifier to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1563.1">consteval</span></code><span class="koboSpan" id="kobo.1564.1">, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1565.1">consteval</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1566.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1567.1">square</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1568.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1569.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1570.1"> x)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1571.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1572.1">return</span></span><span class="koboSpan" id="kobo.1573.1"> x*x;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1574.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1575.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1576.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1577.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1578.1">constexpr</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1579.1">int</span></span><span class="koboSpan" id="kobo.1580.1"> arg = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1581.1">2</span></span><span class="koboSpan" id="kobo.1582.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1583.1">int</span></span><span class="koboSpan" id="kobo.1584.1"> ret = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1585.1">square</span></span><span class="koboSpan" id="kobo.1586.1">(arg);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1587.1">return</span></span><span class="koboSpan" id="kobo.1588.1"> ret;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1589.1">If you run the program in Compiler Explorer, it will return </span><code class="inlineCode"><span class="koboSpan" id="kobo.1590.1">4</span></code><span class="koboSpan" id="kobo.1591.1"> and result in small assembly code. </span><span class="koboSpan" id="kobo.1591.2">However, if we now remove the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1592.1">constexpr</span></code><span class="koboSpan" id="kobo.1593.1"> specifier from the variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.1594.1">arg</span></code><span class="koboSpan" id="kobo.1595.1">, the compilation will fail with the following error:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1596.1">&lt;source&gt;: In function 'int main()':
&lt;source&gt;:7:21: error: call to consteval function 'square(arg)' is not a constant expression
    7 |     int ret = square(arg);
      |               ~~~~~~^~~~~
&lt;source&gt;:7:21: error: the value of 'arg' is not usable in a constant expression
&lt;source&gt;:6:9: note: 'int arg' is not const
    6 |     int arg = 2;
      |         ^~~
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1597.1">The consteval specifier</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.1598.1"> ensures that a function is evaluated only at compile time. </span><span class="koboSpan" id="kobo.1598.2">This prevents the function from being accidentally run at runtime, which could happen with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1599.1">constexpr</span></code><span class="koboSpan" id="kobo.1600.1"> function.</span></p>
<h1 class="heading-1" id="_idParaDest-167"><span class="koboSpan" id="kobo.1601.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1602.1">In this chapter, we explored techniques for compile-time computation in C++. </span><span class="koboSpan" id="kobo.1602.2">We covered the basics of TMP and provided an in-depth explanation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1603.1">constexpr</span></code><span class="koboSpan" id="kobo.1604.1"> specifier, using examples relevant to embedded systems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1605.1">With the knowledge from this chapter, you can generate lookup tables and convert human-readable addresses, UUIDs, and similar data into arrays used by communication stacks, all at compile time. </span><span class="koboSpan" id="kobo.1605.2">This allows you to write expressive code that generates complex mathematical signals without consuming extra memory or processing time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1606.1">Next, we will go over the techniques used in writing a HAL in C++.</span></p>
<h1 class="heading-1" id="_idParaDest-168"><span class="koboSpan" id="kobo.1607.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1608.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="https://packt.link/embeddedsystems"><span class="url"><span class="koboSpan" id="kobo.1609.1">https://packt.link/embeddedsystems</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.1610.1"><img alt="" role="presentation" src="../Images/QR_code_Discord.png"/></span></p>
</div>
</body></html>