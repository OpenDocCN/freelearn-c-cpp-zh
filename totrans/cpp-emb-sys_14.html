<html><head></head><body>
<div><h1 class="chapterNumber">11</h1>
<h1 class="chapterTitle" id="_idParaDest-157">Compile-Time Computation</h1>
<p class="normal"><strong class="keyWord">Compile-time computation</strong> refers <a id="_idIndexMarker506"/>to the ability of a compiler to execute functions at compile time, instead of converting them to machine code. This means that the results of complex operations can be calculated by the compiler and stored in variables that are used at runtime. A compiler can execute a function at compile time only if all arguments of the function are known at compile time.</p>
<p class="normal">We can use compile-time computation in C++ firmware to calculate complex math operations, generate lookup tables and arrays in general, and use the generated values at runtime. Performing these operations at compile time will save valuable memory and processor (space and time) resources and make them available for other, more important operations.</p>
<p class="normal">The goal of this chapter is to learn how to use compile-time computation in C++ to shift complex operations at compile time and save valuable resources. In this chapter, we’re going to cover the following main topics: </p>
<ul>
<li class="bulletList">Templates</li>
<li class="bulletList">The <code class="inlineCode">constexpr</code> specifier</li>
<li class="bulletList">The consteval specifier</li>
</ul>
<h1 class="heading-1" id="_idParaDest-158">Technical requirements</h1>
<p class="normal">To get the most out of this chapter, I strongly recommend using Compiler Explorer (<a href="https://godbolt.org/">https://godbolt.org/</a>) as you read through the examples. Select GCC as your compiler for x86 architecture. This will allow you to see standard output (stdio) results and better observe the code’s behavior. As we are using a lot of modern C++ features, make sure to select the C++23 standard by adding <code class="inlineCode">-std=c++23</code> to the compiler options box.</p>
<p class="normal">Compiler Explorer makes it easy to try out the code, tweak it, and immediately see how it affects the output and generated assembly code. Most of the examples can also be run in the Renode simulator on an ARM Cortex-M0 target and are available on GitHub (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter11">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter11</a>).</p>
<h1 class="heading-1" id="_idParaDest-159">Templates</h1>
<p class="normal">The first available mechanism <a id="_idIndexMarker507"/>for compile-time computation in C++ was <strong class="keyWord">Template Meta-Programming (TMP)</strong>. Using TMP, we<a id="_idIndexMarker508"/> can store the results of operations in types, as shown in the following example of computing the factorial:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;unsigned int N&gt;
<code class="inlineCode">struct</code> factorial {
    static const unsigned int value = N * factorial&lt;N-1&gt;::value;
};
template &lt;&gt;
<code class="inlineCode">struct</code> factorial&lt;0&gt; {
    static const unsigned int value = 1;
};
int main () {
    const int fact = factorial&lt;5&gt;::value;
    return fact;
}
</code></pre>
<p class="normal">If you run this <a id="_idIndexMarker509"/>example in Compiler Explorer (even without optimizations), you will see that it returns 120. The generated assembly code is short and does not contain any function calls. It simply places the value 120 in the return register in the <code class="inlineCode">main</code> function, meaning the factorial computation was done at compile time. You can see the generated assembly code here:</p>
<pre class="programlisting code"><code class="hljs-code">main:
push rbp
mov rbp, rsp
mov DWORD PTR [rbp-4], 120
mov eax, 120
pop rbp
ret
</code></pre>
<p class="normal">We performed the following steps in the preceding example:</p>
<ul>
<li class="bulletList">We defined a class template factorial. It has an unsigned int, N, as the parameter and only one member: <code class="inlineCode">static const unsigned int value = N * factorial&lt;N-1&gt;::value</code>.</li>
<li class="bulletList">In the assignment expression of the member <code class="inlineCode">value</code>, we use recursion at the template level as we calculate it by multiplying <code class="inlineCode">N</code> by the <code class="inlineCode">value</code> from the factorial instantiated with <code class="inlineCode">N – 1</code>.</li>
<li class="bulletList">We define factorial template specialization for 0, making it a base type that will stop recursion, meaning that <code class="inlineCode">factorial&lt;0&gt;::value</code> will contain <code class="inlineCode">1</code>.</li>
</ul>
<p class="normal">To better understand the recursion at the template level, we will write down the entire recursion chain for the preceding example:</p>
<ul>
<li class="bulletList"><code class="inlineCode">factorial&lt;5&gt;::value = 5 * factorial&lt;4&gt;::value;</code></li>
<li class="bulletList"><code class="inlineCode">factorial&lt;4&gt;::value = 4 * factorial&lt;3&gt;::value;</code></li>
<li class="bulletList"><code class="inlineCode">factorial&lt;3&gt;::value = 3 * factorial&lt;2&gt;::value;</code></li>
<li class="bulletList"><code class="inlineCode">factorial&lt;2&gt;::value = 2 * factorial&lt;1&gt;::value;</code></li>
<li class="bulletList"><code class="inlineCode">factorial&lt;1&gt;::value = 1 * factorial&lt;0&gt;::value;</code></li>
<li class="bulletList"><code class="inlineCode">factorial&lt;0&gt;::value = 1;</code></li>
</ul>
<p class="normal">If we substitute the base value of <code class="inlineCode">factorial&lt;0&gt;</code> with <code class="inlineCode">1</code>, back up the chain, we have the following:</p>
<ul>
<li class="bulletList"><code class="inlineCode">factorial&lt;1&gt;::value = 1 * 1 = 1</code></li>
<li class="bulletList"><code class="inlineCode">factorial&lt;2&gt;::value = 2 * 1 = 2</code></li>
<li class="bulletList"><code class="inlineCode">factorial&lt;3&gt;::value = 3 * 2 = 6</code></li>
<li class="bulletList"><code class="inlineCode">factorial&lt;4&gt;::value = 4 * 6 = 24</code></li>
<li class="bulletList"><code class="inlineCode">factorial&lt;5&gt;::value = 5 * 24 = 120</code></li>
</ul>
<p class="normal">The <code class="inlineCode">main</code> function <a id="_idIndexMarker510"/>computes the factorial of <code class="inlineCode">5</code> by accessing <code class="inlineCode">factorial&lt;5&gt;::value</code> and returns it. The recursion is terminated by the specialized template for <code class="inlineCode">factorial&lt;0&gt;</code>, which provides the base case. The final result is that the program returns <code class="inlineCode">120</code>, the factorial of <code class="inlineCode">5</code>.</p>
<p class="normal">While TMP allows for compile-time computations, it often involves complex recursive patterns that can be difficult to read and maintain. To address these challenges, C++11 introduced the <code class="inlineCode">constexpr</code> specifier, which has become the preferred mechanism for compile-time computations.</p>
<h1 class="heading-1" id="_idParaDest-160">constexpr specifier</h1>
<p class="normal">Using the <code class="inlineCode">constexpr</code><strong class="keyWord"> specifier</strong>, we <a id="_idIndexMarker511"/>declare that it is possible to evaluate variables and functions at compile time. There are limitations to what can be evaluated at compile time. A <code class="inlineCode">constexpr</code> variable must meet the following requirements:</p>
<ul>
<li class="bulletList">It needs to be of a <code class="inlineCode">literal</code> type, any of the following:<ul>
<li class="bulletList">Scalar types such as arithmetic types, enumerations, and pointers</li>
<li class="bulletList">Reference types</li>
<li class="bulletList">An array of <code class="inlineCode">literal</code> types</li>
</ul>
</li>
<li class="bulletList">Classes that meet specific requirements (such as a trivial <code class="inlineCode">constexpr</code> de<code class="inlineCode">struct</code>or, all of its non-static data members are <code class="inlineCode">literal</code> types, or at least one <code class="inlineCode">constexpr</code> con<code class="inlineCode">struct</code>or).</li>
<li class="bulletList">It must be immediately initialized.</li>
<li class="bulletList">The entire expression of its initialization needs to be a constant expression.</li>
</ul>
<p class="normal">Let’s go through the following example to better understand the requirements for <code class="inlineCode">constexpr</code> variables:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cmath&gt;
int main () {
    <code class="inlineCode">constexpr</code> int ret = round(sin(3.14));
    return ret;
}
</code></pre>
<p class="normal">If you run this example in Compiler Explorer using <code class="inlineCode">x86-64 GCC 14.2</code> compiler, without optimization enabled, we can observe the following:</p>
<ul>
<li class="bulletList">The program returns <code class="inlineCode">0</code>.</li>
<li class="bulletList">The resulting assembly is small, and it just moves <code class="inlineCode">0</code> to return the register.</li>
<li class="bulletList">If you change the initialization of the <code class="inlineCode">ret</code> variable so that the sine function takes <code class="inlineCode">3.14/2</code> as the argument, the program will return <code class="inlineCode">1</code>.</li>
</ul>
<p class="normal">Now, if we try to change the compiler in Compiler Explorer to <code class="inlineCode">x86-64 clang 18.1.0</code>, we will get the following compiler error:</p>
<pre class="programlisting con"><code class="hljs-con">&lt;source&gt;:4:19: error: constexpr variable 'ret' must be initialized by a constant expression
    4 |     constexpr int ret = round(sin(3.14));
      |                   ^     ~~~~~~~~~~~~~~~~
&lt;source&gt;:4:31: note: non-constexpr function 'sin' cannot be used in a constant expression
    4 |     constexpr int ret = round(sin(3.14));
</code></pre>
<p class="normal">The compiler reports that we are violating the rule that says that the entire expression of its initialization needs to be a constant expression, as the function <code class="inlineCode">sin,</code> in the expression <code class="inlineCode">round(sin(3.14))</code>, is non-<code class="inlineCode">constexpr</code>. This is because Clang’s implementation of math functions is non-<code class="inlineCode">constexpr</code>, while GCC implements them as <code class="inlineCode">constexpr</code> functions. Many math functions will be <code class="inlineCode">constexpr</code> functions in the new C++26 standard.</p>
<p class="normal">Although the upcoming C++26 standard mandates that math functions should be <code class="inlineCode">constexpr</code>, we will utilize the current GCC implementation because it is the compiler we are using for our STM32 target in the examples throughout this book. All <code class="inlineCode">constexpr</code> functions must meet the following <a id="_idIndexMarker512"/>requirements:</p>
<ul>
<li class="bulletList">Its <code class="inlineCode">return</code> type must be of the <code class="inlineCode">literal</code> type.</li>
<li class="bulletList">Each of its parameters must be of the <code class="inlineCode">literal</code> type.</li>
<li class="bulletList">If a function is not a con<code class="inlineCode">struct</code>or, it must have only one <code class="inlineCode">return</code> statement.</li>
</ul>
<p class="normal">To better understand <code class="inlineCode">constexpr</code> functions, let us implement the factorial algorithm as a <code class="inlineCode">constexpr</code> function in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">constexpr unsigned int factorial(unsigned int n) {
    unsigned int prod = 1;
    while(n &gt; 0) {
        prod *= n;
        n--;
    }
    return prod;
}
int main () {
    constexpr int calc_val = 5;
    constexpr unsigned int ret = factorial(calc_val);
    return ret;
}
</code></pre>
<p class="normal">In this example, we<a id="_idIndexMarker513"/> implemented the <code class="inlineCode">factorial</code> algorithm as a simple <code class="inlineCode">constexpr</code> function. Comparing it to a TMP-based solution, this code looks familiar to many developers with a C background. There is no recursion at the template level and strange syntax. C++11 <code class="inlineCode">constexpr</code> functions still relied on recursion, but C++14 relaxed constraints on <code class="inlineCode">constexpr</code> functions and allowed using local variables and loops.</p>
<p class="normal">If we run the preceding example in Compiler Explorer using the <code class="inlineCode">x86-64 GCC 14.2</code> compiler, without optimization enabled, we can observe the following:</p>
<ul>
<li class="bulletList">The program returns 120.</li>
<li class="bulletList">The resulting assembly is small, and it just moves 120 to the return register.</li>
<li class="bulletList">There is no <code class="inlineCode">factorial</code> function in the resulting assembly code, meaning that the compiler executed this function at compile time. We supplied a factorial function with a constant expression argument and the compiler evaluated the function at compile time.</li>
<li class="bulletList">If we remove the <code class="inlineCode">constexpr</code> specifier from the <code class="inlineCode">calc_val</code> and <code class="inlineCode">ret</code> variables declarations, we will see the <code class="inlineCode">factorial</code> function in the resulting assembly call, and in <code class="inlineCode">main</code>, we will see a call to this function, meaning that in this case, the <code class="inlineCode">factorial</code> function is being executed at runtime, and in the case of firmware, it will be part of<a id="_idIndexMarker514"/> the binary.</li>
</ul>
<p class="normal">As we can see from this example, the <code class="inlineCode">constexpr</code> function can be executed at both compile time and runtime, depending on the arguments we supply it with. Next, we will go over practical examples to see how we can apply the <code class="inlineCode">constexpr</code> specifier in firmware development.</p>
<h2 class="heading-2" id="_idParaDest-161">Example 1 – MAC address parser</h2>
<p class="normal">The <strong class="keyWord">Medium Access Control</strong> (<strong class="keyWord">MAC</strong>) address<a id="_idIndexMarker515"/> is used in the MAC layer of different communication stacks, including Ethernet, Wi-Fi, and Bluetooth. Here, we will create a 48-bit MAC address compile-time parser that will help us convert a common format of a MAC address written as hex numbers separated by a colon into an array of <code class="inlineCode">uint8_t</code>, which is usually used in software stacks. The code is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;array&gt;
#include &lt;cstdint&gt;
#include &lt;string_view&gt;
#include &lt;charconv&gt;
<code class="inlineCode">struct</code> mac_address {
    static constexpr std::size_t c_bytes_num = 6;
    static constexpr std::size_t c_mac_addr_str_size = 17;
   
    std::array&lt;uint8_t, c_bytes_num&gt; bytes{};
    bool is_valid = false;
    constexpr mac_address(std::string_view str) {
        if (str.size() != c_mac_addr_str_size) {
            return;
        }
        for (size_t i = 0; i &lt; c_bytes_num; ++i) {
            const std::string_view byte_str = str.substr(i * 3, 2);
            uint8_t value = 0;
            auto result = std::from_chars(byte_str.data(), byte_str.data() 
 + byte_str.size(), value, 16);
            if (result.ec != std::errc()) {
                return;
            }
            bytes[i] = value;
        }
        is_valid = true;
    }
};
int main () {
    constexpr mac_address addr("00:11:22:33:44:55");
    static_assert(addr.is_valid);
    return addr.bytes.at(5);
}
</code></pre>
<p class="normal">In the <code class="inlineCode">main</code> function, we <a id="_idIndexMarker516"/>create an instance of the <code class="inlineCode">struct</code> <code class="inlineCode">mac_address</code>, by providing a con<code class="inlineCode">struct</code>or with <code class="inlineCode">"00:11:22:33:44:55"</code>. If we run the preceding example in Compiler Explorer using the x86-64 GCC 14.2 compiler, without optimization enabled, we can observe the following:</p>
<ul>
<li class="bulletList">The program returns <code class="inlineCode">85</code> as a decimal number. Converting it to hex format, we will get 0x55, which corresponds to the last byte from the MAC address <code class="inlineCode">00:11:22:33:44:55</code>.</li>
<li class="bulletList">The resulting assembly is small. It populates the stack with bytes from the MAC address we used in the con<code class="inlineCode">struct</code>or. There are no calls to the con<code class="inlineCode">struct</code>or, meaning it is executed at compile time.</li>
<li class="bulletList">If we change the MAC address provided in the con<code class="inlineCode">struct</code>or to <code class="inlineCode">"000:11:22:33:44:55"</code> or <code class="inlineCode">"G0:11:22:33:44:55"</code>, the compiler will generate an error due to failed <code class="inlineCode">static_assert(addr.is_valid)</code>.</li>
</ul>
<p class="normal">Let us now explain<a id="_idIndexMarker517"/> the <code class="inlineCode">struct</code> <code class="inlineCode">mac_address</code> in more detail:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">struct</code> contains the members <code class="inlineCode">std::array&lt;uint8_t, c_bytes_num&gt; bytes</code> and <code class="inlineCode">bool is_valid</code>. It doesn’t contain any methods except the con<code class="inlineCode">struct</code>or.</li>
<li class="bulletList">The con<code class="inlineCode">struct</code>or accepts the <code class="inlineCode">std::string_view</code> class template, which encapsulates a pointer to the first element of the provided string literal, and its size.</li>
<li class="bulletList">The con<code class="inlineCode">struct</code>or creates substring views using the <code class="inlineCode">susbstr</code> method on the <code class="inlineCode">string_view</code> object and it uses <code class="inlineCode">std::from_char</code> to convert them to <code class="inlineCode">uint8_t</code> values, which are stored in the <code class="inlineCode">bytes</code> array.</li>
<li class="bulletList">The con<code class="inlineCode">struct</code>or sets the bool <code class="inlineCode">is_valid</code> to true if there are no errors. Using <code class="inlineCode">static_assert</code>, we can validate at compile time that the provided MAC address string literal was converted successfully. We cannot use asserts in <code class="inlineCode">constexpr</code> functions. The alternative is to throw an exception, which would result in a compile-time error, but we decided not to use exceptions for our embedded target.</li>
</ul>
<p class="normal">You can also run the preceding example in the Renode simulator on the STM32 target. Start Visual Studio Code, attach it to the running container, and open the <code class="inlineCode">Chapter11/compile_time</code> project, as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ cd Chapter11/compile_time
$ cmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel -DMAIN_CPP_FILE_NAME=main_constexpr_mac_address.cpp
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">Here is part of <a id="_idIndexMarker518"/>the <code class="inlineCode">main</code> function from the <code class="inlineCode">main_constexpr_mac_address.cpp</code> file:</p>
<pre class="programlisting code"><code class="hljs-code">constexpr mac_address addr("00:11:22:33:44:55");
static_assert(addr.is_valid);
const std::array&lt;uint8_t, 6&gt; addr_arr{0x00, 0x11, 0x22, 0x33, 0x44, 0x55};
const auto &amp; mac_ref = addr.bytes;
//const auto &amp; mac_ref = addr_arr;
printf("%02X:%02X:%02X:%02X:%02X:%02X\r\n", mac_ref[0], mac_ref[1], mac_ref[2], mac_ref[3], mac_ref[4], mac_ref[5]);
</code></pre>
<p class="normal">To confirm that all the work of converting a string literal to an array is performed at compile time, you can bind the reference <code class="inlineCode">mac_ref</code> to <code class="inlineCode">addr_arr</code> and compare binary sizes in both cases. They are both 6,564 bytes, meaning that the <code class="inlineCode">constexpr</code> con<code class="inlineCode">struct</code>or is not included in the binary as it is actually executed at compile time by the compiler.</p>
<p class="normal">Next, we will go through an example of creating a lookup table for a temperature thermistor using <code class="inlineCode">constexpr</code> functions in C++.</p>
<h2 class="heading-2" id="_idParaDest-162">Example 2 – Generating a lookup table</h2>
<p class="normal">Thermistors are resistors <a id="_idIndexMarker519"/>whose resistance changes with temperature. They are commonly used in embedded systems. They usually have a non-linear curve. There are different methods to approximate an <strong class="keyWord">Analog-to-Digital Converter</strong> (<strong class="keyWord">ADC</strong>) reading <a id="_idIndexMarker520"/>from a thermistor into a temperature. One of the most used methods is <a id="_idIndexMarker521"/>the <strong class="keyWord">beta coefficient</strong>. It is calculated by measuring the thermistor’s resistance at two temperature points. It is used to calculate temperature using the following equation:</p>
<p class="normal"><img alt="" role="presentation" src="img/B22402_11_001.png"/></p>
<p class="normal">In this equation, <em class="italic">T</em><sub class="italic">0</sub> is a room temperature of 25<sup class="superscript">o</sup>C (298.15K) and <em class="italic">R</em><sub class="italic">0</sub> is the resistance of a thermistor at room temperature. Using the beta coefficient (a constant provided by the manufacturer) is a simplification of the thermistor’s curve as it relies on measuring the curve only at two points.</p>
<p class="normal">The Steinhart-Hart equation provides a more accurate curve-fitting method as it relies on four coefficients calculated by measuring the thermistor at four temperature points. The equation is shown here:</p>
<p class="normal"><img alt="" role="presentation" src="img/B22402_11_002.png"/></p>
<p class="normal">Coefficients <em class="italic">A</em>, <em class="italic">B</em>, <em class="italic">C</em>, and <em class="italic">D</em> are calculated after measuring the thermistor’s temperature at four different temperature points – meaning these are constants that are given for a thermistor by the manufacturer. The calculated temperature from the Steinhart-Hart equation is in Kelvins. The drawback of the Steinhart-Hart equation is it is computationally heavy for small, embedded targets.</p>
<p class="normal">In this example, we will create a lookup table using the Steinhart-Hart equation and rely on it to determine temperature by reading a value from the ADC in our embedded target. As we can see from the equation, temperature is a function of resistance and given constants. For a selected range of resistance, and with a selected resolution, we will generate a lookup table of temperature values. Then, we will simulate a reading of the thermistor resistance and search the lookup table to determine the temperature.</p>
<p class="normal">We will select a range of resistance that we want to base the lookup table on, and the number of points we want to use. For this, we need functionality that will generate an array of numbers in the given range that are evenly spaced, also called linear space. Next, we will use that linear space <a id="_idIndexMarker522"/>as an argument to a signal generator. Let’s start with implementing this as follows:</p>
<ol>
<li class="numberedList" value="1">Here is the code showing the linear space generator:
        <pre class="programlisting code"><code class="hljs-code">#include &lt;array&gt;
#include &lt;cstdio&gt;
template &lt;typename T, std::size_t N&gt;
<code class="inlineCode">struct</code> signal : public std::array&lt;T, N&gt; {
  constexpr signal() {}
  constexpr signal(T begin, T end) {
    static_assert(N &gt; 1, "N must be bigger than 1"); 
    float step = (end - begin) / (N - 1);
    for (std::size_t i = 0; i &lt; N; i++) {
      this-&gt;at(i) = begin + i * step;
    }
  }
};
int main() {
    constexpr signal&lt;float, 10&gt; x_axis(0, 9);
    for(auto elem: x_axis) {
        printf("%.2f, ", elem);
    }
    printf("\r\n");
    return 0;
}
</code></pre>
</li>
</ol>
<p class="normal">If we run this program, it will print 10 numbers in the range of 0 to 10, as shown here:</p>
<pre class="programlisting con"><code class="hljs-con">0.00, 1.00, 2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00, 9.00,
</code></pre>
<p class="normal">The numbers <a id="_idIndexMarker523"/>printed are generated at compile time by the <code class="inlineCode">signal</code> <code class="inlineCode">struct</code>. To connect this back to our example, imagine that these are the values of resistance for which we want to calculate the temperature using the Steinhart-Hart equation. Let’s go through the implementation in detail:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">signal</code> is a class template. Template parameters are <code class="inlineCode">typename T</code> and <code class="inlineCode">std::size_t N</code>. They determine the array type that the <code class="inlineCode">struct</code> is based on.</li>
<li class="bulletList">The <code class="inlineCode">struct</code> derives from <code class="inlineCode">std::array&lt;T, N&gt;</code>. We based it on <code class="inlineCode">std::array</code> to be able to use range-based for loops easily and standard library algorithms.</li>
<li class="bulletList">In the <code class="inlineCode">constexpr</code> con<code class="inlineCode">struct</code>or, we use <code class="inlineCode">static_assert</code> to make sure that <code class="inlineCode">N</code> is greater than 1, and we populate the underlying array with evenly spaced points between <code class="inlineCode">begin</code> and <code class="inlineCode">end</code>.</li>
<li class="bulletList">In <code class="inlineCode">main</code>, we provide <code class="inlineCode">float</code> and <code class="inlineCode">10</code> as template arguments to the <code class="inlineCode">struct signal</code>, and <code class="inlineCode">0</code> and <code class="inlineCode">9</code> as <code class="inlineCode">begin</code> and <code class="inlineCode">end</code> points for the linear space to the con<code class="inlineCode">struct</code>or. We use a range-based for loop to go through elements of the compile-time-generated object <code class="inlineCode">x_axis</code> and print its elements.</li>
</ul>
<ol>
<li class="numberedList" value="2">Next, we will expand the signal <code class="inlineCode">struct</code> with an additional con<code class="inlineCode">struct</code>or that allows us to create a signal based on another signal and a lambda we will use to provide a math function to generate elements of a new signal. The code for a new con<code class="inlineCode">struct</code>or is shown here:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T, std::size_t N&gt;
<code class="inlineCode">struct</code> signal : public std::array&lt;T, N&gt; {
// ...
constexpr signal(const signal &amp;sig, auto fun) {
    for (std::size_t i = 0; i &lt; N; i++) {
      this-&gt;at(i) = fun(sig.at(i));
    }
  }
};
</code></pre>
</li>
</ol>
<p class="normal">In this con<code class="inlineCode">struct</code>or, we <a id="_idIndexMarker524"/>initialize elements of a new signal by calling the passed <code class="inlineCode">fun</code> on elements of the passed signal <code class="inlineCode">sig</code>.</p>
<ol>
<li class="numberedList" value="3">Now we can create a new signal, as shown in this code:
        <pre class="programlisting code"><code class="hljs-code">int main() {
    const auto print_signal = [](auto sig) {
        for(auto elem: sig) {
            printf("%.2f, ", elem);
        }
        printf("\r\n");
    };
    constexpr signal&lt;float, 10&gt; x_axis(0, 9);
    print_signal(x_axis);
    auto sine = signal(x_axis, [](float x){ return std::sin(x);});
    print_signal(sine);
    return 0;
}
</code></pre>
</li>
</ol>
<p class="normal">If you are following the example using Compiler Explorer, make sure to include the <code class="inlineCode">&lt;cmath&gt;</code> header as we are using the <code class="inlineCode">std::sin</code> function. Running it will give the following output:</p>
<pre class="programlisting con"><code class="hljs-con">0.00, 1.00, 2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00, 9.00,
0.00, 0.84, 0.91, 0.14, -0.76, -0.96, -0.28, 0.66, 0.99, 0.41,
</code></pre>
<p class="normal">In this code, we created a new signal named <code class="inlineCode">sine</code> by passing <code class="inlineCode">x_axis</code> and the lambda <code class="inlineCode">[](int x){return std::sin(x);}</code> to the newly created con<code class="inlineCode">struct</code>or.</p>
<p class="normal">To connect <a id="_idIndexMarker525"/>this with the example, now we can generate a lookup table using simple math functions (such as <code class="inlineCode">std::sin</code>) and linear space generated with the signal con<code class="inlineCode">struct</code>or from <em class="italic">step 1</em>.</p>
<h3 class="heading-3" id="_idParaDest-163">Generating a lookup table</h3>
<p class="normal">To generate more complex <a id="_idIndexMarker526"/>functions, we need to expand the <code class="inlineCode">signal</code> class with more functionality:</p>
<ol>
<li class="numberedList" value="1">First, we will overload the operators <code class="inlineCode">*</code> and <code class="inlineCode">/</code>, to multiply signals by constants and divide constants by elements of signal. The code is shown here:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T, std::size_t N&gt;
<code class="inlineCode">struct</code> signal : public std::array&lt;T, N&gt; {
// ...
constexpr signal operator*(const T &amp;t) const {
    return signal(*this, [&amp;](T elem)
                  { return elem * t; });
  };
  constexpr signal operator/(const T &amp;t) const {
    return signal(*this, [&amp;](T elem)
                  { return elem / t; });
  };
 };
</code></pre>
</li>
</ol>
<p class="normal">In this code, we <a id="_idIndexMarker527"/>overloaded the operators <code class="inlineCode">*</code> and <code class="inlineCode">/</code>, enabling multiplication and division of a signal with a scalar, as in:</p>
<pre class="programlisting con"><code class="hljs-con">auto result = sig * 2.0f;
</code></pre>
<p class="normal">The preceding code will create a new signal called <code class="inlineCode">result</code>, which will be the result of the multiplication of every element of signal <code class="inlineCode">sig</code> by scalar <code class="inlineCode">2.0</code>.</p>
<ol>
<li class="numberedList" value="2">Similarly, we can create a new signal by dividing the existing signal by a scalar, as shown here:
        <pre class="programlisting code"><code class="hljs-code">auto result = sig / 2.0f;
</code></pre>
</li>
</ol>
<p class="normal">This code will create a new signal called <code class="inlineCode">result</code>, which will be the result of the division of every element of signal <code class="inlineCode">sig</code> by scalar <code class="inlineCode">2.0</code>.</p>
<ol>
<li class="numberedList" value="3">To support scalars from the left side of operators <code class="inlineCode">*</code> and <code class="inlineCode">/</code>, we need to implement the global operators <code class="inlineCode">operator*</code> and <code class="inlineCode">operator/</code>. We will do so by declaring them as friends to the <code class="inlineCode">struct signal</code>, as shown here:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T, std::size_t N&gt;
struct signal : public std::array&lt;T, N&gt; {
// ...
friend constexpr signal operator*(const T &amp;t, const signal &amp;sig)
  {
    return sig * t;
  }
  friend constexpr signal operator/(const T &amp;t, const signal &amp;sig)
  {
    signal ret;
    for (std::size_t i = 0; i &lt; N; i++) {
      ret.at(i) = t / sig.at(i);
    }
    return ret;
  }
};
</code></pre>
</li>
</ol>
<p class="normal">The friend <a id="_idIndexMarker528"/>function <code class="inlineCode">operator*</code> in this code allows scalar multiplication when the scalar is on the left-hand side (scalar * signal), which is not possible with the member function alone. As multiplication has a commutative property (<em class="italic">a * b = b * a</em>), we simply call the member function <code class="inlineCode">operator*</code> and return the result (<code class="inlineCode">return sig * t</code>).</p>
<ol>
<li class="numberedList" value="4">In the friend function <code class="inlineCode">operator/</code>, we perform the following steps:<ol>
<li class="numberedList" value="1">Create a new signal, <code class="inlineCode">ret</code>.</li>
<li class="numberedList">Iterate over the elements of the signal <code class="inlineCode">sig</code>, and for each element, the scalar <code class="inlineCode">t</code> is divided by the element.</li>
<li class="numberedList">We return the signal <code class="inlineCode">ret</code>.</li>
</ol>
</li>
<li class="numberedList">By overloading the operators <code class="inlineCode">*</code> and <code class="inlineCode">/</code> both as global and as member functions, we can now create signals as in the following example:
        <pre class="programlisting code"><code class="hljs-code">int main() {
    // ...
constexpr signal&lt;float, 10&gt; x_axis(0, 9);
    print_signal(x_axis);
    auto linear_fun = 2.f * x_axis;
    print_signal(linear_fun);
    auto linear_fun2 = linear_fun / 2.f;
    print_signal(linear_fun2);
    return 0;
}
</code></pre>
</li>
</ol>
<p class="normal">This code will<a id="_idIndexMarker529"/> result in the following output:</p>
<pre class="programlisting con"><code class="hljs-con">0.00, 1.00, 2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00, 9.00,
0.00, 2.00, 4.00, 6.00, 8.00, 10.00, 12.00, 14.00, 16.00, 18.00,
0.00, 1.00, 2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00, 9.00,
</code></pre>
<p class="normal">As we can see from this output, the originally created <code class="inlineCode">x_axis</code>, representing linear space from 0 to 9.00 with 10 points, is multiplied by 2.0 to create <code class="inlineCode">linear_fun</code>. Then we divide <code class="inlineCode">linear_fun</code> by 2.0 to create <code class="inlineCode">linear_fun2</code>, which matches the <code class="inlineCode">x_axis</code>.</p>
<ol>
<li class="numberedList" value="6">To be able to<a id="_idIndexMarker530"/> write the full Steinhart-Hart equation, we also need to overload operators <code class="inlineCode">+</code> and <code class="inlineCode">-</code>, as shown here:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T, std::size_t N&gt;
struct signal : public std::array&lt;T, N&gt; {
// ...
constexpr signal operator+(const T &amp;t) const {
    return signal(*this, [&amp;](T elem)
                  { return elem + t; });
  };
  constexpr signal operator-(const T &amp;t) const {
    return signal(*this, [&amp;](T elem)
                  { return elem - t; });
  };
  constexpr signal operator+(const signal &amp;sig) const {
    signal ret;
    for (std::size_t i = 0; i &lt; N; i++)
    {
      ret.at(i) = this-&gt;at(i) + sig.at(i);
    }
    return ret;
  };
  friend constexpr signal operator+(const T &amp;t, const signal &amp;sig)
  {
    return sig + t;
  }
};
</code></pre>
</li>
</ol>
<p class="normal">In this code, we overload the following operators:</p>
<ul>
<li class="bulletList">A member <code class="inlineCode">constexpr signal operator+(const T &amp;t)</code>, allowing us to add a scalar to a signal (signal + scalar)</li>
<li class="bulletList">A member <code class="inlineCode">constexpr signal operator-(const T &amp;t)</code>, allowing us to subtract a scalar from a signal (signal - scalar)</li>
<li class="bulletList">A member <code class="inlineCode">constexpr signal operator+(const signal &amp;sig)</code>, allowing us to <a id="_idIndexMarker531"/>add two signals, element by element (signal1 + signal2)</li>
<li class="bulletList">Global <code class="inlineCode">constexpr signal operator+(const T &amp;t, const signal &amp;sig)</code>, allowing us to add a signal to a scalar (scalar + signal)</li>
</ul>
<h3 class="heading-3" id="_idParaDest-164">Writing a signal representing the Steinhart-Hart equation</h3>
<p class="normal">Now we have all the elements we need to write a<a id="_idIndexMarker532"/> signal that represents the<a id="_idIndexMarker533"/> Steinhart-Hart equation, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">int main()
{
  constexpr float A = 1.18090254918130e-3;
  constexpr float B = 2.16884014794388e-4;
  constexpr float C = 1.90058756197216e-6;
  constexpr float D = 1.83161892641824e-8;
  constexpr int c_lut_points = 50;
  constexpr signal&lt;float, c_lut_points&gt; resistance(1e3, 10e3);
  constexpr auto temperature_k =
  1 / (A +
  B * signal(resistance, [](float x)
                    { return std::log(x); }) +
  C * signal(resistance, [](float x)
                    { return std::pow(std::log(x), 2); }) +
  D * signal(resistance, [](float x)
                    { return std::pow(std::log(x), 3); }));
  constexpr auto temperature_celsius = temperature_k - 273.15f;
  std::ofstream file("out.csv");
  file &lt;&lt; "Resistance[Ohm], Temperature[Celsius]\n";
  for (int i = 0; i &lt; c_lut_points; i++) {
    file &lt;&lt; resistance[i] &lt;&lt; ", " &lt;&lt; temperature_celsius[i] &lt;&lt; "\n";
  }
  return 0;
}
</code></pre>
<p class="normal">This code generates<a id="_idIndexMarker534"/> points from the Steinhart-Hart equation through the following steps:</p>
<ol>
<li class="numberedList" value="1">Define the <em class="italic">A</em>, <em class="italic">B</em>, <em class="italic">C</em>, and <em class="italic">D</em> coefficients.</li>
<li class="numberedList">Create values for resistance in the range 1 to 10 kOhms across 50 points.</li>
<li class="numberedList">Calculate values of temperature in Kelvins using the Steinhart-Hart equation in points from the generated resistance signal. We convert temperature to Celsius by subtracting 273.15.</li>
<li class="numberedList">Save the values from the generated resistance and temperature signals into a CSV file (file operations require including the <code class="inlineCode">&lt;fstream&gt;</code> header).</li>
</ol>
<p class="normal">You can run the full example in a Docker container. Start Visual Studio Code, attach it to the running container, and open the <code class="inlineCode">Chapter11/signal_generator</code> project, as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, and then run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ cd Chapter11/signal_generator
$ cmake -B build
$ cmake --build build
$ ./build/signal_gen
</code></pre>
<p class="normal">Running the example <a id="_idIndexMarker535"/>will result in a CSV file being created (<code class="inlineCode">out.csv</code>). We can generate an image from the created CSV file using the following command in the terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ graph out.csv -o curve.png
</code></pre>
<p class="normal">We can transfer the generated image using the <code class="inlineCode">docker cp</code> command from the host machine:</p>
<pre class="programlisting con"><code class="hljs-con">$ docker cp dev_env:/workspace/Cpp-in-Embedded-Systems/Chapter11/signal_generator/curve.png
</code></pre>
<p class="normal">This command will transfer the generated image <code class="inlineCode">curve.png</code> to the host machine. We can also see the same image here:</p>
<figure class="mediaobject"><img alt="Figure 11.1 – Steinhart-Hart curve" src="img/B22402_11_01.png"/></figure>
<p class="packt_figref">Figure 11.1 – Steinhart-Hart curve</p>
<p class="normal"><em class="italic">Figure 11</em><em class="italic">.1</em> depicts<a id="_idIndexMarker536"/> the calculated Steinhart-Hart curve. Values for resistance and temperature were generated at compile time using the <code class="inlineCode">signal</code> <code class="inlineCode">struct</code>. Next, we will use the generated curve in Renode to read a temperature from a simulated thermistor using the ADC. Here is an image of a circuit showing how the thermistor is connected to the microcontroller:</p>
<figure class="mediaobject"><img alt="Figure 11.2 – Thermistor circuit" src="img/B22402_11_02.png"/></figure>
<p class="packt_figref">Figure 11.2 – Thermistor circuit</p>
<p class="normal"><em class="italic">Figure 11</em><em class="italic">.2</em> depicts a voltage divider with a thermistor. If we measure the voltage on the ADC pin, we can calculate the thermistor’s resistance using the following equation:</p>
<p class="normal"><img alt="" role="presentation" src="img/B22402_11_003.png"/></p>
<p class="normal">In the preceding equation:</p>
<ul>
<li class="bulletList"><em class="italic">R</em><sub class="italic">T</sub> is the <a id="_idIndexMarker537"/>calculated resistance of the thermistor.</li>
<li class="bulletList"><em class="italic">R</em><sub class="italic">2</sub> is the resistance of a resistor with a known value.</li>
<li class="bulletList"><em class="italic">V</em><sub class="italic">CC</sub> is the power supply voltage.</li>
<li class="bulletList"><em class="italic">V</em><sub class="italic">ADC</sub> is the voltage measured by the ADC.</li>
</ul>
<p class="normal">We can model a voltage divider using a simple <code class="inlineCode">struct</code> in C++, shown here:</p>
<pre class="programlisting code"><code class="hljs-code">struct voltage_divider {
        units::resistance r2;
        units::voltage vcc;
        units::resistance get_r1(units::voltage vadc) {
            return r2 * (vcc/vadc - 1);
        }
    };
voltage_divider divider{10e3_Ohm, 3.3_V};
</code></pre>
<p class="normal">This code shows the <code class="inlineCode">struct</code> <code class="inlineCode">voltage_divider</code>. We will go through its details:</p>
<ul>
<li class="bulletList">It uses strong type resistance and voltage defined in namespace units. You can check the implementation details for these strong types in the project folder, <code class="inlineCode">Chapter11/compile_time/util</code>.</li>
<li class="bulletList">We instantiate an object of voltage_divider using list initialization as in <code class="inlineCode">voltage_divider divider{10e3_Ohm, 3.3_V}</code>. <code class="inlineCode">10e3_Ohm</code> and <code class="inlineCode">3.3_V</code> are user-defined literals for types <code class="inlineCode">resistance</code> and <code class="inlineCode">voltage</code>.</li>
<li class="bulletList">The <code class="inlineCode">struct</code> has a single method, <code class="inlineCode">units::resistance get_r1(units::voltage vadc)</code>. It calculates the R1 value from a voltage divider circuit based on the provided <a id="_idIndexMarker538"/>voltage on ADC. In our case, this is the thermistor’s resistance.</li>
</ul>
<h3 class="heading-3" id="_idParaDest-165">Analyzing the usage example firmware code</h3>
<p class="normal">Next, we <a id="_idIndexMarker539"/>will go through the firmware code in a while loop in the <code class="inlineCode">main</code> function from <code class="inlineCode">Chapter11/compile_time/app/src/main_lookup_table.cpp</code>. It is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">auto adc_val = adc.get_reading();
if(adc_val) {
  auto adc_val_voltage = *adc_val;
  auto thermistor_r = divider.get_r1(adc_val_voltage);
  auto it = std::lower_bound(resistance.begin(),    
                resistance.end(), thermistor_r.get());
  if(it != resistance.end()) {
     std::size_t pos = std::distance(resistance.begin(), it);
     float temperature = temperature_celsius.at(pos);
     printf("%d mV, %d Ohm, %d.%d C\r\n",
           static_cast&lt;int&gt;(adc_val_voltage.get_mili()),
           static_cast&lt;int&gt;(thermistor_r.get()),
           static_cast&lt;int&gt;(temperature),
           static_cast&lt;int&gt;(10*(temperature-std::floor(temperature))) );
    }
  }
hal::time::delay_ms(200);
</code></pre>
<p class="normal">Let us analyze<a id="_idIndexMarker540"/> this code in detail:</p>
<ol>
<li class="numberedList" value="1">We are calling the <code class="inlineCode">get_reading</code> method on the object <code class="inlineCode">adc</code>. It is of type <code class="inlineCode">hal::adc_stm32</code>, and it returns <code class="inlineCode">std::expected&lt;units::voltage, adc::error&gt;</code>. It is an error-handling technique that we covered in <a href="Chapter_07.xhtml"><em class="italic">Chapter 7</em></a>. You can check the implementation details of the <code class="inlineCode">adc_stm32</code> class in the project folder, <code class="inlineCode">Chapter11/compile_time/hal/adc</code>.</li>
<li class="numberedList">If the call to <code class="inlineCode">get_reading</code> was successful, we dereference the returned object to get access to the voltage, which we pass to <code class="inlineCode">voltage_divider</code>'s <code class="inlineCode">get_r1</code> method to calculate the thermistor’s value.</li>
<li class="numberedList">Next, we use the algorithm <code class="inlineCode">std::lower_bound</code> to get an iterator to the first element in the <code class="inlineCode">resistance</code> signal that is not ordered before calculating the thermistor’s value. If we find such an element, we calculate its position using <code class="inlineCode">std::distance</code>, and index <code class="inlineCode">temperature_celsius</code> to get the temperature value.</li>
<li class="numberedList">Finally, we print the ADC’s voltage, the thermistor’s resistance, and the temperature value. Note that we printed the float value of temperature using <code class="inlineCode">ints</code>, as printing floats increases the binary size of the firmware.</li>
</ol>
<p class="normal">To run the firmware in the Renode simulator on the STM32 target, start Visual Studio Code, attach it to the running container, and open the <code class="inlineCode">Chapter11/compile_time</code> project, as described in <a href="Chapter_04.xhtml"><em class="italic">Chapter 4</em></a>, then run the following commands in the Visual Studio Code terminal, or run them directly in the container terminal:</p>
<pre class="programlisting con"><code class="hljs-con">$ cd Chapter11/compile_time
$ cmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel -DMAIN_CPP_FILE_NAME=main_lookup_table.cpp
$ cmake --build build --target run_in_renode
</code></pre>
<p class="normal">To simulate <a id="_idIndexMarker541"/>voltage on the ADC, please enter the following command in the terminal running Renode:</p>
<pre class="programlisting con"><code class="hljs-con">$ adc FeedVoltageSampleToChannel 0 1700 3
</code></pre>
<p class="normal">The preceding command will feed a voltage of 1700 mV to the ADC in three successive readings. This will result in the following output:</p>
<pre class="programlisting con"><code class="hljs-con">1699 mV, 9412 Ohm, 26.2 C
</code></pre>
<p class="normal">This command shows that for a value of 1700 mV on the ADC, we calculated a thermistor value of 9412 Ohms, resulting in a temperature of 26.2<sup class="superscript">0</sup>C. As an exercise, feed the simulation with different ADC voltage values and compare the results with the curve graph from previous steps.</p>
<p class="normal">The <code class="inlineCode">constexpr</code> specifier is a flexible tool in C++ allowing us to run a function at both compile time and runtime. If we want to make sure that a function is evaluated only at compile time, we can use the consteval specifier.</p>
<h1 class="heading-1" id="_idParaDest-166">consteval specifier</h1>
<p class="normal">The <strong class="keyWord">consteval specifier</strong> may be <a id="_idIndexMarker542"/>applied only to functions. It specifies that a function is a so-called immediate function and that every call to it must result in a compile-time constant. Let’s go through the following simple example:</p>
<pre class="programlisting code"><code class="hljs-code">constexpr int square(int x) {
    return x*x;
}
int main() {
    constexpr int arg = 2;
    int ret = square(arg);
    return ret;
}
</code></pre>
<p class="normal">If you run this example in Compiler Explorer using the <code class="inlineCode">x86-64 GCC 14.2</code> compiler, without optimization enabled, we can observe the following:</p>
<ul>
<li class="bulletList">The program returns 4.</li>
<li class="bulletList">The resulting assembly is small, and it just moves 4 to the return register.</li>
<li class="bulletList">Removing the <code class="inlineCode">constexpr</code> specifier from the variable <code class="inlineCode">arg</code> will result in the function square being generated and a call to it in the <code class="inlineCode">main</code> function.</li>
</ul>
<p class="normal">Now, let’s change the function <code class="inlineCode">square</code> <code class="inlineCode">constexpr</code> specifier to <code class="inlineCode">consteval</code>, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">consteval int square(int x) {
    return x*x;
}
int main() {
    constexpr int arg = 2;
    int ret = square(arg);
    return ret;
}
</code></pre>
<p class="normal">If you run the program in Compiler Explorer, it will return <code class="inlineCode">4</code> and result in small assembly code. However, if we now remove the <code class="inlineCode">constexpr</code> specifier from the variable <code class="inlineCode">arg</code>, the compilation will fail with the following error:</p>
<pre class="programlisting con"><code class="hljs-con">&lt;source&gt;: In function 'int main()':
&lt;source&gt;:7:21: error: call to consteval function 'square(arg)' is not a constant expression
    7 |     int ret = square(arg);
      |               ~~~~~~^~~~~
&lt;source&gt;:7:21: error: the value of 'arg' is not usable in a constant expression
&lt;source&gt;:6:9: note: 'int arg' is not const
    6 |     int arg = 2;
      |         ^~~
</code></pre>
<p class="normal">The consteval specifier<a id="_idIndexMarker543"/> ensures that a function is evaluated only at compile time. This prevents the function from being accidentally run at runtime, which could happen with a <code class="inlineCode">constexpr</code> function.</p>
<h1 class="heading-1" id="_idParaDest-167">Summary</h1>
<p class="normal">In this chapter, we explored techniques for compile-time computation in C++. We covered the basics of TMP and provided an in-depth explanation of the <code class="inlineCode">constexpr</code> specifier, using examples relevant to embedded systems.</p>
<p class="normal">With the knowledge from this chapter, you can generate lookup tables and convert human-readable addresses, UUIDs, and similar data into arrays used by communication stacks, all at compile time. This allows you to write expressive code that generates complex mathematical signals without consuming extra memory or processing time.</p>
<p class="normal">Next, we will go over the techniques used in writing a HAL in C++.</p>
<h1 class="heading-1" id="_idParaDest-168">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/embeddedsystems">https://packt.link/embeddedsystems</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_code_Discord.png"/></p>
</div>
</body></html>