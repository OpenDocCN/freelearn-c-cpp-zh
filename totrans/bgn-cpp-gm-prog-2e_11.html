<html><head></head><body>
		<div id="_idContainer070">
			<h1 id="_idParaDest-207"><a id="_idTextAnchor214"/><em class="italic">Chapter 10</em>: Pointers, the Standard Template Library, and Texture Management</h1>
			<p>We will learn a lot as well as get plenty done in terms of the game in this chapter. We will first learn about the fundamental C++ topic of <strong class="bold">pointers</strong>. Pointers are variables that hold a memory address. Typically, a pointer will hold the memory address of another variable. This sounds a bit like a reference, but we will see how they are much more powerful and use a pointer to handle an ever-expanding horde of zombies. </p>
			<p>We will also learn about the <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>), which is a collection of classes that allow us to quickly and easily implement common data management techniques.</p>
			<p>Once we understand the basics of the STL, we will be able to use that new knowledge to manage all the textures from the game because, if we have 1,000 zombies, we don't really want to load a copy of a zombie graphic into the GPU for each and every one.</p>
			<p>We will also dig a little deeper into OOP and use a <strong class="bold">static</strong> function, which is a function of a class that can be called without an instance of the class. At the same time, we will see how we can design a class to ensure that only one instance can ever exist. This is ideal when we need to guarantee that different parts of our code will use the same data.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Learning about pointers</li>
				<li>Learning about the STL</li>
				<li>Implementing the <strong class="source-inline">TextureHolder</strong> class using static functions and a <strong class="bold">singleton</strong> class</li>
				<li>Implementing a pointer to a horde of zombies</li>
				<li>Editing some existing code to use the <strong class="source-inline">TextureHolder</strong> class for the player and background</li>
			</ul>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor215"/>Learning about Pointers</h1>
			<p>Pointers can be the cause of frustration while learning to code C++. However, the concept is simple. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">A <strong class="bold">pointer</strong> is a variable that holds a memory address.</p>
			<p>That's it! There's nothing to be concerned about. What probably causes the frustration to beginners is the syntax—the code we use to handle pointers. We will step through each part of the code for using pointers. You can then begin the ongoing process of mastering them. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">In this section, we will actually learn more about pointers than we need to for this project. In the next project, we will make greater use of pointers. Despite this, we will only scratch the surface of this topic. Further study is definitely recommended, and we will talk more about that in the final chapter.</p>
			<p>Rarely do I suggest that memorizing facts, figures, or syntax is the best way to learn. However, memorizing the brief but crucial syntax related to pointers might be worthwhile. This will ensure that the information sinks so deep into our brains that we can never forget it. We can then talk about why we would need pointers at all and examine their relationship to references. A pointer analogy might help:</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If a variable is a house and its contents are the value it holds, then a pointer is the address of the house.</p>
			<p>In the previous chapter, while discussing references, we learned that when we pass values to, or return values from, a function, we are actually making a completely new house, but it's exactly the same as the previous one. We are making a copy of the value that's passed to or from a function. </p>
			<p>At this point, pointers are probably starting to sound a bit like references. That's because they are a bit like references. Pointers, however, are much more flexible, powerful, and have their own special and unique uses. These special and unique uses require a special and unique syntax.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor216"/>Pointer syntax</h2>
			<p>There are two main operators associated with pointers. The first is the <strong class="bold">address of </strong>operator:</p>
			<p class="source-code">&amp;</p>
			<p>The second is the <strong class="bold">dereference</strong> operator:</p>
			<p class="source-code">*</p>
			<p>We will now look at the different ways in which we can use these operators with pointers.</p>
			<p>The first thing you will notice is that the address of the operator is the same as the reference operator. To add to the woes of an aspiring C++ game programmer, the operators do different things in different contexts. Knowing this from the outset is valuable. If you are staring at some code involving pointers and it seems like you are going mad, know this:</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You are perfectly sane! You just need to look at the detail of the context.</p>
			<p>Now, you know that if something isn't clear and immediately obvious, it is not your fault. Pointers are not clear and immediately obvious but looking carefully at the context will reveal what is going on.</p>
			<p>Armed with the knowledge that you need to pay more attention to pointers than to previous syntax, as well as what the two operators are (<strong class="bold">address of</strong> and <strong class="bold">dereference</strong>), we can now start to look at some real pointer code.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Make sure you have memorized the two operators before proceeding.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor217"/>Declaring a pointer</h2>
			<p>To declare a new pointer, we use the dereference operator, along with the type of variable the pointer will be holding the address of. Take a look at the following code before we talk about pointers some more:</p>
			<p class="source-code">// Declare a pointer to hold </p>
			<p class="source-code">// the address of a variable of type int</p>
			<p class="source-code">int* pHealth;</p>
			<p>The preceding code declares a new pointer called <strong class="source-inline">pHealth</strong> that can hold the address of a variable of the <strong class="source-inline">int</strong> type. Notice I said <em class="italic">can</em> hold a variable of the <strong class="source-inline">int</strong> type. Like other variables, a pointer also needs to be initialized with a value to make proper use of it.</p>
			<p>The name <strong class="source-inline">pHealth</strong>, just like other variables, is arbitrary. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">It is common practice to prefix the names of variables that are pointers with a <strong class="source-inline">p</strong>. It is then much easier to remember when we are dealing with a pointer and can then distinguish them from regular variables.</p>
			<p>The white space that's used around the dereference operator is optional because C++ rarely cares about spaces in syntax. However, it's recommended because it aids readability. Look at the following three lines of code that all do the same thing.</p>
			<p>We have just seen the following format in the previous example, with the dereference operator next to the type:</p>
			<p class="source-code">int* pHealth;</p>
			<p>The following code shows white space either side of the dereference operator:</p>
			<p class="source-code">int * pHealth;</p>
			<p>The following code shows the dereference operator next to the name of the pointer:</p>
			<p class="source-code">int *pHealth;</p>
			<p>It is worth being aware of these possibilities so that when you read code, perhaps on the web, you will understand they are all the same. In this book, we will always use the first option with the dereference operator next to the type. </p>
			<p>Just like a regular variable can only successfully contain data of the appropriate type, a pointer should only hold the address of a variable of the appropriate type.</p>
			<p>A pointer to the <strong class="source-inline">int</strong> type should not hold the address of a <strong class="source-inline">String</strong>, <strong class="source-inline">Zombie</strong>, <strong class="source-inline">Player</strong>, <strong class="source-inline">Sprite</strong>, <strong class="source-inline">float</strong>, or any other type, except <strong class="source-inline">int</strong>.</p>
			<p>Let's see how we can initialize our pointers.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor218"/>Initializing a pointer</h2>
			<p>Next, we will see how we can get the address of a variable into a pointer. Take a look at the following code:</p>
			<p class="source-code">// A regular int variable called health</p>
			<p class="source-code">int health = 5;</p>
			<p class="source-code">// Declare a pointer to hold the address of a variable of type int</p>
			<p class="source-code">int* pHealth;</p>
			<p class="source-code">// Initialize pHealth to hold the address of health,</p>
			<p class="source-code">// using the "address of" operator</p>
			<p class="source-code">pHealth = &amp;health;</p>
			<p>In the previous code, we declare an <strong class="source-inline">int</strong> variable called <strong class="source-inline">health</strong> and initialize it to <strong class="source-inline">5</strong>. It makes sense, although we have never discussed it before, that this variable must be somewhere in our computer's memory. It must have a memory address. </p>
			<p>We can access this address using the <strong class="bold">address of</strong> operator. Look closely at the last line of the previous code. We initialize <strong class="source-inline">pHealth</strong> with the address of <strong class="source-inline">health</strong>, like this:</p>
			<p class="source-code">  pHealth = &amp;health;</p>
			<p>Our <strong class="source-inline">pHealth</strong> pointer now holds the address of the regular <strong class="source-inline">int</strong>, <strong class="source-inline">health</strong>. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">In C++ terminology, we say that <strong class="source-inline">pHealth</strong> points to <strong class="source-inline">health</strong>.</p>
			<p>We can use <strong class="source-inline">pHealth</strong> by passing it to a function so that the function can work on <strong class="source-inline">health</strong>, just like we did with references. </p>
			<p>There would be no reason for pointers if that was all we were going to do with them, so let's take a look at reinitializing them.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor219"/>Reinitializing pointers</h2>
			<p>A pointer, unlike a reference, can be reinitialized to point to a different address. Look at this following code:</p>
			<p class="source-code">// A regular int variable called health</p>
			<p class="source-code">int health = 5;</p>
			<p class="source-code">int score = 0;</p>
			<p class="source-code">// Declare a pointer to hold the address of a variable of type int</p>
			<p class="source-code">int* pHealth;</p>
			<p class="source-code">// Initialize pHealth to hold the address of health</p>
			<p class="source-code">pHealth = &amp;health;</p>
			<p class="source-code">// Re-initialize pHealth to hold the address of score</p>
			<p class="source-code">pHealth = &amp;score;</p>
			<p>Now, <strong class="source-inline">pHealth</strong> points to the <strong class="source-inline">int</strong> variable, <strong class="source-inline">score</strong>. </p>
			<p>Of course, the name of our pointer, <strong class="source-inline">pHealth</strong>, is now ambiguous and should perhaps have been called <strong class="source-inline">pIntPointer</strong>. The key thing to understand here is that we <em class="italic">can</em> do this reassignment.</p>
			<p>At this stage, we haven't actually used a pointer for anything other than simply pointing (holding a memory address). Let's see how we can access the value stored at the address that's pointed to by a pointer. This will make them genuinely useful.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor220"/>Dereferencing a pointer</h2>
			<p>We know that a pointer holds an address in memory. If we were to output this address in our game, perhaps in our HUD, after it has been declared and initialized, it might look something like this: <strong class="bold">9876</strong>.</p>
			<p>It is just a value – a value that represents an address in memory. On different operating systems and hardware types, the range of these values will vary. In the context of this book, we never need to manipulate an address directly. We only care about what the value stored at the address that is pointed to is.</p>
			<p>The actual addresses used by variables are determined when the game is executed (at runtime) and so there is no way of knowing the address of a variable and hence the value stored in a pointer while we are coding the game.</p>
			<p>We can access the value stored at the address that's pointed to by a pointer by using the <strong class="bold">dereference</strong> operator:</p>
			<p class="source-code">*</p>
			<p>The following code manipulates some variables directly and by using a pointer. Try and follow along and then we will go through it:</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Warning! The code that follows is pointless (pun intended). It just demonstrates using pointers.</p>
			<p class="source-code">// Some regular int variables</p>
			<p class="source-code">int score = 0;</p>
			<p class="source-code">int hiScore = 10;</p>
			<p class="source-code">// Declare 2 pointers to hold the addresses of int</p>
			<p class="source-code">int* pIntPointer1;</p>
			<p class="source-code">int* pIntPointer2;</p>
			<p class="source-code">// Initialize pIntPointer1 to hold the address of score</p>
			<p class="source-code">pIntPointer1 = &amp;score;</p>
			<p class="source-code">// Initialize pIntPointer2 to hold the address of hiScore</p>
			<p class="source-code">pIntPointer2 = &amp;hiScore;</p>
			<p class="source-code">// Add 10 to score directly</p>
			<p class="source-code">score += 10;</p>
			<p class="source-code">// Score now equals 10</p>
			<p class="source-code">// Add 10 to score using pIntPointer1</p>
			<p class="source-code">*pIntPointer1 += 10;</p>
			<p class="source-code">// score now equals 20. A new high score</p>
			<p class="source-code">// Assign the new hi score to hiScore using only pointers</p>
			<p class="source-code">*pIntPointer2 = *pIntPointer1;</p>
			<p class="source-code">// hiScore and score both equal 20</p>
			<p>In the previous code, we declare two <strong class="source-inline">int</strong> variables, <strong class="source-inline">score</strong> and <strong class="source-inline">hiScore</strong>. We then initialize them with the values 0 and 10, respectively. Next, we declare two pointers to <strong class="source-inline">int</strong>. These are <strong class="source-inline">pIntPointer1</strong> and <strong class="source-inline">pIntPointer2</strong>. We initialize them in the same step as declaring them to hold the addresses of (point to) the <strong class="source-inline">score</strong> and <strong class="source-inline">hiScore</strong> variables, respectively.</p>
			<p>Following on, we add 10 to <strong class="source-inline">score</strong> in the usual way, <strong class="source-inline">score += 10</strong>. Then, we can see that by using the dereference operator on a pointer, we can access the value stored at the address they point to. The following code changed the value stored by the variable that's pointed to by <strong class="source-inline">pIntPointer1</strong>:</p>
			<p class="source-code">// Add 10 to score using pIntPointer1</p>
			<p class="source-code"><strong class="bold">*pIntPointer1 += 10;</strong></p>
			<p class="source-code">// score now equals 20, A new high score</p>
			<p>The last part of the preceding code dereferences both pointers to assign the value that's pointed to by <strong class="source-inline">pIntPointer1</strong> as the value that's pointed to by <strong class="source-inline">pIntPointer2</strong>:</p>
			<p class="source-code">// Assign the new hi-score to hiScore with only pointers</p>
			<p class="source-code">*pIntPointer2 = *pIntPointer1;</p>
			<p class="source-code">// hiScore and score both equal 20</p>
			<p>Both <strong class="source-inline">score</strong> and <strong class="source-inline">hiScore</strong> are now equal to 20.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor221"/>Pointers are versatile and powerful</h2>
			<p>We can do so much more with pointers. Here are just a few useful things we can do.</p>
			<h3>Dynamically allocated memory</h3>
			<p>All the pointers we have seen so far point to memory addresses that have a scope limited only to the function they are created in. So, if we declare and initialize a pointer to a local variable, when the function returns, the pointer, the local variable, and the memory address will be gone. They are out of scope. </p>
			<p>Up until now, we have been using a fixed amount of memory that is decided in advance of the game being executed. Furthermore, the memory we have been using is controlled by the operating system, and variables are lost and created as we call and return from functions. What we need is a way to use memory that is always in scope until we are finished with it. We want to have access to memory we can call our own and take responsibility for.</p>
			<p>When we declare variables (including pointers), they are in an area of memory known as <strong class="bold">the stack</strong>. There is another area of memory which, although allocated and controlled by the operating system, can be allocated at runtime. This other area of memory is called the <strong class="bold">free store</strong>, or sometimes, the <strong class="bold">heap</strong>. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Memory on the heap does not have scope to a specific function. Returning from a function does not delete the memory on the heap.</p>
			<p>This gives us great power. With access to memory that is only limited by the resources of the computer our game is running on, we can plan games with huge amounts of objects. In our case, we want a vast horde of zombies. As Spiderman's uncle wouldn't hesitate to remind us, however, "with great power comes great responsibility."</p>
			<p>Let's look at how we can use pointers to take advantage of the memory on the free store and how we can release that memory back to the operating system when we are finished with it.</p>
			<p>To create a pointer that points to a value on the heap, we need a pointer:</p>
			<p class="source-code">int* pToInt = nullptr;</p>
			<p>In the previous line of code, we declare a pointer in the same way we have seen before, but since we are not initializing it to point to a variable, we initialize it to <strong class="source-inline">nullptr</strong>. We do this because it is good practice. Consider dereferencing a pointer (changing a value at the address it points to) when you don't even know what it is pointing to. It would be the programming equivalent of going to the shooting range, blindfolding someone, spinning them around, and telling them to shoot. By pointing a pointer to nothing (<strong class="source-inline">nullptr</strong>), we can't do any harm with it.</p>
			<p>When we are ready to request memory on the free store, we use the <strong class="source-inline">new</strong> keyword, as shown in the following line of code:</p>
			<p class="source-code">pToInt = new int;</p>
			<p><strong class="source-inline">pToInt</strong> now holds the memory address of space on the free store that is just the right size to hold an <strong class="source-inline">int</strong> value. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Any allocated memory is returned when the program ends. It is, however, important to realize that this memory will never be freed (within the execution of our game) unless we free it. If we continue to take memory from the free store without giving it back, eventually it will run out and the game will crash.</p>
			<p>It is unlikely that we would ever run out of memory by occasionally taking <strong class="source-inline">int</strong> sized chunks of the free store. But if our program has a function or loop that requests memory and this function or loop is executed regularly throughout the game, eventually the game will slow and then crash. Furthermore, if we allocate lots of objects on the free store and don't manage them correctly, then this situation can happen quite quickly.</p>
			<p>The following line of code hands back (deletes) the memory on the free store that was previously pointed to by <strong class="source-inline">pToInt</strong>:</p>
			<p class="source-code">delete pToInt;</p>
			<p>Now, the memory that was previously pointed to by <strong class="source-inline">pToInt</strong> is no longer ours to do what we like with; we must take precautions. Although the memory has been handed back to the operating system, <strong class="source-inline">pToInt</strong> still holds the address of this memory, which no longer belongs to us.</p>
			<p>The following line of code ensures that <strong class="source-inline">pToInt</strong> can't be used to attempt to manipulate or access this memory:</p>
			<p class="source-code">pToInt = nullptr;</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If a pointer points to an address that is invalid, it is called a <strong class="bold">wild</strong> or <strong class="bold">dangling</strong> pointer. If you attempt to dereference a dangling pointer and if you are lucky, the game will crash, and you will get a memory access violation error. If you are unlucky, you will create a bug that will be incredibly difficult to find. Furthermore, if we use memory on the free store that will persist beyond the life of a function, we must make sure to keep a pointer to it or we will have leaked memory.</p>
			<p>Now, we can declare pointers and point them to newly allocated memory on the free store. We can manipulate and access the memory they point to by dereferencing them. We can also return memory to the free store when we are done with it, and we know how to avoid having a dangling pointer. </p>
			<p>Let's look at some more advantages of pointers.</p>
			<h3>Passing a pointer to a function</h3>
			<p>In order to pass a pointer to a function, we need to write a function that has a pointer in the prototype, like in the following code:</p>
			<p class="source-code">void myFunction(int *pInt)</p>
			<p class="source-code">{</p>
			<p class="source-code">   // Dereference and increment the value stored </p>
			<p class="source-code">   // at the address pointed to by the pointer</p>
			<p class="source-code">   *pInt ++</p>
			<p class="source-code">   return;</p>
			<p class="source-code">}</p>
			<p>The preceding function simply dereferences the pointer and adds 1 to the value stored at the pointed to address.</p>
			<p>Now, we can use that function and pass the address of a variable or another pointer to a variable explicitly: </p>
			<p class="source-code">int someInt = 10;</p>
			<p class="source-code">int* pToInt = &amp;someInt;</p>
			<p class="source-code">myFunction(&amp;someInt);</p>
			<p class="source-code">// someInt now equals 11</p>
			<p class="source-code">myFunction(pToInt);</p>
			<p class="source-code">// someInt now equals 12</p>
			<p>As shown in the previous code, within the function, we are manipulating the variable from the calling code and can do so using the address of a variable or a pointer to that variable, since both actions amount to the same thing.</p>
			<p>Pointers can also point to instances of a class.</p>
			<h3>Declaring and using a pointer to an object</h3>
			<p>Pointers are not just for regular variables. We can also declare pointers to user-defined types such as our classes. This is how we would declare a pointer to an object of the <strong class="source-inline">Player</strong> type:</p>
			<p class="source-code">Player player;</p>
			<p class="source-code">Player* pPlayer = &amp;Player;</p>
			<p>We can even access the member functions of a <strong class="source-inline">Player</strong> object directly from the pointer, as shown in the following code:</p>
			<p class="source-code">// Call a member function of the player class</p>
			<p class="source-code">pPlayer-&gt;moveLeft()</p>
			<p>Notice the subtle but vital difference: accessing a function with a pointer to an object rather than an object directly uses the -&gt; operator. We won't need to use pointers to objects in this project, but we will explore them more carefully before we do, which will be in the next project.</p>
			<p>Let's go over one more new pointer topic before we talk about something completely new.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor222"/>Pointers and arrays</h2>
			<p>Arrays and pointers have something in common. An array's name is a memory address. More specifically, the name of an array is the memory address of the first element in that array. To put this yet another away, an array name points to the first element of an array. The best way to understand this is to read on and look at the following example.</p>
			<p>We can create a pointer to the type that an array holds and then use the pointer in the same way using exactly the same syntax that we would use for the array:</p>
			<p class="source-code">// Declare an array of ints</p>
			<p class="source-code">int arrayOfInts[100];</p>
			<p class="source-code">// Declare a pointer to int and initialize it </p>
			<p class="source-code">// with the address of the first</p>
			<p class="source-code">// element of the array, arrayOfInts</p>
			<p class="source-code">int* pToIntArray = arrayOfInts;</p>
			<p class="source-code">// Use pToIntArray just as you would arrayOfInts</p>
			<p class="source-code">arrayOfInts[0] = 999;</p>
			<p class="source-code">// First element of arrayOfInts now equals 999</p>
			<p class="source-code">pToIntArray[0] = 0;</p>
			<p class="source-code">// First element of arrayOfInts now equals 0</p>
			<p>This also means that a function that has a prototype that accepts a pointer also accepts arrays of the type the pointer is pointing to. We will use this fact when we build our ever-increasing horde of zombies.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Regarding the relationship between pointers and references, the compiler actually uses pointers when implementing our references. This means that references are just a handy tool (that uses pointers "under the hood"). You could think of a reference as an automatic gearbox that is fine and convenient for driving around town, whereas pointers are a manual gearbox – more complicated, but with the correct use, they can provide better results/performance/flexibility.</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor223"/>Summary of pointers</h2>
			<p>Pointers are a bit fiddly at times. In fact, our discussion of pointers was only an introduction to the subject. The only way to get comfortable with them is to use them as much as possible. All you need to understand about pointers in order to complete this project is the following:</p>
			<ul>
				<li>Pointers are variables that store a memory address.</li>
				<li>We can pass pointers to functions to directly manipulate values from the calling function's scope, within the called function.</li>
				<li>Array names hold the memory address of the first element. We can pass this address as a pointer because that is exactly what it is.</li>
				<li>We can use pointers to point to memory on the free store. This means we can dynamically allocate large amounts of memory while the game is running.<p class="callout-heading">Tip</p><p class="callout">There are yet more ways to use pointers. We will learn about <strong class="bold">smart pointers</strong> in the final project, once we have got used to using regular pointers.</p></li>
			</ul>
			<p>There is just one more topic to cover before we can start coding the Zombie Arena project again.</p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor224"/>The Standard Template Library</h1>
			<p>The <strong class="bold">Standard Template Library (STL)</strong> is a collection of data containers and ways to manipulate the data we put in those containers. If we want to be more specific, it is a way to store and manipulate different types of C++ variables and classes.</p>
			<p>We can think of the different containers as customized and more advanced arrays. The STL is part of C++. It is not an optional thing that needs to be set up like SFML. </p>
			<p>The STL is part of C++ because its containers and the code that manipulates them are fundamental to many types of code that many apps will need to use.</p>
			<p>In short, the STL implements code that we and just about every C++ programmer is almost bound to need, at least at some point, and probably quite regularly.</p>
			<p>If we were to write our own code to contain and manage our data, then it is unlikely we would write it as efficiently as the people who wrote the STL.</p>
			<p>So, by using the STL, we guarantee that we are using the best written code possible to manage our data. Even SFML uses the STL. For example, under the hood, the <strong class="source-inline">VertexArray</strong> class uses the STL.</p>
			<p>All we need to do is choose the right type of container from those that are available. The types of container that are available through the STL include the following:</p>
			<ul>
				<li><strong class="bold">Vector</strong>: This is like an array with boosters. It handles dynamic resizing, sorting, and searching. This is probably the most useful container.</li>
				<li><strong class="bold">List</strong>: A container that allows for the ordering of the data.</li>
				<li><strong class="bold">Map</strong>: An associative container that allows the user to store data as key/value pairs. This is where one piece of data is the "key" to finding the other piece. A map can also grow and shrink, as well as be searched. </li>
				<li><strong class="bold">Set</strong>: A container that guarantees that every element is unique.<p class="callout-heading">Important note</p><p class="callout">For a full list of STL container types, their different uses, and explanations, take a look at the following link: <a href="http://www.tutorialspoint.com/cplusplus/cpp_stl_tutorial.htm">http://www.tutorialspoint.com/cplusplus/cpp_stl_tutorial.htm</a>.</p></li>
			</ul>
			<p>In the Zombie Arena game, we will use a map.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want a glimpse into the kind of complexity that the STL is sparing us, then take a look at this tutorial, which implements the kind of thing that a list would do. Note that the tutorial implements only the very simplest bare-bones implementation of a list: <a href="http://www.sanfoundry.com/cpp-program-implement-single-linked-list/">http://www.sanfoundry.com/cpp-program-implement-single-linked-list/</a>.</p>
			<p>We can easily see that we will save a lot of time and end up with a better game if we explore the STL. Let's take a closer look at how to use a <strong class="source-inline">Map</strong> instance, and then we will see how it will be useful to us in the Zombie Arena game.</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor225"/>What is a map?</h2>
			<p>A <strong class="bold">map</strong> is a container that is dynamically resizable. We can add and remove elements with ease. What makes the <strong class="source-inline">map</strong> class special compared to the other containers in the STL is the way that we access the data within it.</p>
			<p>The data in a <strong class="source-inline">map</strong> instance is stored in pairs. Consider a situation where you log in to an account, perhaps with a username and password. A map would be perfect for looking up the username and then checking the value of the associated password.</p>
			<p>A map would also be just right for things such as account names and numbers, or perhaps company names and share prices.</p>
			<p>Note that when we use <strong class="source-inline">map</strong> from the STL, we decide the type of values that form the key-value pairs. The values could be <strong class="source-inline">string</strong> instances and <strong class="source-inline">int</strong> instances, such as account numbers; <strong class="source-inline">string</strong> instances and other <strong class="source-inline">string</strong> instances such as usernames and passwords; or user-defined types such as objects.</p>
			<p>What follows is some real code to make us familiar with <strong class="source-inline">map</strong>. </p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor226"/>Declaring a map</h2>
			<p>This is how we could declare a <strong class="source-inline">map</strong>:</p>
			<p class="source-code">map&lt;string, int&gt; accounts;</p>
			<p>The previous line of code declares a new <strong class="source-inline">map</strong> called <strong class="source-inline">accounts</strong> that has a key of <strong class="source-inline">string</strong> objects, each of which will refer to a value that is an <strong class="source-inline">int</strong>. </p>
			<p>We can now store key-value pairs of the <strong class="source-inline">string</strong> type that refer to values of the <strong class="source-inline">int</strong> type. We will see how we can do this next.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor227"/>Adding data to a Map</h2>
			<p>Let's go ahead and add a key-value pair to accounts:</p>
			<p class="source-code">accounts["John"] = 1234567;</p>
			<p>Now, there is an entry in the map that can be accessed using the key of John. The following code adds two more entries to the accounts map:</p>
			<p class="source-code">accounts["Smit"] = 7654321;</p>
			<p class="source-code">accounts["Larissa"] = 8866772;</p>
			<p>Our map has three entries in it. Let's see how we can access the account numbers.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor228"/>Finding data in a map</h2>
			<p>We would access the data in the same way that we added it: by using the key. As an example, we could assign the value stored by the <strong class="source-inline">Smit</strong> key to a new <strong class="source-inline">int</strong>, <strong class="source-inline">accountNumber</strong>, like this:</p>
			<p class="source-code">int accountNumber = accounts["Smit"];</p>
			<p>The <strong class="source-inline">int</strong> variable, <strong class="source-inline">accountNumber</strong>, now stores the value <strong class="source-inline">7654321</strong>. We can do anything to a value stored in a <strong class="source-inline">map</strong> instance that we can do to that type.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor229"/>Removing data from a map</h2>
			<p>Taking values out of our map is also straightforward. The following line of code removes the key, <strong class="source-inline">John</strong>, and its associated value:</p>
			<p class="source-code">accounts.erase("John");</p>
			<p>Let's look at a few more things we can do with a <strong class="source-inline">map</strong>.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor230"/>Checking the size of a map</h2>
			<p>We might like to know how many key-value pairs we have in our map. The following line of code does just that:</p>
			<p class="source-code">int size = accounts.size();</p>
			<p>The <strong class="source-inline">int</strong> variable, <strong class="source-inline">size</strong>, now holds the value of <strong class="source-inline">2</strong>. This is because <strong class="source-inline">accounts</strong> holds values for Smit and Larissa, because we deleted John.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor231"/>Checking for keys in a map</h2>
			<p>The most relevant feature of <strong class="source-inline">map</strong> is its ability to find a value using a key. We can test for the presence or otherwise of a specific key like this:</p>
			<p class="source-code">if(accounts.find("John") != accounts.end())</p>
			<p class="source-code">{</p>
			<p class="source-code">    // This code won't run because John was erased</p>
			<p class="source-code">}</p>
			<p class="source-code">if(accounts.find("Smit") != accounts.end())</p>
			<p class="source-code">{</p>
			<p class="source-code">    // This code will run because Smit is in the map</p>
			<p class="source-code">}</p>
			<p>In the previous code, the <strong class="source-inline">!= accounts.end</strong> value is used to determine when a key does or doesn't exist. If the searched for key is not present in the <strong class="source-inline">map</strong>, then <strong class="source-inline">accounts.end</strong> will be the result of the <strong class="source-inline">if</strong> statement.</p>
			<p>Let's see how we can test or use all the values in a map by looping through a map.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor232"/>Looping/iterating through the key-value pairs of a map</h2>
			<p>We have seen how we can use a <strong class="source-inline">for </strong>loop to loop/iterate through all the values of an array. But, what if we want to do something like this to a map?  </p>
			<p>The following code shows how we could loop through each key-value pair of the account's <strong class="source-inline">map</strong> and add one to each of the account numbers:</p>
			<p class="source-code">for (map&lt;string,int&gt;::iterator it = accounts.begin(); </p>
			<p class="source-code">    it != accounts.end();  </p>
			<p class="source-code">    ++ it)</p>
			<p class="source-code">{</p>
			<p class="source-code">    it-&gt;second += 1;</p>
			<p class="source-code">}</p>
			<p>The condition of the <strong class="source-inline">for</strong> loop is probably the most interesting part of the previous code. The first part of the condition is the longest part. <strong class="source-inline">map&lt;string,int&gt;::iterator it = accounts.begin()</strong> is more understandable if we break it down.</p>
			<p> <strong class="source-inline">map&lt;string,int&gt;::iterator</strong> is a type. We are declaring an <strong class="source-inline">iterator</strong> that's suitable for a <strong class="source-inline">map</strong> with key-value pairs of <strong class="source-inline">string</strong> and <strong class="source-inline">int</strong>. The iterator's name is <strong class="source-inline">it</strong>. We assign the value that's returned by <strong class="source-inline">accounts.begin()</strong> to <strong class="source-inline">it</strong>. The iterator, <strong class="source-inline">it</strong>, now holds the first key-value pair from the <strong class="source-inline">accounts</strong> map.</p>
			<p>The rest of the condition of the <strong class="source-inline">for</strong> loop works as follows. <strong class="source-inline">it != accounts.end()</strong> means the loop will continue until the end of the map is reached, and <strong class="source-inline">++it</strong> simply steps to the next key-value pair in the map, each pass through the loop.</p>
			<p>Inside the <strong class="source-inline">for</strong> loop, <strong class="source-inline">it-&gt;second</strong> accesses the value of the key-value pair and <strong class="source-inline">+= 1</strong> adds one to the value. Note that we can access the key (which is the first part of the key-value pair) with <strong class="source-inline">it-&gt;first</strong>.</p>
			<p>You might have noticed that the syntax for setting up a loop through a map is quite verbose. C++ has a way to cut down on this verbosity.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor233"/>The auto keyword</h2>
			<p>The code in the condition of the <strong class="source-inline">for</strong> loop was quite verbose – especially in terms of <strong class="source-inline">map&lt;string,int&gt;::iterator</strong>. C++ supplies a neat way to reduce verbosity with the <strong class="source-inline">auto</strong> keyword. Using the <strong class="source-inline">auto</strong> keyword, we can improve the previous code:</p>
			<p class="source-code">for (auto it = accounts.begin(); it != accounts.end(); ++ it)</p>
			<p class="source-code">{</p>
			<p class="source-code">    it-&gt;second += 1;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">auto</strong> keyword instructs the compiler to automatically deduce the type for us. This will be especially useful with the next class that we write.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor234"/>STL summary</h2>
			<p>As with almost every C++ concept that we have covered in this book, the STL is a massive topic. Whole books have been written covering just the STL. At this point, however, we know enough to build a class that uses the STL <strong class="source-inline">map</strong> to store SFML <strong class="source-inline">Texture</strong> objects. We can then have textures that can be retrieved/loaded by using the filename as the key of the key-value pair.</p>
			<p>The reason why we would go to this extra level of complexity and not just carry on using the <strong class="source-inline">Texture</strong> class the same way as we have been so far will become apparent as we proceed.</p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor235"/>The TextureHolder class</h1>
			<p>Thousands of zombies represent a new challenge. Not only would loading, storing, and manipulating thousands of copies of three different zombie textures take up a lot of memory, but also a lot of processing power. We will create a new type of class that overcomes this problem and allows us to store just one of each texture.</p>
			<p>We will also code the class in such a way that there can only ever be one instance of it. This type of class is called a <strong class="bold">singleton</strong>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">A singleton is a design pattern. A design pattern is a way to structure our code that is proven to work.</p>
			<p>Furthermore, we will also code the class so that it can be used anywhere in our game code directly through the class name, without access to an instance. </p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor236"/>Coding the TextureHolder header file</h2>
			<p>Let's make a new header file. Right-click <strong class="bold">Header Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">Header File (.h)</strong>, and then in the <strong class="bold">Name</strong> field, type <strong class="source-inline">TextureHolder.h</strong>.</p>
			<p>Add the code that follows into the <strong class="source-inline">TextureHolder.h</strong> file, and then we can discuss it:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#ifndef TEXTURE_HOLDER_H</p>
			<p class="source-code">#define TEXTURE_HOLDER_H</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include &lt;map&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">using namespace std;</p>
			<p class="source-code">class TextureHolder</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    // A map container from the STL,</p>
			<p class="source-code">    // that holds related pairs of String and Texture</p>
			<p class="source-code">    map&lt;    string, Texture&gt; m_Textures;</p>
			<p class="source-code">    // A pointer of the same type as the class itself</p>
			<p class="source-code">    // the one and only instance</p>
			<p class="source-code">    static TextureHolder* m_s_Instance;</p>
			<p class="source-code">public:</p>
			<p class="source-code">    TextureHolder();</p>
			<p class="source-code">    static Texture&amp; GetTexture(string const&amp; filename);</p>
			<p class="source-code">};</p>
			<p class="source-code">#endif</p>
			<p>In the previous code, notice that we have an <strong class="source-inline">include</strong> directive for <strong class="source-inline">map</strong> from the STL. We declare a <strong class="source-inline">map</strong> instance that holds the <strong class="source-inline">string</strong> type and the SFML <strong class="source-inline">Texture</strong> type, as well as the key-value pairs. The <strong class="source-inline">map</strong> is called <strong class="source-inline">m_Textures</strong>.</p>
			<p>In the preceding code, this line follows on:</p>
			<p class="source-code">static TextureHolder* m_s_Instance;</p>
			<p>The previous line of code is quite interesting. We are declaring a static pointer to an object of the <strong class="source-inline">TextureHolder</strong> type called <strong class="source-inline">m_s_Instance</strong>. This means that the <strong class="source-inline">TextureHolder</strong> class has an object that is the same type as itself. Not only that, but because it is static, it can be used through the class itself, without an instance of the class. When we code the related <strong class="source-inline">.cpp</strong> file, we will see how we can use this.</p>
			<p>In the <strong class="source-inline">public</strong> part of the class, we have the prototype for the constructor function, <strong class="source-inline">TextureHolder</strong>. The constructor takes no arguments and, as usual, has no return type. This is the same as the default constructor. We are going to override the default constructor with a definition that makes our singleton work how we want it to.</p>
			<p>We have another function called <strong class="source-inline">GetTexture</strong>. Let's look at the signature again and analyze exactly what is happening:</p>
			<p class="source-code">static Texture&amp; GetTexture(string const&amp; filename);</p>
			<p>First, notice that the function returns a reference to a <strong class="source-inline">Texture</strong>. This means that <strong class="source-inline">GetTexture</strong> will return a reference, which is efficient because it avoids making a copy of what could be a large graphic. Also, notice that the function is declared as <strong class="source-inline">static</strong>. This means that the function can be used without an instance of the class. The function takes a <strong class="source-inline">string</strong> as a constant reference, as a parameter. The effect of this is two-fold. Firstly, the operation is efficient and secondly, because the reference is constant, it can't be changed.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor237"/>Coding the TextureHolder function definitions</h2>
			<p>Now, we can create a new <strong class="source-inline">.cpp</strong> file that will contain the function definition. This will allow us to see the reasons behind our new types of functions and variables. Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong>, and then in the <strong class="bold">Name</strong> field, type <strong class="source-inline">TextureHolder.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the class.</p>
			<p>Add the following code, and then we can discuss it:</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code">// Include the "assert feature"</p>
			<p class="source-code">#include &lt;assert.h&gt;</p>
			<p class="source-code">TextureHolder* TextureHolder::m_s_Instance = nullptr;</p>
			<p class="source-code">TextureHolder::TextureHolder()</p>
			<p class="source-code">{</p>
			<p class="source-code">    assert(m_s_Instance == nullptr);</p>
			<p class="source-code">    m_s_Instance = this;</p>
			<p class="source-code">}</p>
			<p>In the previous code, we initialize our pointer of the <strong class="source-inline">TextureHolder</strong> type to <strong class="source-inline">nullptr</strong>. In the constructor, <strong class="source-inline">assert(m_s_Instance == nullptr)</strong> ensures that <strong class="source-inline">m_s_Instance</strong> equals <strong class="source-inline">nullptr</strong>. If it doesn't the game will exit execution. Then, <strong class="source-inline">m_s_Instance = this</strong> assigns the pointer to <strong class="source-inline">this</strong> instance. Now, consider where this code is taking place. The code is in the constructor. The constructor is the way that we create instances of objects from classes. So, effectively, we now have a pointer to a <strong class="source-inline">TextureHolder</strong> that points to the one and only instance of itself.</p>
			<p>Add the final part of the code to the <strong class="source-inline">TextureHolder.cpp</strong> file. There are more comments than code here. Examine the following code and read the comments as you add the code, and then we can go through it:</p>
			<p class="source-code">Texture&amp; TextureHolder::GetTexture(string const&amp; filename)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Get a reference to m_Textures using m_s_Instance</p>
			<p class="source-code">    auto&amp; m = m_s_Instance-&gt;m_Textures;</p>
			<p class="source-code">    // auto is the equivalent of map&lt;string, Texture&gt;</p>
			<p class="source-code">    // Create an iterator to hold a key-value-pair (kvp)</p>
			<p class="source-code">    // and search for the required kvp</p>
			<p class="source-code">    // using the passed in file name</p>
			<p class="source-code">    auto keyValuePair = m.find(filename);</p>
			<p class="source-code">    // auto is equivalent of map&lt;string, Texture&gt;::iterator</p>
			<p class="source-code">    </p>
			<p class="source-code">        </p>
			<p class="source-code">    // Did we find a match?</p>
			<p class="source-code">    if (keyValuePair != m.end())</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // Yes</p>
			<p class="source-code">        // Return the texture,</p>
			<p class="source-code">        // the second part of the kvp, the texture</p>
			<p class="source-code">        return keyValuePair-&gt;second;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // File name not found</p>
			<p class="source-code">        // Create a new key value pair using the filename</p>
			<p class="source-code">        auto&amp; texture = m[filename];</p>
			<p class="source-code">        // Load the texture from file in the usual way</p>
			<p class="source-code">        texture.loadFromFile(filename);</p>
			<p class="source-code">        // Return the texture to the calling code</p>
			<p class="source-code">        return texture;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The first thing you will probably notice about the previous code is the <strong class="source-inline">auto</strong> keyword. The <strong class="source-inline">auto</strong> keyword was explained in the previous section. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you want to know what the actual types that have been replaced by <strong class="source-inline">auto</strong> are, then look at the comments immediately after each use of <strong class="source-inline">auto</strong> in the previous code.</p>
			<p>At the start of the code, we get a reference to <strong class="source-inline">m_textures</strong>. Then, we attempt to get an iterator to the key-value pair represented by the passed-in filename (<strong class="source-inline">filename</strong>). If we find a matching key, we return the texture with <strong class="source-inline">return keyValuePair-&gt;second</strong>. Otherwise, we add the texture to the map and then return it to the calling code.</p>
			<p>Admittedly, the <strong class="source-inline">TextureHolder</strong> class introduced lots of new concepts (singletons, <strong class="source-inline">static</strong> functions, constant references, <strong class="source-inline">this</strong>, and the <strong class="source-inline">auto</strong> keyword,) and syntax. Add to this the fact that we have only just learned about pointers and the STL, and this section's code might have been a little daunting. </p>
			<p>So, was it all worth it?</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor238"/>What have we achieved with TextureHolder?</h2>
			<p>The point is that now that we have this class, we can go wild using textures from wherever we like in our code and not worry about running out of memory or having access to any texture in a particular function or class. We will see how to use <strong class="source-inline">TextureHolder</strong> soon. </p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor239"/>Building a horde of zombies</h1>
			<p>Now, we are armed with the <strong class="source-inline">TextureHolder</strong> class to make sure that our zombie textures are easily available as well as only loaded into the GPU once. Then, we can investigate creating a whole horde of them.</p>
			<p>We will store zombies in an array. Since the process of building and spawning a horde of zombies involves quite a few lines of code, it is a good candidate for abstracting to a separate function. Soon, we will code the <strong class="source-inline">CreateHorde</strong> function but first, of course, we need a <strong class="source-inline">Zombie</strong> class.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor240"/>Coding the Zombie.h file</h2>
			<p>The first step to building a class to represent a zombie is to code the member variables and function prototypes in a header file.</p>
			<p>Right-click <strong class="bold">Header Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">Header File (.h)</strong>, and then in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Zombie.h</strong>.</p>
			<p>Add the following code to the <strong class="source-inline">Zombie.h</strong> file: </p>
			<p class="source-code">#pragma once</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">class Zombie</p>
			<p class="source-code">{</p>
			<p class="source-code">private:</p>
			<p class="source-code">    // How fast is each zombie type?</p>
			<p class="source-code">    const float BLOATER_SPEED = 40;</p>
			<p class="source-code">    const float CHASER_SPEED = 80;</p>
			<p class="source-code">    const float CRAWLER_SPEED = 20;</p>
			<p class="source-code">    // How tough is each zombie type</p>
			<p class="source-code">    const float BLOATER_HEALTH = 5;</p>
			<p class="source-code">    const float CHASER_HEALTH = 1;</p>
			<p class="source-code">    const float CRAWLER_HEALTH = 3;</p>
			<p class="source-code">    // Make each zombie vary its speed slightly</p>
			<p class="source-code">    const int MAX_VARRIANCE = 30;</p>
			<p class="source-code">    const int OFFSET = 101 - MAX_VARRIANCE;</p>
			<p class="source-code">    // Where is this zombie?</p>
			<p class="source-code">    Vector2f m_Position;</p>
			<p class="source-code">    // A sprite for the zombie</p>
			<p class="source-code">    Sprite m_Sprite;</p>
			<p class="source-code">    // How fast can this one run/crawl?</p>
			<p class="source-code">    float m_Speed;</p>
			<p class="source-code">    // How much health has it got?</p>
			<p class="source-code">    float m_Health;</p>
			<p class="source-code">    // Is it still alive?</p>
			<p class="source-code">    bool m_Alive;</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Public prototypes go here</p>
			<p class="source-code">};</p>
			<p>The previous code declares all the private member variables of the <strong class="source-inline">Zombie</strong> class. At the top of the previous code, we have three constant variables to hold the speed of each type of zombie: a very slow Crawler, a slightly faster Bloater, and a somewhat speedy Chaser. We can experiment with the value of these three constants to help balance the difficulty level of the game. It's also worth mentioning here that these three values are only used as a starting value for the speed of each zombie type. As we will see later in this chapter, we will vary the speed of every zombie by a small percentage from these values. This stops zombies of the same type from bunching up together as they pursue the player.</p>
			<p>The next three constants determine the health level for each zombie type. Note that Bloaters are the toughest, followed by Crawlers. As a matter of balance, the Chaser zombies will be the easiest to kill.</p>
			<p>Next, we have two more constants, <strong class="source-inline">MAX_VARRIANCE</strong> and <strong class="source-inline">OFFSET</strong>. These will help us determine the individual speed of each zombie. We will see exactly how when we code the <strong class="source-inline">Zombie.cpp</strong> file.</p>
			<p>After these constants, we declare a bunch of variables that should look familiar because we had very similar variables in our <strong class="source-inline">Player </strong>class. The <strong class="source-inline">m_Position</strong>, <strong class="source-inline">m_Sprite</strong>, <strong class="source-inline">m_Speed</strong>, and <strong class="source-inline">m_Health</strong> variables are for what their names imply: the position, sprite, speed, and health of the zombie object. </p>
			<p>Finally, in the preceding code, we declare a Boolean called <strong class="source-inline">m_Alive</strong>, which will be true when the zombie is alive and hunting, but false when its health gets to zero and it is just a splurge of blood on our otherwise pretty background.</p>
			<p>Now, we can complete the <strong class="source-inline">Zombie.h</strong> file. Add the function prototypes highlighted in the following code, and then we will talk about them:</p>
			<p class="source-code">    // Is it still alive?</p>
			<p class="source-code">    bool m_Alive;</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Public prototypes go here    </p>
			<p class="source-code"><strong class="bold">public:</strong></p>
			<p class="source-code"><strong class="bold">    </strong></p>
			<p class="source-code"><strong class="bold">    // Handle when a bullet hits a zombie</strong></p>
			<p class="source-code"><strong class="bold">    bool hit();</strong></p>
			<p class="source-code"><strong class="bold">    // Find out if the zombie is alive</strong></p>
			<p class="source-code"><strong class="bold">    bool isAlive();</strong></p>
			<p class="source-code"><strong class="bold">    // Spawn a new zombie</strong></p>
			<p class="source-code"><strong class="bold">    void spawn(float startX, float startY, int type, int seed);</strong></p>
			<p class="source-code"><strong class="bold">    // Return a rectangle that is the position in the world</strong></p>
			<p class="source-code"><strong class="bold">    FloatRect getPosition();</strong></p>
			<p class="source-code"><strong class="bold">    // Get a copy of the sprite to draw</strong></p>
			<p class="source-code"><strong class="bold">    Sprite getSprite();</strong></p>
			<p class="source-code"><strong class="bold">    // Update the zombie each frame</strong></p>
			<p class="source-code"><strong class="bold">    void update(float elapsedTime, Vector2f playerLocation);</strong></p>
			<p class="source-code">};</p>
			<p>In the previous code, there is a <strong class="source-inline">hit</strong> function, which we can call every time the zombie is hit by a bullet. The function can then take the necessary steps, such as taking health from the zombie (reducing the value of <strong class="source-inline">m_Health</strong>) or killing it dead (setting <strong class="source-inline">m_Alive</strong> to false).</p>
			<p>The <strong class="source-inline">isAlive</strong> function returns a Boolean that lets the calling code know whether the zombie is alive or dead. We don't want to perform collision detection or remove health from the player for walking over a blood splat.</p>
			<p>The <strong class="source-inline">spawn</strong> function takes a starting position, a type (Crawler, Bloater, or Chaser, represented by an <strong class="source-inline">int</strong>), as well as a seed to use in some random number generation that we will see in the next section.</p>
			<p>Just like we have in the <strong class="source-inline">Player</strong> class, the <strong class="source-inline">Zombie</strong> class has <strong class="source-inline">getPosition</strong> and <strong class="source-inline">getSprite</strong> functions to get a rectangle that represents the space occupied by the zombie and the sprite that can be drawn each frame.</p>
			<p>The last prototype in the previous code is the <strong class="source-inline">update</strong> function. We could have probably guessed that it would receive the elapsed time since the last frame, but also notice that it receives a <strong class="source-inline">Vector2f</strong> vector called <strong class="source-inline">playerLocation</strong>. This vector will indeed be the exact coordinates of the center of the player. We will soon see how we can use this vector to chase after the player.</p>
			<p>Now, we can code the function definitions in the <strong class="source-inline">.cpp</strong> file.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor241"/>Coding the Zombie.cpp file</h2>
			<p>Next, we will code the functionality of the <strong class="source-inline">Zombie</strong> class— the function definitions.</p>
			<p>Create a new <strong class="source-inline">.cpp</strong> file that will contain the function definitions. Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong>, and then in the <strong class="bold">Name</strong> field, type <strong class="source-inline">Zombie.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button. We are now ready to code the class.</p>
			<p>Add the following code to the <strong class="source-inline">Zombie.cpp</strong> file:</p>
			<p class="source-code">#include "zombie.h"</p>
			<p class="source-code">#include "TextureHolder.h"</p>
			<p class="source-code">#include &lt;cstdlib&gt;</p>
			<p class="source-code">#include &lt;ctime&gt;</p>
			<p class="source-code">using namespace std;</p>
			<p>First, we add the necessary include directives and then <strong class="source-inline">using namespace std</strong>. You might remember a few instances when we prefixed our object declarations with <strong class="source-inline">std::</strong>. This <strong class="source-inline">using</strong> directive means we don't need to do that for the code in this file.</p>
			<p>Now, add the following code, which is the definition of the <strong class="source-inline">spawn</strong> function. Study the code once you have added it, and then we will discuss it:</p>
			<p class="source-code">void Zombie::spawn(float startX, float startY, int type, int seed)</p>
			<p class="source-code">{</p>
			<p class="source-code">    </p>
			<p class="source-code">    switch (type)</p>
			<p class="source-code">    {</p>
			<p class="source-code">    case 0:</p>
			<p class="source-code">        // Bloater</p>
			<p class="source-code">        m_Sprite = Sprite(TextureHolder::GetTexture(</p>
			<p class="source-code">            "graphics/bloater.png"));</p>
			<p class="source-code">        m_Speed = BLOATER_SPEED;</p>
			<p class="source-code">        m_Health = BLOATER_HEALTH;</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    case 1:</p>
			<p class="source-code">        // Chaser</p>
			<p class="source-code">        m_Sprite = Sprite(TextureHolder::GetTexture(</p>
			<p class="source-code">            "graphics/chaser.png"));</p>
			<p class="source-code">        m_Speed = CHASER_SPEED;</p>
			<p class="source-code">        m_Health = CHASER_HEALTH;</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    case 2:</p>
			<p class="source-code">        // Crawler</p>
			<p class="source-code">        m_Sprite = Sprite(TextureHolder::GetTexture(</p>
			<p class="source-code">            "graphics/crawler.png"));</p>
			<p class="source-code">        m_Speed = CRAWLER_SPEED;</p>
			<p class="source-code">        m_Health = CRAWLER_HEALTH;</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Modify the speed to make the zombie unique</p>
			<p class="source-code">    // Every zombie is unique. Create a speed modifier</p>
			<p class="source-code">    srand((int)time(0) * seed);</p>
			<p class="source-code">    // Somewhere between 80 and 100</p>
			<p class="source-code">    float modifier = (rand() % MAX_VARRIANCE) + OFFSET;</p>
			<p class="source-code">    // Express this as a fraction of 1</p>
			<p class="source-code">    modifier /= 100; // Now equals between .7 and 1</p>
			<p class="source-code">    m_Speed *= modifier;</p>
			<p class="source-code">    </p>
			<p class="source-code">    // Initialize its location</p>
			<p class="source-code">    m_Position.x = startX;</p>
			<p class="source-code">    m_Position.y = startY;</p>
			<p class="source-code">    // Set its origin to its center</p>
			<p class="source-code">    m_Sprite.setOrigin(25, 25);</p>
			<p class="source-code">    // Set its position</p>
			<p class="source-code">    m_Sprite.setPosition(m_Position);</p>
			<p class="source-code">}</p>
			<p>The first thing the function does is <strong class="source-inline">switch</strong> paths of execution based on the <strong class="source-inline">int</strong> value, which is passed in as a parameter. Within the <strong class="source-inline">switch</strong> block, there is a <strong class="source-inline">case</strong> for each type of zombie. Depending on the type of zombie, the appropriate texture, speed, and health is initialized to the relevant member variables. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We could have used an enumeration for the different types of zombie. Feel free to upgrade your code when the project is finished.</p>
			<p>Of interest here is that we use the static <strong class="source-inline">TextureHolder::GetTexture</strong> function to assign the texture. This means that no matter how many zombies we spawn, there will be a maximum of three textures in the memory of the GPU.</p>
			<p>The next three lines of code (excluding comments) do the following:</p>
			<ul>
				<li>Seed the random number generator with the <strong class="source-inline">seed</strong> variable that was passed in as a parameter.</li>
				<li>Declare and initialize the <strong class="source-inline">modifier</strong> variable using the <strong class="source-inline">rand</strong> function and the <strong class="source-inline">MAX_VARRIANCE</strong> and <strong class="source-inline">OFFSET</strong> constants. The result is a fraction between zero and one, which can be used to make each zombie's speed unique. The reason we want to do this is so that the zombies don't bunch up together on top of each other too much.</li>
				<li>We can now multiply <strong class="source-inline">m_Speed</strong> by <strong class="source-inline">modifier</strong> and we will have a zombie whose speed is within the <strong class="source-inline">MAX_VARRIANCE</strong> percent of the constant defined for this type of zombie's speed.</li>
			</ul>
			<p>After we have resolved the speed, we assign the passed-in position held in <strong class="source-inline">startX</strong> and <strong class="source-inline">startY</strong> to <strong class="source-inline">m_Position.x</strong> and <strong class="source-inline">m_Position.y</strong>, respectively.</p>
			<p>The last two lines of code in the previous listing set the origin of the sprite to the center and use the <strong class="source-inline">m_Position</strong> vector to set the position of the sprite.</p>
			<p>Now, add the following code for the <strong class="source-inline">hit</strong> function to the <strong class="source-inline">Zombie.cpp</strong> file:</p>
			<p class="source-code">bool Zombie::hit()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Health--;</p>
			<p class="source-code">    if (m_Health &lt; 0)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // dead</p>
			<p class="source-code">        m_Alive = false;</p>
			<p class="source-code">        m_Sprite.setTexture(TextureHolder::GetTexture(</p>
			<p class="source-code">            "graphics/blood.png"));</p>
			<p class="source-code">        return true; </p>
			<p class="source-code">    }</p>
			<p class="source-code">    // injured but not dead yet</p>
			<p class="source-code">    return false;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">hit</strong> function is nice and simple: reduce <strong class="source-inline">m_Health</strong> by one and then check whether <strong class="source-inline">m_Health</strong> is below zero.</p>
			<p>If it is below zero, then it sets <strong class="source-inline">m_Alive</strong> to false, swaps the zombie's texture for a blood splat, and returns <strong class="source-inline">true</strong> to the calling code so that it knows the zombie is now dead. If the zombie has survived, the hit returns <strong class="source-inline">false</strong>.</p>
			<p>Add the following three getter functions, which just return a value to the calling code:</p>
			<p class="source-code">bool Zombie::isAlive()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Alive;</p>
			<p class="source-code">}</p>
			<p class="source-code">FloatRect Zombie::getPosition()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Sprite.getGlobalBounds();</p>
			<p class="source-code">}</p>
			<p class="source-code">Sprite Zombie::getSprite()</p>
			<p class="source-code">{</p>
			<p class="source-code">    return m_Sprite;</p>
			<p class="source-code">}</p>
			<p>The previous three functions are quite self-explanatory, perhaps with the exception of the <strong class="source-inline">getPosition</strong> function, which uses the <strong class="source-inline">m_Sprite.getLocalBounds</strong> function to get the <strong class="source-inline">FloatRect</strong> instance, which is then returned to the calling code.</p>
			<p>Finally, for the <strong class="source-inline">Zombie</strong> class, we need to add the code for the <strong class="source-inline">update</strong> function. Look closely at the following code, and then we will go through it:</p>
			<p class="source-code">void Zombie::update(float elapsedTime, </p>
			<p class="source-code">    Vector2f playerLocation)</p>
			<p class="source-code">{</p>
			<p class="source-code">    float playerX = playerLocation.x;</p>
			<p class="source-code">    float playerY = playerLocation.y;</p>
			<p class="source-code">    // Update the zombie position variables</p>
			<p class="source-code">    if (playerX &gt; m_Position.x)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Position.x = m_Position.x + </p>
			<p class="source-code">            m_Speed * elapsedTime;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (playerY &gt; m_Position.y)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Position.y = m_Position.y + </p>
			<p class="source-code">            m_Speed * elapsedTime;</p>
			<p class="source-code">    }</p>
			<p class="source-code">        </p>
			<p class="source-code">    if (playerX &lt; m_Position.x)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Position.x = m_Position.x - </p>
			<p class="source-code">            m_Speed * elapsedTime;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if (playerY &lt; m_Position.y)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        m_Position.y = m_Position.y - </p>
			<p class="source-code">            m_Speed * elapsedTime;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Move the sprite</p>
			<p class="source-code">    m_Sprite.setPosition(m_Position);</p>
			<p class="source-code">    // Face the sprite in the correct direction</p>
			<p class="source-code">    float angle = (atan2(playerY - m_Position.y,</p>
			<p class="source-code">        playerX - m_Position.x)</p>
			<p class="source-code">        * 180) / 3.141;</p>
			<p class="source-code">    m_Sprite.setRotation(angle);</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we copy <strong class="source-inline">playerLocation.x</strong> and <strong class="source-inline">playerLocation.y</strong> into the local variables called <strong class="source-inline">playerX</strong> and <strong class="source-inline">playerY</strong>.</p>
			<p>Next, there are four <strong class="source-inline">if</strong> statements. They test to see whether the zombie is to the left, right, above, or below the current player's position. These four <strong class="source-inline">if</strong> statements, when they evaluate to true, adjust the zombie's <strong class="source-inline">m_Position.x</strong> and <strong class="source-inline">m_Position.y</strong> values appropriately using the usual formula, that is, speed multiplied by time since last frame. More specifically, the code is<strong class="source-inline"> m_Speed * elapsedTime</strong>.</p>
			<p>After the four <strong class="source-inline">if </strong>statements, <strong class="source-inline">m_Sprite</strong> is moved to its new location.</p>
			<p>We then use the same calculation we previously used with the player and the mouse pointer, but this time, we do so for the zombie and the player. This calculation finds the angle that's needed to face the zombie toward the player.</p>
			<p>Finally, for this function and the class, we call <strong class="source-inline">m_Sprite.setRotation</strong> to actually rotate the zombie sprite. Remember that this function will be called for every zombie (that is alive) on every frame of the game.</p>
			<p>But, we want a whole horde of zombies.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor242"/>Using the Zombie class to create a horde</h2>
			<p>Now that we have a class to create a living, attacking, and killable zombie, we want to spawn a whole horde of them.</p>
			<p>To achieve this, we will write a separate function and we will use a pointer so that we can refer to our horde that will be declared in <strong class="source-inline">main</strong> but configured in a different scope.</p>
			<p>Open the <strong class="source-inline">ZombieArena.h</strong> file in Visual Studio and add the following highlighted lines of code:</p>
			<p class="source-code">#pragma once</p>
			<p class="source-code"><strong class="bold">#include "Zombie.h"</strong></p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">int createBackground(VertexArray&amp; rVA, IntRect arena);</p>
			<p class="source-code"><strong class="bold">Zombie* createHorde(int numZombies, IntRect arena);</strong></p>
			<p>Now that we have a prototype, we can code the function definition.</p>
			<p>Create a new <strong class="source-inline">.cpp</strong> file that will contain the function definition. Right-click <strong class="bold">Source Files</strong> in the <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add | New Item...</strong>. In the <strong class="bold">Add New Item</strong> window, highlight (by left-clicking) <strong class="bold">C++ File (.cpp)</strong>, and then in the <strong class="bold">Name</strong> field, type <strong class="source-inline">CreateHorde.cpp</strong>. Finally, click the <strong class="bold">Add</strong> button.</p>
			<p>Add in the following code to the <strong class="source-inline">CreateHorde.cpp</strong> file and study it. Afterward, we will break it down into chunks and discuss it:</p>
			<p class="source-code">#include "ZombieArena.h"</p>
			<p class="source-code">#include "Zombie.h"</p>
			<p class="source-code">Zombie* createHorde(int numZombies, IntRect arena) </p>
			<p class="source-code">{</p>
			<p class="source-code">    Zombie* zombies = new Zombie[numZombies];</p>
			<p class="source-code">    int maxY = arena.height - 20;</p>
			<p class="source-code">    int minY = arena.top + 20;</p>
			<p class="source-code">    int maxX = arena.width - 20;</p>
			<p class="source-code">    int minX = arena.left + 20;</p>
			<p class="source-code">    for (int i = 0; i &lt; numZombies; i++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        </p>
			<p class="source-code">        // Which side should the zombie spawn</p>
			<p class="source-code">        srand((int)time(0) * i);</p>
			<p class="source-code">        int side = (rand() % 4);</p>
			<p class="source-code">        float x, y;</p>
			<p class="source-code">        switch (side)</p>
			<p class="source-code">        {</p>
			<p class="source-code">        case 0:</p>
			<p class="source-code">            // left</p>
			<p class="source-code">            x = minX;</p>
			<p class="source-code">            y = (rand() % maxY) + minY;</p>
			<p class="source-code">            break;</p>
			<p class="source-code">        case 1:</p>
			<p class="source-code">            // right</p>
			<p class="source-code">            x = maxX;</p>
			<p class="source-code">            y = (rand() % maxY) + minY;</p>
			<p class="source-code">            break;</p>
			<p class="source-code">        case 2:</p>
			<p class="source-code">            // top</p>
			<p class="source-code">            x = (rand() % maxX) + minX;</p>
			<p class="source-code">            y = minY;</p>
			<p class="source-code">            break;</p>
			<p class="source-code">        case 3:</p>
			<p class="source-code">            // bottom</p>
			<p class="source-code">            x = (rand() % maxX) + minX;</p>
			<p class="source-code">            y = maxY;</p>
			<p class="source-code">            break;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        // Bloater, crawler or runner</p>
			<p class="source-code">        srand((int)time(0) * i * 2);</p>
			<p class="source-code">        int type = (rand() % 3);</p>
			<p class="source-code">        // Spawn the new zombie into the array</p>
			<p class="source-code">        zombies[i].spawn(x, y, type, i);</p>
			<p class="source-code">                </p>
			<p class="source-code">    }</p>
			<p class="source-code">    return zombies;</p>
			<p class="source-code">}</p>
			<p>Let's look at all the previous code again, in bite-size pieces. First, we added the now familiar <strong class="source-inline">include</strong> directives:</p>
			<p class="source-code">#include "ZombieArena.h"</p>
			<p class="source-code">#include "Zombie.h"</p>
			<p>Next comes the function signature. Notice that the function must return a pointer to a <strong class="source-inline">Zombie</strong> object. We will be creating an array of <strong class="source-inline">Zombie</strong> objects. Once we are done creating the horde, we will return the array. When we return the array, we are actually returning the address of the first element of the array. This, as we learned in the section on pointers earlier in this chapter, is the same thing as a pointer. The signature also shows that we have two parameters. The first, <strong class="source-inline">numZombies</strong>, will be the number of zombies this current horde requires and the second, <strong class="source-inline">arena</strong>, is an <strong class="source-inline">IntRect</strong> that holds the size of the current arena in which to create this horde.</p>
			<p>After the function signature, we declare a pointer to the <strong class="source-inline">Zombie</strong> type called <strong class="source-inline">zombies</strong> and initialize it with the memory address of the first element of an array, which we dynamically allocate on the heap:</p>
			<p class="source-code">Zombie* createHorde(int numZombies, IntRect arena) </p>
			<p class="source-code">{</p>
			<p class="source-code">    Zombie* zombies = new Zombie[numZombies];</p>
			<p>The next part of the code simply copies the extremities of the arena into <strong class="source-inline">maxY</strong>, <strong class="source-inline">minY</strong>, <strong class="source-inline">maxX</strong>, and <strong class="source-inline">minX</strong>. We subtract twenty pixels from the right and bottom while adding twenty pixels to the top and left. We use these four local variables to help position each of the zombies. We made the twenty-pixel adjustments to stop the zombies appearing on top of the walls:</p>
			<p class="source-code">int maxY = arena.height - 20;</p>
			<p class="source-code">int minY = arena.top + 20;</p>
			<p class="source-code">int maxX = arena.width - 20;</p>
			<p class="source-code">int minX = arena.left + 20;</p>
			<p>Now, we enter a <strong class="source-inline">for</strong> loop that will loop through each of the <strong class="source-inline">Zombie</strong> objects in the <strong class="source-inline">zombies</strong> array from zero through to <strong class="source-inline">numZombies</strong>:</p>
			<p class="source-code">for (int i = 0; i &lt; numZombies; i++)</p>
			<p>Inside the <strong class="source-inline">for</strong> loop, the first thing the code does is seed the random number generator and then generate a random number between zero and three. This number is stored in the <strong class="source-inline">side</strong> variable. We will use the <strong class="source-inline">side</strong> variable to decide whether the zombie spawns at the left, top, right, or bottom of the arena. We also declare two <strong class="source-inline">int</strong> variables, <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>. These two variables will temporarily hold the actual horizontal and vertical coordinates of the current zombie:</p>
			<p class="source-code">// Which side should the zombie spawn</p>
			<p class="source-code">srand((int)time(0) * i);</p>
			<p class="source-code">int side = (rand() % 4);</p>
			<p class="source-code">float x, y;</p>
			<p>Still inside the <strong class="source-inline">for</strong> loop, we have a <strong class="source-inline">switch</strong> block with four <strong class="source-inline">case</strong> statements. Note that the <strong class="source-inline">case</strong> statements are for <strong class="source-inline">0</strong>, <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, and <strong class="source-inline">3</strong>, and that the argument in the <strong class="source-inline">switch</strong> statement is <strong class="source-inline">side</strong>. Inside each of the <strong class="source-inline">case</strong> blocks, we initialize <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> with one predetermined value, either <strong class="source-inline">minX</strong>, <strong class="source-inline">maxX</strong>, <strong class="source-inline">minY</strong>, or <strong class="source-inline">maxY</strong>, and one randomly generated value. Look closely at the combinations of each predetermined and random value. You will see that they are appropriate for positioning the current zombie randomly across either the left side, top side, right side, or bottom side. The effect of this will be that each zombie can spawn randomly, anywhere on the outside edge of the arena: </p>
			<p class="source-code">switch (side)</p>
			<p class="source-code">{</p>
			<p class="source-code">    case 0:</p>
			<p class="source-code">        // left</p>
			<p class="source-code">        x = minX;</p>
			<p class="source-code">        y = (rand() % maxY) + minY;</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    case 1:</p>
			<p class="source-code">        // right</p>
			<p class="source-code">        x = maxX;</p>
			<p class="source-code">        y = (rand() % maxY) + minY;</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    case 2:</p>
			<p class="source-code">        // top</p>
			<p class="source-code">        x = (rand() % maxX) + minX;</p>
			<p class="source-code">        y = minY;</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    case 3:</p>
			<p class="source-code">        // bottom</p>
			<p class="source-code">        x = (rand() % maxX) + minX;</p>
			<p class="source-code">        y = maxY;</p>
			<p class="source-code">        break;        </p>
			<p class="source-code">}</p>
			<p>Still inside the <strong class="source-inline">for</strong> loop, we seed the random number generator again and generate a random number between 0 and 2. We store this number in the <strong class="source-inline">type</strong> variable. The <strong class="source-inline">type</strong> variable will determine whether the current zombie will be a Chaser, Bloater, or Crawler.</p>
			<p>After the type is determined, we call the <strong class="source-inline">spawn</strong> function on the current <strong class="source-inline">Zombie</strong> object in the <strong class="source-inline">zombies</strong> array. As a reminder, the arguments that are sent into the <strong class="source-inline">spawn</strong> function determine the starting location of the zombie and the type of zombie it will be. The apparently arbitrary <strong class="source-inline">i </strong>is passed in as it is used as a unique seed that randomly varies the speed of a zombie within an appropriate range. This stops our zombies "bunching up" and becoming a blob rather than a horde:</p>
			<p class="source-code">// Bloater, crawler or runner</p>
			<p class="source-code">srand((int)time(0) * i * 2);</p>
			<p class="source-code">int type = (rand() % 3);</p>
			<p class="source-code">// Spawn the new zombie into the array</p>
			<p class="source-code">zombies[i].spawn(x, y, type, i);</p>
			<p>The <strong class="source-inline">for </strong>loop repeats itself once for each zombie, controlled by the value contained in <strong class="source-inline">numZombies</strong>, and then we return the array. The array, as another reminder, is simply an address of the first element of itself. The array is dynamically allocated on the heap, so it persists after the function returns:</p>
			<p class="source-code">return zombies;</p>
			<p>Now, we can bring our zombies to life.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor243"/>Bringing the horde to life (back to life)</h2>
			<p>We have a <strong class="source-inline">Zombie</strong> class and a function to make a randomly spawning horde of them. We have the <strong class="source-inline">TextureHolder</strong> singleton as a neat way to hold just three textures that can be used for dozens or even thousands of zombies. Now, we can add the horde to our game engine in <strong class="source-inline">main</strong>.</p>
			<p>Add the following highlighted code to include the <strong class="source-inline">TextureHolder</strong> class. Then, just inside <strong class="source-inline">main</strong>, we will initialize the one and only instance of <strong class="source-inline">TextureHolder</strong>, which can be used from anywhere within our game:</p>
			<p class="source-code">#include &lt;SFML/Graphics.hpp&gt;</p>
			<p class="source-code">#include "ZombieArena.h"</p>
			<p class="source-code">#include "Player.h"</p>
			<p class="source-code"><strong class="bold">#include "TextureHolder.h"</strong></p>
			<p class="source-code">using namespace sf;</p>
			<p class="source-code">int main()</p>
			<p class="source-code">{</p>
			<p class="source-code"><strong class="bold">    // Here is the instance of TextureHolder</strong></p>
			<p class="source-code"><strong class="bold">    TextureHolder holder;</strong></p>
			<p class="source-code">    // The game will always be in one of four states</p>
			<p class="source-code">    enum class State { PAUSED, LEVELING_UP, GAME_OVER, PLAYING };</p>
			<p class="source-code">    // Start with the GAME_OVER state</p>
			<p class="source-code">    State state = State::GAME_OVER;</p>
			<p>The following few lines of highlighted code declare some control variables for the number of zombies at the start of the wave, the number of zombies still to be killed, and, of course, a pointer to <strong class="source-inline">Zombie</strong> called <strong class="source-inline">zombies</strong> that we initialize to <strong class="source-inline">nullptr</strong>:</p>
			<p class="source-code">// Create the background</p>
			<p class="source-code">VertexArray background;</p>
			<p class="source-code">// Load the texture for our background vertex array</p>
			<p class="source-code">Texture textureBackground;</p>
			<p class="source-code">textureBackground.loadFromFile("graphics/background_sheet.png");</p>
			<p class="source-code"><strong class="bold">// Prepare for a horde of zombies</strong></p>
			<p class="source-code"><strong class="bold">int numZombies;</strong></p>
			<p class="source-code"><strong class="bold">int numZombiesAlive;</strong></p>
			<p class="source-code"><strong class="bold">Zombie* zombies = nullptr;</strong></p>
			<p class="source-code">// The main game loop</p>
			<p class="source-code">while (window.isOpen())</p>
			<p>Next, in the <strong class="source-inline">PLAYING</strong> section, nested inside the <strong class="source-inline">LEVELING_UP</strong> section, we add code that does the following:</p>
			<ul>
				<li>Initializes <strong class="source-inline">numZombies</strong> to <strong class="source-inline">10</strong>. As the project progresses, this will eventually be dynamic and based on the current wave number.</li>
				<li>Delete any preexisting allocated memory. Otherwise, each new call to <strong class="source-inline">createHorde</strong> would take up progressively more memory but without freeing up the previous horde's memory.</li>
				<li>Then, we call <strong class="source-inline">createHorde</strong> and assign the returned memory address to <strong class="source-inline">zombies</strong>.</li>
				<li>We also initialize <strong class="source-inline">zombiesAlive</strong> with <strong class="source-inline">numZombies </strong>because we haven't killed any at this point.</li>
			</ul>
			<p>Add the following highlighted code, which we have just discussed:</p>
			<p class="source-code">if (state == State::PLAYING)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Prepare the level</p>
			<p class="source-code">    // We will modify the next two lines later</p>
			<p class="source-code">    arena.width = 500;</p>
			<p class="source-code">    arena.height = 500;</p>
			<p class="source-code">    arena.left = 0;</p>
			<p class="source-code">    arena.top = 0;</p>
			<p class="source-code">    // Pass the vertex array by reference </p>
			<p class="source-code">    // to the createBackground function</p>
			<p class="source-code">    int tileSize = createBackground(background, arena);</p>
			<p class="source-code">    // Spawn the player in the middle of the arena</p>
			<p class="source-code">    player.spawn(arena, resolution, tileSize);</p>
			<p class="source-code"><strong class="bold">    // Create a horde of zombies</strong></p>
			<p class="source-code"><strong class="bold">    numZombies = 10;</strong></p>
			<p class="source-code"><strong class="bold">    // Delete the previously allocated memory (if it exists)</strong></p>
			<p class="source-code"><strong class="bold">    delete[] zombies;</strong></p>
			<p class="source-code"><strong class="bold">    zombies = createHorde(numZombies, arena);</strong></p>
			<p class="source-code"><strong class="bold">    numZombiesAlive = numZombies;</strong></p>
			<p class="source-code">    // Reset the clock so there isn't a frame jump</p>
			<p class="source-code">    clock.restart();</p>
			<p class="source-code">}</p>
			<p>Now, add the following highlighted code to the <strong class="source-inline">ZombieArena.cpp</strong> file: </p>
			<p class="source-code">/*</p>
			<p class="source-code"> ****************</p>
			<p class="source-code"> UPDATE THE FRAME</p>
			<p class="source-code"> ****************</p>
			<p class="source-code"> */</p>
			<p class="source-code">if (state == State::PLAYING)</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Update the delta time</p>
			<p class="source-code">    Time dt = clock.restart();</p>
			<p class="source-code">    // Update the total game time</p>
			<p class="source-code">    gameTimeTotal += dt;</p>
			<p class="source-code">    // Make a decimal fraction of 1 from the delta time</p>
			<p class="source-code">    float dtAsSeconds = dt.asSeconds();</p>
			<p class="source-code">    // Where is the mouse pointer</p>
			<p class="source-code">    mouseScreenPosition = Mouse::getPosition();</p>
			<p class="source-code">    // Convert mouse position to world coordinates of mainView</p>
			<p class="source-code">    mouseWorldPosition = window.mapPixelToCoords(</p>
			<p class="source-code">        Mouse::getPosition(), mainView);</p>
			<p class="source-code">    // Update the player</p>
			<p class="source-code">    player.update(dtAsSeconds, Mouse::getPosition());</p>
			<p class="source-code">    // Make a note of the players new position</p>
			<p class="source-code">    Vector2f playerPosition(player.getCenter());</p>
			<p class="source-code">    // Make the view centre around the player                </p>
			<p class="source-code">    mainView.setCenter(player.getCenter());</p>
			<p class="source-code"><strong class="bold">    // Loop through each Zombie and update them</strong></p>
			<p class="source-code"><strong class="bold">    for (int i = 0; i &lt; numZombies; i++)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        if (zombies[i].isAlive())</strong></p>
			<p class="source-code"><strong class="bold">        {</strong></p>
			<p class="source-code"><strong class="bold">            zombies[i].update(dt.asSeconds(), playerPosition);</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}// End updating the scene</p>
			<p>All the new preceding code does is loop through the array of zombies, check whether the current zombie is alive and, if it is, calls its <strong class="source-inline">update</strong> function with the necessary arguments.</p>
			<p>Add the following code to draw all the zombies:</p>
			<p class="source-code">/*</p>
			<p class="source-code"> **************</p>
			<p class="source-code"> Draw the scene</p>
			<p class="source-code"> **************</p>
			<p class="source-code"> */</p>
			<p class="source-code">if (state == State::PLAYING)</p>
			<p class="source-code">{</p>
			<p class="source-code">    window.clear();</p>
			<p class="source-code">    // set the mainView to be displayed in the window</p>
			<p class="source-code">    // And draw everything related to it</p>
			<p class="source-code">    window.setView(mainView);</p>
			<p class="source-code">    // Draw the background</p>
			<p class="source-code">    window.draw(background, &amp;textureBackground);</p>
			<p class="source-code"><strong class="bold">    // Draw the zombies</strong></p>
			<p class="source-code"><strong class="bold">    for (int i = 0; i &lt; numZombies; i++)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        window.draw(zombies[i].getSprite());</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">    // Draw the player</p>
			<p class="source-code">    window.draw(player.getSprite());</p>
			<p class="source-code">}</p>
			<p>The preceding code loops through all the zombies and calls the <strong class="source-inline">getSprite</strong> function to allow the <strong class="source-inline">draw</strong> function to do its work. We don't check whether the zombie is alive because even if the zombie is dead, we want to draw the blood splatter.</p>
			<p>At the end of the main function, we need to make sure to delete our pointer because it is a good practice as well as often being essential. However, technically, this isn't essential because the game is about to exit, and the operating system will reclaim all the memory that's used after the <strong class="source-inline">return 0</strong> statement:</p>
			<p class="source-code">    }// End of main game loop</p>
			<p class="source-code"><strong class="bold">     // Delete the previously allocated memory (if it exists)</strong></p>
			<p class="source-code"><strong class="bold">    delete[] zombies;</strong></p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>You can run the game and see the zombies spawn around the edge of the arena. They will immediately head straight toward the player at their various speeds. Just for fun, I increased the size of the arena and increased the number of zombies to 1,000 as you can see in the following screenshot:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B14278_10_01.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption"> This is going to end badly!</p>
			<p>Note that you can also pause and resume the onslaught of the horde using the <em class="italic">Enter</em> key because of the code we wrote in <a href="B14278_08_Final_AG_ePub.xhtml#_idTextAnchor183"><em class="italic">Chapter 8</em></a>,<em class="italic"> SFML Views – Starting the Zombie Shooter Game</em>.</p>
			<p>Let's fix the fact that some classes still use a <strong class="source-inline">Texture</strong> instance directly and modify it to use the new <strong class="source-inline">TextureHolder</strong> class.</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor244"/>Using the TextureHolder class for all textures</h1>
			<p>Since we have our <strong class="source-inline">TextureHolder</strong> class, we might as well be consistent and use it to load all our textures. Let's make some very small alterations to the existing code that loads textures for the background sprite sheet and the player.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor245"/>Changing the way the background gets its textures</h2>
			<p>In the <strong class="source-inline">ZombieArena.cpp</strong> file, find the following code:</p>
			<p class="source-code">// Load the texture for our background vertex array</p>
			<p class="source-code"><strong class="bold">Texture textureBackground;</strong></p>
			<p class="source-code"><strong class="bold">textureBackground.loadFromFile("graphics/background_sheet.png");</strong></p>
			<p>Delete the code highlighted previously and replace it with the following highlighted code, which uses our new <strong class="source-inline">TextureHolder</strong> class:</p>
			<p class="source-code">// Load the texture for our background vertex array</p>
			<p class="source-code"><strong class="bold">Texture textureBackground = TextureHolder::GetTexture(</strong></p>
			<p class="source-code"><strong class="bold">    "graphics/background_sheet.png");</strong></p>
			<p>Let's update the way the <strong class="source-inline">Player</strong> class gets a texture.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor246"/>Changing the way the Player gets its texture</h2>
			<p>In the <strong class="source-inline">Player.cpp</strong> file, inside the constructor, find this code:</p>
			<p class="source-code">#include "player.h"</p>
			<p class="source-code">Player::Player()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Speed = START_SPEED;</p>
			<p class="source-code">    m_Health = START_HEALTH;</p>
			<p class="source-code">    m_MaxHealth = START_HEALTH;</p>
			<p class="source-code">    // Associate a texture with the sprite</p>
			<p class="source-code">    // !!Watch this space!!</p>
			<p class="source-code"><strong class="bold">    m_Texture.loadFromFile("graphics/player.png");</strong></p>
			<p class="source-code"><strong class="bold">    m_Sprite.setTexture(m_Texture);</strong></p>
			<p class="source-code">    // Set the origin of the sprite to the centre, </p>
			<p class="source-code">    // for smooth rotation</p>
			<p class="source-code">    m_Sprite.setOrigin(25, 25);</p>
			<p class="source-code">}</p>
			<p>Delete the code highlighted previously and replace it with the following highlighted code, which uses our new <strong class="source-inline">TextureHolder</strong> class. In addition, add the <strong class="source-inline">include</strong> directive to add the <strong class="source-inline">TextureHolder</strong> header to the file. The new code is shown highlighted, in context, as follows:</p>
			<p class="source-code">#include "player.h"</p>
			<p class="source-code"><strong class="bold">#include "TextureHolder.h"</strong></p>
			<p class="source-code">Player::Player()</p>
			<p class="source-code">{</p>
			<p class="source-code">    m_Speed = START_SPEED;</p>
			<p class="source-code">    m_Health = START_HEALTH;</p>
			<p class="source-code">    m_MaxHealth = START_HEALTH;</p>
			<p class="source-code">    // Associate a texture with the sprite</p>
			<p class="source-code">    // !!Watch this space!!</p>
			<p class="source-code"><strong class="bold">    m_Sprite = Sprite(TextureHolder::GetTexture(</strong></p>
			<p class="source-code"><strong class="bold">            "graphics/player.png"));</strong></p>
			<p class="source-code">    // Set the origin of the sprite to the centre, </p>
			<p class="source-code">    // for smooth rotation</p>
			<p class="source-code">    m_Sprite.setOrigin(25, 25);</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">From now on, we will use the <strong class="source-inline">TextureHolder</strong> class for loading all textures.</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor247"/>Summary</h1>
			<p>In this chapter, we have covered pointers and discussed that they are variables that hold a memory address to a specific type of object. The full significance of this will begin to reveal itself as this book progresses and the power of pointers is revealed. We also used pointers in order to create a huge horde of zombies that can be accessed using a pointer, which it turns out is also the same thing as the first element of an array.</p>
			<p>We learned about the STL, and in particular the <strong class="source-inline">map</strong> class. We implemented a class that will store all our textures, as well as provide access to them.</p>
			<p>You might have noticed that the zombies don't appear to be very dangerous. They just drift through the player without leaving a scratch. Currently, this is a good thing because the player has no way to defend themselves. </p>
			<p>In the next chapter, we will make two more classes: one for ammo and health pickups and one for bullets that the player can shoot. After we have done that, we will learn how to detect collisions so that the bullets and zombies do some damage and the pickups can be collected by the player.</p>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor248"/>FAQ</h1>
			<p>Here are some questions that might be on your mind:</p>
			<p>Q) What's the difference between pointers and references?</p>
			<p>A) Pointers are like references with boosters. Pointers can be changed to point to different variables (memory addresses), as well as point to dynamically allocated memory on the free store.</p>
			<p>Q) What's the deal with arrays and pointers?</p>
			<p>A) Arrays are really constant pointers to their first element. </p>
			<p>Q) Can you remind me about the <strong class="source-inline">new</strong> keyword and memory leaks?</p>
			<p>A) When we use memory on the free store using the <strong class="source-inline">new</strong> keyword, it persists even when the function it was created in has returned and all the local variables are gone. When we are done with using memory on the free store, we must release it. So, if we use memory on the free store that we want to persist beyond the life of a function, we must make sure to keep a pointer to it or we will have leaked memory. It would be like putting all our belongings in our house and then forgetting where we live! When we return the <strong class="source-inline">zombies</strong> array from <strong class="source-inline">createHorde</strong>, it is like passing the relay baton (memory address) from <strong class="source-inline">createHorde</strong> to <strong class="source-inline">main</strong>. It's like saying, <em class="italic">OK, here is your horde of zombies— they are your responsibility now</em>. And, we wouldn't want any leaked zombies running around in our RAM! So, we must remember to call <strong class="source-inline">delete</strong> on pointers to dynamically allocated memory.</p>
		</div>
	</body></html>