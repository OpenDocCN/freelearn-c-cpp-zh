- en: Chapter 5. Hit and Run
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。碰撞与逃逸
- en: You've already come a long way since beginning the book at the first chapter!
    You have managed to render moving images to the screen and control their movement.
    You are well on your way toward creating a great game. The next step is to code
    the interactions between various objects in the game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自从你在第一章开始阅读本书以来，你已经取得了很大的进步！你已经能够将移动图像渲染到屏幕上并控制它们的移动。你正在朝着创建一个伟大的游戏迈进。下一步是编写游戏中各种对象之间的交互代码。
- en: 'This chapter will explain how to implement collision detection. Collision detection
    determines how objects interact with each other when they are in the same location.
    Topics will include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释如何实现碰撞检测。碰撞检测确定当对象位于同一位置时它们如何相互作用。包括以下主题：
- en: '**Boundary detection**: When an object reaches the top, bottom, left, or right
    edge of the screen, what should happen? There are a surprising number of choices
    and you get to choose what to do.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界检测**：当一个对象达到屏幕的顶部、底部、左侧或右侧边缘时，会发生什么？有惊人的多种选择，你可以选择你想要做什么。'
- en: '**Collision detection**: There are various scenarios that we often need to
    check to determine whether two objects have hit each other. We will cover circular
    and rectangular collision detection algorithms. We will also discuss when each
    type of collision detection is appropriate to use.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞检测**：存在各种场景，我们经常需要检查以确定两个对象是否相撞。我们将介绍圆形和矩形碰撞检测算法。我们还将讨论何时使用每种类型的碰撞检测是合适的。'
- en: Out of bounds!
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超出边界！
- en: If you run our current game, you will notice that the robot will go off the
    screen if you allow him to continue moving to the left or right. When he reaches
    the edge of the screen, he will keep on moving until he is no longer visible.
    If you reverse his direction and make him move the same number of steps now, he
    will reappear on the screen.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行我们当前的游戏，你会注意到，如果你允许机器人继续向左或向右移动，它将会离开屏幕。当他到达屏幕边缘时，他会继续移动，直到他不再可见。如果你反转他的方向，并让他移动相同的步数，他将会重新出现在屏幕上。
- en: 'Whenever an object reaches the edge of the screen, we often want it to do something
    special, such as stopping, or turning around. The code that determines when an
    object has reached a screen edge is known as **boundary checking**. There are
    many possibilities for what we can do when an object reaches a boundary:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象达到屏幕边缘时，我们通常希望它执行一些特殊操作，例如停止或转身。确定对象何时达到屏幕边缘的代码称为**边界检测**。当对象达到边界时，我们可以做的事情有很多可能性。
- en: Stop the object
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止对象
- en: Allow the object to continue past the border (and therefore, disappear)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许对象超出边界（因此，消失）
- en: Allow the object to continue past the border and reappear at the opposite border
    (ever played the arcade version of Asteroids?)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许对象超出边界并在对面的边界重新出现（你玩过Asteroids的街机版本吗？）
- en: Scroll the camera and the screen along with the object (aka Mario)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿着对象（即马里奥）滚动相机和屏幕
- en: Allow the object to rebound off the border (ever played Breakout?)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许对象反弹离开边界（你玩过Breakout吗？）
- en: As our Robo is controlled by the player, we will simply force him to stop moving
    when he has reached the edge of the screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的机器人由玩家控制，我们将简单地强制他在到达屏幕边缘时停止移动。
- en: Getting anchored
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取锚点
- en: In order to implement boundary checking, you must first know the exact anchor
    point of the image. Technically, the anchor point could be anywhere, but the two
    most common locations are the top-left corner and the center of the image.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现边界检查，你必须首先知道图像的确切锚点。技术上，锚点可以位于任何位置，但最常见的两个位置是左上角和图像中心。
- en: First, let's see what happens if we just ignore the anchor point. Open the **RoboRacer2D**
    project and then open `RoboRacer2D.cpp`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如果我们忽略锚点会发生什么。打开**RoboRacer2D**项目，然后打开`RoboRacer2D.cpp`。
- en: 'Insert the following function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 插入以下函数：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is what this code is doing for us:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这段代码为我们做了什么：
- en: The function accepts a sprite as its parameter
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数接受一个精灵作为其参数
- en: The function first checks to see whether the `x` position of the sprite is less
    than `0`, where `0` is the `x` coordinate of the far-left edge of the screen
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数首先检查精灵的`x`位置是否小于`0`，其中`0`是屏幕最左边缘的`x`坐标
- en: The function then checks to see whether the `x` position of the sprite is greater
    than the screen width, where `screen_width` is the `x` coordinate of the far-right
    edge of the screen
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数随后检查精灵的`x`位置是否大于屏幕宽度，其中`screen_width`是屏幕最右边缘的`x`坐标
- en: If either check is `true`, the sprite's velocity is set to `0`, effectively
    stopping the sprite in its tracks
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何一个检查为 `true`，精灵的速度将被设置为 `0`，从而有效地阻止了精灵的运动
- en: 'Now, add the highlighted line of code to the `Update` function right after
    `ProcessInput` in `RoboRacer2D.cpp`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将高亮的代码行添加到 `RoboRacer2D.cpp` 中的 `Update` 函数，紧接在 `ProcessInput` 之后：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This simply calls the `CheckBoundaries` function that we just created and passes
    in the `player` object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是调用我们刚刚创建的 `CheckBoundaries` 函数，并传入 `player` 对象。
- en: Now, run the program. Move Robo until he reaches the far left of the screen.
    Then run him to the far right of the screen. Does anything seem wrong about the
    way we have implemented our boundary checking?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行程序。移动 Robo 直到他到达屏幕的左端。然后将他移动到屏幕的右端。我们实现边界检查的方式有什么不妥之处吗？
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Ignore the way the background scrolls off to the side. We'll fix this shortly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略背景向一侧滚动的方式。我们很快就会修复这个问题。
- en: '**Problem 1**: Robo doesn''t seem to hit the boundary on the left.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 1**：Robo 似乎没有碰到左边的边界。'
- en: The following screenshot shows you what happens if you allow Robo to go to the
    far left of the screen. He appears to stop just before reaching the edge. Although
    you can't see it in the following screenshot, there is a shadow that always extends
    to the left edge of the robot. It is the left edge of the shadow that is being
    detected as the edge of the image.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了如果你允许 Robo 前往屏幕的左端会发生什么。他看起来在到达边缘前就停止了。尽管你无法在以下截图中看到，但有一个影子始终延伸到机器人的左侧。被检测为图像边缘的是影子的左边缘。
- en: It turns out that the default anchor point for images loaded by our image loading
    routine is, in fact, the upper-left corner.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们通过图像加载例程加载的图像的默认锚点实际上是在左上角。
- en: '![Getting anchored](img/8199OS_05_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![获得锚点](img/8199OS_05_01.jpg)'
- en: '**Problem 2**: Robo moves completely off the screen to the right.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 2**：Robo 完全移出屏幕到右边。'
- en: The following screenshot shows you what occurs if you allow Robo to continue
    traveling to the right. Now that you understand that the anchor point is at the
    upper-left, you may already understand what is happening.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了如果你允许 Robo 继续向右移动会发生什么。现在你理解了锚点位于左上角，你可能已经明白了正在发生的事情。
- en: 'As the boundary checking is based on the `x` coordinate of the sprite, by the
    time the upper-left hand corner exceeds the screen width, the entire sprite has
    already moved off the screen. The grayscale image of the robot shows us where
    his actual position would be if we could see him:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于边界检查是基于精灵的 `x` 坐标，当左上角超过屏幕宽度时，整个精灵已经移出屏幕。机器人的灰度图像显示了他实际的位置，如果我们能看到他的话：
- en: '![Getting anchored](img/8199OS_05_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![获得锚点](img/8199OS_05_02.jpg)'
- en: '**Problem 3**: Once Robo reaches the far left or far right of the screen, he
    gets stuck. Changing his direction seems to have no effect!'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 3**：一旦 Robo 到达屏幕的左端或右端，他会卡住。改变他的方向似乎没有任何效果！'
- en: 'This problem is known as **embedding**. Here is what has happened:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题被称为 **嵌入**。以下是发生的事情：
- en: We continued check Robo's position until his *x* coordinate exceeded a threshold.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们继续检查 Robo 的位置，直到他的 *x* 坐标超过一个阈值。
- en: Once he exceeded that threshold, we set his velocity to `0`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦他超过了那个阈值，我们就将他的速度设置为 `0`。
- en: Now that Robo's *x* coordinate exceeds that threshold, it will always exceed
    that threshold. Any attempt to move him in the opposite direction will trigger
    the boundary check, which will discover that Robo's *x* coordinate still exceeds
    the threshold and his velocity will be set to `0`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在 Robo 的 *x* 坐标超过了那个阈值，它将始终超过那个阈值。任何试图将他移动到相反方向的努力都会触发边界检查，这将发现 Robo 的 *x*
    坐标仍然超过阈值，他的速度将被设置为 `0`。
- en: The solution is to set Robo's position to the other side of threshold as soon
    as we discover he has crossed it. We will add this correction, but first we have
    to understand collision rectangles.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在我们发现 Robo 已经越过阈值时立即将 Robo 的位置设置在阈值另一侧。我们将添加这个修正，但首先我们必须理解碰撞矩形。
- en: Collision rectangles
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞矩形
- en: Take a look at the following image of Robo. The solid rectangle represents the
    boundaries of the texture. The dotted rectangle represents the area that we actually
    want to consider for boundary and collision detection. This is known as the **collision
    rectangle**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下 Robo 的图像。实心矩形代表纹理的边界。虚线矩形代表我们实际上想要考虑的边界和碰撞检测区域。这被称为 **碰撞矩形**。
- en: '![Collision rectangles](img/8199OS_05_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞矩形](img/8199OS_05_03.jpg)'
- en: 'Comparing the two rectangles, here is what we would have to do to convert the
    texture rectangle to be the collision rectangle:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个矩形，以下是我们将纹理矩形转换为碰撞矩形的步骤：
- en: Add about 34 pixels to the left texture boundary
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左侧纹理边界添加大约34个像素
- en: Subtract about 10 pixels from the right texture boundary
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从右侧纹理边界减去大约10个像素
- en: Both the top and right boundaries require no adjustment
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部和右侧边界不需要调整
- en: Let's enhance the sprite class by adding functionality to define a collision
    rectangle.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加定义碰撞矩形的功能来增强精灵类。
- en: 'Open `Sprite.h` and add the following member variable:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Sprite.h`并添加以下成员变量：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then add the two accessor methods:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加两个访问器方法：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The implementation for `GetCollisionRect` is a little more complex, so we will
    put that code into `Sprite.cpp`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetCollisionRect`的实现稍微复杂一些，所以我们将这段代码放入`Sprite.cpp`：'
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s what we are doing:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在做的是：
- en: '`m_collision`: This will hold four offset values. These values will represent
    a number that must be added to the texture''s bounding rectangle to get to the
    collision rectangle that we desire.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_collision`：这将保存四个偏移量值。这些值将代表一个必须添加到纹理的边界矩形中，以得到我们想要的碰撞矩形。'
- en: '`SetCollisionRectOffset`: This accepts a `Rect` parameter that contains the
    four offsets—top, bottom, left, and right—that must be added to the top, bottom,
    left, and right of the texture boundaries to create the collision rectangle.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetCollisionRectOffset`：这个方法接受一个`Rect`参数，它包含四个偏移量——顶部、底部、左侧和右侧，这些偏移量必须添加到纹理边界的顶部、底部、左侧和右侧以创建碰撞矩形。'
- en: '`GetCollisionRect`: This returns the collision rectangle that we can actually
    use when checking boundaries and checking for collisions. This is calculated by
    adding the width and height to the sprite''s current anchor point (the top-left
    corner), and then adjusting it by the values in `m_collision`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetCollisionRect`：这个方法返回我们在检查边界和检测碰撞时实际可以使用的碰撞矩形。这是通过将宽度和高度添加到精灵的当前锚点（左上角）并调整`m_collision`中的值来计算的。'
- en: Note that `GetCollisionRect` is dynamic; it always returns the current collision
    rectangle based on the sprite's current position. Thus, we are returning the actual
    top, bottom, left, and right boundaries that need to be checked at any moment
    in the game.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`GetCollisionRect`是动态的；它总是根据精灵的当前位置返回当前的碰撞矩形。因此，我们在任何游戏时刻返回实际需要检查的顶部、底部、左侧和右侧边界。
- en: If you look closely at the design, you should be able to see that if no collision
    rectangle is defined, `GetCollisionRect` will return a collision rectangle determined
    by the texture's rectangle. Therefore, this new design allows us to use the texture
    rectangle as the collision rectangle by default. On the other hand, if we want
    to specify our own collision rectangle, we can do so using `SetCollisionRectOffset`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细观察设计，你应该能够看到如果没有定义碰撞矩形，`GetCollisionRect`将返回由纹理矩形确定的碰撞矩形。因此，这种新的设计允许我们默认使用纹理矩形作为碰撞矩形。另一方面，如果我们想指定自己的碰撞矩形，我们可以使用`SetCollisionRectOffset`来做到这一点。
- en: 'Just to be safe, we will want to initialize m_collision by adding the following
    lines to the constructor:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，我们将在构造函数中通过添加以下行来初始化m_collision：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that we have the code to support a collision rectangle, we need to define
    the collision rectangle for the robot''s sprites. Go to the `LoadTextures` function
    in `RoboRacer2D.cpp` and add the following highlighted lines just before the `return
    true` line of code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了支持碰撞矩形的代码，我们需要为机器人的精灵定义碰撞矩形。转到`RoboRacer2D.cpp`中的`LoadTextures`函数，并在`return
    true`代码行之前添加以下突出显示的行：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Remember, only add the preceding code that is highlighted. The last line of
    the code is shown to provide context.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，只添加前面的突出显示代码。代码的最后一行是为了提供上下文。
- en: 'We are now going to rewrite our boundary detection function to take advantage
    of the collision rectangle. Along the way we will solve all three of the problems
    that we encountered in our first attempt. The current code uses the anchor point
    of the image, which doesn''t accurately reflect the actual boundaries that we
    want to check. The new code will use the collision rect. Replace the `CheckBoundaries`
    function in RoboRacer2D with the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将重写我们的边界检测函数，以利用碰撞矩形。在这个过程中，我们将解决我们在第一次尝试中遇到的所有三个问题。当前的代码使用图像的锚点，这并不能准确地反映我们想要检查的实际边界。新的代码将使用碰撞矩形。将RoboRacer2D中的`CheckBoundaries`函数替换为以下代码：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code uses the collision rectangle defined for the sprite that is being
    checked. As we already discussed earlier, `GetCollisionRect` returns the top,
    bottom, left, and right boundaries for us based on the current position of the
    sprite. This greatly simplifies our code! Now, we just check to see whether the
    left edge of the sprite is less than zero or whether the right edge of the sprite
    is greater than zero, and we're done!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了为正在检查的精灵定义的碰撞矩形。正如我们之前讨论的，`GetCollisionRect`根据精灵的当前位置返回顶部、底部、左侧和右侧边界，这极大地简化了我们的代码！现在，我们只需检查精灵的左侧是否小于零，或者精灵的右侧是否大于零，我们就完成了！
- en: '![Collision rectangles](img/8199OS_05_04.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞矩形](img/8199OS_05_04.jpg)'
- en: Embedding
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入
- en: 'Hurrah! Robo now successfully stops at the edge of the screen (only the right-hand
    side is shown in the preceding image). But boo! He still gets stuck! As we mentioned
    earlier, this problem is called embedding. If we zoom in, we can see what''s going
    on:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！Robo现在成功停在屏幕边缘（前一个图像中只显示了右侧）。但是，哎呀！它仍然卡住了！正如我们之前提到的，这个问题被称为嵌入。如果我们放大，我们可以看到发生了什么：
- en: '![Embedding](img/8199OS_05_05.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![嵌入](img/8199OS_05_05.jpg)'
- en: 'The vertical line represents the edge of the screen. By the time Robo has stopped,
    his right edge has already exceeded the right edge of the screen, so we stop him.
    Unfortunately, even if we try to turn him around to go in the other direction,
    the `CheckBoundaries` function will check on the very next frame, before Robo
    has a chance to start moving back:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直线代表屏幕的边缘。当Robo停止时，它的右边缘已经超过了屏幕的右边缘，所以我们停止它。不幸的是，即使我们试图让他转向相反方向，`CheckBoundaries`函数也会在Robo有机会开始移动之前在下一个帧上检查：
- en: '![Embedding](img/8199OS_05_06.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![嵌入](img/8199OS_05_06.jpg)'
- en: According to the boundary check, the right edge of Robo is still beyond the
    right edge of the screen, so once again Robo's velocity is set to zero. Robo is
    stopped before he can even take a step!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 根据边界检查，Robo的右边缘仍然在屏幕的右边缘之外，所以Robo的速度再次被设置为零。Robo在甚至无法迈出一步之前就被停止了！
- en: 'Here is the solution; as soon as we detect that Robo has exceeded the boundary,
    we set his velocity to zero and we reposition Robo to just the other side of the
    boundary:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是解决方案；一旦我们检测到Robo超出了边界，我们就将他的速度设置为零，并将Robo重新定位到边界另一侧：
- en: '![Embedding](img/8199OS_05_07.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![嵌入](img/8199OS_05_07.jpg)'
- en: Now, Robo will be able to move as long as he goes in the other direction.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只要Robo朝相反方向移动，它就能移动。
- en: 'To implement this change, we are once again going to change the `CheckBoundaries`
    function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个更改，我们再次将更改应用于`CheckBoundaries`函数：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The highlighted lines show the added code. Basically, we perform the following
    actions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行显示了添加的代码。基本上，我们执行以下操作：
- en: Calculate how far past the boundary Robo has gone
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算Robo超出边界的距离
- en: Adjust his position by that much so that he is now positioned right at the boundary
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整他的位置，使他现在正好位于边界上
- en: You'll notice that we also filled out the function to handle the top and bottom
    boundaries so that the boundary checking can be used for any sprite travelling
    in any direction.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们还填写了处理顶部和底部边界的函数，以便边界检查可以用于任何方向移动的任何精灵。
- en: Fixing the background
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整背景
- en: 'Now that we have Robo moving the way we want him to, two new problems have
    cropped up for the background image:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让Robo按照我们希望的方式移动，两个新的问题已经出现在背景图片上：
- en: When Robo stops, the background keeps scrolling.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Robo停止时，背景继续滚动。
- en: When the background image ends at either the right or the left, it slides off
    the screen and we are left with a black background.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当背景图片在右侧或左侧结束时，它会从屏幕上滑出，我们只剩下黑色背景。
- en: 'Before we continue on with collision detection, let''s fix the background.
    First, we will add the following function to `RoboRacer2D.cpp`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行碰撞检测之前，让我们修复背景。首先，我们将添加以下函数到`RoboRacer2D.cpp`：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code is very similar to the boundary checking code. If the background anchor
    point moves far enough to the left to expose the right edge of the texture, it
    will be reset. If the background anchor point moves far enough to the right to
    expose the left edge of the texture, it will be reset.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与边界检查代码非常相似。如果背景锚点向左移动足够远以至于暴露了纹理的右边缘，它将被重置。如果背景锚点向右移动足够远以至于暴露了纹理的左边缘，它将被重置。
- en: 'Now, add the highlighted line of code to the `Update` function right after
    the call to `CheckBoundaries` in `RoboRacer2D.cpp`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将高亮显示的代码行添加到`Update`函数中，在`RoboRacer2D.cpp`中调用`CheckBoundaries`之后：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The background should now run from edge to edge. Play the game and take a coffee
    break. You deserve it!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 背景现在应该从边缘延伸到边缘。玩玩游戏，休息一下喝杯咖啡吧。你应得的！
- en: Collideables
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可碰撞物体
- en: There are many times that we may want to check and see whether objects in the
    game have collided with each other. We may want to see whether the player has
    struck an obstacle or an enemy. We may have objects that the player can pick up,
    often called **pickups** or **powerups**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多次我们可能想要检查和查看游戏中的物体是否相互碰撞。我们可能想知道玩家是否撞到了障碍物或敌人。我们可能有玩家可以捡起的物体，通常称为**拾取物**或**道具**。
- en: Collectively, objects in the game that can collide with other objects are known
    as collideables. When we created our `Sprite` class, we actually it designed for
    this. Looking at the class constructor, you will notice that member variable `m_isCollideable`
    is set to `false`. When we write our collision detection code, we will ignore
    objects that have `m_isCollideable` set to `false`. If we want to allow an object
    to collide with other objects, we have to make sure to set `m_collideable` to
    `true`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，可以与其他物体发生碰撞的物体统称为可碰撞物体。当我们创建`Sprite`类时，实际上是为这个目的设计的。查看类构造函数，你会注意到成员变量`m_isCollideable`被设置为`false`。当我们编写碰撞检测代码时，我们将忽略那些`m_isCollideable`设置为`false`的物体。如果我们想让一个物体能够与其他物体发生碰撞，我们必须确保将`m_collideable`设置为`true`。
- en: Ready to score
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备得分
- en: To keep our design simple, we are going to create one enemy and one pickup.
    Running into an enemy will subtract points from the player's score, while running
    into the pickup will increase the player's score. We will add some additional
    code to the sprite class to support this feature.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的设计简单，我们将创建一个敌人和一个拾取物。撞到敌人会从玩家的得分中扣除分数，而撞到拾取物则会增加玩家的得分。我们将在精灵类中添加一些额外的代码来支持这个功能。
- en: 'First, let''s add some new member variables. Declare a new variable in `Sprite.h`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加一些新的成员变量。在`Sprite.h`中声明一个新的变量：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then add the following methods:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加以下方法：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With these changes, every sprite will have an intrinsic value. If the value
    is positive, then it is a reward. If the value is negative, then it is a penalty.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，每个精灵都将有一个内在值。如果值为正，则表示奖励。如果值为负，则表示惩罚。
- en: Don't forget to initialize `m_value` to zero in the `Sprite` class constructor!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`Sprite`类构造函数中将`m_value`初始化为零！
- en: A friend indeed
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真正的朋友
- en: Let's add the sprite for our pickup. In this case, the pickup is a can of oil
    to keep Robo's joints working smoothly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们的拾取物精灵。在这种情况下，拾取物是一个油罐，以保持Robo的关节平滑工作。
- en: 'Add the following sprite definitions to RoboRacer2D:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下精灵定义添加到RoboRacer2D中：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we will set up the sprite. Add the following code to `LoadTextures`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将设置精灵。将以下代码添加到`LoadTextures`：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code is essentially the same code that we used to create all of our sprites.
    One notable difference is that we use the new `SetValue` method to add a value
    to the sprite. This represents how many points the player will earn for the collection
    of this pickup.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码基本上与我们用来创建所有精灵的代码相同。一个值得注意的区别是我们使用新的`SetValue`方法向精灵添加一个值。这代表玩家收集这个拾取物将获得的分数。
- en: Time to spawn
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成时间
- en: 'Note that we have set the sprite as inactive and invisible. Now, we will write
    a function to randomly spawn the pickup. First, we need to add two more C++ headers.
    In `RoboRacer2D.cpp` add the following headers:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将精灵设置为非活动状态和不可见状态。现在，我们将编写一个函数来随机生成拾取物。首先，我们需要添加两个额外的C++头文件。在`RoboRacer2D.cpp`中添加以下头文件：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We need `stdlib` for the `rand` function and `time` to give us a value to seed
    the random generator.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`stdlib`中的`rand`函数和`time`来为我们提供一个值来初始化随机生成器。
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Random numbers are generated from internal tables. In order to guarantee that
    a different random number is chosen each time the program is started, you first
    seed the random number generator with a value that is guaranteed to be different
    each time you start the program. As the time that the program is started will
    always be different, we often use time as the seed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数是从内部表中生成的。为了保证每次程序启动时选择不同的随机数，你首先需要用保证每次启动程序时都不同的值来初始化随机数生成器。由于程序启动的时间总是不同的，我们通常使用时间作为种子。
- en: 'Next, we need a timer. Declare the following variables in `RoboRacer2D.cpp`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个计时器。在`RoboRacer2D.cpp`中声明以下变量：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The threshold will be the number of seconds that we want to pass before a pickup
    is spawned. The timer will start and zero and count up to that number of seconds.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值是我们希望在生成拾取物之前经过的秒数。计时器将从零开始并计数到那个秒数。
- en: 'Let''s initialize these values in the `StartGame` function. The `StartGame`
    function is also a great place to seed our random number generator. Add the following
    three lines of code to the end of `StartGame`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`StartGame`函数中初始化这些值。`StartGame`函数也是一个很好的地方来初始化我们的随机数生成器。将以下三行代码添加到`StartGame`的末尾：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line seeds the random number generator by passing in an integer representing
    the current time. The next line sets a spawn threshold of `15` seconds. The third
    line sets the spawn timer to `0`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行通过传递表示当前时间的整数来初始化随机数生成器。下一行设置生成阈值为`15`秒。第三行将生成计时器设置为`0`。
- en: 'Now, let''s create a function to spawn our pickups. Add the following code
    to `RoboRacer2D.cpp`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个生成拾取物的函数。将以下代码添加到`RoboRacer2D.cpp`中：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code does the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行以下操作：
- en: It checks to make sure that the pickup is not already on the screen
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会检查拾取物是否已经在屏幕上了
- en: If there is no pickup, then the spawn timer is incremented
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有拾取物，则生成计时器递增
- en: If the spawn timer exceeds the spawn threshold, the pickup is spawned at a random
    position somewhere within the width of the screen and within the vertical reach
    of Robo
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果生成计时器超过了生成阈值，拾取物将在屏幕宽度和Robo的垂直范围内随机位置生成。
- en: Don't get too worried about the particular math being used. Your algorithm to
    position the pickup could be completely different. The key here is that a single
    pickup will be generated within Robo's reach.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于担心所使用的特定数学。你的拾取物定位算法可能完全不同。这里的关键是，将生成一个位于Robo可触及范围内的单个拾取物。
- en: 'Make sure to add a call to `SpawnPickup` in the `Update` function as well as
    a line to update the pickup:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在`Update`函数中调用`SpawnPickup`并在更新拾取物时添加一行：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We also need to add a line to `Render` to render the pickup:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`Render`中添加一行代码来渲染拾取物：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you run the game right now, then an oil can should be spawned about five
    seconds after the game starts.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，那么在游戏开始后的约五秒钟，应该会生成一个油桶。
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The current code has one flaw. It could potentially spawn the pickup right on
    top of Robo. Once we implement collision detection, the result will be that Robo
    immediately picks up the oil can. This will happen so quickly that you won't even
    see it happen. In the name of keeping it simple, we will live with this particular
    flaw.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当前代码有一个缺陷。它可能会在Robo的正上方生成拾取物。一旦我们实现了碰撞检测，Robo将立即捡起油桶。这将会发生得如此之快，以至于你甚至看不到它发生。为了保持简单，我们将容忍这个特定的缺陷。
- en: Circular collision detection
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 圆形碰撞检测
- en: One way to detect collision is to see how far each of the objects are from each
    other's center. This is known as circular collision detection because it treats
    each object as if it is bound by a circle, and uses the radius of that circle
    to determine whether the objects are close enough to collide.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 检测碰撞的一种方法是通过观察每个物体彼此之间的距离。这被称为圆形碰撞检测，因为它将每个物体视为被一个圆所包围，并使用该圆的半径来确定物体是否足够接近以发生碰撞。
- en: 'Take a look at the following diagram:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的图：
- en: '![Circular collision detection](img/8199OS_05_08.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![圆形碰撞检测](img/8199OS_05_08.jpg)'
- en: The circles on the left are not colliding, while the circles on the right are
    colliding. For the non-colliding circles, the distance (*d*) between the center
    points of the two circles is greater than the sum of the two radii (*r1 + r2*).
    For the colliding circles, the distance (*d*) between the two centers is less
    than the sum of the two radii (*r1 + r2*). We can use this knowledge to test any
    two objects for collision based on the radii of the circles and the distance between
    the objects center point.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的圆没有发生碰撞，而右侧的圆发生了碰撞。对于没有碰撞的圆，两个圆心之间的距离（*d*）大于两个半径（*r1 + r2*）之和。对于发生碰撞的圆，两个圆心之间的距离（*d*）小于两个半径（*r1
    + r2*）之和。我们可以利用这个知识来测试任何两个物体是否基于圆的半径和物体中心点之间的距离发生碰撞。
- en: So, how do we use this information?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用这些信息呢？
- en: We will know **r1** and **r2** because we set them when we create the sprite.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将知道**r1**和**r2**，因为我们创建精灵时设置了它们。
- en: We will calculate two legs of a right-triangle using the *x* and *y* coordinates
    for the center of each circle.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用每个圆心的*x*和*y*坐标来计算直角三角形的两条边。
- en: We will calculate *d*, the distance between two center points, using a variant
    of the **Pythagorean Theorem**.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用勾股定理的变体来计算两个中心点之间的距离 *d*。
- en: It will probably hurt your brain a little, but I'd like to refresh your memory
    one tenet of basic geometry.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会让你感到有点头疼，但我希望刷新你记忆中基本几何的一个定理。
- en: The Pythagorean Theorem
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 勾股定理
- en: The Pythagorean Theorem allows us to find the distance between any two points
    in a two-dimensional space if we know the lengths of the line segments that form
    a right-angle between the points.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 勾股定理允许我们在知道形成两个点之间直角的两条线段长度的情况下，找到二维空间中任意两点之间的距离。
- en: '![The Pythagorean Theorem](img/8199OS_05_09.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![勾股定理](img/8199OS_05_09.jpg)'
- en: '*a² + b² = c²*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*a² + b² = c²*'
- en: In our case, we are trying to calculate the distance (c) between the two points.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们试图计算两点之间的距离（c）。
- en: 'A little algebra will transform this equation to:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一点代数变换可以将这个方程转换为：
- en: '![The Pythagorean Theorem](img/81990S_05_11.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![勾股定理](img/81990S_05_11.jpg)'
- en: It is computationally expensive to perform the square root. A nice mathematical
    trick will actually allow us to perform our collision detection without calculating
    the square root.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 计算平方根是计算上昂贵的。一个很棒的数学技巧实际上允许我们在不计算平方根的情况下进行碰撞检测。
- en: 'If we were to use square roots to do this calculation, here is what that might
    look like:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用平方根来进行这个计算，它可能看起来是这样的：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Although this would work, there is a nice little mathematical trick that allows
    us to accomplish this test without taking the square root. Take a look at this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可以工作，但有一个很棒的数学技巧可以让我们在不计算平方根的情况下完成这个测试。看看这个：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It turns out that we can just keep everything in the equation at the power of
    2 and the comparison still works. This is because we are only interested in the
    relative comparison between the distance and the sum of the radii, not the absolute
    mathematical values.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们可以在方程中保持所有项的平方，比较仍然有效。这是因为我们只对距离和半径之和的相对比较感兴趣，而不是绝对数学值。
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the math we presented here boggles your brain, then don't worry too much.
    Circular collision detection is so common that the math to detect it is generally
    already built into the game engine that you will use. However, I wanted you to
    take a little look under the hood. After all, game programming is inherently mathematical,
    and the more you understand the math, the better you will be at coding.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里展示的数学让你感到困惑，那么请不要过于担心。圆形碰撞检测非常常见，检测它的数学通常已经内置到你将使用的游戏引擎中。然而，我想让你稍微了解一下引擎内部。毕竟，游戏编程本质上是数学性的，你对数学了解得越多，你的编码能力就会越强。
- en: Adding the circular collision code
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加圆形碰撞代码
- en: 'Now, it''s time to modify `Sprite.h` to add support for the circular collision
    detection. First, we need to add some member variables to hold the center point
    and radius. Add these two properties to `Sprite.h`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候修改 `Sprite.h` 以添加对圆形碰撞检测的支持。首先，我们需要添加一些成员变量来保存中心点和半径。将这两个属性添加到 `Sprite.h`
    中：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then add the following methods declarations:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加以下方法声明：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'These methods allow us to set and retrieve the center point and radius of the
    sprite. The `GetCenter` method is more than one line, so we will implement it
    in `Sprite.cpp`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法允许我们设置和检索精灵的中心点和半径。`GetCenter` 方法有多行，因此我们将在 `Sprite.cpp` 中实现它：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: An important point to note here is that `m_center` represents an `x` and `y`
    offset from the sprite's anchor point. So, to return the center point we will
    add `m_center` to the current position of the sprite and this will give us the
    current center point of the sprite exactly where it is in the game.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个重要点是，`m_center` 代表精灵锚点的一个 `x` 和 `y` 偏移。因此，为了返回中心点，我们将 `m_center` 添加到精灵的当前位置，这将给出精灵在游戏中的当前中心点。
- en: 'We now need to add the code to perform the collision detection. Add the following
    code to `Sprite.cpp`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要添加代码以执行碰撞检测。将以下代码添加到 `Sprite.cpp` 中：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we have already explained the use of the Pythagorean Theorem, this code
    should actually seem a little familiar to you. Here is what we are doing:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解释了勾股定理的使用，所以这段代码对你来说可能有点熟悉。以下是我们在做什么：
- en: The function accepts one sprite to compare with itself.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个与自身比较的精灵。
- en: First, we check to make sure both sprites are collideable.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们检查确保两个精灵都是可碰撞的。
- en: '`p1` and `p2` represent the two centers.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p1` 和 `p2` 代表两个中心点。'
- en: '`x` and `y` represent the lengths of the *a* and *b* sides of a right-angled
    triangle. Notice that the calculation is simply the difference between the `x`
    and `y` position of each sprite, respectively.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`和`y`代表直角三角形的边`a`和`b`的长度。请注意，计算只是简单地计算每个精灵的`x`和`y`位置之间的差异。'
- en: '`r1` and `r2` are the radii of the two circles (left as a power of 2).'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r1`和`r2`是两个圆的半径（以2的幂表示）。'
- en: '`d` is the distance between the two centers (left as a power of 2).'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d` 是两个中心之间的距离（以2的幂表示）。'
- en: If `d` is less than or equal to the sum of the two radii, then the circles are
    intersecting.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`d`小于或等于两个半径之和，则表示圆相交。
- en: Why use circular collision detection?
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用圆形碰撞检测？
- en: 'As we discussed many times, textures are represented as rectangles. In fact,
    we will take advantage of this when we cover rectangular collision detection later
    in the chapter. The following figure illustrates how rectangular and circular
    collision detection differ (the relative sizes are exaggerated to make a point):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们多次讨论的那样，纹理被表示为矩形。实际上，我们将在本章后面介绍矩形碰撞检测时利用这一点。以下图示说明了矩形和圆形碰撞检测的不同之处（相对大小被夸张以说明问题）：
- en: '![Why use circular collision detection?](img/8199OS_05_10.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![为什么使用圆形碰撞检测？](img/8199OS_05_10.jpg)'
- en: The sprites on the left are colliding using a rectangular bounding box. The
    sprites on the right are colliding using a bounding circle. In general, using
    a bounding circle is visually more convincing when we are dealing with rounder
    shapes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的精灵使用矩形边界框进行碰撞。右侧的精灵使用边界圆进行碰撞。一般来说，当我们处理更圆的形状时，使用边界圆在视觉上更有说服力。
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I'll admit the difference in this example is not that big. You could get away
    with rectangular or circular collision detection in this example. The round nature
    of the oil can made it a good candidate for circular collision detection. Circular
    collision detection is really essential if the two objects that are colliding
    are actually circles (that is, two balls colliding).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，在这个例子中，差异并不大。你可以在这个例子中用矩形或圆形碰撞检测。油桶的圆形特性使其成为圆形碰撞检测的良好候选者。如果碰撞的两个物体实际上是圆形（即，两个球体碰撞），圆形碰撞检测就非常关键。
- en: 'With the code that we developed, we need to define the center and radius for
    any sprites that will use circular collision detection. Add the following code
    to the `LoadTextures` function in `RoboRacer.cpp`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们开发的代码，我们需要为任何将使用圆形碰撞检测的精灵定义中心和半径。将以下代码添加到`RoboRacer.cpp`中的`LoadTextures`函数：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Don't get too worried about the exact values that we are using here. We are
    basically setting up a bounding circle for Robo and the oil can that match the
    preceding figure. Robo's bounding circle is set to the middle of the robot, while
    the oil can's circle is set to the bottom half of the texture.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于担心我们在这里使用的确切值。我们基本上是为Robo和油桶设置一个边界圆，以匹配前面的图。Robo的边界圆设置为机器人的中间，而油桶的圆设置为纹理的下半部分。
- en: Wiring in the collision detection
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接碰撞检测
- en: 'We are now going to add a new function that will perform all of our collision
    detection. Add the following function to `RoboRacer2D.cpp`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个新函数来执行所有的碰撞检测。将以下函数添加到`RoboRacer2D.cpp`中：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The purpose of this code is to check to see whether the player has collided
    with the pickup:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的目的是检查玩家是否与拾取物品发生了碰撞：
- en: If the call to `player->IntersectsCircle(pickup)` returns `true`, then the player
    has collided with the pickup
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`player->IntersectsCircle(pickup)`的调用返回`true`，则表示玩家与拾取物品发生了碰撞
- en: The pickup is deactivated and made invisible
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾取物品被禁用并变得不可见
- en: The pickup's value is added to the player's value (this will be the base for
    scoring in a future chapter)
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾取物品的值被添加到玩家的值中（这将是未来章节中计分的基准）
- en: The spawn timer is reset
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成计时器被重置
- en: 'We have two small details left. First, you must add a call to `CheckCollisions`
    to the `Update` function:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还剩下两个小细节。首先，你必须将`CheckCollisions`的调用添加到`Update`函数中：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Secondly, you need to make the player and pickup `collideable`. Add these three
    lines to the bottom of `LoadTextures` just before the return statement:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你需要使玩家和拾取物品`可碰撞`。将以下三行代码添加到`LoadTextures`的底部，就在返回语句之前：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, the real fun starts! Play the game and when the oil can spawns, and use
    Robo to pick it up. Five seconds later another oil can spawns. The fun never ends!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，真正的乐趣开始了！玩游戏，当油桶生成时，用Robo去拾取它。五秒后，另一个油桶生成。乐趣永无止境！
- en: Rectangular collision detection
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩形碰撞检测
- en: Now, we are going to learn how to implement rectangular collision detection.
    It turns out that both Robo and our enemy (a water bottle) are very rectangular,
    making rectangular collision detection the best choice.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何实现矩形碰撞检测。结果证明，机器人和我们的敌人（一个水瓶）都非常矩形，这使得矩形碰撞检测是最好的选择。
- en: The enemy within
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敌人内部
- en: Let's introduce our Robo's enemy—a bottle of water to rust his gears. The code
    for this is included next.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍我们的机器人敌人——一瓶水来生锈他的齿轮。这个代码将在下面包括。
- en: 'Add the following sprite definition to `RoboRacer2D`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下精灵定义添加到 `RoboRacer2D`：
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we will setup the sprite. Add the following code to `LoadTextures`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将设置精灵。将以下代码添加到 `LoadTextures`：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code is essentially the same code that we used to create all of our sprites.
    One notable difference is that we use the new `SetValue` method to add a negative
    value to the sprite. This is how many points the player will lose if they hit
    this enemy. We also make sure that we set the enemy to be collideable.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码基本上是我们用来创建所有精灵的相同代码。一个值得注意的差异是，我们使用新的 `SetValue` 方法向精灵添加一个负值。这就是玩家如果击中这个敌人将失去多少分。我们还确保将敌人设置为可碰撞。
- en: Spawning the enemy
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成敌人
- en: Just like the pickups, we need to spawn our enemies. We could use the same code
    as the pickups, but I thought it would be nicer if our enemies worked on a different
    timer.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就像拾取物一样，我们需要生成我们的敌人。我们可以使用与拾取物相同的代码，但我认为如果我们的敌人使用不同的计时器会更好。
- en: 'Declare the following variables in `RoboRacer2D.cpp`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RoboRacer2D.cpp` 中声明以下变量：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The threshold will be the amount of seconds that we want to pass before an enemy
    is spawned. The timer will start and zero and count up to that number of seconds.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值是我们希望敌人生成前要经过的秒数。计时器将从零开始并向上计数到这个秒数。
- en: 'Let''s initialize these values in the `StartGame` function. Add the following
    two lines of code to the end of `StartGame`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `StartGame` 函数中初始化这些值。将以下两行代码添加到 `StartGame` 的末尾：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We set a spawn threshold of 7 seconds, and set the spawn timer to 0.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了7秒的生成阈值，并将生成计时器设置为0。
- en: 'Now, let''s create a function to spawn our enemies. Add the following code
    to `RoboRacer2D.cpp`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个生成我们敌人的函数。将以下代码添加到 `RoboRacer2D.cpp`：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This code does the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行以下操作：
- en: It checks to make sure that the enemy is not already on the screen
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检查确保敌人尚未在屏幕上
- en: If there is no enemy, then the spawn timer is incremented
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有敌人，则生成计时器增加
- en: If the spawn timer exceeds the spawn threshold, the enemy is spawned at a random
    position somewhere within the width of the screen and within the vertical reach
    of Robo
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果生成计时器超过生成阈值，敌人将在屏幕宽度内和机器人垂直范围内随机位置生成
- en: Don't get too worried about the particular math being used. Your algorithm to
    position the enemy can be completely different. The key here is that a single
    enemy will be generated within Robo's path.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于担心所使用的特定数学。你的敌人定位算法可以完全不同。这里的关键是，一个敌人将在机器人的路径内生成。
- en: 'Make sure to add a call to `SpawnEnemy` in the `Update` function as well as
    a line to update the enemy:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 `Update` 函数中添加对 `SpawnEnemy` 的调用以及更新敌人的行：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We also need to add a line to `Render` to render the enemy:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在 `Render` 中添加一行来渲染敌人：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you run the game right now, then a water bottle should be spawned about seven
    seconds after the game starts.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，那么大约在游戏开始后七秒应该会生成一个水瓶。
- en: Adding the rectangular collision code
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加矩形碰撞代码
- en: As we have mentioned several times, all sprites are essentially rectangles.
    Visually, if any border of these rectangles overlap, we can assume that the two
    sprites have collided.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们多次提到的，所有精灵本质上都是矩形。从视觉上看，如果这些矩形的任何边框重叠，我们可以假设两个精灵发生了碰撞。
- en: 'We are going to add a function to our `Sprite` class that determines whether
    two rectangles are intersecting. Open `Sprite.h` and add the following method
    declaration:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向我们的 `Sprite` 类添加一个函数，用于确定两个矩形是否相交。打开 `Sprite.h` 并添加以下方法声明：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let''s add the implementation to `Sprite.cpp`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将实现添加到 `Sprite.cpp`：
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here''s how this code works:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这段代码的工作方式：
- en: This function looks really complicated, but it is really only doing a few things.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数看起来很复杂，但实际上只做了几件事情。
- en: The function accepts a sprite parameter.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数接受一个精灵参数。
- en: We set `recta` to be the collision rectangle of the sprite that called the `IntersectsRect`
    method and set `rectb` to be the collision rectangle of the sprite that was passed
    in.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`recta`设置为调用`IntersectsRect`方法的精灵的碰撞矩形，并将`rectb`设置为传入的精灵的碰撞矩形。
- en: We then test every possible combination of the position of the vertices in of
    `recta` to those of `rectb`. If any test is `true`, then we return `true`. Otherwise
    we return `false`.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们测试`recta`中顶点的位置与`rectb`中所有可能的位置组合。如果任何测试返回`true`，则我们返回`true`。否则，我们返回`false`。
- en: 'The following figure illustrates some of the ways that two rectangles could
    interact:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了两个矩形可能交互的一些方式：
- en: '![Adding the rectangular collision code](img/8199OS_05_12.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![添加矩形碰撞代码](img/8199OS_05_12.jpg)'
- en: Wiring continued
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接继续
- en: 'We have already wired in the collision check using `CheckCollisions`. We just
    need to add the following code to `CheckCollisions` to the check whether the player
    is colliding with an enemy:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过使用`CheckCollisions`实现了碰撞检测。我们只需将以下代码添加到`CheckCollisions`中，以检查玩家是否与敌人发生碰撞：
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, the real fun starts! Play the game and when the water can enemy spawns
    make sure Robo avoids it! If you collide with an enemy, you will lose points (as
    the value of enemy is set to a negative number). Until we implement a visible
    score, you may want to write the score out to the console.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，真正的乐趣开始了！玩这个游戏，当水敌人出现时确保Robo避开它！如果你与敌人发生碰撞，你会失去分数（因为敌人的值被设置为负数）。在我们实现可见分数之前，你可能需要将分数输出到控制台。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I'm sure you can now understand that most games would not be possible without
    collision detection. Collision detection allows objects in the game to interact
    with each other. We used collision detection to get pickups and detect whether
    we ran into an enemy.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你现在可以理解，没有碰撞检测，大多数游戏都是不可能实现的。碰撞检测允许游戏中的对象相互交互。我们使用碰撞检测来获取物品并检测我们是否遇到了敌人。
- en: We also discussed the essential task of boundary checking. Boundary checking
    is a special form of collision detection that checks to see whether an object
    has reached the screen boundaries. Another type of boundary checking is used to
    manage the scene background.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了边界检查的基本任务。边界检查是一种特殊的碰撞检测形式，用于检查一个对象是否达到了屏幕边界。另一种类型的边界检查用于管理场景背景。
- en: In the next chapter, we will wrap up the game by adding some finishing touches,
    including a heads-up display!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过添加一些收尾工作来结束游戏，包括一个抬头显示（heads-up display）！
