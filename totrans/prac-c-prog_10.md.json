["```cpp\n(V) - { a,b,c,d,e}\n```", "```cpp\n(E) - {(a,b), (a,c), (c,d), (c,e), (d,b), (d,e), (e,a), (e,b)}\n```", "```cpp\n(V) - { a,b,c,d,e}\n```", "```cpp\n(E) - {(a,b), (b,a), (a,c), (c,a), (a,e), (e,a), (b,e), (e,b), (b,d), (d,b), (c,d), (d,c), (c,e), (e,c)}\n```", "```cpp\n5,5          1              2              3              4              5\n-----------------------------------------------------------------------------\n1            0              1              1              0              0\n2            0              0              0              0              0\n3            0              0              0              1              1\n4            0              1              0              0              1\n5            1              1              0              0              0\n```", "```cpp\n//adjmatdirect.c\n\n#include <stdio.h>\n\n#define max 10\nint main() {\n  static int edg[max][max], i, j, v1, v2, numb;\n  printf(\"How many vertices are there? \");\n  scanf(\"%d\", & numb);\n  printf(\"We assume that the vertices are numbered from : \");\n  for (i = 1; i <= numb; i++) printf(\"%d \", i);\n  printf(\"\\nEnter the edges of the graph. Like 1 4 if there is an \\n\");\n  printf(\"edge between vertex 1 and 4\\. Enter 0 0 when over\\n\");\n  for (i = 1; i <= numb * (numb - 1); i++) {\n    /* The for loop will run for at most numb*(numb-1) times because, \n       the number of edges are at most numb*(numb-1) where numb is \n       the number of vertices */\n    scanf(\"%d %d\", & v1, & v2);\n    if (v1 == 0 && v2 == 0) break;\n    edg[v1][v2] = 1;\n  }\n  printf(\"\\nThe adjacency matrix for the graph is \\n\");\n  for (i = 1; i <= numb; i++) printf(\"\\t%d\", i);\n  printf(\"\\n-----------------------------------------------------\\n\");\n  for (i = 1; i <= numb; i++) {\n    printf(\"%d |\\t\", i);\n    for (j = 1; j <= numb; j++) {\n      printf(\"%d\\t\", edg[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n```", "```cpp\n5,5          1              2              3              4              5\n----------------------------------------------------------------------------\n1            0              1              1              0              1\n2            1              0              0              1              1\n3            1              0              0              1              1\n4            0              1              1              0              1\n5            1              1              1              1              0\n```", "```cpp\n//adjmatundirect.c\n\n#include <stdio.h>\n\n#define max 10\n\nint main() {\n  static int edg[max][max], i, j, v1, v2, numb;\n  printf(\"How many vertices are there? \");\n  scanf(\"%d\", & numb);\n  printf(\"We assume that the vertices are numbered from : \");\n  for (i = 1; i <= numb; i++) printf(\"%d \", i);\n  printf(\"\\nEnter the edges of the graph. Like 1 4 if there is an \\n\");\n  printf(\"edge between vertex 1 and 4\\. Enter 0 0 when over\\n\");\n  for (i = 1; i <= numb * (numb - 1); i++) {\n    /* The for loop will run for at most numb*(numb-1) times because, the \n       number of edges are at most numb*(numb-1) where numb is the number \n       of vertices */\n    scanf(\"%d %d\", & v1, & v2);\n    if (v1 == 0 && v2 == 0) break;\n    edg[v1][v2] = 1;\n    edg[v2][v1] = 1;\n  }\n  printf(\"\\nThe adjacency matrix for the graph is \\n\");\n  for (i = 1; i <= numb; i++) printf(\"\\t%d\", i);\n  printf(\"\\n----------------------------------------------------------\\n\");\n  for (i = 1; i <= numb; i++) {\n    printf(\"%d |\\t\", i);\n    for (j = 1; j <= numb; j++) {\n      printf(\"%d\\t\", edg[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}\n```", "```cpp\nedg[v2][v1]=1;\n```", "```cpp\n//adjlistdirect.c\n\n#include <stdlib.h>\n#include <stdio.h>\n\nstruct node {\n  char nme;\n  struct node * vrt;\n  struct node * edg;\n};\n\nint main() {\n  int numb, i, j, noe;\n  char v1, v2;\n  struct node * startList, * newNode, * temp1, * temp2;\n  printf(\"How many vertices are there ? \");\n  scanf(\"%d\", & numb);\n  startList = NULL;\n  printf(\"Enter all vertices names\\n\");\n  for (i = 1; i <= numb; i++) {\n    if (startList == NULL) {\n      newNode = malloc(sizeof(struct node));\n      scanf(\" %c\", & newNode - > nme); /* There is a space before %c */\n      startList = newNode;\n      temp1 = newNode;\n      newNode - > vrt = NULL;\n      newNode - > edg = NULL;\n    } else {\n      newNode = malloc(sizeof(struct node));\n      scanf(\" %c\", & newNode - > nme);\n      /* There is a space before %c */\n      newNode - > vrt = NULL;\n      newNode - > edg = NULL;\n      temp1 - > vrt = newNode;\n      temp1 = newNode;\n    }\n  }\n  printf(\"Enter the edges between vertices. Enter v1 v2, if there is an edge\\n\");\n  printf(\"between v1 and v2\\. Enter 0 0 if over\\n\");\n  noe = numb * (numb - 1);\n  for (j = 1; j <= noe; j++) {\n    scanf(\" %c %c\", & v1, & v2);\n    /* There is a space before %c */\n    if (v1 == '0' && v2 == '0') break;\n    temp1 = startList;\n    while (temp1 != NULL && temp1 - > nme != v1)\n      temp1 = temp1 - > vrt;\n    if (temp1 == NULL) {\n      printf(\"Sorry no vertex exist by this name\\n\");\n      break;\n    }\n    temp2 = temp1;\n    while (temp2 - > edg != NULL) temp2 = temp2 - > edg;\n    newNode = malloc(sizeof(struct node));\n    newNode - > nme = v2;\n    temp2 - > edg = newNode;\n    newNode - > edg = NULL;\n    newNode - > vrt = NULL;\n  }\n  printf(\"\\nAdjacency List representation of Graph is\\n\");\n  temp1 = startList;\n  while (temp1 != NULL) {\n    printf(\"%c\\t\", temp1 - > nme);\n    temp2 = temp1 - > edg;\n    while (temp2 != NULL) {\n      printf(\"%c\\t\", temp2 - > nme);\n      temp2 = temp2 - > edg;\n    }\n    printf(\"\\n\");\n    temp1 = temp1 - > vrt;\n  }\n}\n```", "```cpp\n//breadthfirsttrav.c\n\n#include <stdlib.h>\n#include <stdio.h>\n\n#define max 20\n\nenum Setmarked {\n  Y,\n  N\n};\nstruct node {\n  char nme;\n  struct node * vrt;\n  struct node * edg;\n  enum Setmarked marked;\n};\n\nstruct node * que[max];\nint rear = -1, front = -1;\nvoid queue(struct node * paramNode);\nstruct node * dequeue();\n\nint main() {\n  int numb, i, j, noe;\n  char v1, v2;\n  struct node * startList, * newNode, * temp1, * temp2, * temp3;\n  printf(\"How many vertices are there ?\");\n  scanf(\"%d\", & numb);\n  startList = NULL;\n  printf(\"Enter all vertices names\\n\");\n  for (i = 1; i <= numb; i++) {\n    if (startList == NULL) {\n      newNode = malloc(sizeof(struct node));\n      scanf(\" %c\", & newNode - > nme);\n      /* There is a space before %c */\n      startList = newNode;\n      temp1 = newNode;\n      newNode - > vrt = NULL;\n      newNode - > edg = NULL;\n      newNode - > marked = N;\n    } else {\n      newNode = malloc(sizeof(struct node));\n      scanf(\" %c\", & newNode - > nme);\n      /* There is a space before %c */\n      newNode - > vrt = NULL;\n      newNode - > edg = NULL;\n      newNode - > marked = N;\n      temp1 - > vrt = newNode;\n      temp1 = newNode;\n    }\n  }\n  printf(\"Enter the edges between vertices. Enter v1 v2, if there is an edge\\n\");\n  printf(\"between v1 and v2\\. Enter 0 0 if over\\n\");\n  noe = numb * (numb - 1);\n  for (j = 1; j <= noe; j++) {\n    scanf(\" %c %c\", & v1, & v2);\n    /* There is a space before %c */\n    if (v1 == '0' && v2 == '0') break;\n    temp1 = startList;\n    while (temp1 != NULL && temp1 - > nme != v1)\n      temp1 = temp1 - > vrt;\n    if (temp1 == NULL) {\n      printf(\"Sorry no vertex exist by this name\\n\");\n      break;\n    }\n    temp2 = temp1;\n    while (temp2 - > edg != NULL) temp2 = temp2 - > edg;\n    newNode = malloc(sizeof(struct node));\n    newNode - > nme = v2;\n    temp2 - > edg = newNode;\n    newNode - > edg = NULL;\n    newNode - > vrt = NULL;\n  }\n  printf(\"\\nAdjacency List representation of Graph is\\n\");\n  temp1 = startList;\n  while (temp1 != NULL) {\n    printf(\"%c\\t\", temp1 - > nme);\n    temp2 = temp1 - > edg;\n    while (temp2 != NULL) {\n      printf(\"%c\\t\", temp2 - > nme);\n      temp2 = temp2 - > edg;\n    }\n    printf(\"\\n\");\n    temp1 = temp1 - > vrt;\n  }\n  printf(\"\\nBreadth First traversal of the graph is \\n\");\n  temp1 = startList;\n  if (temp1 == NULL)\n    printf(\"Sorry no vertices in the graph\\n\");\n  else\n    queue(temp1);\n  while (rear != -1) {\n    temp3 = dequeue();\n    temp1 = startList;\n    while (temp1 - > nme != temp3 - > nme) temp1 = temp1 - > vrt;\n    temp3 = temp1;\n    if (temp3 - > marked == N) {\n      printf(\"%c\\t\", temp3 - > nme);\n      temp3 - > marked = Y;\n      temp2 = temp3 - > edg;\n      while (temp2 != NULL) {\n        queue(temp2);\n        temp2 = temp2 - > edg;\n      }\n    }\n  }\n  return 0;\n}\n\nvoid queue(struct node * paramNode) {\n  rear++;\n  que[rear] = paramNode;\n  if (front == -1) front = 0;\n}\n\nstruct node * dequeue() {\n  struct node * tempNode;\n  if (front == rear) {\n    tempNode = que[front];\n    front = -1;\n    rear = -1;\n  } else {\n    tempNode = que[front];\n    front++;\n  }\n  return (tempNode);\n}\n```", "```cpp\n//depthfirsttrav.c\n\n#include <stdlib.h>\n#include <stdio.h>\n#define max 20\n\nenum Setmarked {Y,N};\nstruct node {\n  char nme;\n  struct node * vrt;\n  struct node * edg;\n  enum Setmarked marked;\n};\n\nstruct node * stack[max];\nint top = -1;\nvoid push(struct node * h);\nstruct node * pop();\n\nint main() {\n  int numb, i, j, noe;\n  char v1, v2;\n  struct node * startList, * newNode, * temp1, * temp2, * temp3;\n  printf(\"How many vertices are there ?\");\n  scanf(\"%d\", & numb);\n  startList = NULL;\n  printf(\"Enter all vertices names\\n\");\n  for (i = 1; i <= numb; i++) {\n    if (startList == NULL) {\n      newNode = malloc(sizeof(struct node));\n      scanf(\" %c\", & newNode - > nme);\n      /* There is a white space before %c */\n      startList = newNode;\n      temp1 = newNode;\n      newNode - > vrt = NULL;\n      newNode - > edg = NULL;\n      newNode - > marked = N;\n    } else {\n      newNode = malloc(sizeof(struct node));\n      scanf(\" %c\", & newNode - > nme);\n      /* There is a white space before %c */\n      newNode - > vrt = NULL;\n      newNode - > edg = NULL;\n      newNode - > marked = N;\n      temp1 - > vrt = newNode;\n      temp1 = newNode;\n    }\n  }\n  printf(\"Enter the edges between vertices. Enter v1 v2, if there is an edge\\n\");\n  printf(\"between v1 and v2\\. Enter 0 0 if over\\n\");\n  noe = numb * (numb - 1);\n  for (j = 1; j <= noe; j++) {\n    scanf(\" %c %c\", & v1, & v2);\n    /* There is a white space before %c */\n    if (v1 == '0' && v2 == '0') break;\n    temp1 = startList;\n    while (temp1 != NULL && temp1 - > nme != v1)\n      temp1 = temp1 - > vrt;\n    if (temp1 == NULL) {\n      printf(\"Sorry no vertex exist by this name\\n\");\n      break;\n    }\n    temp2 = temp1;\n    while (temp2 - > edg != NULL) temp2 = temp2 - > edg;\n    newNode = malloc(sizeof(struct node));\n    newNode - > nme = v2;\n    temp2 - > edg = newNode;\n    newNode - > edg = NULL;\n    newNode - > vrt = NULL;\n  }\n  printf(\"\\nAdjacency List representation of Graph is\\n\");\n  temp1 = startList;\n  while (temp1 != NULL) {\n    printf(\"%c\\t\", temp1 - > nme);\n    temp2 = temp1 - > edg;\n    while (temp2 != NULL) {\n      printf(\"%c\\t\", temp2 - > nme);\n      temp2 = temp2 - > edg;\n    }\n    printf(\"\\n\");\n    temp1 = temp1 - > vrt;\n  }\n  printf(\"\\nDepth First traversal of the graph is \\n\");\n  temp1 = startList;\n  if (temp1 == NULL)\n    printf(\"Sorry no vertices in the graph\\n\");\n  else\n    push(temp1);\n  while (top >= 0) {\n    temp3 = pop();\n    temp1 = startList;\n    while (temp1 - > nme != temp3 - > nme) temp1 = temp1 - > vrt;\n    temp3 = temp1;\n    if (temp3 - > marked == N) {\n      printf(\"%c\\t\", temp3 - > nme);\n      temp3 - > marked = Y;\n      temp2 = temp3 - > edg;\n      while (temp2 != NULL) {\n        push(temp2);\n        temp2 = temp2 - > edg;\n      }\n    }\n  }\n  return 0;\n}\n\nvoid push(struct node * h) {\n  top++;\n  stack[top] = h;\n}\n\nstruct node * pop() {\n  return (stack[top--]);\n}\n```", "```cpp\n//prims.c\n\n#include <stdlib.h>\n#include <stdio.h>\n#define max 20 \nstruct node\n{\n int nme;\n int wt;\n struct node *vrt;\n struct node *edg;\n };\n\nstruct node *startList;\n\nstruct lst\n{\n int u,v;\n int wt;\n struct lst *next;\n}lst; \n\nstruct lst *pq=NULL;\nstruct lst *tr=NULL;\nvoid addpqu(int a, int b, int w);\nvoid maketree();\nvoid disptree();\nstruct lst *delet();\nint visited[max];\nint n,nov=0; \n\nint main()\n{\n int i,j,noe,w;\n int a,b;\n struct node *newNode,*temp1,*temp2;\n printf (\"How many vertices are there ?\");\n scanf(\"%d\",&n);\n printf(\"The vertices are named\\n\");\n for(i=1;i<=n;i++)printf(\"%d\\t\",i);\n printf(\"for convenience \\n\");\n startList=NULL;\n for(i=1;i<=n;i++)\n {\n     if (startList==NULL)\n     {\n         newNode =malloc(sizeof (struct node));\n         newNode->nme=i;\n         startList=newNode;\n         temp1=newNode;\n         newNode->vrt=NULL;\n         newNode->edg=NULL;\n     }\n     else\n     {\n         newNode=malloc(sizeof (struct node));\n         newNode->nme=i;\n         newNode->vrt=NULL;\n         newNode->edg=NULL;\n         temp1->vrt=newNode;\n         temp1=newNode;\n     }\n }\n printf(\"Enter the edges between vertices. Enter 1 3, if there is an edge\\n\");\n printf(\"between 1 and 3\\. Enter 0 0 if over\\n\");\n noe=n*(n-1);\n for(j=1;j<=noe;j++)\n {\n     printf(\"Enter edge \");\n     scanf(\"%d %d\",&a,&b);\n     if(a==0 && b==0)break;\n     printf(\"Enter weight \");\n     scanf(\"%d\",&w);\n     temp1=startList;\n     while(temp1!=NULL && temp1->nme!=a)\n     {\n         temp1=temp1->vrt;\n     }\n     if(temp1==NULL)\n     {\n         printf(\"Sorry no vertex exist by this name\\n\");\n         break;\n     }\n     temp2=temp1;\n     while(temp2->edg!=NULL)temp2=temp2->edg;\n     newNode=malloc(sizeof (struct node));\n     newNode->nme=b;\n     newNode->wt=w;\n     temp2->edg=newNode;\n     newNode->edg=NULL;\n     newNode->vrt=NULL;\n     temp1=startList;\n     while(temp1!=NULL && temp1->nme!=b)\n         temp1=temp1->vrt;\n     if(temp1==NULL)\n     {\n         printf(\"Sorry no vertex exist by this name\\n\");\n         break;\n     }\n     temp2=temp1;\n     while(temp2->edg!=NULL)temp2=temp2->edg;\n     newNode=malloc(sizeof (struct node));\n     newNode->nme=a;\n     newNode->wt=w;\n     temp2->edg=newNode;\n     newNode->edg=NULL;\n     newNode->vrt=NULL;\n}\nprintf (\"Adjacency List representation of Graph is\\n\");\ntemp1=startList;\nwhile (temp1!=NULL)\n{\n     printf (\"%d\\t\",temp1->nme);\n     temp2=temp1->edg;\n     while(temp2!=NULL)\n     {\n         printf(\"%d\\t\",temp2->nme);\n         temp2=temp2->edg;\n     }\n     printf(\"\\n\");\n     temp1=temp1->vrt;\n}\ntemp1=startList;\ntemp2=temp1->edg;\nwhile(temp2!=NULL)\n{\n    addpqu(temp1->nme,temp2->nme, temp2->wt);\n    temp2=temp2->edg;\n}\nmaketree();\ndisptree();\nreturn 0;\n}\n\nvoid addpqu(int a, int b, int w)\n{\n struct lst *lstNode,*findloc1,*findloc2;\n lstNode=malloc(sizeof(struct lst));\n lstNode->u=a;\n lstNode->v=b;\n lstNode->wt=w;\n lstNode->next=NULL;\n if(pq==NULL)\n {\n     pq = lstNode;\n }\n else\n {\n     if(lstNode->wt < pq->wt)\n     {\n         lstNode->next=pq;\n         pq=lstNode;\n     }\n     else\n     {\n         findloc1=pq;\n         while((findloc1!=NULL) && (findloc1->wt <= lstNode->wt))\n         {\n             findloc2=findloc1;\n             findloc1=findloc1->next;\n         }\n         findloc2->next=lstNode;\n         lstNode->next=findloc1;\n     }\n  }\n} \n\nstruct lst *delet()\n{\n struct lst *tempNode;\n if (pq !=NULL)\n {\n     tempNode=pq;\n     pq=pq->next;\n     return tempNode;\n }\n else\n     return NULL;\n } \n\nvoid maketree()\n{\n struct lst *lstNode,*tempNode1,*tempNode2;\n struct node *x,*y;\n int i,j;\n while(nov <n)\n {\n     nxt: lstNode=delet();\n     for(i=1;i<=nov;i++)\n     {\n         if(visited[i]==lstNode->u)\n         {\n             for(j=1;j<=nov;j++)\n                 if(visited[j]==lstNode->v) goto nxt;\n         }\n     }\n     for(i=1;i<=nov;i++)\n         if(visited[i]==lstNode->u) goto rpt;\n     nov++;\n     visited[nov]=lstNode->u;\n     rpt: for(i=1;i<=nov;i++)\n     {\n         if(visited[i]==lstNode->v) goto rptt;\n     }\n     nov++;\n     visited[nov]=lstNode->v;\n     rptt: lstNode->next=NULL;\n     if (tr==NULL)\n     {\n         tr=lstNode;\n         tempNode1=tr;\n     }\n     else\n     {\n         tempNode1->next=lstNode;\n         tempNode1=lstNode;\n     }\n     x=startList;\n     while(x->nme!=lstNode->v)x=x->vrt;\n     y=x->edg;\n     pq=NULL;\n     while(y!=NULL)\n     {\n         addpqu(x->nme,y->nme, y->wt);\n         y=y->edg;\n     }\n  }\n}\n\nvoid disptree()\n{\n struct lst *t;\n t=tr;\n printf(\"Minimal Spanning tree with Prims Algorithm is \\n\");\n while(t!=NULL)\n {\n     printf(\"%d %d\\n\",t->u,t->v);\n     t=t->next;\n }\n} \n\n```", "```cpp\n//kruskal.c\n\n#include <stdlib.h>\n#include <stdio.h>\n#define max 20\n\nstruct node\n{\n int nme;\n int wt;\n struct node *v;\n struct node *e;\n}; \n\ntypedef struct lst\n{\n int u,v;\n int wt;\n struct lst *nxt;\n}lst; \n\nlst *pq=NULL;\nlst *tr=NULL;\nvoid addpqu(int a, int b, int w);\nvoid maketree();\nvoid disptree();\nlst *delet();\nint parent[max]; \n\nint main()\n{\n int n,i,j,noe,w;\n int a,b;\n struct node *adj,*newNode,*p,*q;\n printf (\"How many vertices are there ? \");\n scanf(\"%d\",&n);\n for(i=1;i<=n;i++)parent[i]=0;\n printf(\"The vertices are named\\n\");\n for(i=1;i<=n;i++)printf(\"%d\\t\",i);\n printf(\"for convenience \\n\");\n for(i=1;i<=n;i++)\n {\n     if (i==1)\n     {\n         newNode =malloc(sizeof (struct node));\n         newNode->nme=i;\n         adj=newNode;\n         p=newNode;\n         newNode->v=NULL;\n         newNode->e=NULL;\n     }\n     else\n     {\n         newNode=malloc(sizeof (struct node));\n         newNode->nme=i;\n         newNode->v=NULL;\n         newNode->e=NULL;\n         p->v=newNode;\n         p=newNode;\n     }\n }\n printf(\"Enter the edges between vertices. Enter 1 3, if there is an edge\\n\");\n printf(\"between 1 and 3\\. Enter 0 0 if over\\n\");\n noe=n*(n-1);\n for(j=1;j<=noe;j++)\n {\n     printf(\"Enter edge: \");\n     scanf(\"%d %d\",&a,&b);\n     if(a==0 && b==0)break;\n     printf(\"Enter weight: \");\n     scanf(\"%d\",&w);\n     p=adj;\n     while(p!=NULL && p->nme!=a)\n         p=p->v;\n     if(p==NULL)\n     {\n         printf(\"Sorry no vertex exist by this name\\n\");\n         break;\n     }\n     q=p;\n     while(q->e!=NULL)q=q->e;\n     newNode=malloc(sizeof (struct node));\n     newNode->nme=b;\n     newNode->wt=w;\n     q->e=newNode;\n     newNode->e=NULL;\n     newNode->v=NULL;\n     addpqu(a,b,w);\n }\n printf (\"Adjacency List representation of Graph is\\n\");\n p=adj;\n while (p!=NULL)\n {\n     printf (\"%d\\t\",p->nme);\n     q=p->e;\n     while(q!=NULL)\n     {\n         printf(\"%d\\t\",q->nme);\n         q=q->e;\n     }\n     printf(\"\\n\");\n     p=p->v;\n }\n maketree();\n disptree();\n return 0;\n} \n\nvoid addpqu(int a, int b, int w)\n{\n lst *newNode,*k,*h;\n newNode=(lst *)malloc(sizeof(lst));\n newNode->u=a;\n newNode->v=b;\n newNode->wt=w;\n newNode->nxt=NULL;\n if(pq==NULL)\n     pq = newNode;\n else\n {\n     if(newNode->wt < pq->wt)\n     {\n         newNode->nxt=pq;\n         pq=newNode;\n     }\n     else\n     {\n         k=pq;\n         while((k!=NULL) &&(k->wt <= newNode->wt))\n         {\n             h=k;\n             k=k->nxt;\n         }\n         h->nxt=newNode;\n         newNode->nxt=k;\n     }\n   }\n } \n\nlst *delet()\n{\n lst *q;\n if (pq !=NULL)\n {\n     q=pq;\n     pq=pq->nxt;\n     return q;\n }\n else\n     return NULL;\n } \n\nvoid maketree()\n{\n lst *newNode,*p;\n int x,y,r1,r2;\n newNode=delet();\n while(newNode !=NULL)\n {\n     newNode->nxt=NULL;\n     x=newNode->u;\n     y=newNode->v;\n     while(x>0)\n     {\n         r1=x;\n         x=parent[x];\n     }\n     while(y>0)\n     {\n         r2=y;\n         y=parent[y];\n     }\n     if(r1 !=r2)\n     {\n         parent[r2]=r1;\n         if (tr==NULL)\n         {\n             tr=newNode;\n             p=tr;\n         }\n         else\n         {\n             p->nxt=newNode;\n             p=newNode;\n         }\n     }\n     newNode=delet();\n   }\n } \n\nvoid disptree()\n{\n lst *t;\n t=tr;\n printf(\"Minimal Spanning tree with Kruskal Algorithm is \\n\");\n while(t!=NULL)\n {\n     printf(\"%d %d\\n\",t->u,t->v);\n     t=t->nxt;\n }\n}\n```", "```cpp\nWeight   Src    Dest\n 1        1      2\n 1        3      5\n 2        1      5\n 2        2      5\n 2        3      4\n 3        1      3\n 3        2      4\n 4        4      5\n```"]