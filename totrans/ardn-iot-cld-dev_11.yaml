- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing the Arduino IoT Cloud Scheduler and Over-the-Air Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world is full of different and interesting use cases that vary according
    to different circumstances. In the world of full automation, many use cases require
    applications to perform a specific operation at a certain time or frequency, defined
    by an end user. To handle this situation, the **Arduino IoT Cloud** has a **Scheduler**
    feature to let end users configure the execution time and frequency through a
    dashboard, without any modification to code on end devices. Initially, in this
    chapter, you will learn about the Arduino IoT Cloud Scheduler feature and its
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Then, this chapter will cover the **Over-the-Air** (**OTA**) feature, which
    is becoming increasingly popular in remote devices such as mobile nodes, especially
    remote IoT nodes. The OTA feature allows you to broadcast the firmware update
    to IoT nodes, which will update wirelessly without any physical connection. This
    procedure enables the remote maintenance of commercial Arduino-based/ESP-series
    IoT nodes during their life cycle, reducing the related service costs when new
    features and security fixes become available.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud Scheduler provides the ability to schedule operations
    via a dashboard widget, which helps to execute the operations on devices without
    modifying the code, and a user can simply adjust the time for routine operations.
    OTA helps you to send the latest code and updates to devices over the air without
    any physical connection to a device, which will save operational costs and time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of the Scheduler in IoT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Arduino IoT Cloud Scheduler – an MKR Wi-Fi 1010 illustration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial configuration – Things, network credentials, cloud variables, and code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dashboard creation and a deep dive into the Scheduler widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The task at hand – an assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring OTA updates in IoT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging the Arduino IoT Cloud for OTA updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we go any further, first of all, you need to have an Arduino IoT Cloud-compatible
    board. I recommend Arduino **MKR Wi-Fi 1010** with a bunch of 5 mm LEDs, but here
    is the complete list of compatible boards: [https://store-usa.arduino.cc/pages/cloud-compatible-boards](https://store-usa.arduino.cc/pages/cloud-compatible-boards).
    You can choose one according to your requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: Second, you need to have an Arduino IoT Cloud account. If you don’t already
    have one, you can sign up at [https://cloud.arduino.cc/](https://cloud.arduino.cc/)
    and select a plan according to your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Third, we need to download and install the **Arduino Create Agent**. Arduino
    has created a very beautiful web-based guide for installation at [https://create.arduino.cc/getting-started/plugin/welcome](https://create.arduino.cc/getting-started/plugin/welcome).
    The code for this chapter is available in the book’s official GitHub repository
    at [https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers](https://github.com/PacktPublishing/Arduino-IoT-Cloud-for-Developers).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'All the Arduino IoT Cloud plans were discussed in detail in [*Chapter 1*](B19752_01.xhtml#_idTextAnchor015).
    You can also visit the following link for updated plan pricing and features: [https://cloud.arduino.cc/plans/](https://cloud.arduino.cc/plans/).
    If you are from an educational institute, then there are plenty of good plans
    for students and faculties. Arduino also offers customized plans to business organizations
    according to their requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of the Scheduler in IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within the realm of IoT and cloud computing, a scheduler refers to a component
    or system that is responsible for managing and controlling the timing and execution
    of tasks, processes, or events. Its primary function is to ensure the smooth and
    efficient operation of various activities within an IoT cloud setup. Here are
    some advantages of employing a scheduler in an IoT cloud environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task coordination**: The scheduler facilitates the orchestration of multiple
    tasks and processes in an IoT cloud by allowing users to define dependencies and
    priorities. This ensures that tasks are executed in the desired sequence, which
    is particularly crucial in complex IoT systems involving interconnected devices
    and services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource optimization**: With the limited computational resources typically
    found in an IoT cloud, a scheduler optimizes its utilization by intelligently
    assigning tasks based on requirements, available resources, and priorities. This
    prevents resource overloading or underutilization, leading to enhanced efficiency
    and cost-effectiveness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time synchronization**: Achieving synchronized timing for specific operations
    or events is critical in IoT systems. The scheduler aids in time synchronization
    by coordinating task execution according to precise timing requirements. This
    synchronization guarantees that devices, sensors, and services are triggered or
    activated at the intended moments, enabling accurate data collection, analysis,
    and decision-making.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Energy efficiency**: Many IoT devices operate on constrained battery power,
    making energy efficiency a vital concern. The scheduler optimizes task scheduling
    to minimize devices’ active time and maximize sleep or low-power mode, thereby
    conserving energy. This prolongs the battery life of IoT devices, reduces maintenance
    needs, and enhances overall system reliability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault tolerance**: IoT systems are susceptible to failures and disruptions
    caused by network issues, device malfunctions, or service unavailability. By monitoring
    task statuses and detecting failures, the scheduler incorporates fault tolerance
    mechanisms. It automatically reschedules failed or interrupted tasks, ensuring
    operational continuity and reliability within the IoT cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, a scheduler in an IoT cloud environment brings organization, efficiency,
    and reliability by coordinating tasks, optimizing resources, synchronizing time,
    conserving energy, ensuring fault tolerance, and supporting scalability. Its presence
    is instrumental in managing the complexities of IoT systems and maximizing their
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have discussed in detail what a scheduler is and how we
    can benefit from it in product development. In the following section, we will
    take a look at how the Arduino IoT Cloud Scheduler benefits us in terms of real-world
    scenarios, and we will also learn how to implement the Arduino IoT Cloud Scheduler
    using MKR Wi-Fi 101.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Arduino IoT Cloud Scheduler – an MKR Wi-Fi 1010 illustration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at how the Arduino IoT Cloud Scheduler
    provides different benefits and when and where we require scheduler functionality.
    Later, we will implement a practical example of a Scheduler using MKR Wi-Fi 1010.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud Scheduler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Arduino IoT Cloud Scheduler** is a feature integrated into the Arduino
    IoT Cloud platform that empowers users to schedule and automate actions and events
    for their connected Arduino devices. It provides a convenient way to define and
    manage the timing of various tasks and functions within IoT projects. Here are
    some key aspects and benefits of the Arduino IoT Cloud Scheduler:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task scheduling**: The Arduino IoT Cloud Scheduler allows users to schedule
    tasks and events on their Arduino devices. It enables the definition of specific
    timings, intervals, or triggers for actions such as data collection, device control,
    and sensor readings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote control**: By leveraging the Scheduler, users can remotely trigger
    actions on their Arduino devices. This capability enables the control and automation
    of functions from any location, without the need for direct physical access to
    the devices. It enhances flexibility and enables the efficient remote management
    of IoT projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-based triggers**: The Scheduler supports event-based triggers, empowering
    users to automate actions based on specific events or conditions. For instance,
    tasks can be scheduled to execute when a particular sensor value surpasses a defined
    threshold or when an external event is detected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time zone management**: The Arduino IoT Cloud Scheduler handles time zone
    management, ensuring that tasks are executed according to the desired time zone.
    This functionality is particularly useful when operating across different time
    zones or serving users in diverse regions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration with IoT cloud services**: The Scheduler seamlessly integrates
    with other features and services offered by the Arduino IoT Cloud platform. This
    includes data storage, visualization, and notification services. Users can combine
    scheduling with data logging, charting, and alerting to create comprehensive and
    cohesive IoT applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility and customization**: The Arduino IoT Cloud Scheduler provides
    a high degree of customization, enabling users to define complex schedules and
    conditions for their tasks. Users can specify the task frequency, duration, and
    intervals, and configure advanced parameters to align with their specific requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By harnessing the power of the Arduino IoT Cloud Scheduler, users can automate
    tasks, remotely control devices, and establish time-based or event-driven workflows
    for their Arduino-based IoT projects. This feature simplifies the management and
    coordination of actions across devices, elevating the functionality and efficiency
    of IoT applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed how the Arduino IoT Cloud Scheduler provides a
    benefit to schedule our tasks. In the next section, we will implement a Scheduler
    using MKR Wi-Fi 1010.
  prefs: []
  type: TYPE_NORMAL
- en: An MKR Wi-Fi 1010 example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, I will not do a complex project to demonstrate how we can use
    the Scheduler. Instead, we will use a simple MKR Wi-Fi 1010 with three 5 mm LEDs,
    and we will set up the system so that it will turn LEDs on or off after a specific
    time interval. This example will simplify the hardware complexity and help you
    understand how the Arduino IoT Cloud Scheduler works. *Figure 11**.1* shows how
    LEDs connect with the MKR Wi-Fi 1010 for this Scheduler example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The MKR Wi-Fi 1010 with LEDs](img/B19752_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The MKR Wi-Fi 1010 with LEDs
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will just use three LEDs for three different schedulers/timers. We
    used *Pins 8*, *7*, and *6* to attach the LEDs with the MKR Wi-Fi 1010, using
    a 220-Ohm resistance, which will control the power from these pins, and one common
    **ground** (**GND**) goes to all the LEDs via the breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the schematic diagram of our project, where we
    explained which pins are used to connect the LEDs with the MKR Wi-Fi 1010\. In
    the upcoming section, we will set up a Thing and device association with the Thing,
    and cloud variable creation and network configuration will be discussed step by
    step, along with code.
  prefs: []
  type: TYPE_NORMAL
- en: Initial configuration – Things, network credentials, cloud variables, and code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After setting up the hardware, it’s time to set up a Thing in the Arduino IoT
    Cloud. For this project, we need three cloud variables for the Scheduler, which
    will be linked with dashboard widgets and receive the values from users. Later,
    the device will perform an operation (in our example, it will turn the LEDs on
    and off according to a scheduler time) when the Scheduler is active. *Figure 11**.2*
    gives a complete overview of the **Cloud** **Scheduler** Thing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – The Cloud Scheduler Thing setup](img/B19752_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – The Cloud Scheduler Thing setup
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up a new Thing with the name `CloudScheduler`. Take the following steps
    to create cloud variables, associate a device, set up network configuration, and
    finally, write the code. In *Figure 11**.2*, all the steps are marked with a number
    above red boxes, which relate to the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we need to set up three cloud variables for `CloudScheduler`. The complete
    details regarding cloud variables are available in the next section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we need to associate the device with the Thing. In the current project,
    we are using Arduino’s MKR Wi-Fi 1010, so the wizard will be the same for Arduino
    boards. The complete details are available in the *Associating a* *device* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to set up the network configuration for the device. Arduino-compatible
    boards are configured by the Arduino IoT Cloud automatically during the device
    setup wizard, so you just need to provide the Wi-Fi **service set identifier**
    (**SSID**) and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cloud variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following table explains all the properties of the variables that we need
    to use during cloud variable creation. For the Scheduler, we will use a custom
    data type, `Schedule`, which we have thanks to Arduino IoT Cloud’s extended group
    of variables. Then, make sure you have the same `declaration` variable as per
    the table; otherwise, you will need to modify the example code according to your
    naming.
  prefs: []
  type: TYPE_NORMAL
- en: '| **S#** | **Variable Name** | **Variable Type** | **Declaration** | **Permission**
    | **Update** **Policy** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `CloudScheduler1` | `Schedule` | `cloudScheduler1` | Read and write |
    On change |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `CloudScheduler2` | `Schedule` | `cloudScheduler2` | Read and write |
    On change |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `CloudScheduler3` | `Schedule` | `cloudScheduler3` | Read and write |
    On change |'
  prefs: []
  type: TYPE_TB
- en: Table 11.1 – The cloud variables declaration list
  prefs: []
  type: TYPE_NORMAL
- en: Here, I set the permission as *read* and *write* because we will input the date,
    time, and interval from the Arduino dashboard, which will be controlled by the
    end user, and the device will only perform the LED on/off operation when the Scheduler
    is in a state of `true`. **Update Policy** is set to **On change**, as the dashboard
    will send data to the device when there is any change in Scheduler values by the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Associating a device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After creating the variable, it’s time to add a device and associate it with
    the Thing:'
  prefs: []
  type: TYPE_NORMAL
- en: Before adding the device, connect the development board to the computer and
    open the **Arduino Create** **Agent** application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After assigning a name to the Thing, we need to attach the device to it. When
    you click on the **Select Device** button, you will see a popup that shows you
    the available devices and an option to add a new device. In our case, we don’t
    have a device in the portal, so we can just click on **SET UP NEW DEVICE** to
    configure a new device in the account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.3 – The associated device](img/B19752_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – The associated device
  prefs: []
  type: TYPE_NORMAL
- en: Then, you will see two options in the popup. The first option is **Set up an
    Arduino device**, and the second option is **Set up a 3rd Party device**. Here,
    you will see a note under both options that says **Compatible devices**. This
    means you cannot use all types of Arduino devices and third-party devices with
    the Arduino IoT Cloud.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Choosing the device](img/B19752_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Choosing the device
  prefs: []
  type: TYPE_NORMAL
- en: Select one option from the popup according to the available device. For this
    example, we will click on **Set up an Arduino device**, as in this chapter, we
    are using an MKR Wi-Fi 1010 board. Before adding the device, make sure the **Arduino
    Create Agent** is running on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the link where you can find the Arduino IoT Cloud-compatible boards:
    [https://store-usa.arduino.cc/pages/cloud-compatible-boards](https://store-usa.arduino.cc/pages/cloud-compatible-boards).
    For third-party devices, we have three options, which are ESP8266, ESP32, and
    **LoRaWAN** devices. For other devices, we have API access, which was discussed
    in the second part of [*Chapter 2*](B19752_02.xhtml#_idTextAnchor038).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you will see the **Setup Device** popup, which will start searching for
    your device. Make sure the device is properly connected to the machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Setup Device](img/B19752_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Setup Device
  prefs: []
  type: TYPE_NORMAL
- en: The wizard will find and list all the connected boards with their name and port
    details. Click on the **CONFIGURE** button to move forward. If the wizard didn’t
    show the device after searching, try to plug it into a different port, and click
    on the **refresh** link located at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: In the next configuration wizard, provide the device name. Spaces and special
    characters are not allowed in the device name. Then, click on the **NEXT** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.6 – The device configuration name](img/B19752_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – The device configuration name
  prefs: []
  type: TYPE_NORMAL
- en: After that, the wizard will start the device configuration process. This will
    take up to five minutes, but in most cases, it only takes one minute to configure
    the device.
  prefs: []
  type: TYPE_NORMAL
- en: You will then see the **Congratulations! You are all set** message in the next
    popup. Click on the **Done** button, and the device will be attached to your Thing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we associated the MKR Wi-Fi 1010 development board with our
    Thing. In the next section, we will configure the Wi-Fi network configuration
    for the MKR Wi-Fi 1010.
  prefs: []
  type: TYPE_NORMAL
- en: Network configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the attachment of the device with the Thing, we can see that the device
    is offline. To get it online, we need to provide the Wi-Fi details.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Network configuration](img/B19752_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Network configuration
  prefs: []
  type: TYPE_NORMAL
- en: On the Thing page under the **Network** tab, click on the **CONFIGURE** button.
    You will see the **Configure network** pop-up box with two fields – **Wi-Fi Name**
    and **Password**. Type in the Wi-Fi SSID and password, and click on the **SAVE**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: We are done with the device and network configuration; only the coding part
    is left. In the next section, we will look at the code for the device.
  prefs: []
  type: TYPE_NORMAL
- en: Coding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code for this chapter is available in the book’s official GitHub repository.
    Download the `Cloud_Scheduler_may22a` code from the repository, and import it
    to your **Arduino** **Web Editor**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the code and put it into your Thing by navigating to the `delay()`
    method, as it will block the `ArduinoCloud.update()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have very simple code. Firstly, we will define the pins’ `LED1`, `LED2`,
    and `LED3` constants, which will be initialized in the `setup()` method as output,
    using the `pinMode()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have all the code regarding Schedulers in the `loop()` method, which
    will perform an operation when a scheduler/timer is in an active state. In the
    following code, we have a separate `if-else` statement for each `cloudScheduler`
    cloud variable; here, we check whether `cloudScheduler` is active and then turn
    on the LED; otherwise, we turn off the LED. We have `cloudScheduler1`, `cloudScheduler2`,
    and `cloudScheduler3`, plus three `if-else` statements to check their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Scheduler widget is very complex in configuration with lots of options,
    but its code is very simple and straightforward. You just need to verify whether
    the Scheduler state is `true` or `false`, and if it’s `true`, then proceed with
    the task; otherwise, stop the task. So, in the `loop()` method, we have three
    `if-else` statements, which check different cloud Schedulers’/timers’ states.
    If a specific Scheduler is active, then a specific LED will be turned on; otherwise,
    it will be turned off.
  prefs: []
  type: TYPE_NORMAL
- en: 'I attached the LED in *Pin #8* to `cloudScheduler1`, the LED in *Pin #7* to
    `cloudScheduler2`, and the LED in *Pin #6* to `cloudScheduler3`. Now, set the
    first widget’s time to 5 seconds for every minute, the second widget to 10 seconds
    for every minute, and 15 seconds for every minute for the third widget. All the
    LEDs will turn on at the same time, but the first LED will be on for 5 seconds,
    the second LED will be on for 10 seconds, and the third will turn off after 15
    seconds. In this example project, we have used three different Schedulers to demonstrate
    how we can use multiple Schedulers/timers to automate our tasks on a single development
    board.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you used different *naming* in the variable declaration, then update the
    code according to your naming scheme. However, it’s better at first if you follow
    all the steps according to the book and later change the cloud variable names
    and modify your code, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Also, don’t put the code at the end of the `loop()` method, as it will create
    a delay with pulse sensor readings.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed code and how it works with the Arduino IoT Cloud
    Scheduler to turn the LEDs on and off. In the following section, we will set up
    a dashboard, where we will place the Scheduler widget and attach it to our cloud
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Dashboard creation and a deep dive into the Scheduler widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After uploading the code to the device, it’s time to set up a dashboard for
    web and mobile to insert the multiple Scheduler widgets that will be linked to
    the Scheduler variables, for further controls and operations. The following figure
    shows the visualization Scheduler with different timer options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – The Thing dashboard](img/B19752_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – The Thing dashboard
  prefs: []
  type: TYPE_NORMAL
- en: We have three Scheduler variables. To visualize all of them, three Scheduler
    widgets will be linked to each cloud variable, respectively. The purpose of the
    three widgets and variables is to demonstrate how we can set different types of
    timers. The first widget demonstrates how to use a timer that will be executed
    every minute for 30 seconds, the second widget demonstrates how to use a timer
    that will be activated every hour for five minutes, and the third widget demonstrates
    that we can set the timer for a long period, such as specific days at a specific
    time. Here, I have set it to be activated on Monday, Wednesday, and Friday for
    five minutes.
  prefs: []
  type: TYPE_NORMAL
- en: We just set the different widgets with different timer settings. One of the
    example settings of the Scheduler widget is shown in *Figure 11**.9*, and we will
    explore in depth how to set these settings. This control widget has multiple options
    for configuration, so I think it’s necessary to discuss it in detail for proper
    guidance.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – The Scheduler widget options](img/B19752_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – The Scheduler widget options
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on the Scheduler widget, a popup will appear with options, just
    like in the preceding figure. Here, I have divided the screenshot into four different
    numbered sections. From this popup, you can adjust your time settings from seconds
    to years and set the start and end date, or choose to execute without any date
    limitation. Let’s look at each section:'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have two input controls – one is for the starting date and the other
    is for the starting time, as indicated by the control headings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we have the **Duration** setting, in which we have three drop-down boxes
    – **HOURS**, **MINUTES**, and **SECONDS**. This will define how long the timer
    will be executed on the machine. For example, if you want to perform an operation
    for 30 seconds, then just select **30** seconds and leave the other fields, or
    if you want to perform an operation for 5 minutes, then select **5** minutes and
    leave the other fields, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we have the **Repeat every** setting, which is only applicable for **Week**,
    **Month**, and **Year**; there is no predefined setting for minutes and hours.
    I have selected **Week**. Under that, the days are shown (by their first letter),
    and there, you can select on which day/days you can perform an operation. There
    are different options for **Month** and **Year**, which will be discussed in a
    moment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we have the **End recurrence** setting. Here, we have two options –
    **Never** and **On**. When you click on **On**, you will need to enter the date
    and time when your operation will be stopped. If you want to execute it indefinitely,
    then just select the **Never** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For **Year** and **Month** in the **Repeat every** section, we have different
    options in the Scheduler. The following figures show all the details regarding
    both options. First, let’s look at **Month**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – The Month option in the Scheduler](img/B19752_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – The Month option in the Scheduler
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the **Year** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – The Year option in the Scheduler](img/B19752_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – The Year option in the Scheduler
  prefs: []
  type: TYPE_NORMAL
- en: For **Month**, we have a dropdown that allows us to select the day (such as
    **1st**), while in the case of **Year**, we have two dropdowns – one for the day
    and one for the month (such as **1st** **January**).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we set up the dashboard with three different Scheduler widgets
    and assigned them Boolean-type cloud variables, which will be used in our code
    to check the Scheduler state and whether the Scheduler is active or not. In the
    following section, you have an assignment to use the Scheduler according to the
    specified requirements, giving you a proper idea of how you can use the scheduler
    functionality in your projects to enhance your product development.
  prefs: []
  type: TYPE_NORMAL
- en: The task at hand – an assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Continuing from the previous project where you connected three LEDs to the
    MKR Wi-Fi 1010 and set up the Arduino IoT Cloud Scheduler, complete the following
    assignment tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Attach three relays to control any electrical/electronic appliance, such as
    a fan, light, or heater, using the Scheduler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the Scheduler to turn your home’s outside/indoor lights on/off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach a buzzer instead of LEDs, and create an alarm device for your room/classroom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn on surprise lighting with the Scheduler for a birthday or anniversary.
    Use the same light strip with multiple Schedulers to turn the light strips on/off
    for different occasions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control the water solenoid valve for your garden/tunnel farm using the Scheduler
    (this is optional, and if you have a smart agriculture facility).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we outlined an assignment that will test your skills with different
    scenarios and help you explore the usage of the Scheduler feature in different
    environments. In the following section, we will start to explore the benefits
    of OTA, the Arduino IoT Cloud's OTA features, supported development boards for
    OTA, and how to use OTA features in the Arduino IoT Cloud. And, of, course you
    will also learn about the pros and cons of the Arduino IoT Cloud OTA.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring OTA updates in IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OTA is a term that refers to the wireless distribution of software or firmware
    updates, or other updates to devices. This technology allows updates to be delivered
    and installed on devices without the need for physical connections or manual intervention.
    OTA is widely utilized across various industries, including telecommunications,
    automotive, consumer electronics, and IoT. Here are a few examples of OTA usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mobile devices**: OTA updates are commonly employed to distribute operating
    system updates, security patches, and feature enhancements to smartphones and
    tablets. Users receive notifications, prompting them to download and install the
    updates wirelessly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automotive industry**: Many modern vehicles are equipped with OTA capabilities,
    enabling manufacturers to remotely update the vehicle software, infotainment systems,
    navigation maps, and other features. OTA updates can improve vehicle performance,
    introduce new functionalities, and address security vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IoT devices**: IoT devices, such as smart home devices, wearables, and industrial
    sensors, often rely on OTA updates to deliver firmware updates, bug fixes, and
    new features. This enables manufacturers to enhance device performance, address
    vulnerabilities, and introduce new functionalities without the need for physical
    access to the devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set-top boxes and smart TVs**: OTA updates are utilized to deliver firmware
    updates and software patches to set-top boxes and smart TVs. This ensures that
    these devices remain up to date with the latest features, security enhancements,
    and bug fixes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OTA updates offer numerous benefits, including convenience, cost-effectiveness,
    and the ability to quickly address security vulnerabilities or software issues.
    However, ensuring the integrity and security of OTA updates is crucial to prevent
    unauthorized access or malicious activities that could compromise the devices
    or data.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored what OTA is and how it offers benefits in today’s
    world. In the following section, we will discuss in detail the Arduino IoT Cloud
    OTA feature, which includes compatible devices that are supported by the Arduino
    IoT Cloud for OTA, and how to use the OTA feature in the Arduino IoT Cloud to
    send firmware updates to devices.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the Arduino IoT Cloud for OTA updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Arduino IoT Cloud OTA** is a feature available in the Arduino IoT Cloud platform,
    designed to facilitate the remote monitoring and control of Arduino-based IoT
    devices. This functionality allows users to wirelessly update the firmware of
    their deployed Arduino IoT devices.'
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud pros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Arduino IoT Cloud OTA feature offers the following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Firmware updates**: Users can remotely update the firmware of their Arduino
    IoT devices as well as ESP-series devices using Arduino IoT Cloud OTA. This enables
    the deployment of bug fixes, security patches, feature enhancements, and new versions
    of code without the need for physical access to the devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code synchronization**: The OTA feature ensures that the code running on
    Arduino/ESP-series IoT devices remains synchronized with the latest version stored
    on the cloud. It eliminates the necessity of manually updating each device individually,
    thereby maintaining consistency across the entire fleet of IoT devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OTA configuration**: In addition to firmware updates and code synchronization,
    Arduino IoT Cloud OTA enables users to remotely configure the parameters or settings
    of their Arduino/ESP-series IoT devices. This means device behavior can be modified,
    thresholds can be adjusted, and variables can be changed without the need for
    physical intervention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and integrity**: Arduino IoT Cloud OTA ensures the security and
    integrity of firmware updates through authentication and encryption mechanisms.
    This safeguards against unauthorized access or tampering during the transmission
    process, enhancing the security of IoT devices and preventing potential vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By providing a convenient and secure method to remotely update firmware and
    configure devices, the Arduino IoT Cloud OTA simplifies the management and maintenance
    of Arduino-based IoT deployments. It enhances efficiency, reduces costs, and enables
    users to keep their IoT devices up to date with the latest features, bug fixes,
    and security enhancements. In the following subsection, we will discuss the cons
    of the Arduino IoT Cloud OTA feature.
  prefs: []
  type: TYPE_NORMAL
- en: Arduino IoT Cloud OTA cons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Arduino IoT Cloud OTA feature is a convenient tool to remotely update the
    firmware of your Arduino devices connected to the Arduino IoT Cloud platform.
    However, as with any technology, it has its drawbacks and limitations. Here are
    some cons of the Arduino IoT Cloud OTA feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Limited bandwidth**: OTA updates require data transfer over the internet,
    which can be costly or problematic in areas with limited or expensive data bandwidth.
    Large firmware updates may consume a significant amount of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network stability**: Reliable internet connectivity is essential for OTA
    updates. If a device loses connection during an update, it can result in failed
    or corrupt firmware, potentially rendering the device unusable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version control**: Managing different versions of firmware across multiple
    devices can become challenging. Keeping track of which devices are running which
    firmware versions and ensuring compatibility can be time-consuming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compatibility issues**: OTA updates may not work seamlessly with all types
    of devices and configurations. Ensuring that your hardware supports OTA updates
    and that you have the necessary libraries and code in place can be a complex task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latency**: Depending on the size of the firmware update and the speed of
    the internet connection, OTA updates can introduce latency, causing devices to
    be temporarily unavailable during the update process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency on the Arduino IoT Cloud**: To use the Arduino IoT Cloud OTA feature,
    you must rely on the Arduino IoT Cloud platform. If the platform experiences downtime
    or changes in its services, it can impact your ability to perform OTA updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited rollback options**: In some cases, if an OTA update fails or causes
    issues, rolling back to a previous firmware version can be challenging, especially
    if you didn’t plan for rollback mechanisms in advance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite these cons, OTA updates remain a valuable feature for many IoT projects.
    However, it’s essential to carefully assess your project’s specific requirements
    and constraints before implementing OTA updates and to address these challenges
    through proper planning and security measures.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the different benefits of the Arduino IoT Cloud
    OTA feature as well as its cons. In the following section, we will take a deeper
    look into which hardware development boards are compatible with the Arduino IoT
    Cloud OTA feature, as it is currently not supported by all hardware development
    boards. Therefore, it’s necessary for you to keep this point in mind during the
    product development stage if you need an OTA feature for your product.
  prefs: []
  type: TYPE_NORMAL
- en: A list of compatible development hardware for Arduino OTA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not all of the official Arduino (or other) development boards are ready for
    the OTA feature, but here are the ones that are compatible and ready. Go to this
    link to check out all the information regarding OTA-compatible development boards:
    https://docs.arduino.cc/arduino-cloud/features/ota-getting-started.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the official Arduino development boards that are ready for OTA:'
  prefs: []
  type: TYPE_NORMAL
- en: Arduino MKR Wi-Fi 1010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arduino Nano 33 IoT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arduino Nano RP2040 Connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portenta H7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portenta Machine Control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nicla Vision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arduino Opta (PLC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the ESP32-series development boards that are ready for OTA:'
  prefs: []
  type: TYPE_NORMAL
- en: ESP32-S2-DevKitC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NodeMCU-32-S2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WeMos LOLIN D32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ESP32-S3-DevKitC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ESP32-CAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NodeMCU-32S
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freenove ESP32 WROVER
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ESP32-DevKitC-32E
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DOIT ESP32 DevKit v1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The good thing is that Arduino provides the latest features to ESP32-series
    development boards. These boards are very popular among students/researchers and
    professional developers, due to their cost and availability all around the world.
    I used the **XIAO ESP32-C3 series** development board for various projects and
    tested the OTA service for that board. From my personal experience, the OTA service
    works faster on official Arduino development boards as compared to the ESP32 series,
    but I hope in the future that the Arduino Cloud team will optimize the OTA feature
    for the ESP32 series board for a faster and better experience.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud offers the OTA feature to Wi-Fi-enabled devices. This
    means that LoRaWAN is currently not compatible with the OTA feature.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the broad range of compatible boards that support
    the Arduino IoT Cloud OTA feature. In the following section, we will take a look
    at how we can use the OTA feature in the Arduino IoT Cloud to send firmware updates
    via the internet, without any device connection to the host computer.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the OTA update on the MKR Wi-Fi 1010
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, we will explore how we can use OTA, and then we will dive deep into
    how OTA works behind the scenes. We need to navigate to a Thing that uses an OTA-supported
    development board; we will choose a Thing that is already attached to the MKR
    Wi-Fi 1010 device. Navigate to the **Sketch** tab in the Thing. The following
    figure shows the OTA feature and port:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – The physical port connection with the OTA update feature](img/B19752_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – The physical port connection with the OTA update feature
  prefs: []
  type: TYPE_NORMAL
- en: My device is connected to my MacBook as well as to the Arduino IoT Cloud via
    Wi-Fi. That’s why you can see two options in the preceding figure for sketch uploading.
    The first one is the **Port** option, which is only available when your development
    board is directly connected to your laptop/computer, while the second option is
    **Over-the-Air**, which is available when your code is configured on your development
    board with network settings and successfully connected to the Arduino IoT Cloud
    over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Over-the-Air** option, and click on the **Sketch Uploading** (the
    green arrow icon) button; this will start uploading your updated code to the board
    via the internet without the intervention of a physical connection. However, how
    can you confirm that this works via the internet? Just unplug the development
    board from your computer and power it with any adapter, but make sure your device
    has access to a Wi-Fi router.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – The standalone Over-the-Air update option](img/B19752_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – The standalone Over-the-Air update option
  prefs: []
  type: TYPE_NORMAL
- en: After disconnecting from the computer and turning on the device via the power
    adapter, you will see only the **Over-the-Air** update option in your **Sketch**
    tab. Just modify your code or add some extra login details, and click on **Sketch
    Uploading** (the green arrow icon), and within a short time, your code will be
    on the development board without any hassle.
  prefs: []
  type: TYPE_NORMAL
- en: Based on my experience, I've often thought we should have an option by which
    we can modify/update the code of remote devices, such as devices for smart agriculture,
    warehouse monitoring, and industrial monitoring, because it’s very difficult to
    travel to remote places to update/modify the code. However, the Arduino IoT Cloud
    OTA feature makes our lives easier overall. With the OTA feature, we can save
    time and cost and provide the correct updates on time to our devices without any
    delay.
  prefs: []
  type: TYPE_NORMAL
- en: How OTA works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s talk about how OTA works behind the scenes. The Arduino IoT Cloud first
    compiles the code in a cloud environment, according to the selected device, and
    then stores these compiled files in `OTA_REQ` flag is `true`, it will start downloading
    the compiled files from the specified URL. After download completion, the development
    board verifies the downloaded files with a length/CRC check. After download verification,
    the board will start flashing with the latest firmware. The following figure illustrates
    the whole procedure that happens behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – The Arduino IoT Cloud OTA behind the scenes](img/B19752_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – The Arduino IoT Cloud OTA behind the scenes
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino IoT Cloud team has simplified the complexity of this process and
    provides only a single-click option for developers for OTA. The purpose of this
    diagram is to give you an overview of how things work, which will hopefully provide
    you with new ideas for your future developments.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to implement the Arduino IoT Cloud OTA feature
    to send firmware OTA. We also discussed how the Arduino IoT Cloud sends firmware
    updates to devices using the Amazon S3 service.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the Scheduler and how we can use the Arduino IoT
    Cloud to automate tasks that have different patterns or random patterns of operation.
    We used simple LEDs with the MKR Wi-Fi 1010 to demonstrate multiple Scheduler/timer
    operations, which helped you to understand how to use this function in real-world
    projects, such as in smart agriculture and smart industry.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of the chapter, we explored OTA. Firstly, we discussed the
    pros and cons of OTA and how we can save time and costs with it. Then, we used
    OTA-enabled development boards to demonstrate the use of the OTA feature, and
    finally, we explored how OTA works behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will implement a healthcare project. You will learn
    how to use a heartbeat sensor as well as the Arduino IoT Cloud webhooks feature,
    which will send data to a third-party service (**Zapier**). We will use Zapier
    to set up a *Zap*, which will receive the heartbeat readings and send an email
    notification to a designated person if the reading is over or under the threshold.
  prefs: []
  type: TYPE_NORMAL
