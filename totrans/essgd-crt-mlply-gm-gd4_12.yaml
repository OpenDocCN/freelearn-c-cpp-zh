- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Implementing Lag Compensation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现延迟补偿
- en: Welcome to one of the most anticipated chapters in the book. Here, we will dive
    into the core of online multiplayer game optimization. In the world of online
    gaming, where players from across the globe unite to embark on epic adventures,
    two formidable adversaries lurk in the shadows; they are **lag** and **latency**.
    These foes can transform a thrilling gaming experience into a frustrating trial.
    In this chapter, we’ll confront these challenges head-on, arming you with the
    knowledge and tools to mitigate their impact and create an engaging online gaming
    environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本书中最受期待的章节之一。在这里，我们将深入探讨在线多人游戏优化的核心。在在线游戏的世界里，来自全球的玩家聚集在一起开始史诗般的冒险，两个强大的对手潜伏在阴影中；他们是**延迟**和**延迟**。这些敌人可以将激动人心的游戏体验转变为令人沮丧的考验。在本章中，我们将直面这些挑战，为你提供知识和工具来减轻它们的影响，并创建一个引人入胜的在线游戏环境。
- en: In this chapter, we will use `Player` node’s`Spaceship` node maintain its position
    and rotation, synced throughout the game instances across the network. For that,
    we will understand the core issues regarding packet loss and latency, something
    common when we use unreliable packets, as we do when using the ENet protocols.
    Then, we will fake some latency and packet loss by using `Timer` nodes so that
    we can understand how these issues may display in the actual game. After that,
    we will talk about some common techniques to create solutions for these issues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`Player`节点的`Spaceship`节点来维护其位置和旋转，在整个游戏实例的网络中保持同步。为此，我们将了解与数据包丢失和延迟相关的核心问题，这在使用不可靠的数据包时很常见，就像我们使用ENet协议时那样。然后，我们将通过使用`Timer`节点来模拟一些延迟和数据包丢失，以便我们了解这些问题如何在实际游戏中显示。之后，我们将讨论一些常见的补偿技术来解决这些问题。
- en: By the end of the chapter, you will understand how we can fake some smooth movement,
    even when the game’s `MultiplayerSynchronizer` fails to deliver data across peers’
    game instances.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解我们如何模拟一些平滑的运动，即使游戏的`MultiplayerSynchronizer`未能将数据传递到对等游戏实例中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing lag issues
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍延迟问题
- en: Dealing with unreliable packets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理不可靠的数据包
- en: Common compensation techniques
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的补偿技术
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As mentioned in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging
    and Profiling the Network*, *Part 3*, *Optimizing the Online Experience*, of this
    book focuses on the final version of the project made in *Chapter 9*, *Creating
    an Online Adventure Prototype*, so it’s fundamental to read, exercise, and implement
    the concepts presented there. You can get the files necessary to start this chapter
    at the following link: [https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation).
    They contain the progress we’ve made for optimizations in [*Chapter 11*](B18527_11.xhtml#_idTextAnchor276),
    *Optimizing* *Data Requests*.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第10章*](B18527_10.xhtml#_idTextAnchor260)，*调试和配置网络*，*第3部分*，*优化在线体验*中所述，本书的*第9章*，*创建在线冒险原型*中的项目最终版本是重点，因此阅读、练习和实现那里介绍的概念是基本的。你可以从以下链接获取开始本章所需的文件：[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation)。它们包含了我们在[*第11章*](B18527_11.xhtml#_idTextAnchor276)，*优化*
    *数据请求*中进行的优化进展。
- en: It’s also necessary that you have read and understood the concepts and tools
    presented in [*Chapter 11*](B18527_11.xhtml#_idTextAnchor276), *Optimizing Data
    Requests*, so that we can continue with the assumption that you already know what
    they are and how to use them properly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，你也需要阅读并理解了[*第11章*](B18527_11.xhtml#_idTextAnchor276)，*优化数据请求*中介绍的概念和工具，这样我们才能继续假设你已经知道它们是什么以及如何正确使用它们。
- en: Introducing lag issues
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍延迟问题
- en: Addressing lag and unreliable packets involves three techniques – **interpolation**,
    **prediction**, and **extrapolation**. These techniques smoothen player movements,
    maintain responsiveness, and anticipate object movements. The Godot Engine’s physics
    simulation and RPC method are crucial in these techniques, aiding in realistic
    object movement and data synchronization, despite network issues.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 解决延迟和不稳定的包涉及三种技术——**插值**、**预测**和**外推**。这些技术使玩家动作更加平滑，保持响应性，并预测物体运动。Godot引擎的物理模拟和RPC方法在这些技术中至关重要，有助于实现逼真的物体运动和数据同步，即使在网络问题的情况下。
- en: Lag and latency are the archenemies of any online multiplayer game. Lag, often
    used interchangeably with latency, refers to the delay between a player’s action
    and its corresponding effect in the game. It’s the momentary pause between pulling
    the trigger and seeing the enemy fall. Latency, on the other hand, represents
    the time it takes for data to travel from a player’s device to the game server
    and back. Together, these factors can disrupt the fluidity of gameplay, leaving
    players frustrated and disconnected from the virtual world.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟和延迟是任何在线多人游戏的宿敌。延迟，通常与延迟互换使用，指的是玩家动作与其在游戏中的相应效果之间的延迟。这是拉动扳机和看到敌人倒下的瞬间暂停。另一方面，延迟表示数据从玩家设备传输到游戏服务器并返回所需的时间。这两个因素可以破坏游戏流畅性，让玩家感到挫败，并使他们与虚拟世界脱节。
- en: Within the world of online multiplayer gaming, the transmission of data is seldom
    a seamless journey. Unreliable packets, those mischievous bits of information,
    can create issues by arriving out of order or disappearing altogether. When packets
    are out of order, a player might see an opponent magically teleport across the
    map and back or perform impossible feats. Data loss results in vital game updates
    never reaching their intended destination, leaving characters and objects frozen
    in time. Our mission in this chapter is to combat these issues and bring order
    to the chaos.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在在线多人游戏的世界里，数据的传输很少是一帆风顺的。不稳定的包，这些调皮的信息片段，可能会因为顺序混乱或完全消失而造成问题。当包顺序混乱时，玩家可能会看到对手神奇地穿越地图并返回，或者完成不可能的壮举。数据丢失导致关键的游戏更新无法到达其目标位置，使得角色和物体停滞在时间中。在本章中，我们的任务是解决这些问题，将混乱变为有序。
- en: In the realm of online multiplayer gaming, a recurring and often frustrating
    issue that plagues both developers and players alike is the challenge of lag and
    latency. In this section, we’ll talk about these two fundamental aspects of online
    gaming and shed light on the profound impact they have on a player’s experience.
    As you already discovered in previous chapters, creating a seamless and immersive
    multiplayer environment requires a nuanced understanding of these concepts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在在线多人游戏领域，延迟和延迟是困扰开发者和玩家的一个反复出现且经常令人沮丧的问题。在本节中，我们将讨论这两个在线游戏的基本方面，并揭示它们对玩家体验的深远影响。正如你在前面的章节中已经发现的，创建一个无缝和沉浸式的多人环境需要对这些概念有细微的理解。
- en: Now, let’s talk about the impact of lag and latency on gameplay. When a player
    experiences lag, it disrupts the flow of the game and can lead to missed opportunities,
    frustration, and, in competitive scenarios, unfavorable outcomes. Imagine firing
    a weapon in an online shooter, only to have the shot register seconds later, long
    after your target has moved to safety.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈延迟和延迟对游戏体验的影响。当玩家遇到延迟时，它会打断游戏的流畅性，可能导致错失机会、挫败感，在竞技场景中，甚至可能导致不利的结局。想象一下，在在线射击游戏中开火，却发现子弹在几秒后才被记录下来，而此时目标早已安全撤离。
- en: Understanding the causes of lag and latency is crucial for effective mitigation.
    Network congestion, hardware limitations, and geographic distance between players
    and servers are common causes. **Network congestion** occurs when the data traffic
    on a network is too high, causing data packets to be delayed or lost. Hardware
    limitations, such as a slow internet connection or an underpowered computer, can
    also contribute to latency.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 理解延迟和延迟的原因对于有效缓解至关重要。网络拥塞、硬件限制以及玩家和服务器之间的地理距离是常见的原因。**网络拥塞**发生在网络上的数据流量过高，导致数据包延迟或丢失。硬件限制，如缓慢的互联网连接或性能不足的计算机，也可能导致延迟。
- en: Mitigating lag and latency is a constant challenge for game developers. One
    strategy is server optimization, where game servers are finely tuned to handle
    large volumes of data efficiently. Another approach is client-side prediction
    and interpolation, techniques that help to smooth out gameplay even when there
    are network delays; we will talk about these in the *Common compensation techniques*
    section. On top of these, choosing the right network infrastructure, such as **Content
    Delivery Networks** (**CDNs**), can significantly reduce latency by placing game
    assets closer to players.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解延迟和延迟是游戏开发者面临的一个持续挑战。一种策略是服务器优化，游戏服务器被精细调整以高效处理大量数据。另一种方法是客户端预测和插值，这些技术有助于在网络延迟的情况下平滑游戏体验；我们将在*常见补偿技术*部分中讨论这些内容。除此之外，选择合适的网络基础设施，例如**内容分发网络**（**CDNs**），通过将游戏资产放置在玩家附近，可以显著降低延迟。
- en: We’ve peeled back the layers of lag and latency, understanding how these factors
    impact online multiplayer games. We saw some of their causes and discussed strategies
    for mitigation, all with the goal of enhancing a player’s gaming experience. In
    the next section, we will talk about issues specific to unreliable packets, which
    are what we usually use to transfer data over a network in online multiplayer
    games.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经揭开了延迟和延迟的层，了解了这些因素如何影响在线多人游戏。我们看到了一些原因，并讨论了缓解策略，所有这些都有助于提升玩家的游戏体验。在下一节中，我们将讨论与不可靠数据包相关的问题，这是我们通常用于在线多人游戏中通过网络传输数据的方式。
- en: Dealing with unreliable packets
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理不可靠的数据包
- en: One of the top concerns that developers grapple with when creating online multiplayer
    games is the reliability of data packets. In this section, we’ll see the complexities
    surrounding unreliable packets, shedding light on the issues they bring to the
    forefront of online multiplayer games. As you’ve already gleaned from our discussions,
    understanding these challenges is core to crafting a smooth and immersive multiplayer
    gaming experience.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在创建在线多人游戏时面临的一个主要担忧是数据包的可靠性。在本节中，我们将探讨围绕不可靠数据包的复杂性，揭示它们给在线多人游戏带来的问题。正如您从我们的讨论中已经了解到的，理解这些挑战是打造流畅和沉浸式多人游戏体验的核心。
- en: '**Unreliable packets**, as the name suggests, are data packets sent over a
    network without any guarantee of arrival or order. They’re like letters in the
    wind, reaching their destination only if the conditions are favorable. These packets
    are used to transmit non-critical data in online games, such as character positions,
    because they offer lower latency compared to reliable packets, which come with
    built-in delivery assurances at the expense of potential lag.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，**不可靠的数据包**是指在网络上发送的数据包，没有任何到达或顺序保证。它们就像随风飘散的信件，只有在条件有利的情况下才能到达目的地。这些数据包用于在线游戏中传输非关键数据，如角色位置，因为与具有内置交付保证的可靠数据包相比，它们提供了更低的延迟。
- en: One of the primary issues associated with unreliable packets is packet loss.
    This occurs when packets sent from one player’s device fail to reach a server
    or another player’s device. It’s like pieces of a puzzle disappearing into thin
    air, leading to incomplete and inconsistent data. In a fast-paced action game,
    packet loss can manifest as abrupt character teleportations, vanished projectiles,
    or inexplicable desynchronization among players.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与不可靠数据包相关的一个主要问题是数据包丢失。这发生在从一位玩家的设备发送的数据包未能到达服务器或另一位玩家的设备时。这就像拼图碎片消失在空中，导致数据不完整和不一致。在快节奏的动作游戏中，数据包丢失可能表现为角色突然传送、消失的弹丸或玩家之间不可解释的同步错误。
- en: Another challenge is the out-of-order arrival of packets. In an ideal world,
    data packets would arrive at their destination in the same order they were sent.
    However, the unpredictability of network routes can cause packets to arrive out
    of order, leading to chaos in the game world. Imagine receiving instructions to
    assemble a piece of furniture, only to receive the steps out of sequence; it’s
    a recipe for confusion and frustration. Usually, in these cases, we only use the
    latest data and ignore the older ones, as only the most recent information is
    relevant to the game.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个挑战是数据包的顺序到达。在一个理想的世界里，数据包会以发送时的相同顺序到达目的地。然而，网络路由的不确定性可能导致数据包顺序到达，导致游戏世界中的混乱。想象一下，你收到组装家具的指令，但步骤却顺序混乱；这是一场混乱和挫败的预兆。通常，在这些情况下，我们只使用最新的数据并忽略旧数据，因为只有最新的信息与游戏相关。
- en: The consequences of unreliable packets can be dire for gameplay. Packet loss
    and out-of-order arrivals can lead to player disconnection, incorrect character
    positions, and erratic synchronization among players. For example, a player’s
    character might appear to jump from one location to another due to missing packets.
    This not only disrupts immersion but also undermines the fairness and integrity
    of competitive play.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不可靠数据包对游戏的影响可能是灾难性的。数据包丢失和顺序错误到达可能导致玩家断开连接、角色位置不正确以及玩家之间的同步异常。例如，由于缺失数据包，玩家的角色可能会从一个位置跳跃到另一个位置。这不仅会破坏沉浸感，还会损害竞技游戏的公平性和完整性。
- en: Mitigating the issues brought on by unreliable packets requires a multifaceted
    approach. Developers often employ techniques such as client-side prediction, where
    the client makes informed guesses about missing data to maintain a coherent game
    state. Interpolation, another valuable tool, smooths out the jitters caused by
    missing packets by smoothly transitioning between known data points.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解不可靠数据包带来的问题需要多方面的方法。开发者通常会采用客户端预测等技术，客户端根据缺失的数据做出明智的猜测，以保持游戏状态的一致性。插值是另一个有价值的工具，通过在已知数据点之间平滑过渡，它平滑了由缺失数据包引起的抖动。
- en: In this section, we saw that packet loss is a common issue where packets fail
    to reach their destination, leading to incomplete and inconsistent data. We also
    saw that some packets may arrive out of order, causing chaos in the game world.
    These issues can result in player disconnection, incorrect character positions,
    and erratic synchronization among players. In the next section, we are going to
    see the most common compensation techniques to solve these and the lag-related
    issues.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解到数据包丢失是一个常见问题，其中数据包未能到达目的地，导致数据不完整和不一致。我们还看到，一些数据包可能会顺序错误地到达，导致游戏世界中的混乱。这些问题可能导致玩家断开连接、角色位置不正确以及玩家之间的同步异常。在下一节中，我们将看到解决这些以及与延迟相关问题的最常见补偿技术。
- en: Common compensation techniques
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的补偿技术
- en: Welcome to the most anticipated section in our journey through the realm of
    online multiplayer game development. In the previous sections, we unraveled the
    complexities of networking, synchronization, and the intricacies of dealing with
    unreliable packets. Now, we stand at a crucial juncture, ready to explore the
    fascinating world of **interpolation**, **prediction**, and **extrapolation**,
    a trio of techniques that hold the key to creating seamless and responsive online
    gaming experiences, or at least to get as close as we can to this Holy Grail.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们探索在线多人游戏开发领域的最期待部分。在前面的章节中，我们揭开了网络、同步以及处理不可靠数据包的复杂性的面纱。现在，我们站在一个关键的分岔路口，准备探索**插值**、**预测**和**外推**的迷人世界，这三项技术是创造无缝和响应式在线游戏体验的关键，或者至少让我们尽可能地接近这个圣杯。
- en: Picture this – you’re in the heat of an intense multiplayer battle, and the
    stakes couldn’t be higher. In the world of online gaming, every second counts,
    and every move must be precise. But what happens when network latency rears its
    head, causing a slight delay in transmitting data between players? This is where
    interpolation, prediction, and extrapolation come to the rescue.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下——你正处于一场激烈的多玩家战斗的高潮，赌注无法更高。在在线游戏的世界里，每一秒都很重要，每一个动作都必须精确。但当网络延迟出现，导致玩家之间数据传输出现轻微延迟时，会发生什么呢？这就是插值、预测和外推发挥作用的地方。
- en: One of the cornerstones of implementing interpolation, prediction, and extrapolation
    is the integration of physics simulation. In **Godot Engine**, the physics engine
    plays a crucial role in determining how objects move and interact within the game
    world. By marrying physics with prediction algorithms, you can create a realistic
    and responsive gameplay experience that feels in sync with the laws of our virtual
    universe.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实施插值、预测和外推的一个关键基石是将物理模拟与预测算法相结合。在**Godot引擎**中，物理引擎在确定游戏世界中对象如何移动和交互方面发挥着至关重要的作用。通过将物理与预测算法相结合，你可以创建一个符合我们虚拟宇宙法则的逼真和响应式的游戏体验。
- en: To orchestrate the symphony of data synchronization, we’ll take rid of the `Player`
    node’s `MultiplayerSynchronizer` node and employ some *RPC* methods. These functions
    serve as the conductor of our data orchestra, allowing us to send the necessary
    information to clients or a server precisely when it’s needed. With RPCs, we can
    trigger the transmission of interpolated, predicted, or extrapolated data, ensuring
    that all players stay on the same page.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了协调数据同步的交响乐，我们将移除`Player`节点的`MultiplayerSynchronizer`节点，并使用一些*RPC*方法。这些函数充当我们数据乐团的指挥，允许我们在需要时精确地向客户端或服务器发送必要的信息。通过RPC，我们可以触发插值、预测或外推数据的传输，确保所有玩家保持一致。
- en: In the next sections, we’ll jump into the implementation of interpolation, prediction,
    and extrapolation in our online multiplayer top-down adventure prototype. By the
    end, you’ll understand how these techniques work together to compensate for network
    latency. So, fasten your seatbelts, for we are about to navigate the intricacies
    of smooth and responsive gameplay in the dynamic world of online multiplayer gaming.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨在我们的在线多人俯视冒险原型中实现插值、预测和外推。到那时，你将了解这些技术是如何共同工作以补偿网络延迟的。所以，系好安全带，因为我们即将导航在线多人游戏动态世界中的流畅和响应式游戏细节。
- en: Implementing server-side motion
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现服务器端运动
- en: 'To have a better setup to understand how lag influences the gameplay experience,
    we are going to make some changes to the `Player` scene and scripts. Instead of
    allowing the movement to happen on the client side and being synced to the server
    and other peers, a player will use input events to change the movement of a server’s
    `Spaceship` instance. This will allow us to also decrease the amount of syncing
    data sent by `MultiplayerSynchronizer`, since now we will have the motion simulated,
    based on `Spaceship`’s thrusting and rotating states. To do that, let’s open the
    `res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn` scene. Then,
    follow the following steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地设置以了解延迟如何影响游戏体验，我们将对`Player`场景和脚本进行一些修改。我们不再允许在客户端发生移动并同步到服务器和其他对等节点，而是玩家将使用输入事件来改变服务器`Spaceship`实例的运动。这将使我们能够减少`MultiplayerSynchronizer`发送的同步数据量，因为现在我们将基于`Spaceship`的推力和旋转状态进行运动模拟。为此，让我们打开`res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn`场景。然后，按照以下步骤进行：
- en: 'Select the `MultiplayerSynchronizer` node, and in the `Spaceship`’s position
    and rotation sync on both the **Spawn** and **Sync** options:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`MultiplayerSynchronizer`节点，并在**Spawn**和**Sync**选项上同步`Spaceship`的位置和旋转：
- en: '![Figure 12.1 – The Player scene’s MultiplayerSynchronizer Replication menu,
    with the Spaceship position and rotation properties disabled](img/Figure_12.01_B18527.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 玩家场景的MultiplayerSynchronizer复制菜单，Spaceship位置和旋转属性已禁用](img/Figure_12.01_B18527.jpg)'
- en: Figure 12.1 – The Player scene’s MultiplayerSynchronizer Replication menu, with
    the Spaceship position and rotation properties disabled
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 玩家场景的MultiplayerSynchronizer复制菜单，Spaceship位置和旋转属性已禁用
- en: 'Then, let’s open the `res://09.prototyping-space- adventure/Actors/Player/Player2D.gd`
    file, and we will make some changes to the `setup_multiplayer()` method. The first
    thing to do here is to remove the line that enables the `_physics_process()` and
    `_process()` callbacks, leaving only `_unhandled_input()`. We will see why in
    the following steps:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们打开`res://09.prototyping-space-adventure/Actors/Player/Player2D.gd`文件，并对`setup_multiplayer()`方法进行一些修改。在这里要做的第一件事是删除启用`_physics_process()`和`_process()`回调的行，只留下`_unhandled_input()`。我们将在以下步骤中看到原因：
- en: '[PRE0]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we will check whether the current instance isn’t the server; if it isn’t,
    we call the `make_current()` method, effectively enabling this player’s `Camera2D`
    node on their game instance:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将检查当前实例是否不是服务器；如果不是，我们将调用`make_current()`方法，从而在他们的游戏实例上有效启用此玩家的`Camera2D`节点：
- en: '[PRE1]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, we will lay the groundwork the new `Spaceship` node movement logic, get
    rid of the `_physics_process()` callback, and work in the `_unhandled_input()`
    callback instead. The whole logic follows the same idea of `Weapon2D`; `Spaceship`
    will have `thrusting`, `direction`, and `turning` variables that we can use to
    change its movement. Based on the input events we get in `_unhandled_input()`,
    we will change the state of these variables. The secret here is that we will use
    the `rpc_id()` method to change these states on the server’s `Spaceship` instance.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为新 `Spaceship` 节点的运动逻辑打下基础，移除 `_physics_process()` 回调，并在 `_unhandled_input()`
    回调中工作。整个逻辑遵循 `Weapon2D` 的相同思路；`Spaceship` 将有 `thrusting`、`direction` 和 `turning`
    变量，我们可以使用这些变量来改变其运动。基于我们在 `_unhandled_input()` 中获得的事件输入，我们将改变这些变量的状态。这里的秘密是我们将使用
    `rpc_id()` 方法在服务器的 `Spaceship` 实例上改变这些状态。
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let’s move on to the `res://09.prototyping-space- adventure/Objects/Spaceship/Spaceship.gd`
    script, where we will implement the variables and methods necessary for the aforementioned
    changes to work. First, let’s declare the properties and their setter methods:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们转到 `res://09.prototyping-space-adventure/Objects/Spaceship/Spaceship.gd`
    脚本，在那里我们将实现上述更改所需的变量和方法。首先，让我们声明属性及其设置方法：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, let’s declare these methods; here’s the trick – they are *RPCs* that
    any peer can call, and they will be called locally:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们声明这些方法；这里有个技巧——它们是 *RPCs*，任何对等节点都可以调用，并且它们将在本地被调用：
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we will make changes to the `thrust()` and `turn()` methods. The whole
    idea is that they will receive the delta as an argument now. The `turn()` doesn’t
    need to receive a direction argument anymore, since the direction became a `member`
    variable:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将对 `thrust()` 和 `turn()` 方法进行修改。整个思路是它们现在将接收 delta 作为参数。`turn()` 方法不再需要接收方向参数，因为方向已经成为了一个
    `member` 变量：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we will use the `_physics_process()` callback to call the `thrust()`
    and `turn()` methods, based on the thrusting and turning variable states:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用 `_physics_process()` 回调根据推力和转向变量的状态调用 `thrust()` 和 `turn()` 方法：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With that, we have everything we need to keep the movement as it was, but now
    the server is responsible for responding to the player’s input instead of being
    passive to how the `Spaceship` node behaved in the player’s game instance. This
    is important, due to how lag and latency compensation works, as we need an instance
    of the game to always fall back to if we need to update some data that may have
    been lost on the network. On top of that, some techniques involve the server side
    ultimately handling discrepancies. There’s an excellent video on *YouTube* called
    *How to reduce Lag - A Tutorial on Lag Compensation Techniques for Online Games*
    that explains the role of each side of the connection in lag compensation techniques.
    This video is available at this link and is highly recommended: [https://www.youtube.com/watch?v=2kIgbvl7FRs](https://www.youtube.com/watch?v=2kIgbvl7FRs).'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，我们就有了所有需要保持运动不变的东西，但现在服务器负责响应玩家的输入，而不是被动地对待玩家游戏实例中的 `Spaceship` 节点的行为。这很重要，因为延迟和延迟补偿的工作方式，我们需要一个游戏实例始终作为后备，以防我们需要更新可能已在网络上丢失的一些数据。此外，一些技术涉及服务器端最终处理差异。YouTube
    上有一个名为 *How to reduce Lag - A Tutorial on Lag Compensation Techniques for Online
    Games* 的优秀视频，解释了连接每一方在延迟补偿技术中的作用。这个视频可以通过此链接访问，并且强烈推荐：[https://www.youtube.com/watch?v=2kIgbvl7FRs](https://www.youtube.com/watch?v=2kIgbvl7FRs)。
- en: Now that we have this in place, we can start to implement the actual techniques
    that will help us deal with this issue. In the next section, we will set up our
    fake lag mechanisms, which are basically `twoTimers`, and see how we can use the
    `Tween` node to implement *interpolation* in our game so that we can create a
    fluid motion, based on the sparse `Spaceship` node position and rotation updates.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了，我们可以开始实现实际的技术，这些技术将帮助我们处理这个问题。在下一节中，我们将设置我们的模拟延迟机制，这基本上是 `twoTimers`，并看看我们如何使用
    `Tween` 节点在我们的游戏中实现 *插值*，以便我们可以创建基于稀疏的 `Spaceship` 节点位置和旋转更新的流畅运动。
- en: Bridging the gaps with interpolation
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过插值弥合差距
- en: '**Interpolation** is the art of filling in the gaps between received data points.
    When data packets arrive at irregular intervals due to network latency or packet
    loss, interpolation ensures that the movement of characters, objects, and projectiles
    appears smooth and continuous. Imagine it as the magic glue that binds fragmented
    data, allowing players to witness uninterrupted, fluid motion.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**插值**是填补接收到的数据点之间空隙的艺术。当数据包由于网络延迟或数据包丢失而以不规则的时间间隔到达时，插值确保角色、对象和弹头的移动看起来平滑且连续。想象一下，它就像粘合碎片数据的魔法胶水，允许玩家见证不间断、流畅的运动。'
- en: In this section, we will see how we can use the `Tween` class to interpolate
    the sparse data we will receive from players. `Tween` is a specialized class that
    is used to interpolate values in Godot Engine. We will also use the lerping methods,
    `lerp()` and `lerp_angle()`, to find the correct values to use in the interpolation,
    especially for `Spaceship`’s rotation angles.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何使用`Tween`类来插值我们从玩家那里接收到的稀疏数据。`Tween`是一个专门用于在Godot引擎中插值值的类。我们还将使用lerping方法，`lerp()`和`lerp_angle()`，来找到用于插值的正确值，特别是对于`Spaceship`的旋转角度。
- en: 'To fake some latency, we will use `Timer` nodes so that we can see how our
    interpolation will work in different scenarios. However, ideally, you would use
    `ENetPacketPeer.get_statistic()` method passing `ENetPacketPeer.PEER_ROUND_TRIP_TIME`
    as argument to get access to the actual network latency. We can access the `ENetPacketPeer`
    instance referring to the server’s peer connection using `multiplayer.multiplayer_peer.get_peer(1)`in
    order to call the `get_statistic()` method on it. So, to access a player’s latency
    to a server, we can use the following code snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟一些延迟，我们将使用`Timer`节点，这样我们就可以看到我们的插值在不同场景下的工作情况。然而，理想情况下，你会使用`ENetPacketPeer.get_statistic()`方法，传递`ENetPacketPeer.PEER_ROUND_TRIP_TIME`作为参数来获取对实际网络延迟的访问权限。我们可以通过使用`multiplayer.multiplayer_peer.get_peer(1)`来引用服务器的peer连接，从而在它上面调用`get_statistic()`方法。因此，要访问玩家的延迟到服务器，我们可以使用以下代码片段：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That being said, we are going to make some changes to the `Player` scene and
    script so that we can implement the interpolation logic and understand how to
    use this technique. Open the `res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn`
    scene and follow the following steps to implement our interpolation logic:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们将对`Player`场景和脚本进行一些修改，以便我们可以实现插值逻辑并了解如何使用这项技术。打开`res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn`场景，并按照以下步骤实现我们的插值逻辑：
- en: Since we are not syncing the `Spaceship` node’s position and rotation properties
    using the `MultiplayerSynchronizer` node anymore, we are going to add `Timer`
    node to simulate some latency. So, add a new `Timer` node to the scene, and name
    it `InterpolationTimer`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们不再使用`MultiplayerSynchronizer`节点来同步`Spaceship`节点的位置和旋转属性，我们将添加`Timer`节点来模拟一些延迟。因此，向场景中添加一个新的`Timer`节点，并将其命名为`InterpolationTimer`。
- en: '![Figure 12.2 – Player’s scene node hierarchy with the newly added InterpolationTimer](img/Figure_12.02_B18527.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 带有新添加的InterpolationTimer的玩家场景节点层次结构](img/Figure_12.02_B18527.jpg)'
- en: Figure 12.2 – Player’s scene node hierarchy with the newly added InterpolationTimer
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 带有新添加的InterpolationTimer的玩家场景节点层次结构
- en: Then, let’s set `0.1`. In this context, `0.1` wait time would be as high as
    a 100 ms latency, which is already high enough for players to start noticing some
    jittering and noticeable delays in their interactions.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们设置`0.1`。在这个上下文中，`0.1`的等待时间相当于100毫秒的延迟，这已经足够高，以至于玩家开始注意到一些抖动和明显的交互延迟。
- en: '![Figure 12.3 – The InterpolationTimer node settings](img/Figure_12.03_B18527.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – InterpolationTimer节点设置](img/Figure_12.03_B18527.jpg)'
- en: Figure 12.3 – The InterpolationTimer node settings
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – InterpolationTimer节点设置
- en: 'With that, our next step is to connect the `timeout` signal to the `Player`
    node’s script; we can create a callback method called `_on_interpolation_timer_timeout()`,
    like so:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个，我们的下一步是将`timeout`信号连接到`Player`节点的脚本；我们可以创建一个名为`_on_interpolation_timer_timeout()`的回调方法，如下所示：
- en: '![Figure 12.4 – The InterpolationTimer timeout signal connection](img/Figure_12.04_B18527.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – InterpolationTimer超时信号连接](img/Figure_12.04_B18527.jpg)'
- en: Figure 12.4 – The InterpolationTimer timeout signal connection
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – InterpolationTimer超时信号连接
- en: 'Then, let’s move on to the `res://09.prototyping-space-nadventure/Actors/Player/Player2D.gd`
    script. Here, we will create two new variables to store the previously known `Spaceship`
    node’s position and rotation. This will be necessary to interpolate from the previous
    to the newest values moving forward:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们继续到 `res://09.prototyping-space-nadventure/Actors/Player/Player2D.gd`
    脚本。在这里，我们将创建两个新的变量来存储之前已知的 `Spaceship` 节点的位置和旋转。这将是在向前移动到最新值时进行插值所必需的：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, in the `_on_interpolation_timer_timeout()` callback, we will make two
    RPC calls. One to the the `"interpolate_position"`method and the other to the
    `"interpolate_rotation"` method. These methods will ask for two arguments – the
    target property (for example, position or rotation), and the duration of the interpolation.
    In this case, we will use the `InterpolationTimer.wait_time` property as the duration,
    since this is the time interval between network updates in this context. We will
    set up these methods in the following steps:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `_on_interpolation_timer_timeout()` 回调中，我们将进行两次 RPC 调用。一个是调用 `"interpolate_position"`
    方法，另一个是调用 `"interpolate_rotation"` 方法。这些方法将请求两个参数——目标属性（例如，位置或旋转）和插值的持续时间。在这种情况下，我们将使用
    `InterpolationTimer.wait_time` 属性作为持续时间，因为这是在此上下文中网络更新的时间间隔。我们将在以下步骤中设置这些方法：
- en: '[PRE10]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let’s declare these methods, starting with `interpolate_position()`. Only
    the server should be able to call these methods remotely because it’s the server
    that will update these properties, so their `@rpc` annotation should use `"authority"`
    and `"call_remote"` as options:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们声明这些方法，从 `interpolate_position()` 开始。只有服务器应该能够远程调用这些方法，因为服务器将更新这些属性，所以它们的
    `@rpc` 注解应该使用 `"authority"` 和 `"call_remote"` 作为选项：
- en: '[PRE11]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside the `interpolate_position()` method, the first thing we will do is create
    a new `Tween` instance and store it in a variable, using the `create_tween()`
    method:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `interpolate_position()` 方法内部，我们将首先创建一个新的 `Tween` 实例并将其存储在一个变量中，使用 `create_tween()`
    方法：
- en: '[PRE12]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we will use the `lerp()` function to figure out the final value we will
    use in the interpolation. For the `position` property, this is not as useful,
    but it will be in the rotation case. However, let’s do it this way to maintain
    some consistency between these functions:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用 `lerp()` 函数来确定在插值中我们将使用的最终值。对于 `position` 属性，这并不那么有用，但在旋转的情况下将会很有用。然而，让我们这样操作以保持这些函数之间的一致性：
- en: '[PRE13]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since we are playing with a body that will run some physics simulation, it’s
    safer to use the `Tween.TWEEN_PROCESS_PHYSICS` mode in `tween` variable so that
    the interpolation happens during the physics processing. For that, we use the
    `Tween.set_process_mode()` method:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在处理一个将运行一些物理模拟的实体，所以在 `tween` 变量中使用 `Tween.TWEEN_PROCESS_PHYSICS` 模式会更安全，这样插值就会在物理处理期间发生。为此，我们使用
    `Tween.set_process_mode()` 方法：
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we can start the actual interpolation; we will store it into a variable
    called `tweener`, as `Tween.tween_property` returns a `PropertyTween` object that
    we can use when necessary. In this function, we pass four arguments – the object,
    the property that’s going to be interpolated, the target value, and the duration
    of the interpolation in seconds:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以开始实际的插值；我们将将其存储到一个名为 `tweener` 的变量中，因为 `Tween.tween_property` 返回一个 `PropertyTween`
    对象，我们可以在必要时使用它。在这个函数中，我们传递四个参数——对象、将要进行插值的属性、目标值和插值的持续时间（以秒为单位）：
- en: '[PRE15]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To ensure the interpolation will happen from the previous known value and the
    most recent one, we will change `tweener`’s starting value, using the `from()`
    method and passing `previous_position` as an argument:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保插值将从之前已知的值和最新值发生，我们将使用 `from()` 方法更改 `tweener` 的起始值，并传递 `previous_position`
    作为参数：
- en: '[PRE16]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we update `previous_posistion` to match the now-known most current value,
    which is our `final_value`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将更新 `previous_posistion` 以匹配现在已知的最新值，即我们的 `final_value`：
- en: '[PRE17]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As for `interpolate_rotation`, we will do the same thing, but this time, we
    will use the `lerp_angle()` function. This is because interpolating angles is
    a bit trickier, as we would need to know the shortest path between the starting
    and target angles. Using this function with a weight of `1.0` provides the final
    value properly and saves us a lot of time. The whole `interpolate_rotation()`
    method is very similar to the `interpolate_position()` method but, of course,
    passing the `previous_rotation` variable instead of the `previous_position` variable.
    It looks like this:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于`interpolate_rotation`，我们将做同样的事情，但这次我们将使用`lerp_angle()`函数。这是因为插值角度有点复杂，因为我们需要知道起始角度和目标角度之间的最短路径。使用这个函数并以`1.0`的权重提供最终值是正确的，并且为我们节省了很多时间。整个`interpolate_rotation()`方法与`interpolate_position()`方法非常相似，但当然，传递的是`previous_rotation`变量而不是`previous_position`变量。它看起来像这样：
- en: '[PRE18]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we need to start `InterpolationTimer` if the current instance is the connection’s
    server. For that, move to the `setup_multiplayer()` method and add an `else` statement;
    inside it, start the timer. Don’t forget to remove the line that sets up the new
    instance authority, as from now on, the server itself will always be `Player`’s
    authority. The `setup_multiplayer()` method should look like this:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果当前实例是连接的服务器，我们需要开始`InterpolationTimer`。为此，转到`setup_multiplayer()`方法并添加一个`else`语句；在它里面，启动定时器。别忘了删除设置新实例权限的行，因为从现在起，服务器本身将始终是`Player`的权限。`setup_multiplayer()`方法应该看起来像这样：
- en: '[PRE19]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And there we have it – our interpolation logic is ready to smoothly move and
    rotate our `Spaceship` node, just by getting sparse updates from a server. Note
    that since we are faking some latency, we are using a fixed interpolation duration.
    In a more realistic scenario, you’d use the `ENetPacketPeer.PEER_ROUND_TRIP_TIME`
    statistic as a reference for the actual interpolation duration.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样，我们的插值逻辑已经准备好，只需从服务器获取稀疏更新，就可以平滑地移动和旋转我们的`Spaceship`节点。请注意，由于我们在模拟一些延迟，我们使用固定的插值持续时间。在更现实的场景中，你会使用`ENetPacketPeer.PEER_ROUND_TRIP_TIME`统计信息作为实际插值持续时间的参考。
- en: In this section, we saw how we can use the `Timer` node to fake some latency
    and, by using the `Tween` class, interpolate between two known values for the
    `Spaceship` node’s position and rotation. We also saw how to access some statistics
    regarding the connection between two peers, especially regarding the latency between
    clients and a server. However, what happens when we need to keep some consistency
    in movement while we don’t get updates from the server? This is what we will discuss
    in the next section!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何使用`Timer`节点来模拟一些延迟，并通过使用`Tween`类，在`Spaceship`节点的位置和旋转之间进行插值。我们还看到了如何访问有关两个对等体之间连接的一些统计信息，特别是关于客户端和服务器之间的延迟。然而，当我们需要保持运动的一致性而服务器没有更新时会发生什么？这就是下一节我们将要讨论的内容！
- en: Playing ahead with prediction
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提前预测
- en: '**Prediction**, different from interpolation, is all about playing ahead of
    the game – quite literally. It involves making informed guesses about an object’s
    future position based on its past behavior. When network delays cause data updates
    to lag, prediction steps in, ensuring that your character’s actions remain responsive
    and instantaneous, even in the face of network hiccups.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**预测**，与插值不同，完全是关于提前进入游戏——字面上的。它涉及到根据对象过去的行为做出关于其未来位置的有根据的猜测。当网络延迟导致数据更新滞后时，预测介入，确保你的角色动作保持响应和即时，即使在网络波动的情况下。'
- en: To implement prediction, we are going to use some Newtonian physics to calculate
    the `Spaceship` node’s velocity and project, based on this calculation, where
    it will likely be in the next tic, and use it to extrapolate its position and
    rotation moving forward. This will help us prevent the `Spaceship` node from idling.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现预测，我们将使用一些牛顿物理学来计算`Spaceship`节点的速度，并根据这个计算预测它下一个tick可能的位置，并使用它来外推其位置和旋转。这将帮助我们防止`Spaceship`节点空闲。
- en: 'A core aspect of prediction and extrapolation is that they aim to fix some
    drawbacks of the interpolation. For instance, from time to time, we need to re-sync
    the actual `Spaceship` node’s position because, otherwise, due to the interpolation
    duration and potential latency involved, the `Spaceship` node will always be lagged
    behind, and this can accumulate to a point where the game isn’t played in real
    time anymore. Also, we will use this synchronization time as a reference for the
    predictions. So, open the `res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn`
    scene, and let’s start implementing the necessary steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 预测和外推的一个核心方面是它们旨在弥补插值的一些缺点。例如，有时我们需要重新同步实际 `Spaceship` 节点的位置，否则，由于插值持续时间和潜在的延迟，`Spaceship`
    节点将始终落后，这可能会积累到游戏不再是实时进行的地步。此外，我们还将使用这个同步时间作为预测的参考。因此，打开 `res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn`
    场景，让我们开始实现必要的步骤：
- en: First of all, let’s add a new `Timer` node, and name it `SynchronizationTimer`.
    This one needs to be at a pace greater than `InterpolationTimer`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们添加一个新的 `Timer` 节点，并将其命名为 `SynchronizationTimer`。这个节点的速度需要大于 `InterpolationTimer`。
- en: '![Figure 12.5 – Player’s scene hierarchy with the SynchronizationTimer node](img/Figure_12.05_B18527.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 带有同步定时器节点的玩家场景层次结构](img/Figure_12.05_B18527.jpg)'
- en: Figure 12.5 – Player’s scene hierarchy with the SynchronizationTimer node
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 带有同步定时器节点的玩家场景层次结构
- en: Then, we will connect `SynchronizationTimer` node’s `timeout` signal to the
    `Player` node’s script in a callback, which we can name `_on_synchronization_timer_timeout()`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将 `SynchronizationTimer` 节点的 `timeout` 信号连接到 `Player` 节点的脚本中的回调，我们可以将其命名为
    `_on_synchronization_timer_timeout()`。
- en: '![Figure 12.6 – The SynchronizationTimer timeout signal connecting to Player’s
    _on_synchronization_timer_timeout() method](img/Figure_12.06_B18527.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 连接到玩家 `_on_synchronization_timer_timeout()` 方法的同步定时器超时信号](img/Figure_12.06_B18527.jpg)'
- en: Figure 12.6 – The SynchronizationTimer timeout signal connecting to Player’s
    _on_synchronization_timer_timeout() method
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 连接到玩家 `_on_synchronization_timer_timeout()` 方法的同步定时器超时信号
- en: 'Then, let’s open the `res://09.prototyping-space-` `adventure/Actors/Player/Player2D.gd`
    script, and in the `setup_multiplayer()` method, we will also start `SynchronizationTimer`
    if this instance is the server:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们打开 `res://09.prototyping-space-adventure/Actors/Player/Player2D.gd` 脚本，并在
    `setup_multiplayer()` 方法中，如果这个实例是服务器，我们也将启动 `SynchronizationTimer`：
- en: '[PRE20]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, in the `_on_synchronization_timer_timeout()` callback, we will make two
    *RPC*s – one to a method called `synchronize_position()` and another to a method
    called `synchronize_rotation()`. We will implement these methods shortly, but
    for now, just know they ask for a target position and rotation, respectively,
    and a synchronization tic. For the synchronization tic, we will use the `SynchronizationTimer`
    node’s `wait_time` property as reference:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `_on_synchronization_timer_timeout()` 回调中，我们将执行两个 *RPC* – 一个是调用 `synchronize_position()`
    方法的，另一个是调用 `synchronize_rotation()` 方法的。我们将很快实现这些方法，但到目前为止，只需知道它们分别请求目标位置和旋转，以及一个同步节拍。对于同步节拍，我们将使用
    `SynchronizationTimer` 节点的 `wait_time` 属性作为参考：
- en: '[PRE21]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let’s start by implementing the `synchronize_position()` method. Only
    the `Spaceship` node, it should only call remotely:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们首先实现 `synchronize_position()` 方法。只有 `Spaceship` 节点，它应该只远程调用：
- en: '[PRE22]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Inside this method, we will stop all currently processing `Tween` instances;
    note that this approach works in our game because we only have the `interpolate_*()`
    methods creating `Tween` instances. If you have other `Tween` instances running
    in your game, I recommend storing them in an array and running through them to
    stop the active ones. We do that to stop the interpolation from continuing as
    we will set the `Spaceship` node’s final position manually:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法内部，我们将停止所有当前正在处理的 `Tween` 实例；请注意，这种方法在我们的游戏中有效，因为我们只有 `interpolate_*()`
    方法创建 `Tween` 实例。如果你在游戏中还有其他正在运行的 `Tween` 实例，我建议将它们存储在一个数组中，并遍历它们以停止活动的实例。我们这样做是为了停止插值继续，因为我们将会手动设置
    `Spaceship` 节点的最终位置：
- en: '[PRE23]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we will create a variable to store the future position, based on a prediction
    we will make, taking the previous and the new positions we just received. We will
    work on the prediction method later, but for now, just know that it will ask for
    a new position and how many seconds ahead you want to predict. We will use this
    prediction to extrapolate movement when we implement extrapolation in the *Gazing
    into the future with* *extrapolation* section:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个变量来存储基于我们即将做出的预测的未来位置，这个预测将基于我们刚刚收到的先前和新的位置。我们将在稍后处理预测方法，但现在，只需知道它将要求一个新位置以及你想要预测多少秒。我们将使用这个预测来在实现
    *用外推法展望未来* 部分时外推运动：
- en: '[PRE24]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that, we can set the `Spaceship` node’s position to the new position
    and update `previous_position` to match the most recent value, so in the next
    tic, it maintains a reference to the previously updated value:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以将 `Spaceship` 节点的位置设置为新位置，并更新 `previous_position` 以匹配最新的值，这样在下一次滴答时，它就能保持对先前更新值的引用：
- en: '[PRE25]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As for the `predict_position()` method, it will happen locally on the client’s
    machine, so there’s no need to make an RPC here. Let’s declare the function’s
    signature and see how we can predict the future with some physics:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至于 `predict_position()` 方法，它将在客户端的本地发生，因此这里不需要进行 RPC。让我们声明函数的签名，看看我们如何通过一些物理知识来预测未来：
- en: '[PRE26]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Inside the `predict_position()` method, we will calculate the distance from
    the previous position to the new one. We will also calculate the direction from
    the previous position to the new position so that we have `Vector2` to work with,
    predicting the movement’s velocity:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `predict_position()` 方法内部，我们将计算从先前位置到新位置的距离。我们还将计算从先前位置到新位置的方向，这样我们就有 `Vector2`
    来工作，预测运动的速度：
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With that, we will calculate the movement’s linear velocity, based on how many
    seconds ahead we want to predict. We will then set this linear velocity as the
    `Spaceship`.`linear_velocity` property so that we it doesn’t idle between updates,
    asthe `Spaceship` node will start moving using this new velocity:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个，我们将根据我们想要预测多少秒来计算运动的线性速度。然后我们将这个线性速度设置为 `Spaceship`.`linear_velocity` 属性，这样它就不会在更新之间闲置，因为
    `Spaceship` 节点将开始使用这个新速度移动：
- en: '[PRE28]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we will add the linear velocity to the new position to predict what
    will be the next position. We will then return this new position so that we can
    use this value when we decide to extrapolate the `Spaceship` node’s movement:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将线性速度加到新位置上，以预测下一个位置将会是什么。然后我们将返回这个新位置，这样我们就可以在我们决定外推 `Spaceship` 节点的运动时使用这个值：
- en: '[PRE29]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The logic to predict the rotation will be exactly the same, but take into account
    that we will use the `learp_angle()` built-in method to figure out the closest
    angle to extrapolate to. The `synchronize_rotation()` method will look like this:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预测旋转的逻辑将完全相同，但请注意，我们将使用 `lerp_angle()` 内置方法来确定外推的最接近角度。`synchronize_rotation()`
    方法将看起来像这样：
- en: '[PRE30]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `predict_rotation()` method will look like this:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`predict_rotation()` 方法将看起来像这样：'
- en: '[PRE31]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With that, we can start to make assumptions of where the `Spaceship` node is
    likely to be in the near future, based on `SynchronizationTimer` node’s tics.
    However, note that this is a very important available function on the server side,
    as sometimes, we may want to use it to mitigate lag in *Player* interactions and
    trigger the right game events. For instance, if we decide to have some **player
    versus player** (**PvP**) interactions, we may need to predict where a given player’s
    *Spaceship* was when another player fired their gun. This is because, due to latency,
    the player may have made a guessed shot and landed a hit. However, it is up to
    the server to decide whether the shot would actually land, given the latency and
    other aspects.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有了这个方法，我们可以开始基于 `SynchronizationTimer` 节点的滴答声，对 `Spaceship` 节点在不久的将来可能的位置做出假设。然而，请注意，这是服务器端一个非常重要的可用功能，因为有时我们可能想用它来减轻
    *Player* 交互中的延迟并触发正确的游戏事件。例如，如果我们决定有一些 **玩家对玩家** （**PvP**） 交互，我们可能需要预测当另一个玩家开枪时，给定玩家的
    *Spaceship* 在哪里。这是因为，由于延迟，玩家可能已经做出猜测并击中目标。然而，是否击中实际上取决于服务器，考虑到延迟和其他方面。
- en: In this section, we have seen two important techniques to handle lag and latency
    in online multiplayer games – prediction and synchronization. Prediction involves
    making informed guesses about an object’s future position and rotation, based
    on its past behavior. To implement prediction, Newtonian physics calculations
    are used to calculate the `Spaceship` node’s velocity and project its likely future
    position and rotation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了处理在线多人游戏中滞后和延迟的两个重要技术——预测和同步。预测涉及根据物体的过去行为做出关于其未来位置和旋转的有根据的猜测。为了实现预测，使用牛顿物理学计算来计算
    `Spaceship` 节点的速度，并预测其可能的位置和旋转。
- en: We also saw how to implement the synchronization process, by stopping ongoing
    `Tween` instances and updating the `Spaceship` node’s position and rotation accordingly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何通过停止正在进行的 `Tween` 实例并相应地更新 `Spaceship` 节点的位置和旋转来实现同步过程。
- en: In the next section, we will use the predicted position and rotation to extrapolate
    `Spaceship` node’s movement, both linear and angular, so that if we happen to
    miss updates, we can at least fake a movement and fix it in the synchronization
    later if necessary.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用预测的位置和旋转来外推 `Spaceship` 节点的移动，包括线性移动和角移动，这样如果我们错过了更新，我们至少可以模拟一个移动，并在必要时在同步中修复它。
- en: Gazing into the future with extrapolation
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过外推展望未来
- en: Extrapolation is the visionary member of the lag compensation trio, gazing into
    the future to anticipate where objects will be next. By analyzing the current
    state of a game and the trajectory of objects, extrapolation extends beyond the
    data you have, offering a glimpse into what lies ahead. This technique is particularly
    handy for fast-paced games, where a split-second delay can mean the difference
    between victory and defeat.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 外推是滞后补偿三剑客中的先知，展望未来以预测物体将出现在哪里。通过分析游戏当前状态和物体的轨迹，外推超越了现有数据，提供对未来的洞察。这种技术在快节奏的游戏中特别有用，因为一秒钟的延迟可能意味着胜利和失败的区别。
- en: 'The whole idea of extrapolation is that it is an interpolation into the future.
    Using the predictions we’ve made, we can create another interpolation, based on
    some assumptions of where a player is likely to be while we wait for its actual
    position. This will prevent hiccups and idling between updates. Let’s implement
    our extrapolation algorithm. Open the `res://09.prototyping-space- adventure/Actors/Player/Player2D.gd`
    script, and follow the following steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 外推的整体想法是它是对未来的插值。使用我们做出的预测，我们可以创建另一个基于一些假设的插值，即在我们等待其实际位置时玩家可能的位置。这将防止更新之间的中断和闲置。让我们实现我们的外推算法。打开
    `res://09.prototyping-space-adventure/Actors/Player/Player2D.gd` 脚本，并按照以下步骤进行：
- en: 'Starting with the function’s signature, the `extrapolation_position()` method
    will ask for the next position and duration in seconds that the extrapolation
    lasts for. Here, we will use terms similar to the ones in prediction, such as
    `seconds_ahead`, as we will work with future timing:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从函数签名开始，`extrapolation_position()` 方法将请求下一个位置和持续时间的秒数，即外推持续的时间。在这里，我们将使用与预测中类似的术语，例如
    `seconds_ahead`，因为我们将会处理未来的时间：
- en: '[PRE32]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This function only happens on the client side, so there’s no need to add any
    RPC annotations to it. Inside this function, we will use a new `Tween` instance
    to interpolate from the previous known position to the predicted next position,
    using `seconds_ahead` variable as the duration:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数仅在客户端发生，因此不需要向其添加任何 RPC 注解。在这个函数内部，我们将使用一个新的 `Tween` 实例，从先前已知的位置到预测的下一个位置进行插值，使用
    `seconds_ahead` 变量作为持续时间：
- en: '[PRE33]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And that’s basically it. We will call the `extrapolate_position()` method inside
    the `synchronize_position()` method right before updating the current and previous
    positions. Also, we will use the `future_position` variable, which stores the
    predicted position as an argument for the extrapolated next position:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这基本上就是全部内容。我们将在更新当前和先前位置之前，在 `synchronize_position()` 方法中调用 `extrapolate_position()`
    方法。此外，我们将使用 `future_position` 变量，它存储预测的位置，作为外推下一个位置的参数：
- en: '[PRE34]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We do the same thing for the `extrapolate_rotation()` method. It should look
    like this:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对 `extrapolate_rotation()` 方法也做同样的事情。它应该看起来像这样：
- en: '[PRE35]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `synchronize_rotation()` method should look like this after adding the
    line to call the `extrapolate_rotation()` method, using the `future_rotation`
    variable as an argument:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加调用 `extrapolate_rotation()` 方法的行之后，`synchronize_rotation()` 方法应该看起来像这样，使用
    `future_rotation` 变量作为参数：
- en: '[PRE36]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this section, you learned about the concept of extrapolation in the context
    of online multiplayer game development. Extrapolation is a technique that looks
    into the future to anticipate where objects will be next. By analyzing the current
    state of a game and the trajectory of objects, extrapolation extends beyond the
    available data, providing a glimpse into what lies ahead. It is particularly useful
    in fast-paced games where a split-second delay can significantly impact gameplay.
    The implementation of extrapolation involves interpolating from the previous known
    position and rotation to the predicted next position and rotation, using `Tween`
    instances, with the duration set to the desired time into the future.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了在线多人游戏开发中外推的概念。外推是一种展望未来以预测物体下一步位置的技巧。通过分析游戏当前状态和物体的轨迹，外推超越了现有数据，为未来可能发生的情况提供了一瞥。这在节奏快速的游戏中尤其有用，因为一秒钟的延迟可能会显著影响游戏体验。外推的实现涉及从先前的已知位置和旋转到预测的下一个位置和旋转的插值，使用`Tween`实例，持续时间设置为未来期望的时间。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the issues caused by lag, latency, and packet
    loss. Then, we saw how to fix them by implementing lag compensation techniques.
    We explored the concepts of interpolation, prediction, synchronization, and extrapolation
    to ensure smooth and responsive gameplay, even in the face of network delays.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了由滞后、延迟和丢包引起的问题。然后，我们看到了如何通过实现滞后补偿技术来解决这个问题。我们探讨了插值、预测、同步和外推的概念，以确保即使在面对网络延迟的情况下，游戏也能保持平滑和响应。
- en: First, we delved into interpolation, which is the core technique regarding lag
    compensation. Interpolation helps to fix some drawbacks of latency and sparse
    data updates by animating between two known values, while actual updates don’t
    arrive. This ensures that the `Spaceship` node won’t idling, waiting for new updates
    from the network. It will smoothly move toward new data, instead of abruptly teleporting
    to it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们深入探讨了插值，这是关于滞后补偿的核心技术。插值通过在两个已知值之间进行动画，帮助解决延迟和稀疏数据更新的某些缺点，而实际更新尚未到达。这确保了`Spaceship`节点不会闲置，等待来自网络的新的更新。它将平滑地移动到新数据，而不是突然传送到它那里。
- en: Then, we discussed prediction, which involves making informed guesses about
    an object’s future position, based on its past behavior. By using Newtonian physics
    calculations, we were able to calculate the spaceship’s velocity and project its
    likely future position and rotation. This helps prevent idle movements and keeps
    gameplay responsive.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了预测，它涉及根据物体的过去行为做出关于其未来位置的明智猜测。通过使用牛顿物理学计算，我们能够计算出宇宙飞船的速度并预测其可能的位置和旋转。这有助于防止闲置动作并保持游戏响应。
- en: We then explored extrapolation, which extends beyond available data to anticipate
    where objects will be next. By interpolating from the previous known position
    and rotation to the predicted next position and rotation, we were able to create
    smooth movements, even when updates were missed. This technique is particularly
    useful in fast-paced games where split-second delays can significantly impact
    gameplay.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了外推，它超越了现有数据以预测物体的下一步位置。通过从先前的已知位置和旋转到预测的下一个位置和旋转进行插值，我们能够创建平滑的运动，即使错过了更新。这种技术在节奏快速的游戏中特别有用，因为瞬间的延迟可能会显著影响游戏体验。
- en: By implementing these lag compensation techniques, we can provide players with
    a seamless and immersive multiplayer gaming experience, even in the presence of
    network hiccups and delays.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现这些滞后补偿技术，我们可以在网络出现故障和延迟的情况下，为玩家提供无缝和沉浸式的多人游戏体验。
- en: In the next chapter, we will see how we can store some data on a client’s machine
    to reduce the bandwidth used in our game, relying on data that the players already
    have available on their machines.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何将一些数据存储在客户端机器上，以减少我们游戏中使用的带宽，依赖于玩家已经在他们的机器上可用的数据。
