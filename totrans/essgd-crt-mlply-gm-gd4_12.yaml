- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Lag Compensation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to one of the most anticipated chapters in the book. Here, we will dive
    into the core of online multiplayer game optimization. In the world of online
    gaming, where players from across the globe unite to embark on epic adventures,
    two formidable adversaries lurk in the shadows; they are **lag** and **latency**.
    These foes can transform a thrilling gaming experience into a frustrating trial.
    In this chapter, we’ll confront these challenges head-on, arming you with the
    knowledge and tools to mitigate their impact and create an engaging online gaming
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use `Player` node’s`Spaceship` node maintain its position
    and rotation, synced throughout the game instances across the network. For that,
    we will understand the core issues regarding packet loss and latency, something
    common when we use unreliable packets, as we do when using the ENet protocols.
    Then, we will fake some latency and packet loss by using `Timer` nodes so that
    we can understand how these issues may display in the actual game. After that,
    we will talk about some common techniques to create solutions for these issues.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will understand how we can fake some smooth movement,
    even when the game’s `MultiplayerSynchronizer` fails to deliver data across peers’
    game instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing lag issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with unreliable packets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common compensation techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in [*Chapter 10*](B18527_10.xhtml#_idTextAnchor260), *Debugging
    and Profiling the Network*, *Part 3*, *Optimizing the Online Experience*, of this
    book focuses on the final version of the project made in *Chapter 9*, *Creating
    an Online Adventure Prototype*, so it’s fundamental to read, exercise, and implement
    the concepts presented there. You can get the files necessary to start this chapter
    at the following link: [https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation).
    They contain the progress we’ve made for optimizations in [*Chapter 11*](B18527_11.xhtml#_idTextAnchor276),
    *Optimizing* *Data Requests*.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s also necessary that you have read and understood the concepts and tools
    presented in [*Chapter 11*](B18527_11.xhtml#_idTextAnchor276), *Optimizing Data
    Requests*, so that we can continue with the assumption that you already know what
    they are and how to use them properly.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing lag issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Addressing lag and unreliable packets involves three techniques – **interpolation**,
    **prediction**, and **extrapolation**. These techniques smoothen player movements,
    maintain responsiveness, and anticipate object movements. The Godot Engine’s physics
    simulation and RPC method are crucial in these techniques, aiding in realistic
    object movement and data synchronization, despite network issues.
  prefs: []
  type: TYPE_NORMAL
- en: Lag and latency are the archenemies of any online multiplayer game. Lag, often
    used interchangeably with latency, refers to the delay between a player’s action
    and its corresponding effect in the game. It’s the momentary pause between pulling
    the trigger and seeing the enemy fall. Latency, on the other hand, represents
    the time it takes for data to travel from a player’s device to the game server
    and back. Together, these factors can disrupt the fluidity of gameplay, leaving
    players frustrated and disconnected from the virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: Within the world of online multiplayer gaming, the transmission of data is seldom
    a seamless journey. Unreliable packets, those mischievous bits of information,
    can create issues by arriving out of order or disappearing altogether. When packets
    are out of order, a player might see an opponent magically teleport across the
    map and back or perform impossible feats. Data loss results in vital game updates
    never reaching their intended destination, leaving characters and objects frozen
    in time. Our mission in this chapter is to combat these issues and bring order
    to the chaos.
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of online multiplayer gaming, a recurring and often frustrating
    issue that plagues both developers and players alike is the challenge of lag and
    latency. In this section, we’ll talk about these two fundamental aspects of online
    gaming and shed light on the profound impact they have on a player’s experience.
    As you already discovered in previous chapters, creating a seamless and immersive
    multiplayer environment requires a nuanced understanding of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s talk about the impact of lag and latency on gameplay. When a player
    experiences lag, it disrupts the flow of the game and can lead to missed opportunities,
    frustration, and, in competitive scenarios, unfavorable outcomes. Imagine firing
    a weapon in an online shooter, only to have the shot register seconds later, long
    after your target has moved to safety.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the causes of lag and latency is crucial for effective mitigation.
    Network congestion, hardware limitations, and geographic distance between players
    and servers are common causes. **Network congestion** occurs when the data traffic
    on a network is too high, causing data packets to be delayed or lost. Hardware
    limitations, such as a slow internet connection or an underpowered computer, can
    also contribute to latency.
  prefs: []
  type: TYPE_NORMAL
- en: Mitigating lag and latency is a constant challenge for game developers. One
    strategy is server optimization, where game servers are finely tuned to handle
    large volumes of data efficiently. Another approach is client-side prediction
    and interpolation, techniques that help to smooth out gameplay even when there
    are network delays; we will talk about these in the *Common compensation techniques*
    section. On top of these, choosing the right network infrastructure, such as **Content
    Delivery Networks** (**CDNs**), can significantly reduce latency by placing game
    assets closer to players.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve peeled back the layers of lag and latency, understanding how these factors
    impact online multiplayer games. We saw some of their causes and discussed strategies
    for mitigation, all with the goal of enhancing a player’s gaming experience. In
    the next section, we will talk about issues specific to unreliable packets, which
    are what we usually use to transfer data over a network in online multiplayer
    games.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with unreliable packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the top concerns that developers grapple with when creating online multiplayer
    games is the reliability of data packets. In this section, we’ll see the complexities
    surrounding unreliable packets, shedding light on the issues they bring to the
    forefront of online multiplayer games. As you’ve already gleaned from our discussions,
    understanding these challenges is core to crafting a smooth and immersive multiplayer
    gaming experience.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unreliable packets**, as the name suggests, are data packets sent over a
    network without any guarantee of arrival or order. They’re like letters in the
    wind, reaching their destination only if the conditions are favorable. These packets
    are used to transmit non-critical data in online games, such as character positions,
    because they offer lower latency compared to reliable packets, which come with
    built-in delivery assurances at the expense of potential lag.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary issues associated with unreliable packets is packet loss.
    This occurs when packets sent from one player’s device fail to reach a server
    or another player’s device. It’s like pieces of a puzzle disappearing into thin
    air, leading to incomplete and inconsistent data. In a fast-paced action game,
    packet loss can manifest as abrupt character teleportations, vanished projectiles,
    or inexplicable desynchronization among players.
  prefs: []
  type: TYPE_NORMAL
- en: Another challenge is the out-of-order arrival of packets. In an ideal world,
    data packets would arrive at their destination in the same order they were sent.
    However, the unpredictability of network routes can cause packets to arrive out
    of order, leading to chaos in the game world. Imagine receiving instructions to
    assemble a piece of furniture, only to receive the steps out of sequence; it’s
    a recipe for confusion and frustration. Usually, in these cases, we only use the
    latest data and ignore the older ones, as only the most recent information is
    relevant to the game.
  prefs: []
  type: TYPE_NORMAL
- en: The consequences of unreliable packets can be dire for gameplay. Packet loss
    and out-of-order arrivals can lead to player disconnection, incorrect character
    positions, and erratic synchronization among players. For example, a player’s
    character might appear to jump from one location to another due to missing packets.
    This not only disrupts immersion but also undermines the fairness and integrity
    of competitive play.
  prefs: []
  type: TYPE_NORMAL
- en: Mitigating the issues brought on by unreliable packets requires a multifaceted
    approach. Developers often employ techniques such as client-side prediction, where
    the client makes informed guesses about missing data to maintain a coherent game
    state. Interpolation, another valuable tool, smooths out the jitters caused by
    missing packets by smoothly transitioning between known data points.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw that packet loss is a common issue where packets fail
    to reach their destination, leading to incomplete and inconsistent data. We also
    saw that some packets may arrive out of order, causing chaos in the game world.
    These issues can result in player disconnection, incorrect character positions,
    and erratic synchronization among players. In the next section, we are going to
    see the most common compensation techniques to solve these and the lag-related
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Common compensation techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the most anticipated section in our journey through the realm of
    online multiplayer game development. In the previous sections, we unraveled the
    complexities of networking, synchronization, and the intricacies of dealing with
    unreliable packets. Now, we stand at a crucial juncture, ready to explore the
    fascinating world of **interpolation**, **prediction**, and **extrapolation**,
    a trio of techniques that hold the key to creating seamless and responsive online
    gaming experiences, or at least to get as close as we can to this Holy Grail.
  prefs: []
  type: TYPE_NORMAL
- en: Picture this – you’re in the heat of an intense multiplayer battle, and the
    stakes couldn’t be higher. In the world of online gaming, every second counts,
    and every move must be precise. But what happens when network latency rears its
    head, causing a slight delay in transmitting data between players? This is where
    interpolation, prediction, and extrapolation come to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: One of the cornerstones of implementing interpolation, prediction, and extrapolation
    is the integration of physics simulation. In **Godot Engine**, the physics engine
    plays a crucial role in determining how objects move and interact within the game
    world. By marrying physics with prediction algorithms, you can create a realistic
    and responsive gameplay experience that feels in sync with the laws of our virtual
    universe.
  prefs: []
  type: TYPE_NORMAL
- en: To orchestrate the symphony of data synchronization, we’ll take rid of the `Player`
    node’s `MultiplayerSynchronizer` node and employ some *RPC* methods. These functions
    serve as the conductor of our data orchestra, allowing us to send the necessary
    information to clients or a server precisely when it’s needed. With RPCs, we can
    trigger the transmission of interpolated, predicted, or extrapolated data, ensuring
    that all players stay on the same page.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we’ll jump into the implementation of interpolation, prediction,
    and extrapolation in our online multiplayer top-down adventure prototype. By the
    end, you’ll understand how these techniques work together to compensate for network
    latency. So, fasten your seatbelts, for we are about to navigate the intricacies
    of smooth and responsive gameplay in the dynamic world of online multiplayer gaming.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing server-side motion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To have a better setup to understand how lag influences the gameplay experience,
    we are going to make some changes to the `Player` scene and scripts. Instead of
    allowing the movement to happen on the client side and being synced to the server
    and other peers, a player will use input events to change the movement of a server’s
    `Spaceship` instance. This will allow us to also decrease the amount of syncing
    data sent by `MultiplayerSynchronizer`, since now we will have the motion simulated,
    based on `Spaceship`’s thrusting and rotating states. To do that, let’s open the
    `res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn` scene. Then,
    follow the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `MultiplayerSynchronizer` node, and in the `Spaceship`’s position
    and rotation sync on both the **Spawn** and **Sync** options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.1 – The Player scene’s MultiplayerSynchronizer Replication menu,
    with the Spaceship position and rotation properties disabled](img/Figure_12.01_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – The Player scene’s MultiplayerSynchronizer Replication menu, with
    the Spaceship position and rotation properties disabled
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let’s open the `res://09.prototyping-space- adventure/Actors/Player/Player2D.gd`
    file, and we will make some changes to the `setup_multiplayer()` method. The first
    thing to do here is to remove the line that enables the `_physics_process()` and
    `_process()` callbacks, leaving only `_unhandled_input()`. We will see why in
    the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will check whether the current instance isn’t the server; if it isn’t,
    we call the `make_current()` method, effectively enabling this player’s `Camera2D`
    node on their game instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will lay the groundwork the new `Spaceship` node movement logic, get
    rid of the `_physics_process()` callback, and work in the `_unhandled_input()`
    callback instead. The whole logic follows the same idea of `Weapon2D`; `Spaceship`
    will have `thrusting`, `direction`, and `turning` variables that we can use to
    change its movement. Based on the input events we get in `_unhandled_input()`,
    we will change the state of these variables. The secret here is that we will use
    the `rpc_id()` method to change these states on the server’s `Spaceship` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s move on to the `res://09.prototyping-space- adventure/Objects/Spaceship/Spaceship.gd`
    script, where we will implement the variables and methods necessary for the aforementioned
    changes to work. First, let’s declare the properties and their setter methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s declare these methods; here’s the trick – they are *RPCs* that
    any peer can call, and they will be called locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will make changes to the `thrust()` and `turn()` methods. The whole
    idea is that they will receive the delta as an argument now. The `turn()` doesn’t
    need to receive a direction argument anymore, since the direction became a `member`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will use the `_physics_process()` callback to call the `thrust()`
    and `turn()` methods, based on the thrusting and turning variable states:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that, we have everything we need to keep the movement as it was, but now
    the server is responsible for responding to the player’s input instead of being
    passive to how the `Spaceship` node behaved in the player’s game instance. This
    is important, due to how lag and latency compensation works, as we need an instance
    of the game to always fall back to if we need to update some data that may have
    been lost on the network. On top of that, some techniques involve the server side
    ultimately handling discrepancies. There’s an excellent video on *YouTube* called
    *How to reduce Lag - A Tutorial on Lag Compensation Techniques for Online Games*
    that explains the role of each side of the connection in lag compensation techniques.
    This video is available at this link and is highly recommended: [https://www.youtube.com/watch?v=2kIgbvl7FRs](https://www.youtube.com/watch?v=2kIgbvl7FRs).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have this in place, we can start to implement the actual techniques
    that will help us deal with this issue. In the next section, we will set up our
    fake lag mechanisms, which are basically `twoTimers`, and see how we can use the
    `Tween` node to implement *interpolation* in our game so that we can create a
    fluid motion, based on the sparse `Spaceship` node position and rotation updates.
  prefs: []
  type: TYPE_NORMAL
- en: Bridging the gaps with interpolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Interpolation** is the art of filling in the gaps between received data points.
    When data packets arrive at irregular intervals due to network latency or packet
    loss, interpolation ensures that the movement of characters, objects, and projectiles
    appears smooth and continuous. Imagine it as the magic glue that binds fragmented
    data, allowing players to witness uninterrupted, fluid motion.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will see how we can use the `Tween` class to interpolate
    the sparse data we will receive from players. `Tween` is a specialized class that
    is used to interpolate values in Godot Engine. We will also use the lerping methods,
    `lerp()` and `lerp_angle()`, to find the correct values to use in the interpolation,
    especially for `Spaceship`’s rotation angles.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fake some latency, we will use `Timer` nodes so that we can see how our
    interpolation will work in different scenarios. However, ideally, you would use
    `ENetPacketPeer.get_statistic()` method passing `ENetPacketPeer.PEER_ROUND_TRIP_TIME`
    as argument to get access to the actual network latency. We can access the `ENetPacketPeer`
    instance referring to the server’s peer connection using `multiplayer.multiplayer_peer.get_peer(1)`in
    order to call the `get_statistic()` method on it. So, to access a player’s latency
    to a server, we can use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That being said, we are going to make some changes to the `Player` scene and
    script so that we can implement the interpolation logic and understand how to
    use this technique. Open the `res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn`
    scene and follow the following steps to implement our interpolation logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are not syncing the `Spaceship` node’s position and rotation properties
    using the `MultiplayerSynchronizer` node anymore, we are going to add `Timer`
    node to simulate some latency. So, add a new `Timer` node to the scene, and name
    it `InterpolationTimer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Player’s scene node hierarchy with the newly added InterpolationTimer](img/Figure_12.02_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Player’s scene node hierarchy with the newly added InterpolationTimer
  prefs: []
  type: TYPE_NORMAL
- en: Then, let’s set `0.1`. In this context, `0.1` wait time would be as high as
    a 100 ms latency, which is already high enough for players to start noticing some
    jittering and noticeable delays in their interactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.3 – The InterpolationTimer node settings](img/Figure_12.03_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – The InterpolationTimer node settings
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, our next step is to connect the `timeout` signal to the `Player`
    node’s script; we can create a callback method called `_on_interpolation_timer_timeout()`,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4 – The InterpolationTimer timeout signal connection](img/Figure_12.04_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – The InterpolationTimer timeout signal connection
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let’s move on to the `res://09.prototyping-space-nadventure/Actors/Player/Player2D.gd`
    script. Here, we will create two new variables to store the previously known `Spaceship`
    node’s position and rotation. This will be necessary to interpolate from the previous
    to the newest values moving forward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `_on_interpolation_timer_timeout()` callback, we will make two
    RPC calls. One to the the `"interpolate_position"`method and the other to the
    `"interpolate_rotation"` method. These methods will ask for two arguments – the
    target property (for example, position or rotation), and the duration of the interpolation.
    In this case, we will use the `InterpolationTimer.wait_time` property as the duration,
    since this is the time interval between network updates in this context. We will
    set up these methods in the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s declare these methods, starting with `interpolate_position()`. Only
    the server should be able to call these methods remotely because it’s the server
    that will update these properties, so their `@rpc` annotation should use `"authority"`
    and `"call_remote"` as options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `interpolate_position()` method, the first thing we will do is create
    a new `Tween` instance and store it in a variable, using the `create_tween()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will use the `lerp()` function to figure out the final value we will
    use in the interpolation. For the `position` property, this is not as useful,
    but it will be in the rotation case. However, let’s do it this way to maintain
    some consistency between these functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are playing with a body that will run some physics simulation, it’s
    safer to use the `Tween.TWEEN_PROCESS_PHYSICS` mode in `tween` variable so that
    the interpolation happens during the physics processing. For that, we use the
    `Tween.set_process_mode()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can start the actual interpolation; we will store it into a variable
    called `tweener`, as `Tween.tween_property` returns a `PropertyTween` object that
    we can use when necessary. In this function, we pass four arguments – the object,
    the property that’s going to be interpolated, the target value, and the duration
    of the interpolation in seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To ensure the interpolation will happen from the previous known value and the
    most recent one, we will change `tweener`’s starting value, using the `from()`
    method and passing `previous_position` as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we update `previous_posistion` to match the now-known most current value,
    which is our `final_value`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As for `interpolate_rotation`, we will do the same thing, but this time, we
    will use the `lerp_angle()` function. This is because interpolating angles is
    a bit trickier, as we would need to know the shortest path between the starting
    and target angles. Using this function with a weight of `1.0` provides the final
    value properly and saves us a lot of time. The whole `interpolate_rotation()`
    method is very similar to the `interpolate_position()` method but, of course,
    passing the `previous_rotation` variable instead of the `previous_position` variable.
    It looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to start `InterpolationTimer` if the current instance is the connection’s
    server. For that, move to the `setup_multiplayer()` method and add an `else` statement;
    inside it, start the timer. Don’t forget to remove the line that sets up the new
    instance authority, as from now on, the server itself will always be `Player`’s
    authority. The `setup_multiplayer()` method should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And there we have it – our interpolation logic is ready to smoothly move and
    rotate our `Spaceship` node, just by getting sparse updates from a server. Note
    that since we are faking some latency, we are using a fixed interpolation duration.
    In a more realistic scenario, you’d use the `ENetPacketPeer.PEER_ROUND_TRIP_TIME`
    statistic as a reference for the actual interpolation duration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we saw how we can use the `Timer` node to fake some latency
    and, by using the `Tween` class, interpolate between two known values for the
    `Spaceship` node’s position and rotation. We also saw how to access some statistics
    regarding the connection between two peers, especially regarding the latency between
    clients and a server. However, what happens when we need to keep some consistency
    in movement while we don’t get updates from the server? This is what we will discuss
    in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Playing ahead with prediction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Prediction**, different from interpolation, is all about playing ahead of
    the game – quite literally. It involves making informed guesses about an object’s
    future position based on its past behavior. When network delays cause data updates
    to lag, prediction steps in, ensuring that your character’s actions remain responsive
    and instantaneous, even in the face of network hiccups.'
  prefs: []
  type: TYPE_NORMAL
- en: To implement prediction, we are going to use some Newtonian physics to calculate
    the `Spaceship` node’s velocity and project, based on this calculation, where
    it will likely be in the next tic, and use it to extrapolate its position and
    rotation moving forward. This will help us prevent the `Spaceship` node from idling.
  prefs: []
  type: TYPE_NORMAL
- en: 'A core aspect of prediction and extrapolation is that they aim to fix some
    drawbacks of the interpolation. For instance, from time to time, we need to re-sync
    the actual `Spaceship` node’s position because, otherwise, due to the interpolation
    duration and potential latency involved, the `Spaceship` node will always be lagged
    behind, and this can accumulate to a point where the game isn’t played in real
    time anymore. Also, we will use this synchronization time as a reference for the
    predictions. So, open the `res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn`
    scene, and let’s start implementing the necessary steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let’s add a new `Timer` node, and name it `SynchronizationTimer`.
    This one needs to be at a pace greater than `InterpolationTimer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Player’s scene hierarchy with the SynchronizationTimer node](img/Figure_12.05_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Player’s scene hierarchy with the SynchronizationTimer node
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will connect `SynchronizationTimer` node’s `timeout` signal to the
    `Player` node’s script in a callback, which we can name `_on_synchronization_timer_timeout()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – The SynchronizationTimer timeout signal connecting to Player’s
    _on_synchronization_timer_timeout() method](img/Figure_12.06_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – The SynchronizationTimer timeout signal connecting to Player’s
    _on_synchronization_timer_timeout() method
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let’s open the `res://09.prototyping-space-` `adventure/Actors/Player/Player2D.gd`
    script, and in the `setup_multiplayer()` method, we will also start `SynchronizationTimer`
    if this instance is the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `_on_synchronization_timer_timeout()` callback, we will make two
    *RPC*s – one to a method called `synchronize_position()` and another to a method
    called `synchronize_rotation()`. We will implement these methods shortly, but
    for now, just know they ask for a target position and rotation, respectively,
    and a synchronization tic. For the synchronization tic, we will use the `SynchronizationTimer`
    node’s `wait_time` property as reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s start by implementing the `synchronize_position()` method. Only
    the `Spaceship` node, it should only call remotely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this method, we will stop all currently processing `Tween` instances;
    note that this approach works in our game because we only have the `interpolate_*()`
    methods creating `Tween` instances. If you have other `Tween` instances running
    in your game, I recommend storing them in an array and running through them to
    stop the active ones. We do that to stop the interpolation from continuing as
    we will set the `Spaceship` node’s final position manually:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will create a variable to store the future position, based on a prediction
    we will make, taking the previous and the new positions we just received. We will
    work on the prediction method later, but for now, just know that it will ask for
    a new position and how many seconds ahead you want to predict. We will use this
    prediction to extrapolate movement when we implement extrapolation in the *Gazing
    into the future with* *extrapolation* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we can set the `Spaceship` node’s position to the new position
    and update `previous_position` to match the most recent value, so in the next
    tic, it maintains a reference to the previously updated value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As for the `predict_position()` method, it will happen locally on the client’s
    machine, so there’s no need to make an RPC here. Let’s declare the function’s
    signature and see how we can predict the future with some physics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `predict_position()` method, we will calculate the distance from
    the previous position to the new one. We will also calculate the direction from
    the previous position to the new position so that we have `Vector2` to work with,
    predicting the movement’s velocity:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that, we will calculate the movement’s linear velocity, based on how many
    seconds ahead we want to predict. We will then set this linear velocity as the
    `Spaceship`.`linear_velocity` property so that we it doesn’t idle between updates,
    asthe `Spaceship` node will start moving using this new velocity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will add the linear velocity to the new position to predict what
    will be the next position. We will then return this new position so that we can
    use this value when we decide to extrapolate the `Spaceship` node’s movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The logic to predict the rotation will be exactly the same, but take into account
    that we will use the `learp_angle()` built-in method to figure out the closest
    angle to extrapolate to. The `synchronize_rotation()` method will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `predict_rotation()` method will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we can start to make assumptions of where the `Spaceship` node is
    likely to be in the near future, based on `SynchronizationTimer` node’s tics.
    However, note that this is a very important available function on the server side,
    as sometimes, we may want to use it to mitigate lag in *Player* interactions and
    trigger the right game events. For instance, if we decide to have some **player
    versus player** (**PvP**) interactions, we may need to predict where a given player’s
    *Spaceship* was when another player fired their gun. This is because, due to latency,
    the player may have made a guessed shot and landed a hit. However, it is up to
    the server to decide whether the shot would actually land, given the latency and
    other aspects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we have seen two important techniques to handle lag and latency
    in online multiplayer games – prediction and synchronization. Prediction involves
    making informed guesses about an object’s future position and rotation, based
    on its past behavior. To implement prediction, Newtonian physics calculations
    are used to calculate the `Spaceship` node’s velocity and project its likely future
    position and rotation.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to implement the synchronization process, by stopping ongoing
    `Tween` instances and updating the `Spaceship` node’s position and rotation accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will use the predicted position and rotation to extrapolate
    `Spaceship` node’s movement, both linear and angular, so that if we happen to
    miss updates, we can at least fake a movement and fix it in the synchronization
    later if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Gazing into the future with extrapolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extrapolation is the visionary member of the lag compensation trio, gazing into
    the future to anticipate where objects will be next. By analyzing the current
    state of a game and the trajectory of objects, extrapolation extends beyond the
    data you have, offering a glimpse into what lies ahead. This technique is particularly
    handy for fast-paced games, where a split-second delay can mean the difference
    between victory and defeat.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole idea of extrapolation is that it is an interpolation into the future.
    Using the predictions we’ve made, we can create another interpolation, based on
    some assumptions of where a player is likely to be while we wait for its actual
    position. This will prevent hiccups and idling between updates. Let’s implement
    our extrapolation algorithm. Open the `res://09.prototyping-space- adventure/Actors/Player/Player2D.gd`
    script, and follow the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the function’s signature, the `extrapolation_position()` method
    will ask for the next position and duration in seconds that the extrapolation
    lasts for. Here, we will use terms similar to the ones in prediction, such as
    `seconds_ahead`, as we will work with future timing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This function only happens on the client side, so there’s no need to add any
    RPC annotations to it. Inside this function, we will use a new `Tween` instance
    to interpolate from the previous known position to the predicted next position,
    using `seconds_ahead` variable as the duration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And that’s basically it. We will call the `extrapolate_position()` method inside
    the `synchronize_position()` method right before updating the current and previous
    positions. Also, we will use the `future_position` variable, which stores the
    predicted position as an argument for the extrapolated next position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We do the same thing for the `extrapolate_rotation()` method. It should look
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `synchronize_rotation()` method should look like this after adding the
    line to call the `extrapolate_rotation()` method, using the `future_rotation`
    variable as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this section, you learned about the concept of extrapolation in the context
    of online multiplayer game development. Extrapolation is a technique that looks
    into the future to anticipate where objects will be next. By analyzing the current
    state of a game and the trajectory of objects, extrapolation extends beyond the
    available data, providing a glimpse into what lies ahead. It is particularly useful
    in fast-paced games where a split-second delay can significantly impact gameplay.
    The implementation of extrapolation involves interpolating from the previous known
    position and rotation to the predicted next position and rotation, using `Tween`
    instances, with the duration set to the desired time into the future.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the issues caused by lag, latency, and packet
    loss. Then, we saw how to fix them by implementing lag compensation techniques.
    We explored the concepts of interpolation, prediction, synchronization, and extrapolation
    to ensure smooth and responsive gameplay, even in the face of network delays.
  prefs: []
  type: TYPE_NORMAL
- en: First, we delved into interpolation, which is the core technique regarding lag
    compensation. Interpolation helps to fix some drawbacks of latency and sparse
    data updates by animating between two known values, while actual updates don’t
    arrive. This ensures that the `Spaceship` node won’t idling, waiting for new updates
    from the network. It will smoothly move toward new data, instead of abruptly teleporting
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we discussed prediction, which involves making informed guesses about
    an object’s future position, based on its past behavior. By using Newtonian physics
    calculations, we were able to calculate the spaceship’s velocity and project its
    likely future position and rotation. This helps prevent idle movements and keeps
    gameplay responsive.
  prefs: []
  type: TYPE_NORMAL
- en: We then explored extrapolation, which extends beyond available data to anticipate
    where objects will be next. By interpolating from the previous known position
    and rotation to the predicted next position and rotation, we were able to create
    smooth movements, even when updates were missed. This technique is particularly
    useful in fast-paced games where split-second delays can significantly impact
    gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing these lag compensation techniques, we can provide players with
    a seamless and immersive multiplayer gaming experience, even in the presence of
    network hiccups and delays.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how we can store some data on a client’s machine
    to reduce the bandwidth used in our game, relying on data that the players already
    have available on their machines.
  prefs: []
  type: TYPE_NORMAL
