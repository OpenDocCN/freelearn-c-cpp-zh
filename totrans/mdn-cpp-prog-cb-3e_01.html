<html><head></head><body>
<div><h1 class="chapterNumber">1</h1>
<h1 class="chapterTitle" id="_idParaDest-15">Learning Modern Core Language Features</h1>
<p class="normal">The C++ language has gone through a major transformation in the past decades with the development and release of C++11 and then, later, with its newer versions: C++14, C++17, C++20, and C++23. These new standards have introduced new concepts, simplified and extended existing syntax and semantics, and transformed the way we write code overall. C++11 looks and feels like a new language compared to what we previously knew, and code written using these new standards is called modern C++ code. This introductory chapter will touch on some of the language features introduced, starting with C++11, that help you with many coding routines. However, the core of the language expands way beyond the topics addressed in this chapter, and many other features are discussed in the other chapters of the book.</p>
<p class="normal">The recipes included in this chapter are as follows:</p>
<ul>
<li class="bulletList">Using <code class="inlineCode">auto</code> whenever possible</li>
<li class="bulletList">Creating type aliases and alias templates</li>
<li class="bulletList">Understanding uniform initialization</li>
<li class="bulletList">Understanding the various forms of non-static member initialization</li>
<li class="bulletList">Controlling and querying object alignment</li>
<li class="bulletList">Using scoped enumerations</li>
<li class="bulletList">Using <code class="inlineCode">override</code> and <code class="inlineCode">final</code> for virtual methods</li>
<li class="bulletList">Using range-based for loops to iterate on a range</li>
<li class="bulletList">Enabling range-based for loops for custom types</li>
<li class="bulletList">Using explicit constructors and conversion operators to avoid implicit conversion</li>
<li class="bulletList">Using unnamed namespaces instead of static globals</li>
<li class="bulletList">Using inline namespaces for symbol versioning</li>
<li class="bulletList">Using structured bindings to handle multi-return values</li>
<li class="bulletList">Simplifying code with class template argument deduction</li>
<li class="bulletList">Using the subscript operator to access elements in a collection</li>
</ul>
<p class="normal">Let’s start by learning about automatic type deduction.</p>
<h1 class="heading-1" id="_idParaDest-16">Using auto whenever possible</h1>
<p class="normal">Automatic type deduction<a id="_idIndexMarker000"/> is one of the most important and widely used features in modern C++. The new C++ standards have made it possible to use <code class="inlineCode">auto</code> as a placeholder for types in various contexts, letting the compiler deduce the actual type. In C++11, <code class="inlineCode">auto</code> can <a id="_idIndexMarker001"/>be used to declare local variables and for the return type of a function with a trailing return type. In C++14, <code class="inlineCode">auto</code> can be used for the return type of a function without specifying a trailing type and for parameter declarations in lambda expressions. In C++17, it can be used to declare structured bindings, which are discussed at the end of the chapter. In C++20, it can be used to simplify function template syntax with so-called abbreviated function templates. In C++23, it can be used to perform an explicit cast to a prvalue copy. Future standard versions are likely to expand the use of <code class="inlineCode">auto</code> to even more cases. The use of <code class="inlineCode">auto</code> as introduced in C++11 and C++14 has several important benefits, all of which will be discussed in the <em class="italic">How it works...</em> section. Developers should be aware of them and aim to use <code class="inlineCode">auto</code> whenever possible. An actual term was coined for this by Andrei Alexandrescu and promoted by<a id="_idIndexMarker002"/> Herb Sutter—<strong class="keyWord">almost always auto</strong> (<strong class="keyWord">AAA</strong>) (<a href="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/">https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/</a>).</p>
<h2 class="heading-2" id="_idParaDest-17">How to do it...</h2>
<p class="normal">Consider using <code class="inlineCode">auto</code> as a placeholder for the actual type in the following situations:</p>
<ul>
<li class="bulletList">To declare local variables with the form <code class="inlineCode">auto name = expression</code> when you do not want to commit to a specific type:
        <pre class="programlisting code"><code class="hljs-code">auto i = 42;          // int
auto d = 42.5;        // double
auto s = "text";      // char const *
auto v = { 1, 2, 3 }; // std::initializer_list&lt;int&gt;
</code></pre>
</li>
<li class="bulletList">To declare local variables with the <code class="inlineCode">auto name = type-id { expression }</code> form when you need to commit to a specific type:
        <pre class="programlisting code"><code class="hljs-code">auto b  = new char[10]{ 0 };            // char*
auto s1 = std::string {"text"};         // std::string
auto v1 = std::vector&lt;int&gt; { 1, 2, 3 }; // std::vector&lt;int&gt;
auto p  = std::make_shared&lt;int&gt;(42);    // std::shared_ptr&lt;int&gt;
</code></pre>
</li>
<li class="bulletList">To declare <a id="_idIndexMarker003"/>named lambda functions, with the form <code class="inlineCode">auto name = lambda-expression</code>, unless the lambda needs to be passed or returned to a function:
        <pre class="programlisting code"><code class="hljs-code">auto upper = [](char const c) {return toupper(c); };
</code></pre>
</li>
<li class="bulletList">To declare lambda parameters and return values:
        <pre class="programlisting code"><code class="hljs-code">auto add = [](auto const a, auto const b) {return a + b;};
</code></pre>
</li>
<li class="bulletList">To declare a function return type when you don’t want to commit to a specific type:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename F, typename T&gt;
auto apply(F&amp;&amp; f, T value)
{
  return f(value);
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-18">How it works...</h2>
<p class="normal">The <code class="inlineCode">auto</code> specifier is basically a placeholder for an actual type. When using <code class="inlineCode">auto</code>, the compiler deduces the actual type from the following instances:</p>
<ul>
<li class="bulletList">From the type of expression used to initialize a variable, when <code class="inlineCode">auto</code> is used to declare variables.</li>
<li class="bulletList">From the trailing return type or the return expression type of a function, when <code class="inlineCode">auto</code> is used as a placeholder for the return type of a function.</li>
</ul>
<p class="normal">In some cases, it is necessary to commit to a specific type. For instance, in the first example, the compiler deduces the type of <code class="inlineCode">s</code> to be <code class="inlineCode">char const *</code>. If the intention was to have a <code class="inlineCode">std::string</code>, then the type must be specified explicitly. Similarly, the type of <code class="inlineCode">v</code> was deduced as <code class="inlineCode">std::initializer_list&lt;int&gt;</code> because it is bound to <code class="inlineCode">auto</code> and not a specific type; in this case, the rules say the deduced type is <code class="inlineCode">std::initializer_list&lt;T&gt;</code>, with <code class="inlineCode">T</code> being <code class="inlineCode">int</code> in our case. However, the intention could be to have a <code class="inlineCode">std::vector&lt;int&gt;</code>. In such cases, the type must be specified explicitly on the right side of the assignment.</p>
<p class="normal">There are some important <a id="_idIndexMarker004"/>benefits of using the <code class="inlineCode">auto</code> specifier instead of actual types; the following is a list of, perhaps, the most important ones:</p>
<ul>
<li class="bulletList">It is not possible to leave a variable uninitialized. This is a common mistake that developers make when declaring variables and specifying the actual type. However, this is not possible with <code class="inlineCode">auto</code>, which requires an initialization of the variable in order to deduce the type. Initializing variables with a defined value is important because uninitialized variables incur undefined behavior.</li>
<li class="bulletList">Using <code class="inlineCode">auto</code> ensures that you always use the intended type and that implicit conversion will not occur. Consider the following example where we retrieve the size of a vector for a local variable. In the first case, the type of the variable is <code class="inlineCode">int</code>, although the <code class="inlineCode">size()</code> method returns <code class="inlineCode">size_t</code>. This means an implicit conversion from <code class="inlineCode">size_t</code> to <code class="inlineCode">int</code> will occur. However, using <code class="inlineCode">auto</code> for the type will deduce the correct type—that is, <code class="inlineCode">size_t</code>:
        <pre class="programlisting code"><code class="hljs-code">auto v = std::vector&lt;int&gt;{ 1, 2, 3 };
// implicit conversion, possible loss of data
int size1 = v.size();
// OK
auto size2 = v.size();
// ill-formed (warning in gcc, error in clang &amp; VC++)
auto size3 = int{ v.size() };
</code></pre>
</li>
<li class="bulletList">Using <code class="inlineCode">auto</code> promotes good object-oriented practices, such as preferring interfaces over implementations. This is important in <strong class="keyWord">object-oriented programming</strong> (<strong class="keyWord">OOP</strong>) because it provides the flexibility to change between different implementations, modularity of the code, and better testability because it’s easy to mock objects. The fewer the number of types specified, the more generic the code is and more open to future changes, which is a fundamental principle of OOP.</li>
<li class="bulletList">It means<a id="_idIndexMarker005"/> less typing (in general) and less concern for actual types that we don’t care about anyway. It is very often the case that even though we explicitly specify the type, we don’t actually care about it. A very common case is with iterators, but there are many more. When you want to iterate over a range, you don’t care about the actual type of the iterator. You are only interested in the iterator itself; so using <code class="inlineCode">auto</code> saves time spent typing (possibly long) names and helps you focus on actual code and not type names. In the following example, in the first <code class="inlineCode">for</code> loop, we explicitly use the type of the iterator. It is a lot of text to type; the long statements can actually make the code less readable, and you also need to know the type name, which you actually don’t care about. The second loop with the <code class="inlineCode">auto</code> specifier looks simpler and saves you from typing and caring about actual types:
        <pre class="programlisting code"><code class="hljs-code">std::map&lt;int, std::string&gt; m;
for (std::map&lt;int, std::string&gt;::const_iterator
  it = m.cbegin();
  it != m.cend(); ++it)
{ /*...*/ }
for (auto it = m.cbegin(); it != m.cend(); ++it)
{ /*...*/ }
</code></pre>
</li>
<li class="bulletList">Declaring variables with <code class="inlineCode">auto</code> provides a consistent coding style, with the type always on the right-hand side. If you allocate objects dynamically, you need to write the type both on the left and right side of the assignment, for example, <code class="inlineCode">int* p = new int(42)</code>. With <code class="inlineCode">auto</code>, the type is specified only once on the right side.</li>
</ul>
<p class="normal">However, there are some gotchas when using <code class="inlineCode">auto</code>:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">auto</code> specifier is only a placeholder for the type, not for the <code class="inlineCode">const</code>/<code class="inlineCode">volatile</code> and reference specifiers. If you need a <code class="inlineCode">const</code>/<code class="inlineCode">volatile</code> and/or a reference type, then you need to specify them explicitly. In the following example, the <code class="inlineCode">get()</code> member function of <code class="inlineCode">foo</code> returns a reference to <code class="inlineCode">int</code>; when the variable <code class="inlineCode">x</code> is initialized from the return value, the type deduced by the compiler is <code class="inlineCode">int</code>, not <code class="inlineCode">int&amp;</code>. Therefore, any change made to <code class="inlineCode">x</code> will not propagate to <code class="inlineCode">foo.x_</code>. In order to do so, we should use <code class="inlineCode">auto&amp;</code>:
        <pre class="programlisting code"><code class="hljs-code">class foo {
  int x;
public:
  foo(int const value = 0) :x{ value } {}
  int&amp; get() { return x; }
};
foo f(42);
auto x = f.get();
x = 100;
std::cout &lt;&lt; f.get() &lt;&lt; '\n'; // prints 42
</code></pre>
</li>
<li class="bulletList">It is not possible to use <code class="inlineCode">auto</code> for types that are not moveable:
        <pre class="programlisting code"><code class="hljs-code">auto ai = std::atomic&lt;int&gt;(42); // error
</code></pre>
</li>
<li class="bulletList">It is not possible to use <code class="inlineCode">auto</code> for multi-word types, such as <code class="inlineCode">long long</code>, <code class="inlineCode">long double</code>, or <code class="inlineCode">struct foo</code>. However, in the first case, the possible workarounds are to use literals or type aliases; also, with Clang and GCC (but not MSVC) it’s possible to put the type name in parentheses, <code class="inlineCode">(long long){ 42 }</code>. As for the second case, using <code class="inlineCode">struct</code>/<code class="inlineCode">class</code> in that form is only supported in C++ for C compatibility and should be avoided anyway:
        <pre class="programlisting code"><code class="hljs-code">auto l1 = long long{ 42 }; // error
using llong = long long;
auto l2 = llong{ 42 };     // OK
auto l3 = 42LL;            // OK
auto l4 = (long long){ 42 }; // OK with gcc/clang
</code></pre>
</li>
<li class="bulletList">If you use the <code class="inlineCode">auto</code> specifier but still need to know the type, you can do so in most IDEs by putting the cursor over a variable, for instance. If you leave the IDE, however, that is not possible anymore, and the only way to know the actual type is to deduce it yourself from the initialization expression, which could mean searching through the code for function return types.</li>
</ul>
<p class="normal">The <code class="inlineCode">auto</code> can be used <a id="_idIndexMarker006"/>to specify the return type from a function. In C++11, this requires a trailing return type in the function declaration. In C++14, this has been relaxed, and the type of the return value is deduced by the compiler from the <code class="inlineCode">return</code> expression. If there are multiple return values, they should have the same type:</p>
<pre class="programlisting code"><code class="hljs-code">// C++11
auto func1(int const i) -&gt; int
{ return 2*i; }
// C++14
auto func2(int const i)
{ return 2*i; }
</code></pre>
<p class="normal">As mentioned earlier, <code class="inlineCode">auto</code> does not retain <code class="inlineCode">const</code>/<code class="inlineCode">volatile</code> and reference qualifiers. This leads to problems with <code class="inlineCode">auto</code> as a placeholder for the return type from a function. To explain this, let’s consider the preceding example with <code class="inlineCode">foo.get()</code>. This time, we have a wrapper function called <code class="inlineCode">proxy_get()</code> that takes a reference to a <code class="inlineCode">foo</code>, calls <code class="inlineCode">get()</code>, and returns the value returned by <code class="inlineCode">get()</code>, which is an <code class="inlineCode">int&amp;</code>. However, the compiler will deduce the return type of <code class="inlineCode">proxy_get()</code> as being <code class="inlineCode">int</code>, not <code class="inlineCode">int&amp;</code>. </p>
<p class="normal">Trying to assign that value to an <code class="inlineCode">int&amp;</code> fails with an error:</p>
<pre class="programlisting code"><code class="hljs-code">class foo
{
  int x_;
public:
  foo(int const x = 0) :x_{ x } {}
  int&amp; get() { return x_; }
};
auto proxy_get(foo&amp; f) { return f.get(); }
auto f = foo{ 42 };
auto&amp; x = proxy_get(f); // cannot convert from 'int' to 'int &amp;'
</code></pre>
<p class="normal">To fix this, we need to <a id="_idIndexMarker007"/>actually return <code class="inlineCode">auto&amp;</code>. However, there is a problem with templates and perfect forwarding the return type without knowing whether it is a value or a reference. The solution to this problem in C++14 is <code class="inlineCode">decltype(auto)</code>, which will correctly deduce the type:</p>
<pre class="programlisting code"><code class="hljs-code">decltype(auto) proxy_get(foo&amp; f) 
{ return f.get(); }
auto f = foo{ 42 };
decltype(auto) x = proxy_get(f);
</code></pre>
<p class="normal">The <code class="inlineCode">decltype</code> specifier is used to inspect the declared type of an entity or an expression. It’s mostly useful when declaring types is cumbersome or if they can’t be declared at all with the standard notation. Examples of this include declaring lambda types and types that depend on template parameters.</p>
<p class="normal">The last important case where <code class="inlineCode">auto</code> can be used is with lambdas. As of C++14, both lambda return types and lambda parameter types can be <code class="inlineCode">auto</code>. Such a lambda is called a <em class="italic">generic lambda</em> because the closure type defined by the lambda has a templated call operator. The following shows a generic lambda that takes two <code class="inlineCode">auto</code> parameters and returns the result of applying <code class="inlineCode">operator+</code> to the actual types:</p>
<pre class="programlisting code"><code class="hljs-code">auto ladd = [] (auto const a, auto const b) { return a + b; };
</code></pre>
<p class="normal">The compiler-generated function object has the following form, where the call operator is a function template:</p>
<pre class="programlisting code"><code class="hljs-code">struct
{
  template&lt;typename T, typename U&gt;
 auto operator () (T const a, U const b) const { return a+b; }
} L;
</code></pre>
<p class="normal">This lambda can be used to add anything for which the <code class="inlineCode">operator+</code> is defined, as shown in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">auto i = ladd(40, 2);            // 42
auto s = ladd("forty"s, "two"s); // "fortytwo"s
</code></pre>
<p class="normal">In this example, we used the <code class="inlineCode">ladd</code> lambda<a id="_idIndexMarker008"/> to add two integers and concatenate them to <code class="inlineCode">std::string</code> objects (using the C++14 user-defined literal <code class="inlineCode">operator ""s</code>).</p>
<h2 class="heading-2" id="_idParaDest-19">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Creating type aliases and alias templates</em>, to learn about aliases for types</li>
<li class="bulletList"><em class="italic">Understanding uniform initialization</em>, to see how brace-initialization works</li>
</ul>
<h1 class="heading-1" id="_idParaDest-20">Creating type aliases and alias templates</h1>
<p class="normal">In C++, it is possible to create synonyms that can be used instead of a type name. This is achieved by creating a <code class="inlineCode">typedef</code> declaration. This <a id="_idIndexMarker009"/>is useful in several cases, such as creating shorter or more meaningful names for a type or names for function pointers. However, <code class="inlineCode">typedef</code> declarations cannot be used with templates to create template type aliases. An <code class="inlineCode">std::vector&lt;T&gt;</code>, for instance, is not a type (<code class="inlineCode">std::vector&lt;int&gt;</code> is a type), but a sort of family of all types that can be created when the type placeholder <code class="inlineCode">T</code> is replaced with an actual type.</p>
<p class="normal">In C++11, a type alias<a id="_idIndexMarker010"/> is a name for another already declared type, and an alias template is a name for another already declared template. Both of these types of aliases are introduced with a new <code class="inlineCode">using</code> syntax.</p>
<h2 class="heading-2" id="_idParaDest-21">How to do it...</h2>
<ul>
<li class="bulletList">Create <a id="_idIndexMarker011"/>type aliases with the form <code class="inlineCode">using identifier = type-id</code>, as in the following examples:
        <pre class="programlisting code"><code class="hljs-code">using byte     = unsigned char;
using byte_ptr = unsigned char *;
using array_t  = int[10];
using fn       = void(byte, double);
void func(byte b, double d) { /*...*/ }
byte b{42};
byte_ptr pb = new byte[10] {0};
array_t a{0,1,2,3,4,5,6,7,8,9};
fn* f = func;
</code></pre>
</li>
<li class="bulletList">Create alias templates<a id="_idIndexMarker012"/> with the form <code class="inlineCode">template&lt;template-params-list&gt; identifier = type-id</code>, as in the following examples:
        <pre class="programlisting code"><code class="hljs-code">template &lt;class T&gt;
class custom_allocator { /* ... */ };
template &lt;typename T&gt;
using vec_t = std::vector&lt;T, custom_allocator&lt;T&gt;&gt;;
vec_t&lt;int&gt;           vi;
vec_t&lt;std::string&gt;   vs;
</code></pre>
</li>
</ul>
<p class="normal">For consistency and readability, you should do the following:</p>
<ul>
<li class="bulletList">Not mix <code class="inlineCode">typedef</code> and <code class="inlineCode">using</code> declarations when creating aliases</li>
<li class="bulletList">Prefer the <code class="inlineCode">using</code> syntax to create names of function pointer types</li>
</ul>
<h2 class="heading-2" id="_idParaDest-22">How it works...</h2>
<p class="normal">A <code class="inlineCode">typedef</code> declaration<a id="_idIndexMarker013"/> introduces a synonym (an alias, in other words) for a type. It does not introduce another type (like a <code class="inlineCode">class</code>, <code class="inlineCode">struct</code>, <code class="inlineCode">union</code>, or <code class="inlineCode">enum</code> declaration). Type names introduced with a <code class="inlineCode">typedef</code> declaration follow the same hiding rules as identifier names. They can also be redeclared, but only to refer to the same type (therefore, you can have valid multiple <code class="inlineCode">typedef</code> declarations that introduce the same type name synonym in a translation unit, as long as it is a synonym for the same type). The following are typical<a id="_idIndexMarker014"/> examples of <code class="inlineCode">typedef</code> declarations:</p>
<pre class="programlisting code"><code class="hljs-code">typedef unsigned char   byte;
typedef unsigned char * byte_ptr;
typedef int array_t[10];
typedef void(*fn)(byte, double);
template&lt;typename T&gt;
class foo {
  typedef T value_type;
};
typedef std::vector&lt;int&gt; vint_t;
typedef int INTEGER;
INTEGER x = 10;
typedef int INTEGER; // redeclaration of same type
INTEGER y = 20;
</code></pre>
<p class="normal">A type alias declaration<a id="_idIndexMarker015"/> is equivalent to a <code class="inlineCode">typedef</code> declaration. It can appear in a block scope, class scope, or namespace scope. According to C++11 standard (paragraph 9.2.4, document version N4917):</p>
<blockquote class="packt_quote">
<p class="quote">A typedef-name can also be introduced by an alias declaration. The identifier following the using keyword becomes a typedef-name and the optional attribute-specifier-seq following the identifier appertains to that typedef-name. It has the same semantics as if it were introduced by the typedef specifier. In particular, it does not define a new type and it shall not appear in the type-id.</p>
</blockquote>
<p class="normal">An alias declaration is, however, more readable and clearer about the actual type that is aliased when it comes to creating aliases for array types and function pointer types. In the examples from the <em class="italic">How to do it...</em> section, it is easily understandable that <code class="inlineCode">array_t</code> is a name for the type array of 10 integers, while <code class="inlineCode">fn</code> is a name for a function type that takes two parameters of the type <code class="inlineCode">byte</code> and <code class="inlineCode">double</code> and returns <code class="inlineCode">void</code>. This is also consistent with the syntax for declaring <code class="inlineCode">std::function</code> objects (for example, <code class="inlineCode">std::function&lt;void(byte, double)&gt; f</code>).</p>
<p class="normal">It is important to take note of the following things:</p>
<ul>
<li class="bulletList">Alias templates <a id="_idIndexMarker016"/>cannot be partially or explicitly specialized.</li>
<li class="bulletList">Alias templates are never deduced by template argument deduction when deducing a template parameter.</li>
<li class="bulletList">The type produced when specializing an alias template is not allowed to directly or indirectly make use of its own type.</li>
</ul>
<p class="normal">The driving purpose of <a id="_idIndexMarker017"/>the new syntax is to define alias templates. These are templates that, when specialized, are equivalent to the result of substituting the template arguments of the alias template for the template parameters in the type-id.</p>
<h2 class="heading-2" id="_idParaDest-23">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Simplifying code with class template argument deduction</em>, to learn how to use class templates without explicitly specifying template arguments</li>
</ul>
<h1 class="heading-1" id="_idParaDest-24">Understanding uniform initialization</h1>
<p class="normal">Brace-initialization<a id="_idIndexMarker018"/> is a uniform method for initializing data in C++11. For this reason, it is also called <em class="italic">uniform initialization</em>. It is arguably one of the most important features of C++11 that developers should understand and use. It removes previous distinctions between initializing fundamental types, aggregate and non-aggregate types, and arrays and standard containers.</p>
<h2 class="heading-2" id="_idParaDest-25">Getting ready</h2>
<p class="normal">To continue with this recipe, you <a id="_idIndexMarker019"/>need to be familiar with direct initialization, which initializes an object from an explicit set of constructor arguments, and copy initialization, which initializes an object from another object. The following is a simple example of both types of initializations:</p>
<pre class="programlisting code"><code class="hljs-code">std::string s1("test");   // direct initialization
std::string s2 = "test";  // copy initialization
</code></pre>
<p class="normal">With these in mind, let’s explore how to perform uniform initialization.</p>
<h2 class="heading-2" id="_idParaDest-26">How to do it...</h2>
<p class="normal">To uniformly initialize<a id="_idIndexMarker020"/> objects regardless of their type, use the brace-initialization form <code class="inlineCode">{}</code>, which can be used for both direct initialization and copy initialization. When used with brace-initialization, these are called direct-list and copy-list-initialization:</p>
<pre class="programlisting code"><code class="hljs-code">T object {other};   // direct-list-initialization
T object = {other}; // copy-list-initialization
</code></pre>
<p class="normal">Examples of uniform initialization are as follows:</p>
<ul>
<li class="bulletList">Standard containers:
        <pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v { 1, 2, 3 };
std::map&lt;int, std::string&gt; m { {1, "one"}, { 2, "two" }};
</code></pre>
</li>
<li class="bulletList">Dynamically allocated arrays:
        <pre class="programlisting code"><code class="hljs-code">int* arr2 = new int[3]{ 1, 2, 3 };
</code></pre>
</li>
<li class="bulletList">Arrays:
        <pre class="programlisting code"><code class="hljs-code">int arr1[3] { 1, 2, 3 };
</code></pre>
</li>
<li class="bulletList">Built-in types:
        <pre class="programlisting code"><code class="hljs-code">int i { 42 };
double d { 1.2 };
</code></pre>
</li>
<li class="bulletList">User-defined types:
        <pre class="programlisting code"><code class="hljs-code">class foo
{
  int a_;
  double b_;
public:
  foo():a_(0), b_(0) {}
  foo(int a, double b = 0.0):a_(a), b_(b) {}
};
foo f1{};
foo f2{ 42, 1.2 };
foo f3{ 42 };
</code></pre>
</li>
<li class="bulletList">User-defined <strong class="keyWord">Plain Old Data</strong> (<strong class="keyWord">POD</strong>) types:
        <pre class="programlisting code"><code class="hljs-code">struct bar { int a_; double b_;};
bar b{ 42, 1.2 };
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-27">How it works...</h2>
<p class="normal">Before C++11, objects required <a id="_idIndexMarker021"/>different types of initialization based on their type:</p>
<ul>
<li class="bulletList">Fundamental types could be initialized using assignment:
        <pre class="programlisting code"><code class="hljs-code">int a = 42;
double b = 1.2;
</code></pre>
</li>
<li class="bulletList">Class objects could also be initialized using an assignment from a single value if they had a conversion constructor (prior to C++11, a constructor with a single parameter was called a <em class="italic">conversion constructor</em>):
        <pre class="programlisting code"><code class="hljs-code">class foo
{
  int a_;
public:
  foo(int a):a_(a) {}
};
foo f1 = 42;
</code></pre>
</li>
<li class="bulletList">Non-aggregate classes could be initialized with parentheses (the functional form) when arguments were provided and only without any parentheses when default initialization was performed (a call to the default constructor). In the next example, <code class="inlineCode">foo</code> is the structure defined in the <em class="italic">How to do it...</em> section:
        <pre class="programlisting code"><code class="hljs-code">foo f1;           // default initialization
foo f2(42, 1.2);
foo f3(42);
foo f4();         // function declaration
</code></pre>
</li>
<li class="bulletList">Aggregate and <a id="_idIndexMarker022"/>POD types could be initialized with brace-initialization. In the following example, <code class="inlineCode">bar</code> is the structure defined in the <em class="italic">How to do it...</em> section:
        <pre class="programlisting code"><code class="hljs-code">bar b = {42, 1.2};
int a[] = {1, 2, 3, 4, 5};
</code></pre>
</li>
</ul>
<div><p class="normal">A <strong class="keyWord">Plain Old Data</strong> (<strong class="keyWord">POD</strong>) type<a id="_idIndexMarker023"/> is a type that is both trivial (has special members that are compiler-provided or explicitly defaulted and occupy a contiguous memory area) and has a standard layout (a class that does not contain language features, such as virtual functions, which are incompatible with the C language, and all members have the same access control). The concept of POD types has been deprecated in C++20 in favor of trivial and standard layout types.</p>
</div>
<p class="normal">Apart from the different methods of initializing the data, there are also some limitations. For instance, the only way to initialize a standard container (apart from copy constructing) is to first declare an object and then insert elements into it; <code class="inlineCode">std::vector</code> was an exception because it is possible to assign values from an array that can be initialized prior using aggregate initialization. On the other hand, however, dynamically allocated aggregates could not be initialized directly.</p>
<p class="normal">All the examples in the <em class="italic">How to do it...</em> section use direct initialization, but copy initialization is also possible with brace-initialization. These two forms, direct and copy initialization, may be equivalent in most cases, but copy initialization is less permissive because it does not consider explicit constructors in its implicit conversion sequence, which must produce an object directly from the initializer, whereas direct initialization expects an implicit conversion from the initializer to an argument of the constructor. Dynamically allocated arrays can only be initialized using direct initialization.</p>
<p class="normal">Of the classes shown in the preceding examples, <code class="inlineCode">foo</code> is the one class that has both a default constructor and a constructor with parameters. To use the default constructor to perform default initialization, we need to use empty braces—that is, <code class="inlineCode">{}</code>. To use the constructor with parameters, we need to provide the values for all the arguments in braces <code class="inlineCode">{}</code>. Unlike non-aggregate types, where default initialization means invoking the default constructor, for aggregate types, default initialization means initializing with zeros.</p>
<p class="normal">Initialization of standard containers, such as the vector and the map, also shown previously, is possible because all standard containers have an additional constructor in C++11 that takes an argument of the type <code class="inlineCode">std::initializer_list&lt;T&gt;</code>. This is basically a lightweight proxy over an array of elements of the type <code class="inlineCode">T const</code>. These constructors then initialize the internal data from the values in the initializer list.</p>
<p class="normal">The way <a id="_idIndexMarker024"/>initialization using <code class="inlineCode">std::initializer_list</code> works is as follows:</p>
<ul>
<li class="bulletList">The compiler resolves the types of the elements in the initialization list (all the elements must have the same type).</li>
<li class="bulletList">The compiler creates an array with the elements in the initializer list.</li>
<li class="bulletList">The compiler creates an <code class="inlineCode">std::initializer_list&lt;T&gt;</code> object to wrap the previously created array.</li>
<li class="bulletList">The <code class="inlineCode">std::initializer_list&lt;T&gt;</code> object is passed as an argument to the constructor.</li>
</ul>
<p class="normal">An initializer list always takes precedence over other constructors where brace-initialization is used. If such a constructor exists for a class, it will be called when brace-initialization is performed:</p>
<pre class="programlisting code"><code class="hljs-code">class foo
{
  int a_;
  int b_;
public:
  foo() :a_(0), b_(0) {}
  foo(int a, int b = 0) :a_(a), b_(b) {}
  foo(std::initializer_list&lt;int&gt; l) {}
};
foo f{ 1, 2 }; // calls constructor with initializer_list&lt;int&gt;
</code></pre>
<p class="normal">The precedence rule applies to any function, not just constructors. In the following example, two overloads of the same function exist. Calling the function with an initializer list resolves a call to the overload with an <code class="inlineCode">std::initializer_list</code>:</p>
<pre class="programlisting code"><code class="hljs-code">void func(int const a, int const b, int const c)
{
  std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; '\n';
}
void func(std::initializer_list&lt;int&gt; const list)
{
  for (auto const &amp; e : list)
    std::cout &lt;&lt; e &lt;&lt; '\n';
}
func({ 1,2,3 }); // calls second overload
</code></pre>
<p class="normal">However, this has the<a id="_idIndexMarker025"/> potential to lead to bugs. Let’s take, for example, the <code class="inlineCode">std::vector</code> type. Among the constructors of the vector, there is one that has a single argument, representing the initial number of elements to be allocated, and another one that has an <code class="inlineCode">std::initializer_list</code> as an argument. If the intention is to create a vector with a preallocated size, using brace-initialization will not work, as the constructor with the <code class="inlineCode">std::initializer_list</code> will be the best overload to be called:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v {5};
</code></pre>
<p class="normal">The preceding code does not create a vector with five elements but, instead, a vector with one element with a value of <code class="inlineCode">5</code>. To be able to actually create a vector with five elements, initialization with the parentheses form must be used:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v (5);
</code></pre>
<p class="normal">Another thing to note is that brace-initialization does not allow narrowing conversion. According to the C++ standard (refer to paragraph 9.4.5 of the standard, document version N4917), a narrowing conversion is an implicit conversion:</p>
<blockquote class="packt_quote">
<p class="quote">— From a floating-point type to an integer type.</p>
<p class="quote">— From long double to double or float, or from double to float, except where the source is a constant expression and the actual value after conversion is within the range of values that can be represented (even if it cannot be represented exactly).</p>
<p class="quote">— From an integer type or unscoped enumeration type to a floating-point type, except where the source is a constant expression and the actual value after conversion will fit into the target type and will produce the original value when converted to its original type.</p>
<p class="quote">— From an integer type or unscoped enumeration type to an integer type that cannot represent all the values of the original type, except where the source is a constant expression and the actual value after conversion will fit into the target type and will produce the original value when converted to its original type.</p>
</blockquote>
<p class="normal">The following declarations trigger compiler errors because they require a narrowing conversion:</p>
<pre class="programlisting code"><code class="hljs-code">int i{ 1.2 };           // error
double d = 47 / 13;
float f1{ d };          // error, only warning in gcc
</code></pre>
<p class="normal">To fix this error, an<a id="_idIndexMarker026"/> explicit conversion must be done:</p>
<pre class="programlisting code"><code class="hljs-code">int i{ static_cast&lt;int&gt;(1.2) };
double d = 47 / 13;
float f1{ static_cast&lt;float&gt;(d) };
</code></pre>
<div><p class="normal">A brace-initialization list is not an expression and does not have a type. Therefore, <code class="inlineCode">decltype</code> cannot be used on a brace-init-list, and template type deductions cannot deduce the type that matches a brace-init-list.</p>
</div>
<p class="normal">Let’s consider one more example:</p>
<pre class="programlisting code"><code class="hljs-code">float f2{47/13};        // OK, f2=3
</code></pre>
<p class="normal">The preceding declaration is, despite the above, correct because an implicit conversion from <code class="inlineCode">int</code> to <code class="inlineCode">float</code> exists. The expression <code class="inlineCode">47/13</code> is first evaluated to integer value <code class="inlineCode">3</code>, which is then assigned to the variable <code class="inlineCode">f2</code> of the type <code class="inlineCode">float</code>.</p>
<h2 class="heading-2" id="_idParaDest-28">There’s more...</h2>
<p class="normal">The following<a id="_idIndexMarker027"/> example shows several examples of direct-list-initialization and <a id="_idIndexMarker028"/>copy-list-initialization. In C++11, the deduced type of all these expressions is <code class="inlineCode">std::initializer_list&lt;int&gt;</code>:</p>
<pre class="programlisting code"><code class="hljs-code">auto a = {42};   // std::initializer_list&lt;int&gt;
auto b {42};     // std::initializer_list&lt;int&gt;
auto c = {4, 2}; // std::initializer_list&lt;int&gt;
auto d {4, 2};   // std::initializer_list&lt;int&gt;
</code></pre>
<p class="normal">C++17 has changed the rules for list initialization, differentiating between direct- and copy-list-initialization. The new rules for type deduction are as follows:</p>
<ul>
<li class="bulletList">For<a id="_idIndexMarker029"/> copy-list-initialization, auto deduction will deduce an <code class="inlineCode">std::initializer_list&lt;T&gt;</code> if all the elements in the list have the same type, or be ill-formed.</li>
<li class="bulletList">For <a id="_idIndexMarker030"/>direct-list-initialization, auto deduction will deduce a <code class="inlineCode">T</code> if the list has a single element, or be ill-formed if there is more than one element.</li>
</ul>
<p class="normal">Based on these new rules, the previous examples would change as follows (the deduced type is mentioned in the comments):</p>
<pre class="programlisting code"><code class="hljs-code">auto a = {42};   // std::initializer_list&lt;int&gt;
auto b {42};     // int
auto c = {4, 2}; // std::initializer_list&lt;int&gt;
auto d {4, 2};   // error, too many
</code></pre>
<p class="normal">In this case, <code class="inlineCode">a</code> and <code class="inlineCode">c</code> are deduced as <code class="inlineCode">std::initializer_list&lt;int&gt;</code>, <code class="inlineCode">b</code> is deduced as an <code class="inlineCode">int</code>, and <code class="inlineCode">d</code>, which uses direct initialization and has more than one value in the brace-init-list, triggers a compiler error.</p>
<h2 class="heading-2" id="_idParaDest-29">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using auto whenever possible</em>, to understand how automatic type deduction works in C++</li>
<li class="bulletList"><em class="italic">Understanding the various forms of non-static member initialization</em>, to learn how to best perform initialization of class members</li>
</ul>
<h1 class="heading-1" id="_idParaDest-30">Understanding the various forms of non-static member initialization</h1>
<p class="normal">Constructors are places where <a id="_idIndexMarker031"/>non-static class member initialization is done. Many developers prefer assignments in the constructor body. Aside from the several exceptional cases when that is actually necessary, initialization of non-static members should be done in the constructor’s initializer list or, as of C++11, using default member initialization when they are declared in the class. Prior to C++11, constants and non-constant non-static data members of a class had to be initialized in the constructor. Initialization on declaration in a class was only possible for static constants. As we will see here, this limitation was removed in C++11, which allows the initialization of non-statics in the class declaration. This initialization is called <em class="italic">default member initialization</em> and is explained in the following sections.</p>
<p class="normal">This recipe will explore the ways non-static member initialization should be done. Using the appropriate initialization method for each member leads not only to more efficient code but also to better organized and more readable code.</p>
<h2 class="heading-2" id="_idParaDest-31">How to do it...</h2>
<p class="normal">To initialize <a id="_idIndexMarker032"/>non-static members of a class, you should:</p>
<ul>
<li class="bulletList">Use default member initialization for constants, both static and non-static (see <code class="inlineCode">[1]</code> and <code class="inlineCode">[2]</code> in the following code).</li>
<li class="bulletList">Use default member initialization to provide default values for members of classes with multiple constructors that would use a common initializer for those members (see <code class="inlineCode">[3]</code> and <code class="inlineCode">[4]</code> in the following code).</li>
<li class="bulletList">Use the constructor initializer list to initialize members that don’t have default values but depend on constructor parameters (see <code class="inlineCode">[5]</code> and <code class="inlineCode">[6]</code> in the following code).</li>
<li class="bulletList">Use assignment in constructors when the other options are not possible (examples include initializing data members with the pointer <code class="inlineCode">this</code>, checking constructor parameter values, and throwing exceptions prior to initializing members with those values or self-references to two non-static data members).</li>
</ul>
<p class="normal">The following example shows these forms of initialization:</p>
<pre class="programlisting code"><code class="hljs-code">struct Control
{
  const int DefaultHeight = 14;                                // [1]
const int DefaultWidth  = 80;                                // [2]
  std::string text;
  TextVerticalAlignment valign = TextVerticalAlignment::Middle;   // [3]
  TextHorizontalAlignment halign = TextHorizontalAlignment::Left; // [4]
Control(std::string const &amp; t) : text(t)      // [5]
  {}
  Control(std::string const &amp; t,
    TextVerticalAlignment const va,
    TextHorizontalAlignment const ha):
    text(t), valign(va), halign(ha)             // [6]
  {}
};
</code></pre>
<h2 class="heading-2" id="_idParaDest-32">How it works...</h2>
<p class="normal">Non-static data members<a id="_idIndexMarker033"/> are supposed to be initialized in the constructor’s initializer list, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">struct Point
{
  double x, y;
  Point(double const x = 0.0, double const y = 0.0) : x(x), y(y)  {}
};
</code></pre>
<p class="normal">Many developers, however, do not use the initializer list and prefer assignments in the constructor’s body, or even mix assignments and the initializer list. That could be for several reasons—for large classes with many members, the constructor assignments may be easier to read than long initializer lists, perhaps split into many lines, or it could be because these developers are familiar with other programming languages that don’t have an initializer list. </p>
<div><p class="normal">It is important to note that the order in which non-static data members are initialized is the order in which they were declared in the class definition, not the order of their initialization in a constructor initializer list. Conversely, the order in which non-static data members are destroyed is the reversed order of construction.</p>
</div>
<p class="normal">Using assignments in the constructor is not efficient, as this can create temporary objects that are later discarded. If not initialized in the initializer list, non-static members are initialized via their default constructor and then, when assigned a value in the constructor’s body, the assignment operator is invoked. This can lead to inefficient work if the default constructor allocates a resource (such as memory or a file) and that has to be deallocated and reallocated in the assignment operator. This is exemplified in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">struct foo
{
  foo()
  { std::cout &lt;&lt; "default constructor\n"; }
  foo(std::string const &amp; text)
  { std::cout &lt;&lt; "constructor '" &lt;&lt; text &lt;&lt; "\n"; }
  foo(foo const &amp; other)
  { std::cout &lt;&lt; "copy constructor\n"; }
  foo(foo&amp;&amp; other)
  { std::cout &lt;&lt; "move constructor\n"; };
  foo&amp; operator=(foo const &amp; other)
  { std::cout &lt;&lt; "assignment\n"; return *this; }
  foo&amp; operator=(foo&amp;&amp; other)
  { std::cout &lt;&lt; "move assignment\n"; return *this;}
  ~foo()
  { std::cout &lt;&lt; "destructor\n"; }
};
struct bar
{
  foo f;
  bar(foo const &amp; value)
  {
    f = value;
  }
};
foo f;
bar b(f);
</code></pre>
<p class="normal">The preceding <a id="_idIndexMarker034"/>code produces the following output, showing how the data member <code class="inlineCode">f</code> is first default initialized and then assigned a new value:</p>
<pre class="programlisting con"><code class="hljs-con">default constructor
default constructor
assignment
destructor
destructor
</code></pre>
<p class="normal">If you want to track which object was created and destroyed, you can slightly change the <code class="inlineCode">foo</code> class above and print the value of the <code class="inlineCode">this</code> pointer for each of the special member functions. You can do this as a follow-up exercise.</p>
<p class="normal">Changing the initialization from the assignment in the constructor body to the initializer list replaces the calls to the default constructor, plus the assignment operator, with a call to the copy constructor:</p>
<pre class="programlisting code"><code class="hljs-code">bar(foo const &amp; value) : f(value) { }
</code></pre>
<p class="normal">Adding the preceding line of code produces the following output:</p>
<pre class="programlisting con"><code class="hljs-con">default constructor
copy constructor
destructor
destructor
</code></pre>
<p class="normal">For those reasons, at <a id="_idIndexMarker035"/>least for types other than the built-in types (such as <code class="inlineCode">bool</code>, <code class="inlineCode">char</code>, <code class="inlineCode">int</code>, <code class="inlineCode">float</code>, <code class="inlineCode">double</code>, or pointers), you should prefer the constructor initializer list. However, to be consistent with your initialization style, you should always prefer the constructor initializer list when possible. There are several situations when using the initializer list is not possible; these include the following cases (but the list could be expanded for other cases):</p>
<ul>
<li class="bulletList">If a member has to be initialized with a pointer or reference to the object that contains it, using the <code class="inlineCode">this</code> pointer in the initialization list may trigger a warning with some compilers that it should be used before the object is constructed.</li>
<li class="bulletList">If you have two data members that must contain references to each other.</li>
<li class="bulletList">If you want to test an input parameter and throw an exception before initializing a non-static data member with the value of the parameter.</li>
</ul>
<p class="normal">Starting with C++11, non-static data members can be initialized when declared in the class. This is called <em class="italic">default member initialization</em> because it is supposed to represent initialization with default values. Default member initialization is intended for constants and members that are not initialized based on constructor parameters (in other words, members whose value does not depend on the way the object is constructed):</p>
<pre class="programlisting code"><code class="hljs-code">enum class TextFlow { LeftToRight, RightToLeft };
struct Control
{
  const int DefaultHeight = 20;
  const int DefaultWidth = 100;
  TextFlow textFlow = TextFlow::LeftToRight;
  std::string text;
  Control(std::string const &amp; t) : text(t)
  {}
};
</code></pre>
<p class="normal">In the preceding example, <code class="inlineCode">DefaultHeight</code> and <code class="inlineCode">DefaultWidth</code> are both constants; therefore, the values do not depend on the way the object is constructed, so they are initialized when declared. The <code class="inlineCode">textFlow</code> object is a non-constant, non-static data member whose value also does not depend on the way the object is initialized (it could be changed via another member function); therefore, it is also initialized using default member initialization when it is declared. <code class="inlineCode">text</code>, conversely, is also a non-constant non-static data member, but its initial value depends on the way the object is constructed.</p>
<p class="normal">Therefore, it is initialized in the constructor’s initializer list using a value passed as an argument to the constructor.</p>
<p class="normal">If a data member<a id="_idIndexMarker036"/> is initialized both with the default member initialization and constructor initializer list, the latter takes precedence and the default value is discarded. To exemplify this, let’s again consider the <code class="inlineCode">foo</code> class mentioned earlier and the following <code class="inlineCode">bar</code> class, which uses it:</p>
<pre class="programlisting code"><code class="hljs-code">struct bar
{
  foo f{"default value"};
  bar() : f{"constructor initializer"}
  {
  }
};
bar b;
</code></pre>
<p class="normal">In this case, the output differs as follows:</p>
<pre class="programlisting con"><code class="hljs-con">constructor 'constructor initializer'
destructor
</code></pre>
<p class="normal">The reason for the different behavior is that the value from the default initializer list is discarded, and the <a id="_idIndexMarker037"/>object is not initialized twice.</p>
<h2 class="heading-2" id="_idParaDest-33">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Understanding uniform initialization</em>, to see how brace-initialization works</li>
</ul>
<h1 class="heading-1" id="_idParaDest-34">Controlling and querying object alignment</h1>
<p class="normal">C++11 provides <a id="_idIndexMarker038"/>standardized methods for specifying and querying the alignment<a id="_idIndexMarker039"/> requirements of a type (something that was previously possible only through compiler-specific methods). Controlling the alignment is important in order to boost performance on different processors and enable the use of some instructions that only work with data on particular alignments.</p>
<p class="normal">For example, Intel <strong class="keyWord">Streaming SIMD Extensions</strong> (<strong class="keyWord">SSE</strong>) and <a id="_idIndexMarker040"/>Intel SSE2, which are a set of processor instructions that can greatly increase performance when the same operations are to be applied on multiple data objects, require 16 bytes of alignment of data. Conversely, for <strong class="keyWord">Intel Advanced Vector Extensions</strong> (or <strong class="keyWord">Intel AVX</strong>), which <a id="_idIndexMarker041"/>expands most integer processor commands to 256 bits, it is highly recommended to use 32-byte alignment. This recipe explores the <code class="inlineCode">alignas</code> specifier for controlling the alignment requirements and the <code class="inlineCode">alignof</code> operator, which retrieves the alignment requirements of a type.</p>
<h2 class="heading-2" id="_idParaDest-35">Getting ready</h2>
<p class="normal">You should be familiar with what data alignment is and the way the compiler performs default data alignment. However, basic information about the latter is provided in the <em class="italic">How it works...</em> section.</p>
<h2 class="heading-2" id="_idParaDest-36">How to do it...</h2>
<ul>
<li class="bulletList">To control the alignment of a type (both at the class level or data member level) or an object, use the <code class="inlineCode">alignas</code> specifier:
        <pre class="programlisting code"><code class="hljs-code">struct alignas(4) foo
{
  char a;
  char b;
};
struct bar
{
  alignas(2) char a;
  alignas(8) int  b;
};
alignas(8)   int a;
alignas(256) long b[4];
</code></pre>
</li>
<li class="bulletList">To query the alignment of a type, use the <code class="inlineCode">alignof</code> operator:
        <pre class="programlisting code"><code class="hljs-code">auto align = alignof(foo);
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-37">How it works...</h2>
<p class="normal">Processors<a id="_idIndexMarker042"/> do not access memory one byte at a time but in larger<a id="_idIndexMarker043"/> chunks of powers of two (2, 4, 8, 16, 32, and so on). Owing to this, it is important that compilers align data in memory so that it can be easily accessed by the processor. Should this data be misaligned, the compiler has to do extra work to access data; it has to read multiple chunks of data, shift and discard unnecessary bytes, and combine the rest.</p>
<p class="normal">C++ compilers align variables based on the size of their data type. The standard only specifies the sizes of <code class="inlineCode">char</code>, <code class="inlineCode">signed char</code>, <code class="inlineCode">unsigned char</code>, <code class="inlineCode">char8_t</code> (introduced in C++20), and <code class="inlineCode">std::byte</code> (introduced in C++17), which must be 1. It also requires that the size of <code class="inlineCode">short</code> must be at least 16 bits, the size of <code class="inlineCode">long</code> must be at least 32 bits, and the size of <code class="inlineCode">long long</code> must be at least 64 bits. It also requires that 1 == <code class="inlineCode">sizeof(char)</code> &lt;= <code class="inlineCode">sizeof(short)</code> &lt;= <code class="inlineCode">sizeof(int)</code> &lt;= <code class="inlineCode">sizeof(long)</code> &lt;= <code class="inlineCode">sizeof(long long)</code>. Therefore, the size of most types is compiler-specific and may depend on the platform. Typically, these are 1 byte for <code class="inlineCode">bool</code> and <code class="inlineCode">char</code>, 2 bytes for <code class="inlineCode">short</code>, 4 bytes for <code class="inlineCode">int</code>, <code class="inlineCode">long</code>, and <code class="inlineCode">float</code>, 8 bytes for <code class="inlineCode">double</code> and <code class="inlineCode">long long</code>, and so on. When it comes to structures or unions, the alignment must match the size of the largest member in order to avoid performance issues. To exemplify this, let’s consider the following data structures:</p>
<pre class="programlisting code"><code class="hljs-code">struct foo1 // size = 1, alignment = 1
{              // foo1:    +-+
char a;      // members: |a|
};
struct foo2 // size = 2, alignment = 1
{              // foo2:    +-+-+
char a;      // members  |a|b|
char b;
};
struct foo3 // size = 8, alignment = 4
{              // foo3:    +----+----+
char a;      // members: |a...|bbbb|
int  b;      // . represents a byte of padding
};
</code></pre>
<p class="normal"><code class="inlineCode">foo1</code> and <code class="inlineCode">foo2</code> are <a id="_idIndexMarker044"/>different sizes, but the alignment is the same—that is, 1—because <a id="_idIndexMarker045"/>all data members are of the type <code class="inlineCode">char</code>, which has a size of 1 byte. In the structure <code class="inlineCode">foo3</code>, the second member is an integer, whose size is 4. As a result, the alignment of members of this structure is done at addresses that are multiples of 4. To achieve this, the compiler introduces padding bytes.</p>
<p class="normal">The structure <code class="inlineCode">foo3</code> is actually transformed into the following:</p>
<pre class="programlisting code"><code class="hljs-code">struct foo3_
{
  char a;        // 1 byte
char _pad0[3]; // 3 bytes padding to put b on a 4-byte boundary
int  b;        // 4 bytes
};
</code></pre>
<p class="normal">Similarly, the following structure has a size of 32 bytes and an alignment of 8; this is because the largest member is a <code class="inlineCode">double</code> whose size is 8. This structure, however, requires padding in several places to make sure that all the members can be accessed at addresses that are multiples of 8:</p>
<pre class="programlisting code"><code class="hljs-code">struct foo4 // size = 24, alignment = 8
{               // foo4:    +--------+--------+--------+--------+
int a;        // members: |aaaab...|cccc....|dddddddd|e.......|
char b;       // . represents a byte of padding
float c;
  double d;
  bool e;
};
</code></pre>
<p class="normal">The equivalent structure that’s created by the compiler is as follows:</p>
<pre class="programlisting code"><code class="hljs-code">struct foo4_
{
  int a;         // 4 bytes
char b;        // 1 byte
char _pad0[3]; // 3 bytes padding to put c on a 8-byte boundary
float c;       // 4 bytes
char _pad1[4]; // 4 bytes padding to put d on a 8-byte boundary
double d;      // 8 bytes
bool e;        // 1 byte
char _pad2[7]; // 7 bytes padding to make sizeof struct multiple of 8
};
</code></pre>
<p class="normal">In C++11, specifying <a id="_idIndexMarker046"/>the alignment of an object or type is done using <a id="_idIndexMarker047"/>the <code class="inlineCode">alignas</code> specifier. This can take either an expression (an integral constant expression that evaluates to <code class="inlineCode">0</code> or a valid value for an alignment), a type-id, or a parameter pack. The <code class="inlineCode">alignas</code> specifier can be applied to the declaration of a variable or a class data member that does not represent a bit field, or to the declaration of a class, union, or enumeration.</p>
<p class="normal">The type or object on which an <code class="inlineCode">alignas</code> specification is applied will have the alignment requirement equal to the largest, greater than zero, expression of all <code class="inlineCode">alignas</code> specifications used in the declaration.</p>
<p class="normal">There are several restrictions when using the <code class="inlineCode">alignas</code> specifier:</p>
<ul>
<li class="bulletList">The only valid alignments are the powers of two (1, 2, 4, 8, 16, 32, and so on). Any other values are illegal, and the program is considered ill-formed; that doesn’t necessarily have to produce an error, as the compiler may choose to ignore the specification.</li>
<li class="bulletList">An alignment of 0 is always ignored.</li>
<li class="bulletList">If the largest <code class="inlineCode">alignas</code> on a declaration is smaller than the natural alignment without any <code class="inlineCode">alignas</code> specifier, then the program is also considered ill-formed.</li>
</ul>
<p class="normal">In the following example, the <code class="inlineCode">alignas</code> specifier has been applied to a class declaration. The natural alignment without the <code class="inlineCode">alignas</code> specifier would have been 1, but with <code class="inlineCode">alignas(4)</code>, it becomes 4:</p>
<pre class="programlisting code"><code class="hljs-code">struct alignas(4) foo
{
  char a;
  char b;
};
</code></pre>
<p class="normal">In other words, the compiler transforms the preceding class into the following:</p>
<pre class="programlisting code"><code class="hljs-code">struct foo
{
  char a;
  char b;
  char _pad0[2];
};
</code></pre>
<p class="normal">The <code class="inlineCode">alignas</code> specifier can <a id="_idIndexMarker048"/>be applied both to the class declaration and the member <a id="_idIndexMarker049"/>data declarations. In this case, the strictest (that is, largest) value wins. In the following example, member <code class="inlineCode">a</code> has a natural size of 1 and requires an alignment of 2; member <code class="inlineCode">b</code> has a natural size of 4 and requires an alignment of 8, so the strictest alignment would be 8. The alignment requirement of the entire class is 4, which is weaker (that is, smaller) than the strictest required alignment, and therefore, it will be ignored, although the compiler will produce a warning:</p>
<pre class="programlisting code"><code class="hljs-code">struct alignas(4) foo
{
  alignas(2) char a;
  alignas(8) int  b;
};
</code></pre>
<p class="normal">The result is a structure that looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">struct foo
{
  char a;
  char _pad0[7];
  int b;
  char _pad1[4];
};
</code></pre>
<p class="normal">The <code class="inlineCode">alignas</code> specifier can also be applied to variables. In the following example, variable <code class="inlineCode">a</code>, which is an integer, is required to be placed in memory at a multiple of 8. The next variable, the array of 4 longs, is required to be placed in memory at a multiple of 256. As a result, the compiler will introduce up to 244 bytes of padding between the two variables (depending on where in memory, at an address multiple of 8, variable <code class="inlineCode">a</code> is located):</p>
<pre class="programlisting code"><code class="hljs-code">alignas(8)   int a;
alignas(256) long b[4];
printf("%p\n", &amp;a); // eg. 0000006C0D9EF908
printf("%p\n", &amp;b); // eg. 0000006C0D9EFA00
</code></pre>
<p class="normal">Looking at the addresses, we can see that the address of <code class="inlineCode">a</code> is indeed a multiple of 8, and that the address of <code class="inlineCode">b</code> is a multiple of 256 (hexadecimal 100).</p>
<p class="normal">To query the <a id="_idIndexMarker050"/>alignment of a type, we use the <code class="inlineCode">alignof</code> operator. Unlike <code class="inlineCode">sizeof</code>, this operator can only be applied to types, not to variables or class data <a id="_idIndexMarker051"/>members. The types it can be applied to are complete types, array types, or reference types. For arrays, the value that’s returned is the alignment of the element type; for references, the value that’s returned is the alignment of the referenced type. Here are several examples:</p>
<table class="table-container" id="table001">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Expression</strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord">Evaluation</strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">alignof(char)</code></p>
</td>
<td class="table-cell">
<p class="normal">1, because the natural alignment of <code class="inlineCode">char</code> is 1</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">alignof(int)</code></p>
</td>
<td class="table-cell">
<p class="normal">4, because the natural alignment of <code class="inlineCode">int</code> is 4</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">alignof(int*)</code></p>
</td>
<td class="table-cell">
<p class="normal">4 on 32-bit and 8 on 64-bit, the alignment for pointers</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">alignof(int[4])</code></p>
</td>
<td class="table-cell">
<p class="normal">4, because the natural alignment of the element type is 4</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode">alignof(foo&amp;)</code></p>
</td>
<td class="table-cell">
<p class="normal">8, because the specified alignment for the class <code class="inlineCode">foo</code>, which is the reference type (as shown in the previous example), was 8</p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref">Table 1.1: Examples of alignof expressions and their evaluated value</p>
<p class="normal">The <code class="inlineCode">alignas</code> specifier is useful if you wish to force an alignment for a data type (taking into consideration the restriction mentioned previously) so that variables of that type can be accessed and copied efficiently. This means optimizing CPU reads and writes and avoiding unnecessary invalidation from cache lines. </p>
<p class="normal">This can be highly important in some categories of applications where performance is key, such as games or trading applications. Conversely, the <code class="inlineCode">alignof</code> operator retries the minimum alignment requirement of a specified type.</p>
<h2 class="heading-2" id="_idParaDest-38">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Creating type aliases and alias templates</em>, to learn about aliases for types</li>
</ul>
<h1 class="heading-1" id="_idParaDest-39">Using scoped enumerations</h1>
<p class="normal">Enumeration<a id="_idIndexMarker052"/> is a basic type in C++ that defines a collection of values, always of an integral underlying type. Their named values, which are constant, are called enumerators. Enumerations declared with the keyword <code class="inlineCode">enum</code> are called <em class="italic">unscoped enumerations</em>, while enumerations declared with <code class="inlineCode">enum class</code> or <code class="inlineCode">enum struct</code> are called <em class="italic">scoped enumerations</em>. The latter ones were introduced in C++11 and are intended to solve several problems with unscoped enumerations, which are explained in this recipe.</p>
<h2 class="heading-2" id="_idParaDest-40">How to do it...</h2>
<p class="normal">When <a id="_idIndexMarker053"/>working with enumerations, you should:</p>
<ul>
<li class="bulletList">Prefer to use scoped enumerations instead of unscoped ones</li>
<li class="bulletList">Declare scoped enumerations using <code class="inlineCode">enum class</code> or <code class="inlineCode">enum struct</code>:
        <pre class="programlisting code"><code class="hljs-code">enum class Status { Unknown, Created, Connected };
Status s = Status::Created;
</code></pre>
</li>
</ul>
<div><p class="normal">The <code class="inlineCode">enum class</code> and <code class="inlineCode">enum struct</code> declarations are equivalent, and throughout this recipe and the rest of this book, we will use <code class="inlineCode">enum class</code>.</p>
</div>
<p class="normal">Because scope enumerations are restricted namespaces, the C++20 standard allows us to associate them with a <code class="inlineCode">using</code> directive. You can do the following:</p>
<ul>
<li class="bulletList">Introduce a scoped enumeration identifier in the local scope with a <code class="inlineCode">using</code> directive, as follows:
        <pre class="programlisting code"><code class="hljs-code">int main()
{
  using Status::Unknown;
  Status s = Unknown;
}
</code></pre>
</li>
<li class="bulletList">Introduce all the identifiers of a scoped enumeration in the local scope with a <code class="inlineCode">using</code> directive, as follows:
        <pre class="programlisting code"><code class="hljs-code">struct foo
{
  enum class Status { Unknown, Created, Connected };
  using enum Status;
};
foo::Status s = foo::Created; // instead of
// foo::Status::Created
</code></pre>
</li>
<li class="bulletList">Use a <code class="inlineCode">using enum</code> directive to introduce the enum identifiers in a <code class="inlineCode">switch</code> statement to simplify your code:
        <pre class="programlisting code"><code class="hljs-code">void process(Status const s)
{
  switch (s)
  {
    using enum Status;
    case Unknown:   /*…*/ break;
    case Created:   /*...*/ break;
    case Connected: /*...*/ break;
  }
}
</code></pre>
</li>
</ul>
<p class="normal">Converting a scoped enumeration to its underlying type is sometimes necessary, especially in the context of using old-style APIs that take integers as arguments. In C++23, you can convert to the<a id="_idIndexMarker054"/> underlying type of a scoped enumeration by using the <code class="inlineCode">std::to_underlying()</code> utility function:</p>
<pre class="programlisting code"><code class="hljs-code">void old_api(unsigned flag);
enum class user_rights : unsigned
{
    None, Read = 1, Write = 2, Delete = 4
};
old_api(std::to_underlying(user_rights::Read));
</code></pre>
<h2 class="heading-2" id="_idParaDest-41">How it works...</h2>
<p class="normal">Unscoped enumerations<a id="_idIndexMarker055"/> have several issues that create problems for developers:</p>
<ul>
<li class="bulletList">They export their enumerators to the surrounding scope (for which reason, they are called unscoped enumerations), and that has the following two drawbacks:<ul>
<li class="bulletList">It can lead to name clashes if two enumerations in the same namespace have enumerators with the same name</li>
<li class="bulletList">It’s not possible to use an enumerator using its fully qualified name:
            <pre class="programlisting code"><code class="hljs-code">enum Status {Unknown, Created, Connected};
enum Codes {OK, Failure, Unknown};   // error
auto status = Status::Created;       // error
</code></pre>
</li>
</ul>
</li>
<li class="bulletList">Prior to C++ 11, they <a id="_idIndexMarker056"/>could not specify the underlying type, which is required to be an integral type. This type must not be larger than <code class="inlineCode">int</code>, unless the enumerator value cannot fit a signed or unsigned integer. Owing to this, forward declaration of enumerations was not possible. The reason for this was that the size of the enumeration was not known. This was because the underlying type was not known until the values of the enumerators were defined so that the compiler could pick the appropriate integer type. This has been fixed in C++11.</li>
<li class="bulletList">Values of enumerators implicitly convert to <code class="inlineCode">int</code>. This means you can intentionally or accidentally mix enumerations that have a certain meaning and integers (which may not even be related to the meaning of the enumeration) and the compiler will not be able to warn you:
        <pre class="programlisting code"><code class="hljs-code">enum Codes { OK, Failure };
void include_offset(int pixels) {/*...*/}
include_offset(Failure);
</code></pre>
</li>
</ul>
<p class="normal">The scoped <a id="_idIndexMarker057"/>enumerations are basically strongly typed enumerations that behave differently than the unscoped enumerations:</p>
<ul>
<li class="bulletList">They do not export their enumerators to the surrounding scope. The two enumerations shown earlier would change to the following, no longer generating a name collision and making it possible to fully qualify the names of the enumerators:
        <pre class="programlisting code"><code class="hljs-code">enum class Status { Unknown, Created, Connected };
enum class Codes { OK, Failure, Unknown }; // OK
Codes code = Codes::Unknown;               // OK
</code></pre>
</li>
<li class="bulletList">You can <a id="_idIndexMarker058"/>specify the underlying type. The same rules for underlying types of unscoped enumerations apply to scoped enumerations too, except that the user can explicitly specify the underlying type. This also solves the problem with forward declarations, since the underlying type can be known before the definition is available:
        <pre class="programlisting code"><code class="hljs-code">enum class Codes : unsigned int;
void print_code(Codes const code) {}
enum class Codes : unsigned int
{
  OK = 0,
  Failure = 1,
  Unknown = 0xFFFF0000U
};
</code></pre>
</li>
<li class="bulletList">Values of scoped enumerations no longer convert implicitly to <code class="inlineCode">int</code>. Assigning the value of an <code class="inlineCode">enum class</code> to an integer variable would trigger a compiler error unless an explicit cast is specified:
        <pre class="programlisting code"><code class="hljs-code">Codes c1 = Codes::OK;                       // OK
int c2 = Codes::Failure;                    // error
int c3 = static_cast&lt;int&gt;(Codes::Failure);  // OK
</code></pre>
</li>
</ul>
<p class="normal">However, the scoped enumerations have a drawback: they are restricted namespaces. They do not export the identifiers in the outer scope, which can be inconvenient at times, for instance, if you are writing a <code class="inlineCode">switch</code> and you need to repeat the enumeration name for each case label, as in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">std::string_view to_string(Status const s)
{
  switch (s)
  {
    case Status::Unknown:   return "Unknown";
    case Status::Created:   return "Created";
    case Status::Connected: return "Connected";
  }
}
</code></pre>
<p class="normal">In C++20, this can be simplified with the help of a <code class="inlineCode">using</code> directive with the name of the scoped enumeration. The preceding code can be simplified as follows:</p>
<pre class="programlisting code"><code class="hljs-code">std::string_view to_string(Status const s)
{
  switch (s)
  {
    using enum Status;
    case Unknown:   return "Unknown";
    case Created:   return "Created";
    case Connected: return "Connected";
  }
}
</code></pre>
<p class="normal">The effect of <a id="_idIndexMarker059"/>this <code class="inlineCode">using</code> directive is that all the enumerator identifiers are introduced in the local scope, making it possible to refer to them with the unqualified form. It is also possible to bring only a particular enum identifier to the local scope with a <code class="inlineCode">using</code> directive with the qualified identifier name, such as <code class="inlineCode">using</code> <code class="inlineCode">Status::Connected</code>.</p>
<p class="normal">The C++23 version of the standard adds a couple of utility functions for working with scoped enumerations. The first of these is <code class="inlineCode">std::to_underlying()</code>, available in the <code class="inlineCode">&lt;utility&gt;</code> header. What it does is convert an enumeration to its underlying type. </p>
<p class="normal">Its purpose is to work with APIs (legacy or not) that don’t use scoped enumerations. Let’s look at an example. Consider the following function, <code class="inlineCode">old_api()</code>, which takes an integer argument, which it interprets as flags controlling user rights, into the system:</p>
<pre class="programlisting code"><code class="hljs-code">void old_api(unsigned flag)
{
    if ((flag &amp; 0x01) == 0x01) { /* can read */ }
    if ((flag &amp; 0x02) == 0x02) { /* can write */ }
    if ((flag &amp; 0x04) == 0x04) { /* can delete */ }
}
</code></pre>
<p class="normal">This function can be invoked as follows:</p>
<pre class="programlisting code"><code class="hljs-code">old_api(1); // read only
old_api(3); // read &amp; write
</code></pre>
<p class="normal">Conversely, a newer part of the system defines the following scoped enumeration for the user rights:</p>
<pre class="programlisting code"><code class="hljs-code">enum class user_rights : unsigned
{
    None,
    Read = 1,
    Write = 2,
    Delete = 4
};
</code></pre>
<p class="normal">However, invoking the <code class="inlineCode">old_api()</code> function with enumerations from <code class="inlineCode">user_rights</code> is not possible, and a <code class="inlineCode">static_cast</code> must be used:</p>
<pre class="programlisting code"><code class="hljs-code">old_api(static_cast&lt;int&gt;(user_rights::Read)); // read only
old_api(static_cast&lt;int&gt;(user_rights::Read) | 
        static_cast&lt;int&gt;(user_rights::Write)); // read &amp; write
</code></pre>
<p class="normal">To avoid these <a id="_idIndexMarker060"/>static casts, C++23 provides the function <code class="inlineCode">std::to_underlying()</code>, which can be used as follows:</p>
<pre class="programlisting code"><code class="hljs-code">old_api(std::to_underlying(user_rights::Read));
old_api(std::to_underlying(user_rights::Read) | 
        std::to_underlying(user_rights::Write));
</code></pre>
<p class="normal">The other utility introduced in C++23 is a type trait called <code class="inlineCode">is_scoped_enum&lt;T&gt;</code>, available in the <code class="inlineCode">&lt;type_traits&gt;</code> header. This contains a member constant called <code class="inlineCode">value</code>, which is equal to <code class="inlineCode">true</code> if the template type parameter <code class="inlineCode">T</code> is a scoped enumeration type, or <code class="inlineCode">false</code> otherwise. There is also a helper variable template, <code class="inlineCode">is_scoped_enum_v&lt;T&gt;</code>. </p>
<p class="normal">The purpose of this type trait is to identify whether an enumeration is scoped or not in order to apply different behavior, depending on the type of the enumeration. Here is a simple example:</p>
<pre class="programlisting code"><code class="hljs-code">enum A {};
enum class B {};
int main()
{
   std::cout &lt;&lt; std::is_scoped_enum_v&lt;A&gt; &lt;&lt; '\n';
   std::cout &lt;&lt; std::is_scoped_enum_v&lt;B&gt; &lt;&lt; '\n';
}
</code></pre>
<p class="normal">The first line will<a id="_idIndexMarker061"/> print 0 because <code class="inlineCode">A</code> is an unscoped enum, while the second line will print <code class="inlineCode">1</code> because <code class="inlineCode">B</code> is a scoped enum.</p>
<h2 class="heading-2" id="_idParaDest-42">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 9</em>, <em class="italic">Creating compile-time constant expressions</em>, to learn how to work with compile-time constants</li>
</ul>
<h1 class="heading-1" id="_idParaDest-43">Using override and final for virtual methods</h1>
<p class="normal">Unlike other<a id="_idIndexMarker062"/> similar programming languages, C++ does not <a id="_idIndexMarker063"/>have a specific syntax for declaring interfaces (which are basically classes with pure virtual methods only) and also has some deficiencies related to<a id="_idIndexMarker064"/> how virtual methods are declared. In C++, the virtual methods are introduced with the <code class="inlineCode">virtual</code> keyword. However, the keyword <code class="inlineCode">virtual</code> is optional for declaring overrides in derived classes, which can lead to confusion when dealing with large classes or hierarchies. You may need to navigate throughout the hierarchy up to the base to figure out whether a function is virtual or not. Conversely, sometimes, it is useful to make sure that a virtual function or even a derived class can no longer be overridden or derived further. In this recipe, we will see how to use the C++11 special identifiers <code class="inlineCode">override</code> and <code class="inlineCode">final</code> to declare virtual functions or classes.</p>
<h2 class="heading-2" id="_idParaDest-44">Getting ready</h2>
<p class="normal">You should be familiar with inheritance and polymorphism in C++ and concepts such as abstract classes, pure specifiers, and virtual and overridden methods.</p>
<h2 class="heading-2" id="_idParaDest-45">How to do it...</h2>
<p class="normal">To ensure the correct declaration of virtual methods both in base and derived classes, also ensuring that you increase readability, do the following:</p>
<ul>
<li class="bulletList">Aim to use the <code class="inlineCode">virtual</code> keyword when declaring virtual functions in derived classes that are supposed to override virtual functions from a base class.</li>
<li class="bulletList">Always use the <code class="inlineCode">override</code> special identifier after the declarator part of a virtual function’s declaration or definition:
        <pre class="programlisting code"><code class="hljs-code">class Base
{
  virtual void foo() = 0;
  virtual void bar() {}
  virtual void foobar() = 0;
};
void Base::foobar() {}
class Derived1 : public Base
{
  virtual void foo() override = 0;
  virtual void bar() override {}
  virtual void foobar() override {}
};
class Derived2 : public Derived1
{
  virtual void foo() override {}
};
</code></pre>
</li>
</ul>
<div><p class="normal">The declarator is the part of the type of a function that excludes the return type.</p>
</div>
<p class="normal">To ensure that <a id="_idIndexMarker065"/>functions cannot be overridden further or that <a id="_idIndexMarker066"/>classes cannot be derived any more, use the <code class="inlineCode">final</code> special<a id="_idIndexMarker067"/> identifier, like this:</p>
<ul>
<li class="bulletList">After the declarator part of a virtual function declaration or definition to prevent further overrides in a derived class:
        <pre class="programlisting code"><code class="hljs-code">class Derived2 : public Derived1
{
  virtual void foo() final {}
};
</code></pre>
</li>
<li class="bulletList">After the name of a class in the declaration of the class to prevent further derivations of the class:
        <pre class="programlisting code"><code class="hljs-code">class Derived4 final : public Derived1
{
  virtual void foo() override {}
};
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-46">How it works...</h2>
<p class="normal">The<a id="_idIndexMarker068"/> way <code class="inlineCode">override</code> works is very simple; in a virtual <a id="_idIndexMarker069"/>function declaration or definition, it ensures that the <a id="_idIndexMarker070"/>function actually overrides a base class function; otherwise, the compiler will trigger an error.</p>
<p class="normal">It should be noted that both the <code class="inlineCode">override</code> and <code class="inlineCode">final</code> special identifiers are special identifiers that have a meaning only in a member function declaration or definition. They are not reserved keywords and can still be used elsewhere in a program as user-defined identifiers.</p>
<p class="normal">Using the <code class="inlineCode">override</code> special identifier helps the compiler detect situations where a virtual method does not override another one, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">class Base
{
public:
  virtual void foo() {}
  virtual void bar() {}
};
class Derived1 : public Base
{
public:
  void foo() override {}
  // for readability use the virtual keyword
virtual void bar(char const c) override {}
  // error, no Base::bar(char const)
};
</code></pre>
<p class="normal">Without the presence of the <code class="inlineCode">override</code> specifier, the virtual <code class="inlineCode">bar(char const)</code> method of the <code class="inlineCode">Derived1</code> class would not be an overridden method but, instead, an overload of the <code class="inlineCode">bar()</code> from <code class="inlineCode">Base</code>.</p>
<p class="normal">The other special identifier, <code class="inlineCode">final</code>, is used in a member function declaration or definition to indicate that the function is virtual and cannot be overridden in a derived class. If a derived class attempts to override the virtual function, the compiler triggers an error:</p>
<pre class="programlisting code"><code class="hljs-code">class Derived2 : public Derived1
{
  virtual void foo() final {}
};
class Derived3 : public Derived2
{
  virtual void foo() override {} // error
};
</code></pre>
<p class="normal">The <code class="inlineCode">final</code> specifier can also be used in a class declaration to indicate that it cannot be derived:</p>
<pre class="programlisting code"><code class="hljs-code">class Derived4 final : public Derived1
{
  virtual void foo() override {}
};
class Derived5 : public Derived4 // error
{
};
</code></pre>
<p class="normal">Since both <code class="inlineCode">override</code> and <code class="inlineCode">final</code> have this special meaning when used in the defined context and<a id="_idIndexMarker071"/> are not, in fact, reserved keywords, you can still use <a id="_idIndexMarker072"/>them anywhere else in the C++ code. This<a id="_idIndexMarker073"/> ensures that existing code written before C++11 does not break because of the use of these names for identifiers:</p>
<pre class="programlisting code"><code class="hljs-code">class foo
{
  int final = 0;
  void override() {}
};
</code></pre>
<p class="normal">Although the recommendation given earlier suggested using both <code class="inlineCode">virtual</code> and <code class="inlineCode">override</code> in the declaration of an overridden virtual method, the <code class="inlineCode">virtual</code> keyword is optional and can be omitted to shorten the declaration. The presence of the <code class="inlineCode">override</code> specifier should be enough to indicate to the reader that the method is virtual. This is rather a matter of personal preference and does not affect the semantics.</p>
<h2 class="heading-2" id="_idParaDest-47">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 10</em>, <em class="italic">Static polymorphism with the curiously recurring template pattern</em>, to learn how the CRTP pattern helps with implementing polymorphism at compile time</li>
</ul>
<h1 class="heading-1" id="_idParaDest-48">Using range-based for loops to iterate on a range</h1>
<p class="normal">Many programming<a id="_idIndexMarker074"/> languages support a variant of a <code class="inlineCode">for</code> loop called <code class="inlineCode">for each</code>—that is, repeating a group of statements over the elements of a collection. C++ did not have core language support for this until C++11. The closest feature was the general-purpose algorithm from the standard library called <code class="inlineCode">std::for_each</code>, which applies a function to all the elements in a range. C++11 brought language support for <code class="inlineCode">for each</code> that’s actually called <em class="italic">range-based for loops</em>. The new C++17 standard provides several improvements to the original language feature.</p>
<h2 class="heading-2" id="_idParaDest-49">Getting ready</h2>
<p class="normal">In C++11, a range-based for loop has the following general syntax:</p>
<pre class="programlisting code"><code class="hljs-code">for ( range_declaration : range_expression ) loop_statement
</code></pre>
<p class="normal">In C++20, an initialization statement (which must end with a semicolon) can be present before the range declaration. Therefore, the general form becomes the following:</p>
<pre class="programlisting code"><code class="hljs-code">for(init-statement range-declaration : range-expression)
loop-statement
</code></pre>
<p class="normal">To exemplify the various ways of using range-based for loops, we will use the following functions, which return sequences of elements:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; getRates()
{
  return std::vector&lt;int&gt; {1, 1, 2, 3, 5, 8, 13};
}
std::multimap&lt;int, bool&gt; getRates2()
{
  return std::multimap&lt;int, bool&gt; {
    { 1, true },
    { 1, true },
    { 2, false },
    { 3, true },
    { 5, true },
    { 8, false },
    { 13, true }
  };
}
</code></pre>
<p class="normal">In the next section, we’ll look at the various ways we can use range-based for loops.</p>
<h2 class="heading-2" id="_idParaDest-50">How to do it...</h2>
<p class="normal">Range-based <a id="_idIndexMarker075"/>for loops can be used in various ways:</p>
<ul>
<li class="bulletList">By committing to a specific type for the elements of the sequence:
        <pre class="programlisting code"><code class="hljs-code">auto rates = getRates();
for (int rate : rates)
  std::cout &lt;&lt; rate &lt;&lt; '\n';
for (int&amp; rate : rates)
  rate *= 2;
</code></pre>
</li>
<li class="bulletList">By not specifying a type and letting the compiler deduce it:
        <pre class="programlisting code"><code class="hljs-code">for (auto&amp;&amp; rate : getRates())
  std::cout &lt;&lt; rate &lt;&lt; '\n';
for (auto &amp; rate : rates)
  rate *= 2;
for (auto const &amp; rate : rates)
  std::cout &lt;&lt; rate &lt;&lt; '\n';
</code></pre>
</li>
<li class="bulletList">By using structured bindings and decomposition declaration in C++17:
        <pre class="programlisting code"><code class="hljs-code">for (auto&amp;&amp; [rate, flag] : getRates2())
  std::cout &lt;&lt; rate &lt;&lt; '\n';
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-51">How it works...</h2>
<p class="normal">The <a id="_idIndexMarker076"/>expression for the range-based for loops shown earlier in the <em class="italic">How to do it...</em> section is basically syntactic sugar, as the compiler transforms it into something else. Before C++17, the code generated by the compiler used to be the following:</p>
<pre class="programlisting code"><code class="hljs-code">{
  auto &amp;&amp; __range = range_expression;
  for (auto __begin = begin_expr, __end = end_expr;
  __begin != __end; ++__begin) {
    range_declaration = *__begin;
    loop_statement
  }
}
</code></pre>
<p class="normal">What <code class="inlineCode">begin_expr</code> and <code class="inlineCode">end_expr</code> are in this code depends on the type of the range:</p>
<ul>
<li class="bulletList">For C-like arrays: <code class="inlineCode">__range</code> and <code class="inlineCode">__range + __bound</code> (where <code class="inlineCode">__bound</code> is the number of elements in the array).</li>
<li class="bulletList">For a class type with <code class="inlineCode">begin</code> and <code class="inlineCode">end</code> members (regardless of their type and accessibility): <code class="inlineCode">__range.begin()</code> and <code class="inlineCode">__range.end()</code>.</li>
<li class="bulletList">For others, it is <code class="inlineCode">begin(__range)</code> and <code class="inlineCode">end(__range)</code>, which are determined via argument-dependent lookup.</li>
</ul>
<p class="normal">It is important to note that if a class contains any members (function, data member, or enumerators) called <code class="inlineCode">begin</code> or <code class="inlineCode">end</code>, regardless of their type and accessibility, they will be picked for <code class="inlineCode">begin_expr</code> and <code class="inlineCode">end_expr</code>. Therefore, such a class type cannot be used in range-based for loops.</p>
<p class="normal">In C++17, the code generated by the compiler is slightly different:</p>
<pre class="programlisting code"><code class="hljs-code">{
  auto &amp;&amp; __range = range_expression;
  auto __begin = begin_expr;
  auto __end = end_expr;
  for (; __begin != __end; ++__begin) {
    range_declaration = *__begin;
    loop_statement
  }
}
</code></pre>
<p class="normal">The new <a id="_idIndexMarker077"/>standard has removed the constraint that the <code class="inlineCode">begin</code> expression and the <code class="inlineCode">end</code> expression must be the same type. The end expression does not need to be an actual iterator, but it has to be able to be compared for inequality with an iterator. A benefit of this is that the range can be delimited by a predicate. Conversely, the <code class="inlineCode">end</code> expression is only evaluated once, and not every time the loop is iterated, which could potentially increase performance.</p>
<p class="normal">As mentioned in the previous section, in C++20, an initialization statement can be present before the range declaration. This has the effect that the compiler-generated code for a range-based for loop has the following form:</p>
<pre class="programlisting code"><code class="hljs-code">{
  init-statement
  auto &amp;&amp; __range = range_expression;
  auto __begin = begin_expr;
  auto __end = end_expr;
  for (; __begin != __end; ++__begin) {
    range_declaration = *__begin;
    loop_statement
  }
}
</code></pre>
<p class="normal">The initialization statement can be an empty statement, an expression statement, a simple declaration, or, starting with C++23, an alias declaration. An example is shown in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">for (auto rates = getRates(); int rate : rates)
{
   std::cout &lt;&lt; rate &lt;&lt; '\n';
}
</code></pre>
<p class="normal">Prior to C++23, this was helpful to avoid undefined behavior with temporaries in range expressions. The lifetime of a temporary returned by the <code class="inlineCode">range-expression</code> is extended until the end of the loop. However, the lifetime of temporaries within the <code class="inlineCode">range-expression</code> is not extended if they will be destroyed at the end of <code class="inlineCode">range-expression</code>.</p>
<p class="normal">We will explain this with the help of the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">struct item
{
   std::vector&lt;int&gt; getRates()
 {
      return std::vector&lt;int&gt; {1, 1, 2, 3, 5, 8, 13};
   }
};
item make_item()
{
   return item{};
}
// undefined behavior, until C++23
for (int rate : make_item().getRates())
{
   std::cout &lt;&lt; rate &lt;&lt; '\n';
} 
</code></pre>
<p class="normal">Since <code class="inlineCode">make_item()</code> returns by value, we have a temporary within <code class="inlineCode">range-expression</code>. This introduces undefined behavior, which can be avoided with an initialization statement, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">for (auto item = make_item(); int rate : item.getRates())
{
   std::cout &lt;&lt; rate &lt;&lt; '\n';
}
</code></pre>
<p class="normal">This problem <a id="_idIndexMarker078"/>no longer manifests in C++23, because this version of the standard also extends the lifetime of all the temporaries within the <code class="inlineCode">range-expression</code> until the end of the loop.</p>
<h2 class="heading-2" id="_idParaDest-52">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Enabling range-based for loops for custom types</em>, to see how to make it possible for user-defined types to be used with range-based for loops</li>
<li class="bulletList"><em class="chapterRef">Chapter 12</em>, <em class="italic">Iterating over collections with the ranges library</em>, to learn about the fundamentals of the C++20 ranges library</li>
<li class="bulletList"><em class="chapterRef">Chapter 12</em>, <em class="italic">Creating your own range view</em>, to see how to extend the C++20 range library’s capabilities with user-defined range adaptors</li>
</ul>
<h1 class="heading-1" id="_idParaDest-53">Enabling range-based for loops for custom types</h1>
<p class="normal">As we saw in the<a id="_idIndexMarker079"/> preceding recipe, range-based <a id="_idIndexMarker080"/>for loops, known as <code class="inlineCode">for each</code> in other programming languages, allow you to iterate over the elements of a range, providing a simplified syntax over the standard <code class="inlineCode">for</code> loops and making the code more readable in many situations. However, range-based for loops do not work out of the box with any type representing a range, but require the presence of <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code> functions (for non-array types), either as a member or free function. In this recipe, we will learn how to enable a custom type to be used in range-based for loops.</p>
<h2 class="heading-2" id="_idParaDest-54">Getting ready</h2>
<p class="normal">It is recommended that you read the <em class="italic">Using range-based for loops to iterate on a range</em> recipe before continuing with this one if you need to understand how range-based for loops work, as well as what code the compiler generates for such a loop.</p>
<p class="normal">To show how we can enable range-based for loops for custom types representing sequences, we will use the following implementation of a simple array:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T, size_t const Size&gt;
class dummy_array
{
  T data[Size] = {};
public:
  T const &amp; GetAt(size_t const index) const
 {
    if (index &lt; Size) return data[index];
    throw std::out_of_range("index out of range");
  }
  void SetAt(size_t const index, T const &amp; value)
 {
    if (index &lt; Size) data[index] = value;
    else throw std::out_of_range("index out of range");
  }
  size_t GetSize() const { return Size; }
};
</code></pre>
<p class="normal">The purpose of this recipe is to enable writing code like the following:</p>
<pre class="programlisting code"><code class="hljs-code">dummy_array&lt;int, 3&gt; arr;
arr.SetAt(0, 1);
arr.SetAt(1, 2);
arr.SetAt(2, 3);
for(auto&amp;&amp; e : arr)
{
  std::cout &lt;&lt; e &lt;&lt; '\n';
}
</code></pre>
<p class="normal">The steps necessary to make all this possible are described in detail in the following section.</p>
<h2 class="heading-2" id="_idParaDest-55">How to do it...</h2>
<p class="normal">To enable a<a id="_idIndexMarker081"/> custom type to be used in range-based <code class="inlineCode">for</code> loops, you<a id="_idIndexMarker082"/> need to do the following:</p>
<ul>
<li class="bulletList">Create mutable and constant iterators for the type, which must implement the following operators:<ul>
<li class="bulletList"><code class="inlineCode">operator++</code> (both the prefix and the postfix version) for incrementing the iterator</li>
<li class="bulletList"><code class="inlineCode">operator*</code> for dereferencing the iterator and accessing the actual element being pointed to by the iterator</li>
<li class="bulletList"><code class="inlineCode">operator!=</code> for comparing the iterator with another iterator for inequality</li>
</ul>
</li>
<li class="bulletList">Provide free <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code> functions for the type.</li>
</ul>
<p class="normal">Given the earlier example of a simple range, we need to provide the following:</p>
<ul>
<li class="bulletList">The following minimal implementation of an iterator class:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T, typename C, size_t const Size&gt;
class dummy_array_iterator_type
{
public:
  dummy_array_iterator_type(C&amp; collection,
                            size_t const index) :
  index(index), collection(collection)
  { }
  bool operator!= (dummy_array_iterator_type const &amp; other) const
  {
    return index != other.index;
  }
  T const &amp; operator* () const
  {
    return collection.GetAt(index);
  }
  dummy_array_iterator_type&amp; operator++()
  {
    ++index;
    return *this;
  }
  dummy_array_iterator_type operator++(int)
  {
    auto temp = *this;
    ++*this;
    return temp;
  }
private:
  size_t   index;
  C&amp;       collection;
};
</code></pre>
</li>
<li class="bulletList">Alias<a id="_idIndexMarker083"/> templates for mutable and <a id="_idIndexMarker084"/>constant iterators:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T, size_t const Size&gt;
using dummy_array_iterator =
  dummy_array_iterator_type&lt;
    T, dummy_array&lt;T, Size&gt;, Size&gt;;
template &lt;typename T, size_t const Size&gt;
using dummy_array_const_iterator =
  dummy_array_iterator_type&lt;
    T, dummy_array&lt;T, Size&gt; const, Size&gt;;
</code></pre>
</li>
<li class="bulletList">Free <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code> functions that return the respective begin and end iterators, with overloads for both alias templates:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T, size_t const Size&gt;
inline dummy_array_iterator&lt;T, Size&gt; begin(
  dummy_array&lt;T, Size&gt;&amp; collection)
{
  return dummy_array_iterator&lt;T, Size&gt;(collection, 0);
}
template &lt;typename T, size_t const Size&gt;
inline dummy_array_iterator&lt;T, Size&gt; end(
  dummy_array&lt;T, Size&gt;&amp; collection)
{
  return dummy_array_iterator&lt;T, Size&gt;(
    collection, collection.GetSize());
}
template &lt;typename T, size_t const Size&gt;
inline dummy_array_const_iterator&lt;T, Size&gt; begin(
  dummy_array&lt;T, Size&gt; const &amp; collection)
{
  return dummy_array_const_iterator&lt;T, Size&gt;(
    collection, 0);
}
template &lt;typename T, size_t const Size&gt;
inline dummy_array_const_iterator&lt;T, Size&gt; end(
  dummy_array&lt;T, Size&gt; const &amp; collection)
{
  return dummy_array_const_iterator&lt;T, Size&gt;(
    collection, collection.GetSize());
}
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-56">How it works...</h2>
<p class="normal">Having this<a id="_idIndexMarker085"/> implementation available, the range-based<a id="_idIndexMarker086"/> for loop shown earlier compiles and executes as expected. When performing an argument-dependent lookup, the compiler will identify the two <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code> functions that we wrote (which take a reference to a <code class="inlineCode">dummy_array</code>), and therefore, the code it generates becomes valid.</p>
<p class="normal">In the preceding example, we have defined one iterator class template and two alias templates, called <code class="inlineCode">dummy_array_iterator</code> and <code class="inlineCode">dummy_array_const_iterator</code>. The <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code> functions both have two overloads for these two types of iterators.</p>
<p class="normal">This is necessary so that the container we have considered can be used in range-based for loops with both constant and non-constant instances:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T, const size_t Size&gt;
void print_dummy_array(dummy_array&lt;T, Size&gt; const &amp; arr)
{
  for (auto &amp;&amp; e : arr)
  {
    std::cout &lt;&lt; e &lt;&lt; '\n';
  }
}
</code></pre>
<p class="normal">A possible <a id="_idIndexMarker087"/>alternative to enable range-based for <a id="_idIndexMarker088"/>loops for the simple range class we considered for this recipe is to provide the member <code class="inlineCode">begin()</code> and <code class="inlineCode">end()</code> functions. In general, that will make sense only if you own and can modify the source code. Conversely, the solution shown in this recipe works in all cases and should be preferred to other alternatives.</p>
<h2 class="heading-2" id="_idParaDest-57">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Creating type aliases and alias templates</em>, to learn about aliases for types</li>
<li class="bulletList"><em class="chapterRef">Chapter 12</em>, <em class="italic">Iterating over collections with the ranges library</em>, to learn about the fundamentals of the C++20 ranges library</li>
</ul>
<h1 class="heading-1" id="_idParaDest-58">Using explicit constructors and conversion operators to avoid implicit conversion</h1>
<p class="normal">Before C++11, a constructor<a id="_idIndexMarker089"/> with a single parameter was considered a converting constructor (because it takes a value of another type and creates a new instance of the class out of it). With C++11, every constructor without the <code class="inlineCode">explicit</code> specifier is considered a converting constructor. This is important because such a constructor defines an implicit conversion from the type or types of its arguments to the type of the class. Classes can also define converting operators that convert the type of the class to another specified type. All of these are useful in some cases but can create problems in other cases. In this recipe, we will learn how to use explicit constructors and conversion operators.</p>
<h2 class="heading-2" id="_idParaDest-59">Getting ready</h2>
<p class="normal">For this recipe, you<a id="_idIndexMarker090"/> need to be familiar with converting constructors and converting operators. In this recipe, you will learn how to write explicit constructors and conversion operators to avoid implicit conversions to and from a type. The use of explicit constructors and conversion operators (called <em class="italic">user-defined conversion functions</em>) enables the compiler to yield errors—which, in some cases, are coding errors—and allow developers to spot those errors quickly and fix them.</p>
<h2 class="heading-2" id="_idParaDest-60">How to do it...</h2>
<p class="normal">To declare explicit constructors and explicit conversion operators (regardless of whether they are functions or function templates), use the <code class="inlineCode">explicit</code> specifier in the declaration.</p>
<p class="normal">The following example shows both an explicit constructor and an explicit converting operator:</p>
<pre class="programlisting code"><code class="hljs-code">struct handle_t
{
  explicit handle_t(int const h) : handle(h) {}
  explicit operator bool() const { return handle != 0; };
private:
  int handle;
};
</code></pre>
<h2 class="heading-2" id="_idParaDest-61">How it works...</h2>
<p class="normal">To understand why explicit constructors are necessary and how they work, we will first look at converting constructors. The following class, <code class="inlineCode">foo</code>, has three constructors: a default constructor (without parameters), a constructor that takes an <code class="inlineCode">int</code>, and a constructor that takes two parameters, an <code class="inlineCode">int</code> and a <code class="inlineCode">double</code>. They don’t do anything except print a message. As of C++11, these are all considered converting constructors. The class also has a conversion operator that converts a value of the <code class="inlineCode">foo</code> type to a <code class="inlineCode">bool</code>:</p>
<pre class="programlisting code"><code class="hljs-code">struct foo
{
  foo()
  { std::cout &lt;&lt; "foo" &lt;&lt; '\n'; }
  foo(int const a)
  { std::cout &lt;&lt; "foo(a)" &lt;&lt; '\n'; }
  foo(int const a, double const b)
  { std::cout &lt;&lt; "foo(a, b)" &lt;&lt; '\n'; }
  operator bool() const { return true; }
};
</code></pre>
<p class="normal">Based on this, the <a id="_idIndexMarker091"/>following definitions of objects are possible (note that the comments represent the console’s output):</p>
<pre class="programlisting code"><code class="hljs-code">foo f1;              // foo()
foo f2 {};           // foo()
foo f3(1);           // foo(a)
foo f4 = 1;          // foo(a)
foo f5 { 1 };        // foo(a)
foo f6 = { 1 };      // foo(a)
foo f7(1, 2.0);      // foo(a, b)
foo f8 { 1, 2.0 };   // foo(a, b)
foo f9 = { 1, 2.0 }; // foo(a, b)
</code></pre>
<p class="normal">The variables <code class="inlineCode">f1</code> and <code class="inlineCode">f2</code> invoke the default constructor. <code class="inlineCode">f3</code>, <code class="inlineCode">f4</code>, <code class="inlineCode">f5</code>, and <code class="inlineCode">f6</code> invoke the constructor that takes an <code class="inlineCode">int</code>. Note that all the definitions of these objects are equivalent, even if they look different (<code class="inlineCode">f3</code> is initialized using the functional form, <code class="inlineCode">f4</code> and <code class="inlineCode">f6</code> are copy initialized, and <code class="inlineCode">f5</code> is directly initialized using brace-init-list). Similarly, <code class="inlineCode">f7</code>, <code class="inlineCode">f8</code>, and <code class="inlineCode">f9</code> invoke the constructor with two parameters.</p>
<p class="normal">In this case, <code class="inlineCode">f5</code> and <code class="inlineCode">f6</code> will <code class="inlineCode">print foo(l)</code>, while <code class="inlineCode">f8</code> and <code class="inlineCode">f9</code> will generate compiler errors (although compilers may have options to ignore some warnings, such as <code class="inlineCode">-Wno-narrowing</code> for GCC) because all the elements of the initializer list should be integers.</p>
<p class="normal">It may be important to note that if <code class="inlineCode">foo</code> defines a constructor that takes a <code class="inlineCode">std::initializer_list</code>, then all the initializations using <code class="inlineCode">{}</code> would resolve to that constructor:</p>
<pre class="programlisting code"><code class="hljs-code">foo(std::initializer_list&lt;int&gt; l)
{ std::cout &lt;&lt; "foo(l)" &lt;&lt; '\n'; }
</code></pre>
<p class="normal">These may all look right, but the implicit conversion constructors enable scenarios where the implicit conversion may not be what we wanted. First, let’s look at some correct examples:</p>
<pre class="programlisting code"><code class="hljs-code">void bar(foo const f)
{
}
bar({});             // foo()
bar(1);              // foo(a)
bar({ 1, 2.0 });     // foo(a, b)
</code></pre>
<p class="normal">The conversion operator to <code class="inlineCode">bool</code> from the <code class="inlineCode">foo</code> class also enables us to use <code class="inlineCode">foo</code> objects where Boolean values are expected. Here is an example:</p>
<pre class="programlisting code"><code class="hljs-code">bool flag = f1;                // OK, expect bool conversion
if(f2) { /* do something */ }  // OK, expect bool conversion
std::cout &lt;&lt; f3 + f4 &lt;&lt; '\n';  // wrong, expect foo addition
if(f5 == f6) { /* do more */ } // wrong, expect comparing foos
</code></pre>
<p class="normal">The first two are examples where <code class="inlineCode">foo</code> is expected to be used as a Boolean. However, the last two, one with addition and one with a test for equality, are probably incorrect, as we most likely expect to add <code class="inlineCode">foo</code> objects and test <code class="inlineCode">foo</code> objects for equality, not the Booleans they implicitly convert to.</p>
<p class="normal">Perhaps a more realistic example to understand where problems could arise would be to consider a string buffer implementation. This would be a class that contains an internal buffer of characters.</p>
<p class="normal">This class provides<a id="_idIndexMarker092"/> several conversion constructors: a default constructor, a constructor that takes a <code class="inlineCode">size_t</code> parameter representing the size of the buffer to pre-allocate, and a constructor that takes a pointer to <code class="inlineCode">char</code>, which should be used to allocate and initialize the internal buffer. Succinctly, the implementation of the string buffer that we use for this exemplification looks like this:</p>
<pre class="programlisting code"><code class="hljs-code">class string_buffer
{
public:
  string_buffer() {}
  string_buffer(size_t const size) { data.resize(size); }
  string_buffer(char const * const ptr) : data(ptr) {}
  size_t size() const { return data.size(); }
  operator bool() const { return !data.empty(); }
  operator char const * () const { return data.c_str(); }
private:
   std::string data;
};
</code></pre>
<p class="normal">Based on this definition, we could construct the following objects:</p>
<pre class="programlisting code"><code class="hljs-code">std::shared_ptr&lt;char&gt; str;
string_buffer b1;            // calls string_buffer()
string_buffer b2(20);        // calls string_buffer(size_t const)
string_buffer b3(str.get()); // calls string_buffer(char const*)
</code></pre>
<p class="normal">The object <code class="inlineCode">b1</code> is<a id="_idIndexMarker093"/> created using the default constructor and, thus, has an empty buffer; <code class="inlineCode">b2</code> is initialized using the constructor with a single parameter, where the value of the parameter represents the size in terms of the characters of the internal buffer; and <code class="inlineCode">b3</code> is initialized with an existing buffer, which is used to define the size of the internal buffer and copy its value into the internal buffer. However, the same definition also enables the following object definitions:</p>
<pre class="programlisting code"><code class="hljs-code">enum ItemSizes {DefaultHeight, Large, MaxSize};
string_buffer b4 = 'a';
string_buffer b5 = MaxSize;
</code></pre>
<p class="normal">In this case, <code class="inlineCode">b4</code> is initialized with a <code class="inlineCode">char</code>. Since an implicit conversion to <code class="inlineCode">size_t</code> exists, the constructor with a single parameter will be called. The intention here is not necessarily clear; perhaps it should have been <code class="inlineCode">"a"</code> instead of <code class="inlineCode">'a'</code>, in which case the third constructor would have been called.</p>
<p class="normal">However, <code class="inlineCode">b5</code> is most likely an error, because <code class="inlineCode">MaxSize</code> is an enumerator representing an <code class="inlineCode">ItemSizes</code> and should have nothing to do with a string buffer size. These erroneous situations are not flagged by the compiler in any way. The implicit conversion of unscoped enums to <code class="inlineCode">int</code> is a good argument for preferring to use scoped enums (declared with enum class), which do not have this implicit conversion. If <code class="inlineCode">ItemSizes</code> was a scoped enum, the situation described here would not appear.</p>
<p class="normal">When using the <code class="inlineCode">explicit</code> specifier in the declaration of a constructor, that constructor becomes an explicit constructor and no longer allows implicit constructions of objects of a <code class="inlineCode">class</code> type. To exemplify this, we will slightly change the <code class="inlineCode">string_buffer</code> class to declare all constructors as <code class="inlineCode">explicit</code>:</p>
<pre class="programlisting code"><code class="hljs-code">class string_buffer
{
public:
  explicit string_buffer() {}
  explicit string_buffer(size_t const size) { data.resize(size); }
  explicit string_buffer(char const * const ptr) :data(ptr) {}
  size_t size() const { return data.size(); }
  explicit operator bool() const { return !data.empty(); }
  explicit operator char const * () const { return data.c_str(); }
private:
   std::string data;
};
</code></pre>
<p class="normal">The change here is<a id="_idIndexMarker094"/> minimal, but the definitions of <code class="inlineCode">b4</code> and <code class="inlineCode">b5</code> in the earlier example no longer work and are incorrect. This is because the implicit conversions from <code class="inlineCode">char</code> or <code class="inlineCode">int</code> to <code class="inlineCode">size_t</code> are no longer available during overload resolution to figure out what constructor should be called. The result is compiler errors for both <code class="inlineCode">b4</code> and <code class="inlineCode">b5</code>. Note that <code class="inlineCode">b1</code>, <code class="inlineCode">b2</code>, and <code class="inlineCode">b3</code> are still valid definitions, even if the constructors are explicit.</p>
<p class="normal">The only way to fix the problem, in this case, is to provide an explicit cast from <code class="inlineCode">char</code> or <code class="inlineCode">int</code> to <code class="inlineCode">string_buffer</code>:</p>
<pre class="programlisting code"><code class="hljs-code">string_buffer b4 = string_buffer('a');
string_buffer b5 = static_cast&lt;string_buffer&gt;(MaxSize);
string_buffer b6 = string_buffer{ "a" };
</code></pre>
<p class="normal">With explicit constructors, the compiler is able to immediately flag erroneous situations and developers can react accordingly, either fixing the initialization with a correct value or providing an explicit cast.</p>
<div><p class="normal">This is only the case when initialization is done with copy initialization and not when using functional or universal initialization.</p>
</div>
<p class="normal">The following definitions are still possible (but wrong) with explicit constructors:</p>
<pre class="programlisting code"><code class="hljs-code">string_buffer b7{ 'a' };
string_buffer b8('a');
</code></pre>
<p class="normal">Similar to <a id="_idIndexMarker095"/>constructors, conversion operators can be declared explicit (as shown earlier). In this case, the implicit conversions from the object type to the type specified by the conversion operator are no longer possible and require an explicit cast. Considering <code class="inlineCode">b1</code> and <code class="inlineCode">b2</code>, which are the <code class="inlineCode">string_buffer</code> objects we defined earlier, the following is no longer possible with an explicit <code class="inlineCode">operator bool</code> conversion:</p>
<pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; b4 + b5 &lt;&lt; '\n'; // error
if(b4 == b5) {}               // error
</code></pre>
<p class="normal">Instead, they require explicit conversion to <code class="inlineCode">bool</code>:</p>
<pre class="programlisting code"><code class="hljs-code">std::cout &lt;&lt; static_cast&lt;bool&gt;(b4) + static_cast&lt;bool&gt;(b5);
if(static_cast&lt;bool&gt;(b4) == static_cast&lt;bool&gt;(b5)) {}
</code></pre>
<p class="normal">The addition of two <code class="inlineCode">bool</code> values does not make much sense. The preceding example is intended only to show how an explicit cast is required in order to make the statement compile. The error issued by the compiler when there is no explicit static cast should help you figure out that the expression itself is wrong and something else was probably intended.</p>
<h2 class="heading-2" id="_idParaDest-62">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Understanding uniform initialization</em>, to see how brace-initialization works</li>
</ul>
<h1 class="heading-1" id="_idParaDest-63">Using unnamed namespaces instead of static globals</h1>
<p class="normal">The larger a program, the <a id="_idIndexMarker096"/>greater the chance that you could run into name collisions when your program is linked to multiple translation units. Functions or variables that are declared in a source file, intended to be local to the translation unit, may collide with other similar functions or variables declared in another translation unit.</p>
<p class="normal">That is because all the symbols that are not declared static have external linkage, and their names must be unique throughout the program. The typical C solution for this problem is to declare those symbols as static, changing their linkage from external to internal and, therefore, making them local to a translation unit. An alternative is to prefix the names with the name of the module or library they belong to. In this recipe, we will look at the C++ solution for this problem.</p>
<h2 class="heading-2" id="_idParaDest-64">Getting ready</h2>
<p class="normal">In this recipe, we will discuss concepts such as global functions and static functions, as well as variables, namespaces, and translation units. We expect that you have a basic understanding of these concepts. Apart from these, it is required that you understand the difference between internal and external linkage; this is key for this recipe.</p>
<h2 class="heading-2" id="_idParaDest-65">How to do it...</h2>
<p class="normal">When you are in a<a id="_idIndexMarker097"/> situation where you need to declare global symbols as static to avoid linkage problems, you should prefer to use unnamed namespaces:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Declare a namespace without a name in your source file.</li>
<li class="numberedList">Put the definition of the global function or variable in the unnamed namespace without making it <code class="inlineCode">static</code>.</li>
</ol>
<p class="normal">The following example shows two functions called <code class="inlineCode">print()</code> in two different translation units; each of them is defined in an unnamed namespace:</p>
<pre class="programlisting code"><code class="hljs-code">// file1.cpp
namespace
{
  void print(std::string const &amp; message)
 {
    std::cout &lt;&lt; "[file1] " &lt;&lt; message &lt;&lt; '\n';
  }
}
void file1_run()
{
  print("run");
}
// file2.cpp
namespace
{
  void print(std::string const &amp; message)
 {
    std::cout &lt;&lt; "[file2] " &lt;&lt; message &lt;&lt; '\n';
  }
}
void file2_run()
{
  print("run");
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-66">How it works...</h2>
<p class="normal">When a function is <a id="_idIndexMarker098"/>declared in a translation unit, it has an external linkage. This means two functions with the same name from two different translation units would generate a linkage error because it is not possible to have two symbols with the same name. The way this problem is solved in C, and sometimesin C++ also, is to declare the function or variable as static and change its linkage from external to internal. In this case, its name is no longer exported outside the translation unit, and the linkage problem is avoided.</p>
<p class="normal">The proper solution in C++ is to use unnamed namespaces. When you define a namespace like the ones shown previously, the compiler transforms it into the following:</p>
<pre class="programlisting code"><code class="hljs-code">// file1.cpp
namespace _unique_name_ {}
using namespace _unique_name_;
namespace _unique_name_
{
  void print(std::string message)
 {
    std::cout &lt;&lt; "[file1] " &lt;&lt; message &lt;&lt; '\n';
  }
}
void file1_run()
{
  print("run");
}
</code></pre>
<p class="normal">First of all, it declares a namespace with a unique name (what the name is and how it generates that name is a compiler implementation detail and should not be a concern). At this point, the namespace is empty, and the purpose of this line is to basically establish the namespace. Second, a <code class="inlineCode">using</code> directive brings everything from the <code class="inlineCode">_unique_name_</code> namespace into the current namespace. Third, the namespace, with the compiler-generated name, is defined as it was in the original source code (when it had no name).</p>
<p class="normal">By defining the translation unit local <code class="inlineCode">print()</code> functions in an unnamed namespace, they have local visibility only, yet their external linkage no longer produces linkage errors, since they now have external unique names.</p>
<p class="normal">Unnamed namespaces also work in a perhaps more obscure situation involving templates. Prior to C++11, template non-type arguments could not be names with internal linkage, so using static variables was not possible. Conversely, symbols in an unnamed namespace have external linkage and could be used as template arguments. Although this linkage restriction for template non-type arguments was lifted in C++11, it is still present in <a id="_idIndexMarker099"/>the latest version of the VC++ compiler. This problem is shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;int const&amp; Size&gt;
class test {};
static int Size1 = 10;
namespace
{
  int Size2 = 10;
}
test&lt;Size1&gt; t1;
test&lt;Size2&gt; t2;
</code>
t1</code> variable produces a compiler error because the non-type argument expression, <code class="inlineCode">Size1</code>, has internal linkage. Conversely, the declaration of the <code class="inlineCode">t2</code> variable is correct because <code class="inlineCode">Size2</code> has an external linkage. (Note that compiling this snippet with Clang and GCC does not produce an error.)</pre>
<h2 class="heading-2" id="_idParaDest-67">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using inline namespaces for symbol versioning</em>, to learn how to version your source code using inline namespaces and conditional compilation</li>
</ul>
<h1 class="heading-1" id="_idParaDest-68">Using inline namespaces for symbol versioning</h1>
<p class="normal">The C++11 standard has introduced a<a id="_idIndexMarker100"/> new type of namespace called <em class="italic">inline namespaces</em>, which are basically a mechanism that makes declarations from a nested namespace look and act like they were part of the surrounding namespace. Inline namespaces are declared using the <code class="inlineCode">inline</code> keyword in the namespace declaration (unnamed namespaces can also be inlined). This is a helpful feature for library versioning, and in this recipe, we will learn how inline namespaces can be used for versioning symbols. From this recipe, you will learn how to version your source code using inline namespaces and conditional compilation.</p>
<h2 class="heading-2" id="_idParaDest-69">Getting ready</h2>
<p class="normal">In this recipe, we will discuss namespaces and nested namespaces, templates and template specializations, and conditional compilation using preprocessor macros. Familiarity with these concepts is required in order to proceed with this recipe.</p>
<h2 class="heading-2" id="_idParaDest-70">How to do it...</h2>
<p class="normal">To provide <a id="_idIndexMarker101"/>multiple versions of a library and let the<a id="_idIndexMarker102"/> user decide what version to use, do the following:</p>
<ul>
<li class="bulletList">Define the content of the library inside a namespace.</li>
<li class="bulletList">Define each version of the library or parts of it inside an inner inline namespace.</li>
<li class="bulletList">Use preprocessor macros and <code class="inlineCode">#if</code> directives to enable a particular version of the library.</li>
</ul>
<p class="normal">The following example shows a library that has two versions that clients can use:</p>
<pre class="programlisting code"><code class="hljs-code">namespace modernlib
{
  #ifndef LIB_VERSION_2
inline namespace version_1
  {
    template&lt;typename T&gt;
 int test(T value) { return 1; }
  }
  #endif
#ifdef LIB_VERSION_2
inline namespace version_2
  {
    template&lt;typename T&gt;
 int test(T value) { return 2; }
  }
  #endif
}
</code></pre>
<h2 class="heading-2" id="_idParaDest-71">How it works...</h2>
<p class="normal">A member of <a id="_idIndexMarker103"/>an inline namespace is <a id="_idIndexMarker104"/>treated as if it were a member of the surrounding namespace. Such a member can be partially specialized, explicitly instantiated, or explicitly specialized. This is a transitive property, which means that if a namespace, <code class="inlineCode">A</code>, contains an inline namespace, <code class="inlineCode">B</code>, that contains an inline namespace, <code class="inlineCode">C</code>, then the members of <code class="inlineCode">C</code> appear as they were members of both <code class="inlineCode">B</code> and <code class="inlineCode">A</code> and the members of <code class="inlineCode">B</code> appear as they were members of <code class="inlineCode">A</code>.</p>
<p class="normal">To better understand why inline namespaces are helpful, let’s consider the case of developing a library that evolves over time from a first version to a second version (and further on). This library defines all its types and functions under a namespace called <code class="inlineCode">modernlib</code>. In the first version, this library could look like this:</p>
<pre class="programlisting code"><code class="hljs-code">namespace modernlib
{
  template&lt;typename T&gt;
 int test(T value) { return 1; }
}
</code></pre>
<p class="normal">A client of the library can make the following call and get back the value <code class="inlineCode">1</code>:</p>
<pre class="programlisting code"><code class="hljs-code">auto x = modernlib::test(42);
</code></pre>
<p class="normal">However, the client might decide to specialize the template function <code class="inlineCode">test()</code> as follows:</p>
<pre class="programlisting code"><code class="hljs-code">struct foo { int a; };
namespace modernlib
{
  template&lt;&gt;
  int test(foo value) { return value.a; }
}
auto y = modernlib::test(foo{ 42 });
</code></pre>
<p class="normal">In this case, the value of <code class="inlineCode">y</code> is no longer <code class="inlineCode">1</code> but <code class="inlineCode">42</code> instead because the user-specialized function gets called.</p>
<p class="normal">Everything is <a id="_idIndexMarker105"/>working correctly so far, but as a library <a id="_idIndexMarker106"/>developer, you decide to create a second version of the library, yet still ship both the first and the second version and let the user control what to use with a macro. In this second version, you provide a new implementation of the <code class="inlineCode">test()</code> function that no longer returns <code class="inlineCode">1</code> but <code class="inlineCode">2</code> instead. </p>
<p class="normal">To be able to provide both the first and second implementations, you put them in nested namespaces called <code class="inlineCode">version_1</code> and <code class="inlineCode">version_2</code> and conditionally compile the library using preprocessor macros:</p>
<pre class="programlisting code"><code class="hljs-code">namespace modernlib
{
  namespace version_1
  {
    template&lt;typename T&gt;
 int test(T value) { return 1; }
  }
  #ifndef LIB_VERSION_2
using namespace version_1;
  #endif
namespace version_2
  {
    template&lt;typename T&gt;
 int test(T value) { return 2; }
  }
  #ifdef LIB_VERSION_2
using namespace version_2;
  #endif
}
</code></pre>
<p class="normal">Suddenly, the client code breaks, regardless of whether it uses the first or second version of the library. This is because the test function is now inside a nested namespace, and the specialization for <code class="inlineCode">foo</code> is done in the <code class="inlineCode">modernlib</code> namespace, when it should actually be done in <code class="inlineCode">modernlib::version_1</code> or <code class="inlineCode">modernlib::version_2</code>. This is because the specialization of a template is required to be done in the same namespace where the template was declared.</p>
<p class="normal">In this case, the <a id="_idIndexMarker107"/>client needs to change the code, like<a id="_idIndexMarker108"/> this:</p>
<pre class="programlisting code"><code class="hljs-code">#define LIB_VERSION_2
#include "modernlib.h"
struct foo { int a; };
namespace modernlib
{
  namespace version_2
  {
    template&lt;&gt;
    int test(foo value) { return value.a; }
  }
}
</code></pre>
<p class="normal">This is a problem because the library leaks implementation details, and the client needs to be aware of those in order to do template specialization. These internal details are hidden with inline namespaces in the manner shown in the <em class="italic">How to do it...</em> section of this recipe. With that definition of the <code class="inlineCode">modernlib</code> library, the client code with the specialization of the <code class="inlineCode">test()</code> function in the <code class="inlineCode">modernlib</code> namespace is no longer broken, because either <code class="inlineCode">version_1::test()</code> or <code class="inlineCode">version_2::test()</code> (depending on what version the client actually uses) acts as if it is part of the enclosing <code class="inlineCode">modernlib</code> namespace when template specialization is done. The details of the implementation are now hidden to the client, who only sees the surrounding namespace, <code class="inlineCode">modernlib</code>.</p>
<p class="normal">However, you should<a id="_idIndexMarker109"/> keep in mind that the<a id="_idIndexMarker110"/> namespace <code class="inlineCode">std</code> is reserved for the standard and should never be inlined. Also, a namespace should not be defined inline if it was not inline in its first definition.</p>
<h2 class="heading-2" id="_idParaDest-72">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using unnamed namespaces instead of static globals</em>, to explore anonymous namespaces and learn how they help</li>
<li class="bulletList"><em class="chapterRef">Chapter 4</em>, <em class="italic">Conditionally compiling your source code</em>, to learn the various options for performing conditional compilation</li>
</ul>
<h1 class="heading-1" id="_idParaDest-73">Using structured bindings to handle multi-return values</h1>
<p class="normal">Returning <a id="_idIndexMarker111"/>multiple values from a function<a id="_idIndexMarker112"/> is very common, yet there is no first-class solution in C++ to make it possible in a straightforward way. Developers have to choose between returning multiple values through reference parameters to a function, defining a structure to contain the multiple values, or returning a <code class="inlineCode">std::pair</code> or <code class="inlineCode">std::tuple</code>. The first two use named variables, which gives them the advantage that they clearly indicate the meaning of the return value, but have the disadvantage that they have to be explicitly defined. <code class="inlineCode">std::pair</code> has its members called <code class="inlineCode">first</code> and <code class="inlineCode">second</code>, while <code class="inlineCode">std::tuple</code> has unnamed members that can only be retrieved with a function call but can be copied to named variables, using <code class="inlineCode">std::tie()</code>. None of these solutions are ideal.</p>
<p class="normal">C++17 extends the semantic use of <code class="inlineCode">std::tie()</code> to a first-class core language feature that enables unpacking the values of a tuple into named variables. This feature is called <em class="italic">structured bindings</em>.</p>
<h2 class="heading-2" id="_idParaDest-74">Getting ready</h2>
<p class="normal">For this recipe, you should be familiar with the standard utility types <code class="inlineCode">std::pair</code> and <code class="inlineCode">std::tuple</code> and the utility function <code class="inlineCode">std::tie()</code>.</p>
<h2 class="heading-2" id="_idParaDest-75">How to do it...</h2>
<p class="normal">To return multiple values from a function using a compiler that supports C++17, you should do the following:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Use an <code class="inlineCode">std::tuple</code> for the return type:
        <pre class="programlisting code"><code class="hljs-code">std::tuple&lt;int, std::string, double&gt; find()
{
  return {1, "marius", 1234.5};
}
</code></pre>
</li>
<li class="numberedList">Use structured bindings to unpack the values of the tuple into named objects:
        <pre class="programlisting code"><code class="hljs-code">auto [id, name, score] = find();
</code></pre>
</li>
<li class="numberedList">Use structure bindings to bind the returned values to the variables inside an <code class="inlineCode">if</code> statement or <code class="inlineCode">switch</code> statement:
        <pre class="programlisting code"><code class="hljs-code">if (auto [id, name, score] = find(); score &gt; 1000)
{
  std::cout &lt;&lt; name &lt;&lt; '\n';
}
</code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-76">How it works...</h2>
<p class="normal">Structured bindings (sometimes referred to as <em class="italic">decomposition declaration</em>) are a language feature that works just like <code class="inlineCode">std::tie()</code>, except that we don’t have to define named variables <a id="_idIndexMarker113"/>for each value that needs to <a id="_idIndexMarker114"/>be unpacked explicitly with <code class="inlineCode">std::tie()</code>. With structured bindings, we define all the named variables in a single definition using the <code class="inlineCode">auto</code> specifier so that the compiler can infer the correct type for each variable.</p>
<p class="normal">To exemplify this, let’s consider the case of inserting items into a <code class="inlineCode">std::map</code>. The <code class="inlineCode">insert</code> method returns a <code class="inlineCode">std::pair</code>, containing an iterator for the inserted element or the element that prevented the insertion, and a Boolean indicating whether the insertion was successful or not. The following code is very explicit, and the use of <code class="inlineCode">second</code> or <code class="inlineCode">first-&gt;second</code> makes the code harder to read because you need to constantly figure out what they represent:</p>
<pre class="programlisting code"><code class="hljs-code">std::map&lt;int, std::string&gt; m;
auto result = m.insert({ 1, "one" });
std::cout &lt;&lt; "inserted = " &lt;&lt; result.second &lt;&lt; '\n'
          &lt;&lt; "value = " &lt;&lt; result.first-&gt;second &lt;&lt; '\n';
</code></pre>
<p class="normal">The <a id="_idIndexMarker115"/>preceding code can be made more<a id="_idIndexMarker116"/> readable with the use of <code class="inlineCode">std::tie</code>, which unpacks tuples into individual objects (and works with <code class="inlineCode">std::pair</code> because <code class="inlineCode">std::tuple</code> has a converting assignment from <code class="inlineCode">std::pair</code>):</p>
<pre class="programlisting code"><code class="hljs-code">std::map&lt;int, std::string&gt; m;
std::map&lt;int, std::string&gt;::iterator it;
bool inserted;
std::tie(it, inserted) = m.insert({ 1, "one" });
std::cout &lt;&lt; "inserted = " &lt;&lt; inserted &lt;&lt; '\n'
          &lt;&lt; "value = " &lt;&lt; it-&gt;second &lt;&lt; '\n';
std::tie(it, inserted) = m.insert({ 1, "two" });
std::cout &lt;&lt; "inserted = " &lt;&lt; inserted &lt;&lt; '\n'
          &lt;&lt; "value = " &lt;&lt; it-&gt;second &lt;&lt; '\n';
</code></pre>
<p class="normal">The code is not necessarily simpler because it requires defining the objects that the pair is unpacked to in advance. Similarly, the more elements the tuple has, the more objects you need to define, but using named objects makes the code easier to read.</p>
<p class="normal">C++17 <a id="_idIndexMarker117"/>structured bindings elevate unpacking tuple elements into named objects to the rank of a language feature; there is no requirement for the use of <code class="inlineCode">std::tie()</code>, and objects are initialized when declared:</p>
<pre class="programlisting code"><code class="hljs-code">std::map&lt;int, std::string&gt; m;
{
  auto [it, inserted] = m.insert({ 1, "one" });
  std::cout &lt;&lt; "inserted = " &lt;&lt; inserted &lt;&lt; '\n'
            &lt;&lt; "value = " &lt;&lt; it-&gt;second &lt;&lt; '\n';
}
{
  auto [it, inserted] = m.insert({ 1, "two" });
  std::cout &lt;&lt; "inserted = " &lt;&lt; inserted &lt;&lt; '\n'
            &lt;&lt; "value = " &lt;&lt; it-&gt;second &lt;&lt; '\n';
}
</code></pre>
<p class="normal">The use of multiple blocks in the preceding example is necessary because variables cannot be redeclared in the same block, and structured bindings imply a declaration using the <code class="inlineCode">auto</code> specifier. Therefore, if you need to make multiple calls, as in the preceding example, and use structured bindings, you must either use different variable names or multiple blocks. An alternative to that is to avoid structured bindings and use <code class="inlineCode">std::tie()</code>, because it can be called multiple times with the same variables, so you only need to declare them once.</p>
<p class="normal">In C++17, it is also possible to declare variables in <code class="inlineCode">if</code> and <code class="inlineCode">switch</code> statements in the form <code class="inlineCode">if(init; condition)</code> and <code class="inlineCode">switch(init; condition)</code>, respectively. This could be combined with structured bindings to produce simpler code. Let’s look at an example:</p>
<pre class="programlisting code"><code class="hljs-code">if(auto [it, inserted] = m.insert({ 1, "two" }); inserted)
{ std::cout &lt;&lt; it-&gt;second &lt;&lt; '\n'; }
</code>
it</code> and <code class="inlineCode">inserted</code>, defined in the scope of the <code class="inlineCode">if</code> statement in the initialization part. Then, the condition <a id="_idIndexMarker118"/>of the <code class="inlineCode">if</code> statement is evaluated from the <a id="_idIndexMarker119"/>value of the <code class="inlineCode">inserted</code> variable.</pre>
<h2 class="heading-2" id="_idParaDest-77">There’s more...</h2>
<p class="normal">Although we focused on binding<a id="_idIndexMarker120"/> names to the elements of tuples, structured bindings can be used in a broader scope because they also support binding to array elements or data members of a class. If you want to bind to the elements of an array, you must provide a name for every element of the array; otherwise, the declaration is ill-formed. The following is an example of binding to array elements:</p>
<pre class="programlisting code"><code class="hljs-code">int arr[] = { 1,2 };
auto [a, b] = arr;
auto&amp; [x, y] = arr;
arr[0] += 10;
arr[1] += 10;
std::cout &lt;&lt; arr[0] &lt;&lt; ' ' &lt;&lt; arr[1] &lt;&lt; '\n'; // 11 12
std::cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; '\n';           // 1 2
std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';           // 11 12
</code></pre>
<p class="normal">In this example, <code class="inlineCode">arr</code> is an array with two elements. We first bind <code class="inlineCode">a</code> and <code class="inlineCode">b</code> to its elements, and then we bind the <code class="inlineCode">x</code> and <code class="inlineCode">y</code> references to its elements. Changes that are made to the elements of the array are not visible through the variables <code class="inlineCode">a</code> and <code class="inlineCode">b</code>, but they are through the <code class="inlineCode">x</code> and <code class="inlineCode">y</code> references, as shown in the comments that print these values to the console. This happens because when we do the first binding, a copy of the array is created, and <code class="inlineCode">a</code> and <code class="inlineCode">b</code> are bound to the elements of the copy.</p>
<p class="normal">As we already mentioned, it’s also possible to bind to data members of a class. The following restrictions apply:</p>
<ul>
<li class="bulletList">Binding is possible only for non-static members of the class.</li>
<li class="bulletList">The class cannot have anonymous union members.</li>
<li class="bulletList">The number of identifiers must match the number of non-static members of the class.</li>
</ul>
<p class="normal">The binding of <a id="_idIndexMarker121"/>identifiers occurs in the order of the declaration of the data members, which can include bitfields. An example is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">struct foo
{
   int         id;
   std::string name;
};
foo f{ 42, "john" };
auto [i, n] = f;
auto&amp; [ri, rn] = f;
f.id = 43;
std::cout &lt;&lt; f.id &lt;&lt; ' ' &lt;&lt; f.name &lt;&lt; '\n';   // 43 john
std::cout &lt;&lt; i &lt;&lt;'''' &lt;&lt; n &lt;&lt;''\'';           // 42 john
std::cout &lt;&lt; ri &lt;&lt;'''' &lt;&lt; rn &lt;&lt;''\'';         // 43 john
</code></pre>
<p class="normal">Again, changes to the <code class="inlineCode">foo</code> object are not visible to the variables <code class="inlineCode">i</code> and <code class="inlineCode">n</code> but are to <code class="inlineCode">ri</code> and <code class="inlineCode">rn</code>. This is because each identifier in the structure binding becomes the name of an lvalue that refers to a data member of the class (just like with an array, it refers to an element of the array). However, the reference type of an identifier is the corresponding data member (or array element).</p>
<p class="normal">The new C++20 standard has introduced a series of improvements to structure bindings, including the following:</p>
<ul>
<li class="bulletList">The possibility to include the <code class="inlineCode">static</code> or <code class="inlineCode">thread_local</code> storage-class specifiers in the declaration of the structure bindings.</li>
<li class="bulletList">The use of the <code class="inlineCode">[[maybe_unused]]</code> attribute for the declaration of a structured binding. Some compilers, such as Clang and GCC, had already supported this feature.</li>
<li class="bulletList">The possibility to capture structure binding identifiers in lambdas. All identifiers, including those bound to bitfields, can be captured by value. Conversely, all identifiers except for those bound to bitfields can also be captured by reference.</li>
</ul>
<p class="normal">These changes enable us to write the following:</p>
<pre class="programlisting code"><code class="hljs-code">foo f{ 42,"john" };
auto [i, n] = f;
auto l1 = [i] {std::cout &lt;&lt; i; };
auto l2 = [=] {std::cout &lt;&lt; i; };
auto l3 = [&amp;i] {std::cout &lt;&lt; i; };
auto l4 = [&amp;] {std::cout &lt;&lt; i; };
</code></pre>
<p class="normal">These examples show the various ways structured bindings can be captured in lambdas in C++20.</p>
<p class="normal">Sometimes, we need to bind variables that we don’t use. In C++26, it will be possible to ignore a variable by using an underscore (<code class="inlineCode">_</code>) instead of a name. Although not supported by any compiler at the time of writing, this feature has been included in C++26.</p>
<pre class="programlisting code"><code class="hljs-code">foo f{ 42,"john" };
auto [_, n] = f;
</code></pre>
<p class="normal">Here, <code class="inlineCode">_</code> is a placeholder for a variable that is bound to the <code class="inlineCode">id</code> member of the <code class="inlineCode">foo</code> object. It is used to indicate that this value is not used and will be ignored in this context.</p>
<p class="normal">The use of a <code class="inlineCode">_</code> placeholder is not<a id="_idIndexMarker122"/> limited to structured bindings. It can be used as an identifier for non-static class members, structured bindings, and lambda captures. You can use an underscore to redefine an existing declaration in the same scope, therefore making it possible to ignore multiple variables. However, a program is considered ill-formed if the variable named <code class="inlineCode">_</code> is used after a redeclaration.</p>
<h2 class="heading-2" id="_idParaDest-78">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Using auto whenever possible</em>, to understand how automatic type deduction works in C++</li>
<li class="bulletList"><em class="chapterRef">Chapter 3</em>, <em class="italic">Using lambdas with standard algorithms</em>, to learn how lambdas can be used with standard library general-purpose algorithms</li>
<li class="bulletList"><em class="chapterRef">Chapter 4</em>, <em class="italic">Providing metadata to the compiler with attributes</em>, to learn about providing hints to the compiler with the use of standard attributes</li>
</ul>
<h1 class="heading-1" id="_idParaDest-79">Simplifying code with class template argument deduction</h1>
<p class="normal">Templates are ubiquitous in C++, but having to specify template arguments all the time can be annoying. There are cases when the compiler can actually infer the template arguments from the context. This feature, available in C++17, is called <em class="italic">class template argument deduction</em> and<a id="_idIndexMarker123"/> enables the compiler to deduce the missing template arguments from the type of the initializer. In this recipe, we will learn how to take advantage of this feature.</p>
<h2 class="heading-2" id="_idParaDest-80">How to do it...</h2>
<p class="normal">In C++17, you <a id="_idIndexMarker124"/>can skip specifying template arguments and let the compiler deduce them in the following cases:</p>
<ul>
<li class="bulletList">When you declare a variable or a variable template and initialize it:
        <pre class="programlisting code"><code class="hljs-code">std::pair   p{ 42, "demo" };  // deduces std::pair&lt;int, char const*&gt;
std::vector v{ 1, 2 };        // deduces std::vector&lt;int&gt;
std::less   l;                // deduces std::less&lt;void&gt;
</code></pre>
</li>
<li class="bulletList">When you create an object using a new expression:
        <pre class="programlisting code"><code class="hljs-code">template &lt;class T&gt;
struct foo
{
   foo(T v) :data(v) {}
private:
   T data;
};
auto f = new foo(42);
</code></pre>
</li>
<li class="bulletList">When you perform function-like cast expressions:
        <pre class="programlisting code"><code class="hljs-code">std::mutex mx;
// deduces std::lock_guard&lt;std::mutex&gt;
auto lock = std::lock_guard(mx);
std::vector&lt;int&gt; v;
// deduces std::back_insert_iterator&lt;std::vector&lt;int&gt;&gt;
std::fill_n(std::back_insert_iterator(v), 5, 42);
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-81">How it works...</h2>
<p class="normal">Prior to<a id="_idIndexMarker125"/> C++17, you had to specify all the template arguments when initializing variables, because all of them must be known in order to instantiate the class template, such as in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">std::pair&lt;int, char const*&gt; p{ 42, "demo" };
std::vector&lt;int&gt;            v{ 1, 2 };
foo&lt;int&gt;                    f{ 42 };
</code></pre>
<p class="normal">The problem of explicitly specifying template arguments could have been avoided with a function template, such as <code class="inlineCode">std::make_pair()</code>, which benefits from function template argument deduction and allows us to write code such as the following:</p>
<pre class="programlisting code"><code class="hljs-code">auto p = std::make_pair(42, "demo");
</code></pre>
<p class="normal">In the case of the <code class="inlineCode">foo</code> class template shown here, we can write the following <code class="inlineCode">make_foo()</code> function template to enable the same behavior:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
constexpr foo&lt;T&gt; make_foo(T&amp;&amp; value)
{
   return foo{ value };
}
auto f = make_foo(42);
</code></pre>
<p class="normal">In C++17, this is no longer necessary in the cases listed in the <em class="italic">How it works...</em> section. Let’s take the following declaration as an example:</p>
<pre class="programlisting code"><code class="hljs-code">std::pair p{ 42, "demo" };
</code></pre>
<p class="normal">In this context, <code class="inlineCode">std::pair</code> is not a type, but it acts as a placeholder for a type that activates class template argument deduction. When the compiler encounters it during the declaration of a variable with initialization or a function-style cast, it builds a set of deduction guides. These deduction guides are fictional constructors of a hypothetical class type. </p>
<p class="normal">As a user, you can complement this set with user-defined deduction rules. This set is used to perform template argument deduction and overload resolution.</p>
<p class="normal">In the <a id="_idIndexMarker126"/>case of <code class="inlineCode">std::pair</code>, the compiler will build a set of deduction guides that includes the following fictional function templates (but not only these):</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;class T1, class T2&gt;
std::pair&lt;T1, T2&gt; F();
template &lt;class T1, class T2&gt;
std::pair&lt;T1, T2&gt; F(T1 const&amp; x, T2 const&amp; y);
template &lt;class T1, class T2, class U1, class U2&gt;
std::pair&lt;T1, T2&gt; F(U1&amp;&amp; x, U2&amp;&amp; y);
</code></pre>
<p class="normal">These compiler-generated deduction guides are created from the constructors of the class template, and if none are present, then a deduction guide is created for a hypothetical default constructor. In addition, in all cases, a deduction guide for a hypothetical copy constructor is always created.</p>
<p class="normal">The user-defined deduction guides are function signatures with a trailing return type and without the <code class="inlineCode">auto</code> keyword (since they represent hypothetical constructors that don’t have a return value). They must be defined in the namespace of the class template they apply to.</p>
<p class="normal">To <a id="_idIndexMarker127"/>understand how this works, let’s consider the same example with the <code class="inlineCode">std::pair</code> object:</p>
<pre class="programlisting code"><code class="hljs-code">std::pair p{ 42, "demo" };
</code></pre>
<p class="normal">The type that the compiler deduces is <code class="inlineCode">std::pair&lt;int, char const*&gt;</code>. If we want to instruct the compiler to deduce <code class="inlineCode">std::string</code> instead of <code class="inlineCode">char const*</code>, then we need several user-defined deduction rules, as shown here:</p>
<pre class="programlisting code"><code class="hljs-code">namespace std {
   template &lt;class T&gt;
   pair(T&amp;&amp;, char const*)-&gt;pair&lt;T, std::string&gt;;
   template &lt;class T&gt;
   pair(char const*, T&amp;&amp;)-&gt;pair&lt;std::string, T&gt;;
   pair(char const*, char const*)-&gt;pair&lt;std::string, std::string&gt;;
}
</code></pre>
<p class="normal">These will enable us to perform the following declarations, where the type of the string <code class="inlineCode">"demo"</code> is always deduced to be <code class="inlineCode">std::string</code>:</p>
<pre class="programlisting code"><code class="hljs-code">std::pair  p1{ 42, "demo" };    // std::pair&lt;int, std::string&gt;
std::pair  p2{ "demo", 42 };    // std::pair&lt;std::string, int&gt;
std::pair  p3{ "42", "demo" };  // std::pair&lt;std::string, std::string&gt;
</code></pre>
<div><p class="normal">As you can see from this example, deduction guides do not have to be function templates.</p>
</div>
<p class="normal">It is important to note that class template argument deduction does not occur if the template argument list is present, regardless of the number of specified arguments. Examples of this are shown here:</p>
<pre class="programlisting code"><code class="hljs-code">std::pair&lt;&gt;    p1 { 42, "demo" };
std::pair&lt;int&gt; p2 { 42, "demo" };
</code></pre>
<p class="normal">Because both these declarations specify a template argument list, they are invalid and produce compiler errors.</p>
<p class="normal">There are some <a id="_idIndexMarker128"/>known cases where class template argument deduction does not work:</p>
<ul>
<li class="bulletList">Aggregate templates, where you could write a user-defined deduction guide to circumvent the problem.
        <pre class="programlisting code"><code class="hljs-code">template&lt;class T&gt;
struct Point3D { T x; T y; T z; }; 
 
Point3D p{1, 2, 2};   // error, requires Point3D&lt;int&gt;
</code></pre>
</li>
<li class="bulletList">Type aliases, as shown in the following example (for GCC, this actually works when compiling with <code class="inlineCode">-std=c++20</code>):
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
using my_vector = std::vector&lt;T&gt;;
std::vector v{1,2,3}; // OK
my_vector mv{1,2,3};  // error
</code></pre>
</li>
<li class="bulletList">Inherited <a id="_idIndexMarker129"/>constructors, because deduction guides, whether implicit or user-defined, are not inherited when constructors are inherited:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt; 
struct box
{
   box(T&amp;&amp; t) : content(std::forward&lt;T&gt;(t)) {}
   virtual void unwrap()
 { std::cout &lt;&lt; "unwrapping " &lt;&lt; content &lt;&lt; '\n'; }
   T content;
};
template &lt;typename T&gt;
struct magic_box : public box&lt;T&gt;
{
   using box&lt;T&gt;::box;
   virtual void unwrap() override
 { std::cout &lt;&lt; "unwrapping " &lt;&lt; box&lt;T&gt;::content &lt;&lt; '\n'; }
};
int main()
{
   box b(42);        // OK
   b.unwrap();
   magic_box m(21);  // error, requires magic_box&lt;int&gt;
   m.unwrap();
}
</code></pre>
</li>
</ul>
<p class="normal">This <a id="_idIndexMarker130"/>latter limitation has been removed in C++23, where deduction guides are inherited when constructors are inherited.</p>
<h2 class="heading-2" id="_idParaDest-82">See also</h2>
<ul>
<li class="bulletList"><em class="italic">Understanding uniform initialization</em>, to see how brace-initialization works</li>
</ul>
<h1 class="heading-1" id="_idParaDest-83">Using the subscript operator to access elements in a collection</h1>
<p class="normal">Accessing <a id="_idIndexMarker131"/>elements of an array is a basic feature not just in C++ but also in any programming language that supports arrays. The syntax is also the same across many programming languages. In C++, the subscript operator used for this purpose, <code class="inlineCode">[]</code>, can be overloaded to provide access to data in a class. Typically, this is the case for classes that model containers. In this recipe, we’ll see how to leverage this operator and what changes C++23 brings.</p>
<h2 class="heading-2" id="_idParaDest-84">How to do it…</h2>
<p class="normal">To provide random access to elements in a container, overload the subscript operator as follows:</p>
<ul>
<li class="bulletList">For one-dimensional containers, you can overload the subscript operator with one argument, regardless of the version of the standard:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T&gt;
struct some_buffer
{
   some_buffer(size_t const size):data(size)
   {}
   size_t size() const { return data.size(); }
   T const&amp; operator[](size_t const index) const
   {
      if(index &gt;= data.size())
         std::runtime_error("invalid index");
      return data[index];
   }
   T &amp; operator[](size_t const index)
   {
      if (index &gt;= data.size())
         std::runtime_error("invalid index");
      return data[index];
   }
private:
   std::vector&lt;T&gt; data;
};
</code></pre>
</li>
<li class="bulletList">For<a id="_idIndexMarker132"/> multidimensional containers, in C++23, you can overload the subscript operator with multiple arguments:
        <pre class="programlisting code"><code class="hljs-code">template &lt;typename T, size_t ROWS, size_t COLS&gt;
struct matrix
{
   T&amp; operator[](size_t const row, size_t const col)
   {
      if(row &gt;= ROWS || col &gt;= COLS)
         throw std::runtime_error("invalid index");
      return data[row * COLS + col];
   }
   T const &amp; operator[](size_t const row,                         size_t const col) const
   {
      if (row &gt;= ROWS || col &gt;= COLS)
         throw std::runtime_error("invalid index");
      return data[row * COLS + col];
   }
private:
   std::array&lt;T, ROWS* COLS&gt; data;
};
</code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-85">How it works…</h2>
<p class="normal">The subscript operator is used to access elements in an array. However, it is possible to overload it as a member function in classes typically modeling containers (or collections in general) to access its elements. Standard containers such as <code class="inlineCode">std::vector</code>, <code class="inlineCode">std::set</code>, and <code class="inlineCode">std::map</code> provide overloads for the subscript operator for this purpose. Therefore, you can write code as follows:</p>
<pre class="programlisting code"><code class="hljs-code">std::vector&lt;int&gt; v {1, 2, 3};
v[2] = v[1] + v[0];
</code></pre>
<p class="normal">In the previous section, we saw how the subscript operator can be overloaded. There are typically two overloads, one that is constant and one that is mutable. The const-qualified overload returns a reference to a constant object, while the mutable overload returns a reference.</p>
<p class="normal">The major<a id="_idIndexMarker133"/> problem with the subscript operator was that, prior to C++23, it could only have one parameter. Therefore, it could not be used to provide access to elements of a multidimensional container. As a result, developers usually resorted to using the call operator for this purpose. An example is shown in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T, size_t ROWS, size_t COLS&gt;
struct matrix
{
   T&amp; operator()(size_t const row, size_t const col)
 {
      if(row &gt;= ROWS || col &gt;= COLS)
         throw std::runtime_error("invalid index");
      return data[row * COLS + col];
   }
   T const &amp; operator()(size_t const row, size_t const col) const
 {
      if (row &gt;= ROWS || col &gt;= COLS)
         throw std::runtime_error("invalid index");
      return data[row * COLS + col];
   }
private:
   std::array&lt;T, ROWS* COLS&gt; data;
};
matrix&lt;int, 2, 3&gt; m;
m(0, 0) = 1;
</code></pre>
<p class="normal">To help with this, and allow a more consistent approach, C++11 made it possible to use the subscript operator with the syntax <code class="inlineCode">[{expr1, expr2, …}]</code>. A modified implementation of <a id="_idIndexMarker134"/>the <code class="inlineCode">matrix</code> class that leverages this syntax is shown next:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T, size_t ROWS, size_t COLS&gt;
struct matrix
{
   T&amp; operator[](std::initializer_list&lt;size_t&gt; index)
   {
      size_t row = *index.begin();
      size_t col = *(index.begin() + 1);
      if (row &gt;= ROWS || col &gt;= COLS)
         throw std::runtime_error("invalid index");
      return data[row * COLS + col];
   }
   T const &amp; operator[](std::initializer_list&lt;size_t&gt; index) const
   {
      size_t row = *index.begin();
      size_t col = *(index.begin() + 1);
      if (row &gt;= ROWS || col &gt;= COLS)
         throw std::runtime_error("invalid index");
      return data[row * COLS + col];
   }
private:
   std::array&lt;T, ROWS* COLS&gt; data;
};
matrix&lt;int, 2, 3&gt; m;
m[{0, 0}] = 1;
</code></pre>
<p class="normal">However, the syntax is rather cumbersome and was probably rarely used in practice. For this reason, the C++23 standard makes it possible to overload the subscript operator using multiple parameters. A modified <code class="inlineCode">matrix</code> class is shown here:</p>
<pre class="programlisting code"><code class="hljs-code">template &lt;typename T, size_t ROWS, size_t COLS&gt;
struct matrix
{
   T&amp; operator[](size_t const row, size_t const col)
   {
      if(row &gt;= ROWS || col &gt;= COLS)
         throw std::runtime_error("invalid index");
      return data[row * COLS + col];
   }
   T const &amp; operator[](size_t const row, size_t const col) const
   {
      if (row &gt;= ROWS || col &gt;= COLS)
         throw std::runtime_error("invalid index");
      return data[row * COLS + col];
   }
private:
   std::array&lt;T, ROWS* COLS&gt; data;
};
matrix&lt;int, 2, 3&gt; m;
m[0, 0] = 1;
</code></pre>
<p class="normal">This makes the calling syntax consistent with accessing one-dimensional containers. This is used by <code class="inlineCode">std::mdspan</code> to provide element access. This is a new C++23 class that represents a non-owning view into a contiguous sequence (such as an array), but it reinterprets the sequence as a multidimensional array.</p>
<p class="normal">The <code class="inlineCode">matrix</code> class shown previously can actually be replaced with an <code class="inlineCode">mdspan</code> view over an array, as shown<a id="_idIndexMarker135"/> in the following snippet:</p>
<pre class="programlisting code"><code class="hljs-code">int data[2*3] = {};
auto m = std::mdspan&lt;int, std::extents&lt;2, 3&gt;&gt; (data);
m[0, 0] = 1;
</code></pre>
<h2 class="heading-2" id="_idParaDest-86">See also</h2>
<ul>
<li class="bulletList"><em class="chapterRef">Chapter 5</em>, <em class="italic">Writing your own random-access iterator</em>, to see how you can write an iterator for accessing the elements of a container</li>
<li class="bulletList"><em class="chapterRef">Chapter 6</em>, <em class="italic">Using std::mdspan for multidimensional views of sequences of objects</em>, to learn more about the <code class="inlineCode">std::mdspan</code> class</li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="Chapter_01.xhtml">https://discord.gg/7xRaTCeEhx</a></p>
<p class="normal"><img alt="" src="img/QR_Code2659294082093549796.png"/></p>
</div>
</body></html>