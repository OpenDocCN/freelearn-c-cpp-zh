<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer020">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 class="chapterTitle" id="_idParaDest-15"><span class="koboSpan" id="kobo.2.1">Learning Modern Core Language Features</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">The C++ language has gone through a major transformation in the past decades with the development and release of C++11 and then, later, with its newer versions: C++14, C++17, C++20, and C++23. </span><span class="koboSpan" id="kobo.3.2">These new standards have introduced new concepts, simplified and extended existing syntax and semantics, and transformed the way we write code overall. </span><span class="koboSpan" id="kobo.3.3">C++11 looks and feels like a new language compared to what we previously knew, and code written using these new standards is called modern C++ code. </span><span class="koboSpan" id="kobo.3.4">This introductory chapter will touch on some of the language features introduced, starting with C++11, that help you with many coding routines. </span><span class="koboSpan" id="kobo.3.5">However, the core of the language expands way beyond the topics addressed in this chapter, and many other features are discussed in the other chapters of the book.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4.1">The recipes included in this chapter are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.6.1">auto</span></code><span class="koboSpan" id="kobo.7.1"> whenever possible</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.8.1">Creating type aliases and alias templates</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.9.1">Understanding uniform initialization</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">Understanding the various forms of non-static member initialization</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Controlling and querying object alignment</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Using scoped enumerations</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.14.1">override</span></code><span class="koboSpan" id="kobo.15.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.16.1">final</span></code><span class="koboSpan" id="kobo.17.1"> for virtual methods</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">Using range-based for loops to iterate on a range</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.19.1">Enabling range-based for loops for custom types</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.20.1">Using explicit constructors and conversion operators to avoid implicit conversion</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.21.1">Using unnamed namespaces instead of static globals</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.22.1">Using inline namespaces for symbol versioning</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.23.1">Using structured bindings to handle multi-return values</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.24.1">Simplifying code with class template argument deduction</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.25.1">Using the subscript operator to access elements in a collection</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.26.1">Let’s start by learning about automatic type deduction.</span></p>
<h1 class="heading-1" id="_idParaDest-16"><span class="koboSpan" id="kobo.27.1">Using auto whenever possible</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.28.1">Automatic type deduction</span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.29.1"> is one of the most important and widely used features in modern C++. </span><span class="koboSpan" id="kobo.29.2">The new C++ standards have made it possible to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.30.1">auto</span></code><span class="koboSpan" id="kobo.31.1"> as a placeholder for types in various contexts, letting the compiler deduce the actual type. </span><span class="koboSpan" id="kobo.31.2">In C++11, </span><code class="inlineCode"><span class="koboSpan" id="kobo.32.1">auto</span></code><span class="koboSpan" id="kobo.33.1"> can </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.34.1">be used to declare local variables and for the return type of a function with a trailing return type. </span><span class="koboSpan" id="kobo.34.2">In C++14, </span><code class="inlineCode"><span class="koboSpan" id="kobo.35.1">auto</span></code><span class="koboSpan" id="kobo.36.1"> can be used for the return type of a function without specifying a trailing type and for parameter declarations in lambda expressions. </span><span class="koboSpan" id="kobo.36.2">In C++17, it can be used to declare structured bindings, which are discussed at the end of the chapter. </span><span class="koboSpan" id="kobo.36.3">In C++20, it can be used to simplify function template syntax with so-called abbreviated function templates. </span><span class="koboSpan" id="kobo.36.4">In C++23, it can be used to perform an explicit cast to a prvalue copy. </span><span class="koboSpan" id="kobo.36.5">Future standard versions are likely to expand the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.37.1">auto</span></code><span class="koboSpan" id="kobo.38.1"> to even more cases. </span><span class="koboSpan" id="kobo.38.2">The use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.39.1">auto</span></code><span class="koboSpan" id="kobo.40.1"> as introduced in C++11 and C++14 has several important benefits, all of which will be discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.41.1">How it works...</span></em><span class="koboSpan" id="kobo.42.1"> section. </span><span class="koboSpan" id="kobo.42.2">Developers should be aware of them and aim to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.43.1">auto</span></code><span class="koboSpan" id="kobo.44.1"> whenever possible. </span><span class="koboSpan" id="kobo.44.2">An actual term was coined for this by Andrei Alexandrescu and promoted by</span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.45.1"> Herb Sutter—</span><strong class="keyWord"><span class="koboSpan" id="kobo.46.1">almost always auto</span></strong><span class="koboSpan" id="kobo.47.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.48.1">AAA</span></strong><span class="koboSpan" id="kobo.49.1">) (</span><a href="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/"><span class="url"><span class="koboSpan" id="kobo.50.1">https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/</span></span></a><span class="koboSpan" id="kobo.51.1">).</span></p>
<h2 class="heading-2" id="_idParaDest-17"><span class="koboSpan" id="kobo.52.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.53.1">Consider using </span><code class="inlineCode"><span class="koboSpan" id="kobo.54.1">auto</span></code><span class="koboSpan" id="kobo.55.1"> as a placeholder for the actual type in the following situations:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.56.1">To declare local variables with the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.57.1">auto name = expression</span></code><span class="koboSpan" id="kobo.58.1"> when you do not want to commit to a specific type:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.59.1">auto</span></span><span class="koboSpan" id="kobo.60.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.61.1">42</span></span><span class="koboSpan" id="kobo.62.1">;          </span><span class="hljs-comment"><span class="koboSpan" id="kobo.63.1">// int</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.64.1">auto</span></span><span class="koboSpan" id="kobo.65.1"> d = </span><span class="hljs-number"><span class="koboSpan" id="kobo.66.1">42.5</span></span><span class="koboSpan" id="kobo.67.1">;        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.68.1">// double</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.69.1">auto</span></span><span class="koboSpan" id="kobo.70.1"> s = </span><span class="hljs-string"><span class="koboSpan" id="kobo.71.1">"text"</span></span><span class="koboSpan" id="kobo.72.1">;      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.73.1">// char const *</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.74.1">auto</span></span><span class="koboSpan" id="kobo.75.1"> v = { </span><span class="hljs-number"><span class="koboSpan" id="kobo.76.1">1</span></span><span class="koboSpan" id="kobo.77.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.78.1">2</span></span><span class="koboSpan" id="kobo.79.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.80.1">3</span></span><span class="koboSpan" id="kobo.81.1"> }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.82.1">// std::initializer_list&lt;int&gt;</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.83.1">To declare local variables with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.84.1">auto name = type-id { expression }</span></code><span class="koboSpan" id="kobo.85.1"> form when you need to commit to a specific type:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.86.1">auto</span></span><span class="koboSpan" id="kobo.87.1"> b  = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.88.1">new</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.89.1">char</span></span><span class="koboSpan" id="kobo.90.1">[</span><span class="hljs-number"><span class="koboSpan" id="kobo.91.1">10</span></span><span class="koboSpan" id="kobo.92.1">]{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.93.1">0</span></span><span class="koboSpan" id="kobo.94.1"> };            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.95.1">// char*</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.96.1">auto</span></span><span class="koboSpan" id="kobo.97.1"> s1 = std::string {</span><span class="hljs-string"><span class="koboSpan" id="kobo.98.1">"text"</span></span><span class="koboSpan" id="kobo.99.1">};         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.100.1">// std::string</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.101.1">auto</span></span><span class="koboSpan" id="kobo.102.1"> v1 = std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.103.1">int</span></span><span class="koboSpan" id="kobo.104.1">&gt; { </span><span class="hljs-number"><span class="koboSpan" id="kobo.105.1">1</span></span><span class="koboSpan" id="kobo.106.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.107.1">2</span></span><span class="koboSpan" id="kobo.108.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.109.1">3</span></span><span class="koboSpan" id="kobo.110.1"> }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.111.1">// std::vector&lt;int&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.112.1">auto</span></span><span class="koboSpan" id="kobo.113.1"> p  = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.114.1">make_shared</span></span><span class="koboSpan" id="kobo.115.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.116.1">int</span></span><span class="koboSpan" id="kobo.117.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.118.1">42</span></span><span class="koboSpan" id="kobo.119.1">);    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.120.1">// std::shared_ptr&lt;int&gt;</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.121.1">To declare </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.122.1">named lambda functions, with the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.123.1">auto name = lambda-expression</span></code><span class="koboSpan" id="kobo.124.1">, unless the lambda needs to be passed or returned to a function:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.125.1">auto</span></span><span class="koboSpan" id="kobo.126.1"> upper = [](</span><span class="hljs-type"><span class="koboSpan" id="kobo.127.1">char</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.128.1">const</span></span><span class="koboSpan" id="kobo.129.1"> c) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.130.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.131.1">toupper</span></span><span class="koboSpan" id="kobo.132.1">(c); };
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.133.1">To declare lambda parameters and return values:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.134.1">auto</span></span><span class="koboSpan" id="kobo.135.1"> add = [](</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.136.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.137.1">const</span></span><span class="koboSpan" id="kobo.138.1"> a, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.139.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.140.1">const</span></span><span class="koboSpan" id="kobo.141.1"> b) {</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.142.1">return</span></span><span class="koboSpan" id="kobo.143.1"> a + b;};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.144.1">To declare a function return type when you don’t want to commit to a specific type:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.145.1">template</span></span><span class="koboSpan" id="kobo.146.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.147.1">typename</span></span><span class="koboSpan" id="kobo.148.1"> F, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.149.1">typename</span></span><span class="koboSpan" id="kobo.150.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.151.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.152.1">apply</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.153.1">(F&amp;&amp; f, T value)</span></span><span class="koboSpan" id="kobo.154.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.155.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.156.1">f</span></span><span class="koboSpan" id="kobo.157.1">(value);
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-18"><span class="koboSpan" id="kobo.158.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.159.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.160.1">auto</span></code><span class="koboSpan" id="kobo.161.1"> specifier is basically a placeholder for an actual type. </span><span class="koboSpan" id="kobo.161.2">When using </span><code class="inlineCode"><span class="koboSpan" id="kobo.162.1">auto</span></code><span class="koboSpan" id="kobo.163.1">, the compiler deduces the actual type from the following instances:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.164.1">From the type of expression used to initialize a variable, when </span><code class="inlineCode"><span class="koboSpan" id="kobo.165.1">auto</span></code><span class="koboSpan" id="kobo.166.1"> is used to declare variables.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.167.1">From the trailing return type or the return expression type of a function, when </span><code class="inlineCode"><span class="koboSpan" id="kobo.168.1">auto</span></code><span class="koboSpan" id="kobo.169.1"> is used as a placeholder for the return type of a function.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.170.1">In some cases, it is necessary to commit to a specific type. </span><span class="koboSpan" id="kobo.170.2">For instance, in the first example, the compiler deduces the type of </span><code class="inlineCode"><span class="koboSpan" id="kobo.171.1">s</span></code><span class="koboSpan" id="kobo.172.1"> to be </span><code class="inlineCode"><span class="koboSpan" id="kobo.173.1">char const *</span></code><span class="koboSpan" id="kobo.174.1">. </span><span class="koboSpan" id="kobo.174.2">If the intention was to have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.175.1">std::string</span></code><span class="koboSpan" id="kobo.176.1">, then the type must be specified explicitly. </span><span class="koboSpan" id="kobo.176.2">Similarly, the type of </span><code class="inlineCode"><span class="koboSpan" id="kobo.177.1">v</span></code><span class="koboSpan" id="kobo.178.1"> was deduced as </span><code class="inlineCode"><span class="koboSpan" id="kobo.179.1">std::initializer_list&lt;int&gt;</span></code><span class="koboSpan" id="kobo.180.1"> because it is bound to </span><code class="inlineCode"><span class="koboSpan" id="kobo.181.1">auto</span></code><span class="koboSpan" id="kobo.182.1"> and not a specific type; in this case, the rules say the deduced type is </span><code class="inlineCode"><span class="koboSpan" id="kobo.183.1">std::initializer_list&lt;T&gt;</span></code><span class="koboSpan" id="kobo.184.1">, with </span><code class="inlineCode"><span class="koboSpan" id="kobo.185.1">T</span></code><span class="koboSpan" id="kobo.186.1"> being </span><code class="inlineCode"><span class="koboSpan" id="kobo.187.1">int</span></code><span class="koboSpan" id="kobo.188.1"> in our case. </span><span class="koboSpan" id="kobo.188.2">However, the intention could be to have a </span><code class="inlineCode"><span class="koboSpan" id="kobo.189.1">std::vector&lt;int&gt;</span></code><span class="koboSpan" id="kobo.190.1">. </span><span class="koboSpan" id="kobo.190.2">In such cases, the type must be specified explicitly on the right side of the assignment.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.191.1">There are some important </span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.192.1">benefits of using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">auto</span></code><span class="koboSpan" id="kobo.194.1"> specifier instead of actual types; the following is a list of, perhaps, the most important ones:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.195.1">It is not possible to leave a variable uninitialized. </span><span class="koboSpan" id="kobo.195.2">This is a common mistake that developers make when declaring variables and specifying the actual type. </span><span class="koboSpan" id="kobo.195.3">However, this is not possible with </span><code class="inlineCode"><span class="koboSpan" id="kobo.196.1">auto</span></code><span class="koboSpan" id="kobo.197.1">, which requires an initialization of the variable in order to deduce the type. </span><span class="koboSpan" id="kobo.197.2">Initializing variables with a defined value is important because uninitialized variables incur undefined behavior.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.198.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.199.1">auto</span></code><span class="koboSpan" id="kobo.200.1"> ensures that you always use the intended type and that implicit conversion will not occur. </span><span class="koboSpan" id="kobo.200.2">Consider the following example where we retrieve the size of a vector for a local variable. </span><span class="koboSpan" id="kobo.200.3">In the first case, the type of the variable is </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">int</span></code><span class="koboSpan" id="kobo.202.1">, although the </span><code class="inlineCode"><span class="koboSpan" id="kobo.203.1">size()</span></code><span class="koboSpan" id="kobo.204.1"> method returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.205.1">size_t</span></code><span class="koboSpan" id="kobo.206.1">. </span><span class="koboSpan" id="kobo.206.2">This means an implicit conversion from </span><code class="inlineCode"><span class="koboSpan" id="kobo.207.1">size_t</span></code><span class="koboSpan" id="kobo.208.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.209.1">int</span></code><span class="koboSpan" id="kobo.210.1"> will occur. </span><span class="koboSpan" id="kobo.210.2">However, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.211.1">auto</span></code><span class="koboSpan" id="kobo.212.1"> for the type will deduce the correct type—that is, </span><code class="inlineCode"><span class="koboSpan" id="kobo.213.1">size_t</span></code><span class="koboSpan" id="kobo.214.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.215.1">auto</span></span><span class="koboSpan" id="kobo.216.1"> v = std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.217.1">int</span></span><span class="koboSpan" id="kobo.218.1">&gt;{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.219.1">1</span></span><span class="koboSpan" id="kobo.220.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.221.1">2</span></span><span class="koboSpan" id="kobo.222.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.223.1">3</span></span><span class="koboSpan" id="kobo.224.1"> };
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.225.1">// implicit conversion, possible loss of data</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.226.1">int</span></span><span class="koboSpan" id="kobo.227.1"> size1 = v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.228.1">size</span></span><span class="koboSpan" id="kobo.229.1">();
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.230.1">// OK</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.231.1">auto</span></span><span class="koboSpan" id="kobo.232.1"> size2 = v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.233.1">size</span></span><span class="koboSpan" id="kobo.234.1">();
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.235.1">// ill-formed (warning in gcc, error in clang &amp; VC++)</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.236.1">auto</span></span><span class="koboSpan" id="kobo.237.1"> size3 = </span><span class="hljs-type"><span class="koboSpan" id="kobo.238.1">int</span></span><span class="koboSpan" id="kobo.239.1">{ v.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.240.1">size</span></span><span class="koboSpan" id="kobo.241.1">() };
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.242.1">Using </span><code class="inlineCode"><span class="koboSpan" id="kobo.243.1">auto</span></code><span class="koboSpan" id="kobo.244.1"> promotes good object-oriented practices, such as preferring interfaces over implementations. </span><span class="koboSpan" id="kobo.244.2">This is important in </span><strong class="keyWord"><span class="koboSpan" id="kobo.245.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.246.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.247.1">OOP</span></strong><span class="koboSpan" id="kobo.248.1">) because it provides the flexibility to change between different implementations, modularity of the code, and better testability because it’s easy to mock objects. </span><span class="koboSpan" id="kobo.248.2">The fewer the number of types specified, the more generic the code is and more open to future changes, which is a fundamental principle of OOP.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.249.1">It means</span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.250.1"> less typing (in general) and less concern for actual types that we don’t care about anyway. </span><span class="koboSpan" id="kobo.250.2">It is very often the case that even though we explicitly specify the type, we don’t actually care about it. </span><span class="koboSpan" id="kobo.250.3">A very common case is with iterators, but there are many more. </span><span class="koboSpan" id="kobo.250.4">When you want to iterate over a range, you don’t care about the actual type of the iterator. </span><span class="koboSpan" id="kobo.250.5">You are only interested in the iterator itself; so using </span><code class="inlineCode"><span class="koboSpan" id="kobo.251.1">auto</span></code><span class="koboSpan" id="kobo.252.1"> saves time spent typing (possibly long) names and helps you focus on actual code and not type names. </span><span class="koboSpan" id="kobo.252.2">In the following example, in the first </span><code class="inlineCode"><span class="koboSpan" id="kobo.253.1">for</span></code><span class="koboSpan" id="kobo.254.1"> loop, we explicitly use the type of the iterator. </span><span class="koboSpan" id="kobo.254.2">It is a lot of text to type; the long statements can actually make the code less readable, and you also need to know the type name, which you actually don’t care about. </span><span class="koboSpan" id="kobo.254.3">The second loop with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.255.1">auto</span></code><span class="koboSpan" id="kobo.256.1"> specifier looks simpler and saves you from typing and caring about actual types:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.257.1">std::map&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.258.1">int</span></span><span class="koboSpan" id="kobo.259.1">, std::string&gt; m;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.260.1">for</span></span><span class="koboSpan" id="kobo.261.1"> (std::map&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.262.1">int</span></span><span class="koboSpan" id="kobo.263.1">, std::string&gt;::const_iterator
  it = m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.264.1">cbegin</span></span><span class="koboSpan" id="kobo.265.1">();
  it != m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.266.1">cend</span></span><span class="koboSpan" id="kobo.267.1">(); ++it)
{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.268.1">/*...*/</span></span><span class="koboSpan" id="kobo.269.1"> }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.270.1">for</span></span><span class="koboSpan" id="kobo.271.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.272.1">auto</span></span><span class="koboSpan" id="kobo.273.1"> it = m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.274.1">cbegin</span></span><span class="koboSpan" id="kobo.275.1">(); it != m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.276.1">cend</span></span><span class="koboSpan" id="kobo.277.1">(); ++it)
{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.278.1">/*...*/</span></span><span class="koboSpan" id="kobo.279.1"> }
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.280.1">Declaring variables with </span><code class="inlineCode"><span class="koboSpan" id="kobo.281.1">auto</span></code><span class="koboSpan" id="kobo.282.1"> provides a consistent coding style, with the type always on the right-hand side. </span><span class="koboSpan" id="kobo.282.2">If you allocate objects dynamically, you need to write the type both on the left and right side of the assignment, for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.283.1">int* p = new int(42)</span></code><span class="koboSpan" id="kobo.284.1">. </span><span class="koboSpan" id="kobo.284.2">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.285.1">auto</span></code><span class="koboSpan" id="kobo.286.1">, the type is specified only once on the right side.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.287.1">However, there are some gotchas when using </span><code class="inlineCode"><span class="koboSpan" id="kobo.288.1">auto</span></code><span class="koboSpan" id="kobo.289.1">:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.290.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.291.1">auto</span></code><span class="koboSpan" id="kobo.292.1"> specifier is only a placeholder for the type, not for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.293.1">const</span></code><span class="koboSpan" id="kobo.294.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.295.1">volatile</span></code><span class="koboSpan" id="kobo.296.1"> and reference specifiers. </span><span class="koboSpan" id="kobo.296.2">If you need a </span><code class="inlineCode"><span class="koboSpan" id="kobo.297.1">const</span></code><span class="koboSpan" id="kobo.298.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.299.1">volatile</span></code><span class="koboSpan" id="kobo.300.1"> and/or a reference type, then you need to specify them explicitly. </span><span class="koboSpan" id="kobo.300.2">In the following example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.301.1">get()</span></code><span class="koboSpan" id="kobo.302.1"> member function of </span><code class="inlineCode"><span class="koboSpan" id="kobo.303.1">foo</span></code><span class="koboSpan" id="kobo.304.1"> returns a reference to </span><code class="inlineCode"><span class="koboSpan" id="kobo.305.1">int</span></code><span class="koboSpan" id="kobo.306.1">; when the variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.307.1">x</span></code><span class="koboSpan" id="kobo.308.1"> is initialized from the return value, the type deduced by the compiler is </span><code class="inlineCode"><span class="koboSpan" id="kobo.309.1">int</span></code><span class="koboSpan" id="kobo.310.1">, not </span><code class="inlineCode"><span class="koboSpan" id="kobo.311.1">int&amp;</span></code><span class="koboSpan" id="kobo.312.1">. </span><span class="koboSpan" id="kobo.312.2">Therefore, any change made to </span><code class="inlineCode"><span class="koboSpan" id="kobo.313.1">x</span></code><span class="koboSpan" id="kobo.314.1"> will not propagate to </span><code class="inlineCode"><span class="koboSpan" id="kobo.315.1">foo.x_</span></code><span class="koboSpan" id="kobo.316.1">. </span><span class="koboSpan" id="kobo.316.2">In order to do so, we should use </span><code class="inlineCode"><span class="koboSpan" id="kobo.317.1">auto&amp;</span></code><span class="koboSpan" id="kobo.318.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.319.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.320.1">foo</span></span><span class="koboSpan" id="kobo.321.1"> {
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.322.1">int</span></span><span class="koboSpan" id="kobo.323.1"> x;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.324.1">public</span></span><span class="koboSpan" id="kobo.325.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.326.1">foo</span></span><span class="koboSpan" id="kobo.327.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.328.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.329.1">const</span></span><span class="koboSpan" id="kobo.330.1"> value = </span><span class="hljs-number"><span class="koboSpan" id="kobo.331.1">0</span></span><span class="koboSpan" id="kobo.332.1">) :x{ value } {}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.333.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.334.1">&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.335.1">get</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.336.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.337.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.338.1">return</span></span><span class="koboSpan" id="kobo.339.1"> x; }
};
</span><span class="hljs-function"><span class="koboSpan" id="kobo.340.1">foo </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.341.1">f</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.342.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.343.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.344.1">)</span></span><span class="koboSpan" id="kobo.345.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.346.1">auto</span></span><span class="koboSpan" id="kobo.347.1"> x = f.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.348.1">get</span></span><span class="koboSpan" id="kobo.349.1">();
x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.350.1">100</span></span><span class="koboSpan" id="kobo.351.1">;
std::cout &lt;&lt; f.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.352.1">get</span></span><span class="koboSpan" id="kobo.353.1">() &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.354.1">'\n'</span></span><span class="koboSpan" id="kobo.355.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.356.1">// prints 42</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.357.1">It is not possible to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">auto</span></code><span class="koboSpan" id="kobo.359.1"> for types that are not moveable:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.360.1">auto</span></span><span class="koboSpan" id="kobo.361.1"> ai = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.362.1">atomic</span></span><span class="koboSpan" id="kobo.363.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.364.1">int</span></span><span class="koboSpan" id="kobo.365.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.366.1">42</span></span><span class="koboSpan" id="kobo.367.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.368.1">// error</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.369.1">It is not possible to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.370.1">auto</span></code><span class="koboSpan" id="kobo.371.1"> for multi-word types, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.372.1">long long</span></code><span class="koboSpan" id="kobo.373.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.374.1">long double</span></code><span class="koboSpan" id="kobo.375.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.376.1">struct foo</span></code><span class="koboSpan" id="kobo.377.1">. </span><span class="koboSpan" id="kobo.377.2">However, in the first case, the possible workarounds are to use literals or type aliases; also, with Clang and GCC (but not MSVC) it’s possible to put the type name in parentheses, </span><code class="inlineCode"><span class="koboSpan" id="kobo.378.1">(long long){ 42 }</span></code><span class="koboSpan" id="kobo.379.1">. </span><span class="koboSpan" id="kobo.379.2">As for the second case, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.380.1">struct</span></code><span class="koboSpan" id="kobo.381.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.382.1">class</span></code><span class="koboSpan" id="kobo.383.1"> in that form is only supported in C++ for C compatibility and should be avoided anyway:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.384.1">auto</span></span><span class="koboSpan" id="kobo.385.1"> l1 = </span><span class="hljs-type"><span class="koboSpan" id="kobo.386.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.387.1">long</span></span><span class="koboSpan" id="kobo.388.1">{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.389.1">42</span></span><span class="koboSpan" id="kobo.390.1"> }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.391.1">// error</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.392.1">using</span></span><span class="koboSpan" id="kobo.393.1"> llong = </span><span class="hljs-type"><span class="koboSpan" id="kobo.394.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.395.1">long</span></span><span class="koboSpan" id="kobo.396.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.397.1">auto</span></span><span class="koboSpan" id="kobo.398.1"> l2 = llong{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.399.1">42</span></span><span class="koboSpan" id="kobo.400.1"> };     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.401.1">// OK</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.402.1">auto</span></span><span class="koboSpan" id="kobo.403.1"> l3 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.404.1">42LL</span></span><span class="koboSpan" id="kobo.405.1">;            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.406.1">// OK</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.407.1">auto</span></span><span class="koboSpan" id="kobo.408.1"> l4 = (</span><span class="hljs-type"><span class="koboSpan" id="kobo.409.1">long</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.410.1">long)</span></span><span class="koboSpan" id="kobo.411.1">{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.412.1">42</span></span><span class="koboSpan" id="kobo.413.1"> }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.414.1">// OK with gcc/clang</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.415.1">If you use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.416.1">auto</span></code><span class="koboSpan" id="kobo.417.1"> specifier but still need to know the type, you can do so in most IDEs by putting the cursor over a variable, for instance. </span><span class="koboSpan" id="kobo.417.2">If you leave the IDE, however, that is not possible anymore, and the only way to know the actual type is to deduce it yourself from the initialization expression, which could mean searching through the code for function return types.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.418.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.419.1">auto</span></code><span class="koboSpan" id="kobo.420.1"> can be used </span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.421.1">to specify the return type from a function. </span><span class="koboSpan" id="kobo.421.2">In C++11, this requires a trailing return type in the function declaration. </span><span class="koboSpan" id="kobo.421.3">In C++14, this has been relaxed, and the type of the return value is deduced by the compiler from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.422.1">return</span></code><span class="koboSpan" id="kobo.423.1"> expression. </span><span class="koboSpan" id="kobo.423.2">If there are multiple return values, they should have the same type:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.424.1">// C++11</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.425.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.426.1">func1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.427.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.428.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.429.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.430.1"> i)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.431.1"> -&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.432.1">int</span></span><span class="koboSpan" id="kobo.433.1">
{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.434.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.435.1">2</span></span><span class="koboSpan" id="kobo.436.1">*i; }
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.437.1">// C++14</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.438.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.439.1">func2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.440.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.441.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.442.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.443.1"> i)</span></span><span class="koboSpan" id="kobo.444.1">
{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.445.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.446.1">2</span></span><span class="koboSpan" id="kobo.447.1">*i; }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.448.1">As mentioned earlier, </span><code class="inlineCode"><span class="koboSpan" id="kobo.449.1">auto</span></code><span class="koboSpan" id="kobo.450.1"> does not retain </span><code class="inlineCode"><span class="koboSpan" id="kobo.451.1">const</span></code><span class="koboSpan" id="kobo.452.1">/</span><code class="inlineCode"><span class="koboSpan" id="kobo.453.1">volatile</span></code><span class="koboSpan" id="kobo.454.1"> and reference qualifiers. </span><span class="koboSpan" id="kobo.454.2">This leads to problems with </span><code class="inlineCode"><span class="koboSpan" id="kobo.455.1">auto</span></code><span class="koboSpan" id="kobo.456.1"> as a placeholder for the return type from a function. </span><span class="koboSpan" id="kobo.456.2">To explain this, let’s consider the preceding example with </span><code class="inlineCode"><span class="koboSpan" id="kobo.457.1">foo.get()</span></code><span class="koboSpan" id="kobo.458.1">. </span><span class="koboSpan" id="kobo.458.2">This time, we have a wrapper function called </span><code class="inlineCode"><span class="koboSpan" id="kobo.459.1">proxy_get()</span></code><span class="koboSpan" id="kobo.460.1"> that takes a reference to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.461.1">foo</span></code><span class="koboSpan" id="kobo.462.1">, calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.463.1">get()</span></code><span class="koboSpan" id="kobo.464.1">, and returns the value returned by </span><code class="inlineCode"><span class="koboSpan" id="kobo.465.1">get()</span></code><span class="koboSpan" id="kobo.466.1">, which is an </span><code class="inlineCode"><span class="koboSpan" id="kobo.467.1">int&amp;</span></code><span class="koboSpan" id="kobo.468.1">. </span><span class="koboSpan" id="kobo.468.2">However, the compiler will deduce the return type of </span><code class="inlineCode"><span class="koboSpan" id="kobo.469.1">proxy_get()</span></code><span class="koboSpan" id="kobo.470.1"> as being </span><code class="inlineCode"><span class="koboSpan" id="kobo.471.1">int</span></code><span class="koboSpan" id="kobo.472.1">, not </span><code class="inlineCode"><span class="koboSpan" id="kobo.473.1">int&amp;</span></code><span class="koboSpan" id="kobo.474.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.475.1">Trying to assign that value to an </span><code class="inlineCode"><span class="koboSpan" id="kobo.476.1">int&amp;</span></code><span class="koboSpan" id="kobo.477.1"> fails with an error:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.478.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.479.1">foo</span></span><span class="koboSpan" id="kobo.480.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.481.1">int</span></span><span class="koboSpan" id="kobo.482.1"> x_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.483.1">public</span></span><span class="koboSpan" id="kobo.484.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.485.1">foo</span></span><span class="koboSpan" id="kobo.486.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.487.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.488.1">const</span></span><span class="koboSpan" id="kobo.489.1"> x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.490.1">0</span></span><span class="koboSpan" id="kobo.491.1">) :x_{ x } {}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.492.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.493.1">&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.494.1">get</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.495.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.496.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.497.1">return</span></span><span class="koboSpan" id="kobo.498.1"> x_; }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.499.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.500.1">proxy_get</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.501.1">(foo&amp; f)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.502.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.503.1">return</span></span><span class="koboSpan" id="kobo.504.1"> f.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.505.1">get</span></span><span class="koboSpan" id="kobo.506.1">(); }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.507.1">auto</span></span><span class="koboSpan" id="kobo.508.1"> f = foo{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.509.1">42</span></span><span class="koboSpan" id="kobo.510.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.511.1">auto</span></span><span class="koboSpan" id="kobo.512.1">&amp; x = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.513.1">proxy_get</span></span><span class="koboSpan" id="kobo.514.1">(f); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.515.1">// cannot convert from 'int' to 'int &amp;'</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.516.1">To fix this, we need to </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.517.1">actually return </span><code class="inlineCode"><span class="koboSpan" id="kobo.518.1">auto&amp;</span></code><span class="koboSpan" id="kobo.519.1">. </span><span class="koboSpan" id="kobo.519.2">However, there is a problem with templates and perfect forwarding the return type without knowing whether it is a value or a reference. </span><span class="koboSpan" id="kobo.519.3">The solution to this problem in C++14 is </span><code class="inlineCode"><span class="koboSpan" id="kobo.520.1">decltype(auto)</span></code><span class="koboSpan" id="kobo.521.1">, which will correctly deduce the type:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.522.1">decltype</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.523.1">(</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.524.1">auto</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.525.1">) </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.526.1">proxy_get</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.527.1">(foo&amp; f)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.528.1">
{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.529.1">return</span></span><span class="koboSpan" id="kobo.530.1"> f.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.531.1">get</span></span><span class="koboSpan" id="kobo.532.1">(); }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.533.1">auto</span></span><span class="koboSpan" id="kobo.534.1"> f = foo{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.535.1">42</span></span><span class="koboSpan" id="kobo.536.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.537.1">decltype</span></span><span class="koboSpan" id="kobo.538.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.539.1">auto</span></span><span class="koboSpan" id="kobo.540.1">) x = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.541.1">proxy_get</span></span><span class="koboSpan" id="kobo.542.1">(f);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.543.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.544.1">decltype</span></code><span class="koboSpan" id="kobo.545.1"> specifier is used to inspect the declared type of an entity or an expression. </span><span class="koboSpan" id="kobo.545.2">It’s mostly useful when declaring types is cumbersome or if they can’t be declared at all with the standard notation. </span><span class="koboSpan" id="kobo.545.3">Examples of this include declaring lambda types and types that depend on template parameters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.546.1">The last important case where </span><code class="inlineCode"><span class="koboSpan" id="kobo.547.1">auto</span></code><span class="koboSpan" id="kobo.548.1"> can be used is with lambdas. </span><span class="koboSpan" id="kobo.548.2">As of C++14, both lambda return types and lambda parameter types can be </span><code class="inlineCode"><span class="koboSpan" id="kobo.549.1">auto</span></code><span class="koboSpan" id="kobo.550.1">. </span><span class="koboSpan" id="kobo.550.2">Such a lambda is called a </span><em class="italic"><span class="koboSpan" id="kobo.551.1">generic lambda</span></em><span class="koboSpan" id="kobo.552.1"> because the closure type defined by the lambda has a templated call operator. </span><span class="koboSpan" id="kobo.552.2">The following shows a generic lambda that takes two </span><code class="inlineCode"><span class="koboSpan" id="kobo.553.1">auto</span></code><span class="koboSpan" id="kobo.554.1"> parameters and returns the result of applying </span><code class="inlineCode"><span class="koboSpan" id="kobo.555.1">operator+</span></code><span class="koboSpan" id="kobo.556.1"> to the actual types:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.557.1">auto</span></span><span class="koboSpan" id="kobo.558.1"> ladd = [] (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.559.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.560.1">const</span></span><span class="koboSpan" id="kobo.561.1"> a, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.562.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.563.1">const</span></span><span class="koboSpan" id="kobo.564.1"> b) { </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.565.1">return</span></span><span class="koboSpan" id="kobo.566.1"> a + b; };
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.567.1">The compiler-generated function object has the following form, where the call operator is a function template:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.568.1">struct</span></span><span class="koboSpan" id="kobo.569.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.570.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.571.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.572.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.573.1"> T, </span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.574.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.575.1"> U&gt;</span></span>
<span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.576.1">auto</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.577.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.578.1">()</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.579.1">(T </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.580.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.581.1"> a, U </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.582.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.583.1"> b)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.584.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.585.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.586.1">return</span></span><span class="koboSpan" id="kobo.587.1"> a+b; }
} L;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.588.1">This lambda can be used to add anything for which the </span><code class="inlineCode"><span class="koboSpan" id="kobo.589.1">operator+</span></code><span class="koboSpan" id="kobo.590.1"> is defined, as shown in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.591.1">auto</span></span><span class="koboSpan" id="kobo.592.1"> i = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.593.1">ladd</span></span><span class="koboSpan" id="kobo.594.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.595.1">40</span></span><span class="koboSpan" id="kobo.596.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.597.1">2</span></span><span class="koboSpan" id="kobo.598.1">);            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.599.1">// 42</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.600.1">auto</span></span><span class="koboSpan" id="kobo.601.1"> s = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.602.1">ladd</span></span><span class="koboSpan" id="kobo.603.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.604.1">"forty"</span></span><span class="koboSpan" id="kobo.605.1">s, </span><span class="hljs-string"><span class="koboSpan" id="kobo.606.1">"two"</span></span><span class="koboSpan" id="kobo.607.1">s); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.608.1">// "fortytwo"s</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.609.1">In this example, we used the </span><code class="inlineCode"><span class="koboSpan" id="kobo.610.1">ladd</span></code><span class="koboSpan" id="kobo.611.1"> lambda</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.612.1"> to add two integers and concatenate them to </span><code class="inlineCode"><span class="koboSpan" id="kobo.613.1">std::string</span></code><span class="koboSpan" id="kobo.614.1"> objects (using the C++14 user-defined literal </span><code class="inlineCode"><span class="koboSpan" id="kobo.615.1">operator ""s</span></code><span class="koboSpan" id="kobo.616.1">).</span></p>
<h2 class="heading-2" id="_idParaDest-19"><span class="koboSpan" id="kobo.617.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.618.1">Creating type aliases and alias templates</span></em><span class="koboSpan" id="kobo.619.1">, to learn about aliases for types</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.620.1">Understanding uniform initialization</span></em><span class="koboSpan" id="kobo.621.1">, to see how brace-initialization works</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-20"><span class="koboSpan" id="kobo.622.1">Creating type aliases and alias templates</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.623.1">In C++, it is possible to create synonyms that can be used instead of a type name. </span><span class="koboSpan" id="kobo.623.2">This is achieved by creating a </span><code class="inlineCode"><span class="koboSpan" id="kobo.624.1">typedef</span></code><span class="koboSpan" id="kobo.625.1"> declaration. </span><span class="koboSpan" id="kobo.625.2">This </span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.626.1">is useful in several cases, such as creating shorter or more meaningful names for a type or names for function pointers. </span><span class="koboSpan" id="kobo.626.2">However, </span><code class="inlineCode"><span class="koboSpan" id="kobo.627.1">typedef</span></code><span class="koboSpan" id="kobo.628.1"> declarations cannot be used with templates to create template type aliases. </span><span class="koboSpan" id="kobo.628.2">An </span><code class="inlineCode"><span class="koboSpan" id="kobo.629.1">std::vector&lt;T&gt;</span></code><span class="koboSpan" id="kobo.630.1">, for instance, is not a type (</span><code class="inlineCode"><span class="koboSpan" id="kobo.631.1">std::vector&lt;int&gt;</span></code><span class="koboSpan" id="kobo.632.1"> is a type), but a sort of family of all types that can be created when the type placeholder </span><code class="inlineCode"><span class="koboSpan" id="kobo.633.1">T</span></code><span class="koboSpan" id="kobo.634.1"> is replaced with an actual type.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.635.1">In C++11, a type alias</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.636.1"> is a name for another already declared type, and an alias template is a name for another already declared template. </span><span class="koboSpan" id="kobo.636.2">Both of these types of aliases are introduced with a new </span><code class="inlineCode"><span class="koboSpan" id="kobo.637.1">using</span></code><span class="koboSpan" id="kobo.638.1"> syntax.</span></p>
<h2 class="heading-2" id="_idParaDest-21"><span class="koboSpan" id="kobo.639.1">How to do it...</span></h2>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.640.1">Create </span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.641.1">type aliases with the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.642.1">using identifier = type-id</span></code><span class="koboSpan" id="kobo.643.1">, as in the following examples:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.644.1">using</span></span><span class="koboSpan" id="kobo.645.1"> byte     = </span><span class="hljs-type"><span class="koboSpan" id="kobo.646.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.647.1">char</span></span><span class="koboSpan" id="kobo.648.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.649.1">using</span></span><span class="koboSpan" id="kobo.650.1"> byte_ptr = </span><span class="hljs-type"><span class="koboSpan" id="kobo.651.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.652.1">char</span></span><span class="koboSpan" id="kobo.653.1"> *;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.654.1">using</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.655.1">array_t</span></span><span class="koboSpan" id="kobo.656.1">  = </span><span class="hljs-type"><span class="koboSpan" id="kobo.657.1">int</span></span><span class="koboSpan" id="kobo.658.1">[</span><span class="hljs-number"><span class="koboSpan" id="kobo.659.1">10</span></span><span class="koboSpan" id="kobo.660.1">];
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.661.1">using</span></span><span class="koboSpan" id="kobo.662.1"> fn       = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.663.1">void</span></span><span class="koboSpan" id="kobo.664.1">(byte, </span><span class="hljs-type"><span class="koboSpan" id="kobo.665.1">double</span></span><span class="koboSpan" id="kobo.666.1">);
</span><span class="hljs-type"><span class="koboSpan" id="kobo.667.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.668.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.669.1">(byte b, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.670.1">double</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.671.1"> d)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.672.1">{ </span><span class="hljs-comment"><span class="koboSpan" id="kobo.673.1">/*...*/</span></span><span class="koboSpan" id="kobo.674.1"> }
byte b{</span><span class="hljs-number"><span class="koboSpan" id="kobo.675.1">42</span></span><span class="koboSpan" id="kobo.676.1">};
byte_ptr pb = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.677.1">new</span></span><span class="koboSpan" id="kobo.678.1"> byte[</span><span class="hljs-number"><span class="koboSpan" id="kobo.679.1">10</span></span><span class="koboSpan" id="kobo.680.1">] {</span><span class="hljs-number"><span class="koboSpan" id="kobo.681.1">0</span></span><span class="koboSpan" id="kobo.682.1">};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.683.1">array_t</span></span><span class="koboSpan" id="kobo.684.1"> a{</span><span class="hljs-number"><span class="koboSpan" id="kobo.685.1">0</span></span><span class="koboSpan" id="kobo.686.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.687.1">1</span></span><span class="koboSpan" id="kobo.688.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.689.1">2</span></span><span class="koboSpan" id="kobo.690.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.691.1">3</span></span><span class="koboSpan" id="kobo.692.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.693.1">4</span></span><span class="koboSpan" id="kobo.694.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.695.1">5</span></span><span class="koboSpan" id="kobo.696.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.697.1">6</span></span><span class="koboSpan" id="kobo.698.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.699.1">7</span></span><span class="koboSpan" id="kobo.700.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.701.1">8</span></span><span class="koboSpan" id="kobo.702.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.703.1">9</span></span><span class="koboSpan" id="kobo.704.1">};
fn* f = func;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.705.1">Create alias templates</span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.706.1"> with the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.707.1">template&lt;template-params-list&gt; identifier = type-id</span></code><span class="koboSpan" id="kobo.708.1">, as in the following examples:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.709.1">template</span></span><span class="koboSpan" id="kobo.710.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.711.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.712.1">T</span></span><span class="koboSpan" id="kobo.713.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.714.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.715.1">custom_allocator</span></span><span class="koboSpan" id="kobo.716.1"> { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.717.1">/* ... </span><span class="koboSpan" id="kobo.717.2">*/</span></span><span class="koboSpan" id="kobo.718.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.719.1">template</span></span><span class="koboSpan" id="kobo.720.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.721.1">typename</span></span><span class="koboSpan" id="kobo.722.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.723.1">using</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.724.1">vec_t</span></span><span class="koboSpan" id="kobo.725.1"> = std::vector&lt;T, custom_allocator&lt;T&gt;&gt;;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.726.1">vec_t</span></span><span class="koboSpan" id="kobo.727.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.728.1">int</span></span><span class="koboSpan" id="kobo.729.1">&gt;           vi;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.730.1">vec_t</span></span><span class="koboSpan" id="kobo.731.1">&lt;std::string&gt;   vs;
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.732.1">For consistency and readability, you should do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.733.1">Not mix </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">typedef</span></code><span class="koboSpan" id="kobo.735.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.736.1">using</span></code><span class="koboSpan" id="kobo.737.1"> declarations when creating aliases</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.738.1">Prefer the </span><code class="inlineCode"><span class="koboSpan" id="kobo.739.1">using</span></code><span class="koboSpan" id="kobo.740.1"> syntax to create names of function pointer types</span></li>
</ul>
<h2 class="heading-2" id="_idParaDest-22"><span class="koboSpan" id="kobo.741.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.742.1">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.743.1">typedef</span></code><span class="koboSpan" id="kobo.744.1"> declaration</span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.745.1"> introduces a synonym (an alias, in other words) for a type. </span><span class="koboSpan" id="kobo.745.2">It does not introduce another type (like a </span><code class="inlineCode"><span class="koboSpan" id="kobo.746.1">class</span></code><span class="koboSpan" id="kobo.747.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.748.1">struct</span></code><span class="koboSpan" id="kobo.749.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.750.1">union</span></code><span class="koboSpan" id="kobo.751.1">, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.752.1">enum</span></code><span class="koboSpan" id="kobo.753.1"> declaration). </span><span class="koboSpan" id="kobo.753.2">Type names introduced with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.754.1">typedef</span></code><span class="koboSpan" id="kobo.755.1"> declaration follow the same hiding rules as identifier names. </span><span class="koboSpan" id="kobo.755.2">They can also be redeclared, but only to refer to the same type (therefore, you can have valid multiple </span><code class="inlineCode"><span class="koboSpan" id="kobo.756.1">typedef</span></code><span class="koboSpan" id="kobo.757.1"> declarations that introduce the same type name synonym in a translation unit, as long as it is a synonym for the same type). </span><span class="koboSpan" id="kobo.757.2">The following are typical</span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.758.1"> examples of </span><code class="inlineCode"><span class="koboSpan" id="kobo.759.1">typedef</span></code><span class="koboSpan" id="kobo.760.1"> declarations:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.761.1">typedef</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.762.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.763.1">char</span></span><span class="koboSpan" id="kobo.764.1">   byte;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.765.1">typedef</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.766.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.767.1">char</span></span><span class="koboSpan" id="kobo.768.1"> * byte_ptr;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.769.1">typedef</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.770.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.771.1">array_t</span></span><span class="koboSpan" id="kobo.772.1">[</span><span class="hljs-number"><span class="koboSpan" id="kobo.773.1">10</span></span><span class="koboSpan" id="kobo.774.1">];
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.775.1">typedef</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.776.1">void</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.777.1">(*fn)(byte, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.778.1">double</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.779.1">)</span></span><span class="koboSpan" id="kobo.780.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.781.1">template</span></span><span class="koboSpan" id="kobo.782.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.783.1">typename</span></span><span class="koboSpan" id="kobo.784.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.785.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.786.1">foo</span></span><span class="koboSpan" id="kobo.787.1"> {
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.788.1">typedef</span></span><span class="koboSpan" id="kobo.789.1"> T value_type;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.790.1">typedef</span></span><span class="koboSpan" id="kobo.791.1"> std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.792.1">int</span></span><span class="koboSpan" id="kobo.793.1">&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.794.1">vint_t</span></span><span class="koboSpan" id="kobo.795.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.796.1">typedef</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.797.1">int</span></span><span class="koboSpan" id="kobo.798.1"> INTEGER;
INTEGER x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.799.1">10</span></span><span class="koboSpan" id="kobo.800.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.801.1">typedef</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.802.1">int</span></span><span class="koboSpan" id="kobo.803.1"> INTEGER; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.804.1">// redeclaration of same type</span></span><span class="koboSpan" id="kobo.805.1">
INTEGER y = </span><span class="hljs-number"><span class="koboSpan" id="kobo.806.1">20</span></span><span class="koboSpan" id="kobo.807.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.808.1">A type alias declaration</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.809.1"> is equivalent to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.810.1">typedef</span></code><span class="koboSpan" id="kobo.811.1"> declaration. </span><span class="koboSpan" id="kobo.811.2">It can appear in a block scope, class scope, or namespace scope. </span><span class="koboSpan" id="kobo.811.3">According to C++11 standard (paragraph 9.2.4, document version N4917):</span></p>
<blockquote class="packt_quote">
<p class="quote"><span class="koboSpan" id="kobo.812.1">A typedef-name can also be introduced by an alias declaration. </span><span class="koboSpan" id="kobo.812.2">The identifier following the using keyword becomes a typedef-name and the optional attribute-specifier-seq following the identifier appertains to that typedef-name. </span><span class="koboSpan" id="kobo.812.3">It has the same semantics as if it were introduced by the typedef specifier. </span><span class="koboSpan" id="kobo.812.4">In particular, it does not define a new type and it shall not appear in the type-id.</span></p>
</blockquote>
<p class="normal"><span class="koboSpan" id="kobo.813.1">An alias declaration is, however, more readable and clearer about the actual type that is aliased when it comes to creating aliases for array types and function pointer types. </span><span class="koboSpan" id="kobo.813.2">In the examples from the </span><em class="italic"><span class="koboSpan" id="kobo.814.1">How to do it...</span></em><span class="koboSpan" id="kobo.815.1"> section, it is easily understandable that </span><code class="inlineCode"><span class="koboSpan" id="kobo.816.1">array_t</span></code><span class="koboSpan" id="kobo.817.1"> is a name for the type array of 10 integers, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.818.1">fn</span></code><span class="koboSpan" id="kobo.819.1"> is a name for a function type that takes two parameters of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.820.1">byte</span></code><span class="koboSpan" id="kobo.821.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.822.1">double</span></code><span class="koboSpan" id="kobo.823.1"> and returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.824.1">void</span></code><span class="koboSpan" id="kobo.825.1">. </span><span class="koboSpan" id="kobo.825.2">This is also consistent with the syntax for declaring </span><code class="inlineCode"><span class="koboSpan" id="kobo.826.1">std::function</span></code><span class="koboSpan" id="kobo.827.1"> objects (for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.828.1">std::function&lt;void(byte, double)&gt; f</span></code><span class="koboSpan" id="kobo.829.1">).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.830.1">It is important to take note of the following things:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.831.1">Alias templates </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.832.1">cannot be partially or explicitly specialized.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.833.1">Alias templates are never deduced by template argument deduction when deducing a template parameter.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.834.1">The type produced when specializing an alias template is not allowed to directly or indirectly make use of its own type.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.835.1">The driving purpose of </span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.836.1">the new syntax is to define alias templates. </span><span class="koboSpan" id="kobo.836.2">These are templates that, when specialized, are equivalent to the result of substituting the template arguments of the alias template for the template parameters in the type-id.</span></p>
<h2 class="heading-2" id="_idParaDest-23"><span class="koboSpan" id="kobo.837.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.838.1">Simplifying code with class template argument deduction</span></em><span class="koboSpan" id="kobo.839.1">, to learn how to use class templates without explicitly specifying template arguments</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-24"><span class="koboSpan" id="kobo.840.1">Understanding uniform initialization</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.841.1">Brace-initialization</span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.842.1"> is a uniform method for initializing data in C++11. </span><span class="koboSpan" id="kobo.842.2">For this reason, it is also called </span><em class="italic"><span class="koboSpan" id="kobo.843.1">uniform initialization</span></em><span class="koboSpan" id="kobo.844.1">. </span><span class="koboSpan" id="kobo.844.2">It is arguably one of the most important features of C++11 that developers should understand and use. </span><span class="koboSpan" id="kobo.844.3">It removes previous distinctions between initializing fundamental types, aggregate and non-aggregate types, and arrays and standard containers.</span></p>
<h2 class="heading-2" id="_idParaDest-25"><span class="koboSpan" id="kobo.845.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.846.1">To continue with this recipe, you </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.847.1">need to be familiar with direct initialization, which initializes an object from an explicit set of constructor arguments, and copy initialization, which initializes an object from another object. </span><span class="koboSpan" id="kobo.847.2">The following is a simple example of both types of initializations:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.848.1">std::string </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.849.1">s1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.850.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.851.1">"test"</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.852.1">)</span></span><span class="koboSpan" id="kobo.853.1">;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.854.1">// direct initialization</span></span><span class="koboSpan" id="kobo.855.1">
std::string s2 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.856.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.857.1">test"</span></span><span class="koboSpan" id="kobo.858.1">;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.859.1">// copy initialization</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.860.1">With these in mind, let’s explore how to perform uniform initialization.</span></p>
<h2 class="heading-2" id="_idParaDest-26"><span class="koboSpan" id="kobo.861.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.862.1">To uniformly initialize</span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.863.1"> objects regardless of their type, use the brace-initialization form </span><code class="inlineCode"><span class="koboSpan" id="kobo.864.1">{}</span></code><span class="koboSpan" id="kobo.865.1">, which can be used for both direct initialization and copy initialization. </span><span class="koboSpan" id="kobo.865.2">When used with brace-initialization, these are called direct-list and copy-list-initialization:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.866.1">T object {other};   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.867.1">// direct-list-initialization</span></span><span class="koboSpan" id="kobo.868.1">
T object = {other}; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.869.1">// copy-list-initialization</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.870.1">Examples of uniform initialization are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.871.1">Standard containers:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.872.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.873.1">int</span></span><span class="koboSpan" id="kobo.874.1">&gt; v { </span><span class="hljs-number"><span class="koboSpan" id="kobo.875.1">1</span></span><span class="koboSpan" id="kobo.876.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.877.1">2</span></span><span class="koboSpan" id="kobo.878.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.879.1">3</span></span><span class="koboSpan" id="kobo.880.1"> };
std::map&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.881.1">int</span></span><span class="koboSpan" id="kobo.882.1">, std::string&gt; m { {</span><span class="hljs-number"><span class="koboSpan" id="kobo.883.1">1</span></span><span class="koboSpan" id="kobo.884.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.885.1">"one"</span></span><span class="koboSpan" id="kobo.886.1">}, { </span><span class="hljs-number"><span class="koboSpan" id="kobo.887.1">2</span></span><span class="koboSpan" id="kobo.888.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.889.1">"two"</span></span><span class="koboSpan" id="kobo.890.1"> }};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.891.1">Dynamically allocated arrays:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.892.1">int</span></span><span class="koboSpan" id="kobo.893.1">* arr2 = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.894.1">new</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.895.1">int</span></span><span class="koboSpan" id="kobo.896.1">[</span><span class="hljs-number"><span class="koboSpan" id="kobo.897.1">3</span></span><span class="koboSpan" id="kobo.898.1">]{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.899.1">1</span></span><span class="koboSpan" id="kobo.900.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.901.1">2</span></span><span class="koboSpan" id="kobo.902.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.903.1">3</span></span><span class="koboSpan" id="kobo.904.1"> };
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.905.1">Arrays:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.906.1">int</span></span><span class="koboSpan" id="kobo.907.1"> arr1[</span><span class="hljs-number"><span class="koboSpan" id="kobo.908.1">3</span></span><span class="koboSpan" id="kobo.909.1">] { </span><span class="hljs-number"><span class="koboSpan" id="kobo.910.1">1</span></span><span class="koboSpan" id="kobo.911.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.912.1">2</span></span><span class="koboSpan" id="kobo.913.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.914.1">3</span></span><span class="koboSpan" id="kobo.915.1"> };
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.916.1">Built-in types:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.917.1">int</span></span><span class="koboSpan" id="kobo.918.1"> i { </span><span class="hljs-number"><span class="koboSpan" id="kobo.919.1">42</span></span><span class="koboSpan" id="kobo.920.1"> };
</span><span class="hljs-type"><span class="koboSpan" id="kobo.921.1">double</span></span><span class="koboSpan" id="kobo.922.1"> d { </span><span class="hljs-number"><span class="koboSpan" id="kobo.923.1">1.2</span></span><span class="koboSpan" id="kobo.924.1"> };
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.925.1">User-defined types:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.926.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.927.1">foo</span></span><span class="koboSpan" id="kobo.928.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.929.1">int</span></span><span class="koboSpan" id="kobo.930.1"> a_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.931.1">double</span></span><span class="koboSpan" id="kobo.932.1"> b_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.933.1">public</span></span><span class="koboSpan" id="kobo.934.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.935.1">foo</span></span><span class="koboSpan" id="kobo.936.1">():</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.937.1">a_</span></span><span class="koboSpan" id="kobo.938.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.939.1">0</span></span><span class="koboSpan" id="kobo.940.1">), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.941.1">b_</span></span><span class="koboSpan" id="kobo.942.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.943.1">0</span></span><span class="koboSpan" id="kobo.944.1">) {}
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.945.1">foo</span></span><span class="koboSpan" id="kobo.946.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.947.1">int</span></span><span class="koboSpan" id="kobo.948.1"> a, </span><span class="hljs-type"><span class="koboSpan" id="kobo.949.1">double</span></span><span class="koboSpan" id="kobo.950.1"> b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.951.1">0.0</span></span><span class="koboSpan" id="kobo.952.1">):</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.953.1">a_</span></span><span class="koboSpan" id="kobo.954.1">(a), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.955.1">b_</span></span><span class="koboSpan" id="kobo.956.1">(b) {}
};
foo f1{};
foo f2{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.957.1">42</span></span><span class="koboSpan" id="kobo.958.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.959.1">1.2</span></span><span class="koboSpan" id="kobo.960.1"> };
foo f3{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.961.1">42</span></span><span class="koboSpan" id="kobo.962.1"> };
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.963.1">User-defined </span><strong class="keyWord"><span class="koboSpan" id="kobo.964.1">Plain Old Data</span></strong><span class="koboSpan" id="kobo.965.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.966.1">POD</span></strong><span class="koboSpan" id="kobo.967.1">) types:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.968.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.969.1">bar</span></span><span class="koboSpan" id="kobo.970.1"> { </span><span class="hljs-type"><span class="koboSpan" id="kobo.971.1">int</span></span><span class="koboSpan" id="kobo.972.1"> a_; </span><span class="hljs-type"><span class="koboSpan" id="kobo.973.1">double</span></span><span class="koboSpan" id="kobo.974.1"> b_;};
bar b{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.975.1">42</span></span><span class="koboSpan" id="kobo.976.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.977.1">1.2</span></span><span class="koboSpan" id="kobo.978.1"> };
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-27"><span class="koboSpan" id="kobo.979.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.980.1">Before C++11, objects required </span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.981.1">different types of initialization based on their type:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.982.1">Fundamental types could be initialized using assignment:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.983.1">int</span></span><span class="koboSpan" id="kobo.984.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.985.1">42</span></span><span class="koboSpan" id="kobo.986.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.987.1">double</span></span><span class="koboSpan" id="kobo.988.1"> b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.989.1">1.2</span></span><span class="koboSpan" id="kobo.990.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.991.1">Class objects could also be initialized using an assignment from a single value if they had a conversion constructor (prior to C++11, a constructor with a single parameter was called a </span><em class="italic"><span class="koboSpan" id="kobo.992.1">conversion constructor</span></em><span class="koboSpan" id="kobo.993.1">):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.994.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.995.1">foo</span></span><span class="koboSpan" id="kobo.996.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.997.1">int</span></span><span class="koboSpan" id="kobo.998.1"> a_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.999.1">public</span></span><span class="koboSpan" id="kobo.1000.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1001.1">foo</span></span><span class="koboSpan" id="kobo.1002.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1003.1">int</span></span><span class="koboSpan" id="kobo.1004.1"> a):</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1005.1">a_</span></span><span class="koboSpan" id="kobo.1006.1">(a) {}
};
foo f1 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1007.1">42</span></span><span class="koboSpan" id="kobo.1008.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1009.1">Non-aggregate classes could be initialized with parentheses (the functional form) when arguments were provided and only without any parentheses when default initialization was performed (a call to the default constructor). </span><span class="koboSpan" id="kobo.1009.2">In the next example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1010.1">foo</span></code><span class="koboSpan" id="kobo.1011.1"> is the structure defined in the </span><em class="italic"><span class="koboSpan" id="kobo.1012.1">How to do it...</span></em><span class="koboSpan" id="kobo.1013.1"> section:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1014.1">foo f1;           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1015.1">// default initialization</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.1016.1">foo </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1017.1">f2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1018.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1019.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1020.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1021.1">1.2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1022.1">)</span></span><span class="koboSpan" id="kobo.1023.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1024.1">foo </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1025.1">f3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1026.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1027.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1028.1">)</span></span><span class="koboSpan" id="kobo.1029.1">;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1030.1">foo </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1031.1">f4</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1032.1">()</span></span><span class="koboSpan" id="kobo.1033.1">;         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1034.1">// function declaration</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1035.1">Aggregate and </span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.1036.1">POD types could be initialized with brace-initialization. </span><span class="koboSpan" id="kobo.1036.2">In the following example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1037.1">bar</span></code><span class="koboSpan" id="kobo.1038.1"> is the structure defined in the </span><em class="italic"><span class="koboSpan" id="kobo.1039.1">How to do it...</span></em><span class="koboSpan" id="kobo.1040.1"> section:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1041.1">bar b = {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1042.1">42</span></span><span class="koboSpan" id="kobo.1043.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1044.1">1.2</span></span><span class="koboSpan" id="kobo.1045.1">};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1046.1">int</span></span><span class="koboSpan" id="kobo.1047.1"> a[] = {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1048.1">1</span></span><span class="koboSpan" id="kobo.1049.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1050.1">2</span></span><span class="koboSpan" id="kobo.1051.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1052.1">3</span></span><span class="koboSpan" id="kobo.1053.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1054.1">4</span></span><span class="koboSpan" id="kobo.1055.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1056.1">5</span></span><span class="koboSpan" id="kobo.1057.1">};
</span></code></pre>
</li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1058.1">A </span><strong class="keyWord"><span class="koboSpan" id="kobo.1059.1">Plain Old Data</span></strong><span class="koboSpan" id="kobo.1060.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.1061.1">POD</span></strong><span class="koboSpan" id="kobo.1062.1">) type</span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.1063.1"> is a type that is both trivial (has special members that are compiler-provided or explicitly defaulted and occupy a contiguous memory area) and has a standard layout (a class that does not contain language features, such as virtual functions, which are incompatible with the C language, and all members have the same access control). </span><span class="koboSpan" id="kobo.1063.2">The concept of POD types has been deprecated in C++20 in favor of trivial and standard layout types.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1064.1">Apart from the different methods of initializing the data, there are also some limitations. </span><span class="koboSpan" id="kobo.1064.2">For instance, the only way to initialize a standard container (apart from copy constructing) is to first declare an object and then insert elements into it; </span><code class="inlineCode"><span class="koboSpan" id="kobo.1065.1">std::vector</span></code><span class="koboSpan" id="kobo.1066.1"> was an exception because it is possible to assign values from an array that can be initialized prior using aggregate initialization. </span><span class="koboSpan" id="kobo.1066.2">On the other hand, however, dynamically allocated aggregates could not be initialized directly.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1067.1">All the examples in the </span><em class="italic"><span class="koboSpan" id="kobo.1068.1">How to do it...</span></em><span class="koboSpan" id="kobo.1069.1"> section use direct initialization, but copy initialization is also possible with brace-initialization. </span><span class="koboSpan" id="kobo.1069.2">These two forms, direct and copy initialization, may be equivalent in most cases, but copy initialization is less permissive because it does not consider explicit constructors in its implicit conversion sequence, which must produce an object directly from the initializer, whereas direct initialization expects an implicit conversion from the initializer to an argument of the constructor. </span><span class="koboSpan" id="kobo.1069.3">Dynamically allocated arrays can only be initialized using direct initialization.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1070.1">Of the classes shown in the preceding examples, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1071.1">foo</span></code><span class="koboSpan" id="kobo.1072.1"> is the one class that has both a default constructor and a constructor with parameters. </span><span class="koboSpan" id="kobo.1072.2">To use the default constructor to perform default initialization, we need to use empty braces—that is, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1073.1">{}</span></code><span class="koboSpan" id="kobo.1074.1">. </span><span class="koboSpan" id="kobo.1074.2">To use the constructor with parameters, we need to provide the values for all the arguments in braces </span><code class="inlineCode"><span class="koboSpan" id="kobo.1075.1">{}</span></code><span class="koboSpan" id="kobo.1076.1">. </span><span class="koboSpan" id="kobo.1076.2">Unlike non-aggregate types, where default initialization means invoking the default constructor, for aggregate types, default initialization means initializing with zeros.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1077.1">Initialization of standard containers, such as the vector and the map, also shown previously, is possible because all standard containers have an additional constructor in C++11 that takes an argument of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1078.1">std::initializer_list&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1079.1">. </span><span class="koboSpan" id="kobo.1079.2">This is basically a lightweight proxy over an array of elements of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1080.1">T const</span></code><span class="koboSpan" id="kobo.1081.1">. </span><span class="koboSpan" id="kobo.1081.2">These constructors then initialize the internal data from the values in the initializer list.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1082.1">The way </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.1083.1">initialization using </span><code class="inlineCode"><span class="koboSpan" id="kobo.1084.1">std::initializer_list</span></code><span class="koboSpan" id="kobo.1085.1"> works is as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1086.1">The compiler resolves the types of the elements in the initialization list (all the elements must have the same type).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1087.1">The compiler creates an array with the elements in the initializer list.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1088.1">The compiler creates an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1089.1">std::initializer_list&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1090.1"> object to wrap the previously created array.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1091.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1092.1">std::initializer_list&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1093.1"> object is passed as an argument to the constructor.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1094.1">An initializer list always takes precedence over other constructors where brace-initialization is used. </span><span class="koboSpan" id="kobo.1094.2">If such a constructor exists for a class, it will be called when brace-initialization is performed:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1095.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1096.1">foo</span></span><span class="koboSpan" id="kobo.1097.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1098.1">int</span></span><span class="koboSpan" id="kobo.1099.1"> a_;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1100.1">int</span></span><span class="koboSpan" id="kobo.1101.1"> b_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1102.1">public</span></span><span class="koboSpan" id="kobo.1103.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1104.1">foo</span></span><span class="koboSpan" id="kobo.1105.1">() :</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1106.1">a_</span></span><span class="koboSpan" id="kobo.1107.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1108.1">0</span></span><span class="koboSpan" id="kobo.1109.1">), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1110.1">b_</span></span><span class="koboSpan" id="kobo.1111.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1112.1">0</span></span><span class="koboSpan" id="kobo.1113.1">) {}
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1114.1">foo</span></span><span class="koboSpan" id="kobo.1115.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1116.1">int</span></span><span class="koboSpan" id="kobo.1117.1"> a, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1118.1">int</span></span><span class="koboSpan" id="kobo.1119.1"> b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1120.1">0</span></span><span class="koboSpan" id="kobo.1121.1">) :</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1122.1">a_</span></span><span class="koboSpan" id="kobo.1123.1">(a), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1124.1">b_</span></span><span class="koboSpan" id="kobo.1125.1">(b) {}
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1126.1">foo</span></span><span class="koboSpan" id="kobo.1127.1">(std::initializer_list&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1128.1">int</span></span><span class="koboSpan" id="kobo.1129.1">&gt; l) {}
};
foo f{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1130.1">1</span></span><span class="koboSpan" id="kobo.1131.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1132.1">2</span></span><span class="koboSpan" id="kobo.1133.1"> }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1134.1">// calls constructor with initializer_list&lt;int&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1135.1">The precedence rule applies to any function, not just constructors. </span><span class="koboSpan" id="kobo.1135.2">In the following example, two overloads of the same function exist. </span><span class="koboSpan" id="kobo.1135.3">Calling the function with an initializer list resolves a call to the overload with an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1136.1">std::initializer_list</span></code><span class="koboSpan" id="kobo.1137.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1138.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1139.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1140.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1141.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1142.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1143.1"> a, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1144.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1145.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1146.1"> b, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1147.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1148.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1149.1"> c)</span></span><span class="koboSpan" id="kobo.1150.1">
{
  std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1151.1">'\n'</span></span><span class="koboSpan" id="kobo.1152.1">;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1153.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1154.1">func</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1155.1">(std::initializer_list&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1156.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1157.1">&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1158.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1159.1"> list)</span></span><span class="koboSpan" id="kobo.1160.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1161.1">for</span></span><span class="koboSpan" id="kobo.1162.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1163.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1164.1">const</span></span><span class="koboSpan" id="kobo.1165.1"> &amp; e : list)
    std::cout &lt;&lt; e &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1166.1">'\n'</span></span><span class="koboSpan" id="kobo.1167.1">;
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1168.1">func</span></span><span class="koboSpan" id="kobo.1169.1">({ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1170.1">1</span></span><span class="koboSpan" id="kobo.1171.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.1172.1">2</span></span><span class="koboSpan" id="kobo.1173.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.1174.1">3</span></span><span class="koboSpan" id="kobo.1175.1"> }); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1176.1">// calls second overload</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1177.1">However, this has the</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.1178.1"> potential to lead to bugs. </span><span class="koboSpan" id="kobo.1178.2">Let’s take, for example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1179.1">std::vector</span></code><span class="koboSpan" id="kobo.1180.1"> type. </span><span class="koboSpan" id="kobo.1180.2">Among the constructors of the vector, there is one that has a single argument, representing the initial number of elements to be allocated, and another one that has an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1181.1">std::initializer_list</span></code><span class="koboSpan" id="kobo.1182.1"> as an argument. </span><span class="koboSpan" id="kobo.1182.2">If the intention is to create a vector with a preallocated size, using brace-initialization will not work, as the constructor with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1183.1">std::initializer_list</span></code><span class="koboSpan" id="kobo.1184.1"> will be the best overload to be called:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.1185.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1186.1">int</span></span><span class="koboSpan" id="kobo.1187.1">&gt; v {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1188.1">5</span></span><span class="koboSpan" id="kobo.1189.1">};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1190.1">The preceding code does not create a vector with five elements but, instead, a vector with one element with a value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1191.1">5</span></code><span class="koboSpan" id="kobo.1192.1">. </span><span class="koboSpan" id="kobo.1192.2">To be able to actually create a vector with five elements, initialization with the parentheses form must be used:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.1193.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1194.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1195.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1196.1">v</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.1197.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1198.1">5</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1199.1">)</span></span><span class="koboSpan" id="kobo.1200.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1201.1">Another thing to note is that brace-initialization does not allow narrowing conversion. </span><span class="koboSpan" id="kobo.1201.2">According to the C++ standard (refer to paragraph 9.4.5 of the standard, document version N4917), a narrowing conversion is an implicit conversion:</span></p>
<blockquote class="packt_quote">
<p class="quote"><span class="koboSpan" id="kobo.1202.1">— From a floating-point type to an integer type.</span></p>
<p class="quote"><span class="koboSpan" id="kobo.1203.1">— From long double to double or float, or from double to float, except where the source is a constant expression and the actual value after conversion is within the range of values that can be represented (even if it cannot be represented exactly).</span></p>
<p class="quote"><span class="koboSpan" id="kobo.1204.1">— From an integer type or unscoped enumeration type to a floating-point type, except where the source is a constant expression and the actual value after conversion will fit into the target type and will produce the original value when converted to its original type.</span></p>
<p class="quote"><span class="koboSpan" id="kobo.1205.1">— From an integer type or unscoped enumeration type to an integer type that cannot represent all the values of the original type, except where the source is a constant expression and the actual value after conversion will fit into the target type and will produce the original value when converted to its original type.</span></p>
</blockquote>
<p class="normal"><span class="koboSpan" id="kobo.1206.1">The following declarations trigger compiler errors because they require a narrowing conversion:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1207.1">int</span></span><span class="koboSpan" id="kobo.1208.1"> i{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.1209.1">1.2</span></span><span class="koboSpan" id="kobo.1210.1"> };           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1211.1">// error</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1212.1">double</span></span><span class="koboSpan" id="kobo.1213.1"> d = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1214.1">47</span></span><span class="koboSpan" id="kobo.1215.1"> / </span><span class="hljs-number"><span class="koboSpan" id="kobo.1216.1">13</span></span><span class="koboSpan" id="kobo.1217.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1218.1">float</span></span><span class="koboSpan" id="kobo.1219.1"> f1{ d };          </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1220.1">// error, only warning in gcc</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1221.1">To fix this error, an</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.1222.1"> explicit conversion must be done:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1223.1">int</span></span><span class="koboSpan" id="kobo.1224.1"> i{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1225.1">static_cast</span></span><span class="koboSpan" id="kobo.1226.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1227.1">int</span></span><span class="koboSpan" id="kobo.1228.1">&gt;(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1229.1">1.2</span></span><span class="koboSpan" id="kobo.1230.1">) };
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1231.1">double</span></span><span class="koboSpan" id="kobo.1232.1"> d = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1233.1">47</span></span><span class="koboSpan" id="kobo.1234.1"> / </span><span class="hljs-number"><span class="koboSpan" id="kobo.1235.1">13</span></span><span class="koboSpan" id="kobo.1236.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1237.1">float</span></span><span class="koboSpan" id="kobo.1238.1"> f1{ </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1239.1">static_cast</span></span><span class="koboSpan" id="kobo.1240.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.1241.1">float</span></span><span class="koboSpan" id="kobo.1242.1">&gt;(d) };
</span></code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1243.1">A brace-initialization list is not an expression and does not have a type. </span><span class="koboSpan" id="kobo.1243.2">Therefore, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1244.1">decltype</span></code><span class="koboSpan" id="kobo.1245.1"> cannot be used on a brace-init-list, and template type deductions cannot deduce the type that matches a brace-init-list.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1246.1">Let’s consider one more example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.1247.1">float</span></span><span class="koboSpan" id="kobo.1248.1"> f2{</span><span class="hljs-number"><span class="koboSpan" id="kobo.1249.1">47</span></span><span class="koboSpan" id="kobo.1250.1">/</span><span class="hljs-number"><span class="koboSpan" id="kobo.1251.1">13</span></span><span class="koboSpan" id="kobo.1252.1">};        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1253.1">// OK, f2=3</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1254.1">The preceding declaration is, despite the above, correct because an implicit conversion from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1255.1">int</span></code><span class="koboSpan" id="kobo.1256.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1257.1">float</span></code><span class="koboSpan" id="kobo.1258.1"> exists. </span><span class="koboSpan" id="kobo.1258.2">The expression </span><code class="inlineCode"><span class="koboSpan" id="kobo.1259.1">47/13</span></code><span class="koboSpan" id="kobo.1260.1"> is first evaluated to integer value </span><code class="inlineCode"><span class="koboSpan" id="kobo.1261.1">3</span></code><span class="koboSpan" id="kobo.1262.1">, which is then assigned to the variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.1263.1">f2</span></code><span class="koboSpan" id="kobo.1264.1"> of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1265.1">float</span></code><span class="koboSpan" id="kobo.1266.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-28"><span class="koboSpan" id="kobo.1267.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1268.1">The following</span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.1269.1"> example shows several examples of direct-list-initialization and </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.1270.1">copy-list-initialization. </span><span class="koboSpan" id="kobo.1270.2">In C++11, the deduced type of all these expressions is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1271.1">std::initializer_list&lt;int&gt;</span></code><span class="koboSpan" id="kobo.1272.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1273.1">auto</span></span><span class="koboSpan" id="kobo.1274.1"> a = {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1275.1">42</span></span><span class="koboSpan" id="kobo.1276.1">};   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1277.1">// std::initializer_list&lt;int&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1278.1">auto</span></span><span class="koboSpan" id="kobo.1279.1"> b {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1280.1">42</span></span><span class="koboSpan" id="kobo.1281.1">};     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1282.1">// std::initializer_list&lt;int&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1283.1">auto</span></span><span class="koboSpan" id="kobo.1284.1"> c = {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1285.1">4</span></span><span class="koboSpan" id="kobo.1286.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1287.1">2</span></span><span class="koboSpan" id="kobo.1288.1">}; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1289.1">// std::initializer_list&lt;int&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1290.1">auto</span></span><span class="koboSpan" id="kobo.1291.1"> d {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1292.1">4</span></span><span class="koboSpan" id="kobo.1293.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1294.1">2</span></span><span class="koboSpan" id="kobo.1295.1">};   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1296.1">// std::initializer_list&lt;int&gt;</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1297.1">C++17 has changed the rules for list initialization, differentiating between direct- and copy-list-initialization. </span><span class="koboSpan" id="kobo.1297.2">The new rules for type deduction are as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1298.1">For</span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.1299.1"> copy-list-initialization, auto deduction will deduce an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1300.1">std::initializer_list&lt;T&gt;</span></code><span class="koboSpan" id="kobo.1301.1"> if all the elements in the list have the same type, or be ill-formed.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1302.1">For </span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.1303.1">direct-list-initialization, auto deduction will deduce a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1304.1">T</span></code><span class="koboSpan" id="kobo.1305.1"> if the list has a single element, or be ill-formed if there is more than one element.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1306.1">Based on these new rules, the previous examples would change as follows (the deduced type is mentioned in the comments):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1307.1">auto</span></span><span class="koboSpan" id="kobo.1308.1"> a = {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1309.1">42</span></span><span class="koboSpan" id="kobo.1310.1">};   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1311.1">// std::initializer_list&lt;int&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1312.1">auto</span></span><span class="koboSpan" id="kobo.1313.1"> b {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1314.1">42</span></span><span class="koboSpan" id="kobo.1315.1">};     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1316.1">// int</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1317.1">auto</span></span><span class="koboSpan" id="kobo.1318.1"> c = {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1319.1">4</span></span><span class="koboSpan" id="kobo.1320.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1321.1">2</span></span><span class="koboSpan" id="kobo.1322.1">}; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1323.1">// std::initializer_list&lt;int&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1324.1">auto</span></span><span class="koboSpan" id="kobo.1325.1"> d {</span><span class="hljs-number"><span class="koboSpan" id="kobo.1326.1">4</span></span><span class="koboSpan" id="kobo.1327.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1328.1">2</span></span><span class="koboSpan" id="kobo.1329.1">};   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1330.1">// error, too many</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1331.1">In this case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1332.1">a</span></code><span class="koboSpan" id="kobo.1333.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1334.1">c</span></code><span class="koboSpan" id="kobo.1335.1"> are deduced as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1336.1">std::initializer_list&lt;int&gt;</span></code><span class="koboSpan" id="kobo.1337.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1338.1">b</span></code><span class="koboSpan" id="kobo.1339.1"> is deduced as an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1340.1">int</span></code><span class="koboSpan" id="kobo.1341.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1342.1">d</span></code><span class="koboSpan" id="kobo.1343.1">, which uses direct initialization and has more than one value in the brace-init-list, triggers a compiler error.</span></p>
<h2 class="heading-2" id="_idParaDest-29"><span class="koboSpan" id="kobo.1344.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1345.1">Using auto whenever possible</span></em><span class="koboSpan" id="kobo.1346.1">, to understand how automatic type deduction works in C++</span></li>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1347.1">Understanding the various forms of non-static member initialization</span></em><span class="koboSpan" id="kobo.1348.1">, to learn how to best perform initialization of class members</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-30"><span class="koboSpan" id="kobo.1349.1">Understanding the various forms of non-static member initialization</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1350.1">Constructors are places where </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.1351.1">non-static class member initialization is done. </span><span class="koboSpan" id="kobo.1351.2">Many developers prefer assignments in the constructor body. </span><span class="koboSpan" id="kobo.1351.3">Aside from the several exceptional cases when that is actually necessary, initialization of non-static members should be done in the constructor’s initializer list or, as of C++11, using default member initialization when they are declared in the class. </span><span class="koboSpan" id="kobo.1351.4">Prior to C++11, constants and non-constant non-static data members of a class had to be initialized in the constructor. </span><span class="koboSpan" id="kobo.1351.5">Initialization on declaration in a class was only possible for static constants. </span><span class="koboSpan" id="kobo.1351.6">As we will see here, this limitation was removed in C++11, which allows the initialization of non-statics in the class declaration. </span><span class="koboSpan" id="kobo.1351.7">This initialization is called </span><em class="italic"><span class="koboSpan" id="kobo.1352.1">default member initialization</span></em><span class="koboSpan" id="kobo.1353.1"> and is explained in the following sections.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1354.1">This recipe will explore the ways non-static member initialization should be done. </span><span class="koboSpan" id="kobo.1354.2">Using the appropriate initialization method for each member leads not only to more efficient code but also to better organized and more readable code.</span></p>
<h2 class="heading-2" id="_idParaDest-31"><span class="koboSpan" id="kobo.1355.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1356.1">To initialize </span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.1357.1">non-static members of a class, you should:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1358.1">Use default member initialization for constants, both static and non-static (see </span><code class="inlineCode"><span class="koboSpan" id="kobo.1359.1">[1]</span></code><span class="koboSpan" id="kobo.1360.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1361.1">[2]</span></code><span class="koboSpan" id="kobo.1362.1"> in the following code).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1363.1">Use default member initialization to provide default values for members of classes with multiple constructors that would use a common initializer for those members (see </span><code class="inlineCode"><span class="koboSpan" id="kobo.1364.1">[3]</span></code><span class="koboSpan" id="kobo.1365.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1366.1">[4]</span></code><span class="koboSpan" id="kobo.1367.1"> in the following code).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1368.1">Use the constructor initializer list to initialize members that don’t have default values but depend on constructor parameters (see </span><code class="inlineCode"><span class="koboSpan" id="kobo.1369.1">[5]</span></code><span class="koboSpan" id="kobo.1370.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1371.1">[6]</span></code><span class="koboSpan" id="kobo.1372.1"> in the following code).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1373.1">Use assignment in constructors when the other options are not possible (examples include initializing data members with the pointer </span><code class="inlineCode"><span class="koboSpan" id="kobo.1374.1">this</span></code><span class="koboSpan" id="kobo.1375.1">, checking constructor parameter values, and throwing exceptions prior to initializing members with those values or self-references to two non-static data members).</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1376.1">The following example shows these forms of initialization:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1377.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1378.1">Control</span></span><span class="koboSpan" id="kobo.1379.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1380.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1381.1">int</span></span><span class="koboSpan" id="kobo.1382.1"> DefaultHeight = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1383.1">14</span></span><span class="koboSpan" id="kobo.1384.1">;                                </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1385.1">// [1]</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1386.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1387.1">int</span></span><span class="koboSpan" id="kobo.1388.1"> DefaultWidth  = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1389.1">80</span></span><span class="koboSpan" id="kobo.1390.1">;                                </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1391.1">// [2]</span></span><span class="koboSpan" id="kobo.1392.1">
  std::string text;
  TextVerticalAlignment valign = TextVerticalAlignment::Middle;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1393.1">// [3]</span></span><span class="koboSpan" id="kobo.1394.1">
  TextHorizontalAlignment halign = TextHorizontalAlignment::Left; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1395.1">// [4]</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1396.1">Control</span></span><span class="koboSpan" id="kobo.1397.1">(std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.1398.1">const</span></span><span class="koboSpan" id="kobo.1399.1"> &amp; t) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1400.1">text</span></span><span class="koboSpan" id="kobo.1401.1">(t)      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1402.1">// [5]</span></span><span class="koboSpan" id="kobo.1403.1">
  {}
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1404.1">Control</span></span><span class="koboSpan" id="kobo.1405.1">(std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.1406.1">const</span></span><span class="koboSpan" id="kobo.1407.1"> &amp; t,
    TextVerticalAlignment </span><span class="hljs-type"><span class="koboSpan" id="kobo.1408.1">const</span></span><span class="koboSpan" id="kobo.1409.1"> va,
    TextHorizontalAlignment </span><span class="hljs-type"><span class="koboSpan" id="kobo.1410.1">const</span></span><span class="koboSpan" id="kobo.1411.1"> ha):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1412.1">text</span></span><span class="koboSpan" id="kobo.1413.1">(t), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1414.1">valign</span></span><span class="koboSpan" id="kobo.1415.1">(va), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1416.1">halign</span></span><span class="koboSpan" id="kobo.1417.1">(ha)             </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1418.1">// [6]</span></span><span class="koboSpan" id="kobo.1419.1">
  {}
};
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-32"><span class="koboSpan" id="kobo.1420.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1421.1">Non-static data members</span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.1422.1"> are supposed to be initialized in the constructor’s initializer list, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1423.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1424.1">Point</span></span><span class="koboSpan" id="kobo.1425.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1426.1">double</span></span><span class="koboSpan" id="kobo.1427.1"> x, y;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1428.1">Point</span></span><span class="koboSpan" id="kobo.1429.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.1430.1">double</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1431.1">const</span></span><span class="koboSpan" id="kobo.1432.1"> x = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1433.1">0.0</span></span><span class="koboSpan" id="kobo.1434.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.1435.1">double</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1436.1">const</span></span><span class="koboSpan" id="kobo.1437.1"> y = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1438.1">0.0</span></span><span class="koboSpan" id="kobo.1439.1">) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1440.1">x</span></span><span class="koboSpan" id="kobo.1441.1">(x), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1442.1">y</span></span><span class="koboSpan" id="kobo.1443.1">(y)  {}
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1444.1">Many developers, however, do not use the initializer list and prefer assignments in the constructor’s body, or even mix assignments and the initializer list. </span><span class="koboSpan" id="kobo.1444.2">That could be for several reasons—for large classes with many members, the constructor assignments may be easier to read than long initializer lists, perhaps split into many lines, or it could be because these developers are familiar with other programming languages that don’t have an initializer list. </span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1445.1">It is important to note that the order in which non-static data members are initialized is the order in which they were declared in the class definition, not the order of their initialization in a constructor initializer list. </span><span class="koboSpan" id="kobo.1445.2">Conversely, the order in which non-static data members are destroyed is the reversed order of construction.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1446.1">Using assignments in the constructor is not efficient, as this can create temporary objects that are later discarded. </span><span class="koboSpan" id="kobo.1446.2">If not initialized in the initializer list, non-static members are initialized via their default constructor and then, when assigned a value in the constructor’s body, the assignment operator is invoked. </span><span class="koboSpan" id="kobo.1446.3">This can lead to inefficient work if the default constructor allocates a resource (such as memory or a file) and that has to be deallocated and reallocated in the assignment operator. </span><span class="koboSpan" id="kobo.1446.4">This is exemplified in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1447.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1448.1">foo</span></span><span class="koboSpan" id="kobo.1449.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1450.1">foo</span></span><span class="koboSpan" id="kobo.1451.1">()
  { std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1452.1">"default constructor\n"</span></span><span class="koboSpan" id="kobo.1453.1">; }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1454.1">foo</span></span><span class="koboSpan" id="kobo.1455.1">(std::string </span><span class="hljs-type"><span class="koboSpan" id="kobo.1456.1">const</span></span><span class="koboSpan" id="kobo.1457.1"> &amp; text)
  { std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1458.1">"constructor '"</span></span><span class="koboSpan" id="kobo.1459.1"> &lt;&lt; text &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1460.1">"\n"</span></span><span class="koboSpan" id="kobo.1461.1">; }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1462.1">foo</span></span><span class="koboSpan" id="kobo.1463.1">(foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.1464.1">const</span></span><span class="koboSpan" id="kobo.1465.1"> &amp; other)
  { std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1466.1">"copy constructor\n"</span></span><span class="koboSpan" id="kobo.1467.1">; }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1468.1">foo</span></span><span class="koboSpan" id="kobo.1469.1">(foo&amp;&amp; other)
  { std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1470.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1471.1">move constructor\n"</span></span><span class="koboSpan" id="kobo.1472.1">; };
  foo&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1473.1">operator</span></span><span class="koboSpan" id="kobo.1474.1">=(foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.1475.1">const</span></span><span class="koboSpan" id="kobo.1476.1"> &amp; other)
  { std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1477.1">"assignment\n"</span></span><span class="koboSpan" id="kobo.1478.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1479.1">return</span></span><span class="koboSpan" id="kobo.1480.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1481.1">this</span></span><span class="koboSpan" id="kobo.1482.1">; }
  foo&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1483.1">operator</span></span><span class="koboSpan" id="kobo.1484.1">=(foo&amp;&amp; other)
  { std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1485.1">"move assignment\n"</span></span><span class="koboSpan" id="kobo.1486.1">; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1487.1">return</span></span><span class="koboSpan" id="kobo.1488.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1489.1">this</span></span><span class="koboSpan" id="kobo.1490.1">;}
  ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1491.1">foo</span></span><span class="koboSpan" id="kobo.1492.1">()
  { std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.1493.1">"destructor\n"</span></span><span class="koboSpan" id="kobo.1494.1">; }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1495.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1496.1">bar</span></span><span class="koboSpan" id="kobo.1497.1">
{
  foo f;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1498.1">bar</span></span><span class="koboSpan" id="kobo.1499.1">(foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.1500.1">const</span></span><span class="koboSpan" id="kobo.1501.1"> &amp; value)
  {
    f = value;
  }
};
foo f;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.1502.1">bar </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1503.1">b</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1504.1">(f)</span></span><span class="koboSpan" id="kobo.1505.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1506.1">The preceding </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.1507.1">code produces the following output, showing how the data member </span><code class="inlineCode"><span class="koboSpan" id="kobo.1508.1">f</span></code><span class="koboSpan" id="kobo.1509.1"> is first default initialized and then assigned a new value:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1510.1">default constructor
default constructor
assignment
destructor
destructor
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1511.1">If you want to track which object was created and destroyed, you can slightly change the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1512.1">foo</span></code><span class="koboSpan" id="kobo.1513.1"> class above and print the value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1514.1">this</span></code><span class="koboSpan" id="kobo.1515.1"> pointer for each of the special member functions. </span><span class="koboSpan" id="kobo.1515.2">You can do this as a follow-up exercise.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1516.1">Changing the initialization from the assignment in the constructor body to the initializer list replaces the calls to the default constructor, plus the assignment operator, with a call to the copy constructor:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1517.1">bar</span></span><span class="koboSpan" id="kobo.1518.1">(foo </span><span class="hljs-type"><span class="koboSpan" id="kobo.1519.1">const</span></span><span class="koboSpan" id="kobo.1520.1"> &amp; value) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1521.1">f</span></span><span class="koboSpan" id="kobo.1522.1">(value) { }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1523.1">Adding the preceding line of code produces the following output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1524.1">default constructor
copy constructor
destructor
destructor
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1525.1">For those reasons, at </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.1526.1">least for types other than the built-in types (such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1527.1">bool</span></code><span class="koboSpan" id="kobo.1528.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1529.1">char</span></code><span class="koboSpan" id="kobo.1530.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1531.1">int</span></code><span class="koboSpan" id="kobo.1532.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1533.1">float</span></code><span class="koboSpan" id="kobo.1534.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1535.1">double</span></code><span class="koboSpan" id="kobo.1536.1">, or pointers), you should prefer the constructor initializer list. </span><span class="koboSpan" id="kobo.1536.2">However, to be consistent with your initialization style, you should always prefer the constructor initializer list when possible. </span><span class="koboSpan" id="kobo.1536.3">There are several situations when using the initializer list is not possible; these include the following cases (but the list could be expanded for other cases):</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1537.1">If a member has to be initialized with a pointer or reference to the object that contains it, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1538.1">this</span></code><span class="koboSpan" id="kobo.1539.1"> pointer in the initialization list may trigger a warning with some compilers that it should be used before the object is constructed.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1540.1">If you have two data members that must contain references to each other.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1541.1">If you want to test an input parameter and throw an exception before initializing a non-static data member with the value of the parameter.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1542.1">Starting with C++11, non-static data members can be initialized when declared in the class. </span><span class="koboSpan" id="kobo.1542.2">This is called </span><em class="italic"><span class="koboSpan" id="kobo.1543.1">default member initialization</span></em><span class="koboSpan" id="kobo.1544.1"> because it is supposed to represent initialization with default values. </span><span class="koboSpan" id="kobo.1544.2">Default member initialization is intended for constants and members that are not initialized based on constructor parameters (in other words, members whose value does not depend on the way the object is constructed):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1545.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1546.1">TextFlow</span></span><span class="koboSpan" id="kobo.1547.1"> { LeftToRight, RightToLeft };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1548.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1549.1">Control</span></span><span class="koboSpan" id="kobo.1550.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1551.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1552.1">int</span></span><span class="koboSpan" id="kobo.1553.1"> DefaultHeight = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1554.1">20</span></span><span class="koboSpan" id="kobo.1555.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1556.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.1557.1">int</span></span><span class="koboSpan" id="kobo.1558.1"> DefaultWidth = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1559.1">100</span></span><span class="koboSpan" id="kobo.1560.1">;
  TextFlow textFlow = TextFlow::LeftToRight;
  std::string text;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1561.1">Control</span></span><span class="koboSpan" id="kobo.1562.1">(std::string const &amp; t) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1563.1">text</span></span><span class="koboSpan" id="kobo.1564.1">(t)
  {}
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1565.1">In the preceding example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1566.1">DefaultHeight</span></code><span class="koboSpan" id="kobo.1567.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1568.1">DefaultWidth</span></code><span class="koboSpan" id="kobo.1569.1"> are both constants; therefore, the values do not depend on the way the object is constructed, so they are initialized when declared. </span><span class="koboSpan" id="kobo.1569.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1570.1">textFlow</span></code><span class="koboSpan" id="kobo.1571.1"> object is a non-constant, non-static data member whose value also does not depend on the way the object is initialized (it could be changed via another member function); therefore, it is also initialized using default member initialization when it is declared. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1572.1">text</span></code><span class="koboSpan" id="kobo.1573.1">, conversely, is also a non-constant non-static data member, but its initial value depends on the way the object is constructed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1574.1">Therefore, it is initialized in the constructor’s initializer list using a value passed as an argument to the constructor.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1575.1">If a data member</span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.1576.1"> is initialized both with the default member initialization and constructor initializer list, the latter takes precedence and the default value is discarded. </span><span class="koboSpan" id="kobo.1576.2">To exemplify this, let’s again consider the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1577.1">foo</span></code><span class="koboSpan" id="kobo.1578.1"> class mentioned earlier and the following </span><code class="inlineCode"><span class="koboSpan" id="kobo.1579.1">bar</span></code><span class="koboSpan" id="kobo.1580.1"> class, which uses it:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1581.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1582.1">bar</span></span><span class="koboSpan" id="kobo.1583.1">
{
  foo f{</span><span class="hljs-string"><span class="koboSpan" id="kobo.1584.1">"default value"</span></span><span class="koboSpan" id="kobo.1585.1">};
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1586.1">bar</span></span><span class="koboSpan" id="kobo.1587.1">() : f{</span><span class="hljs-string"><span class="koboSpan" id="kobo.1588.1">"constructor initializer"</span></span><span class="koboSpan" id="kobo.1589.1">}
  {
  }
};
bar b;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1590.1">In this case, the output differs as follows:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1591.1">constructor 'constructor initializer'
destructor
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1592.1">The reason for the different behavior is that the value from the default initializer list is discarded, and the </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.1593.1">object is not initialized twice.</span></p>
<h2 class="heading-2" id="_idParaDest-33"><span class="koboSpan" id="kobo.1594.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1595.1">Understanding uniform initialization</span></em><span class="koboSpan" id="kobo.1596.1">, to see how brace-initialization works</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-34"><span class="koboSpan" id="kobo.1597.1">Controlling and querying object alignment</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1598.1">C++11 provides </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.1599.1">standardized methods for specifying and querying the alignment</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.1600.1"> requirements of a type (something that was previously possible only through compiler-specific methods). </span><span class="koboSpan" id="kobo.1600.2">Controlling the alignment is important in order to boost performance on different processors and enable the use of some instructions that only work with data on particular alignments.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1601.1">For example, Intel </span><strong class="keyWord"><span class="koboSpan" id="kobo.1602.1">Streaming SIMD Extensions</span></strong><span class="koboSpan" id="kobo.1603.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.1604.1">SSE</span></strong><span class="koboSpan" id="kobo.1605.1">) and </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.1606.1">Intel SSE2, which are a set of processor instructions that can greatly increase performance when the same operations are to be applied on multiple data objects, require 16 bytes of alignment of data. </span><span class="koboSpan" id="kobo.1606.2">Conversely, for </span><strong class="keyWord"><span class="koboSpan" id="kobo.1607.1">Intel Advanced Vector Extensions</span></strong><span class="koboSpan" id="kobo.1608.1"> (or </span><strong class="keyWord"><span class="koboSpan" id="kobo.1609.1">Intel AVX</span></strong><span class="koboSpan" id="kobo.1610.1">), which </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.1611.1">expands most integer processor commands to 256 bits, it is highly recommended to use 32-byte alignment. </span><span class="koboSpan" id="kobo.1611.2">This recipe explores the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1612.1">alignas</span></code><span class="koboSpan" id="kobo.1613.1"> specifier for controlling the alignment requirements and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1614.1">alignof</span></code><span class="koboSpan" id="kobo.1615.1"> operator, which retrieves the alignment requirements of a type.</span></p>
<h2 class="heading-2" id="_idParaDest-35"><span class="koboSpan" id="kobo.1616.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1617.1">You should be familiar with what data alignment is and the way the compiler performs default data alignment. </span><span class="koboSpan" id="kobo.1617.2">However, basic information about the latter is provided in the </span><em class="italic"><span class="koboSpan" id="kobo.1618.1">How it works...</span></em><span class="koboSpan" id="kobo.1619.1"> section.</span></p>
<h2 class="heading-2" id="_idParaDest-36"><span class="koboSpan" id="kobo.1620.1">How to do it...</span></h2>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1621.1">To control the alignment of a type (both at the class level or data member level) or an object, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1622.1">alignas</span></code><span class="koboSpan" id="kobo.1623.1"> specifier:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1624.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1625.1">alignas</span></span><span class="koboSpan" id="kobo.1626.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1627.1">4</span></span><span class="koboSpan" id="kobo.1628.1">) foo
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1629.1">char</span></span><span class="koboSpan" id="kobo.1630.1"> a;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1631.1">char</span></span><span class="koboSpan" id="kobo.1632.1"> b;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1633.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1634.1">bar</span></span><span class="koboSpan" id="kobo.1635.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1636.1">alignas</span></span><span class="koboSpan" id="kobo.1637.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1638.1">2</span></span><span class="koboSpan" id="kobo.1639.1">) </span><span class="hljs-type"><span class="koboSpan" id="kobo.1640.1">char</span></span><span class="koboSpan" id="kobo.1641.1"> a;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1642.1">alignas</span></span><span class="koboSpan" id="kobo.1643.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1644.1">8</span></span><span class="koboSpan" id="kobo.1645.1">) </span><span class="hljs-type"><span class="koboSpan" id="kobo.1646.1">int</span></span><span class="koboSpan" id="kobo.1647.1">  b;
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1648.1">alignas</span></span><span class="koboSpan" id="kobo.1649.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1650.1">8</span></span><span class="koboSpan" id="kobo.1651.1">)   </span><span class="hljs-type"><span class="koboSpan" id="kobo.1652.1">int</span></span><span class="koboSpan" id="kobo.1653.1"> a;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1654.1">alignas</span></span><span class="koboSpan" id="kobo.1655.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1656.1">256</span></span><span class="koboSpan" id="kobo.1657.1">) </span><span class="hljs-type"><span class="koboSpan" id="kobo.1658.1">long</span></span><span class="koboSpan" id="kobo.1659.1"> b[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1660.1">4</span></span><span class="koboSpan" id="kobo.1661.1">];
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.1662.1">To query the alignment of a type, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1663.1">alignof</span></code><span class="koboSpan" id="kobo.1664.1"> operator:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1665.1">auto</span></span><span class="koboSpan" id="kobo.1666.1"> align = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1667.1">alignof</span></span><span class="koboSpan" id="kobo.1668.1">(foo);
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-37"><span class="koboSpan" id="kobo.1669.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1670.1">Processors</span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.1671.1"> do not access memory one byte at a time but in larger</span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.1672.1"> chunks of powers of two (2, 4, 8, 16, 32, and so on). </span><span class="koboSpan" id="kobo.1672.2">Owing to this, it is important that compilers align data in memory so that it can be easily accessed by the processor. </span><span class="koboSpan" id="kobo.1672.3">Should this data be misaligned, the compiler has to do extra work to access data; it has to read multiple chunks of data, shift and discard unnecessary bytes, and combine the rest.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1673.1">C++ compilers align variables based on the size of their data type. </span><span class="koboSpan" id="kobo.1673.2">The standard only specifies the sizes of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1674.1">char</span></code><span class="koboSpan" id="kobo.1675.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1676.1">signed char</span></code><span class="koboSpan" id="kobo.1677.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1678.1">unsigned char</span></code><span class="koboSpan" id="kobo.1679.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1680.1">char8_t</span></code><span class="koboSpan" id="kobo.1681.1"> (introduced in C++20), and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1682.1">std::byte</span></code><span class="koboSpan" id="kobo.1683.1"> (introduced in C++17), which must be 1. </span><span class="koboSpan" id="kobo.1683.2">It also requires that the size of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1684.1">short</span></code><span class="koboSpan" id="kobo.1685.1"> must be at least 16 bits, the size of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1686.1">long</span></code><span class="koboSpan" id="kobo.1687.1"> must be at least 32 bits, and the size of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1688.1">long long</span></code><span class="koboSpan" id="kobo.1689.1"> must be at least 64 bits. </span><span class="koboSpan" id="kobo.1689.2">It also requires that 1 == </span><code class="inlineCode"><span class="koboSpan" id="kobo.1690.1">sizeof(char)</span></code><span class="koboSpan" id="kobo.1691.1"> &lt;= </span><code class="inlineCode"><span class="koboSpan" id="kobo.1692.1">sizeof(short)</span></code><span class="koboSpan" id="kobo.1693.1"> &lt;= </span><code class="inlineCode"><span class="koboSpan" id="kobo.1694.1">sizeof(int)</span></code><span class="koboSpan" id="kobo.1695.1"> &lt;= </span><code class="inlineCode"><span class="koboSpan" id="kobo.1696.1">sizeof(long)</span></code><span class="koboSpan" id="kobo.1697.1"> &lt;= </span><code class="inlineCode"><span class="koboSpan" id="kobo.1698.1">sizeof(long long)</span></code><span class="koboSpan" id="kobo.1699.1">. </span><span class="koboSpan" id="kobo.1699.2">Therefore, the size of most types is compiler-specific and may depend on the platform. </span><span class="koboSpan" id="kobo.1699.3">Typically, these are 1 byte for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1700.1">bool</span></code><span class="koboSpan" id="kobo.1701.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1702.1">char</span></code><span class="koboSpan" id="kobo.1703.1">, 2 bytes for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1704.1">short</span></code><span class="koboSpan" id="kobo.1705.1">, 4 bytes for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1706.1">int</span></code><span class="koboSpan" id="kobo.1707.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1708.1">long</span></code><span class="koboSpan" id="kobo.1709.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1710.1">float</span></code><span class="koboSpan" id="kobo.1711.1">, 8 bytes for </span><code class="inlineCode"><span class="koboSpan" id="kobo.1712.1">double</span></code><span class="koboSpan" id="kobo.1713.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1714.1">long long</span></code><span class="koboSpan" id="kobo.1715.1">, and so on. </span><span class="koboSpan" id="kobo.1715.2">When it comes to structures or unions, the alignment must match the size of the largest member in order to avoid performance issues. </span><span class="koboSpan" id="kobo.1715.3">To exemplify this, let’s consider the following data structures:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1716.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1717.1">foo1</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.1718.1">// size = 1, alignment = 1</span></span><span class="koboSpan" id="kobo.1719.1">
{              </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1720.1">// foo1:    +-+</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1721.1">char</span></span><span class="koboSpan" id="kobo.1722.1"> a;      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1723.1">// members: |a|</span></span><span class="koboSpan" id="kobo.1724.1">
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1725.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1726.1">foo2</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.1727.1">// size = 2, alignment = 1</span></span><span class="koboSpan" id="kobo.1728.1">
{              </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1729.1">// foo2:    +-+-+</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1730.1">char</span></span><span class="koboSpan" id="kobo.1731.1"> a;      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1732.1">// members  |a|b|</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1733.1">char</span></span><span class="koboSpan" id="kobo.1734.1"> b;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1735.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1736.1">foo3</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.1737.1">// size = 8, alignment = 4</span></span><span class="koboSpan" id="kobo.1738.1">
{              </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1739.1">// foo3:    +----+----+</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1740.1">char</span></span><span class="koboSpan" id="kobo.1741.1"> a;      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1742.1">// members: |a...|bbbb|</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1743.1">int</span></span><span class="koboSpan" id="kobo.1744.1">  b;      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1745.1">// . </span><span class="koboSpan" id="kobo.1745.2">represents a byte of padding</span></span><span class="koboSpan" id="kobo.1746.1">
};
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1747.1">foo1</span></code><span class="koboSpan" id="kobo.1748.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1749.1">foo2</span></code><span class="koboSpan" id="kobo.1750.1"> are </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.1751.1">different sizes, but the alignment is the same—that is, 1—because </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.1752.1">all data members are of the type </span><code class="inlineCode"><span class="koboSpan" id="kobo.1753.1">char</span></code><span class="koboSpan" id="kobo.1754.1">, which has a size of 1 byte. </span><span class="koboSpan" id="kobo.1754.2">In the structure </span><code class="inlineCode"><span class="koboSpan" id="kobo.1755.1">foo3</span></code><span class="koboSpan" id="kobo.1756.1">, the second member is an integer, whose size is 4. </span><span class="koboSpan" id="kobo.1756.2">As a result, the alignment of members of this structure is done at addresses that are multiples of 4. </span><span class="koboSpan" id="kobo.1756.3">To achieve this, the compiler introduces padding bytes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1757.1">The structure </span><code class="inlineCode"><span class="koboSpan" id="kobo.1758.1">foo3</span></code><span class="koboSpan" id="kobo.1759.1"> is actually transformed into the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1760.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1761.1">foo3_</span></span><span class="koboSpan" id="kobo.1762.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1763.1">char</span></span><span class="koboSpan" id="kobo.1764.1"> a;        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1765.1">// 1 byte</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1766.1">char</span></span><span class="koboSpan" id="kobo.1767.1"> _pad0[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1768.1">3</span></span><span class="koboSpan" id="kobo.1769.1">]; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1770.1">// 3 bytes padding to put b on a 4-byte boundary</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1771.1">int</span></span><span class="koboSpan" id="kobo.1772.1">  b;        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1773.1">// 4 bytes</span></span><span class="koboSpan" id="kobo.1774.1">
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1775.1">Similarly, the following structure has a size of 32 bytes and an alignment of 8; this is because the largest member is a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1776.1">double</span></code><span class="koboSpan" id="kobo.1777.1"> whose size is 8. </span><span class="koboSpan" id="kobo.1777.2">This structure, however, requires padding in several places to make sure that all the members can be accessed at addresses that are multiples of 8:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1778.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1779.1">foo4</span></span> <span class="hljs-comment"><span class="koboSpan" id="kobo.1780.1">// size = 24, alignment = 8</span></span><span class="koboSpan" id="kobo.1781.1">
{               </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1782.1">// foo4:    +--------+--------+--------+--------+</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1783.1">int</span></span><span class="koboSpan" id="kobo.1784.1"> a;        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1785.1">// members: |aaaab...|cccc....|dddddddd|e.......|</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1786.1">char</span></span><span class="koboSpan" id="kobo.1787.1"> b;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1788.1">// . </span><span class="koboSpan" id="kobo.1788.2">represents a byte of padding</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1789.1">float</span></span><span class="koboSpan" id="kobo.1790.1"> c;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1791.1">double</span></span><span class="koboSpan" id="kobo.1792.1"> d;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1793.1">bool</span></span><span class="koboSpan" id="kobo.1794.1"> e;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1795.1">The equivalent structure that’s created by the compiler is as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1796.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1797.1">foo4_</span></span><span class="koboSpan" id="kobo.1798.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1799.1">int</span></span><span class="koboSpan" id="kobo.1800.1"> a;         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1801.1">// 4 bytes</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1802.1">char</span></span><span class="koboSpan" id="kobo.1803.1"> b;        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1804.1">// 1 byte</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1805.1">char</span></span><span class="koboSpan" id="kobo.1806.1"> _pad0[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1807.1">3</span></span><span class="koboSpan" id="kobo.1808.1">]; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1809.1">// 3 bytes padding to put c on a 8-byte boundary</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1810.1">float</span></span><span class="koboSpan" id="kobo.1811.1"> c;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1812.1">// 4 bytes</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1813.1">char</span></span><span class="koboSpan" id="kobo.1814.1"> _pad1[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1815.1">4</span></span><span class="koboSpan" id="kobo.1816.1">]; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1817.1">// 4 bytes padding to put d on a 8-byte boundary</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1818.1">double</span></span><span class="koboSpan" id="kobo.1819.1"> d;      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1820.1">// 8 bytes</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1821.1">bool</span></span><span class="koboSpan" id="kobo.1822.1"> e;        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1823.1">// 1 byte</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.1824.1">char</span></span><span class="koboSpan" id="kobo.1825.1"> _pad2[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1826.1">7</span></span><span class="koboSpan" id="kobo.1827.1">]; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1828.1">// 7 bytes padding to make sizeof struct multiple of 8</span></span><span class="koboSpan" id="kobo.1829.1">
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1830.1">In C++11, specifying </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.1831.1">the alignment of an object or type is done using </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.1832.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1833.1">alignas</span></code><span class="koboSpan" id="kobo.1834.1"> specifier. </span><span class="koboSpan" id="kobo.1834.2">This can take either an expression (an integral constant expression that evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1835.1">0</span></code><span class="koboSpan" id="kobo.1836.1"> or a valid value for an alignment), a type-id, or a parameter pack. </span><span class="koboSpan" id="kobo.1836.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1837.1">alignas</span></code><span class="koboSpan" id="kobo.1838.1"> specifier can be applied to the declaration of a variable or a class data member that does not represent a bit field, or to the declaration of a class, union, or enumeration.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1839.1">The type or object on which an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1840.1">alignas</span></code><span class="koboSpan" id="kobo.1841.1"> specification is applied will have the alignment requirement equal to the largest, greater than zero, expression of all </span><code class="inlineCode"><span class="koboSpan" id="kobo.1842.1">alignas</span></code><span class="koboSpan" id="kobo.1843.1"> specifications used in the declaration.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1844.1">There are several restrictions when using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1845.1">alignas</span></code><span class="koboSpan" id="kobo.1846.1"> specifier:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1847.1">The only valid alignments are the powers of two (1, 2, 4, 8, 16, 32, and so on). </span><span class="koboSpan" id="kobo.1847.2">Any other values are illegal, and the program is considered ill-formed; that doesn’t necessarily have to produce an error, as the compiler may choose to ignore the specification.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1848.1">An alignment of 0 is always ignored.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1849.1">If the largest </span><code class="inlineCode"><span class="koboSpan" id="kobo.1850.1">alignas</span></code><span class="koboSpan" id="kobo.1851.1"> on a declaration is smaller than the natural alignment without any </span><code class="inlineCode"><span class="koboSpan" id="kobo.1852.1">alignas</span></code><span class="koboSpan" id="kobo.1853.1"> specifier, then the program is also considered ill-formed.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1854.1">In the following example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1855.1">alignas</span></code><span class="koboSpan" id="kobo.1856.1"> specifier has been applied to a class declaration. </span><span class="koboSpan" id="kobo.1856.2">The natural alignment without the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1857.1">alignas</span></code><span class="koboSpan" id="kobo.1858.1"> specifier would have been 1, but with </span><code class="inlineCode"><span class="koboSpan" id="kobo.1859.1">alignas(4)</span></code><span class="koboSpan" id="kobo.1860.1">, it becomes 4:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1861.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1862.1">alignas</span></span><span class="koboSpan" id="kobo.1863.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1864.1">4</span></span><span class="koboSpan" id="kobo.1865.1">) foo
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1866.1">char</span></span><span class="koboSpan" id="kobo.1867.1"> a;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1868.1">char</span></span><span class="koboSpan" id="kobo.1869.1"> b;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1870.1">In other words, the compiler transforms the preceding class into the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1871.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1872.1">foo</span></span><span class="koboSpan" id="kobo.1873.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1874.1">char</span></span><span class="koboSpan" id="kobo.1875.1"> a;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1876.1">char</span></span><span class="koboSpan" id="kobo.1877.1"> b;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1878.1">char</span></span><span class="koboSpan" id="kobo.1879.1"> _pad0[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1880.1">2</span></span><span class="koboSpan" id="kobo.1881.1">];
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1882.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1883.1">alignas</span></code><span class="koboSpan" id="kobo.1884.1"> specifier can </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.1885.1">be applied both to the class declaration and the member </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.1886.1">data declarations. </span><span class="koboSpan" id="kobo.1886.2">In this case, the strictest (that is, largest) value wins. </span><span class="koboSpan" id="kobo.1886.3">In the following example, member </span><code class="inlineCode"><span class="koboSpan" id="kobo.1887.1">a</span></code><span class="koboSpan" id="kobo.1888.1"> has a natural size of 1 and requires an alignment of 2; member </span><code class="inlineCode"><span class="koboSpan" id="kobo.1889.1">b</span></code><span class="koboSpan" id="kobo.1890.1"> has a natural size of 4 and requires an alignment of 8, so the strictest alignment would be 8. </span><span class="koboSpan" id="kobo.1890.2">The alignment requirement of the entire class is 4, which is weaker (that is, smaller) than the strictest required alignment, and therefore, it will be ignored, although the compiler will produce a warning:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1891.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1892.1">alignas</span></span><span class="koboSpan" id="kobo.1893.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1894.1">4</span></span><span class="koboSpan" id="kobo.1895.1">) foo
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1896.1">alignas</span></span><span class="koboSpan" id="kobo.1897.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1898.1">2</span></span><span class="koboSpan" id="kobo.1899.1">) </span><span class="hljs-type"><span class="koboSpan" id="kobo.1900.1">char</span></span><span class="koboSpan" id="kobo.1901.1"> a;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1902.1">alignas</span></span><span class="koboSpan" id="kobo.1903.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1904.1">8</span></span><span class="koboSpan" id="kobo.1905.1">) </span><span class="hljs-type"><span class="koboSpan" id="kobo.1906.1">int</span></span><span class="koboSpan" id="kobo.1907.1">  b;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1908.1">The result is a structure that looks like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1909.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1910.1">foo</span></span><span class="koboSpan" id="kobo.1911.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1912.1">char</span></span><span class="koboSpan" id="kobo.1913.1"> a;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1914.1">char</span></span><span class="koboSpan" id="kobo.1915.1"> _pad0[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1916.1">7</span></span><span class="koboSpan" id="kobo.1917.1">];
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1918.1">int</span></span><span class="koboSpan" id="kobo.1919.1"> b;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.1920.1">char</span></span><span class="koboSpan" id="kobo.1921.1"> _pad1[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1922.1">4</span></span><span class="koboSpan" id="kobo.1923.1">];
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1924.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1925.1">alignas</span></code><span class="koboSpan" id="kobo.1926.1"> specifier can also be applied to variables. </span><span class="koboSpan" id="kobo.1926.2">In the following example, variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.1927.1">a</span></code><span class="koboSpan" id="kobo.1928.1">, which is an integer, is required to be placed in memory at a multiple of 8. </span><span class="koboSpan" id="kobo.1928.2">The next variable, the array of 4 longs, is required to be placed in memory at a multiple of 256. </span><span class="koboSpan" id="kobo.1928.3">As a result, the compiler will introduce up to 244 bytes of padding between the two variables (depending on where in memory, at an address multiple of 8, variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.1929.1">a</span></code><span class="koboSpan" id="kobo.1930.1"> is located):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.1931.1">alignas</span></span><span class="koboSpan" id="kobo.1932.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1933.1">8</span></span><span class="koboSpan" id="kobo.1934.1">)   </span><span class="hljs-type"><span class="koboSpan" id="kobo.1935.1">int</span></span><span class="koboSpan" id="kobo.1936.1"> a;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1937.1">alignas</span></span><span class="koboSpan" id="kobo.1938.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1939.1">256</span></span><span class="koboSpan" id="kobo.1940.1">) </span><span class="hljs-type"><span class="koboSpan" id="kobo.1941.1">long</span></span><span class="koboSpan" id="kobo.1942.1"> b[</span><span class="hljs-number"><span class="koboSpan" id="kobo.1943.1">4</span></span><span class="koboSpan" id="kobo.1944.1">];
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1945.1">printf</span></span><span class="koboSpan" id="kobo.1946.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1947.1">"%p\n"</span></span><span class="koboSpan" id="kobo.1948.1">, &amp;a); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1949.1">// eg. </span><span class="koboSpan" id="kobo.1949.2">0000006C0D9EF908</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1950.1">printf</span></span><span class="koboSpan" id="kobo.1951.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1952.1">"%p\n"</span></span><span class="koboSpan" id="kobo.1953.1">, &amp;b); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1954.1">// eg. </span><span class="koboSpan" id="kobo.1954.2">0000006C0D9EFA00</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1955.1">Looking at the addresses, we can see that the address of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1956.1">a</span></code><span class="koboSpan" id="kobo.1957.1"> is indeed a multiple of 8, and that the address of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1958.1">b</span></code><span class="koboSpan" id="kobo.1959.1"> is a multiple of 256 (hexadecimal 100).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1960.1">To query the </span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.1961.1">alignment of a type, we use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1962.1">alignof</span></code><span class="koboSpan" id="kobo.1963.1"> operator. </span><span class="koboSpan" id="kobo.1963.2">Unlike </span><code class="inlineCode"><span class="koboSpan" id="kobo.1964.1">sizeof</span></code><span class="koboSpan" id="kobo.1965.1">, this operator can only be applied to types, not to variables or class data </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.1966.1">members. </span><span class="koboSpan" id="kobo.1966.2">The types it can be applied to are complete types, array types, or reference types. </span><span class="koboSpan" id="kobo.1966.3">For arrays, the value that’s returned is the alignment of the element type; for references, the value that’s returned is the alignment of the referenced type. </span><span class="koboSpan" id="kobo.1966.4">Here are several examples:</span></p>
<table class="table-container" id="table001">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1967.1">Expression</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1968.1">Evaluation</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1969.1">alignof(char)</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1970.1">1, because the natural alignment of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1971.1">char</span></code><span class="koboSpan" id="kobo.1972.1"> is 1</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1973.1">alignof(int)</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1974.1">4, because the natural alignment of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1975.1">int</span></code><span class="koboSpan" id="kobo.1976.1"> is 4</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1977.1">alignof(int*)</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1978.1">4 on 32-bit and 8 on 64-bit, the alignment for pointers</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1979.1">alignof(int[4])</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1980.1">4, because the natural alignment of the element type is 4</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.1981.1">alignof(foo&amp;)</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.1982.1">8, because the specified alignment for the class </span><code class="inlineCode"><span class="koboSpan" id="kobo.1983.1">foo</span></code><span class="koboSpan" id="kobo.1984.1">, which is the reference type (as shown in the previous example), was 8</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.1985.1">Table 1.1: Examples of alignof expressions and their evaluated value</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1986.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1987.1">alignas</span></code><span class="koboSpan" id="kobo.1988.1"> specifier is useful if you wish to force an alignment for a data type (taking into consideration the restriction mentioned previously) so that variables of that type can be accessed and copied efficiently. </span><span class="koboSpan" id="kobo.1988.2">This means optimizing CPU reads and writes and avoiding unnecessary invalidation from cache lines. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1989.1">This can be highly important in some categories of applications where performance is key, such as games or trading applications. </span><span class="koboSpan" id="kobo.1989.2">Conversely, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1990.1">alignof</span></code><span class="koboSpan" id="kobo.1991.1"> operator retries the minimum alignment requirement of a specified type.</span></p>
<h2 class="heading-2" id="_idParaDest-38"><span class="koboSpan" id="kobo.1992.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.1993.1">Creating type aliases and alias templates</span></em><span class="koboSpan" id="kobo.1994.1">, to learn about aliases for types</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-39"><span class="koboSpan" id="kobo.1995.1">Using scoped enumerations</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1996.1">Enumeration</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.1997.1"> is a basic type in C++ that defines a collection of values, always of an integral underlying type. </span><span class="koboSpan" id="kobo.1997.2">Their named values, which are constant, are called enumerators. </span><span class="koboSpan" id="kobo.1997.3">Enumerations declared with the keyword </span><code class="inlineCode"><span class="koboSpan" id="kobo.1998.1">enum</span></code><span class="koboSpan" id="kobo.1999.1"> are called </span><em class="italic"><span class="koboSpan" id="kobo.2000.1">unscoped enumerations</span></em><span class="koboSpan" id="kobo.2001.1">, while enumerations declared with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2002.1">enum class</span></code><span class="koboSpan" id="kobo.2003.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2004.1">enum struct</span></code><span class="koboSpan" id="kobo.2005.1"> are called </span><em class="italic"><span class="koboSpan" id="kobo.2006.1">scoped enumerations</span></em><span class="koboSpan" id="kobo.2007.1">. </span><span class="koboSpan" id="kobo.2007.2">The latter ones were introduced in C++11 and are intended to solve several problems with unscoped enumerations, which are explained in this recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-40"><span class="koboSpan" id="kobo.2008.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2009.1">When </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.2010.1">working with enumerations, you should:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2011.1">Prefer to use scoped enumerations instead of unscoped ones</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2012.1">Declare scoped enumerations using </span><code class="inlineCode"><span class="koboSpan" id="kobo.2013.1">enum class</span></code><span class="koboSpan" id="kobo.2014.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2015.1">enum struct</span></code><span class="koboSpan" id="kobo.2016.1">:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2017.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2018.1">Status</span></span><span class="koboSpan" id="kobo.2019.1"> { Unknown, Created, Connected };
Status s = Status::Created;
</span></code></pre>
</li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2020.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2021.1">enum class</span></code><span class="koboSpan" id="kobo.2022.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2023.1">enum struct</span></code><span class="koboSpan" id="kobo.2024.1"> declarations are equivalent, and throughout this recipe and the rest of this book, we will use </span><code class="inlineCode"><span class="koboSpan" id="kobo.2025.1">enum class</span></code><span class="koboSpan" id="kobo.2026.1">.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2027.1">Because scope enumerations are restricted namespaces, the C++20 standard allows us to associate them with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2028.1">using</span></code><span class="koboSpan" id="kobo.2029.1"> directive. </span><span class="koboSpan" id="kobo.2029.2">You can do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2030.1">Introduce a scoped enumeration identifier in the local scope with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2031.1">using</span></code><span class="koboSpan" id="kobo.2032.1"> directive, as follows:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2033.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2034.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2035.1">()</span></span><span class="koboSpan" id="kobo.2036.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2037.1">using</span></span><span class="koboSpan" id="kobo.2038.1"> Status::Unknown;
  Status s = Unknown;
}
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2039.1">Introduce all the identifiers of a scoped enumeration in the local scope with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2040.1">using</span></code><span class="koboSpan" id="kobo.2041.1"> directive, as follows:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2042.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2043.1">foo</span></span><span class="koboSpan" id="kobo.2044.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2045.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2046.1">Status</span></span><span class="koboSpan" id="kobo.2047.1"> { Unknown, Created, Connected };
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2048.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2049.1">enum</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2050.1">Status</span></span><span class="koboSpan" id="kobo.2051.1">;
};
foo::Status s = foo::Created; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2052.1">// instead of</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.2053.1">// foo::Status::Created</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2054.1">Use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2055.1">using enum</span></code><span class="koboSpan" id="kobo.2056.1"> directive to introduce the enum identifiers in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2057.1">switch</span></code><span class="koboSpan" id="kobo.2058.1"> statement to simplify your code:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2059.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2060.1">process</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2061.1">(Status </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2062.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2063.1"> s)</span></span><span class="koboSpan" id="kobo.2064.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2065.1">switch</span></span><span class="koboSpan" id="kobo.2066.1"> (s)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2067.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2068.1">enum</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2069.1">Status</span></span><span class="koboSpan" id="kobo.2070.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2071.1">case</span></span><span class="koboSpan" id="kobo.2072.1"> Unknown:   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2073.1">/*…*/</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2074.1">break</span></span><span class="koboSpan" id="kobo.2075.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2076.1">case</span></span><span class="koboSpan" id="kobo.2077.1"> Created:   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2078.1">/*...*/</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2079.1">break</span></span><span class="koboSpan" id="kobo.2080.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2081.1">case</span></span><span class="koboSpan" id="kobo.2082.1"> Connected: </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2083.1">/*...*/</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2084.1">break</span></span><span class="koboSpan" id="kobo.2085.1">;
  }
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2086.1">Converting a scoped enumeration to its underlying type is sometimes necessary, especially in the context of using old-style APIs that take integers as arguments. </span><span class="koboSpan" id="kobo.2086.2">In C++23, you can convert to the</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.2087.1"> underlying type of a scoped enumeration by using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2088.1">std::to_underlying()</span></code><span class="koboSpan" id="kobo.2089.1"> utility function:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2090.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2091.1">old_api</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2092.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2093.1">unsigned</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2094.1"> flag)</span></span><span class="koboSpan" id="kobo.2095.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2096.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2097.1">user_rights</span></span><span class="koboSpan" id="kobo.2098.1"> : </span><span class="hljs-type"><span class="koboSpan" id="kobo.2099.1">unsigned</span></span><span class="koboSpan" id="kobo.2100.1">
{
    None, Read = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2101.1">1</span></span><span class="koboSpan" id="kobo.2102.1">, Write = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2103.1">2</span></span><span class="koboSpan" id="kobo.2104.1">, Delete = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2105.1">4</span></span><span class="koboSpan" id="kobo.2106.1">
};
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2107.1">old_api</span></span><span class="koboSpan" id="kobo.2108.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2109.1">to_underlying</span></span><span class="koboSpan" id="kobo.2110.1">(user_rights::Read));
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-41"><span class="koboSpan" id="kobo.2111.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2112.1">Unscoped enumerations</span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.2113.1"> have several issues that create problems for developers:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2114.1">They export their enumerators to the surrounding scope (for which reason, they are called unscoped enumerations), and that has the following two drawbacks:</span><ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2115.1">It can lead to name clashes if two enumerations in the same namespace have enumerators with the same name</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2116.1">It’s not possible to use an enumerator using its fully qualified name:
            </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2117.1">enum</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2118.1">Status</span></span><span class="koboSpan" id="kobo.2119.1"> {Unknown, Created, Connected};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2120.1">enum</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2121.1">Codes</span></span><span class="koboSpan" id="kobo.2122.1"> {OK, Failure, Unknown};   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2123.1">// error</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2124.1">auto</span></span><span class="koboSpan" id="kobo.2125.1"> status = Status::Created;       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2126.1">// error</span></span>
</code></pre>
</li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2127.1">Prior to C++ 11, they </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.2128.1">could not specify the underlying type, which is required to be an integral type. </span><span class="koboSpan" id="kobo.2128.2">This type must not be larger than </span><code class="inlineCode"><span class="koboSpan" id="kobo.2129.1">int</span></code><span class="koboSpan" id="kobo.2130.1">, unless the enumerator value cannot fit a signed or unsigned integer. </span><span class="koboSpan" id="kobo.2130.2">Owing to this, forward declaration of enumerations was not possible. </span><span class="koboSpan" id="kobo.2130.3">The reason for this was that the size of the enumeration was not known. </span><span class="koboSpan" id="kobo.2130.4">This was because the underlying type was not known until the values of the enumerators were defined so that the compiler could pick the appropriate integer type. </span><span class="koboSpan" id="kobo.2130.5">This has been fixed in C++11.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2131.1">Values of enumerators implicitly convert to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2132.1">int</span></code><span class="koboSpan" id="kobo.2133.1">. </span><span class="koboSpan" id="kobo.2133.2">This means you can intentionally or accidentally mix enumerations that have a certain meaning and integers (which may not even be related to the meaning of the enumeration) and the compiler will not be able to warn you:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2134.1">enum</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2135.1">Codes</span></span><span class="koboSpan" id="kobo.2136.1"> { OK, Failure };
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2137.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2138.1">include_offset</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2139.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2140.1">int</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2141.1"> pixels)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2142.1">{</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2143.1">/*...*/</span></span><span class="koboSpan" id="kobo.2144.1">}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2145.1">include_offset</span></span><span class="koboSpan" id="kobo.2146.1">(Failure);
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2147.1">The scoped </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.2148.1">enumerations are basically strongly typed enumerations that behave differently than the unscoped enumerations:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2149.1">They do not export their enumerators to the surrounding scope. </span><span class="koboSpan" id="kobo.2149.2">The two enumerations shown earlier would change to the following, no longer generating a name collision and making it possible to fully qualify the names of the enumerators:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2150.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2151.1">Status</span></span><span class="koboSpan" id="kobo.2152.1"> { Unknown, Created, Connected };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2153.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2154.1">Codes</span></span><span class="koboSpan" id="kobo.2155.1"> { OK, Failure, Unknown }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2156.1">// OK</span></span><span class="koboSpan" id="kobo.2157.1">
Codes code = Codes::Unknown;               </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2158.1">// OK</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2159.1">You can </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.2160.1">specify the underlying type. </span><span class="koboSpan" id="kobo.2160.2">The same rules for underlying types of unscoped enumerations apply to scoped enumerations too, except that the user can explicitly specify the underlying type. </span><span class="koboSpan" id="kobo.2160.3">This also solves the problem with forward declarations, since the underlying type can be known before the definition is available:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2161.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2162.1">Codes</span></span><span class="koboSpan" id="kobo.2163.1"> : </span><span class="hljs-type"><span class="koboSpan" id="kobo.2164.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2165.1">int</span></span><span class="koboSpan" id="kobo.2166.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2167.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2168.1">print_code</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2169.1">(Codes </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2170.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2171.1"> code)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2172.1">{}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2173.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2174.1">Codes</span></span><span class="koboSpan" id="kobo.2175.1"> : </span><span class="hljs-type"><span class="koboSpan" id="kobo.2176.1">unsigned</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2177.1">int</span></span><span class="koboSpan" id="kobo.2178.1">
{
  OK = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2179.1">0</span></span><span class="koboSpan" id="kobo.2180.1">,
  Failure = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2181.1">1</span></span><span class="koboSpan" id="kobo.2182.1">,
  Unknown = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2183.1">0xFFFF0000</span></span><span class="koboSpan" id="kobo.2184.1">U
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2185.1">Values of scoped enumerations no longer convert implicitly to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2186.1">int</span></code><span class="koboSpan" id="kobo.2187.1">. </span><span class="koboSpan" id="kobo.2187.2">Assigning the value of an </span><code class="inlineCode"><span class="koboSpan" id="kobo.2188.1">enum class</span></code><span class="koboSpan" id="kobo.2189.1"> to an integer variable would trigger a compiler error unless an explicit cast is specified:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2190.1">Codes c1 = Codes::OK;                       </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2191.1">// OK</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.2192.1">int</span></span><span class="koboSpan" id="kobo.2193.1"> c2 = Codes::Failure;                    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2194.1">// error</span></span>
<span class="hljs-type"><span class="koboSpan" id="kobo.2195.1">int</span></span><span class="koboSpan" id="kobo.2196.1"> c3 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2197.1">static_cast</span></span><span class="koboSpan" id="kobo.2198.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2199.1">int</span></span><span class="koboSpan" id="kobo.2200.1">&gt;(Codes::Failure);  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2201.1">// OK</span></span>
</code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2202.1">However, the scoped enumerations have a drawback: they are restricted namespaces. </span><span class="koboSpan" id="kobo.2202.2">They do not export the identifiers in the outer scope, which can be inconvenient at times, for instance, if you are writing a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2203.1">switch</span></code><span class="koboSpan" id="kobo.2204.1"> and you need to repeat the enumeration name for each case label, as in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.2205.1">std::string_view </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2206.1">to_string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2207.1">(Status </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2208.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2209.1"> s)</span></span><span class="koboSpan" id="kobo.2210.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2211.1">switch</span></span><span class="koboSpan" id="kobo.2212.1"> (s)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2213.1">case</span></span><span class="koboSpan" id="kobo.2214.1"> Status::Unknown:   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2215.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2216.1">"Unknown"</span></span><span class="koboSpan" id="kobo.2217.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2218.1">case</span></span><span class="koboSpan" id="kobo.2219.1"> Status::Created:   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2220.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2221.1">"Created"</span></span><span class="koboSpan" id="kobo.2222.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2223.1">case</span></span><span class="koboSpan" id="kobo.2224.1"> Status::Connected: </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2225.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2226.1">"Connected"</span></span><span class="koboSpan" id="kobo.2227.1">;
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2228.1">In C++20, this can be simplified with the help of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2229.1">using</span></code><span class="koboSpan" id="kobo.2230.1"> directive with the name of the scoped enumeration. </span><span class="koboSpan" id="kobo.2230.2">The preceding code can be simplified as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.2231.1">std::string_view </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2232.1">to_string</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2233.1">(Status </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2234.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2235.1"> s)</span></span><span class="koboSpan" id="kobo.2236.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2237.1">switch</span></span><span class="koboSpan" id="kobo.2238.1"> (s)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2239.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2240.1">enum</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2241.1">Status</span></span><span class="koboSpan" id="kobo.2242.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2243.1">case</span></span><span class="koboSpan" id="kobo.2244.1"> Unknown:   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2245.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2246.1">"Unknown"</span></span><span class="koboSpan" id="kobo.2247.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2248.1">case</span></span><span class="koboSpan" id="kobo.2249.1"> Created:   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2250.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2251.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.2252.1">Created"</span></span><span class="koboSpan" id="kobo.2253.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2254.1">case</span></span><span class="koboSpan" id="kobo.2255.1"> Connected: </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2256.1">return</span></span> <span class="hljs-string"><span class="koboSpan" id="kobo.2257.1">"Connected"</span></span><span class="koboSpan" id="kobo.2258.1">;
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2259.1">The effect of </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.2260.1">this </span><code class="inlineCode"><span class="koboSpan" id="kobo.2261.1">using</span></code><span class="koboSpan" id="kobo.2262.1"> directive is that all the enumerator identifiers are introduced in the local scope, making it possible to refer to them with the unqualified form. </span><span class="koboSpan" id="kobo.2262.2">It is also possible to bring only a particular enum identifier to the local scope with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2263.1">using</span></code><span class="koboSpan" id="kobo.2264.1"> directive with the qualified identifier name, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2265.1">using</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.2266.1">Status::Connected</span></code><span class="koboSpan" id="kobo.2267.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2268.1">The C++23 version of the standard adds a couple of utility functions for working with scoped enumerations. </span><span class="koboSpan" id="kobo.2268.2">The first of these is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2269.1">std::to_underlying()</span></code><span class="koboSpan" id="kobo.2270.1">, available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2271.1">&lt;utility&gt;</span></code><span class="koboSpan" id="kobo.2272.1"> header. </span><span class="koboSpan" id="kobo.2272.2">What it does is convert an enumeration to its underlying type. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2273.1">Its purpose is to work with APIs (legacy or not) that don’t use scoped enumerations. </span><span class="koboSpan" id="kobo.2273.2">Let’s look at an example. </span><span class="koboSpan" id="kobo.2273.3">Consider the following function, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2274.1">old_api()</span></code><span class="koboSpan" id="kobo.2275.1">, which takes an integer argument, which it interprets as flags controlling user rights, into the system:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.2276.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2277.1">old_api</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2278.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2279.1">unsigned</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2280.1"> flag)</span></span><span class="koboSpan" id="kobo.2281.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2282.1">if</span></span><span class="koboSpan" id="kobo.2283.1"> ((flag &amp; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2284.1">0x01</span></span><span class="koboSpan" id="kobo.2285.1">) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2286.1">0x01</span></span><span class="koboSpan" id="kobo.2287.1">) { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2288.1">/* can read */</span></span><span class="koboSpan" id="kobo.2289.1"> }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2290.1">if</span></span><span class="koboSpan" id="kobo.2291.1"> ((flag &amp; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2292.1">0x02</span></span><span class="koboSpan" id="kobo.2293.1">) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2294.1">0x02</span></span><span class="koboSpan" id="kobo.2295.1">) { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2296.1">/* can write */</span></span><span class="koboSpan" id="kobo.2297.1"> }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2298.1">if</span></span><span class="koboSpan" id="kobo.2299.1"> ((flag &amp; </span><span class="hljs-number"><span class="koboSpan" id="kobo.2300.1">0x04</span></span><span class="koboSpan" id="kobo.2301.1">) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2302.1">0x04</span></span><span class="koboSpan" id="kobo.2303.1">) { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2304.1">/* can delete */</span></span><span class="koboSpan" id="kobo.2305.1"> }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2306.1">This function can be invoked as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.2307.1">old_api</span></span><span class="koboSpan" id="kobo.2308.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2309.1">1</span></span><span class="koboSpan" id="kobo.2310.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2311.1">// read only</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.2312.1">old_api</span></span><span class="koboSpan" id="kobo.2313.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2314.1">3</span></span><span class="koboSpan" id="kobo.2315.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2316.1">// read &amp; write</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2317.1">Conversely, a newer part of the system defines the following scoped enumeration for the user rights:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2318.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2319.1">user_rights</span></span><span class="koboSpan" id="kobo.2320.1"> : </span><span class="hljs-type"><span class="koboSpan" id="kobo.2321.1">unsigned</span></span><span class="koboSpan" id="kobo.2322.1">
{
    None,
    Read = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2323.1">1</span></span><span class="koboSpan" id="kobo.2324.1">,
    Write = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2325.1">2</span></span><span class="koboSpan" id="kobo.2326.1">,
    Delete = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2327.1">4</span></span><span class="koboSpan" id="kobo.2328.1">
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2329.1">However, invoking the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2330.1">old_api()</span></code><span class="koboSpan" id="kobo.2331.1"> function with enumerations from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2332.1">user_rights</span></code><span class="koboSpan" id="kobo.2333.1"> is not possible, and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2334.1">static_cast</span></code><span class="koboSpan" id="kobo.2335.1"> must be used:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.2336.1">old_api</span></span><span class="koboSpan" id="kobo.2337.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2338.1">static_cast</span></span><span class="koboSpan" id="kobo.2339.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2340.1">int</span></span><span class="koboSpan" id="kobo.2341.1">&gt;(user_rights::Read)); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2342.1">// read only</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.2343.1">old_api</span></span><span class="koboSpan" id="kobo.2344.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2345.1">static_cast</span></span><span class="koboSpan" id="kobo.2346.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2347.1">int</span></span><span class="koboSpan" id="kobo.2348.1">&gt;(user_rights::Read) | 
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2349.1">static_cast</span></span><span class="koboSpan" id="kobo.2350.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2351.1">int</span></span><span class="koboSpan" id="kobo.2352.1">&gt;(user_rights::Write)); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2353.1">// read &amp; write</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2354.1">To avoid these </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.2355.1">static casts, C++23 provides the function </span><code class="inlineCode"><span class="koboSpan" id="kobo.2356.1">std::to_underlying()</span></code><span class="koboSpan" id="kobo.2357.1">, which can be used as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.2358.1">old_api</span></span><span class="koboSpan" id="kobo.2359.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2360.1">to_underlying</span></span><span class="koboSpan" id="kobo.2361.1">(user_rights::Read));
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2362.1">old_api</span></span><span class="koboSpan" id="kobo.2363.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2364.1">to_underlying</span></span><span class="koboSpan" id="kobo.2365.1">(user_rights::Read) | 
        std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2366.1">to_underlying</span></span><span class="koboSpan" id="kobo.2367.1">(user_rights::Write));
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2368.1">The other utility introduced in C++23 is a type trait called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2369.1">is_scoped_enum&lt;T&gt;</span></code><span class="koboSpan" id="kobo.2370.1">, available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2371.1">&lt;type_traits&gt;</span></code><span class="koboSpan" id="kobo.2372.1"> header. </span><span class="koboSpan" id="kobo.2372.2">This contains a member constant called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2373.1">value</span></code><span class="koboSpan" id="kobo.2374.1">, which is equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.2375.1">true</span></code><span class="koboSpan" id="kobo.2376.1"> if the template type parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.2377.1">T</span></code><span class="koboSpan" id="kobo.2378.1"> is a scoped enumeration type, or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2379.1">false</span></code><span class="koboSpan" id="kobo.2380.1"> otherwise. </span><span class="koboSpan" id="kobo.2380.2">There is also a helper variable template, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2381.1">is_scoped_enum_v&lt;T&gt;</span></code><span class="koboSpan" id="kobo.2382.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.2383.1">The purpose of this type trait is to identify whether an enumeration is scoped or not in order to apply different behavior, depending on the type of the enumeration. </span><span class="koboSpan" id="kobo.2383.2">Here is a simple example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2384.1">enum</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2385.1">A</span></span><span class="koboSpan" id="kobo.2386.1"> {};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2387.1">enum class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2388.1">B</span></span><span class="koboSpan" id="kobo.2389.1"> {};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2390.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2391.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2392.1">()</span></span><span class="koboSpan" id="kobo.2393.1">
{
   std::cout &lt;&lt; std::is_scoped_enum_v&lt;A&gt; &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2394.1">'\n'</span></span><span class="koboSpan" id="kobo.2395.1">;
   std::cout &lt;&lt; std::is_scoped_enum_v&lt;B&gt; &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2396.1">'\n'</span></span><span class="koboSpan" id="kobo.2397.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2398.1">The first line will</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.2399.1"> print 0 because </span><code class="inlineCode"><span class="koboSpan" id="kobo.2400.1">A</span></code><span class="koboSpan" id="kobo.2401.1"> is an unscoped enum, while the second line will print </span><code class="inlineCode"><span class="koboSpan" id="kobo.2402.1">1</span></code><span class="koboSpan" id="kobo.2403.1"> because </span><code class="inlineCode"><span class="koboSpan" id="kobo.2404.1">B</span></code><span class="koboSpan" id="kobo.2405.1"> is a scoped enum.</span></p>
<h2 class="heading-2" id="_idParaDest-42"><span class="koboSpan" id="kobo.2406.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.2407.1">Chapter 9</span></em><span class="koboSpan" id="kobo.2408.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2409.1">Creating compile-time constant expressions</span></em><span class="koboSpan" id="kobo.2410.1">, to learn how to work with compile-time constants</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-43"><span class="koboSpan" id="kobo.2411.1">Using override and final for virtual methods</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2412.1">Unlike other</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.2413.1"> similar programming languages, C++ does not </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.2414.1">have a specific syntax for declaring interfaces (which are basically classes with pure virtual methods only) and also has some deficiencies related to</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.2415.1"> how virtual methods are declared. </span><span class="koboSpan" id="kobo.2415.2">In C++, the virtual methods are introduced with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2416.1">virtual</span></code><span class="koboSpan" id="kobo.2417.1"> keyword. </span><span class="koboSpan" id="kobo.2417.2">However, the keyword </span><code class="inlineCode"><span class="koboSpan" id="kobo.2418.1">virtual</span></code><span class="koboSpan" id="kobo.2419.1"> is optional for declaring overrides in derived classes, which can lead to confusion when dealing with large classes or hierarchies. </span><span class="koboSpan" id="kobo.2419.2">You may need to navigate throughout the hierarchy up to the base to figure out whether a function is virtual or not. </span><span class="koboSpan" id="kobo.2419.3">Conversely, sometimes, it is useful to make sure that a virtual function or even a derived class can no longer be overridden or derived further. </span><span class="koboSpan" id="kobo.2419.4">In this recipe, we will see how to use the C++11 special identifiers </span><code class="inlineCode"><span class="koboSpan" id="kobo.2420.1">override</span></code><span class="koboSpan" id="kobo.2421.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2422.1">final</span></code><span class="koboSpan" id="kobo.2423.1"> to declare virtual functions or classes.</span></p>
<h2 class="heading-2" id="_idParaDest-44"><span class="koboSpan" id="kobo.2424.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2425.1">You should be familiar with inheritance and polymorphism in C++ and concepts such as abstract classes, pure specifiers, and virtual and overridden methods.</span></p>
<h2 class="heading-2" id="_idParaDest-45"><span class="koboSpan" id="kobo.2426.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2427.1">To ensure the correct declaration of virtual methods both in base and derived classes, also ensuring that you increase readability, do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2428.1">Aim to use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2429.1">virtual</span></code><span class="koboSpan" id="kobo.2430.1"> keyword when declaring virtual functions in derived classes that are supposed to override virtual functions from a base class.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2431.1">Always use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2432.1">override</span></code><span class="koboSpan" id="kobo.2433.1"> special identifier after the declarator part of a virtual function’s declaration or definition:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2434.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2435.1">Base</span></span><span class="koboSpan" id="kobo.2436.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2437.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2438.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2439.1">foo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2440.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2441.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2442.1">0</span></span><span class="koboSpan" id="kobo.2443.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2444.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2445.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2446.1">bar</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2447.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2448.1">{}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2449.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2450.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2451.1">foobar</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2452.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2453.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2454.1">0</span></span><span class="koboSpan" id="kobo.2455.1">;
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.2456.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2457.1">Base::foobar</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2458.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2459.1">{}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2460.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2461.1">Derived1</span></span><span class="koboSpan" id="kobo.2462.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2463.1">public</span></span><span class="koboSpan" id="kobo.2464.1"> Base
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2465.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2466.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2467.1">foo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2468.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2469.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2470.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2471.1">0</span></span><span class="koboSpan" id="kobo.2472.1">;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2473.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2474.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2475.1">bar</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2476.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2477.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2478.1">{}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2479.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2480.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2481.1">foobar</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2482.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2483.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2484.1">{}
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2485.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2486.1">Derived2</span></span><span class="koboSpan" id="kobo.2487.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2488.1">public</span></span><span class="koboSpan" id="kobo.2489.1"> Derived1
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2490.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2491.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2492.1">foo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2493.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2494.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2495.1">{}
};
</span></code></pre>
</li>
</ul>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.2496.1">The declarator is the part of the type of a function that excludes the return type.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.2497.1">To ensure that </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.2498.1">functions cannot be overridden further or that </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.2499.1">classes cannot be derived any more, use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2500.1">final</span></code><span class="koboSpan" id="kobo.2501.1"> special</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.2502.1"> identifier, like this:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2503.1">After the declarator part of a virtual function declaration or definition to prevent further overrides in a derived class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2504.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2505.1">Derived2</span></span><span class="koboSpan" id="kobo.2506.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2507.1">public</span></span><span class="koboSpan" id="kobo.2508.1"> Derived1
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2509.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2510.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2511.1">foo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2512.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2513.1">final</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2514.1">{}
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2515.1">After the name of a class in the declaration of the class to prevent further derivations of the class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2516.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2517.1">Derived4</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2518.1">final</span></span><span class="koboSpan" id="kobo.2519.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2520.1">public</span></span><span class="koboSpan" id="kobo.2521.1"> Derived1
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2522.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2523.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2524.1">foo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2525.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2526.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2527.1">{}
};
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-46"><span class="koboSpan" id="kobo.2528.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2529.1">The</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.2530.1"> way </span><code class="inlineCode"><span class="koboSpan" id="kobo.2531.1">override</span></code><span class="koboSpan" id="kobo.2532.1"> works is very simple; in a virtual </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.2533.1">function declaration or definition, it ensures that the </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.2534.1">function actually overrides a base class function; otherwise, the compiler will trigger an error.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2535.1">It should be noted that both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2536.1">override</span></code><span class="koboSpan" id="kobo.2537.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2538.1">final</span></code><span class="koboSpan" id="kobo.2539.1"> special identifiers are special identifiers that have a meaning only in a member function declaration or definition. </span><span class="koboSpan" id="kobo.2539.2">They are not reserved keywords and can still be used elsewhere in a program as user-defined identifiers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2540.1">Using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2541.1">override</span></code><span class="koboSpan" id="kobo.2542.1"> special identifier helps the compiler detect situations where a virtual method does not override another one, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2543.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2544.1">Base</span></span><span class="koboSpan" id="kobo.2545.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2546.1">public</span></span><span class="koboSpan" id="kobo.2547.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2548.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2549.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2550.1">foo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2551.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2552.1">{}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2553.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2554.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2555.1">bar</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2556.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2557.1">{}
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2558.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2559.1">Derived1</span></span><span class="koboSpan" id="kobo.2560.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2561.1">public</span></span><span class="koboSpan" id="kobo.2562.1"> Base
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2563.1">public</span></span><span class="koboSpan" id="kobo.2564.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2565.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2566.1">foo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2567.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2568.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2569.1">{}
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2570.1">// for readability use the virtual keyword</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2571.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2572.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2573.1">bar</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2574.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2575.1">char</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2576.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2577.1"> c)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2578.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2579.1">{}
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2580.1">// error, no Base::bar(char const)</span></span><span class="koboSpan" id="kobo.2581.1">
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2582.1">Without the presence of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2583.1">override</span></code><span class="koboSpan" id="kobo.2584.1"> specifier, the virtual </span><code class="inlineCode"><span class="koboSpan" id="kobo.2585.1">bar(char const)</span></code><span class="koboSpan" id="kobo.2586.1"> method of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2587.1">Derived1</span></code><span class="koboSpan" id="kobo.2588.1"> class would not be an overridden method but, instead, an overload of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2589.1">bar()</span></code><span class="koboSpan" id="kobo.2590.1"> from </span><code class="inlineCode"><span class="koboSpan" id="kobo.2591.1">Base</span></code><span class="koboSpan" id="kobo.2592.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2593.1">The other special identifier, </span><code class="inlineCode"><span class="koboSpan" id="kobo.2594.1">final</span></code><span class="koboSpan" id="kobo.2595.1">, is used in a member function declaration or definition to indicate that the function is virtual and cannot be overridden in a derived class. </span><span class="koboSpan" id="kobo.2595.2">If a derived class attempts to override the virtual function, the compiler triggers an error:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2596.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2597.1">Derived2</span></span><span class="koboSpan" id="kobo.2598.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2599.1">public</span></span><span class="koboSpan" id="kobo.2600.1"> Derived1
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2601.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2602.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2603.1">foo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2604.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2605.1">final</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2606.1">{}
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2607.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2608.1">Derived3</span></span><span class="koboSpan" id="kobo.2609.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2610.1">public</span></span><span class="koboSpan" id="kobo.2611.1"> Derived2
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2612.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2613.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2614.1">foo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2615.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2616.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2617.1">{} </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2618.1">// error</span></span><span class="koboSpan" id="kobo.2619.1">
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2620.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.2621.1">final</span></code><span class="koboSpan" id="kobo.2622.1"> specifier can also be used in a class declaration to indicate that it cannot be derived:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2623.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2624.1">Derived4</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2625.1">final</span></span><span class="koboSpan" id="kobo.2626.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2627.1">public</span></span><span class="koboSpan" id="kobo.2628.1"> Derived1
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2629.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.2630.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2631.1">foo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2632.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2633.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2634.1">{}
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2635.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2636.1">Derived5</span></span><span class="koboSpan" id="kobo.2637.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2638.1">public</span></span><span class="koboSpan" id="kobo.2639.1"> Derived4 </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2640.1">// error</span></span><span class="koboSpan" id="kobo.2641.1">
{
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2642.1">Since both </span><code class="inlineCode"><span class="koboSpan" id="kobo.2643.1">override</span></code><span class="koboSpan" id="kobo.2644.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2645.1">final</span></code><span class="koboSpan" id="kobo.2646.1"> have this special meaning when used in the defined context and</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.2647.1"> are not, in fact, reserved keywords, you can still use </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.2648.1">them anywhere else in the C++ code. </span><span class="koboSpan" id="kobo.2648.2">This</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.2649.1"> ensures that existing code written before C++11 does not break because of the use of these names for identifiers:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2650.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2651.1">foo</span></span><span class="koboSpan" id="kobo.2652.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2653.1">int</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2654.1">final</span></span><span class="koboSpan" id="kobo.2655.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2656.1">0</span></span><span class="koboSpan" id="kobo.2657.1">;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.2658.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.2659.1">override</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2660.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.2661.1">{}
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2662.1">Although the recommendation given earlier suggested using both </span><code class="inlineCode"><span class="koboSpan" id="kobo.2663.1">virtual</span></code><span class="koboSpan" id="kobo.2664.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2665.1">override</span></code><span class="koboSpan" id="kobo.2666.1"> in the declaration of an overridden virtual method, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2667.1">virtual</span></code><span class="koboSpan" id="kobo.2668.1"> keyword is optional and can be omitted to shorten the declaration. </span><span class="koboSpan" id="kobo.2668.2">The presence of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2669.1">override</span></code><span class="koboSpan" id="kobo.2670.1"> specifier should be enough to indicate to the reader that the method is virtual. </span><span class="koboSpan" id="kobo.2670.2">This is rather a matter of personal preference and does not affect the semantics.</span></p>
<h2 class="heading-2" id="_idParaDest-47"><span class="koboSpan" id="kobo.2671.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.2672.1">Chapter 10</span></em><span class="koboSpan" id="kobo.2673.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2674.1">Static polymorphism with the curiously recurring template pattern</span></em><span class="koboSpan" id="kobo.2675.1">, to learn how the CRTP pattern helps with implementing polymorphism at compile time</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-48"><span class="koboSpan" id="kobo.2676.1">Using range-based for loops to iterate on a range</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2677.1">Many programming</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.2678.1"> languages support a variant of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.2679.1">for</span></code><span class="koboSpan" id="kobo.2680.1"> loop called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2681.1">for each</span></code><span class="koboSpan" id="kobo.2682.1">—that is, repeating a group of statements over the elements of a collection. </span><span class="koboSpan" id="kobo.2682.2">C++ did not have core language support for this until C++11. </span><span class="koboSpan" id="kobo.2682.3">The closest feature was the general-purpose algorithm from the standard library called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2683.1">std::for_each</span></code><span class="koboSpan" id="kobo.2684.1">, which applies a function to all the elements in a range. </span><span class="koboSpan" id="kobo.2684.2">C++11 brought language support for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2685.1">for each</span></code><span class="koboSpan" id="kobo.2686.1"> that’s actually called </span><em class="italic"><span class="koboSpan" id="kobo.2687.1">range-based for loops</span></em><span class="koboSpan" id="kobo.2688.1">. </span><span class="koboSpan" id="kobo.2688.2">The new C++17 standard provides several improvements to the original language feature.</span></p>
<h2 class="heading-2" id="_idParaDest-49"><span class="koboSpan" id="kobo.2689.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2690.1">In C++11, a range-based for loop has the following general syntax:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2691.1">for</span></span><span class="koboSpan" id="kobo.2692.1"> ( range_declaration : range_expression ) loop_statement
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2693.1">In C++20, an initialization statement (which must end with a semicolon) can be present before the range declaration. </span><span class="koboSpan" id="kobo.2693.2">Therefore, the general form becomes the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2694.1">for(init-statement range-declaration : range-expression)
loop-statement
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2695.1">To exemplify the various ways of using range-based for loops, we will use the following functions, which return sequences of elements:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.2696.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2697.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2698.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2699.1">getRates</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2700.1">()</span></span><span class="koboSpan" id="kobo.2701.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2702.1">return</span></span><span class="koboSpan" id="kobo.2703.1"> std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2704.1">int</span></span><span class="koboSpan" id="kobo.2705.1">&gt; {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2706.1">1</span></span><span class="koboSpan" id="kobo.2707.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2708.1">1</span></span><span class="koboSpan" id="kobo.2709.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2710.1">2</span></span><span class="koboSpan" id="kobo.2711.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2712.1">3</span></span><span class="koboSpan" id="kobo.2713.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2714.1">5</span></span><span class="koboSpan" id="kobo.2715.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2716.1">8</span></span><span class="koboSpan" id="kobo.2717.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2718.1">13</span></span><span class="koboSpan" id="kobo.2719.1">};
}
</span><span class="hljs-function"><span class="koboSpan" id="kobo.2720.1">std::multimap&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2721.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2722.1">, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2723.1">bool</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2724.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2725.1">getRates2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2726.1">()</span></span><span class="koboSpan" id="kobo.2727.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2728.1">return</span></span><span class="koboSpan" id="kobo.2729.1"> std::multimap&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2730.1">int</span></span><span class="koboSpan" id="kobo.2731.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.2732.1">bool</span></span><span class="koboSpan" id="kobo.2733.1">&gt; {
    { </span><span class="hljs-number"><span class="koboSpan" id="kobo.2734.1">1</span></span><span class="koboSpan" id="kobo.2735.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2736.1">true</span></span><span class="koboSpan" id="kobo.2737.1"> },
    { </span><span class="hljs-number"><span class="koboSpan" id="kobo.2738.1">1</span></span><span class="koboSpan" id="kobo.2739.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2740.1">true</span></span><span class="koboSpan" id="kobo.2741.1"> },
    { </span><span class="hljs-number"><span class="koboSpan" id="kobo.2742.1">2</span></span><span class="koboSpan" id="kobo.2743.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2744.1">false</span></span><span class="koboSpan" id="kobo.2745.1"> },
    { </span><span class="hljs-number"><span class="koboSpan" id="kobo.2746.1">3</span></span><span class="koboSpan" id="kobo.2747.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2748.1">true</span></span><span class="koboSpan" id="kobo.2749.1"> },
    { </span><span class="hljs-number"><span class="koboSpan" id="kobo.2750.1">5</span></span><span class="koboSpan" id="kobo.2751.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2752.1">true</span></span><span class="koboSpan" id="kobo.2753.1"> },
    { </span><span class="hljs-number"><span class="koboSpan" id="kobo.2754.1">8</span></span><span class="koboSpan" id="kobo.2755.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2756.1">false</span></span><span class="koboSpan" id="kobo.2757.1"> },
    { </span><span class="hljs-number"><span class="koboSpan" id="kobo.2758.1">13</span></span><span class="koboSpan" id="kobo.2759.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.2760.1">true</span></span><span class="koboSpan" id="kobo.2761.1"> }
  };
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2762.1">In the next section, we’ll look at the various ways we can use range-based for loops.</span></p>
<h2 class="heading-2" id="_idParaDest-50"><span class="koboSpan" id="kobo.2763.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2764.1">Range-based </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.2765.1">for loops can be used in various ways:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2766.1">By committing to a specific type for the elements of the sequence:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2767.1">auto</span></span><span class="koboSpan" id="kobo.2768.1"> rates = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2769.1">getRates</span></span><span class="koboSpan" id="kobo.2770.1">();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2771.1">for</span></span><span class="koboSpan" id="kobo.2772.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.2773.1">int</span></span><span class="koboSpan" id="kobo.2774.1"> rate : rates)
  std::cout &lt;&lt; rate &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2775.1">'\n'</span></span><span class="koboSpan" id="kobo.2776.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2777.1">for</span></span><span class="koboSpan" id="kobo.2778.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.2779.1">int</span></span><span class="koboSpan" id="kobo.2780.1">&amp; rate : rates)
  rate *= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2781.1">2</span></span><span class="koboSpan" id="kobo.2782.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2783.1">By not specifying a type and letting the compiler deduce it:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2784.1">for</span></span><span class="koboSpan" id="kobo.2785.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2786.1">auto</span></span><span class="koboSpan" id="kobo.2787.1">&amp;&amp; rate : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2788.1">getRates</span></span><span class="koboSpan" id="kobo.2789.1">())
  std::cout &lt;&lt; rate &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2790.1">'\n'</span></span><span class="koboSpan" id="kobo.2791.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2792.1">for</span></span><span class="koboSpan" id="kobo.2793.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2794.1">auto</span></span><span class="koboSpan" id="kobo.2795.1"> &amp; rate : rates)
  rate *= </span><span class="hljs-number"><span class="koboSpan" id="kobo.2796.1">2</span></span><span class="koboSpan" id="kobo.2797.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2798.1">for</span></span><span class="koboSpan" id="kobo.2799.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2800.1">auto</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.2801.1">const</span></span><span class="koboSpan" id="kobo.2802.1"> &amp; rate : rates)
  std::cout &lt;&lt; rate &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2803.1">'\n'</span></span><span class="koboSpan" id="kobo.2804.1">;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.2805.1">By using structured bindings and decomposition declaration in C++17:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2806.1">for</span></span><span class="koboSpan" id="kobo.2807.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2808.1">auto</span></span><span class="koboSpan" id="kobo.2809.1">&amp;&amp; [rate, flag] : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2810.1">getRates2</span></span><span class="koboSpan" id="kobo.2811.1">())
  std::cout &lt;&lt; rate &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2812.1">'\n'</span></span><span class="koboSpan" id="kobo.2813.1">;
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-51"><span class="koboSpan" id="kobo.2814.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2815.1">The </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.2816.1">expression for the range-based for loops shown earlier in the </span><em class="italic"><span class="koboSpan" id="kobo.2817.1">How to do it...</span></em><span class="koboSpan" id="kobo.2818.1"> section is basically syntactic sugar, as the compiler transforms it into something else. </span><span class="koboSpan" id="kobo.2818.2">Before C++17, the code generated by the compiler used to be the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2819.1">{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2820.1">auto</span></span><span class="koboSpan" id="kobo.2821.1"> &amp;&amp; __range = range_expression;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2822.1">for</span></span><span class="koboSpan" id="kobo.2823.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2824.1">auto</span></span><span class="koboSpan" id="kobo.2825.1"> __begin = begin_expr, __end = end_expr;
  __begin != __end; ++__begin) {
    range_declaration = *__begin;
    loop_statement
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2826.1">What </span><code class="inlineCode"><span class="koboSpan" id="kobo.2827.1">begin_expr</span></code><span class="koboSpan" id="kobo.2828.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2829.1">end_expr</span></code><span class="koboSpan" id="kobo.2830.1"> are in this code depends on the type of the range:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.2831.1">For C-like arrays: </span><code class="inlineCode"><span class="koboSpan" id="kobo.2832.1">__range</span></code><span class="koboSpan" id="kobo.2833.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2834.1">__range + __bound</span></code><span class="koboSpan" id="kobo.2835.1"> (where </span><code class="inlineCode"><span class="koboSpan" id="kobo.2836.1">__bound</span></code><span class="koboSpan" id="kobo.2837.1"> is the number of elements in the array).</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2838.1">For a class type with </span><code class="inlineCode"><span class="koboSpan" id="kobo.2839.1">begin</span></code><span class="koboSpan" id="kobo.2840.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2841.1">end</span></code><span class="koboSpan" id="kobo.2842.1"> members (regardless of their type and accessibility): </span><code class="inlineCode"><span class="koboSpan" id="kobo.2843.1">__range.begin()</span></code><span class="koboSpan" id="kobo.2844.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2845.1">__range.end()</span></code><span class="koboSpan" id="kobo.2846.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.2847.1">For others, it is </span><code class="inlineCode"><span class="koboSpan" id="kobo.2848.1">begin(__range)</span></code><span class="koboSpan" id="kobo.2849.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2850.1">end(__range)</span></code><span class="koboSpan" id="kobo.2851.1">, which are determined via argument-dependent lookup.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.2852.1">It is important to note that if a class contains any members (function, data member, or enumerators) called </span><code class="inlineCode"><span class="koboSpan" id="kobo.2853.1">begin</span></code><span class="koboSpan" id="kobo.2854.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.2855.1">end</span></code><span class="koboSpan" id="kobo.2856.1">, regardless of their type and accessibility, they will be picked for </span><code class="inlineCode"><span class="koboSpan" id="kobo.2857.1">begin_expr</span></code><span class="koboSpan" id="kobo.2858.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2859.1">end_expr</span></code><span class="koboSpan" id="kobo.2860.1">. </span><span class="koboSpan" id="kobo.2860.2">Therefore, such a class type cannot be used in range-based for loops.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2861.1">In C++17, the code generated by the compiler is slightly different:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2862.1">{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2863.1">auto</span></span><span class="koboSpan" id="kobo.2864.1"> &amp;&amp; __range = range_expression;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2865.1">auto</span></span><span class="koboSpan" id="kobo.2866.1"> __begin = begin_expr;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2867.1">auto</span></span><span class="koboSpan" id="kobo.2868.1"> __end = end_expr;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2869.1">for</span></span><span class="koboSpan" id="kobo.2870.1"> (; __begin != __end; ++__begin) {
    range_declaration = *__begin;
    loop_statement
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2871.1">The new </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.2872.1">standard has removed the constraint that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2873.1">begin</span></code><span class="koboSpan" id="kobo.2874.1"> expression and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2875.1">end</span></code><span class="koboSpan" id="kobo.2876.1"> expression must be the same type. </span><span class="koboSpan" id="kobo.2876.2">The end expression does not need to be an actual iterator, but it has to be able to be compared for inequality with an iterator. </span><span class="koboSpan" id="kobo.2876.3">A benefit of this is that the range can be delimited by a predicate. </span><span class="koboSpan" id="kobo.2876.4">Conversely, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2877.1">end</span></code><span class="koboSpan" id="kobo.2878.1"> expression is only evaluated once, and not every time the loop is iterated, which could potentially increase performance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2879.1">As mentioned in the previous section, in C++20, an initialization statement can be present before the range declaration. </span><span class="koboSpan" id="kobo.2879.2">This has the effect that the compiler-generated code for a range-based for loop has the following form:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.2880.1">{
  init-statement
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2881.1">auto</span></span><span class="koboSpan" id="kobo.2882.1"> &amp;&amp; __range = range_expression;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2883.1">auto</span></span><span class="koboSpan" id="kobo.2884.1"> __begin = begin_expr;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2885.1">auto</span></span><span class="koboSpan" id="kobo.2886.1"> __end = end_expr;
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2887.1">for</span></span><span class="koboSpan" id="kobo.2888.1"> (; __begin != __end; ++__begin) {
    range_declaration = *__begin;
    loop_statement
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2889.1">The initialization statement can be an empty statement, an expression statement, a simple declaration, or, starting with C++23, an alias declaration. </span><span class="koboSpan" id="kobo.2889.2">An example is shown in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2890.1">for</span></span><span class="koboSpan" id="kobo.2891.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2892.1">auto</span></span><span class="koboSpan" id="kobo.2893.1"> rates = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2894.1">getRates</span></span><span class="koboSpan" id="kobo.2895.1">(); </span><span class="hljs-type"><span class="koboSpan" id="kobo.2896.1">int</span></span><span class="koboSpan" id="kobo.2897.1"> rate : rates)
{
   std::cout &lt;&lt; rate &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2898.1">'\n'</span></span><span class="koboSpan" id="kobo.2899.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2900.1">Prior to C++23, this was helpful to avoid undefined behavior with temporaries in range expressions. </span><span class="koboSpan" id="kobo.2900.2">The lifetime of a temporary returned by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2901.1">range-expression</span></code><span class="koboSpan" id="kobo.2902.1"> is extended until the end of the loop. </span><span class="koboSpan" id="kobo.2902.2">However, the lifetime of temporaries within the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2903.1">range-expression</span></code><span class="koboSpan" id="kobo.2904.1"> is not extended if they will be destroyed at the end of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2905.1">range-expression</span></code><span class="koboSpan" id="kobo.2906.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.2907.1">We will explain this with the help of the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2908.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2909.1">item</span></span><span class="koboSpan" id="kobo.2910.1">
{
   </span><span class="hljs-function"><span class="koboSpan" id="kobo.2911.1">std::vector&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.2912.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.2913.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2914.1">getRates</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2915.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.2916.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2917.1">return</span></span><span class="koboSpan" id="kobo.2918.1"> std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.2919.1">int</span></span><span class="koboSpan" id="kobo.2920.1">&gt; {</span><span class="hljs-number"><span class="koboSpan" id="kobo.2921.1">1</span></span><span class="koboSpan" id="kobo.2922.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2923.1">1</span></span><span class="koboSpan" id="kobo.2924.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2925.1">2</span></span><span class="koboSpan" id="kobo.2926.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2927.1">3</span></span><span class="koboSpan" id="kobo.2928.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2929.1">5</span></span><span class="koboSpan" id="kobo.2930.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2931.1">8</span></span><span class="koboSpan" id="kobo.2932.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2933.1">13</span></span><span class="koboSpan" id="kobo.2934.1">};
   }
};
</span><span class="hljs-function"><span class="koboSpan" id="kobo.2935.1">item </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.2936.1">make_item</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.2937.1">()</span></span><span class="koboSpan" id="kobo.2938.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2939.1">return</span></span><span class="koboSpan" id="kobo.2940.1"> item{};
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.2941.1">// undefined behavior, until C++23</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2942.1">for</span></span><span class="koboSpan" id="kobo.2943.1"> (</span><span class="hljs-type"><span class="koboSpan" id="kobo.2944.1">int</span></span><span class="koboSpan" id="kobo.2945.1"> rate : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2946.1">make_item</span></span><span class="koboSpan" id="kobo.2947.1">().</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2948.1">getRates</span></span><span class="koboSpan" id="kobo.2949.1">())
{
   std::cout &lt;&lt; rate &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2950.1">'\n'</span></span><span class="koboSpan" id="kobo.2951.1">;
} 
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2952.1">Since </span><code class="inlineCode"><span class="koboSpan" id="kobo.2953.1">make_item()</span></code><span class="koboSpan" id="kobo.2954.1"> returns by value, we have a temporary within </span><code class="inlineCode"><span class="koboSpan" id="kobo.2955.1">range-expression</span></code><span class="koboSpan" id="kobo.2956.1">. </span><span class="koboSpan" id="kobo.2956.2">This introduces undefined behavior, which can be avoided with an initialization statement, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.2957.1">for</span></span><span class="koboSpan" id="kobo.2958.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2959.1">auto</span></span><span class="koboSpan" id="kobo.2960.1"> item = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2961.1">make_item</span></span><span class="koboSpan" id="kobo.2962.1">(); </span><span class="hljs-type"><span class="koboSpan" id="kobo.2963.1">int</span></span><span class="koboSpan" id="kobo.2964.1"> rate : item.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2965.1">getRates</span></span><span class="koboSpan" id="kobo.2966.1">())
{
   std::cout &lt;&lt; rate &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.2967.1">'\n'</span></span><span class="koboSpan" id="kobo.2968.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.2969.1">This problem </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.2970.1">no longer manifests in C++23, because this version of the standard also extends the lifetime of all the temporaries within the </span><code class="inlineCode"><span class="koboSpan" id="kobo.2971.1">range-expression</span></code><span class="koboSpan" id="kobo.2972.1"> until the end of the loop.</span></p>
<h2 class="heading-2" id="_idParaDest-52"><span class="koboSpan" id="kobo.2973.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.2974.1">Enabling range-based for loops for custom types</span></em><span class="koboSpan" id="kobo.2975.1">, to see how to make it possible for user-defined types to be used with range-based for loops</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.2976.1">Chapter 12</span></em><span class="koboSpan" id="kobo.2977.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2978.1">Iterating over collections with the ranges library</span></em><span class="koboSpan" id="kobo.2979.1">, to learn about the fundamentals of the C++20 ranges library</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.2980.1">Chapter 12</span></em><span class="koboSpan" id="kobo.2981.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2982.1">Creating your own range view</span></em><span class="koboSpan" id="kobo.2983.1">, to see how to extend the C++20 range library’s capabilities with user-defined range adaptors</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-53"><span class="koboSpan" id="kobo.2984.1">Enabling range-based for loops for custom types</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.2985.1">As we saw in the</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.2986.1"> preceding recipe, range-based </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.2987.1">for loops, known as </span><code class="inlineCode"><span class="koboSpan" id="kobo.2988.1">for each</span></code><span class="koboSpan" id="kobo.2989.1"> in other programming languages, allow you to iterate over the elements of a range, providing a simplified syntax over the standard </span><code class="inlineCode"><span class="koboSpan" id="kobo.2990.1">for</span></code><span class="koboSpan" id="kobo.2991.1"> loops and making the code more readable in many situations. </span><span class="koboSpan" id="kobo.2991.2">However, range-based for loops do not work out of the box with any type representing a range, but require the presence of </span><code class="inlineCode"><span class="koboSpan" id="kobo.2992.1">begin()</span></code><span class="koboSpan" id="kobo.2993.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.2994.1">end()</span></code><span class="koboSpan" id="kobo.2995.1"> functions (for non-array types), either as a member or free function. </span><span class="koboSpan" id="kobo.2995.2">In this recipe, we will learn how to enable a custom type to be used in range-based for loops.</span></p>
<h2 class="heading-2" id="_idParaDest-54"><span class="koboSpan" id="kobo.2996.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.2997.1">It is recommended that you read the </span><em class="italic"><span class="koboSpan" id="kobo.2998.1">Using range-based for loops to iterate on a range</span></em><span class="koboSpan" id="kobo.2999.1"> recipe before continuing with this one if you need to understand how range-based for loops work, as well as what code the compiler generates for such a loop.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3000.1">To show how we can enable range-based for loops for custom types representing sequences, we will use the following implementation of a simple array:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3001.1">template</span></span><span class="koboSpan" id="kobo.3002.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3003.1">typename</span></span><span class="koboSpan" id="kobo.3004.1"> T, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3005.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3006.1">const</span></span><span class="koboSpan" id="kobo.3007.1"> Size&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3008.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3009.1">dummy_array</span></span><span class="koboSpan" id="kobo.3010.1">
{
  T data[Size] = {};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3011.1">public</span></span><span class="koboSpan" id="kobo.3012.1">:
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.3013.1">T </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3014.1">const</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3015.1"> &amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3016.1">GetAt</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3017.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3018.1">size_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3019.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3020.1"> index)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3021.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.3022.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3023.1">if</span></span><span class="koboSpan" id="kobo.3024.1"> (index &lt; Size) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3025.1">return</span></span><span class="koboSpan" id="kobo.3026.1"> data[index];
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3027.1">throw</span></span><span class="koboSpan" id="kobo.3028.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3029.1">out_of_range</span></span><span class="koboSpan" id="kobo.3030.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3031.1">"index out of range"</span></span><span class="koboSpan" id="kobo.3032.1">);
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3033.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3034.1">SetAt</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3035.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3036.1">size_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3037.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3038.1"> index, T </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3039.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3040.1"> &amp; value)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.3041.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3042.1">if</span></span><span class="koboSpan" id="kobo.3043.1"> (index &lt; Size) data[index] = value;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3044.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3045.1">throw</span></span><span class="koboSpan" id="kobo.3046.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3047.1">out_of_range</span></span><span class="koboSpan" id="kobo.3048.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3049.1">"index out of range"</span></span><span class="koboSpan" id="kobo.3050.1">);
  }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3051.1">size_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3052.1">GetSize</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3053.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3054.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3055.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3056.1">return</span></span><span class="koboSpan" id="kobo.3057.1"> Size; }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3058.1">The purpose of this recipe is to enable writing code like the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3059.1">dummy_array&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3060.1">int</span></span><span class="koboSpan" id="kobo.3061.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3062.1">3</span></span><span class="koboSpan" id="kobo.3063.1">&gt; arr;
arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3064.1">SetAt</span></span><span class="koboSpan" id="kobo.3065.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3066.1">0</span></span><span class="koboSpan" id="kobo.3067.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3068.1">1</span></span><span class="koboSpan" id="kobo.3069.1">);
arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3070.1">SetAt</span></span><span class="koboSpan" id="kobo.3071.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3072.1">1</span></span><span class="koboSpan" id="kobo.3073.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3074.1">2</span></span><span class="koboSpan" id="kobo.3075.1">);
arr.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3076.1">SetAt</span></span><span class="koboSpan" id="kobo.3077.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3078.1">2</span></span><span class="koboSpan" id="kobo.3079.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3080.1">3</span></span><span class="koboSpan" id="kobo.3081.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3082.1">for</span></span><span class="koboSpan" id="kobo.3083.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3084.1">auto</span></span><span class="koboSpan" id="kobo.3085.1">&amp;&amp; e : arr)
{
  std::cout &lt;&lt; e &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3086.1">'\n'</span></span><span class="koboSpan" id="kobo.3087.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3088.1">The steps necessary to make all this possible are described in detail in the following section.</span></p>
<h2 class="heading-2" id="_idParaDest-55"><span class="koboSpan" id="kobo.3089.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3090.1">To enable a</span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.3091.1"> custom type to be used in range-based </span><code class="inlineCode"><span class="koboSpan" id="kobo.3092.1">for</span></code><span class="koboSpan" id="kobo.3093.1"> loops, you</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.3094.1"> need to do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3095.1">Create mutable and constant iterators for the type, which must implement the following operators:</span><ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3096.1">operator++</span></code><span class="koboSpan" id="kobo.3097.1"> (both the prefix and the postfix version) for incrementing the iterator</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3098.1">operator*</span></code><span class="koboSpan" id="kobo.3099.1"> for dereferencing the iterator and accessing the actual element being pointed to by the iterator</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.3100.1">operator!=</span></code><span class="koboSpan" id="kobo.3101.1"> for comparing the iterator with another iterator for inequality</span></li>
</ul>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3102.1">Provide free </span><code class="inlineCode"><span class="koboSpan" id="kobo.3103.1">begin()</span></code><span class="koboSpan" id="kobo.3104.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3105.1">end()</span></code><span class="koboSpan" id="kobo.3106.1"> functions for the type.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3107.1">Given the earlier example of a simple range, we need to provide the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3108.1">The following minimal implementation of an iterator class:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3109.1">template</span></span><span class="koboSpan" id="kobo.3110.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3111.1">typename</span></span><span class="koboSpan" id="kobo.3112.1"> T, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3113.1">typename</span></span><span class="koboSpan" id="kobo.3114.1"> C, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3115.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3116.1">const</span></span><span class="koboSpan" id="kobo.3117.1"> Size&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3118.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3119.1">dummy_array_iterator_type</span></span><span class="koboSpan" id="kobo.3120.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3121.1">public</span></span><span class="koboSpan" id="kobo.3122.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3123.1">dummy_array_iterator_type</span></span><span class="koboSpan" id="kobo.3124.1">(C&amp; collection,
                            </span><span class="hljs-type"><span class="koboSpan" id="kobo.3125.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3126.1">const</span></span><span class="koboSpan" id="kobo.3127.1"> index) :
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3128.1">index</span></span><span class="koboSpan" id="kobo.3129.1">(index), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3130.1">collection</span></span><span class="koboSpan" id="kobo.3131.1">(collection)
  { }
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3132.1">bool</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3133.1">operator</span></span><span class="koboSpan" id="kobo.3134.1">!= (dummy_array_iterator_type </span><span class="hljs-type"><span class="koboSpan" id="kobo.3135.1">const</span></span><span class="koboSpan" id="kobo.3136.1"> &amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.3137.1">const</span></span><span class="koboSpan" id="kobo.3138.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3139.1">return</span></span><span class="koboSpan" id="kobo.3140.1"> index != other.index;
  }
  T </span><span class="hljs-type"><span class="koboSpan" id="kobo.3141.1">const</span></span><span class="koboSpan" id="kobo.3142.1"> &amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3143.1">operator</span></span><span class="koboSpan" id="kobo.3144.1">* () </span><span class="hljs-type"><span class="koboSpan" id="kobo.3145.1">const</span></span><span class="koboSpan" id="kobo.3146.1">
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3147.1">return</span></span><span class="koboSpan" id="kobo.3148.1"> collection.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3149.1">GetAt</span></span><span class="koboSpan" id="kobo.3150.1">(index);
  }
  dummy_array_iterator_type&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3151.1">operator</span></span><span class="koboSpan" id="kobo.3152.1">++()
  {
    ++index;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3153.1">return</span></span><span class="koboSpan" id="kobo.3154.1"> *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3155.1">this</span></span><span class="koboSpan" id="kobo.3156.1">;
  }
  dummy_array_iterator_type </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3157.1">operator</span></span><span class="koboSpan" id="kobo.3158.1">++(</span><span class="hljs-type"><span class="koboSpan" id="kobo.3159.1">int</span></span><span class="koboSpan" id="kobo.3160.1">)
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3161.1">auto</span></span><span class="koboSpan" id="kobo.3162.1"> temp = *</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3163.1">this</span></span><span class="koboSpan" id="kobo.3164.1">;
    ++*this;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3165.1">return</span></span><span class="koboSpan" id="kobo.3166.1"> temp;
  }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3167.1">private</span></span><span class="koboSpan" id="kobo.3168.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3169.1">size_t</span></span><span class="koboSpan" id="kobo.3170.1">   index;
  C&amp;       collection;
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3171.1">Alias</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.3172.1"> templates for mutable and </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.3173.1">constant iterators:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3174.1">template</span></span><span class="koboSpan" id="kobo.3175.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3176.1">typename</span></span><span class="koboSpan" id="kobo.3177.1"> T, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3178.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3179.1">const</span></span><span class="koboSpan" id="kobo.3180.1"> Size&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3181.1">using</span></span><span class="koboSpan" id="kobo.3182.1"> dummy_array_iterator =
  dummy_array_iterator_type&lt;
    T, dummy_array&lt;T, Size&gt;, Size&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3183.1">template</span></span><span class="koboSpan" id="kobo.3184.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3185.1">typename</span></span><span class="koboSpan" id="kobo.3186.1"> T, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3187.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3188.1">const</span></span><span class="koboSpan" id="kobo.3189.1"> Size&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3190.1">using</span></span><span class="koboSpan" id="kobo.3191.1"> dummy_array_const_iterator =
  dummy_array_iterator_type&lt;
    T, dummy_array&lt;T, Size&gt; </span><span class="hljs-type"><span class="koboSpan" id="kobo.3192.1">const</span></span><span class="koboSpan" id="kobo.3193.1">, Size&gt;;
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.3194.1">Free </span><code class="inlineCode"><span class="koboSpan" id="kobo.3195.1">begin()</span></code><span class="koboSpan" id="kobo.3196.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3197.1">end()</span></code><span class="koboSpan" id="kobo.3198.1"> functions that return the respective begin and end iterators, with overloads for both alias templates:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3199.1">template</span></span><span class="koboSpan" id="kobo.3200.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3201.1">typename</span></span><span class="koboSpan" id="kobo.3202.1"> T, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3203.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3204.1">const</span></span><span class="koboSpan" id="kobo.3205.1"> Size&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3206.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3207.1"> dummy_array_iterator&lt;T, Size&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3208.1">begin</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3209.1">(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.3210.1">  dummy_array&lt;T, Size&gt;&amp; collection)</span></span><span class="koboSpan" id="kobo.3211.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3212.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3213.1">dummy_array_iterator</span></span><span class="koboSpan" id="kobo.3214.1">&lt;T, Size&gt;(collection, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3215.1">0</span></span><span class="koboSpan" id="kobo.3216.1">);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3217.1">template</span></span><span class="koboSpan" id="kobo.3218.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3219.1">typename</span></span><span class="koboSpan" id="kobo.3220.1"> T, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3221.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3222.1">const</span></span><span class="koboSpan" id="kobo.3223.1"> Size&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3224.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3225.1"> dummy_array_iterator&lt;T, Size&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3226.1">end</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3227.1">(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.3228.1">  dummy_array&lt;T, Size&gt;&amp; collection)</span></span><span class="koboSpan" id="kobo.3229.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3230.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3231.1">dummy_array_iterator</span></span><span class="koboSpan" id="kobo.3232.1">&lt;T, Size&gt;(
    collection, collection.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3233.1">GetSize</span></span><span class="koboSpan" id="kobo.3234.1">());
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3235.1">template</span></span><span class="koboSpan" id="kobo.3236.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3237.1">typename</span></span><span class="koboSpan" id="kobo.3238.1"> T, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3239.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3240.1">const</span></span><span class="koboSpan" id="kobo.3241.1"> Size&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3242.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3243.1"> dummy_array_const_iterator&lt;T, Size&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3244.1">begin</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3245.1">(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.3246.1">  dummy_array&lt;T, Size&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3247.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3248.1"> &amp; collection)</span></span><span class="koboSpan" id="kobo.3249.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3250.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3251.1">dummy_array_const_iterator</span></span><span class="koboSpan" id="kobo.3252.1">&lt;T, Size&gt;(
    collection, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3253.1">0</span></span><span class="koboSpan" id="kobo.3254.1">);
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3255.1">template</span></span><span class="koboSpan" id="kobo.3256.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3257.1">typename</span></span><span class="koboSpan" id="kobo.3258.1"> T, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3259.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3260.1">const</span></span><span class="koboSpan" id="kobo.3261.1"> Size&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3262.1">inline</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3263.1"> dummy_array_const_iterator&lt;T, Size&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3264.1">end</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3265.1">(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.3266.1">  dummy_array&lt;T, Size&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3267.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3268.1"> &amp; collection)</span></span><span class="koboSpan" id="kobo.3269.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3270.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.3271.1">dummy_array_const_iterator</span></span><span class="koboSpan" id="kobo.3272.1">&lt;T, Size&gt;(
    collection, collection.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3273.1">GetSize</span></span><span class="koboSpan" id="kobo.3274.1">());
}
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-56"><span class="koboSpan" id="kobo.3275.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3276.1">Having this</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.3277.1"> implementation available, the range-based</span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.3278.1"> for loop shown earlier compiles and executes as expected. </span><span class="koboSpan" id="kobo.3278.2">When performing an argument-dependent lookup, the compiler will identify the two </span><code class="inlineCode"><span class="koboSpan" id="kobo.3279.1">begin()</span></code><span class="koboSpan" id="kobo.3280.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3281.1">end()</span></code><span class="koboSpan" id="kobo.3282.1"> functions that we wrote (which take a reference to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3283.1">dummy_array</span></code><span class="koboSpan" id="kobo.3284.1">), and therefore, the code it generates becomes valid.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3285.1">In the preceding example, we have defined one iterator class template and two alias templates, called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3286.1">dummy_array_iterator</span></code><span class="koboSpan" id="kobo.3287.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3288.1">dummy_array_const_iterator</span></code><span class="koboSpan" id="kobo.3289.1">. </span><span class="koboSpan" id="kobo.3289.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.3290.1">begin()</span></code><span class="koboSpan" id="kobo.3291.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3292.1">end()</span></code><span class="koboSpan" id="kobo.3293.1"> functions both have two overloads for these two types of iterators.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3294.1">This is necessary so that the container we have considered can be used in range-based for loops with both constant and non-constant instances:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3295.1">template</span></span><span class="koboSpan" id="kobo.3296.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3297.1">typename</span></span><span class="koboSpan" id="kobo.3298.1"> T, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3299.1">const</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3300.1">size_t</span></span><span class="koboSpan" id="kobo.3301.1"> Size&gt;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3302.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3303.1">print_dummy_array</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3304.1">(dummy_array&lt;T, Size&gt; </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3305.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3306.1"> &amp; arr)</span></span><span class="koboSpan" id="kobo.3307.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3308.1">for</span></span><span class="koboSpan" id="kobo.3309.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3310.1">auto</span></span><span class="koboSpan" id="kobo.3311.1"> &amp;&amp; e : arr)
  {
    std::cout &lt;&lt; e &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3312.1">'\n'</span></span><span class="koboSpan" id="kobo.3313.1">;
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3314.1">A possible </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.3315.1">alternative to enable range-based for </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.3316.1">loops for the simple range class we considered for this recipe is to provide the member </span><code class="inlineCode"><span class="koboSpan" id="kobo.3317.1">begin()</span></code><span class="koboSpan" id="kobo.3318.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3319.1">end()</span></code><span class="koboSpan" id="kobo.3320.1"> functions. </span><span class="koboSpan" id="kobo.3320.2">In general, that will make sense only if you own and can modify the source code. </span><span class="koboSpan" id="kobo.3320.3">Conversely, the solution shown in this recipe works in all cases and should be preferred to other alternatives.</span></p>
<h2 class="heading-2" id="_idParaDest-57"><span class="koboSpan" id="kobo.3321.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3322.1">Creating type aliases and alias templates</span></em><span class="koboSpan" id="kobo.3323.1">, to learn about aliases for types</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.3324.1">Chapter 12</span></em><span class="koboSpan" id="kobo.3325.1">, </span><em class="italic"><span class="koboSpan" id="kobo.3326.1">Iterating over collections with the ranges library</span></em><span class="koboSpan" id="kobo.3327.1">, to learn about the fundamentals of the C++20 ranges library</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-58"><span class="koboSpan" id="kobo.3328.1">Using explicit constructors and conversion operators to avoid implicit conversion</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3329.1">Before C++11, a constructor</span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.3330.1"> with a single parameter was considered a converting constructor (because it takes a value of another type and creates a new instance of the class out of it). </span><span class="koboSpan" id="kobo.3330.2">With C++11, every constructor without the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3331.1">explicit</span></code><span class="koboSpan" id="kobo.3332.1"> specifier is considered a converting constructor. </span><span class="koboSpan" id="kobo.3332.2">This is important because such a constructor defines an implicit conversion from the type or types of its arguments to the type of the class. </span><span class="koboSpan" id="kobo.3332.3">Classes can also define converting operators that convert the type of the class to another specified type. </span><span class="koboSpan" id="kobo.3332.4">All of these are useful in some cases but can create problems in other cases. </span><span class="koboSpan" id="kobo.3332.5">In this recipe, we will learn how to use explicit constructors and conversion operators.</span></p>
<h2 class="heading-2" id="_idParaDest-59"><span class="koboSpan" id="kobo.3333.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3334.1">For this recipe, you</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.3335.1"> need to be familiar with converting constructors and converting operators. </span><span class="koboSpan" id="kobo.3335.2">In this recipe, you will learn how to write explicit constructors and conversion operators to avoid implicit conversions to and from a type. </span><span class="koboSpan" id="kobo.3335.3">The use of explicit constructors and conversion operators (called </span><em class="italic"><span class="koboSpan" id="kobo.3336.1">user-defined conversion functions</span></em><span class="koboSpan" id="kobo.3337.1">) enables the compiler to yield errors—which, in some cases, are coding errors—and allow developers to spot those errors quickly and fix them.</span></p>
<h2 class="heading-2" id="_idParaDest-60"><span class="koboSpan" id="kobo.3338.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3339.1">To declare explicit constructors and explicit conversion operators (regardless of whether they are functions or function templates), use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3340.1">explicit</span></code><span class="koboSpan" id="kobo.3341.1"> specifier in the declaration.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3342.1">The following example shows both an explicit constructor and an explicit converting operator:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3343.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3344.1">handle_t</span></span><span class="koboSpan" id="kobo.3345.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3346.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3347.1">handle_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3348.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3349.1">int</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3350.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3351.1"> h)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3352.1"> : handle(h) {</span></span><span class="koboSpan" id="kobo.3353.1">}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3354.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3355.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3356.1">bool</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3357.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3358.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3359.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3360.1">return</span></span><span class="koboSpan" id="kobo.3361.1"> handle != </span><span class="hljs-number"><span class="koboSpan" id="kobo.3362.1">0</span></span><span class="koboSpan" id="kobo.3363.1">; };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3364.1">private</span></span><span class="koboSpan" id="kobo.3365.1">:
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3366.1">int</span></span><span class="koboSpan" id="kobo.3367.1"> handle;
};
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-61"><span class="koboSpan" id="kobo.3368.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3369.1">To understand why explicit constructors are necessary and how they work, we will first look at converting constructors. </span><span class="koboSpan" id="kobo.3369.2">The following class, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3370.1">foo</span></code><span class="koboSpan" id="kobo.3371.1">, has three constructors: a default constructor (without parameters), a constructor that takes an </span><code class="inlineCode"><span class="koboSpan" id="kobo.3372.1">int</span></code><span class="koboSpan" id="kobo.3373.1">, and a constructor that takes two parameters, an </span><code class="inlineCode"><span class="koboSpan" id="kobo.3374.1">int</span></code><span class="koboSpan" id="kobo.3375.1"> and a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3376.1">double</span></code><span class="koboSpan" id="kobo.3377.1">. </span><span class="koboSpan" id="kobo.3377.2">They don’t do anything except print a message. </span><span class="koboSpan" id="kobo.3377.3">As of C++11, these are all considered converting constructors. </span><span class="koboSpan" id="kobo.3377.4">The class also has a conversion operator that converts a value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3378.1">foo</span></code><span class="koboSpan" id="kobo.3379.1"> type to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3380.1">bool</span></code><span class="koboSpan" id="kobo.3381.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3382.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3383.1">foo</span></span><span class="koboSpan" id="kobo.3384.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3385.1">foo</span></span><span class="koboSpan" id="kobo.3386.1">()
  { std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3387.1">"foo"</span></span><span class="koboSpan" id="kobo.3388.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3389.1">'\n'</span></span><span class="koboSpan" id="kobo.3390.1">; }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3391.1">foo</span></span><span class="koboSpan" id="kobo.3392.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.3393.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3394.1">const</span></span><span class="koboSpan" id="kobo.3395.1"> a)
  { std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3396.1">"foo(a)"</span></span><span class="koboSpan" id="kobo.3397.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3398.1">'\n'</span></span><span class="koboSpan" id="kobo.3399.1">; }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3400.1">foo</span></span><span class="koboSpan" id="kobo.3401.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.3402.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3403.1">const</span></span><span class="koboSpan" id="kobo.3404.1"> a, </span><span class="hljs-type"><span class="koboSpan" id="kobo.3405.1">double</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3406.1">const</span></span><span class="koboSpan" id="kobo.3407.1"> b)
  { std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3408.1">"foo(a, b)"</span></span><span class="koboSpan" id="kobo.3409.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3410.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3411.1">\n'</span></span><span class="koboSpan" id="kobo.3412.1">; }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3413.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3414.1">bool</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3415.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3416.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3417.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3418.1">return</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.3419.1">true</span></span><span class="koboSpan" id="kobo.3420.1">; }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3421.1">Based on this, the </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.3422.1">following definitions of objects are possible (note that the comments represent the console’s output):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3423.1">foo f1;              </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3424.1">// foo()</span></span><span class="koboSpan" id="kobo.3425.1">
foo f2 {};           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3426.1">// foo()</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.3427.1">foo </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3428.1">f3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3429.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3430.1">1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3431.1">)</span></span><span class="koboSpan" id="kobo.3432.1">;           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3433.1">// foo(a)</span></span><span class="koboSpan" id="kobo.3434.1">
foo f4 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3435.1">1</span></span><span class="koboSpan" id="kobo.3436.1">;          </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3437.1">// foo(a)</span></span><span class="koboSpan" id="kobo.3438.1">
foo f5 { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3439.1">1</span></span><span class="koboSpan" id="kobo.3440.1"> };        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3441.1">// foo(a)</span></span><span class="koboSpan" id="kobo.3442.1">
foo f6 = { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3443.1">1</span></span><span class="koboSpan" id="kobo.3444.1"> };      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3445.1">// foo(a)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.3446.1">foo </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3447.1">f7</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3448.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3449.1">1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3450.1">, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3451.1">2.0</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3452.1">)</span></span><span class="koboSpan" id="kobo.3453.1">;      </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3454.1">// foo(a, b)</span></span><span class="koboSpan" id="kobo.3455.1">
foo f8 { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3456.1">1</span></span><span class="koboSpan" id="kobo.3457.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3458.1">2.0</span></span><span class="koboSpan" id="kobo.3459.1"> };   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3460.1">// foo(a, b)</span></span><span class="koboSpan" id="kobo.3461.1">
foo f9 = { </span><span class="hljs-number"><span class="koboSpan" id="kobo.3462.1">1</span></span><span class="koboSpan" id="kobo.3463.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3464.1">2.0</span></span><span class="koboSpan" id="kobo.3465.1"> }; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3466.1">// foo(a, b)</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3467.1">The variables </span><code class="inlineCode"><span class="koboSpan" id="kobo.3468.1">f1</span></code><span class="koboSpan" id="kobo.3469.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3470.1">f2</span></code><span class="koboSpan" id="kobo.3471.1"> invoke the default constructor. </span><code class="inlineCode"><span class="koboSpan" id="kobo.3472.1">f3</span></code><span class="koboSpan" id="kobo.3473.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3474.1">f4</span></code><span class="koboSpan" id="kobo.3475.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3476.1">f5</span></code><span class="koboSpan" id="kobo.3477.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3478.1">f6</span></code><span class="koboSpan" id="kobo.3479.1"> invoke the constructor that takes an </span><code class="inlineCode"><span class="koboSpan" id="kobo.3480.1">int</span></code><span class="koboSpan" id="kobo.3481.1">. </span><span class="koboSpan" id="kobo.3481.2">Note that all the definitions of these objects are equivalent, even if they look different (</span><code class="inlineCode"><span class="koboSpan" id="kobo.3482.1">f3</span></code><span class="koboSpan" id="kobo.3483.1"> is initialized using the functional form, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3484.1">f4</span></code><span class="koboSpan" id="kobo.3485.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3486.1">f6</span></code><span class="koboSpan" id="kobo.3487.1"> are copy initialized, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3488.1">f5</span></code><span class="koboSpan" id="kobo.3489.1"> is directly initialized using brace-init-list). </span><span class="koboSpan" id="kobo.3489.2">Similarly, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3490.1">f7</span></code><span class="koboSpan" id="kobo.3491.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3492.1">f8</span></code><span class="koboSpan" id="kobo.3493.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3494.1">f9</span></code><span class="koboSpan" id="kobo.3495.1"> invoke the constructor with two parameters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3496.1">In this case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3497.1">f5</span></code><span class="koboSpan" id="kobo.3498.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3499.1">f6</span></code><span class="koboSpan" id="kobo.3500.1"> will </span><code class="inlineCode"><span class="koboSpan" id="kobo.3501.1">print foo(l)</span></code><span class="koboSpan" id="kobo.3502.1">, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.3503.1">f8</span></code><span class="koboSpan" id="kobo.3504.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3505.1">f9</span></code><span class="koboSpan" id="kobo.3506.1"> will generate compiler errors (although compilers may have options to ignore some warnings, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3507.1">-Wno-narrowing</span></code><span class="koboSpan" id="kobo.3508.1"> for GCC) because all the elements of the initializer list should be integers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3509.1">It may be important to note that if </span><code class="inlineCode"><span class="koboSpan" id="kobo.3510.1">foo</span></code><span class="koboSpan" id="kobo.3511.1"> defines a constructor that takes a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3512.1">std::initializer_list</span></code><span class="koboSpan" id="kobo.3513.1">, then all the initializations using </span><code class="inlineCode"><span class="koboSpan" id="kobo.3514.1">{}</span></code><span class="koboSpan" id="kobo.3515.1"> would resolve to that constructor:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in"><span class="koboSpan" id="kobo.3516.1">foo</span></span><span class="koboSpan" id="kobo.3517.1">(std::initializer_list&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3518.1">int</span></span><span class="koboSpan" id="kobo.3519.1">&gt; l)
{ std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3520.1">"foo(l)"</span></span><span class="koboSpan" id="kobo.3521.1"> &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3522.1">'\n'</span></span><span class="koboSpan" id="kobo.3523.1">; }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3524.1">These may all look right, but the implicit conversion constructors enable scenarios where the implicit conversion may not be what we wanted. </span><span class="koboSpan" id="kobo.3524.2">First, let’s look at some correct examples:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3525.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3526.1">bar</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3527.1">(foo </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3528.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3529.1"> f)</span></span><span class="koboSpan" id="kobo.3530.1">
{
}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3531.1">bar</span></span><span class="koboSpan" id="kobo.3532.1">({});             </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3533.1">// foo()</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.3534.1">bar</span></span><span class="koboSpan" id="kobo.3535.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.3536.1">1</span></span><span class="koboSpan" id="kobo.3537.1">);              </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3538.1">// foo(a)</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.3539.1">bar</span></span><span class="koboSpan" id="kobo.3540.1">({ </span><span class="hljs-number"><span class="koboSpan" id="kobo.3541.1">1</span></span><span class="koboSpan" id="kobo.3542.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.3543.1">2.0</span></span><span class="koboSpan" id="kobo.3544.1"> });     </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3545.1">// foo(a, b)</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3546.1">The conversion operator to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3547.1">bool</span></code><span class="koboSpan" id="kobo.3548.1"> from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3549.1">foo</span></code><span class="koboSpan" id="kobo.3550.1"> class also enables us to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.3551.1">foo</span></code><span class="koboSpan" id="kobo.3552.1"> objects where Boolean values are expected. </span><span class="koboSpan" id="kobo.3552.2">Here is an example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.3553.1">bool</span></span><span class="koboSpan" id="kobo.3554.1"> flag = f1;                </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3555.1">// OK, expect bool conversion</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3556.1">if</span></span><span class="koboSpan" id="kobo.3557.1">(f2) { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3558.1">/* do something */</span></span><span class="koboSpan" id="kobo.3559.1"> }  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3560.1">// OK, expect bool conversion</span></span><span class="koboSpan" id="kobo.3561.1">
std::cout &lt;&lt; f3 + f4 &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3562.1">'\n'</span></span><span class="koboSpan" id="kobo.3563.1">;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3564.1">// wrong, expect foo addition</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3565.1">if</span></span><span class="koboSpan" id="kobo.3566.1">(f5 == f6) { </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3567.1">/* do more */</span></span><span class="koboSpan" id="kobo.3568.1"> } </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3569.1">// wrong, expect comparing foos</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3570.1">The first two are examples where </span><code class="inlineCode"><span class="koboSpan" id="kobo.3571.1">foo</span></code><span class="koboSpan" id="kobo.3572.1"> is expected to be used as a Boolean. </span><span class="koboSpan" id="kobo.3572.2">However, the last two, one with addition and one with a test for equality, are probably incorrect, as we most likely expect to add </span><code class="inlineCode"><span class="koboSpan" id="kobo.3573.1">foo</span></code><span class="koboSpan" id="kobo.3574.1"> objects and test </span><code class="inlineCode"><span class="koboSpan" id="kobo.3575.1">foo</span></code><span class="koboSpan" id="kobo.3576.1"> objects for equality, not the Booleans they implicitly convert to.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3577.1">Perhaps a more realistic example to understand where problems could arise would be to consider a string buffer implementation. </span><span class="koboSpan" id="kobo.3577.2">This would be a class that contains an internal buffer of characters.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3578.1">This class provides</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.3579.1"> several conversion constructors: a default constructor, a constructor that takes a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3580.1">size_t</span></code><span class="koboSpan" id="kobo.3581.1"> parameter representing the size of the buffer to pre-allocate, and a constructor that takes a pointer to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3582.1">char</span></code><span class="koboSpan" id="kobo.3583.1">, which should be used to allocate and initialize the internal buffer. </span><span class="koboSpan" id="kobo.3583.2">Succinctly, the implementation of the string buffer that we use for this exemplification looks like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3584.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3585.1">string_buffer</span></span><span class="koboSpan" id="kobo.3586.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3587.1">public</span></span><span class="koboSpan" id="kobo.3588.1">:
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3589.1">string_buffer</span></span><span class="koboSpan" id="kobo.3590.1">() {}
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3591.1">string_buffer</span></span><span class="koboSpan" id="kobo.3592.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.3593.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3594.1">const</span></span><span class="koboSpan" id="kobo.3595.1"> size) { data.resize(size); }
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3596.1">string_buffer</span></span><span class="koboSpan" id="kobo.3597.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.3598.1">char</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3599.1">const</span></span><span class="koboSpan" id="kobo.3600.1"> * </span><span class="hljs-type"><span class="koboSpan" id="kobo.3601.1">const</span></span><span class="koboSpan" id="kobo.3602.1"> ptr) : data(ptr) {}
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3603.1">size_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3604.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3605.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3606.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3607.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3608.1">return</span></span><span class="koboSpan" id="kobo.3609.1"> data.size(); }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3610.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3611.1">bool</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3612.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3613.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3614.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3615.1">return</span></span><span class="koboSpan" id="kobo.3616.1"> !data.empty(); }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3617.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3618.1">char</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3619.1"> const * </span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3620.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3621.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3622.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3623.1">return</span></span><span class="koboSpan" id="kobo.3624.1"> data.c_str(); }
private:
   std::string data;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3625.1">Based on this definition, we could construct the following objects:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3626.1">std::shared_ptr&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3627.1">char</span></span><span class="koboSpan" id="kobo.3628.1">&gt; str;
string_buffer b1;            </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3629.1">// calls string_buffer()</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.3630.1">string_buffer </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3631.1">b2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3632.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.3633.1">20</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3634.1">)</span></span><span class="koboSpan" id="kobo.3635.1">;        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3636.1">// calls string_buffer(size_t const)</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.3637.1">string_buffer </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3638.1">b3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3639.1">(str.get())</span></span><span class="koboSpan" id="kobo.3640.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3641.1">// calls string_buffer(char const*)</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3642.1">The object </span><code class="inlineCode"><span class="koboSpan" id="kobo.3643.1">b1</span></code><span class="koboSpan" id="kobo.3644.1"> is</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.3645.1"> created using the default constructor and, thus, has an empty buffer; </span><code class="inlineCode"><span class="koboSpan" id="kobo.3646.1">b2</span></code><span class="koboSpan" id="kobo.3647.1"> is initialized using the constructor with a single parameter, where the value of the parameter represents the size in terms of the characters of the internal buffer; and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3648.1">b3</span></code><span class="koboSpan" id="kobo.3649.1"> is initialized with an existing buffer, which is used to define the size of the internal buffer and copy its value into the internal buffer. </span><span class="koboSpan" id="kobo.3649.2">However, the same definition also enables the following object definitions:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3650.1">enum</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3651.1">ItemSizes</span></span><span class="koboSpan" id="kobo.3652.1"> {DefaultHeight, Large, MaxSize};
string_buffer b4 = </span><span class="hljs-string"><span class="koboSpan" id="kobo.3653.1">'a'</span></span><span class="koboSpan" id="kobo.3654.1">;
string_buffer b5 = MaxSize;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3655.1">In this case, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3656.1">b4</span></code><span class="koboSpan" id="kobo.3657.1"> is initialized with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3658.1">char</span></code><span class="koboSpan" id="kobo.3659.1">. </span><span class="koboSpan" id="kobo.3659.2">Since an implicit conversion to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3660.1">size_t</span></code><span class="koboSpan" id="kobo.3661.1"> exists, the constructor with a single parameter will be called. </span><span class="koboSpan" id="kobo.3661.2">The intention here is not necessarily clear; perhaps it should have been </span><code class="inlineCode"><span class="koboSpan" id="kobo.3662.1">"a"</span></code><span class="koboSpan" id="kobo.3663.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3664.1">'a'</span></code><span class="koboSpan" id="kobo.3665.1">, in which case the third constructor would have been called.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3666.1">However, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3667.1">b5</span></code><span class="koboSpan" id="kobo.3668.1"> is most likely an error, because </span><code class="inlineCode"><span class="koboSpan" id="kobo.3669.1">MaxSize</span></code><span class="koboSpan" id="kobo.3670.1"> is an enumerator representing an </span><code class="inlineCode"><span class="koboSpan" id="kobo.3671.1">ItemSizes</span></code><span class="koboSpan" id="kobo.3672.1"> and should have nothing to do with a string buffer size. </span><span class="koboSpan" id="kobo.3672.2">These erroneous situations are not flagged by the compiler in any way. </span><span class="koboSpan" id="kobo.3672.3">The implicit conversion of unscoped enums to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3673.1">int</span></code><span class="koboSpan" id="kobo.3674.1"> is a good argument for preferring to use scoped enums (declared with enum class), which do not have this implicit conversion. </span><span class="koboSpan" id="kobo.3674.2">If </span><code class="inlineCode"><span class="koboSpan" id="kobo.3675.1">ItemSizes</span></code><span class="koboSpan" id="kobo.3676.1"> was a scoped enum, the situation described here would not appear.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3677.1">When using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3678.1">explicit</span></code><span class="koboSpan" id="kobo.3679.1"> specifier in the declaration of a constructor, that constructor becomes an explicit constructor and no longer allows implicit constructions of objects of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3680.1">class</span></code><span class="koboSpan" id="kobo.3681.1"> type. </span><span class="koboSpan" id="kobo.3681.2">To exemplify this, we will slightly change the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3682.1">string_buffer</span></code><span class="koboSpan" id="kobo.3683.1"> class to declare all constructors as </span><code class="inlineCode"><span class="koboSpan" id="kobo.3684.1">explicit</span></code><span class="koboSpan" id="kobo.3685.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3686.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3687.1">string_buffer</span></span><span class="koboSpan" id="kobo.3688.1">
{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3689.1">public</span></span><span class="koboSpan" id="kobo.3690.1">:
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3691.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3692.1">string_buffer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3693.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3694.1">{}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3695.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3696.1">string_buffer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3697.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3698.1">size_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3699.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3700.1"> size)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3701.1">{ data.resize(size); }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3702.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3703.1">string_buffer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3704.1">(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3705.1">char</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3706.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3707.1"> * </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.3708.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3709.1"> ptr)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3710.1"> :data(ptr) </span></span><span class="koboSpan" id="kobo.3711.1">{}
  size_t size() const { return data.size(); }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3712.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3713.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3714.1">bool</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3715.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3716.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3717.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3718.1">return</span></span><span class="koboSpan" id="kobo.3719.1"> !data.empty(); }
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3720.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3721.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3722.1">char</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3723.1">const</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3724.1"> * </span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3725.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3726.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3727.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3728.1">return</span></span><span class="koboSpan" id="kobo.3729.1"> data.c_str(); }
private:
   std::string data;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3730.1">The change here is</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.3731.1"> minimal, but the definitions of </span><code class="inlineCode"><span class="koboSpan" id="kobo.3732.1">b4</span></code><span class="koboSpan" id="kobo.3733.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3734.1">b5</span></code><span class="koboSpan" id="kobo.3735.1"> in the earlier example no longer work and are incorrect. </span><span class="koboSpan" id="kobo.3735.2">This is because the implicit conversions from </span><code class="inlineCode"><span class="koboSpan" id="kobo.3736.1">char</span></code><span class="koboSpan" id="kobo.3737.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3738.1">int</span></code><span class="koboSpan" id="kobo.3739.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3740.1">size_t</span></code><span class="koboSpan" id="kobo.3741.1"> are no longer available during overload resolution to figure out what constructor should be called. </span><span class="koboSpan" id="kobo.3741.2">The result is compiler errors for both </span><code class="inlineCode"><span class="koboSpan" id="kobo.3742.1">b4</span></code><span class="koboSpan" id="kobo.3743.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3744.1">b5</span></code><span class="koboSpan" id="kobo.3745.1">. </span><span class="koboSpan" id="kobo.3745.2">Note that </span><code class="inlineCode"><span class="koboSpan" id="kobo.3746.1">b1</span></code><span class="koboSpan" id="kobo.3747.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3748.1">b2</span></code><span class="koboSpan" id="kobo.3749.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3750.1">b3</span></code><span class="koboSpan" id="kobo.3751.1"> are still valid definitions, even if the constructors are explicit.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3752.1">The only way to fix the problem, in this case, is to provide an explicit cast from </span><code class="inlineCode"><span class="koboSpan" id="kobo.3753.1">char</span></code><span class="koboSpan" id="kobo.3754.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.3755.1">int</span></code><span class="koboSpan" id="kobo.3756.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3757.1">string_buffer</span></code><span class="koboSpan" id="kobo.3758.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3759.1">string_buffer b4 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3760.1">string_buffer</span></span><span class="koboSpan" id="kobo.3761.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3762.1">'a'</span></span><span class="koboSpan" id="kobo.3763.1">);
string_buffer b5 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3764.1">static_cast</span></span><span class="koboSpan" id="kobo.3765.1">&lt;string_buffer&gt;(MaxSize);
string_buffer b6 = string_buffer{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3766.1">"a"</span></span><span class="koboSpan" id="kobo.3767.1"> };
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3768.1">With explicit constructors, the compiler is able to immediately flag erroneous situations and developers can react accordingly, either fixing the initialization with a correct value or providing an explicit cast.</span></p>
<div class="packt_tip">
<p class="normal"><span class="koboSpan" id="kobo.3769.1">This is only the case when initialization is done with copy initialization and not when using functional or universal initialization.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.3770.1">The following definitions are still possible (but wrong) with explicit constructors:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3771.1">string_buffer b7{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.3772.1">'a'</span></span><span class="koboSpan" id="kobo.3773.1"> };
</span><span class="hljs-function"><span class="koboSpan" id="kobo.3774.1">string_buffer </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.3775.1">b8</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3776.1">(</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3777.1">'a'</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3778.1">)</span></span><span class="koboSpan" id="kobo.3779.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3780.1">Similar to </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.3781.1">constructors, conversion operators can be declared explicit (as shown earlier). </span><span class="koboSpan" id="kobo.3781.2">In this case, the implicit conversions from the object type to the type specified by the conversion operator are no longer possible and require an explicit cast. </span><span class="koboSpan" id="kobo.3781.3">Considering </span><code class="inlineCode"><span class="koboSpan" id="kobo.3782.1">b1</span></code><span class="koboSpan" id="kobo.3783.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3784.1">b2</span></code><span class="koboSpan" id="kobo.3785.1">, which are the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3786.1">string_buffer</span></code><span class="koboSpan" id="kobo.3787.1"> objects we defined earlier, the following is no longer possible with an explicit </span><code class="inlineCode"><span class="koboSpan" id="kobo.3788.1">operator bool</span></code><span class="koboSpan" id="kobo.3789.1"> conversion:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3790.1">std::cout &lt;&lt; b4 + b5 &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3791.1">'\n'</span></span><span class="koboSpan" id="kobo.3792.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3793.1">// error</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3794.1">if</span></span><span class="koboSpan" id="kobo.3795.1">(b4 == b5) {}               </span><span class="hljs-comment"><span class="koboSpan" id="kobo.3796.1">// error</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3797.1">Instead, they require explicit conversion to </span><code class="inlineCode"><span class="koboSpan" id="kobo.3798.1">bool</span></code><span class="koboSpan" id="kobo.3799.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.3800.1">std::cout &lt;&lt; </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3801.1">static_cast</span></span><span class="koboSpan" id="kobo.3802.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3803.1">bool</span></span><span class="koboSpan" id="kobo.3804.1">&gt;(b4) + </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3805.1">static_cast</span></span><span class="koboSpan" id="kobo.3806.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3807.1">bool</span></span><span class="koboSpan" id="kobo.3808.1">&gt;(b5);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3809.1">if</span></span><span class="koboSpan" id="kobo.3810.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3811.1">static_cast</span></span><span class="koboSpan" id="kobo.3812.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3813.1">bool</span></span><span class="koboSpan" id="kobo.3814.1">&gt;(b4) == </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3815.1">static_cast</span></span><span class="koboSpan" id="kobo.3816.1">&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3817.1">bool</span></span><span class="koboSpan" id="kobo.3818.1">&gt;(b5)) {}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3819.1">The addition of two </span><code class="inlineCode"><span class="koboSpan" id="kobo.3820.1">bool</span></code><span class="koboSpan" id="kobo.3821.1"> values does not make much sense. </span><span class="koboSpan" id="kobo.3821.2">The preceding example is intended only to show how an explicit cast is required in order to make the statement compile. </span><span class="koboSpan" id="kobo.3821.3">The error issued by the compiler when there is no explicit static cast should help you figure out that the expression itself is wrong and something else was probably intended.</span></p>
<h2 class="heading-2" id="_idParaDest-62"><span class="koboSpan" id="kobo.3822.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3823.1">Understanding uniform initialization</span></em><span class="koboSpan" id="kobo.3824.1">, to see how brace-initialization works</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-63"><span class="koboSpan" id="kobo.3825.1">Using unnamed namespaces instead of static globals</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3826.1">The larger a program, the </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.3827.1">greater the chance that you could run into name collisions when your program is linked to multiple translation units. </span><span class="koboSpan" id="kobo.3827.2">Functions or variables that are declared in a source file, intended to be local to the translation unit, may collide with other similar functions or variables declared in another translation unit.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3828.1">That is because all the symbols that are not declared static have external linkage, and their names must be unique throughout the program. </span><span class="koboSpan" id="kobo.3828.2">The typical C solution for this problem is to declare those symbols as static, changing their linkage from external to internal and, therefore, making them local to a translation unit. </span><span class="koboSpan" id="kobo.3828.3">An alternative is to prefix the names with the name of the module or library they belong to. </span><span class="koboSpan" id="kobo.3828.4">In this recipe, we will look at the C++ solution for this problem.</span></p>
<h2 class="heading-2" id="_idParaDest-64"><span class="koboSpan" id="kobo.3829.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3830.1">In this recipe, we will discuss concepts such as global functions and static functions, as well as variables, namespaces, and translation units. </span><span class="koboSpan" id="kobo.3830.2">We expect that you have a basic understanding of these concepts. </span><span class="koboSpan" id="kobo.3830.3">Apart from these, it is required that you understand the difference between internal and external linkage; this is key for this recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-65"><span class="koboSpan" id="kobo.3831.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3832.1">When you are in a</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.3833.1"> situation where you need to declare global symbols as static to avoid linkage problems, you should prefer to use unnamed namespaces:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.3834.1">Declare a namespace without a name in your source file.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.3835.1">Put the definition of the global function or variable in the unnamed namespace without making it </span><code class="inlineCode"><span class="koboSpan" id="kobo.3836.1">static</span></code><span class="koboSpan" id="kobo.3837.1">.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.3838.1">The following example shows two functions called </span><code class="inlineCode"><span class="koboSpan" id="kobo.3839.1">print()</span></code><span class="koboSpan" id="kobo.3840.1"> in two different translation units; each of them is defined in an unnamed namespace:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.3841.1">// file1.cpp</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3842.1">namespace</span></span><span class="koboSpan" id="kobo.3843.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3844.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3845.1">print</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3846.1">(std::string const &amp; message)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.3847.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3848.1">"[file1] "</span></span><span class="koboSpan" id="kobo.3849.1"> &lt;&lt; message &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3850.1">'\n'</span></span><span class="koboSpan" id="kobo.3851.1">;
  }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3852.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3853.1">file1_run</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3854.1">()</span></span><span class="koboSpan" id="kobo.3855.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3856.1">print</span></span><span class="koboSpan" id="kobo.3857.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3858.1">"run"</span></span><span class="koboSpan" id="kobo.3859.1">);
}
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.3860.1">// file2.cpp</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3861.1">namespace</span></span><span class="koboSpan" id="kobo.3862.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3863.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3864.1">print</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3865.1">(std::string const &amp; message)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.3866.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3867.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.3868.1">[file2] "</span></span><span class="koboSpan" id="kobo.3869.1"> &lt;&lt; message &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3870.1">'\n'</span></span><span class="koboSpan" id="kobo.3871.1">;
  }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3872.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3873.1">file2_run</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3874.1">()</span></span><span class="koboSpan" id="kobo.3875.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3876.1">print</span></span><span class="koboSpan" id="kobo.3877.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3878.1">"run"</span></span><span class="koboSpan" id="kobo.3879.1">);
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-66"><span class="koboSpan" id="kobo.3880.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3881.1">When a function is </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.3882.1">declared in a translation unit, it has an external linkage. </span><span class="koboSpan" id="kobo.3882.2">This means two functions with the same name from two different translation units would generate a linkage error because it is not possible to have two symbols with the same name. </span><span class="koboSpan" id="kobo.3882.3">The way this problem is solved in C, and sometimesin C++ also, is to declare the function or variable as static and change its linkage from external to internal. </span><span class="koboSpan" id="kobo.3882.4">In this case, its name is no longer exported outside the translation unit, and the linkage problem is avoided.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3883.1">The proper solution in C++ is to use unnamed namespaces. </span><span class="koboSpan" id="kobo.3883.2">When you define a namespace like the ones shown previously, the compiler transforms it into the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.3884.1">// file1.cpp</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3885.1">namespace</span></span><span class="koboSpan" id="kobo.3886.1"> _unique_name_ {}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3887.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3888.1">namespace</span></span><span class="koboSpan" id="kobo.3889.1"> _unique_name_;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3890.1">namespace</span></span><span class="koboSpan" id="kobo.3891.1"> _unique_name_
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3892.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3893.1">print</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3894.1">(std::string message)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.3895.1">{
    std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3896.1">"[file1] "</span></span><span class="koboSpan" id="kobo.3897.1"> &lt;&lt; message &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.3898.1">'\n'</span></span><span class="koboSpan" id="kobo.3899.1">;
  }
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3900.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3901.1">file1_run</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3902.1">()</span></span><span class="koboSpan" id="kobo.3903.1">
{
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.3904.1">print</span></span><span class="koboSpan" id="kobo.3905.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.3906.1">"run"</span></span><span class="koboSpan" id="kobo.3907.1">);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3908.1">First of all, it declares a namespace with a unique name (what the name is and how it generates that name is a compiler implementation detail and should not be a concern). </span><span class="koboSpan" id="kobo.3908.2">At this point, the namespace is empty, and the purpose of this line is to basically establish the namespace. </span><span class="koboSpan" id="kobo.3908.3">Second, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.3909.1">using</span></code><span class="koboSpan" id="kobo.3910.1"> directive brings everything from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3911.1">_unique_name_</span></code><span class="koboSpan" id="kobo.3912.1"> namespace into the current namespace. </span><span class="koboSpan" id="kobo.3912.2">Third, the namespace, with the compiler-generated name, is defined as it was in the original source code (when it had no name).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3913.1">By defining the translation unit local </span><code class="inlineCode"><span class="koboSpan" id="kobo.3914.1">print()</span></code><span class="koboSpan" id="kobo.3915.1"> functions in an unnamed namespace, they have local visibility only, yet their external linkage no longer produces linkage errors, since they now have external unique names.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.3916.1">Unnamed namespaces also work in a perhaps more obscure situation involving templates. </span><span class="koboSpan" id="kobo.3916.2">Prior to C++11, template non-type arguments could not be names with internal linkage, so using static variables was not possible. </span><span class="koboSpan" id="kobo.3916.3">Conversely, symbols in an unnamed namespace have external linkage and could be used as template arguments. </span><span class="koboSpan" id="kobo.3916.4">Although this linkage restriction for template non-type arguments was lifted in C++11, it is still present in </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.3917.1">the latest version of the VC++ compiler. </span><span class="koboSpan" id="kobo.3917.2">This problem is shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3918.1">template</span></span><span class="koboSpan" id="kobo.3919.1"> &lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.3920.1">int</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3921.1">const</span></span><span class="koboSpan" id="kobo.3922.1">&amp; Size&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3923.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.3924.1">test</span></span><span class="koboSpan" id="kobo.3925.1"> {};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.3926.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.3927.1">int</span></span><span class="koboSpan" id="kobo.3928.1"> Size1 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3929.1">10</span></span><span class="koboSpan" id="kobo.3930.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3931.1">namespace</span></span><span class="koboSpan" id="kobo.3932.1">
{
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.3933.1">int</span></span><span class="koboSpan" id="kobo.3934.1"> Size2 = </span><span class="hljs-number"><span class="koboSpan" id="kobo.3935.1">10</span></span><span class="koboSpan" id="kobo.3936.1">;
}
test&lt;Size1&gt; t1;
test&lt;Size2&gt; t2;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.3937.1">In this snippet, the declaration of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3938.1">t1</span></code><span class="koboSpan" id="kobo.3939.1"> variable produces a compiler error because the non-type argument expression, </span><code class="inlineCode"><span class="koboSpan" id="kobo.3940.1">Size1</span></code><span class="koboSpan" id="kobo.3941.1">, has internal linkage. </span><span class="koboSpan" id="kobo.3941.2">Conversely, the declaration of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3942.1">t2</span></code><span class="koboSpan" id="kobo.3943.1"> variable is correct because </span><code class="inlineCode"><span class="koboSpan" id="kobo.3944.1">Size2</span></code><span class="koboSpan" id="kobo.3945.1"> has an external linkage. </span><span class="koboSpan" id="kobo.3945.2">(Note that compiling this snippet with Clang and GCC does not produce an error.)</span></p>
<h2 class="heading-2" id="_idParaDest-67"><span class="koboSpan" id="kobo.3946.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.3947.1">Using inline namespaces for symbol versioning</span></em><span class="koboSpan" id="kobo.3948.1">, to learn how to version your source code using inline namespaces and conditional compilation</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-68"><span class="koboSpan" id="kobo.3949.1">Using inline namespaces for symbol versioning</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3950.1">The C++11 standard has introduced a</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.3951.1"> new type of namespace called </span><em class="italic"><span class="koboSpan" id="kobo.3952.1">inline namespaces</span></em><span class="koboSpan" id="kobo.3953.1">, which are basically a mechanism that makes declarations from a nested namespace look and act like they were part of the surrounding namespace. </span><span class="koboSpan" id="kobo.3953.2">Inline namespaces are declared using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.3954.1">inline</span></code><span class="koboSpan" id="kobo.3955.1"> keyword in the namespace declaration (unnamed namespaces can also be inlined). </span><span class="koboSpan" id="kobo.3955.2">This is a helpful feature for library versioning, and in this recipe, we will learn how inline namespaces can be used for versioning symbols. </span><span class="koboSpan" id="kobo.3955.3">From this recipe, you will learn how to version your source code using inline namespaces and conditional compilation.</span></p>
<h2 class="heading-2" id="_idParaDest-69"><span class="koboSpan" id="kobo.3956.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3957.1">In this recipe, we will discuss namespaces and nested namespaces, templates and template specializations, and conditional compilation using preprocessor macros. </span><span class="koboSpan" id="kobo.3957.2">Familiarity with these concepts is required in order to proceed with this recipe.</span></p>
<h2 class="heading-2" id="_idParaDest-70"><span class="koboSpan" id="kobo.3958.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.3959.1">To provide </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.3960.1">multiple versions of a library and let the</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.3961.1"> user decide what version to use, do the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.3962.1">Define the content of the library inside a namespace.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3963.1">Define each version of the library or parts of it inside an inner inline namespace.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.3964.1">Use preprocessor macros and </span><code class="inlineCode"><span class="koboSpan" id="kobo.3965.1">#if</span></code><span class="koboSpan" id="kobo.3966.1"> directives to enable a particular version of the library.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.3967.1">The following example shows a library that has two versions that clients can use:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.3968.1">namespace</span></span><span class="koboSpan" id="kobo.3969.1"> modernlib
{
  </span><span class="hljs-meta"><span class="koboSpan" id="kobo.3970.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3971.1">ifndef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.3972.1"> LIB_VERSION_2</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3973.1">inline</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3974.1">namespace</span></span><span class="koboSpan" id="kobo.3975.1"> version_1
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3976.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3977.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3978.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3979.1"> T&gt;</span></span>
<span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3980.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.3981.1">test</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.3982.1">(T value)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.3983.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3984.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.3985.1">1</span></span><span class="koboSpan" id="kobo.3986.1">; }
  }
  </span><span class="hljs-meta"><span class="koboSpan" id="kobo.3987.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3988.1">endif</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.3989.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3990.1">ifdef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.3991.1"> LIB_VERSION_2</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.3992.1">inline</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.3993.1">namespace</span></span><span class="koboSpan" id="kobo.3994.1"> version_2
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3995.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3996.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.3997.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.3998.1"> T&gt;</span></span>
<span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.3999.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4000.1">test</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4001.1">(T value)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4002.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4003.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.4004.1">2</span></span><span class="koboSpan" id="kobo.4005.1">; }
  }
  </span><span class="hljs-meta"><span class="koboSpan" id="kobo.4006.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4007.1">endif</span></span><span class="koboSpan" id="kobo.4008.1">
}
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-71"><span class="koboSpan" id="kobo.4009.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4010.1">A member of </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.4011.1">an inline namespace is </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.4012.1">treated as if it were a member of the surrounding namespace. </span><span class="koboSpan" id="kobo.4012.2">Such a member can be partially specialized, explicitly instantiated, or explicitly specialized. </span><span class="koboSpan" id="kobo.4012.3">This is a transitive property, which means that if a namespace, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4013.1">A</span></code><span class="koboSpan" id="kobo.4014.1">, contains an inline namespace, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4015.1">B</span></code><span class="koboSpan" id="kobo.4016.1">, that contains an inline namespace, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4017.1">C</span></code><span class="koboSpan" id="kobo.4018.1">, then the members of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4019.1">C</span></code><span class="koboSpan" id="kobo.4020.1"> appear as they were members of both </span><code class="inlineCode"><span class="koboSpan" id="kobo.4021.1">B</span></code><span class="koboSpan" id="kobo.4022.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4023.1">A</span></code><span class="koboSpan" id="kobo.4024.1"> and the members of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4025.1">B</span></code><span class="koboSpan" id="kobo.4026.1"> appear as they were members of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4027.1">A</span></code><span class="koboSpan" id="kobo.4028.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4029.1">To better understand why inline namespaces are helpful, let’s consider the case of developing a library that evolves over time from a first version to a second version (and further on). </span><span class="koboSpan" id="kobo.4029.2">This library defines all its types and functions under a namespace called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4030.1">modernlib</span></code><span class="koboSpan" id="kobo.4031.1">. </span><span class="koboSpan" id="kobo.4031.2">In the first version, this library could look like this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4032.1">namespace</span></span><span class="koboSpan" id="kobo.4033.1"> modernlib
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4034.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4035.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4036.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4037.1"> T&gt;</span></span>
<span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4038.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4039.1">test</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4040.1">(T value)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4041.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4042.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.4043.1">1</span></span><span class="koboSpan" id="kobo.4044.1">; }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4045.1">A client of the library can make the following call and get back the value </span><code class="inlineCode"><span class="koboSpan" id="kobo.4046.1">1</span></code><span class="koboSpan" id="kobo.4047.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4048.1">auto</span></span><span class="koboSpan" id="kobo.4049.1"> x = modernlib::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4050.1">test</span></span><span class="koboSpan" id="kobo.4051.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4052.1">42</span></span><span class="koboSpan" id="kobo.4053.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4054.1">However, the client might decide to specialize the template function </span><code class="inlineCode"><span class="koboSpan" id="kobo.4055.1">test()</span></code><span class="koboSpan" id="kobo.4056.1"> as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4057.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4058.1">foo</span></span><span class="koboSpan" id="kobo.4059.1"> { </span><span class="hljs-type"><span class="koboSpan" id="kobo.4060.1">int</span></span><span class="koboSpan" id="kobo.4061.1"> a; };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4062.1">namespace</span></span><span class="koboSpan" id="kobo.4063.1"> modernlib
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4064.1">template</span></span><span class="koboSpan" id="kobo.4065.1">&lt;&gt;
  </span><span class="hljs-type"><span class="koboSpan" id="kobo.4066.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4067.1">test</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4068.1">(foo value)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4069.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4070.1">return</span></span><span class="koboSpan" id="kobo.4071.1"> value.a; }
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4072.1">auto</span></span><span class="koboSpan" id="kobo.4073.1"> y = modernlib::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4074.1">test</span></span><span class="koboSpan" id="kobo.4075.1">(foo{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4076.1">42</span></span><span class="koboSpan" id="kobo.4077.1"> });
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4078.1">In this case, the value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4079.1">y</span></code><span class="koboSpan" id="kobo.4080.1"> is no longer </span><code class="inlineCode"><span class="koboSpan" id="kobo.4081.1">1</span></code><span class="koboSpan" id="kobo.4082.1"> but </span><code class="inlineCode"><span class="koboSpan" id="kobo.4083.1">42</span></code><span class="koboSpan" id="kobo.4084.1"> instead because the user-specialized function gets called.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4085.1">Everything is </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.4086.1">working correctly so far, but as a library </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.4087.1">developer, you decide to create a second version of the library, yet still ship both the first and the second version and let the user control what to use with a macro. </span><span class="koboSpan" id="kobo.4087.2">In this second version, you provide a new implementation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4088.1">test()</span></code><span class="koboSpan" id="kobo.4089.1"> function that no longer returns </span><code class="inlineCode"><span class="koboSpan" id="kobo.4090.1">1</span></code><span class="koboSpan" id="kobo.4091.1"> but </span><code class="inlineCode"><span class="koboSpan" id="kobo.4092.1">2</span></code><span class="koboSpan" id="kobo.4093.1"> instead. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.4094.1">To be able to provide both the first and second implementations, you put them in nested namespaces called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4095.1">version_1</span></code><span class="koboSpan" id="kobo.4096.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4097.1">version_2</span></code><span class="koboSpan" id="kobo.4098.1"> and conditionally compile the library using preprocessor macros:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4099.1">namespace</span></span><span class="koboSpan" id="kobo.4100.1"> modernlib
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4101.1">namespace</span></span><span class="koboSpan" id="kobo.4102.1"> version_1
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4103.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4104.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4105.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4106.1"> T&gt;</span></span>
<span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4107.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4108.1">test</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4109.1">(T value)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4110.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4111.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.4112.1">1</span></span><span class="koboSpan" id="kobo.4113.1">; }
  }
  </span><span class="hljs-meta"><span class="koboSpan" id="kobo.4114.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4115.1">ifndef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.4116.1"> LIB_VERSION_2</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4117.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4118.1">namespace</span></span><span class="koboSpan" id="kobo.4119.1"> version_1;
  </span><span class="hljs-meta"><span class="koboSpan" id="kobo.4120.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4121.1">endif</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4122.1">namespace</span></span><span class="koboSpan" id="kobo.4123.1"> version_2
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4124.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4125.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4126.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4127.1"> T&gt;</span></span>
<span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4128.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4129.1">test</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4130.1">(T value)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4131.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4132.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.4133.1">2</span></span><span class="koboSpan" id="kobo.4134.1">; }
  }
  </span><span class="hljs-meta"><span class="koboSpan" id="kobo.4135.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4136.1">ifdef</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.4137.1"> LIB_VERSION_2</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4138.1">using</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.4139.1">namespace</span></span><span class="koboSpan" id="kobo.4140.1"> version_2;
  </span><span class="hljs-meta"><span class="koboSpan" id="kobo.4141.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4142.1">endif</span></span><span class="koboSpan" id="kobo.4143.1">
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4144.1">Suddenly, the client code breaks, regardless of whether it uses the first or second version of the library. </span><span class="koboSpan" id="kobo.4144.2">This is because the test function is now inside a nested namespace, and the specialization for </span><code class="inlineCode"><span class="koboSpan" id="kobo.4145.1">foo</span></code><span class="koboSpan" id="kobo.4146.1"> is done in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4147.1">modernlib</span></code><span class="koboSpan" id="kobo.4148.1"> namespace, when it should actually be done in </span><code class="inlineCode"><span class="koboSpan" id="kobo.4149.1">modernlib::version_1</span></code><span class="koboSpan" id="kobo.4150.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4151.1">modernlib::version_2</span></code><span class="koboSpan" id="kobo.4152.1">. </span><span class="koboSpan" id="kobo.4152.2">This is because the specialization of a template is required to be done in the same namespace where the template was declared.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4153.1">In this case, the </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.4154.1">client needs to change the code, like</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.4155.1"> this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.4156.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4157.1">define</span></span><span class="hljs-meta"><span class="koboSpan" id="kobo.4158.1"> LIB_VERSION_2</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.4159.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4160.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.4161.1">"modernlib.h"</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4162.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4163.1">foo</span></span><span class="koboSpan" id="kobo.4164.1"> { </span><span class="hljs-type"><span class="koboSpan" id="kobo.4165.1">int</span></span><span class="koboSpan" id="kobo.4166.1"> a; };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4167.1">namespace</span></span><span class="koboSpan" id="kobo.4168.1"> modernlib
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4169.1">namespace</span></span><span class="koboSpan" id="kobo.4170.1"> version_2
  {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4171.1">template</span></span><span class="koboSpan" id="kobo.4172.1">&lt;&gt;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.4173.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4174.1">test</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4175.1">(foo value)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.4176.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4177.1">return</span></span><span class="koboSpan" id="kobo.4178.1"> value.a; }
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4179.1">This is a problem because the library leaks implementation details, and the client needs to be aware of those in order to do template specialization. </span><span class="koboSpan" id="kobo.4179.2">These internal details are hidden with inline namespaces in the manner shown in the </span><em class="italic"><span class="koboSpan" id="kobo.4180.1">How to do it...</span></em><span class="koboSpan" id="kobo.4181.1"> section of this recipe. </span><span class="koboSpan" id="kobo.4181.2">With that definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4182.1">modernlib</span></code><span class="koboSpan" id="kobo.4183.1"> library, the client code with the specialization of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4184.1">test()</span></code><span class="koboSpan" id="kobo.4185.1"> function in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4186.1">modernlib</span></code><span class="koboSpan" id="kobo.4187.1"> namespace is no longer broken, because either </span><code class="inlineCode"><span class="koboSpan" id="kobo.4188.1">version_1::test()</span></code><span class="koboSpan" id="kobo.4189.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4190.1">version_2::test()</span></code><span class="koboSpan" id="kobo.4191.1"> (depending on what version the client actually uses) acts as if it is part of the enclosing </span><code class="inlineCode"><span class="koboSpan" id="kobo.4192.1">modernlib</span></code><span class="koboSpan" id="kobo.4193.1"> namespace when template specialization is done. </span><span class="koboSpan" id="kobo.4193.2">The details of the implementation are now hidden to the client, who only sees the surrounding namespace, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4194.1">modernlib</span></code><span class="koboSpan" id="kobo.4195.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4196.1">However, you should</span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.4197.1"> keep in mind that the</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.4198.1"> namespace </span><code class="inlineCode"><span class="koboSpan" id="kobo.4199.1">std</span></code><span class="koboSpan" id="kobo.4200.1"> is reserved for the standard and should never be inlined. </span><span class="koboSpan" id="kobo.4200.2">Also, a namespace should not be defined inline if it was not inline in its first definition.</span></p>
<h2 class="heading-2" id="_idParaDest-72"><span class="koboSpan" id="kobo.4201.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4202.1">Using unnamed namespaces instead of static globals</span></em><span class="koboSpan" id="kobo.4203.1">, to explore anonymous namespaces and learn how they help</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.4204.1">Chapter 4</span></em><span class="koboSpan" id="kobo.4205.1">, </span><em class="italic"><span class="koboSpan" id="kobo.4206.1">Conditionally compiling your source code</span></em><span class="koboSpan" id="kobo.4207.1">, to learn the various options for performing conditional compilation</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-73"><span class="koboSpan" id="kobo.4208.1">Using structured bindings to handle multi-return values</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4209.1">Returning </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.4210.1">multiple values from a function</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.4211.1"> is very common, yet there is no first-class solution in C++ to make it possible in a straightforward way. </span><span class="koboSpan" id="kobo.4211.2">Developers have to choose between returning multiple values through reference parameters to a function, defining a structure to contain the multiple values, or returning a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4212.1">std::pair</span></code><span class="koboSpan" id="kobo.4213.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4214.1">std::tuple</span></code><span class="koboSpan" id="kobo.4215.1">. </span><span class="koboSpan" id="kobo.4215.2">The first two use named variables, which gives them the advantage that they clearly indicate the meaning of the return value, but have the disadvantage that they have to be explicitly defined. </span><code class="inlineCode"><span class="koboSpan" id="kobo.4216.1">std::pair</span></code><span class="koboSpan" id="kobo.4217.1"> has its members called </span><code class="inlineCode"><span class="koboSpan" id="kobo.4218.1">first</span></code><span class="koboSpan" id="kobo.4219.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4220.1">second</span></code><span class="koboSpan" id="kobo.4221.1">, while </span><code class="inlineCode"><span class="koboSpan" id="kobo.4222.1">std::tuple</span></code><span class="koboSpan" id="kobo.4223.1"> has unnamed members that can only be retrieved with a function call but can be copied to named variables, using </span><code class="inlineCode"><span class="koboSpan" id="kobo.4224.1">std::tie()</span></code><span class="koboSpan" id="kobo.4225.1">. </span><span class="koboSpan" id="kobo.4225.2">None of these solutions are ideal.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4226.1">C++17 extends the semantic use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4227.1">std::tie()</span></code><span class="koboSpan" id="kobo.4228.1"> to a first-class core language feature that enables unpacking the values of a tuple into named variables. </span><span class="koboSpan" id="kobo.4228.2">This feature is called </span><em class="italic"><span class="koboSpan" id="kobo.4229.1">structured bindings</span></em><span class="koboSpan" id="kobo.4230.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-74"><span class="koboSpan" id="kobo.4231.1">Getting ready</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4232.1">For this recipe, you should be familiar with the standard utility types </span><code class="inlineCode"><span class="koboSpan" id="kobo.4233.1">std::pair</span></code><span class="koboSpan" id="kobo.4234.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4235.1">std::tuple</span></code><span class="koboSpan" id="kobo.4236.1"> and the utility function </span><code class="inlineCode"><span class="koboSpan" id="kobo.4237.1">std::tie()</span></code><span class="koboSpan" id="kobo.4238.1">.</span></p>
<h2 class="heading-2" id="_idParaDest-75"><span class="koboSpan" id="kobo.4239.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4240.1">To return multiple values from a function using a compiler that supports C++17, you should do the following:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.4241.1">Use an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4242.1">std::tuple</span></code><span class="koboSpan" id="kobo.4243.1"> for the return type:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-function"><span class="koboSpan" id="kobo.4244.1">std::tuple&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4245.1">int</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4246.1">, std::string, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4247.1">double</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4248.1">&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4249.1">find</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4250.1">()</span></span><span class="koboSpan" id="kobo.4251.1">
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4252.1">return</span></span><span class="koboSpan" id="kobo.4253.1"> {</span><span class="hljs-number"><span class="koboSpan" id="kobo.4254.1">1</span></span><span class="koboSpan" id="kobo.4255.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4256.1">"marius"</span></span><span class="koboSpan" id="kobo.4257.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4258.1">1234.5</span></span><span class="koboSpan" id="kobo.4259.1">};
}
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4260.1">Use structured bindings to unpack the values of the tuple into named objects:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4261.1">auto</span></span><span class="koboSpan" id="kobo.4262.1"> [id, name, score] = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4263.1">find</span></span><span class="koboSpan" id="kobo.4264.1">();
</span></code></pre>
</li>
<li class="numberedList"><span class="koboSpan" id="kobo.4265.1">Use structure bindings to bind the returned values to the variables inside an </span><code class="inlineCode"><span class="koboSpan" id="kobo.4266.1">if</span></code><span class="koboSpan" id="kobo.4267.1"> statement or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4268.1">switch</span></code><span class="koboSpan" id="kobo.4269.1"> statement:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4270.1">if</span></span><span class="koboSpan" id="kobo.4271.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4272.1">auto</span></span><span class="koboSpan" id="kobo.4273.1"> [id, name, score] = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4274.1">find</span></span><span class="koboSpan" id="kobo.4275.1">(); score &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.4276.1">1000</span></span><span class="koboSpan" id="kobo.4277.1">)
{
  std::cout &lt;&lt; name &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4278.1">'\n'</span></span><span class="koboSpan" id="kobo.4279.1">;
}
</span></code></pre>
</li>
</ol>
<h2 class="heading-2" id="_idParaDest-76"><span class="koboSpan" id="kobo.4280.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4281.1">Structured bindings (sometimes referred to as </span><em class="italic"><span class="koboSpan" id="kobo.4282.1">decomposition declaration</span></em><span class="koboSpan" id="kobo.4283.1">) are a language feature that works just like </span><code class="inlineCode"><span class="koboSpan" id="kobo.4284.1">std::tie()</span></code><span class="koboSpan" id="kobo.4285.1">, except that we don’t have to define named variables </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.4286.1">for each value that needs to </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.4287.1">be unpacked explicitly with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4288.1">std::tie()</span></code><span class="koboSpan" id="kobo.4289.1">. </span><span class="koboSpan" id="kobo.4289.2">With structured bindings, we define all the named variables in a single definition using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4290.1">auto</span></code><span class="koboSpan" id="kobo.4291.1"> specifier so that the compiler can infer the correct type for each variable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4292.1">To exemplify this, let’s consider the case of inserting items into a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4293.1">std::map</span></code><span class="koboSpan" id="kobo.4294.1">. </span><span class="koboSpan" id="kobo.4294.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.4295.1">insert</span></code><span class="koboSpan" id="kobo.4296.1"> method returns a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4297.1">std::pair</span></code><span class="koboSpan" id="kobo.4298.1">, containing an iterator for the inserted element or the element that prevented the insertion, and a Boolean indicating whether the insertion was successful or not. </span><span class="koboSpan" id="kobo.4298.2">The following code is very explicit, and the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4299.1">second</span></code><span class="koboSpan" id="kobo.4300.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4301.1">first-&gt;second</span></code><span class="koboSpan" id="kobo.4302.1"> makes the code harder to read because you need to constantly figure out what they represent:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4303.1">std::map&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4304.1">int</span></span><span class="koboSpan" id="kobo.4305.1">, std::string&gt; m;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4306.1">auto</span></span><span class="koboSpan" id="kobo.4307.1"> result = m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4308.1">insert</span></span><span class="koboSpan" id="kobo.4309.1">({ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4310.1">1</span></span><span class="koboSpan" id="kobo.4311.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4312.1">"one"</span></span><span class="koboSpan" id="kobo.4313.1"> });
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4314.1">"inserted = "</span></span><span class="koboSpan" id="kobo.4315.1"> &lt;&lt; result.second &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4316.1">'\n'</span></span><span class="koboSpan" id="kobo.4317.1">
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4318.1">"value = "</span></span><span class="koboSpan" id="kobo.4319.1"> &lt;&lt; result.first-&gt;second &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4320.1">'\n'</span></span><span class="koboSpan" id="kobo.4321.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4322.1">The </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.4323.1">preceding code can be made more</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.4324.1"> readable with the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4325.1">std::tie</span></code><span class="koboSpan" id="kobo.4326.1">, which unpacks tuples into individual objects (and works with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4327.1">std::pair</span></code><span class="koboSpan" id="kobo.4328.1"> because </span><code class="inlineCode"><span class="koboSpan" id="kobo.4329.1">std::tuple</span></code><span class="koboSpan" id="kobo.4330.1"> has a converting assignment from </span><code class="inlineCode"><span class="koboSpan" id="kobo.4331.1">std::pair</span></code><span class="koboSpan" id="kobo.4332.1">):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4333.1">std::map&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4334.1">int</span></span><span class="koboSpan" id="kobo.4335.1">, std::string&gt; m;
std::map&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4336.1">int</span></span><span class="koboSpan" id="kobo.4337.1">, std::string&gt;::iterator it;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4338.1">bool</span></span><span class="koboSpan" id="kobo.4339.1"> inserted;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4340.1">tie</span></span><span class="koboSpan" id="kobo.4341.1">(it, inserted) = m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4342.1">insert</span></span><span class="koboSpan" id="kobo.4343.1">({ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4344.1">1</span></span><span class="koboSpan" id="kobo.4345.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4346.1">"one"</span></span><span class="koboSpan" id="kobo.4347.1"> });
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4348.1">"inserted = "</span></span><span class="koboSpan" id="kobo.4349.1"> &lt;&lt; inserted &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4350.1">'\n'</span></span><span class="koboSpan" id="kobo.4351.1">
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4352.1">"value = "</span></span><span class="koboSpan" id="kobo.4353.1"> &lt;&lt; it-&gt;second &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4354.1">'\n'</span></span><span class="koboSpan" id="kobo.4355.1">;
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4356.1">tie</span></span><span class="koboSpan" id="kobo.4357.1">(it, inserted) = m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4358.1">insert</span></span><span class="koboSpan" id="kobo.4359.1">({ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4360.1">1</span></span><span class="koboSpan" id="kobo.4361.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4362.1">"two"</span></span><span class="koboSpan" id="kobo.4363.1"> });
std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4364.1">"inserted = "</span></span><span class="koboSpan" id="kobo.4365.1"> &lt;&lt; inserted &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4366.1">'\n'</span></span><span class="koboSpan" id="kobo.4367.1">
          &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4368.1">"value = "</span></span><span class="koboSpan" id="kobo.4369.1"> &lt;&lt; it-&gt;second &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4370.1">'\n'</span></span><span class="koboSpan" id="kobo.4371.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4372.1">The code is not necessarily simpler because it requires defining the objects that the pair is unpacked to in advance. </span><span class="koboSpan" id="kobo.4372.2">Similarly, the more elements the tuple has, the more objects you need to define, but using named objects makes the code easier to read.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4373.1">C++17 </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.4374.1">structured bindings elevate unpacking tuple elements into named objects to the rank of a language feature; there is no requirement for the use of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4375.1">std::tie()</span></code><span class="koboSpan" id="kobo.4376.1">, and objects are initialized when declared:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4377.1">std::map&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4378.1">int</span></span><span class="koboSpan" id="kobo.4379.1">, std::string&gt; m;
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4380.1">auto</span></span><span class="koboSpan" id="kobo.4381.1"> [it, inserted] = m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4382.1">insert</span></span><span class="koboSpan" id="kobo.4383.1">({ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4384.1">1</span></span><span class="koboSpan" id="kobo.4385.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4386.1">"one"</span></span><span class="koboSpan" id="kobo.4387.1"> });
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4388.1">"inserted = "</span></span><span class="koboSpan" id="kobo.4389.1"> &lt;&lt; inserted &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4390.1">'\n'</span></span><span class="koboSpan" id="kobo.4391.1">
            &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4392.1">"value = "</span></span><span class="koboSpan" id="kobo.4393.1"> &lt;&lt; it-&gt;second &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4394.1">'\n'</span></span><span class="koboSpan" id="kobo.4395.1">;
}
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4396.1">auto</span></span><span class="koboSpan" id="kobo.4397.1"> [it, inserted] = m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4398.1">insert</span></span><span class="koboSpan" id="kobo.4399.1">({ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4400.1">1</span></span><span class="koboSpan" id="kobo.4401.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4402.1">"two"</span></span><span class="koboSpan" id="kobo.4403.1"> });
  std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4404.1">"inserted = "</span></span><span class="koboSpan" id="kobo.4405.1"> &lt;&lt; inserted &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4406.1">'\n'</span></span><span class="koboSpan" id="kobo.4407.1">
            &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4408.1">"value = "</span></span><span class="koboSpan" id="kobo.4409.1"> &lt;&lt; it-&gt;second &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4410.1">'\n'</span></span><span class="koboSpan" id="kobo.4411.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4412.1">The use of multiple blocks in the preceding example is necessary because variables cannot be redeclared in the same block, and structured bindings imply a declaration using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4413.1">auto</span></code><span class="koboSpan" id="kobo.4414.1"> specifier. </span><span class="koboSpan" id="kobo.4414.2">Therefore, if you need to make multiple calls, as in the preceding example, and use structured bindings, you must either use different variable names or multiple blocks. </span><span class="koboSpan" id="kobo.4414.3">An alternative to that is to avoid structured bindings and use </span><code class="inlineCode"><span class="koboSpan" id="kobo.4415.1">std::tie()</span></code><span class="koboSpan" id="kobo.4416.1">, because it can be called multiple times with the same variables, so you only need to declare them once.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4417.1">In C++17, it is also possible to declare variables in </span><code class="inlineCode"><span class="koboSpan" id="kobo.4418.1">if</span></code><span class="koboSpan" id="kobo.4419.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4420.1">switch</span></code><span class="koboSpan" id="kobo.4421.1"> statements in the form </span><code class="inlineCode"><span class="koboSpan" id="kobo.4422.1">if(init; condition)</span></code><span class="koboSpan" id="kobo.4423.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4424.1">switch(init; condition)</span></code><span class="koboSpan" id="kobo.4425.1">, respectively. </span><span class="koboSpan" id="kobo.4425.2">This could be combined with structured bindings to produce simpler code. </span><span class="koboSpan" id="kobo.4425.3">Let’s look at an example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4426.1">if</span></span><span class="koboSpan" id="kobo.4427.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4428.1">auto</span></span><span class="koboSpan" id="kobo.4429.1"> [it, inserted] = m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4430.1">insert</span></span><span class="koboSpan" id="kobo.4431.1">({ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4432.1">1</span></span><span class="koboSpan" id="kobo.4433.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4434.1">"two"</span></span><span class="koboSpan" id="kobo.4435.1"> }); inserted)
{ std::cout &lt;&lt; it-&gt;second &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4436.1">'</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4437.1">\n'</span></span><span class="koboSpan" id="kobo.4438.1">; }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4439.1">In the preceding snippet, we attempted to insert a new value into a map. </span><span class="koboSpan" id="kobo.4439.2">The result of the call is unpacked into two variables, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4440.1">it</span></code><span class="koboSpan" id="kobo.4441.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4442.1">inserted</span></code><span class="koboSpan" id="kobo.4443.1">, defined in the scope of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4444.1">if</span></code><span class="koboSpan" id="kobo.4445.1"> statement in the initialization part. </span><span class="koboSpan" id="kobo.4445.2">Then, the condition </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.4446.1">of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4447.1">if</span></code><span class="koboSpan" id="kobo.4448.1"> statement is evaluated from the </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.4449.1">value of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4450.1">inserted</span></code><span class="koboSpan" id="kobo.4451.1"> variable.</span></p>
<h2 class="heading-2" id="_idParaDest-77"><span class="koboSpan" id="kobo.4452.1">There’s more...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4453.1">Although we focused on binding</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.4454.1"> names to the elements of tuples, structured bindings can be used in a broader scope because they also support binding to array elements or data members of a class. </span><span class="koboSpan" id="kobo.4454.2">If you want to bind to the elements of an array, you must provide a name for every element of the array; otherwise, the declaration is ill-formed. </span><span class="koboSpan" id="kobo.4454.3">The following is an example of binding to array elements:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.4455.1">int</span></span><span class="koboSpan" id="kobo.4456.1"> arr[] = { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4457.1">1</span></span><span class="koboSpan" id="kobo.4458.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4459.1">2</span></span><span class="koboSpan" id="kobo.4460.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4461.1">auto</span></span><span class="koboSpan" id="kobo.4462.1"> [a, b] = arr;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4463.1">auto</span></span><span class="koboSpan" id="kobo.4464.1">&amp; [x, y] = arr;
arr[</span><span class="hljs-number"><span class="koboSpan" id="kobo.4465.1">0</span></span><span class="koboSpan" id="kobo.4466.1">] += </span><span class="hljs-number"><span class="koboSpan" id="kobo.4467.1">10</span></span><span class="koboSpan" id="kobo.4468.1">;
arr[</span><span class="hljs-number"><span class="koboSpan" id="kobo.4469.1">1</span></span><span class="koboSpan" id="kobo.4470.1">] += </span><span class="hljs-number"><span class="koboSpan" id="kobo.4471.1">10</span></span><span class="koboSpan" id="kobo.4472.1">;
std::cout &lt;&lt; arr[</span><span class="hljs-number"><span class="koboSpan" id="kobo.4473.1">0</span></span><span class="koboSpan" id="kobo.4474.1">] &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4475.1">' '</span></span><span class="koboSpan" id="kobo.4476.1"> &lt;&lt; arr[</span><span class="hljs-number"><span class="koboSpan" id="kobo.4477.1">1</span></span><span class="koboSpan" id="kobo.4478.1">] &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4479.1">'\n'</span></span><span class="koboSpan" id="kobo.4480.1">; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4481.1">// 11 12</span></span><span class="koboSpan" id="kobo.4482.1">
std::cout &lt;&lt; a &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4483.1">' '</span></span><span class="koboSpan" id="kobo.4484.1"> &lt;&lt; b &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4485.1">'\n'</span></span><span class="koboSpan" id="kobo.4486.1">;           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4487.1">// 1 2</span></span><span class="koboSpan" id="kobo.4488.1">
std::cout &lt;&lt; x &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4489.1">' '</span></span><span class="koboSpan" id="kobo.4490.1"> &lt;&lt; y &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4491.1">'\n'</span></span><span class="koboSpan" id="kobo.4492.1">;           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4493.1">// 11 12</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4494.1">In this example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4495.1">arr</span></code><span class="koboSpan" id="kobo.4496.1"> is an array with two elements. </span><span class="koboSpan" id="kobo.4496.2">We first bind </span><code class="inlineCode"><span class="koboSpan" id="kobo.4497.1">a</span></code><span class="koboSpan" id="kobo.4498.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4499.1">b</span></code><span class="koboSpan" id="kobo.4500.1"> to its elements, and then we bind the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4501.1">x</span></code><span class="koboSpan" id="kobo.4502.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4503.1">y</span></code><span class="koboSpan" id="kobo.4504.1"> references to its elements. </span><span class="koboSpan" id="kobo.4504.2">Changes that are made to the elements of the array are not visible through the variables </span><code class="inlineCode"><span class="koboSpan" id="kobo.4505.1">a</span></code><span class="koboSpan" id="kobo.4506.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4507.1">b</span></code><span class="koboSpan" id="kobo.4508.1">, but they are through the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4509.1">x</span></code><span class="koboSpan" id="kobo.4510.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4511.1">y</span></code><span class="koboSpan" id="kobo.4512.1"> references, as shown in the comments that print these values to the console. </span><span class="koboSpan" id="kobo.4512.2">This happens because when we do the first binding, a copy of the array is created, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4513.1">a</span></code><span class="koboSpan" id="kobo.4514.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4515.1">b</span></code><span class="koboSpan" id="kobo.4516.1"> are bound to the elements of the copy.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4517.1">As we already mentioned, it’s also possible to bind to data members of a class. </span><span class="koboSpan" id="kobo.4517.2">The following restrictions apply:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4518.1">Binding is possible only for non-static members of the class.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4519.1">The class cannot have anonymous union members.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4520.1">The number of identifiers must match the number of non-static members of the class.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4521.1">The binding of </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.4522.1">identifiers occurs in the order of the declaration of the data members, which can include bitfields. </span><span class="koboSpan" id="kobo.4522.2">An example is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4523.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4524.1">foo</span></span><span class="koboSpan" id="kobo.4525.1">
{
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.4526.1">int</span></span><span class="koboSpan" id="kobo.4527.1">         id;
   std::string name;
};
foo f{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4528.1">42</span></span><span class="koboSpan" id="kobo.4529.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4530.1">"john"</span></span><span class="koboSpan" id="kobo.4531.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4532.1">auto</span></span><span class="koboSpan" id="kobo.4533.1"> [i, n] = f;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4534.1">auto</span></span><span class="koboSpan" id="kobo.4535.1">&amp; [ri, rn] = f;
f.id = </span><span class="hljs-number"><span class="koboSpan" id="kobo.4536.1">43</span></span><span class="koboSpan" id="kobo.4537.1">;
std::cout &lt;&lt; f.id &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4538.1">' '</span></span><span class="koboSpan" id="kobo.4539.1"> &lt;&lt; f.name &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4540.1">'\n'</span></span><span class="koboSpan" id="kobo.4541.1">;   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4542.1">// 43 john</span></span><span class="koboSpan" id="kobo.4543.1">
std::cout &lt;&lt; i &lt;&lt;'</span><span class="hljs-string"><span class="koboSpan" id="kobo.4544.1">'''</span></span><span class="koboSpan" id="kobo.4545.1"> &lt;&lt; n &lt;&lt;'</span><span class="hljs-string"><span class="koboSpan" id="kobo.4546.1">'\''</span></span><span class="koboSpan" id="kobo.4547.1">;           </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4548.1">// 42 john</span></span><span class="koboSpan" id="kobo.4549.1">
std::cout &lt;&lt; ri &lt;&lt;'</span><span class="hljs-string"><span class="koboSpan" id="kobo.4550.1">'''</span></span><span class="koboSpan" id="kobo.4551.1"> &lt;&lt; rn &lt;&lt;'</span><span class="hljs-string"><span class="koboSpan" id="kobo.4552.1">'\''</span></span><span class="koboSpan" id="kobo.4553.1">;         </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4554.1">// 43 john</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4555.1">Again, changes to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4556.1">foo</span></code><span class="koboSpan" id="kobo.4557.1"> object are not visible to the variables </span><code class="inlineCode"><span class="koboSpan" id="kobo.4558.1">i</span></code><span class="koboSpan" id="kobo.4559.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4560.1">n</span></code><span class="koboSpan" id="kobo.4561.1"> but are to </span><code class="inlineCode"><span class="koboSpan" id="kobo.4562.1">ri</span></code><span class="koboSpan" id="kobo.4563.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.4564.1">rn</span></code><span class="koboSpan" id="kobo.4565.1">. </span><span class="koboSpan" id="kobo.4565.2">This is because each identifier in the structure binding becomes the name of an lvalue that refers to a data member of the class (just like with an array, it refers to an element of the array). </span><span class="koboSpan" id="kobo.4565.3">However, the reference type of an identifier is the corresponding data member (or array element).</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4566.1">The new C++20 standard has introduced a series of improvements to structure bindings, including the following:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4567.1">The possibility to include the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4568.1">static</span></code><span class="koboSpan" id="kobo.4569.1"> or </span><code class="inlineCode"><span class="koboSpan" id="kobo.4570.1">thread_local</span></code><span class="koboSpan" id="kobo.4571.1"> storage-class specifiers in the declaration of the structure bindings.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4572.1">The use of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4573.1">[[maybe_unused]]</span></code><span class="koboSpan" id="kobo.4574.1"> attribute for the declaration of a structured binding. </span><span class="koboSpan" id="kobo.4574.2">Some compilers, such as Clang and GCC, had already supported this feature.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.4575.1">The possibility to capture structure binding identifiers in lambdas. </span><span class="koboSpan" id="kobo.4575.2">All identifiers, including those bound to bitfields, can be captured by value. </span><span class="koboSpan" id="kobo.4575.3">Conversely, all identifiers except for those bound to bitfields can also be captured by reference.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.4576.1">These changes enable us to write the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4577.1">foo f{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4578.1">42</span></span><span class="koboSpan" id="kobo.4579.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.4580.1">"john"</span></span><span class="koboSpan" id="kobo.4581.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4582.1">auto</span></span><span class="koboSpan" id="kobo.4583.1"> [i, n] = f;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4584.1">auto</span></span><span class="koboSpan" id="kobo.4585.1"> l1 = [i] {std::cout &lt;&lt; i; };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4586.1">auto</span></span><span class="koboSpan" id="kobo.4587.1"> l2 = [=] {std::cout &lt;&lt; i; };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4588.1">auto</span></span><span class="koboSpan" id="kobo.4589.1"> l3 = [&amp;i] {std::cout &lt;&lt; i; };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4590.1">auto</span></span><span class="koboSpan" id="kobo.4591.1"> l4 = [&amp;] {std::cout &lt;&lt; i; };
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4592.1">These examples show the various ways structured bindings can be captured in lambdas in C++20.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4593.1">Sometimes, we need to bind variables that we don’t use. </span><span class="koboSpan" id="kobo.4593.2">In C++26, it will be possible to ignore a variable by using an underscore (</span><code class="inlineCode"><span class="koboSpan" id="kobo.4594.1">_</span></code><span class="koboSpan" id="kobo.4595.1">) instead of a name. </span><span class="koboSpan" id="kobo.4595.2">Although not supported by any compiler at the time of writing, this feature has been included in C++26.</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4596.1">foo f{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4597.1">42</span></span><span class="koboSpan" id="kobo.4598.1">,</span><span class="hljs-string"><span class="koboSpan" id="kobo.4599.1">"john"</span></span><span class="koboSpan" id="kobo.4600.1"> };
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4601.1">auto</span></span><span class="koboSpan" id="kobo.4602.1"> [_, n] = f;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4603.1">Here, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4604.1">_</span></code><span class="koboSpan" id="kobo.4605.1"> is a placeholder for a variable that is bound to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4606.1">id</span></code><span class="koboSpan" id="kobo.4607.1"> member of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4608.1">foo</span></code><span class="koboSpan" id="kobo.4609.1"> object. </span><span class="koboSpan" id="kobo.4609.2">It is used to indicate that this value is not used and will be ignored in this context.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4610.1">The use of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.4611.1">_</span></code><span class="koboSpan" id="kobo.4612.1"> placeholder is not</span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.4613.1"> limited to structured bindings. </span><span class="koboSpan" id="kobo.4613.2">It can be used as an identifier for non-static class members, structured bindings, and lambda captures. </span><span class="koboSpan" id="kobo.4613.3">You can use an underscore to redefine an existing declaration in the same scope, therefore making it possible to ignore multiple variables. </span><span class="koboSpan" id="kobo.4613.4">However, a program is considered ill-formed if the variable named </span><code class="inlineCode"><span class="koboSpan" id="kobo.4614.1">_</span></code><span class="koboSpan" id="kobo.4615.1"> is used after a redeclaration.</span></p>
<h2 class="heading-2" id="_idParaDest-78"><span class="koboSpan" id="kobo.4616.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.4617.1">Using auto whenever possible</span></em><span class="koboSpan" id="kobo.4618.1">, to understand how automatic type deduction works in C++</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.4619.1">Chapter 3</span></em><span class="koboSpan" id="kobo.4620.1">, </span><em class="italic"><span class="koboSpan" id="kobo.4621.1">Using lambdas with standard algorithms</span></em><span class="koboSpan" id="kobo.4622.1">, to learn how lambdas can be used with standard library general-purpose algorithms</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.4623.1">Chapter 4</span></em><span class="koboSpan" id="kobo.4624.1">, </span><em class="italic"><span class="koboSpan" id="kobo.4625.1">Providing metadata to the compiler with attributes</span></em><span class="koboSpan" id="kobo.4626.1">, to learn about providing hints to the compiler with the use of standard attributes</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-79"><span class="koboSpan" id="kobo.4627.1">Simplifying code with class template argument deduction</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.4628.1">Templates are ubiquitous in C++, but having to specify template arguments all the time can be annoying. </span><span class="koboSpan" id="kobo.4628.2">There are cases when the compiler can actually infer the template arguments from the context. </span><span class="koboSpan" id="kobo.4628.3">This feature, available in C++17, is called </span><em class="italic"><span class="koboSpan" id="kobo.4629.1">class template argument deduction</span></em><span class="koboSpan" id="kobo.4630.1"> and</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.4631.1"> enables the compiler to deduce the missing template arguments from the type of the initializer. </span><span class="koboSpan" id="kobo.4631.2">In this recipe, we will learn how to take advantage of this feature.</span></p>
<h2 class="heading-2" id="_idParaDest-80"><span class="koboSpan" id="kobo.4632.1">How to do it...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4633.1">In C++17, you </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.4634.1">can skip specifying template arguments and let the compiler deduce them in the following cases:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4635.1">When you declare a variable or a variable template and initialize it:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4636.1">std::pair   p{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4637.1">42</span></span><span class="koboSpan" id="kobo.4638.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4639.1">"demo"</span></span><span class="koboSpan" id="kobo.4640.1"> };  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4641.1">// deduces std::pair&lt;int, char const*&gt;</span></span><span class="koboSpan" id="kobo.4642.1">
std::vector v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4643.1">1</span></span><span class="koboSpan" id="kobo.4644.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4645.1">2</span></span><span class="koboSpan" id="kobo.4646.1"> };        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4647.1">// deduces std::vector&lt;int&gt;</span></span><span class="koboSpan" id="kobo.4648.1">
std::less   l;                </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4649.1">// deduces std::less&lt;void&gt;</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4650.1">When you create an object using a new expression:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4651.1">template</span></span><span class="koboSpan" id="kobo.4652.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4653.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4654.1">T</span></span><span class="koboSpan" id="kobo.4655.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4656.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4657.1">foo</span></span><span class="koboSpan" id="kobo.4658.1">
{
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4659.1">foo</span></span><span class="koboSpan" id="kobo.4660.1">(T v) :</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4661.1">data</span></span><span class="koboSpan" id="kobo.4662.1">(v) {}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4663.1">private</span></span><span class="koboSpan" id="kobo.4664.1">:
   T data;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4665.1">auto</span></span><span class="koboSpan" id="kobo.4666.1"> f = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4667.1">new</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.4668.1">foo</span></span><span class="koboSpan" id="kobo.4669.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4670.1">42</span></span><span class="koboSpan" id="kobo.4671.1">);
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4672.1">When you perform function-like cast expressions:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4673.1">std::mutex mx;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4674.1">// deduces std::lock_guard&lt;std::mutex&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.4675.1">auto</span></span><span class="koboSpan" id="kobo.4676.1"> lock = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4677.1">lock_guard</span></span><span class="koboSpan" id="kobo.4678.1">(mx);
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4679.1">int</span></span><span class="koboSpan" id="kobo.4680.1">&gt; v;
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.4681.1">// deduces std::back_insert_iterator&lt;std::vector&lt;int&gt;&gt;</span></span><span class="koboSpan" id="kobo.4682.1">
std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4683.1">fill_n</span></span><span class="koboSpan" id="kobo.4684.1">(std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4685.1">back_insert_iterator</span></span><span class="koboSpan" id="kobo.4686.1">(v), </span><span class="hljs-number"><span class="koboSpan" id="kobo.4687.1">5</span></span><span class="koboSpan" id="kobo.4688.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4689.1">42</span></span><span class="koboSpan" id="kobo.4690.1">);
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-81"><span class="koboSpan" id="kobo.4691.1">How it works...</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.4692.1">Prior to</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.4693.1"> C++17, you had to specify all the template arguments when initializing variables, because all of them must be known in order to instantiate the class template, such as in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4694.1">std::pair&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4695.1">int</span></span><span class="koboSpan" id="kobo.4696.1">, </span><span class="hljs-type"><span class="koboSpan" id="kobo.4697.1">char</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4698.1">const</span></span><span class="koboSpan" id="kobo.4699.1">*&gt; p{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4700.1">42</span></span><span class="koboSpan" id="kobo.4701.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4702.1">"demo"</span></span><span class="koboSpan" id="kobo.4703.1"> };
std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4704.1">int</span></span><span class="koboSpan" id="kobo.4705.1">&gt;            v{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4706.1">1</span></span><span class="koboSpan" id="kobo.4707.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4708.1">2</span></span><span class="koboSpan" id="kobo.4709.1"> };
foo&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4710.1">int</span></span><span class="koboSpan" id="kobo.4711.1">&gt;                    f{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4712.1">42</span></span><span class="koboSpan" id="kobo.4713.1"> };
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4714.1">The problem of explicitly specifying template arguments could have been avoided with a function template, such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.4715.1">std::make_pair()</span></code><span class="koboSpan" id="kobo.4716.1">, which benefits from function template argument deduction and allows us to write code such as the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4717.1">auto</span></span><span class="koboSpan" id="kobo.4718.1"> p = std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4719.1">make_pair</span></span><span class="koboSpan" id="kobo.4720.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4721.1">42</span></span><span class="koboSpan" id="kobo.4722.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4723.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4724.1">demo"</span></span><span class="koboSpan" id="kobo.4725.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4726.1">In the case of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4727.1">foo</span></code><span class="koboSpan" id="kobo.4728.1"> class template shown here, we can write the following </span><code class="inlineCode"><span class="koboSpan" id="kobo.4729.1">make_foo()</span></code><span class="koboSpan" id="kobo.4730.1"> function template to enable the same behavior:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4731.1">template</span></span><span class="koboSpan" id="kobo.4732.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4733.1">typename</span></span><span class="koboSpan" id="kobo.4734.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4735.1">constexpr</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.4736.1"> foo&lt;T&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4737.1">make_foo</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4738.1">(T&amp;&amp; value)</span></span><span class="koboSpan" id="kobo.4739.1">
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4740.1">return</span></span><span class="koboSpan" id="kobo.4741.1"> foo{ value };
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4742.1">auto</span></span><span class="koboSpan" id="kobo.4743.1"> f = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4744.1">make_foo</span></span><span class="koboSpan" id="kobo.4745.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.4746.1">42</span></span><span class="koboSpan" id="kobo.4747.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4748.1">In C++17, this is no longer necessary in the cases listed in the </span><em class="italic"><span class="koboSpan" id="kobo.4749.1">How it works...</span></em><span class="koboSpan" id="kobo.4750.1"> section. </span><span class="koboSpan" id="kobo.4750.2">Let’s take the following declaration as an example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4751.1">std::pair p{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4752.1">42</span></span><span class="koboSpan" id="kobo.4753.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4754.1">"demo"</span></span><span class="koboSpan" id="kobo.4755.1"> };
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4756.1">In this context, </span><code class="inlineCode"><span class="koboSpan" id="kobo.4757.1">std::pair</span></code><span class="koboSpan" id="kobo.4758.1"> is not a type, but it acts as a placeholder for a type that activates class template argument deduction. </span><span class="koboSpan" id="kobo.4758.2">When the compiler encounters it during the declaration of a variable with initialization or a function-style cast, it builds a set of deduction guides. </span><span class="koboSpan" id="kobo.4758.3">These deduction guides are fictional constructors of a hypothetical class type. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.4759.1">As a user, you can complement this set with user-defined deduction rules. </span><span class="koboSpan" id="kobo.4759.2">This set is used to perform template argument deduction and overload resolution.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4760.1">In the </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.4761.1">case of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4762.1">std::pair</span></code><span class="koboSpan" id="kobo.4763.1">, the compiler will build a set of deduction guides that includes the following fictional function templates (but not only these):</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4764.1">template</span></span><span class="koboSpan" id="kobo.4765.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4766.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4767.1">T1</span></span><span class="koboSpan" id="kobo.4768.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4769.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4770.1">T2</span></span><span class="koboSpan" id="kobo.4771.1">&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4772.1">std::pair&lt;T1, T2&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4773.1">F</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4774.1">()</span></span><span class="koboSpan" id="kobo.4775.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4776.1">template</span></span><span class="koboSpan" id="kobo.4777.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4778.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4779.1">T1</span></span><span class="koboSpan" id="kobo.4780.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4781.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4782.1">T2</span></span><span class="koboSpan" id="kobo.4783.1">&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4784.1">std::pair&lt;T1, T2&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4785.1">F</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4786.1">(T1 </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4787.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4788.1">&amp; x, T2 </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.4789.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4790.1">&amp; y)</span></span><span class="koboSpan" id="kobo.4791.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4792.1">template</span></span><span class="koboSpan" id="kobo.4793.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4794.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4795.1">T1</span></span><span class="koboSpan" id="kobo.4796.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4797.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4798.1">T2</span></span><span class="koboSpan" id="kobo.4799.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4800.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4801.1">U1</span></span><span class="koboSpan" id="kobo.4802.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4803.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4804.1">U2</span></span><span class="koboSpan" id="kobo.4805.1">&gt;
</span><span class="hljs-function"><span class="koboSpan" id="kobo.4806.1">std::pair&lt;T1, T2&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4807.1">F</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4808.1">(U1&amp;&amp; x, U2&amp;&amp; y)</span></span><span class="koboSpan" id="kobo.4809.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4810.1">These compiler-generated deduction guides are created from the constructors of the class template, and if none are present, then a deduction guide is created for a hypothetical default constructor. </span><span class="koboSpan" id="kobo.4810.2">In addition, in all cases, a deduction guide for a hypothetical copy constructor is always created.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4811.1">The user-defined deduction guides are function signatures with a trailing return type and without the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4812.1">auto</span></code><span class="koboSpan" id="kobo.4813.1"> keyword (since they represent hypothetical constructors that don’t have a return value). </span><span class="koboSpan" id="kobo.4813.2">They must be defined in the namespace of the class template they apply to.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4814.1">To </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.4815.1">understand how this works, let’s consider the same example with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4816.1">std::pair</span></code><span class="koboSpan" id="kobo.4817.1"> object:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4818.1">std::pair p{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4819.1">42</span></span><span class="koboSpan" id="kobo.4820.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4821.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4822.1">demo"</span></span><span class="koboSpan" id="kobo.4823.1"> };
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4824.1">The type that the compiler deduces is </span><code class="inlineCode"><span class="koboSpan" id="kobo.4825.1">std::pair&lt;int, char const*&gt;</span></code><span class="koboSpan" id="kobo.4826.1">. </span><span class="koboSpan" id="kobo.4826.2">If we want to instruct the compiler to deduce </span><code class="inlineCode"><span class="koboSpan" id="kobo.4827.1">std::string</span></code><span class="koboSpan" id="kobo.4828.1"> instead of </span><code class="inlineCode"><span class="koboSpan" id="kobo.4829.1">char const*</span></code><span class="koboSpan" id="kobo.4830.1">, then we need several user-defined deduction rules, as shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4831.1">namespace</span></span><span class="koboSpan" id="kobo.4832.1"> std {
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4833.1">template</span></span><span class="koboSpan" id="kobo.4834.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4835.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4836.1">T</span></span><span class="koboSpan" id="kobo.4837.1">&gt;
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4838.1">pair</span></span><span class="koboSpan" id="kobo.4839.1">(T&amp;&amp;, </span><span class="hljs-type"><span class="koboSpan" id="kobo.4840.1">char</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4841.1">const</span></span><span class="koboSpan" id="kobo.4842.1">*)-&gt;pair&lt;T, std::string&gt;;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4843.1">template</span></span><span class="koboSpan" id="kobo.4844.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4845.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4846.1">T</span></span><span class="koboSpan" id="kobo.4847.1">&gt;
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4848.1">pair</span></span><span class="koboSpan" id="kobo.4849.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.4850.1">char</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4851.1">const</span></span><span class="koboSpan" id="kobo.4852.1">*, T&amp;&amp;)-&gt;pair&lt;std::string, T&gt;;
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4853.1">pair</span></span><span class="koboSpan" id="kobo.4854.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.4855.1">char</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4856.1">const</span></span><span class="koboSpan" id="kobo.4857.1">*, </span><span class="hljs-type"><span class="koboSpan" id="kobo.4858.1">char</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.4859.1">const</span></span><span class="koboSpan" id="kobo.4860.1">*)-&gt;pair&lt;std::string, std::string&gt;;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4861.1">These will enable us to perform the following declarations, where the type of the string </span><code class="inlineCode"><span class="koboSpan" id="kobo.4862.1">"demo"</span></code><span class="koboSpan" id="kobo.4863.1"> is always deduced to be </span><code class="inlineCode"><span class="koboSpan" id="kobo.4864.1">std::string</span></code><span class="koboSpan" id="kobo.4865.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4866.1">std::pair  p1{ </span><span class="hljs-number"><span class="koboSpan" id="kobo.4867.1">42</span></span><span class="koboSpan" id="kobo.4868.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4869.1">"demo"</span></span><span class="koboSpan" id="kobo.4870.1"> };    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4871.1">// std::pair&lt;int, std::string&gt;</span></span><span class="koboSpan" id="kobo.4872.1">
std::pair  p2{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.4873.1">"demo"</span></span><span class="koboSpan" id="kobo.4874.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4875.1">42</span></span><span class="koboSpan" id="kobo.4876.1"> };    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4877.1">// std::pair&lt;std::string, int&gt;</span></span><span class="koboSpan" id="kobo.4878.1">
std::pair  p3{ </span><span class="hljs-string"><span class="koboSpan" id="kobo.4879.1">"42"</span></span><span class="koboSpan" id="kobo.4880.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4881.1">"demo"</span></span><span class="koboSpan" id="kobo.4882.1"> };  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4883.1">// std::pair&lt;std::string, std::string&gt;</span></span>
</code></pre>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.4884.1">As you can see from this example, deduction guides do not have to be function templates.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.4885.1">It is important to note that class template argument deduction does not occur if the template argument list is present, regardless of the number of specified arguments. </span><span class="koboSpan" id="kobo.4885.2">Examples of this are shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.4886.1">std::pair&lt;&gt;    p1 { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4887.1">42</span></span><span class="koboSpan" id="kobo.4888.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4889.1">"demo"</span></span><span class="koboSpan" id="kobo.4890.1"> };
std::pair&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.4891.1">int</span></span><span class="koboSpan" id="kobo.4892.1">&gt; p2 { </span><span class="hljs-number"><span class="koboSpan" id="kobo.4893.1">42</span></span><span class="koboSpan" id="kobo.4894.1">, </span><span class="hljs-string"><span class="koboSpan" id="kobo.4895.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.4896.1">demo"</span></span><span class="koboSpan" id="kobo.4897.1"> };
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.4898.1">Because both these declarations specify a template argument list, they are invalid and produce compiler errors.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.4899.1">There are some </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.4900.1">known cases where class template argument deduction does not work:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.4901.1">Aggregate templates, where you could write a user-defined deduction guide to circumvent the problem.
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4902.1">template</span></span><span class="koboSpan" id="kobo.4903.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4904.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4905.1">T</span></span><span class="koboSpan" id="kobo.4906.1">&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4907.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4908.1">Point3D</span></span><span class="koboSpan" id="kobo.4909.1"> { T x; T y; T z; }; 
 
Point3D p{</span><span class="hljs-number"><span class="koboSpan" id="kobo.4910.1">1</span></span><span class="koboSpan" id="kobo.4911.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4912.1">2</span></span><span class="koboSpan" id="kobo.4913.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.4914.1">2</span></span><span class="koboSpan" id="kobo.4915.1">};   </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4916.1">// error, requires Point3D&lt;int&gt;</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4917.1">Type aliases, as shown in the following example (for GCC, this actually works when compiling with </span><code class="inlineCode"><span class="koboSpan" id="kobo.4918.1">-std=c++20</span></code><span class="koboSpan" id="kobo.4919.1">):
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4920.1">template</span></span><span class="koboSpan" id="kobo.4921.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4922.1">typename</span></span><span class="koboSpan" id="kobo.4923.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4924.1">using</span></span><span class="koboSpan" id="kobo.4925.1"> my_vector = std::vector&lt;T&gt;;
std::vector v{</span><span class="hljs-number"><span class="koboSpan" id="kobo.4926.1">1</span></span><span class="koboSpan" id="kobo.4927.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4928.1">2</span></span><span class="koboSpan" id="kobo.4929.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4930.1">3</span></span><span class="koboSpan" id="kobo.4931.1">}; </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4932.1">// OK</span></span><span class="koboSpan" id="kobo.4933.1">
my_vector mv{</span><span class="hljs-number"><span class="koboSpan" id="kobo.4934.1">1</span></span><span class="koboSpan" id="kobo.4935.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4936.1">2</span></span><span class="koboSpan" id="kobo.4937.1">,</span><span class="hljs-number"><span class="koboSpan" id="kobo.4938.1">3</span></span><span class="koboSpan" id="kobo.4939.1">};  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4940.1">// error</span></span>
</code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.4941.1">Inherited </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.4942.1">constructors, because deduction guides, whether implicit or user-defined, are not inherited when constructors are inherited:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.4943.1">template</span></span><span class="koboSpan" id="kobo.4944.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4945.1">typename</span></span><span class="koboSpan" id="kobo.4946.1"> T&gt; 
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4947.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4948.1">box</span></span><span class="koboSpan" id="kobo.4949.1">
{
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4950.1">box</span></span><span class="koboSpan" id="kobo.4951.1">(T&amp;&amp; t) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4952.1">content</span></span><span class="koboSpan" id="kobo.4953.1">(std::forward&lt;T&gt;(t)) {}
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4954.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4955.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4956.1">unwrap</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4957.1">()</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4958.1">{ std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4959.1">"unwrapping "</span></span><span class="koboSpan" id="kobo.4960.1"> &lt;&lt; content &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4961.1">'\n'</span></span><span class="koboSpan" id="kobo.4962.1">; }
   T content;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4963.1">template</span></span><span class="koboSpan" id="kobo.4964.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4965.1">typename</span></span><span class="koboSpan" id="kobo.4966.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4967.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.4968.1">magic_box</span></span><span class="koboSpan" id="kobo.4969.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4970.1">public</span></span><span class="koboSpan" id="kobo.4971.1"> box&lt;T&gt;
{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4972.1">using</span></span><span class="koboSpan" id="kobo.4973.1"> box&lt;T&gt;::box;
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4974.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.4975.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4976.1">unwrap</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4977.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.4978.1">override</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.4979.1">{ std::cout &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4980.1">"unwrapping "</span></span><span class="koboSpan" id="kobo.4981.1"> &lt;&lt; box&lt;T&gt;::content &lt;&lt; </span><span class="hljs-string"><span class="koboSpan" id="kobo.4982.1">'\n'</span></span><span class="koboSpan" id="kobo.4983.1">; }
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.4984.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.4985.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4986.1">()</span></span><span class="koboSpan" id="kobo.4987.1">
{
   </span><span class="hljs-function"><span class="koboSpan" id="kobo.4988.1">box </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4989.1">b</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4990.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.4991.1">42</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.4992.1">)</span></span><span class="koboSpan" id="kobo.4993.1">;        </span><span class="hljs-comment"><span class="koboSpan" id="kobo.4994.1">// OK</span></span><span class="koboSpan" id="kobo.4995.1">
   b.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.4996.1">unwrap</span></span><span class="koboSpan" id="kobo.4997.1">();
   </span><span class="hljs-function"><span class="koboSpan" id="kobo.4998.1">magic_box </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.4999.1">m</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5000.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.5001.1">21</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5002.1">)</span></span><span class="koboSpan" id="kobo.5003.1">;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.5004.1">// error, requires magic_box&lt;int&gt;</span></span><span class="koboSpan" id="kobo.5005.1">
   m.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5006.1">unwrap</span></span><span class="koboSpan" id="kobo.5007.1">();
}
</span></code></pre>
</li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.5008.1">This </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.5009.1">latter limitation has been removed in C++23, where deduction guides are inherited when constructors are inherited.</span></p>
<h2 class="heading-2" id="_idParaDest-82"><span class="koboSpan" id="kobo.5010.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="italic"><span class="koboSpan" id="kobo.5011.1">Understanding uniform initialization</span></em><span class="koboSpan" id="kobo.5012.1">, to see how brace-initialization works</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-83"><span class="koboSpan" id="kobo.5013.1">Using the subscript operator to access elements in a collection</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5014.1">Accessing </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.5015.1">elements of an array is a basic feature not just in C++ but also in any programming language that supports arrays. </span><span class="koboSpan" id="kobo.5015.2">The syntax is also the same across many programming languages. </span><span class="koboSpan" id="kobo.5015.3">In C++, the subscript operator used for this purpose, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5016.1">[]</span></code><span class="koboSpan" id="kobo.5017.1">, can be overloaded to provide access to data in a class. </span><span class="koboSpan" id="kobo.5017.2">Typically, this is the case for classes that model containers. </span><span class="koboSpan" id="kobo.5017.3">In this recipe, we’ll see how to leverage this operator and what changes C++23 brings.</span></p>
<h2 class="heading-2" id="_idParaDest-84"><span class="koboSpan" id="kobo.5018.1">How to do it…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5019.1">To provide random access to elements in a container, overload the subscript operator as follows:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.5020.1">For one-dimensional containers, you can overload the subscript operator with one argument, regardless of the version of the standard:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5021.1">template</span></span><span class="koboSpan" id="kobo.5022.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5023.1">typename</span></span><span class="koboSpan" id="kobo.5024.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5025.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5026.1">some_buffer</span></span><span class="koboSpan" id="kobo.5027.1">
{
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5028.1">some_buffer</span></span><span class="koboSpan" id="kobo.5029.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.5030.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5031.1">const</span></span><span class="koboSpan" id="kobo.5032.1"> size):</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5033.1">data</span></span><span class="koboSpan" id="kobo.5034.1">(size)
   {}
   </span><span class="hljs-type"><span class="koboSpan" id="kobo.5035.1">size_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.5036.1">size</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5037.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5038.1">const</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.5039.1">{ </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5040.1">return</span></span><span class="koboSpan" id="kobo.5041.1"> data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5042.1">size</span></span><span class="koboSpan" id="kobo.5043.1">(); }
   T </span><span class="hljs-type"><span class="koboSpan" id="kobo.5044.1">const</span></span><span class="koboSpan" id="kobo.5045.1">&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5046.1">operator</span></span><span class="koboSpan" id="kobo.5047.1">[](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5048.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5049.1">const</span></span><span class="koboSpan" id="kobo.5050.1"> index) </span><span class="hljs-type"><span class="koboSpan" id="kobo.5051.1">const</span></span><span class="koboSpan" id="kobo.5052.1">
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5053.1">if</span></span><span class="koboSpan" id="kobo.5054.1">(index &gt;= data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5055.1">size</span></span><span class="koboSpan" id="kobo.5056.1">())
         std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5057.1">runtime_error</span></span><span class="koboSpan" id="kobo.5058.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5059.1">"invalid index"</span></span><span class="koboSpan" id="kobo.5060.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5061.1">return</span></span><span class="koboSpan" id="kobo.5062.1"> data[index];
   }
   T &amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5063.1">operator</span></span><span class="koboSpan" id="kobo.5064.1">[](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5065.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5066.1">const</span></span><span class="koboSpan" id="kobo.5067.1"> index)
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5068.1">if</span></span><span class="koboSpan" id="kobo.5069.1"> (index &gt;= data.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5070.1">size</span></span><span class="koboSpan" id="kobo.5071.1">())
         std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5072.1">runtime_error</span></span><span class="koboSpan" id="kobo.5073.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5074.1">"invalid index"</span></span><span class="koboSpan" id="kobo.5075.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5076.1">return</span></span><span class="koboSpan" id="kobo.5077.1"> data[index];
   }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5078.1">private</span></span><span class="koboSpan" id="kobo.5079.1">:
   std::vector&lt;T&gt; data;
};
</span></code></pre>
</li>
<li class="bulletList"><span class="koboSpan" id="kobo.5080.1">For</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.5081.1"> multidimensional containers, in C++23, you can overload the subscript operator with multiple arguments:
        </span><pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5082.1">template</span></span><span class="koboSpan" id="kobo.5083.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5084.1">typename</span></span><span class="koboSpan" id="kobo.5085.1"> T, </span><span class="hljs-type"><span class="koboSpan" id="kobo.5086.1">size_t</span></span><span class="koboSpan" id="kobo.5087.1"> ROWS, </span><span class="hljs-type"><span class="koboSpan" id="kobo.5088.1">size_t</span></span><span class="koboSpan" id="kobo.5089.1"> COLS&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5090.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5091.1">matrix</span></span><span class="koboSpan" id="kobo.5092.1">
{
   T&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5093.1">operator</span></span><span class="koboSpan" id="kobo.5094.1">[](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5095.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5096.1">const</span></span><span class="koboSpan" id="kobo.5097.1"> row, </span><span class="hljs-type"><span class="koboSpan" id="kobo.5098.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5099.1">const</span></span><span class="koboSpan" id="kobo.5100.1"> col)
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5101.1">if</span></span><span class="koboSpan" id="kobo.5102.1">(row &gt;= ROWS || col &gt;= COLS)
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5103.1">throw</span></span><span class="koboSpan" id="kobo.5104.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5105.1">runtime_error</span></span><span class="koboSpan" id="kobo.5106.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5107.1">"invalid index"</span></span><span class="koboSpan" id="kobo.5108.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5109.1">return</span></span><span class="koboSpan" id="kobo.5110.1"> data[row * COLS + col];
   }
   T </span><span class="hljs-type"><span class="koboSpan" id="kobo.5111.1">const</span></span><span class="koboSpan" id="kobo.5112.1"> &amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5113.1">operator</span></span><span class="koboSpan" id="kobo.5114.1">[](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5115.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5116.1">const</span></span><span class="koboSpan" id="kobo.5117.1"> row,                         </span><span class="hljs-type"><span class="koboSpan" id="kobo.5118.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5119.1">const</span></span><span class="koboSpan" id="kobo.5120.1"> col) </span><span class="hljs-type"><span class="koboSpan" id="kobo.5121.1">const</span></span><span class="koboSpan" id="kobo.5122.1">
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5123.1">if</span></span><span class="koboSpan" id="kobo.5124.1"> (row &gt;= ROWS || col &gt;= COLS)
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5125.1">throw</span></span><span class="koboSpan" id="kobo.5126.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5127.1">runtime_error</span></span><span class="koboSpan" id="kobo.5128.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5129.1">"invalid index"</span></span><span class="koboSpan" id="kobo.5130.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5131.1">return</span></span><span class="koboSpan" id="kobo.5132.1"> data[row * COLS + col];
   }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5133.1">private</span></span><span class="koboSpan" id="kobo.5134.1">:
   std::array&lt;T, ROWS* COLS&gt; data;
};
</span></code></pre>
</li>
</ul>
<h2 class="heading-2" id="_idParaDest-85"><span class="koboSpan" id="kobo.5135.1">How it works…</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.5136.1">The subscript operator is used to access elements in an array. </span><span class="koboSpan" id="kobo.5136.2">However, it is possible to overload it as a member function in classes typically modeling containers (or collections in general) to access its elements. </span><span class="koboSpan" id="kobo.5136.3">Standard containers such as </span><code class="inlineCode"><span class="koboSpan" id="kobo.5137.1">std::vector</span></code><span class="koboSpan" id="kobo.5138.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.5139.1">std::set</span></code><span class="koboSpan" id="kobo.5140.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.5141.1">std::map</span></code><span class="koboSpan" id="kobo.5142.1"> provide overloads for the subscript operator for this purpose. </span><span class="koboSpan" id="kobo.5142.2">Therefore, you can write code as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.5143.1">std::vector&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5144.1">int</span></span><span class="koboSpan" id="kobo.5145.1">&gt; v {</span><span class="hljs-number"><span class="koboSpan" id="kobo.5146.1">1</span></span><span class="koboSpan" id="kobo.5147.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5148.1">2</span></span><span class="koboSpan" id="kobo.5149.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5150.1">3</span></span><span class="koboSpan" id="kobo.5151.1">};
v[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5152.1">2</span></span><span class="koboSpan" id="kobo.5153.1">] = v[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5154.1">1</span></span><span class="koboSpan" id="kobo.5155.1">] + v[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5156.1">0</span></span><span class="koboSpan" id="kobo.5157.1">];
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5158.1">In the previous section, we saw how the subscript operator can be overloaded. </span><span class="koboSpan" id="kobo.5158.2">There are typically two overloads, one that is constant and one that is mutable. </span><span class="koboSpan" id="kobo.5158.3">The const-qualified overload returns a reference to a constant object, while the mutable overload returns a reference.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5159.1">The major</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.5160.1"> problem with the subscript operator was that, prior to C++23, it could only have one parameter. </span><span class="koboSpan" id="kobo.5160.2">Therefore, it could not be used to provide access to elements of a multidimensional container. </span><span class="koboSpan" id="kobo.5160.3">As a result, developers usually resorted to using the call operator for this purpose. </span><span class="koboSpan" id="kobo.5160.4">An example is shown in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5161.1">template</span></span><span class="koboSpan" id="kobo.5162.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5163.1">typename</span></span><span class="koboSpan" id="kobo.5164.1"> T, </span><span class="hljs-type"><span class="koboSpan" id="kobo.5165.1">size_t</span></span><span class="koboSpan" id="kobo.5166.1"> ROWS, </span><span class="hljs-type"><span class="koboSpan" id="kobo.5167.1">size_t</span></span><span class="koboSpan" id="kobo.5168.1"> COLS&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5169.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5170.1">matrix</span></span><span class="koboSpan" id="kobo.5171.1">
{
   </span><span class="hljs-function"><span class="koboSpan" id="kobo.5172.1">T&amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5173.1">operator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5174.1">()(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5175.1">size_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5176.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5177.1"> row, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5178.1">size_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5179.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5180.1"> col)</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.5181.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5182.1">if</span></span><span class="koboSpan" id="kobo.5183.1">(row &gt;= ROWS || col &gt;= COLS)
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5184.1">throw</span></span><span class="koboSpan" id="kobo.5185.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5186.1">runtime_error</span></span><span class="koboSpan" id="kobo.5187.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5188.1">"invalid index"</span></span><span class="koboSpan" id="kobo.5189.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5190.1">return</span></span><span class="koboSpan" id="kobo.5191.1"> data[row * COLS + col];
   }
   </span><span class="hljs-function"><span class="koboSpan" id="kobo.5192.1">T </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5193.1">const</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.5194.1"> &amp; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.5195.1">operator</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5196.1">()(</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5197.1">size_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5198.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5199.1"> row, </span></span><span class="hljs-type"><span class="koboSpan" id="kobo.5200.1">size_t</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5201.1">const</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.5202.1"> col)</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.5203.1">const</span></span>
<span class="hljs-function"> </span><span class="koboSpan" id="kobo.5204.1">{
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5205.1">if</span></span><span class="koboSpan" id="kobo.5206.1"> (row &gt;= ROWS || col &gt;= COLS)
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5207.1">throw</span></span><span class="koboSpan" id="kobo.5208.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5209.1">runtime_error</span></span><span class="koboSpan" id="kobo.5210.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5211.1">"invalid index"</span></span><span class="koboSpan" id="kobo.5212.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5213.1">return</span></span><span class="koboSpan" id="kobo.5214.1"> data[row * COLS + col];
   }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5215.1">private</span></span><span class="koboSpan" id="kobo.5216.1">:
   std::array&lt;T, ROWS* COLS&gt; data;
};
matrix&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5217.1">int</span></span><span class="koboSpan" id="kobo.5218.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5219.1">2</span></span><span class="koboSpan" id="kobo.5220.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5221.1">3</span></span><span class="koboSpan" id="kobo.5222.1">&gt; m;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5223.1">m</span></span><span class="koboSpan" id="kobo.5224.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.5225.1">0</span></span><span class="koboSpan" id="kobo.5226.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5227.1">0</span></span><span class="koboSpan" id="kobo.5228.1">) = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5229.1">1</span></span><span class="koboSpan" id="kobo.5230.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5231.1">To help with this, and allow a more consistent approach, C++11 made it possible to use the subscript operator with the syntax </span><code class="inlineCode"><span class="koboSpan" id="kobo.5232.1">[{expr1, expr2, …}]</span></code><span class="koboSpan" id="kobo.5233.1">. </span><span class="koboSpan" id="kobo.5233.2">A modified implementation of </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.5234.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5235.1">matrix</span></code><span class="koboSpan" id="kobo.5236.1"> class that leverages this syntax is shown next:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5237.1">template</span></span><span class="koboSpan" id="kobo.5238.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5239.1">typename</span></span><span class="koboSpan" id="kobo.5240.1"> T, </span><span class="hljs-type"><span class="koboSpan" id="kobo.5241.1">size_t</span></span><span class="koboSpan" id="kobo.5242.1"> ROWS, </span><span class="hljs-type"><span class="koboSpan" id="kobo.5243.1">size_t</span></span><span class="koboSpan" id="kobo.5244.1"> COLS&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5245.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5246.1">matrix</span></span><span class="koboSpan" id="kobo.5247.1">
{
   T&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5248.1">operator</span></span><span class="koboSpan" id="kobo.5249.1">[](std::initializer_list&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5250.1">size_t</span></span><span class="koboSpan" id="kobo.5251.1">&gt; index)
   {
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.5252.1">size_t</span></span><span class="koboSpan" id="kobo.5253.1"> row = *index.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5254.1">begin</span></span><span class="koboSpan" id="kobo.5255.1">();
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.5256.1">size_t</span></span><span class="koboSpan" id="kobo.5257.1"> col = *(index.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5258.1">begin</span></span><span class="koboSpan" id="kobo.5259.1">() + </span><span class="hljs-number"><span class="koboSpan" id="kobo.5260.1">1</span></span><span class="koboSpan" id="kobo.5261.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5262.1">if</span></span><span class="koboSpan" id="kobo.5263.1"> (row &gt;= ROWS || col &gt;= COLS)
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5264.1">throw</span></span><span class="koboSpan" id="kobo.5265.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5266.1">runtime_error</span></span><span class="koboSpan" id="kobo.5267.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5268.1">"invalid index"</span></span><span class="koboSpan" id="kobo.5269.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5270.1">return</span></span><span class="koboSpan" id="kobo.5271.1"> data[row * COLS + col];
   }
   T </span><span class="hljs-type"><span class="koboSpan" id="kobo.5272.1">const</span></span><span class="koboSpan" id="kobo.5273.1"> &amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5274.1">operator</span></span><span class="koboSpan" id="kobo.5275.1">[](std::initializer_list&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5276.1">size_t</span></span><span class="koboSpan" id="kobo.5277.1">&gt; index) </span><span class="hljs-type"><span class="koboSpan" id="kobo.5278.1">const</span></span><span class="koboSpan" id="kobo.5279.1">
   {
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.5280.1">size_t</span></span><span class="koboSpan" id="kobo.5281.1"> row = *index.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5282.1">begin</span></span><span class="koboSpan" id="kobo.5283.1">();
      </span><span class="hljs-type"><span class="koboSpan" id="kobo.5284.1">size_t</span></span><span class="koboSpan" id="kobo.5285.1"> col = *(index.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5286.1">begin</span></span><span class="koboSpan" id="kobo.5287.1">() + </span><span class="hljs-number"><span class="koboSpan" id="kobo.5288.1">1</span></span><span class="koboSpan" id="kobo.5289.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5290.1">if</span></span><span class="koboSpan" id="kobo.5291.1"> (row &gt;= ROWS || col &gt;= COLS)
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5292.1">throw</span></span><span class="koboSpan" id="kobo.5293.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5294.1">runtime_error</span></span><span class="koboSpan" id="kobo.5295.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5296.1">"invalid index"</span></span><span class="koboSpan" id="kobo.5297.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5298.1">return</span></span><span class="koboSpan" id="kobo.5299.1"> data[row * COLS + col];
   }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5300.1">private</span></span><span class="koboSpan" id="kobo.5301.1">:
   std::array&lt;T, ROWS* COLS&gt; data;
};
matrix&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5302.1">int</span></span><span class="koboSpan" id="kobo.5303.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5304.1">2</span></span><span class="koboSpan" id="kobo.5305.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5306.1">3</span></span><span class="koboSpan" id="kobo.5307.1">&gt; m;
m[{</span><span class="hljs-number"><span class="koboSpan" id="kobo.5308.1">0</span></span><span class="koboSpan" id="kobo.5309.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5310.1">0</span></span><span class="koboSpan" id="kobo.5311.1">}] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5312.1">1</span></span><span class="koboSpan" id="kobo.5313.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5314.1">However, the syntax is rather cumbersome and was probably rarely used in practice. </span><span class="koboSpan" id="kobo.5314.2">For this reason, the C++23 standard makes it possible to overload the subscript operator using multiple parameters. </span><span class="koboSpan" id="kobo.5314.3">A modified </span><code class="inlineCode"><span class="koboSpan" id="kobo.5315.1">matrix</span></code><span class="koboSpan" id="kobo.5316.1"> class is shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.5317.1">template</span></span><span class="koboSpan" id="kobo.5318.1"> &lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5319.1">typename</span></span><span class="koboSpan" id="kobo.5320.1"> T, </span><span class="hljs-type"><span class="koboSpan" id="kobo.5321.1">size_t</span></span><span class="koboSpan" id="kobo.5322.1"> ROWS, </span><span class="hljs-type"><span class="koboSpan" id="kobo.5323.1">size_t</span></span><span class="koboSpan" id="kobo.5324.1"> COLS&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5325.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.5326.1">matrix</span></span><span class="koboSpan" id="kobo.5327.1">
{
   T&amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5328.1">operator</span></span><span class="koboSpan" id="kobo.5329.1">[](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5330.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5331.1">const</span></span><span class="koboSpan" id="kobo.5332.1"> row, </span><span class="hljs-type"><span class="koboSpan" id="kobo.5333.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5334.1">const</span></span><span class="koboSpan" id="kobo.5335.1"> col)
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5336.1">if</span></span><span class="koboSpan" id="kobo.5337.1">(row &gt;= ROWS || col &gt;= COLS)
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5338.1">throw</span></span><span class="koboSpan" id="kobo.5339.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5340.1">runtime_error</span></span><span class="koboSpan" id="kobo.5341.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5342.1">"invalid index"</span></span><span class="koboSpan" id="kobo.5343.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5344.1">return</span></span><span class="koboSpan" id="kobo.5345.1"> data[row * COLS + col];
   }
   T </span><span class="hljs-type"><span class="koboSpan" id="kobo.5346.1">const</span></span><span class="koboSpan" id="kobo.5347.1"> &amp; </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5348.1">operator</span></span><span class="koboSpan" id="kobo.5349.1">[](</span><span class="hljs-type"><span class="koboSpan" id="kobo.5350.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5351.1">const</span></span><span class="koboSpan" id="kobo.5352.1"> row, </span><span class="hljs-type"><span class="koboSpan" id="kobo.5353.1">size_t</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.5354.1">const</span></span><span class="koboSpan" id="kobo.5355.1"> col) </span><span class="hljs-type"><span class="koboSpan" id="kobo.5356.1">const</span></span><span class="koboSpan" id="kobo.5357.1">
   {
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5358.1">if</span></span><span class="koboSpan" id="kobo.5359.1"> (row &gt;= ROWS || col &gt;= COLS)
         </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5360.1">throw</span></span><span class="koboSpan" id="kobo.5361.1"> std::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.5362.1">runtime_error</span></span><span class="koboSpan" id="kobo.5363.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.5364.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.5365.1">invalid index"</span></span><span class="koboSpan" id="kobo.5366.1">);
      </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5367.1">return</span></span><span class="koboSpan" id="kobo.5368.1"> data[row * COLS + col];
   }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5369.1">private</span></span><span class="koboSpan" id="kobo.5370.1">:
   std::array&lt;T, ROWS* COLS&gt; data;
};
matrix&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5371.1">int</span></span><span class="koboSpan" id="kobo.5372.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5373.1">2</span></span><span class="koboSpan" id="kobo.5374.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5375.1">3</span></span><span class="koboSpan" id="kobo.5376.1">&gt; m;
m[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5377.1">0</span></span><span class="koboSpan" id="kobo.5378.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5379.1">0</span></span><span class="koboSpan" id="kobo.5380.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5381.1">1</span></span><span class="koboSpan" id="kobo.5382.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.5383.1">This makes the calling syntax consistent with accessing one-dimensional containers. </span><span class="koboSpan" id="kobo.5383.2">This is used by </span><code class="inlineCode"><span class="koboSpan" id="kobo.5384.1">std::mdspan</span></code><span class="koboSpan" id="kobo.5385.1"> to provide element access. </span><span class="koboSpan" id="kobo.5385.2">This is a new C++23 class that represents a non-owning view into a contiguous sequence (such as an array), but it reinterprets the sequence as a multidimensional array.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.5386.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.5387.1">matrix</span></code><span class="koboSpan" id="kobo.5388.1"> class shown previously can actually be replaced with an </span><code class="inlineCode"><span class="koboSpan" id="kobo.5389.1">mdspan</span></code><span class="koboSpan" id="kobo.5390.1"> view over an array, as shown</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.5391.1"> in the following snippet:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.5392.1">int</span></span><span class="koboSpan" id="kobo.5393.1"> data[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5394.1">2</span></span><span class="koboSpan" id="kobo.5395.1">*</span><span class="hljs-number"><span class="koboSpan" id="kobo.5396.1">3</span></span><span class="koboSpan" id="kobo.5397.1">] = {};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.5398.1">auto</span></span><span class="koboSpan" id="kobo.5399.1"> m = std::mdspan&lt;</span><span class="hljs-type"><span class="koboSpan" id="kobo.5400.1">int</span></span><span class="koboSpan" id="kobo.5401.1">, std::extents&lt;</span><span class="hljs-number"><span class="koboSpan" id="kobo.5402.1">2</span></span><span class="koboSpan" id="kobo.5403.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5404.1">3</span></span><span class="koboSpan" id="kobo.5405.1">&gt;&gt; (data);
m[</span><span class="hljs-number"><span class="koboSpan" id="kobo.5406.1">0</span></span><span class="koboSpan" id="kobo.5407.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.5408.1">0</span></span><span class="koboSpan" id="kobo.5409.1">] = </span><span class="hljs-number"><span class="koboSpan" id="kobo.5410.1">1</span></span><span class="koboSpan" id="kobo.5411.1">;
</span></code></pre>
<h2 class="heading-2" id="_idParaDest-86"><span class="koboSpan" id="kobo.5412.1">See also</span></h2>
<ul>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.5413.1">Chapter 5</span></em><span class="koboSpan" id="kobo.5414.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5415.1">Writing your own random-access iterator</span></em><span class="koboSpan" id="kobo.5416.1">, to see how you can write an iterator for accessing the elements of a container</span></li>
<li class="bulletList"><em class="chapterRef"><span class="koboSpan" id="kobo.5417.1">Chapter 6</span></em><span class="koboSpan" id="kobo.5418.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5419.1">Using std::mdspan for multidimensional views of sequences of objects</span></em><span class="koboSpan" id="kobo.5420.1">, to learn more about the </span><code class="inlineCode"><span class="koboSpan" id="kobo.5421.1">std::mdspan</span></code><span class="koboSpan" id="kobo.5422.1"> class</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.5423.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.5424.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="Chapter_01.xhtml"><span class="url"><span class="koboSpan" id="kobo.5425.1">https://discord.gg/7xRaTCeEhx</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.5426.1"><img alt="" src="../Images/QR_Code2659294082093549796.png"/></span></p>
</div>
</body></html>