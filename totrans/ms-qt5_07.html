<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7.    Third-Party Libraries Without a Headache   </h1></div></div></div><p>In previous chapters, we have used our own libraries or the ones provided by Qt. In this chapter, we will learn how to integrate the third-party library OpenCV with a Qt project. This library will give you an impressive image processing toolbox. For each platform, you will learn to use a different specific compiler link configuration.</p><p>Qt Designer is a powerful WYSIWYG editor. This is why this chapter will also teach you to build a Qt Designer plugin that can be dragged and dropped from the <strong>Widget Box</strong> to the <strong>Form Editor</strong>, and then configured directly from Qt Creator.</p><p>In the example project, the user can load a picture, select a filter from thumbnail previews, and save the result. This application will rely on OpenCV functions for image processing.</p><p>This chapter will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Prepare a cross-platform project to host a third-party library</li><li class="listitem">Link with a third party library</li><li class="listitem">Build a custom <code class="literal">QWidget</code> class using Qt Designer plugins</li><li class="listitem">How the OpenCV API can work with Qt</li><li class="listitem">Create a Qt application that relies on a custom <code class="literal">QWidget</code> class</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Creating your Qt Designer plugin</h1></div></div></div><p>In <a class="link" title="Chapter 4.  Conquering the Desktop UI" href="part0040.xhtml#aid-164MG2">Chapter 4</a>, <em>Conquering the Desktop UI</em>, we created a custom Qt widget in Qt Designer using the promoting technique. It is now time to learn how to create a custom Qt widget by building a plugin for Qt Designer. Your widget will be available from the <strong>Design mode</strong> in the <strong>Widget Box</strong> alongside other regular Qt widgets. For this project example, we will create a <code class="literal">FilterWidget</code> class that processes an input image to apply a filter. The widget will also display the filter name and a dynamic thumbnail of the filtered picture.</p><p>This project is composed of two sub-projects:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">filter-plugin-designer</code>: This is a Qt Designer plugin containing <code class="literal">FilterWidget</code> class and the image processing code. This plugin is a dynamic library that will be used by the Qt Creator to offer our new <code class="literal">FilterWidget</code> in the <strong>Form Editor</strong>.</li><li class="listitem"><code class="literal">image-filter</code>: This is a Qt Widget application using multiple <code class="literal">FilterWidget</code>. The user can open an image from their hard disk, select a filter (grayscale, blur, and so on), and save the filtered image.</li></ul></div><p>Our <code class="literal">filter-plugin-designer</code> will use the third-party library <strong>OpenCV</strong> (<strong>Open Source Computer Vision</strong>). It is a powerful, cross-platform open source library to manipulate images. Here is an overview schema:</p><div><img src="img/image00407.jpeg" alt="Creating your Qt Designer plugin"/></div><p style="clear:both; height: 1em;"> </p><p>You can see a plugin as a kind of module, which can be easily added to an existing software. A plugin must respect a specific interface to be automatically called by the application. In our case, the Qt Designer is the application that loads Qt plugins. So creating a plugin allows us to enhance the application without the need to modify the Qt Designer source code and recompile it. A plugin is a generally dynamic library (<code class="literal">.dll</code>/<code class="literal">.so</code>), so it will be loaded at runtime by the application.</p><p>Now that you have a clear mind about the Qt Designer plugins, let's build one! First, create a <code class="literal">Subdirs</code> project called <code class="literal">ch07-image-filter</code>. Then, you can add a subproject, <code class="literal">filter-plugin-designer</code>. You can use the <strong>Empty qmake Project</strong> template because we start this project from scratch. Here is the <code class="literal">filter-plugin-designer.pro</code> file:</p><pre class="programlisting">QT += widgets uiplugin 
CONFIG += plugin 
CONFIG += c++14 
TEMPLATE = lib 
DEFINES += FILTERPLUGINDESIGNER_LIBRARY 
 
TARGET = $$qtLibraryTarget($$TARGET) 
INSTALLS += target 
</pre><p>Please note the <code class="literal">uiplugin</code> and <code class="literal">plugin</code> keywords for <code class="literal">QT</code> and <code class="literal">CONFIG</code>. They are required to create a Qt Designer plugin. We set the <code class="literal">TEMPLATE</code> keyword to <code class="literal">lib</code> because we are creating a dynamic library. The define, <code class="literal">FILTERPLUGINDESIGNER_LIBRARY</code>, will be used by the import/export mechanism of the library. We already covered this topic in <a class="link" title="Chapter 3.  Dividing Your Project and Ruling Your Code" href="part0034.xhtml#aid-10DJ42">Chapter 3</a>, <em>Dividing Your Project and Ruling Your Code</em>. By default, our <code class="literal">TARGET</code> is <code class="literal">filter-plugin-designer</code>; the <code class="literal">$$qtLibraryTarget()</code> function will update it according to your platform. For example, the suffix "d" (standing for debug) will be appended on Windows. Finally, we append <code class="literal">target</code> to <code class="literal">INSTALLS</code>. Right now, this line does nothing, but we will describe a destination path for each platform soon; this way, executing the <code class="literal">make install</code> command will copy our target library file (<code class="literal">.dll</code>/<code class="literal">.so</code>) into the correct folder. To automatically perform this task on each compilation, you can add a new build step.</p><p>The deploy path is configured, but it will not be done automatically. Open the <strong>Projects</strong> tab and do the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <strong>Build Settings</strong> | <strong>Build Steps</strong>.</li><li class="listitem">Click on <strong>Add Build Step</strong> | <strong>Make</strong>.</li><li class="listitem">In the <strong>Make arguments</strong> field, type <code class="literal">install</code>.</li></ol><div></div><p>You should get something like this:</p><div><img src="img/image00408.jpeg" alt="Creating your Qt Designer plugin"/></div><p style="clear:both; height: 1em;"> </p><p>Each time you build the project, the <code class="literal">make install</code> command will be called and it will deploy the library in Qt Creator.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Configuring the project for Windows</h1></div></div></div><p>Before preparing this project on Windows, let's talk about the available choices when you develop a Qt application on a Windows host. The official Qt website provides multiple binary packages. We are mainly interested in the following:</p><div><ul class="itemizedlist"><li class="listitem">Qt for Windows 32-bit (MinGW)</li><li class="listitem">Qt for Windows 32-bit (VS 2013)</li></ul></div><p>You may already be using one of these versions. The first one comes with a MinGW GCC compiler and the Qt framework. The second only provides the Qt framework and relies on the Microsoft Visual C++ compiler that will be installed with Visual Studio.</p><p>Both versions are fine when you want to create a common Qt application for Windows. However, for this chapter, we want to link our <code class="literal">filter-plugin-designer</code> project with OpenCV libraries. Qt Designer must also be able to dynamically load <code class="literal">filter-plugin-designer</code>, so we must use a consistent compiler version at all stages.</p><p>Please note that Qt Creator on Windows is always based on MSVC, even in the MinGW binary package! So if you create a Qt Designer plugin using a MinGW compiler, your Qt Creator will not be able to load it. OpenCV for Windows provides only MSVC libraries, compile for MSVC11 (which is VS 2012), and MSVC12 (VS 2013).</p><p>Here is a summary of the different solutions for building our project example in Windows:</p><div><img src="img/image00409.jpeg" alt="Configuring the project for Windows"/></div><p style="clear:both; height: 1em;"> </p><p>Keep in mind that for open-source software such as Qt Creator and OpenCV you can always try to compile them from a source with a different compiler. So, if you absolutely want to use a MinGW compiler, you must recompile OpenCV and Qt Creator from sources. Otherwise, we suggest that you use Qt for Windows 32-bit (VS 2013) as explained shortly. Here are the steps to prepare your development environment:</p><div><ol class="orderedlist arabic"><li class="listitem">Download and install Visual Studio Community Edition.</li><li class="listitem">Download and install Qt for Windows 32-bit (VS 2013).</li><li class="listitem">Download and extract OpenCV for Windows (for example: <code class="literal">C:\lib\opencv</code>).</li><li class="listitem">Create a new <code class="literal">OPENCV_HOME</code>: <code class="literal">C:\lib\opencv\build\x86\vc12</code> environment variable.</li><li class="listitem">Append to your system <code class="literal">Path</code>: <code class="literal">C:\lib\opencv\build\x86\vc12\bin</code> environment variable.</li></ol><div></div><p>The <code class="literal">OPENCV_HOME</code> directory will be used in our <code class="literal">.pro</code> file. We also add an OpenCV libraries folder to the <code class="literal">Path</code> directory to easily resolve the dependencies at runtime.</p><p>You can now add the following snippet to the <code class="literal">filter-plugin-designer.pro</code> file:</p><pre class="programlisting">windows { 
target.path = $$(QTDIR)/../../Tools/QtCreator/bin/plugins/designer 
 
debug:target_lib.files = $$OUT_PWD/debug/$${TARGET}.lib 
release:target_lib.files = $$OUT_PWD/release/$${TARGET}.lib 
target_lib.path = $$(QTDIR)/../../Tools/QtCreator/bin/plugins/designer 
    INSTALLS += target_lib 
 
    INCLUDEPATH += $$(OPENCV_HOME)/../../include 
    LIBS += -L$$(OPENCV_HOME)/lib 
        -lopencv_core2413 
        -lopencv_imgproc2413 
} 
</pre><p>The <code class="literal">target</code> path is set to the Qt Creator plugin folder. We also create a <code class="literal">target_lib</code> library to copy the <code class="literal">.lib</code> file generated by MSVC when we make a dynamic library (<code class="literal">.dll</code>). We add the OpenCV headers folder to the <code class="literal">INCLUDEPATH</code> to easily include them in our code. Finally, we update <code class="literal">LIBS</code> variable to link our plugin with the OpenCV modules (<code class="literal">core</code> and <code class="literal">imgproc</code>) from the OpenCV <code class="literal">lib</code> folder.</p><p>Please note that the standalone Qt Designer application and the Qt Creator are different software. Both programs use a different plugin path. In our case, we only used the form editor from the Qt Creator, so we are targeting the Qt Creator plugin path.</p><p>Just as we appended <code class="literal">target</code> and <code class="literal">target_lib</code> to <code class="literal">INSTALLS</code>, both <code class="literal">.dll</code> and <code class="literal">.lib</code> files will be copied in the Qt Creator plugin path on a <code class="literal">make install</code> command. Qt Creator only requires the <code class="literal">.dll</code> file to load the plugin at runtime. The <code class="literal">.lib</code> file is only used to resolve the links with <code class="literal">filter-plugin-designer</code> when building our <code class="literal">image-filter</code> application. For simplicity, we are using the same directory.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Configuring the project for Linux</h1></div></div></div><p>OpenCV binaries are certainly available in official software repositories. Depending on your distribution and your package manager, you can install it with commands such as the following:</p><pre class="programlisting">
<strong>apt-get install libopencv</strong>
<strong>yum install opencv</strong>
</pre><p>When OpenCV is installed on your Linux, you can add this snippet to the <code class="literal">filter-plugin-designer.pro</code> file:</p><pre class="programlisting">linux { 
target.path = $$(QTDIR)/../../Tools/QtCreator/lib/Qt/plugins/designer/ 
 
    CONFIG += link_pkgconfig 
    PKGCONFIG += opencv 
} 
</pre><p>This time we do not use the <code class="literal">LIBS</code> variable but <code class="literal">PKGCONFIG</code>, which relies on <code class="literal">pkg-config</code>. It is a helper tool that will insert the correct options into the compile command line. In our case, we will request <code class="literal">pkg-config</code> to link our project with OpenCV.</p><div><h3 class="title"><a id="note35"/>Note</h3><p>You can list all the libs managed by <code class="literal">pkg-config</code> with the <code class="literal">pkg-config --list-all</code> command.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Configuring the project for Mac</h1></div></div></div><p>The first step in making the project work on Mac OS is to install OpenCV. Fortunately, this is very easy using the <code class="literal">brew</code> command. If you develop on Mac OS and do not use it already, you should download it right now. In a nutshell, <code class="literal">brew</code> is an alternate package manager that gives you access to many packages (for developers and non-developers) that are not available on the Mac App Store.</p><div><h3 class="title"><a id="note36"/>Note</h3><p>You can download and install brew from <a class="ulink" href="http://brew.sh/">http://brew.sh/</a>.</p></div><p>In a terminal, simply type the following command:</p><pre class="programlisting">
<strong>brew install opencv</strong>
</pre><p>This will download, compile, and install OpenCV on your machine. At the time of writing, the latest OpenCV version available on brew was version 2.4.13. Once this is done, open <code class="literal">filter-plugin-designer.pro</code> and add the following block:</p><pre class="programlisting">macx { 
target.path = "$$(QTDIR)/../../QtCreator.app/Contents/PlugIns/designer/" 
target_lib.files = $$OUT_PWD/lib$${TARGET}.dylib 
target_lib.path = "$$(QTDIR)/../../QtCreator.app/Contents/PlugIns/designer/" 
    INSTALLS += target_lib 
 
    INCLUDEPATH += /usr/local/Cellar/opencv/2.4.13/include/ 
 
    LIBS += -L/usr/local/lib \ 
         -lopencv_core \ 
        -lopencv_imgproc 
} 
</pre><p>We add OpenCV headers and link the path with <code class="literal">INCLUDEPATH</code> and <code class="literal">LIBS</code> variables. The <code class="literal">target</code> definition and <code class="literal">INSTALLS</code> are used to automatically deploy the output shared object to the Qt Creator application plugins directory.</p><p>The last thing we have to do is to add an environment variable to let the Qt Creator know where it will find the library that will link it to the final application. In the <strong>Projects</strong> tab, go through the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <strong>Details</strong> window in <strong>Build Environment</strong>.</li><li class="listitem">Click on the <strong>Add</strong> Button.</li><li class="listitem">Type <code class="literal">DYLD_LIBRARY_PATH</code> in the <code class="literal">&lt;VARIABLE&gt;</code> field.</li><li class="listitem">Type the path of the build directory in <code class="literal">&lt;VALUE&gt;</code> (you can copy and paste it from the section <strong>General</strong> | <strong>Build directory</strong>).</li></ol><div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Implementing your OpenCV filters</h1></div></div></div><p>Now that your development environment is ready, we can begin the fun part! We will implement three filters using OpenCV:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">FilterOriginal</code>: This filter does nothing and returns the same picture (lazy!)</li><li class="listitem"><code class="literal">FilterGrayscale</code>: This filter converts a picture from color to grayscale</li><li class="listitem"><code class="literal">FilterBlur</code>: This filter smoothes the picture</li></ul></div><p>The parent class of all these filters is <code class="literal">Filter</code>. Here is this abstract class:</p><pre class="programlisting">//Filter.h 
class Filter 
{ 
public: 
Filter(); 
virtual ~Filter(); 
 
virtualQImage process(constQImage&amp; image) = 0; 
}; 
 
//Filter.cpp 
Filter::Filter() {} 
Filter::~Filter() {} 
</pre><p>As you can see, <code class="literal">process()</code> is a pure abstract method. All filters will implement a specific behavior with this function. Let's begin with the simple <code class="literal">FilterOriginal</code> class. Here is <code class="literal">FilterOriginal.h</code>:</p><pre class="programlisting">class FilterOriginal : public Filter 
{ 
public: 
FilterOriginal(); 
    ~FilterOriginal(); 
 
QImageprocess(constQImage&amp; image) override; 
}; 
</pre><p>This class inherits <code class="literal">Filter</code> and we override the  <code class="literal">process()</code> function. The implementation is also really simple. Fill <code class="literal">FilterOriginal.cpp</code> with the following:</p><pre class="programlisting">FilterOriginal::FilterOriginal() : 
Filter() 
{ 
} 
 
FilterOriginal::~FilterOriginal() 
{ 
} 
 
QImageFilterOriginal::process(constQImage&amp; image) 
{ 
return image; 
} 
</pre><p>No modification is performed; we return the same picture. Now that the filter structure is clear, we can create <code class="literal">FilterGrayscale</code>. The <code class="literal">.h</code>/<code class="literal">.cpp</code> files are close to <code class="literal">FilterOriginalFilter</code>, so let's jump to the <code class="literal">process()</code> function of <code class="literal">FilterGrayscale.cpp</code>:</p><pre class="programlisting">QImageFilterGrayscale::process(constQImage&amp; image) 
{ 
    // QImage =&gt; cv::mat 
cv::Mattmp(image.height(), 
image.width(), 
                CV_8UC4, 
                (uchar*)image.bits(), 
image.bytesPerLine()); 
 
cv::MatresultMat; 
    cv::cvtColor(tmp, resultMat, CV_BGR2GRAY); 
 
    // cv::mat =&gt;QImage 
QImageresultImage((constuchar *) resultMat.data, 
resultMat.cols, 
resultMat.rows, 
resultMat.step, 
QImage::Format_Grayscale8); 
returnresultImage.copy(); 
} 
</pre><p>In the Qt framework, we use the <code class="literal">QImage</code> class to manipulate pictures. In the OpenCV world, we use the <code class="literal">Mat</code> class, so the first step is to create a correct <code class="literal">Mat</code> object from the <code class="literal">QImage</code> source. OpenCV and Qt both handle many image formats. An image format describes the data bytes organization with information such as the following:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">Channel count</code>: A grayscale picture only needs one channel (white intensity), while a color picture requires three channels (red, green, and blue). You will even need four channels to handle the opacity (alpha) pixel information.</li><li class="listitem"><code class="literal">Bit depth</code>: The number of bits used to store a pixel color.</li><li class="listitem"><code class="literal">Channel order</code>: The most common orders are RGB and BGR. Alpha can be placed before or after the color information.</li></ul></div><p>For example, the OpenCV image format, <code class="literal">CV_8UC4</code>, means four channels of unsigned 8-bit, which is the perfect fit for an alpha color picture. In our case, we are using a compatible Qt and OpenCV image format to convert our <code class="literal">QImage</code> in <code class="literal">Mat</code>. Here is a little summary:</p><div><img src="img/image00410.jpeg" alt="Implementing your OpenCV filters"/></div><p style="clear:both; height: 1em;"> </p><p>Please note that some <code class="literal">QImage</code> class formats also depend on your platform endianness. The preceding table is for a little endian system. For OpenCV, the order is always the same: <code class="literal">BGRA</code>. It is not required in our project example, but you can swap blue and red channels as follows:</p><pre class="programlisting">// with OpenCV 
cv::cvtColor(mat, mat, CV_BGR2RGB); 
 
// with Qt 
QImage swapped = image.rgbSwapped(); 
</pre><p>OpenCV <code class="literal">Mat</code> and Qt <code class="literal">QImage</code> classes perform shallow construction/copy by default. This means that only metadata is really copied; the pixel data is shared. To create a deep copy of a picture, you must call the <code class="literal">copy()</code> function:</p><pre class="programlisting">// with OpenCV 
mat.clone(); 
 
// with Qt 
image.copy(); 
</pre><p>We created a <code class="literal">Mat</code> class called <code class="literal">tmp</code> from the <code class="literal">QImage</code> class. Note that <code class="literal">tmp</code> is not a deep copy of <code class="literal">image</code>; they share the same data pointer. Then, we can call the OpenCV function to convert the picture from color to grayscale using <code class="literal">cv::cvtColor()</code>. Finally, we create a <code class="literal">QImage</code> class from the grayscale <code class="literal">resultMat</code> element. In that case too, <code class="literal">resultMat</code> and <code class="literal">resultImage</code> share the same data pointer. Once we're done, we return a deep copy of <code class="literal">resultImage</code>.</p><p>It is now time to implement the last filter. Here is the <code class="literal">process()</code> function of <code class="literal">FilterBlur.cpp</code>:</p><pre class="programlisting">QImageFilterBlur::process(constQImage&amp; image) 
{ 
    // QImage =&gt; cv::mat 
cv::Mattmp(image.height(), 
image.width(), 
                CV_8UC4, 
                (uchar*)image.bits(), 
image.bytesPerLine()); 
 
int blur = 17; 
cv::MatresultMat; 
    cv::GaussianBlur(tmp, 
resultMat, 
                     cv::Size(blur, blur), 
                     0.0, 
                     0.0); 
 
    // cv::mat =&gt;QImage 
QImageresultImage((constuchar *) resultMat.data, 
resultMat.cols, 
resultMat.rows, 
resultMat.step, 
QImage::Format_RGB32); 
returnresultImage.copy(); 
} 
</pre><p>The conversion from <code class="literal">QImage</code> to <code class="literal">Mat</code> is the same. The processing differs because we use the <code class="literal">cv::GaussianBlur()</code> OpenCV function to smooth the picture. The <code class="literal">blur</code> is the kernel size used by the Gaussian blur. You can increase this value to get a softer picture, but only use an odd and positive number. Finally, we convert the <code class="literal">Mat</code> to <code class="literal">QImage</code> and return a deep copy to the caller.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Designing the UI with FilterWidget</h1></div></div></div><p>Fine. Our filter classes are implemented, and we can now create our custom widget. This widget will take in input, a source, and a thumbnail picture. Then the thumbnail is immediately processed to display a preview of the filter. If the user clicks on the widget, it will process the source picture and trigger a signal with the filtered picture. Keep in mind that this widget will later be dragged and dropped in the <strong>Form Editor</strong> of Qt Creator. That's why we will provide properties with getters and setters to select a filter from Qt Creator. Please create a new widget called <code class="literal">FilterWidget</code> using the <strong>Qt Designer Form Class</strong> template. The <code class="literal">FilterWidget.ui</code> is really simple:</p><div><img src="img/image00411.jpeg" alt="Designing the UI with FilterWidget"/></div><p style="clear:both; height: 1em;"> </p><p>The <code class="literal">titleLabel</code> is a <code class="literal">QLabel</code> on top of the <code class="literal">QWidget</code>. Below, <code class="literal">thumbnailLabel</code> will display the filtered picture thumbnail. Let's switch to <code class="literal">FilterWidget.h</code>:</p><pre class="programlisting">class FILTERPLUGINDESIGNERSHARED_EXPORT FilterWidget : public QWidget 
{ 
    Q_OBJECT 
 
    Q_ENUMS(FilterType) 
    Q_PROPERTY(QString title READ title WRITE setTitle) 
    Q_PROPERTY(FilterTypefilterType READ filterType WRITE setFilterType) 
 
public: 
enumFilterType { Original, Blur, Grayscale }; 
 
explicitFilterWidget(QWidget *parent = 0); 
    ~FilterWidget(); 
 
void process(); 
voidsetSourcePicture(constQImage&amp;sourcePicture); 
voidupdateThumbnail(constQImage&amp;sourceThumbnail); 
 
QStringtitle() const; 
FilterTypefilterType() const; 
 
public slots: 
voidsetTitle(constQString&amp; tile); 
voidsetFilterType(FilterTypefilterType); 
 
signals: 
voidpictureProcessed(constQImage&amp; picture); 
 
protected: 
voidmousePressEvent(QMouseEvent*) override; 
 
private: 
Ui::FilterWidget *ui; 
std::unique_ptr&lt;Filter&gt;mFilter; 
FilterTypemFilterType; 
 
QImagemDefaultSourcePicture; 
QImagemSourcePicture; 
QImagemSourceThumbnail; 
 
QImagemFilteredPicture; 
QImagemFilteredThumbnail; 
}; 
</pre><p>The top part defines all the available filter types with the <code class="literal">enumFilterType</code>. We also use the Qtproperty system to expose the widget title and the current filter type to the <strong>Property Editor</strong> of Qt Creator. The syntax is like this:</p><pre class="programlisting">Q_PROPERTY(&lt;type&gt;&lt;name&gt; READ &lt;getter&gt; WRITE &lt;setter&gt;) 
</pre><p>Please note that exposing an enumeration requires it to be registered using the <code class="literal">Q_ENUM()</code> macro, so the <strong>Property Editor</strong> will display a combo box that allows you to choose the filter type from Qt Creator.</p><p>The middle part lists all functions, slots, and signals. The most notable is the <code class="literal">process()</code> function that will use the current filter to modify the source picture. The <code class="literal">pictureProcessed()</code> signal will notify the application with the filtered picture.</p><p>The bottom part lists the picture and thumbnail <code class="literal">QImage</code> variables used in this class. In both cases, we handle both source and filtered pictures. The default source picture is an embedded picture in the plugin. This allows you to display a default preview when no thumbnail has been provided. The <code class="literal">mFilter</code> variable is a smart pointer to the current <code class="literal">Filter</code> class.</p><p>Let's switch to the implementation with <code class="literal">FilterWidget.cpp</code>:</p><pre class="programlisting">FilterWidget::FilterWidget(QWidget *parent) : 
QWidget(parent), 
ui(new Ui::FilterWidget), 
mFilterType(Original), 
mDefaultSourcePicture(":/lenna.jpg"), 
mSourcePicture(), 
mSourceThumbnail(mDefaultSourcePicture.scaled(QSize(256, 256), 
Qt::KeepAspectRatio, 
Qt::SmoothTransformation)), 
mFilteredPicture(), 
mFilteredThumbnail() 
{ 
ui-&gt;setupUi(this); 
setFilterType(Original); 
} 
 
FilterWidget::~FilterWidget() 
{ 
deleteui; 
} 
</pre><p>Here are the constructor and the destructor. Please note that the default source picture loads an embedded picture of the gorgeous Lenna often used in image processing literature. The picture is in the resource file, <code class="literal">filter-plugin-designer.qrc</code>. The <code class="literal">mSourceThumbnail</code> function is initialized with a scaled picture of Lenna. The constructor calls the <code class="literal">setFilterType()</code>function to initialize an <code class="literal">Original</code> filter by default. Here is the core <code class="literal">process()</code> function:</p><pre class="programlisting">voidFilterWidget::process() 
{ 
mFilteredPicture = mFilter-&gt;process(mSourcePicture); 
emitpictureProcessed(mFilteredPicture); 
} 
</pre><p>The <code class="literal">process()</code> function is powerful, but really simple. We call <code class="literal">process()</code> of the current filter to update our filtered picture from the current source picture. Then we trigger the <code class="literal">pictureProcessed()</code> signal with the filtered picture. We can now add our <code class="literal">QImage</code> setters:</p><pre class="programlisting">voidFilterWidget::setSourcePicture(constQImage&amp;sourcePicture) 
{ 
mSourcePicture = sourcePicture; 
} 
 
voidFilterWidget::updateThumbnail(constQImage&amp;sourceThumbnail) 
{ 
mSourceThumbnail = sourceThumbnail; 
mFilteredThumbnail = mFilter-&gt;process(mSourceThumbnail); 
QPixmappixmap = QPixmap::fromImage(mFilteredThumbnail); 
ui-&gt;thumbnailLabel-&gt;setPixmap(pixmap); 
} 
</pre><p>The <code class="literal">setSourcePicture()</code> function is a simple setter called by the application with a new source picture. The <code class="literal">updateThumbnail()</code> method will filter the new source thumbnail and display it. Let's add the setters used by <code class="literal">Q_PROPERTY</code>:</p><pre class="programlisting">voidFilterWidget::setTitle(constQString&amp; tile) 
{ 
ui-&gt;titleLabel-&gt;setText(tile); 
} 
 
voidFilterWidget::setFilterType(FilterWidget::FilterTypefilterType) 
{ 
if (filterType == mFilterType&amp;&amp;mFilter) { 
return; 
    } 
mFilterType = filterType; 
 
switch (filterType) { 
case Original: 
mFilter = make_unique&lt;FilterOriginal&gt;(); 
break; 
 
case Blur: 
mFilter = make_unique&lt;FilterBlur&gt;(); 
break; 
 
case Grayscale: 
mFilter = make_unique&lt;FilterGrayscale&gt;(); 
break; 
 
default: 
break; 
    } 
 
updateThumbnail(mSourceThumbnail); 
} 
</pre><p>The <code class="literal">setTitle()</code>function is a simple setter used to customize the widget title. Let's talk about the <code class="literal">setFilterType()</code> function. As you can see, this function does not just update the current filter type, <code class="literal">mFilterType</code>. Depending on the type, the corresponding filter will be created. Do you remember the smart pointer from <a class="link" title="Chapter 3.  Dividing Your Project and Ruling Your Code" href="part0034.xhtml#aid-10DJ42">Chapter 3</a>, <em>Dividing Your Project and Ruling Your Code</em>? Here we are using a <code class="literal">unique_ptr</code> pointer for the <code class="literal">mFilter</code> variable, so we can use <code class="literal">make_unique</code> instead of a <code class="literal">new</code> raw. The <code class="literal">FilterWidget</code> class takes the ownership of the <code class="literal">Filter</code> class, and we do not need to worry about the memory management. Upon the <code class="literal">make_unique</code> instruction, the old owned pointer (if there is any) will be automatically deleted.</p><p>Finally, we call the <code class="literal">updateThumbnail()</code> function to display a filtered thumbnail corresponding to the selected filter type. Here are the getters and the mouse event handler:</p><pre class="programlisting">QStringFilterWidget::title() const 
{ 
returnui-&gt;titleLabel-&gt;text(); 
} 
 
FilterWidget::FilterTypeFilterWidget::filterType() const 
{ 
returnmFilterType; 
} 
 
voidFilterWidget::mousePressEvent(QMouseEvent*) 
{ 
process(); 
} 
</pre><p>The <code class="literal">title()</code> and <code class="literal">filterType()</code> functions are getters used by the Qt Property System. We override the <code class="literal">mousePressEvent()</code> function to call our  <code class="literal">process()</code> function each time the user clicks on the widget.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Exposing your plugin to Qt Designer</h1></div></div></div><p>The <code class="literal">FilterWidget</code> class is completed and ready to be used. We now have to register <code class="literal">FilterWidget</code> with the Qt Designer plugin system. This glue code is made using a child class of <code class="literal">QDesignerCustomWidgetInterface</code>.</p><p>Create a new C++ class named <code class="literal">FilterPluginDesigner</code> and update <code class="literal">FilterPluginDesigner.h</code> like so:</p><pre class="programlisting">#include &lt;QtUiPlugin/QDesignerCustomWidgetInterface&gt; 
 
class  FilterPluginDesigner : public QObject, public QDesignerCustomWidgetInterface 
{ 
    Q_OBJECT 
    Q_PLUGIN_METADATA(IID 
        "org.masteringqt.imagefilter.FilterWidgetPluginInterface") 
    Q_INTERFACES(QDesignerCustomWidgetInterface) 
public: 
FilterPluginDesigner(QObject* parent = 0); 
}; 
</pre><p>The <code class="literal">FilterPlugin</code> class inherits from two classes:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">QObject</code> class, to rely on the Qt parenting system</li><li class="listitem">The <code class="literal">QDesignerCustomWidgetInterface</code> class to properly expose the <code class="literal">FilterWidget</code> information to the plugin system</li></ul></div><p>The <code class="literal">QDesignerCustomWidgetInterface</code> class brings two new macros:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">Q_PLUGIN_METADATA()</code> macro annotates the class to indicate a unique name for our filter to the meta-object system</li><li class="listitem">The <code class="literal">Q_INTERFACES()</code> macro tells the meta-object system which interface the current class has implemented</li></ul></div><p>Qt Designer is now able to detect our plugin. We now have to provide information about the plugin itself. Update <code class="literal">FilterPluginDesigner.h</code>:</p><pre class="programlisting">class  FilterPluginDesigner : public QObject, public QDesignerCustomWidgetInterface 
{ 
    ... 
FilterPluginDesigner(QObject* parent = 0); 
 
QStringname() const override; 
QStringgroup() const override; 
QStringtoolTip() const override; 
QStringwhatsThis() const override; 
QStringincludeFile() const override; 
QIconicon() const override; 
boolisContainer() const override; 
QWidget* createWidget(QWidget* parent) override; 
boolisInitialized() const override; 
void initialize(QDesignerFormEditorInterface* core) override; 
 
private: 
boolmInitialized; 
}; 
</pre><p>This is much less overwhelming than it looks. The body of each one of these functions usually takes a single line. Here is the implementation of the most straightforward functions:</p><pre class="programlisting">QStringFilterPluginDesigner::name() const 
{ 
return "FilterWidget"; 
} 
 
QStringFilterPluginDesigner::group() const 
{ 
return "Mastering Qt5"; 
} 
 
QStringFilterPluginDesigner::toolTip() const 
{ 
return "A filtered picture"; 
} 
 
QStringFilterPluginDesigner::whatsThis() const 
{ 
return "The filter widget applies an image effect"; 
} 
 
QIconFilterPluginDesigner::icon() const 
{ 
returnQIcon(":/icon.jpg"); 
} 
 
boolFilterPluginDesigner::isContainer() const 
{ 
return false; 
} 
</pre><p>As you can see, there isn't much to say about these functions. Most of them will simply return a <code class="literal">QString</code> value that will be displayed on the appropriate spot in the Qt Designer UI. We will focus only on the most interesting ones. Let's start with <code class="literal">includeFile()</code>:</p><pre class="programlisting">QStringFilterPluginDesigner::includeFile() const 
{ 
return "FilterWidget.h"; 
} 
</pre><p>This function will be called by <code class="literal">uic</code> (<strong>User Interface Compiler</strong>) to generate the header corresponding to a <code class="literal">.ui</code> file. Continuing with <code class="literal">createWidget()</code>:</p><pre class="programlisting">QWidget* FilterPluginDesigner::createWidget(QWidget* parent) 
{ 
return new FilterWidget(parent); 
} 
</pre><p>This function makes the bridge between Qt Designer and <code class="literal">FilterWidget</code>. When you add the <code class="literal">FilterWidget</code> class in a <code class="literal">.ui</code> file, Qt Designer will call the <code class="literal">createWidget()</code> function to have an instance of the <code class="literal">FilterWidget</code> class and display its content. It also provides the <code class="literal">parent</code> element to which <code class="literal">FilterWidget</code> will be attached.</p><p>Let's finish with <code class="literal">initialize()</code>:</p><pre class="programlisting">voidFilterPluginDesigner::initialize(QDesignerFormEditorInterface*) 
{ 
if (mInitialized) 
return; 
 
mInitialized = true; 
} 
</pre><p>Nothing much is done in this function. However, the <code class="literal">QDesignerFormEditorInterface*</code> parameter is worth some explanation. This pointer, provided by Qt Designer, gives access to a few of Qt Designer's components via functions:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">actionEditor()</code>: This function is the action editor (bottom panel of the designer)</li><li class="listitem"><code class="literal">formWindowManager()</code>: This function is the interface that enables you to create a new form window</li><li class="listitem"><code class="literal">objectInspector()</code>: This function is the hierarchical representation of your layout (top right panel of the designer)</li><li class="listitem"><code class="literal">propertyEditor()</code>: This function is the list of all the editable properties of the currently selected widget (bottom right panel of the designer)</li><li class="listitem"><code class="literal">topLevel()</code>: This function is the top-level widget of the designer</li></ul></div><p>We covered each of these panels in <a class="link" title="Chapter 1.  Get Your Qt Feet Wet" href="part0014.xhtml#aid-DB7S1">Chapter 1</a>, <em>Get Your Qt Feet Wet</em>. If your widget plugin needs to intervene in any of these areas, this function is the entry point to customize the behavior of Qt Designer.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec71"/>Using your Qt Designer plugin</h1></div></div></div><p>Our custom plugin is now finished. Because we added a custom <code class="literal">Build</code> command to automatically deploy the filter-widget library, it should be visible in Qt Designer. The deploy path we specified is inside the Qt Creator directory. Qt Creator integrates Qt Designer via a plugin that displays the UI inside Qt Creator.</p><p>When Qt Creator starts, it will try to load every library available in its specific paths. This means that you have to restart Qt Creator each time you modify the plugin (if you want to see the result of your modifications in the designer).</p><p>To see the plugin in action, we now have to create the application project of the chapter. Create a <strong>Qt Widgets Application</strong> sub-project in the <code class="literal">ch07-image-filter</code> project named <code class="literal">image-filter</code>. In the wizard, let it generate the form, <code class="literal">MainWindow.ui</code>.</p><p>To properly use the plugin, just link the <code class="literal">filter-plugin-designer</code> library in <code class="literal">image-filter.pro</code> like so:</p><pre class="programlisting">QT       += core gui 
 
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets 
 
TARGET = image-filter 
TEMPLATE = app 
 
INCLUDEPATH += ../filter-plugin-designer 
 
win32 { 
    LIBS += -L$$(QTDIR)/../../Tools/QtCreator/bin/plugins/designer -lfilter-plugin-designer 
} 
 
macx { 
    LIBS += -L$$(QTDIR)/../../"QtCreator.app"/Contents/PlugIns/designer/ -lfilter-plugin-designer 
} 
 
linux { 
    LIBS += -L$$(QTDIR)/../../Tools/QtCreator/lib/Qt/plugins/designer/ -lfilter-plugin-designer 
} 
 
SOURCES += main.cpp\ 
        MainWindow.cpp 
 
HEADERS  += MainWindow.h 
 
FORMS    += MainWindow.ui 
</pre><p>To have access to the headers of <code class="literal">filter-plugin-designer</code>, we simply add it to the <code class="literal">INCLUDEPATH</code> directory. Finally, the linker is instructed to link to the library we deployed in Qt Creator. This ensures that the same library is used by Qt Designer and by our application.</p><p>Open the <code class="literal">MainWindow.ui</code> file and scroll to the bottom of the <strong>Widget box</strong>. Lo and behold, you should see this:</p><div><img src="img/image00412.jpeg" alt="Using your Qt Designer plugin"/></div><p style="clear:both; height: 1em;"> </p><p>The <code class="literal">FilterWidget</code> plugin appears under the Mastering Qt5 section. It even displays the famous Lenna as a preview icon. If you do not see the <code class="literal">FilterWidget</code> plugin, then restart Qt Creator and make sure that the plugin is properly loaded. To check this (in the <strong>Design</strong> tab), go to <strong>Tools</strong> | <strong>Form Editor</strong> | <strong>About Qt Designer Plugins</strong>. This is what it should display:</p><div><img src="img/image00413.jpeg" alt="Using your Qt Designer plugin"/></div><p style="clear:both; height: 1em;"> </p><p>If the <code class="literal">FilterWidget</code> plugin does not appear in this list, you should check the Qt Creator plugin directory content (the path is stated in <code class="literal">image-filter.pro</code>).</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Building the image-filter application</h1></div></div></div><p>We can proceed to build the UI of the application. The idea is to open a picture from the filesystem and apply to it the various filters we developed in the <code class="literal">filter-designer-plugin</code> project. If you want to keep the result, you can save the resulting image.</p><p>We will start by designing the UI. Modify <code class="literal">MainWindow.ui</code> to look like this:</p><div><img src="img/image00414.jpeg" alt="Building the image-filter application"/></div><p style="clear:both; height: 1em;"> </p><p>Here is the Object Inspector content to help you build this layout:</p><div><img src="img/image00415.jpeg" alt="Building the image-filter application"/></div><p style="clear:both; height: 1em;"> </p><p>There are three elements of this UI:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="literal">menuFile</code> element, which contains three possible actions: <code class="literal">actionOpenPicture</code>, <code class="literal">actionExit</code>, and <code class="literal">actionSaveAs</code>. You can see the details of these actions in the <code class="literal">Action Editor</code> window.</li><li class="listitem">The <code class="literal">pictureLabel</code> element, which will display the loaded picture in the empty top part.</li><li class="listitem">The <code class="literal">filtersLayout</code> element, which contains the three instances of our <code class="literal">FilterWidget</code> class in the bottom part.</li></ul></div><p>As you add a <code class="literal">FilterWidget</code> class in <code class="literal">filtersLayout</code>, you can see that you can customize the <code class="literal">title</code> and the <code class="literal">filterType</code> in the <strong>Property Editor</strong> window. The preview will be automatically updated with the selected filter applied to our default picture. A dynamic preview like this is simply awesome, and you can foresee that your custom Qt Designer widgets can become quite powerful.</p><p>Let's implement the logic of our application. Update <code class="literal">MainWindow.h</code> like so:</p><pre class="programlisting">#include &lt;QMainWindow&gt; 
#include &lt;QImage&gt; 
#include &lt;QVector&gt; 
 
namespaceUi { 
classMainWindow; 
} 
 
classFilterWidget; 
 
classMainWindow : public QMainWindow 
{ 
    Q_OBJECT 
 
public: 
explicitMainWindow(QWidget *parent = 0); 
    ~MainWindow(); 
 
voidloadPicture(); 
 
private slots: 
voiddisplayPicture(constQImage&amp; picture); 
 
private: 
voidinitFilters(); 
voidupdatePicturePixmap(); 
 
private: 
Ui::MainWindow *ui; 
QImagemSourcePicture; 
QImagemSourceThumbnail; 
QPixmapmCurrentPixmap; 
FilterWidget* mCurrentFilter; 
QVector&lt;FilterWidget*&gt;mFilters; 
}; 
</pre><p>Here are some elements that we have to explain:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">mSourcePicture</code>: This element is the loaded picture.</li><li class="listitem"><code class="literal">mSourceThumbnail</code>: This element is the generated thumbnail from <code class="literal">mSourcePicture</code>. To avoid wasting CPU cycles, <code class="literal">mSourcePicture</code> will be resized only once, and each of the <code class="literal">FilterWidget</code> instances will process this thumbnail rather than the full-resolution picture.</li><li class="listitem"><code class="literal">mCurrentPixmap</code>: This element is the currently displayed <code class="literal">QPixmap</code> in the <code class="literal">pictureLabel</code> widget.</li><li class="listitem"><code class="literal">mCurrentFilter</code>: This element is the currently applied filter. Each time the user clicks on a different <code class="literal">FilterWidget</code>, this pointer will be updated.</li><li class="listitem"><code class="literal">mFilters</code>: This element is a <code class="literal">QVector</code> of the <code class="literal">FilterWidget</code> class that we added to <code class="literal">MainWindow.ui</code>. It is only a helper, introduced to easily apply the same instructions to each <code class="literal">FilterWidget</code> class.</li></ul></div><p>Now for the functions, we will limit ourselves to a broad overview. The details will be covered when we look at the implementation of each function:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">loadPicture()</code>: This function triggers the whole pipeline. It will be called when the user clicks on <code class="literal">actionOpenPicture</code>.</li><li class="listitem"><code class="literal">initFilters()</code>: This function is in charge of initializing <code class="literal">mFilters.</code></li><li class="listitem"><code class="literal">displayPicture()</code>: This function is the slot called by <code class="literal">mCurrentWidget::pictureProcessed()</code> to display the filtered picture.</li><li class="listitem"><code class="literal">updatePicturePixmap()</code>: This function handles the display of <code class="literal">mCurrentPixmap</code> inside <code class="literal">pictureLabel</code>.</li></ul></div><p>Let's look at the <code class="literal">MainWindow</code> class's constructor implementation in <code class="literal">MainWindow.cpp</code>:</p><pre class="programlisting">#include &lt;QFileDialog&gt; 
#include &lt;QPixmap&gt; 
#include &lt;QDir&gt; 
 
#include "FilterWidget.h" 
 
MainWindow::MainWindow(QWidget *parent) : 
QMainWindow(parent), 
ui(new Ui::MainWindow), 
mSourcePicture(), 
mSourceThumbnail(), 
mCurrentPixmap(), 
mCurrentFilter(nullptr), 
mFilters() 
{ 
ui-&gt;setupUi(this); 
ui-&gt;pictureLabel-&gt;setMinimumSize(1, 1); 
 
connect(ui-&gt;actionOpenPicture, &amp;QAction::triggered,  
    this, &amp;MainWindow::loadPicture); 
connect(ui-&gt;actionExit, &amp;QAction::triggered,  
    this, &amp;QMainWindow::close); 
initFilters(); 
} 
</pre><p>We connect the <code class="literal">actionOpenPicture::triggered()</code> signal to our yet-to-be-implemented <code class="literal">loadPicture()</code> function. The <code class="literal">actionExit</code> is straightforward; it is simply connected to the <code class="literal">QMainWindow::close()</code> slot. Finally, <code class="literal">initFilter()</code> is called. Let's see its body:</p><pre class="programlisting">voidMainWindow::initFilters() 
{ 
mFilters.push_back(ui-&gt;filterWidgetOriginal); 
mFilters.push_back(ui-&gt;filterWidgetBlur); 
mFilters.push_back(ui-&gt;filterWidgetGrayscale); 
 
for (inti = 0; i&lt;mFilters.size(); ++i) { 
connect(mFilters[i], &amp;FilterWidget::pictureProcessed, 
this, &amp;MainWindow::displayPicture); 
    } 
mCurrentFilter = mFilters[0]; 
} 
</pre><p>Each <code class="literal">FilterWidget</code> instance is added to <code class="literal">mFilters</code>. We then proceed to connect the <code class="literal">pictureProcessed()</code> signal to the <code class="literal">MainWindow::displayPicture</code> instruction and <code class="literal">mCurrentFilter</code> is initialized to the original filter.</p><p>The class is now ready to load some pictures! This is the implementation of <code class="literal">loadPicture()</code>:</p><pre class="programlisting">voidMainWindow::loadPicture() 
{ 
QString filename = QFileDialog::getOpenFileName(this, 
        "Open Picture", 
        QDir::homePath(), 
  tr("Images (*.png *.jpg)")); 
if (filename.isEmpty()) { 
return; 
    } 
mSourcePicture = QImage(filename); 
mSourceThumbnail = mSourcePicture.scaled(QSize(256, 256), 
  Qt::KeepAspectRatio,                                                   Qt::SmoothTransformation); 
for (inti = 0; i&lt;mFilters.size(); ++i) { 
mFilters[i]-&gt;setSourcePicture(mSourcePicture); 
mFilters[i]-&gt;updateThumbnail(mSourceThumbnail); 
    } 
 
mCurrentFilter-&gt;process(); 
} 
</pre><p>The  <code class="literal">mSourcePicture</code> method is loaded using a <code class="literal">QFileDialog</code>, and <code class="literal">mSourceThumbnail</code> is generated from this input. Every <code class="literal">FilterWidget</code> class is updated with this new data and the <code class="literal">mCurrentFilter</code> element is triggered by calling its <code class="literal">process()</code> function.</p><p>When <code class="literal">FilterWidget::process()</code> is finished, it emits the <code class="literal">pictureProcessed()</code> signal, which is connected to our <code class="literal">displayPicture()</code> slot. Let's switch to this function:</p><pre class="programlisting">voidMainWindow::displayPicture(constQImage&amp; picture) 
{ 
mCurrentPixmap = QPixmap::fromImage(picture); 
updatePicturePixmap(); 
} 
</pre><p>Nothing very fancy here: <code class="literal">mCurrentPixmap</code> is updated from the given picture and the <code class="literal">updatePicturePixmap()</code> function is in charge of updating the <code class="literal">pictureLabel</code> element. Here is the implementation of <code class="literal">updatePicturePixmap()</code>:</p><pre class="programlisting">voidMainWindow::updatePicturePixmap() 
{ 
if (mCurrentPixmap.isNull()) { 
return; 
    } 
ui-&gt;pictureLabel-&gt;setPixmap( 
mCurrentPixmap.scaled(ui-&gt;pictureLabel-&gt;size(), 
      Qt::KeepAspectRatio, 
Qt::SmoothTransformation)); 
} 
</pre><p>This function simply creates a scaled version of <code class="literal">mCurrentPixmap</code> that fits inside <code class="literal">pictureLabel</code>.</p><p>The whole picture loading/filter processing is completed. If you run the application you should be able to load and modify your pictures. However, if you resize the window, you will see that the <code class="literal">pictureLabel</code> element does not scale very well.</p><p>To address this issue, we have to regenerate the scaled version of <code class="literal">mCurrentPixmap</code> each time the window is resized. Update <code class="literal">MainWindow</code> like so:</p><pre class="programlisting">// In MainWindow.h 
classMainWindow : public QMainWindow 
{ 
    ... 
voidloadPicture(); 
 
protected: 
voidresizeEvent(QResizeEvent* event) override; 
    ... 
}; 
 
// In MainWindow.cpp 
voidMainWindow::resizeEvent(QResizeEvent* /*event*/) 
{ 
updatePicturePixmap(); 
} 
</pre><p>Here, the separation of <code class="literal">mCurrentPixmap</code> and the <code class="literal">pictureLabel</code> element's pixmap makes sense. Because we always generate the scaled version from the full-resolution <code class="literal">mCurrentPixmap</code>, we are sure that the resulting pixmap will look good.</p><p>The image-filter application would not be complete without the ability to save your filtered picture. This will not take much effort. Here is the updated version of <code class="literal">MainWindow.h</code>:</p><pre class="programlisting">classMainWindow : public QMainWindow 
{ 
    ... 
 
private slots: 
voiddisplayPicture(constQImage&amp; picture); 
voidsaveAsPicture(); 
    ... 
 
private: 
Ui::MainWindow *ui; 
QImagemSourcePicture; 
QImagemSourceThumbnail; 
QImage&amp;mFilteredPicture; 
    ... 
}; 
</pre><p>Here, we simply added a <code class="literal">saveAsPicture()</code> function that will take the <code class="literal">mFilteredPicture</code> element and save it to a file. The implementation in <code class="literal">MainWindow.cpp</code> should not blow your mind:</p><pre class="programlisting">// In MainWindow.cpp 
MainWindow::MainWindow(QWidget *parent) : 
QMainWindow(parent), 
ui(new Ui::MainWindow), 
mSourcePicture(), 
mSourceThumbnail(), 
mFilteredPicture(mSourcePicture), 
    ... 
{ 
ui-&gt;setupUi(this); 
ui-&gt;actionSaveAs-&gt;setEnabled(false); 
ui-&gt;pictureLabel-&gt;setMinimumSize(1, 1); 
 
connect(ui-&gt;actionOpenPicture, &amp;QAction::triggered, 
this, &amp;MainWindow::loadPicture); 
connect(ui-&gt;actionSaveAs, &amp;QAction::triggered, 
this, &amp;MainWindow::saveAsPicture); 
    ... 
} 
 
voidMainWindow::loadPicture() 
{ 
    ... 
if (filename.isEmpty()) { 
return; 
    } 
ui-&gt;actionSaveAs-&gt;setEnabled(true); 
    ... 
} 
 
voidMainWindow::displayPicture(constQImage&amp; picture) 
{ 
mFilteredPicture = picture; 
mCurrentPixmap = QPixmap::fromImage(picture); 
updatePicturePixmap(); 
} 
 
voidMainWindow::saveAsPicture() 
{ 
QString filename = QFileDialog::getSaveFileName(this, 
            "Save Picture", 
QDir::homePath(), 
tr("Images (*.png *.jpg)")); 
if (filename.isEmpty()) { 
return; 
    } 
mFilteredPicture.save(filename); 
} 
</pre><p>The code snippet is long, but not very complex. The <code class="literal">actionSaveAs</code> function is enabled only when a picture is loaded. When the picture has been processed, <code class="literal">mFilteredPicture</code> is updated with the given picture. Because it is a reference, it costs absolutely nothing to store this filtered picture.</p><p>Finally, the <code class="literal">saveAsPicture()</code> function asks the user for a path and saves it using the <code class="literal">QImage</code> API, which tries to deduce the picture type based on the file extension.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec73"/>Summary</h1></div></div></div><p>In this chapter, you learned how to integrate a third-party library with each desktop OS (Windows, Linux, and Mac). We chose the OpenCV library, which has been included in a custom Qt Designer plugin, and which can display a live preview of your image processing result in Qt Designer. We created an image filtering application that can open pictures, apply filters to them, and save the result on your machine.</p><p>We had a good look at how you can integrate third-party libraries and how to make a Qt Designer plugin. In the next chapter, we will push things forward by making the <code class="literal">image-filter</code> application ready to load filter plugins that could be implemented by third-party developers. To make things even cooler, we will cover the Qt animation framework to make the <code class="literal">image-filter</code> more spectacular.</p></div></body></html>