<html><head></head><body>
<div id="_idContainer051">
<h1 class="chapter-number" id="_idParaDest-31"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-32"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.2.1">“Hello Patterns”</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This chapter will focus on the principles that underpin all good code. </span><span class="koboSpan" id="kobo.3.2">Design patterns are an extension </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.4.1">of these principles, so it is important to walk before you run. </span><span class="koboSpan" id="kobo.4.2">Once the basics have been covered, we’ll look at some bad Blueprint code so that we can understand the process of fixing it, which we will do by following some </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">step-by-step guides.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">In this chapter, we’ll be covering the </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">following topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.8.1">S.O.L.I.D. </span><span class="koboSpan" id="kobo.8.2">principles</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Exploring solutions to </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">common problems</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">The trade-off</span></span></li>
</ul>
<h1 id="_idParaDest-33"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.12.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.13.1">For this chapter, you will need a blank UE5 project open and ready. </span><span class="koboSpan" id="kobo.13.2">There's no need for C++ right now; we’ll be focusing on Blueprint code </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">for simplicity.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">The files for this project can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.16.1">chapter2</span></strong><span class="koboSpan" id="kobo.17.1"> branch on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">at </span></span><a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter02"><span class="No-Break"><span class="koboSpan" id="kobo.19.1">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter02</span></span></a></p>
<p><span class="koboSpan" id="kobo.20.1">If you’ve not created a blank UE5 project before, the following steps will take you through creating a simple Blueprint project, which is all we need for </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">this chapter:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.22.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">Launch</span></strong><span class="koboSpan" id="kobo.24.1"> button in the top right of the </span><strong class="bold"><span class="koboSpan" id="kobo.25.1">Epic Launcher</span></strong><span class="koboSpan" id="kobo.26.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">Unreal Engine</span></strong><span class="koboSpan" id="kobo.28.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">Library</span></strong><span class="koboSpan" id="kobo.30.1"> tab, where we installed the engine in the </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">first chapter.</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">Games</span></strong><span class="koboSpan" id="kobo.34.1"> on the left side of the </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">Unreal </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.36.1">Project Browser</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">Blank</span></strong><span class="koboSpan" id="kobo.40.1"> from the main section, and toggle </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">Starter Content</span></strong><span class="koboSpan" id="kobo.42.1"> off. </span><span class="koboSpan" id="kobo.42.2">This will prevent Unreal from adding a bunch of unrequired assets to </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">the project.</span></span></li>
<li><span class="koboSpan" id="kobo.44.1">Choose a sensible location (the default is fine) and set the project name </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">HelloPatterns</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.48.1"><img alt="Figure 2.1 – The Unreal Project Browser with a new, blank games project set up for creation" src="image/Figure_02.01_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.49.1">Figure 2.1 – The Unreal Project Browser with a new, blank games project set up for creation</span></p>
<ol>
<li value="5"><span class="No-Break"><span class="koboSpan" id="kobo.50.1">Click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.51.1">Create</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.53.1">Now you have your project set up, you are ready for the interactive part of this chapter, but first, let’s discuss what we mean when we say </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.54.1">good code</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">.</span></span></p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.56.1">S.O.L.I.D. </span><span class="koboSpan" id="kobo.56.2">principles</span></h1>
<p><span class="koboSpan" id="kobo.57.1">To </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.58.1">understand why design patterns work, we need to understand the principles that underpin good code. </span><span class="koboSpan" id="kobo.58.2">Let’s run a whistle-stop tour through most people’s first experience </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">with code.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">The universal </span><em class="italic"><span class="koboSpan" id="kobo.61.1">Hello World</span></em><span class="koboSpan" id="kobo.62.1"> program and the beginner exercises that follow are all made up of linear code. </span><span class="koboSpan" id="kobo.62.2">Linear code executes each line sequentially through a single file in which the whole program is written. </span><span class="koboSpan" id="kobo.62.3">Loops, selections, and statements make up </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">literally everything.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">As each program gets larger, the code becomes unsustainable. </span><span class="koboSpan" id="kobo.64.2">The solution is object orientation. </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">Object-oriented programming</span></strong><span class="koboSpan" id="kobo.66.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.67.1">OOP</span></strong><span class="koboSpan" id="kobo.68.1">) adds a lot, primarily classes and objects, as </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.69.1">the name would suggest. </span><span class="koboSpan" id="kobo.69.2">With OOP’s added complexity, it becomes quite easy to accidentally build in fundamental issues with systems that make it impossible to expand them. </span><span class="koboSpan" id="kobo.69.3">Having a set of rules to follow greatly simplifies the process of building code that works for you and the next person to maintain it. </span><span class="koboSpan" id="kobo.69.4">These rules take the </span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.70.1">form of the </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">S.O.L.I.D.</span></strong><span class="koboSpan" id="kobo.72.1"> principles, which are </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">defined here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.74.1">S – </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.75.1">Single responsibility</span></strong></span></li>
<li><span class="koboSpan" id="kobo.76.1">O – </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.77.1">Open-closed</span></strong></span></li>
<li><span class="koboSpan" id="kobo.78.1">L – </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.79.1">Liskov substitution</span></strong></span></li>
<li><span class="koboSpan" id="kobo.80.1">I – </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.81.1">Interface segregation</span></strong></span></li>
<li><span class="koboSpan" id="kobo.82.1">D – </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.83.1">Dependency inversion</span></strong></span></li>
</ul>
<h2 id="_idParaDest-35"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.84.1">Single responsibility</span></h2>
<p><span class="koboSpan" id="kobo.85.1">In </span><em class="italic"><span class="koboSpan" id="kobo.86.1">Agile Software Development: Principles, Patterns, and Practices</span></em><span class="koboSpan" id="kobo.87.1">, Robert C. </span><span class="koboSpan" id="kobo.87.2">Martin said </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">the following:</span></span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.89.1">A class should have one and only one reason to change, meaning that a class should have only one job.</span></p>
<p><span class="koboSpan" id="kobo.90.1">Each</span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.91.1"> class should </span><em class="italic"><span class="koboSpan" id="kobo.92.1">do what it says on the tin</span></em><span class="koboSpan" id="kobo.93.1">—or, in</span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.94.1"> this case, the class name. </span><span class="koboSpan" id="kobo.94.2">If you were hiring a plumber, you wouldn’t expect that plumber to also recite </span><em class="italic"><span class="koboSpan" id="kobo.95.1">Hamlet</span></em><span class="koboSpan" id="kobo.96.1"> while fixing the pipes. </span><span class="koboSpan" id="kobo.96.2">The same is true for code; if you have a math library class, you expect it to take numbers in and return the results after performing some equations. </span><span class="koboSpan" id="kobo.96.3">What you don’t expect is for it to use these numbers as a seed to generate an image, which it sets as your desktop background. </span><span class="koboSpan" id="kobo.96.4">Granted, this is an extreme case that may even be considered a virus, but the </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">point stands.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">Writing a class that does what is expected by its name helps when working in a team. </span><span class="koboSpan" id="kobo.98.2">Games can become quite large with many interconnected systems, and if a developer can understand what a class is responsible for and how to operate it, from just function and class names, then time is saved. </span><span class="koboSpan" id="kobo.98.3">Implementation can be as simple as consistent naming conventions combined with compartmentalized functionality. </span><span class="koboSpan" id="kobo.98.4">For instance, a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">AddItem(ItemType type, int amount)</span></strong><span class="koboSpan" id="kobo.100.1"> on an inventory component in the object used for our player probably adds an amount of an item to the inventory of the player. </span><span class="koboSpan" id="kobo.100.2">You don’t need to open the function to see what it does due to this </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">clear naming.</span></span></p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.102.1">Open-closed</span></h2>
<p><span class="koboSpan" id="kobo.103.1">In </span><em class="italic"><span class="koboSpan" id="kobo.104.1">Agile Software Development: Principles, patterns, and practices</span></em><span class="koboSpan" id="kobo.105.1">, Robert C. </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">Martin said:</span></span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.107.1">Objects or entities should be open for extension but closed for modification.</span></p>
<p><span class="koboSpan" id="kobo.108.1">New </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.109.1">functionality</span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.110.1"> should be easy to create, without needing to modify the existing code. </span><span class="koboSpan" id="kobo.110.2">It is easy to see this in action through something like a save system. </span><span class="koboSpan" id="kobo.110.3">If you want to port your game to multiple platforms, then it would make sense to have a different </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">save</span></strong><span class="koboSpan" id="kobo.112.1"> method for each. </span><span class="koboSpan" id="kobo.112.2">To start with, there are two target platforms (PC and Xbox); the save system might look </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.114.1">Example SaveClass.cpp</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.115.1">
void SaveClass::SaveGame(GameProgress* gameProgress)
{
    if(target == "PC")
    {
        //save game progress the PC way
    }
    else if (target == "XBOX")
    {
        //save game progress the Xbox way
    }
}</span></pre> <p><span class="koboSpan" id="kobo.116.1">Somewhere down the line, you decide to extend the system to also work on PlayStation. </span><span class="koboSpan" id="kobo.116.2">This is another platform to handle. </span><span class="koboSpan" id="kobo.116.3">The modification seems easy—just add a new case to the ever-expanding statement. </span><span class="koboSpan" id="kobo.116.4">Therein lies the problem; the more platforms we support, the</span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.117.1"> longer this will get, and the more time and memory the function </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">will occupy:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.119.1">Example SaveClass.cpp</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.120.1">
void SaveClass::SaveGame(GameProgress* gameProgress)
{
    if (target == "PC")
    {
        // save game progress the PC way
    }
    else if (target == "XBOX")
    {
        // save game progress the Xbox way
    }
    else if (target == "another platform")
    {
        // save game progress on another platform
    }
    else if (target == "yet another platform")
    {
        // save game progress on yet another platform
    }
}</span></pre> <p><span class="koboSpan" id="kobo.121.1">The solution</span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.122.1"> is to spin the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">save</span></strong><span class="koboSpan" id="kobo.124.1"> function into an abstract function with an overriding child class function for each platform shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.125.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.126.1">.2</span></em><span class="koboSpan" id="kobo.127.1">. </span><span class="koboSpan" id="kobo.127.2">This not only means new platforms can be added with a new child class but also, we don’t have to instantiate versions of the save system we will never use, </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">saving memory:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.129.1"><img alt="Figure 2.2 – UML diagram showing inheritance of a ﻿SaveClass﻿ instance with the open-closed principle applied" src="image/Figure_02.02_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.130.1">Figure 2.2 – UML diagram showing inheritance of a SaveClass instance with the open-closed principle applied</span></p>
<p><span class="koboSpan" id="kobo.131.1">Next, we will look at </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">Liskov substitution.</span></span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.133.1">Liskov substitution</span></h2>
<p><span class="koboSpan" id="kobo.134.1">In </span><em class="italic"><span class="koboSpan" id="kobo.135.1">Agile Software Development: Principles, Patterns, and Practices</span></em><span class="koboSpan" id="kobo.136.1">, Robert C. </span><span class="koboSpan" id="kobo.136.2">Martin said </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">the following:</span></span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.138.1">Let q(x) be a property provable about objects of x of type T. </span><span class="koboSpan" id="kobo.138.2">Then q(y) should be provable for objects y of type S where S is a subtype of T.</span></p>
<p><span class="koboSpan" id="kobo.139.1">Essentially, if </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.140.1">there is a child class in use within your</span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.141.1"> code, you should be able to swap it out for any of its siblings without modifying the structure of the calling code or using variables for unintended purposes. </span><span class="koboSpan" id="kobo.141.2">In the previous example, we turned a save system into a parent-child structure. </span><span class="koboSpan" id="kobo.141.3">If we were to add cloud saving, we would no longer have a file path to send data to and instead, we would use an IP address. </span><span class="koboSpan" id="kobo.141.4">Well, we could make this work by just piping the IP address through the file path argument as shown in the following exerpt but this is a violation of our naming convention. </span><span class="koboSpan" id="kobo.141.5">Undoubtedly, someone down the line will need to use this function and won’t understand what they need to do. </span><span class="koboSpan" id="kobo.141.6">Plus, any data not in the requested type will have to be converted by the calling object, sent, and then parsed inside the child implementation, which </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">wastes time:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.143.1">Excerpt from a program calling a save system</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.144.1">
SaveClass* _XboxSaver = new SaveClass_Xbox();
SaveClass* _CloudSaver = new SaveClass_Cloud();
SaveData* _DataToSave;
//Some code to prepare save data
_XboxSaver-&gt;SaveSomeData(_DataToSave, "filepath");
_CloudSaver-&gt;SaveSomeData(_DataToSave, "127.0.0.1");</span></pre> <p><span class="koboSpan" id="kobo.145.1">The fix for</span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.146.1"> this principle is to make the variable that may </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.147.1">change a member of the child class. </span><span class="koboSpan" id="kobo.147.2">That way, initialization functions can deal with making sure the correct data is asked for, and we can easily swap out </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">save</span></strong><span class="koboSpan" id="kobo.149.1"> objects as needed. </span><span class="koboSpan" id="kobo.149.2">This also means the abstract functionality from the parent can be called the same way wherever it is used, making for easier maintenance as </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">systems grow:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.151.1"><img alt="Figure 2.3 – UML diagram showing inheritance of﻿ SaveClass﻿ with Liskov substitution principle applied" src="image/Figure_02.03_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.152.1">Figure 2.3 – UML diagram showing inheritance of SaveClass with Liskov substitution principle applied</span></p>
<p><span class="koboSpan" id="kobo.153.1">So, if we apply the Liskov substitution to </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">our code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.155.1">Excerpt from a program calling the better save system</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
SaveClass* _XboxSaver = new SaveClass_Xbox("filePath");
SaveClass* _CloudSaver = new SaveClass_Cloud(new IP());
SaveData* _DataToSave;
//Some code to prepare save data
_XboxSaver-&gt;SaveSomeData(_DataToSave);
_CloudSaver-&gt;SaveSomeData(_DataToSave);</span></pre> <p><span class="koboSpan" id="kobo.157.1">As you</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.158.1"> can see, the</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.159.1"> calls become the same format and are therefore substitutable and satisfy </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">the principle.</span></span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.161.1">Interface segregation</span></h2>
<p><span class="koboSpan" id="kobo.162.1">In </span><em class="italic"><span class="koboSpan" id="kobo.163.1">Agile Software Development: Principles, Patterns, and Practices</span></em><span class="koboSpan" id="kobo.164.1">, Robert C. </span><span class="koboSpan" id="kobo.164.2">Martin said </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">the following:</span></span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.166.1">A client should never be forced to implement an interface that it doesn’t use, or clients shouldn’t be forced to depend on methods they do not use.</span></p>
<p><span class="koboSpan" id="kobo.167.1">If the </span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.168.1">parent defines an abstract function, the </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.169.1">child must override it. </span><span class="koboSpan" id="kobo.169.2">This causes issues when implementing an abstract function for some of the child classes as the other children that don’t need that functionality must override to immediately nullify it. </span><span class="koboSpan" id="kobo.169.3">The solution can either be to extend the inheritance so that there is another layer for the classes in need of this extra functionality or to create an interface (only available in multi-inheritance languages) that adds the functionality to </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">certain subclasses.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Going back to the save system, if you need to get account authorization before saving on Xbox and PlayStation, then this can be done via inheritance. </span><span class="koboSpan" id="kobo.171.2">A new sub-class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">Save</span></strong><span class="koboSpan" id="kobo.173.1"> can be made, which declares an abstract function for getting authorization. </span><span class="koboSpan" id="kobo.173.2">This then becomes the parent for each save system that needs </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">the function:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.175.1"><img alt="Figure 2.4 – UML diagram showing ﻿SaveClass﻿ inheritance with interface segregation applied through pure inheritance" src="image/Figure_02.04_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.176.1">Figure 2.4 – UML diagram showing SaveClass inheritance with interface segregation applied through pure inheritance</span></p>
<p><span class="koboSpan" id="kobo.177.1">So, if we apply the concept of interface segregation to </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">our code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.179.1">Excerpt from a program that checks authentication before saving</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.180.1">
SaveClass2FA* _PSNSaver = new SaveClass_PSN("filePath");
SaveData* _DataToSave;
// Some code to prepare save data
if (_PSNSaver-&gt;Authenticate())
{
    _PSNSaver-&gt;SaveSomeData(_DataToSave);
}</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.181.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.182.1">Technically, the structure shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.183.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.184.1">.4</span></em><span class="koboSpan" id="kobo.185.1"> will violate the previous Liskov substitution principle as sub-classes that don’t inherit from the middle </span><em class="italic"><span class="koboSpan" id="kobo.186.1">interface</span></em><span class="koboSpan" id="kobo.187.1"> layer can’t be substituted into the pattern. </span><span class="koboSpan" id="kobo.187.2">Deciding which principle is more important is part of the skill of designing code and is usually learned </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">with practice.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">Although </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.190.1">this inheritance structure does satisfy the </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">interface segregation</span></strong><span class="koboSpan" id="kobo.192.1"> principle, it does end up getting quite messy with lots of </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.193.1">segregated behaviors. </span><span class="koboSpan" id="kobo.193.2">There is another way. </span><span class="koboSpan" id="kobo.193.3">Applying the first principle of single responsibility to this tree, we remove each segregated behavior into its own class. </span><span class="koboSpan" id="kobo.193.4">Objects of this can then be created and injected into the save system where needed. </span><span class="koboSpan" id="kobo.193.5">The result is more independent classes, but cleaner, smaller inheritance structures. </span><span class="koboSpan" id="kobo.193.6">This is what is known as using </span><strong class="bold"><span class="koboSpan" id="kobo.194.1">class composition</span></strong><span class="koboSpan" id="kobo.195.1"> to solve a </span><a id="_idIndexMarker056"/><span class="No-Break"><span class="koboSpan" id="kobo.196.1">structure problem:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.197.1"><img alt="Figure 2.5 – UML diagram showing ﻿SaveClass﻿ alongside ﻿Auth﻿ hierarchy" src="image/Figure_02.05_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.198.1">Figure 2.5 – UML diagram showing SaveClass alongside Auth hierarchy</span></p>
<p><span class="koboSpan" id="kobo.199.1">So, if we apply class composition to </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">our code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.201.1">Excerpt of a program that implements Figure 2.5</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.202.1">
Auth* _Authorizer = new Auth();
SaveClass* _XboxSaver = new SaveClass_Xbox("filePath");
SaveData* _DataToSave;
//Some code to prepare save data
_Authorizer-&gt;Authorize();
_XboxSaver-&gt;SaveSomeData(_DataToSave, _Authorizer);</span></pre> <p><span class="koboSpan" id="kobo.203.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">SaveSomeData</span></strong><span class="koboSpan" id="kobo.205.1"> function</span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.206.1"> would then check the</span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.207.1"> authorized status of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">Auth</span></strong><span class="koboSpan" id="kobo.209.1"> type object as it </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">needs to.</span></span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.211.1">Dependency inversion</span></h2>
<p><span class="koboSpan" id="kobo.212.1">In </span><em class="italic"><span class="koboSpan" id="kobo.213.1">Agile Software Development: Principles, Patterns, and Practices</span></em><span class="koboSpan" id="kobo.214.1">, Robert C. </span><span class="koboSpan" id="kobo.214.2">Martin said </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">the following:</span></span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.216.1">Entities must depend on abstractions, not on concretions. </span><span class="koboSpan" id="kobo.216.2">It states that the high-level module must not depend on the low-level modules, but they should depend on abstractions.</span></p>
<p><span class="koboSpan" id="kobo.217.1">This</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.218.1"> pattern is the most useful for UE5. </span><span class="koboSpan" id="kobo.218.2">Simply put, if </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.219.1">you inject a reference to a class somewhere, it really should be the highest-level abstract parent that still has the functionality you need. </span><span class="koboSpan" id="kobo.219.2">Easy examples would be in a PlayerController, where you don’t reference a specific pawn sub-class but, instead, the idea of a pawn. </span><span class="koboSpan" id="kobo.219.3">Better than that, you could reference the interface for the functionality you need; this will prevent long cast chains to filter for </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">the type.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">In the save example, the injection of the account authorizer is a concretion that assumes every </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">save</span></strong><span class="koboSpan" id="kobo.223.1"> module will authorize in the same way. </span><span class="koboSpan" id="kobo.223.2">In reality, it would be much more appropriate to inject an </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">Authorizer</span></strong><span class="koboSpan" id="kobo.225.1"> parent that only contains the authorized status. </span><span class="koboSpan" id="kobo.225.2">When creating an object to inject, we then create it as the correct sub-class and call its </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">Authorize</span></strong><span class="koboSpan" id="kobo.227.1"> function, which is free to then operate as it needs to. </span><span class="koboSpan" id="kobo.227.2">You can even reuse this structure for authorization of other things </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">elsewhere too:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.229.1"><img alt="Figure 2.6 – UML diagram showing ﻿SaveClass﻿ alongside ﻿Auth﻿ hierarchy" src="image/Figure_02.06_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.230.1">Figure 2.6 – UML diagram showing SaveClass alongside Auth hierarchy</span></p>
<p><span class="koboSpan" id="kobo.231.1">So, if we apply dependency inversion to our code, it would </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">look like:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.233.1">Excerpt of a program that implements Figure 2.6</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.234.1">
Auth* _Authorizer = new Auth_Xbox();
SaveClass* _XboxSaver = new SaveClass_Xbox("filePath");
SaveData* _DataToSave;
//Some code to prepare save data
_Authorizer-&gt;Authorize();
_XboxSaver-&gt;SaveSomeData(_DataToSave, _Authorizer);</span></pre> <p><span class="koboSpan" id="kobo.235.1">That’s a </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.236.1">lot of theory to have gone through, but</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.237.1"> with it, we can make tangible improvements to dire systems. </span><span class="koboSpan" id="kobo.237.2">These improvements should shore up the foundations of our code, setting it up to receive the more structure-heavy patterns we will be using later in </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">The next section will guide you through an average beginner developer’s process of creating a project and getting something working quickly so that you can then apply what you have learned to see a </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">tangible improvement.</span></span></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.241.1">Exploring solutions to common problems</span></h1>
<p><span class="koboSpan" id="kobo.242.1">We are going to explore a series of examples of Blueprint scripts where the intended result has been achieved but causes issues simply due to the approach taken. </span><span class="koboSpan" id="kobo.242.2">We will then offer an improved approach, which makes the Blueprint more performant, tidier, more reusable, or easier to expand at a later point in development. </span><span class="koboSpan" id="kobo.242.3">The purpose of this section is to help you begin to recognize potential areas for improvement within your own code, regardless of whether you are working in Blueprint </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">or C++.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.244.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.245.1">Everything we are about to look at in this section is bad code to prove a point. </span><span class="koboSpan" id="kobo.245.2">Even the fixes that follow are not perfect, but it has been written for the purpose of education and so is </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">simplified somewhat.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">For this section, you will need an empty project that you may have already created at the beginning of the chapter and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">content</span></strong><span class="koboSpan" id="kobo.249.1"> folder from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">chapter2</span></strong><span class="koboSpan" id="kobo.251.1"> branch of the GitHub link provided at the start of </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">the chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">If you’ve not used GitHub before, click the </span><strong class="bold"><span class="koboSpan" id="kobo.254.1">Code</span></strong><span class="koboSpan" id="kobo.255.1"> button on the branch view and then click </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">Download Zip</span></strong><span class="koboSpan" id="kobo.257.1">. </span><span class="koboSpan" id="kobo.257.2">This will download a </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">.zip</span></strong><span class="koboSpan" id="kobo.259.1"> folder that you can then extract into your new </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">project folder.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">Place the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">HelloPatterns</span></strong><span class="koboSpan" id="kobo.263.1"> folder from </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">.zip</span></strong><span class="koboSpan" id="kobo.265.1"> file directly into your content directory; this will provide you with some examples of bad practises that we will first review before explaining how to </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">fix them.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">To fix the problems, first, duplicate each of the Blueprint assets and change the suffix from </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">_Bad</span></strong><span class="koboSpan" id="kobo.269.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">_Better</span></strong><span class="koboSpan" id="kobo.271.1">. </span><span class="koboSpan" id="kobo.271.2">This will ensure you can look back and see the differences between where we start and where we finish when reworking </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">these Blueprints.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">To start fixing these Blueprints, you will need to open them by double-clicking on them in the </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">Content Browser</span></strong><span class="koboSpan" id="kobo.275.1">. </span><span class="koboSpan" id="kobo.275.2">Once open, navigate to the </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">Event Graph</span></strong><span class="koboSpan" id="kobo.277.1"> tab where you will find the examples we’ve covered. </span><span class="koboSpan" id="kobo.277.2">Follow the steps under each of the </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">Solution</span></strong><span class="koboSpan" id="kobo.279.1"> headings to improve </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">the Blueprints.</span></span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.281.1">The moving box problem</span></h2>
<p><span class="koboSpan" id="kobo.282.1">The</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.283.1"> first example we’re going to look at is a simple moving box (a static mesh component) that slides from a start location (relative </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">0</span></strong><span class="koboSpan" id="kobo.285.1">,</span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">0</span></strong><span class="koboSpan" id="kobo.287.1">,</span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">50</span></strong><span class="koboSpan" id="kobo.289.1">) to an end location (relative </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">200</span></strong><span class="koboSpan" id="kobo.291.1">,</span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">0</span></strong><span class="koboSpan" id="kobo.293.1">,</span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">50)</span></strong><span class="koboSpan" id="kobo.295.1">. </span><span class="koboSpan" id="kobo.295.2">Both locations have been stored as vector variables within the Blueprint and their defaults set, </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">as mentioned.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.297.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.298.1">Here, we are using relative location, a vector variable that defines the location of an entity based on the location of its parent. </span><span class="koboSpan" id="kobo.298.2">A relative location of (0,0,50) on a component whose parent actor is positioned at (0,0,0) in the world would also be (0,0,50) in the world. </span><span class="koboSpan" id="kobo.298.3">However, if the parent actor were to move to (10,10,0), the component’s world location would be (10,10,50) as the world and relative locations are combined to provide a world location for </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">the component.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">The Blueprint code to move the box has two logic chains selected via a branch node (Blueprint’s version of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">if</span></strong><span class="koboSpan" id="kobo.302.1"> statement) using </span><strong class="bold"><span class="koboSpan" id="kobo.303.1">Event Tick</span></strong><span class="koboSpan" id="kobo.304.1"> (Unreal’s form of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">Update</span></strong><span class="koboSpan" id="kobo.306.1"> loop). </span><span class="koboSpan" id="kobo.306.2">One logic chain is used to move the box forward, from start to end, and the other is used to move it back. </span><span class="koboSpan" id="kobo.306.3">The decision of which to use is controlled by the </span><strong class="bold"><span class="koboSpan" id="kobo.307.1">Forward</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.308.1">Boolean variable:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.309.1"><img alt="Figure 2.7 – The Event Tick Branch for selecting which direction to move" src="image/Figure_02.07_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.310.1">Figure 2.7 – The Event Tick Branch for selecting which direction to move</span></p>
<p><span class="koboSpan" id="kobo.311.1">The </span><em class="italic"><span class="koboSpan" id="kobo.312.1">move forward</span></em><span class="koboSpan" id="kobo.313.1"> logic chain adds 1 cm to the </span><em class="italic"><span class="koboSpan" id="kobo.314.1">x</span></em><span class="koboSpan" id="kobo.315.1"> coordinate of the box’s relative location and updates the position of the box, relative to the actor using a </span><strong class="bold"><span class="koboSpan" id="kobo.316.1">Set Relative </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.317.1">Location</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.318.1"> node.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">A check then</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.320.1"> takes place, comparing the current relative location to the end point with a 0.0 error tolerance. </span><span class="koboSpan" id="kobo.320.2">If the locations are equal, then </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">Forward</span></strong><span class="koboSpan" id="kobo.322.1"> is set to </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">False</span></strong><span class="koboSpan" id="kobo.324.1">, which means on the next tick, the branch will select the reverse </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">logic change:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.326.1"><img alt="Figure 2.8 – The move forward logic chain for the moving box" src="image/Figure_02.08_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.327.1">Figure 2.8 – The move forward logic chain for the moving box</span></p>
<p><span class="koboSpan" id="kobo.328.1">The </span><em class="italic"><span class="koboSpan" id="kobo.329.1">move backward</span></em><span class="koboSpan" id="kobo.330.1"> logic chain subtracts 1 cm from the </span><em class="italic"><span class="koboSpan" id="kobo.331.1">x</span></em><span class="koboSpan" id="kobo.332.1"> coordinate of the box’s relative location and updates the position in the same way. </span><span class="koboSpan" id="kobo.332.2">The difference here is that the check compares the relative location to the end point and, when they are equal, sets </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">Forward</span></strong><span class="koboSpan" id="kobo.334.1"> to </span><strong class="bold"><span class="koboSpan" id="kobo.335.1">True</span></strong><span class="koboSpan" id="kobo.336.1">, flicking the branch to the </span><em class="italic"><span class="koboSpan" id="kobo.337.1">move forward</span></em><span class="koboSpan" id="kobo.338.1"> logic on the next tick. </span><span class="koboSpan" id="kobo.338.2">This repeats indefinitely or until the actor </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">is destroyed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.340.1"><img alt="Figure 2.9 – The move backward logic chain for moving the box" src="image/Figure_02.09_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.341.1">Figure 2.9 – The move backward logic chain for moving the box</span></p>
<p><span class="koboSpan" id="kobo.342.1">The issue we </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.343.1">have here is we are checking on every tick if the box has arrived at its destination. </span><span class="koboSpan" id="kobo.343.2">Doing the comparison on one box may not cause many issues, but if you are moving a lot of items in a scene, this sort of innocent calculation is a waste of resources, something we are keen </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">to avoid.</span></span></p>
<h3><span class="koboSpan" id="kobo.345.1">Solution to the moving box problem</span></h3>
<p><span class="koboSpan" id="kobo.346.1">Let’s take a</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.347.1"> look at building a better approach using </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">a timeline:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.349.1">Begin by deleting all of the nodes in the </span><strong class="bold"><span class="koboSpan" id="kobo.350.1">Event Graph</span></strong><span class="koboSpan" id="kobo.351.1">, except for the </span><strong class="bold"><span class="koboSpan" id="kobo.352.1">Set Relative Location</span></strong><span class="koboSpan" id="kobo.353.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.354.1">Static Mesh </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.355.1">Box</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.356.1"> nodes.</span></span></li>
<li><span class="koboSpan" id="kobo.357.1">Start by adding a custom event node by right-clicking on the graph, typing </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">custom event</span></strong><span class="koboSpan" id="kobo.359.1">, and pressing </span><em class="italic"><span class="koboSpan" id="kobo.360.1">Enter</span></em><span class="koboSpan" id="kobo.361.1">. </span><span class="koboSpan" id="kobo.361.2">You can select the </span><strong class="bold"><span class="koboSpan" id="kobo.362.1">Add Custom Event…</span></strong><span class="koboSpan" id="kobo.363.1"> option at any point; typing more of the name will simply help reduce the options available, hopefully speeding </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">things up:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.365.1"><img alt=" Figure 2.10 – Node creation in the Event Graph with custom event filtered" src="image/Figure_02.10_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.366.1"> Figure 2.10 – Node creation in the Event Graph with custom event filtered</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.367.1">Call the</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.368.1"> custom event </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">PingPongMovement</span></strong><span class="koboSpan" id="kobo.370.1">—this is intended at this point to be quite literal as that’s what we </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">are coding:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.372.1"><img alt=" Figure 2.11 – A custom event node for ﻿PingPongMovement﻿" src="image/Figure_02.11_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.373.1"> Figure 2.11 – A custom event node for PingPongMovement</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.374.1">Drag out of the </span><strong class="bold"><span class="koboSpan" id="kobo.375.1">exec pin</span></strong><span class="koboSpan" id="kobo.376.1"> (white arrow) and type </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">add timeline</span></strong><span class="koboSpan" id="kobo.378.1">, select </span><strong class="bold"><span class="koboSpan" id="kobo.379.1">Add Timeline…</span></strong><span class="koboSpan" id="kobo.380.1"> from the popup, and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">T_MoveBox</span></strong><span class="koboSpan" id="kobo.382.1"> when prompted. </span><span class="koboSpan" id="kobo.382.2">This will give you a timeline node, a special type of node that contains one or more graphs that can be used to provide values for other nodes that are called during the timeline node’s </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.383.1">Update</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.384.1"> chain:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.385.1"><img alt="Figure 2.12 – A timeline node, named T_MoveBox" src="image/Figure_02.12_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.386.1">Figure 2.12 – A timeline node, named T_MoveBox</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.387.1">Double-click the </span><strong class="bold"><span class="koboSpan" id="kobo.388.1">T_MoveBox</span></strong><span class="koboSpan" id="kobo.389.1"> node; this will open a new tab to allow us to create </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.390.1">and edit the graphs in this timeline. </span><span class="koboSpan" id="kobo.390.2">Note that the length of the timeline, shown at the top of the tab, is 5.0 seconds. </span><span class="koboSpan" id="kobo.390.3">This means the timeline will execute its update chain for a duration of 5.0 seconds from when it is </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">first called:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.392.1"><img alt=" Figure 2.13 – An empty timeline tab with default settings" src="image/Figure_02.13_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.393.1"> Figure 2.13 – An empty timeline tab with default settings</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.394.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.395.1">+Track</span></strong><span class="koboSpan" id="kobo.396.1"> button and choose </span><strong class="bold"><span class="koboSpan" id="kobo.397.1">Add </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.398.1">Float Track</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.400.1">Name</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.401.1"> the track </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">MovementAlpha</span></strong><span class="koboSpan" id="kobo.403.1">. </span><span class="koboSpan" id="kobo.403.2">This will add a float track graph and float value output to the </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">timeline node:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.405.1"><img alt="Figure 2.14 – A float track added to the timeline" src="image/Figure_02.14_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.406.1">Figure 2.14 – A float track added to the timeline</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.407.1">Right-click on the float graph and select </span><strong class="bold"><span class="koboSpan" id="kobo.408.1">Add Key to CurveFloat_0</span></strong><span class="koboSpan" id="kobo.409.1">; repeat this to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">second key.</span></span></li>
<li><span class="koboSpan" id="kobo.411.1">Select the first key and, using the </span><strong class="bold"><span class="koboSpan" id="kobo.412.1">Time</span></strong><span class="koboSpan" id="kobo.413.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.414.1">Value</span></strong><span class="koboSpan" id="kobo.415.1"> variable boxes at the top of the graph, enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">0.0</span></strong><span class="koboSpan" id="kobo.417.1"> into </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">both variables.</span></span></li>
<li><span class="koboSpan" id="kobo.419.1">Select the second key and set </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">Time</span></strong><span class="koboSpan" id="kobo.421.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">5.0</span></strong><span class="koboSpan" id="kobo.423.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.424.1">Value</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.425.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">1.0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.428.1"><img alt="Figure 2.15 – The MovementAlpha track with linear graph" src="image/Figure_02.15_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.429.1">Figure 2.15 – The MovementAlpha track with linear graph</span></p>
<ol>
<li value="11"><span class="koboSpan" id="kobo.430.1">Return to the </span><strong class="bold"><span class="koboSpan" id="kobo.431.1">Event Graph</span></strong><span class="koboSpan" id="kobo.432.1">; you should now see the timeline node has a </span><strong class="bold"><span class="koboSpan" id="kobo.433.1">Movement Alpha</span></strong><span class="koboSpan" id="kobo.434.1"> float pin on the right-hand side of the node; accessing this pin will provide you with the current value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">MovementAlpha</span></strong><span class="koboSpan" id="kobo.436.1"> curve based on the</span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.437.1"> current time of </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">the timeline:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.439.1"><img alt="Figure 2.16 – The timeline node, now with the Movement Alpha float pin" src="image/Figure_02.16_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.440.1">Figure 2.16 – The timeline node, now with the Movement Alpha float pin</span></p>
<ol>
<li value="12"><span class="koboSpan" id="kobo.441.1">Position and connect the </span><strong class="bold"><span class="koboSpan" id="kobo.442.1">Set Relative Location</span></strong><span class="koboSpan" id="kobo.443.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.444.1">Static Mesh Box</span></strong><span class="koboSpan" id="kobo.445.1"> nodes from the old solution to the </span><strong class="bold"><span class="koboSpan" id="kobo.446.1">Update</span></strong><span class="koboSpan" id="kobo.447.1"> output pin from </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">the timeline.</span></span></li>
<li><span class="koboSpan" id="kobo.449.1">Drag from the </span><strong class="bold"><span class="koboSpan" id="kobo.450.1">New Location</span></strong><span class="koboSpan" id="kobo.451.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.452.1">Set Relative Location</span></strong><span class="koboSpan" id="kobo.453.1"> node and type </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">lerp</span></strong><span class="koboSpan" id="kobo.455.1"> to create a </span><strong class="bold"><span class="koboSpan" id="kobo.456.1">Lerp (Vector)</span></strong><span class="koboSpan" id="kobo.457.1"> node. </span><span class="koboSpan" id="kobo.457.2">This setup allows us to interpolate between two vectors, to control where our box moves, relative to the </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">object’s location.</span></span></li>
<li><span class="koboSpan" id="kobo.459.1">Drag and drop the </span><strong class="bold"><span class="koboSpan" id="kobo.460.1">Start Point</span></strong><span class="koboSpan" id="kobo.461.1"> variable from the left side of the </span><strong class="bold"><span class="koboSpan" id="kobo.462.1">Blueprint Editor</span></strong><span class="koboSpan" id="kobo.463.1"> window onto the </span><strong class="bold"><span class="koboSpan" id="kobo.464.1">A</span></strong><span class="koboSpan" id="kobo.465.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.466.1">Lerp (Vector)</span></strong><span class="koboSpan" id="kobo.467.1"> node. </span><span class="koboSpan" id="kobo.467.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.468.1">A</span></strong><span class="koboSpan" id="kobo.469.1"> pin is the start value for </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">the lerp.</span></span></li>
<li><span class="koboSpan" id="kobo.471.1">Drag and drop the </span><strong class="bold"><span class="koboSpan" id="kobo.472.1">End Point</span></strong><span class="koboSpan" id="kobo.473.1"> variable onto the </span><strong class="bold"><span class="koboSpan" id="kobo.474.1">B</span></strong><span class="koboSpan" id="kobo.475.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.476.1">Lerp (Vector)</span></strong><span class="koboSpan" id="kobo.477.1"> node. </span><span class="koboSpan" id="kobo.477.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.478.1">B</span></strong><span class="koboSpan" id="kobo.479.1"> pin is the end value for </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">the lerp.</span></span></li>
<li><span class="koboSpan" id="kobo.481.1">Connect</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.482.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.483.1">Alpha</span></strong><span class="koboSpan" id="kobo.484.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.485.1">Lerp (Vector)</span></strong><span class="koboSpan" id="kobo.486.1"> node to the </span><strong class="bold"><span class="koboSpan" id="kobo.487.1">Movement Alpha</span></strong><span class="koboSpan" id="kobo.488.1"> pin of the </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">timeline node:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.490.1"><img alt="Figure 2.17 – The update logic of the timeline completed" src="image/Figure_02.17_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.491.1">Figure 2.17 – The update logic of the timeline completed</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.492.1">Now the update logic is complete, we need to set our Blueprint up to start the timeline. </span><span class="koboSpan" id="kobo.492.2">To do this, proceed </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">as follows:</span></span></p>
<ol>
<li value="17"><span class="koboSpan" id="kobo.494.1">Right-click on the </span><strong class="bold"><span class="koboSpan" id="kobo.495.1">Event Graph</span></strong><span class="koboSpan" id="kobo.496.1"> and create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">Event BeginPlay</span></strong><span class="koboSpan" id="kobo.498.1"> node. </span><span class="koboSpan" id="kobo.498.2">This is a built-in event that is called when an actor is created (either at the beginning of the game or when spawned by </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">another function).</span></span></li>
<li><span class="koboSpan" id="kobo.500.1">Drag out of the </span><strong class="bold"><span class="koboSpan" id="kobo.501.1">Event BeginPlay</span></strong><span class="koboSpan" id="kobo.502.1"> node and type </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">Ping Pong Movement</span></strong><span class="koboSpan" id="kobo.504.1">; you should now see a </span><strong class="bold"><span class="koboSpan" id="kobo.505.1">Ping Pong Movement</span></strong><span class="koboSpan" id="kobo.506.1"> option under the </span><strong class="bold"><span class="koboSpan" id="kobo.507.1">Call Function</span></strong><span class="koboSpan" id="kobo.508.1"> rollout—select it. </span><span class="koboSpan" id="kobo.508.2">This will create a call to our </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">custom event:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.510.1"><img alt="Figure 2.18 – Ping Pong Movement being called from the Event BeginPlay event" src="image/Figure_02.18_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.511.1">Figure 2.18 – Ping Pong Movement being called from the Event BeginPlay event</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.512.1">This will </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.513.1">now move the box from the start location to the end location in relative space; give it a test by placing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">BP_MovingBox_Better</span></strong><span class="koboSpan" id="kobo.515.1"> Blueprint from the </span><strong class="bold"><span class="koboSpan" id="kobo.516.1">Content Browser</span></strong><span class="koboSpan" id="kobo.517.1"> into the world and clicking the </span><em class="italic"><span class="koboSpan" id="kobo.518.1">Play</span></em><span class="koboSpan" id="kobo.519.1"> button above </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">the viewport:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.521.1"><img alt="Figure 2.19 – Play in Editor controls from the main Unreal Engine Editor user interface" src="image/Figure_02.19_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.522.1">Figure 2.19 – Play in Editor controls from the main Unreal Engine Editor user interface</span></p>
<p><span class="koboSpan" id="kobo.523.1">Next, we want to set the Blueprint up so that the box moves back to the start location once it has reached the end location and loops indefinitely. </span><span class="koboSpan" id="kobo.523.2">To do this, proceed </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.525.1">Detach the </span><strong class="bold"><span class="koboSpan" id="kobo.526.1">Ping Pong Movement</span></strong><span class="koboSpan" id="kobo.527.1"> custom event node from the timeline node by holding </span><em class="italic"><span class="koboSpan" id="kobo.528.1">Alt</span></em><span class="koboSpan" id="kobo.529.1"> on the keyboard and clicking either end of </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">the connection.</span></span></li>
<li><span class="koboSpan" id="kobo.531.1">Drag from the </span><strong class="bold"><span class="koboSpan" id="kobo.532.1">Ping Pong Movement</span></strong><span class="koboSpan" id="kobo.533.1"> custom event node and create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">Flip Flop</span></strong><span class="koboSpan" id="kobo.535.1"> node. </span><span class="koboSpan" id="kobo.535.2">This node swaps between exec pins </span><strong class="bold"><span class="koboSpan" id="kobo.536.1">A</span></strong><span class="koboSpan" id="kobo.537.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.538.1">B</span></strong><span class="koboSpan" id="kobo.539.1"> each time it is entered. </span><span class="koboSpan" id="kobo.539.2">The node always starts with </span><strong class="bold"><span class="koboSpan" id="kobo.540.1">A</span></strong><span class="koboSpan" id="kobo.541.1"> for its first run. </span><span class="koboSpan" id="kobo.541.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.542.1">bool</span></strong><span class="koboSpan" id="kobo.543.1"> pin can be used to inform other logic, but we won’t need that for </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">this solution.</span></span></li>
<li><span class="koboSpan" id="kobo.545.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.546.1">A</span></strong><span class="koboSpan" id="kobo.547.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.548.1">Flip Flop</span></strong><span class="koboSpan" id="kobo.549.1"> node to the </span><strong class="bold"><span class="koboSpan" id="kobo.550.1">Play from Start</span></strong><span class="koboSpan" id="kobo.551.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.552.1">T_MoveBox</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.553.1">timeline node.</span></span></li>
<li><span class="koboSpan" id="kobo.554.1">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.555.1">B</span></strong><span class="koboSpan" id="kobo.556.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.557.1">Flip Flop</span></strong><span class="koboSpan" id="kobo.558.1"> node to the </span><strong class="bold"><span class="koboSpan" id="kobo.559.1">Reverse from End</span></strong><span class="koboSpan" id="kobo.560.1"> pin of the </span><strong class="bold"><span class="koboSpan" id="kobo.561.1">T_MoveBox</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.562.1">timeline node:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.563.1"><img alt="Figure 2.20 – Flip Flop node and timeline" src="image/Figure_02.20_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.564.1">Figure 2.20 – Flip Flop node and timeline</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.565.1">Lastly, connect the </span><strong class="bold"><span class="koboSpan" id="kobo.566.1">Finished</span></strong><span class="koboSpan" id="kobo.567.1"> pin of the timeline node to a </span><strong class="bold"><span class="koboSpan" id="kobo.568.1">Ping Pong Movement</span></strong><span class="koboSpan" id="kobo.569.1"> function call node (either the existing one or a new one), which will restart the</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.570.1"> process every time </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">it finishes:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.572.1"><img alt="Figure 2.21 – The improved Blueprint for the moving box, laid out for readability in the editor" src="image/Figure_02.21_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.573.1">Figure 2.21 – The improved Blueprint for the moving box, laid out for readability in the editor</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.574.1">Now, try pressing the </span><em class="italic"><span class="koboSpan" id="kobo.575.1">Play</span></em><span class="koboSpan" id="kobo.576.1"> button in the editor (the </span><em class="italic"><span class="koboSpan" id="kobo.577.1">Play</span></em><span class="koboSpan" id="kobo.578.1"> button above the viewport) again. </span><span class="koboSpan" id="kobo.578.2">You should now see that the box moves in one direction and then the other, over </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">and over.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">This approach offers a more performant solution due to not requiring the comparison. </span><span class="koboSpan" id="kobo.580.2">The update logic is still constantly running, in the same way as the tick approach was for the </span><strong class="bold"><span class="koboSpan" id="kobo.581.1">Set Relative Location</span></strong><span class="koboSpan" id="kobo.582.1"> node, but because the timeline controls when the direction change occurs, we no longer need to do any comparisons of vector locations after </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">every move.</span></span></p>
<p><span class="koboSpan" id="kobo.584.1">The timeline can also afford us more control over situations when we want to move things. </span><span class="koboSpan" id="kobo.584.2">The current setup features linear movement controlled by the linear curve. </span><span class="koboSpan" id="kobo.584.3">Changing the key types</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.585.1"> to automatic (right-click the key) or adding additional keys can provide more interesting movements and allow you to incorporate considerations such as the principles of animation into your moving objects, something that is very difficult to do without using </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">a curve.</span></span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.587.1">The rotating box problem</span></h2>
<p><span class="koboSpan" id="kobo.588.1">The</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.589.1"> second example we’re going to look at is a simple rotating box. </span><span class="koboSpan" id="kobo.589.2">The Blueprint actor contains the same static mesh component, but this time it’s set up to spin in place 2 degrees of rotation on </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">each tick:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.591.1"><img alt="Figure 2.22 – The rotating box Blueprint code" src="image/Figure_02.22_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.592.1">Figure 2.22 – The rotating box Blueprint code</span></p>
<p><span class="koboSpan" id="kobo.593.1">The Blueprint code also does a check for when the rotation of the box gets to 360 degrees or above and minuses 360 from the rotation value, to ensure that we keep the rotation value from spiraling out of control as the </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">game plays:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.595.1"><img alt="Figure 2.23 – The check to maintain rotations between 0 and 360 degrees" src="image/Figure_02.23_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.596.1">Figure 2.23 – The check to maintain rotations between 0 and 360 degrees</span></p>
<p><span class="koboSpan" id="kobo.597.1">The check that’s been put in place is relatively sensible, and if it were part of a single rotation or </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.598.1">working with a character rotation within an animation Blueprint, then it would </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">be ideal.</span></span></p>
<p><span class="koboSpan" id="kobo.600.1">The problem with this implementation is that we are once again working on tick and doing checks that will become more cumbersome with every additional </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">rotating box.</span></span></p>
<h3><span class="koboSpan" id="kobo.602.1">Solution to the rotating box problem</span></h3>
<p><span class="koboSpan" id="kobo.603.1">For the </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.604.1">rotating box, the solution is to use a pre-existing solution. </span><span class="koboSpan" id="kobo.604.2">Instead of coding differently, we can use a component that is provided as part of UE5 to achieve the desired result. </span><span class="koboSpan" id="kobo.604.3">Follow the </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">next steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.606.1">Firstly, delete all of the logic from the </span><strong class="bold"><span class="koboSpan" id="kobo.607.1">Event Graph</span></strong><span class="koboSpan" id="kobo.608.1">, it is </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">not required.</span></span></li>
<li><span class="koboSpan" id="kobo.610.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.611.1">Components</span></strong><span class="koboSpan" id="kobo.612.1"> tab, click the </span><strong class="bold"><span class="koboSpan" id="kobo.613.1">Add</span></strong><span class="koboSpan" id="kobo.614.1"> button and search for a </span><strong class="bold"><span class="koboSpan" id="kobo.615.1">Rotating </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.616.1">Movement</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.617.1"> component:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.618.1"><img alt="Figure 2.24 – Rotating Movement component selected in the Add components list" src="image/Figure_02.24_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.619.1">Figure 2.24 – Rotating Movement component selected in the Add components list</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.620.1">Create a new variable by clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.621.1">+</span></strong><span class="koboSpan" id="kobo.622.1"> in the </span><strong class="bold"><span class="koboSpan" id="kobo.623.1">Variables</span></strong><span class="koboSpan" id="kobo.624.1"> rollout of the </span><strong class="bold"><span class="koboSpan" id="kobo.625.1">My </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.626.1">Blueprint</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.627.1"> tab.</span></span></li>
<li><span class="koboSpan" id="kobo.628.1">Name the variable </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">Rotation Rate</span></strong><span class="koboSpan" id="kobo.630.1"> and set the type to </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">Rotator</span></strong><span class="koboSpan" id="kobo.632.1"> by clicking on the current type (typically </span><strong class="bold"><span class="koboSpan" id="kobo.633.1">Boolean</span></strong><span class="koboSpan" id="kobo.634.1"> if you are working with a new Blueprint) and selecting </span><strong class="bold"><span class="koboSpan" id="kobo.635.1">Rotator</span></strong><span class="koboSpan" id="kobo.636.1"> from </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">the list.</span></span></li>
<li><span class="koboSpan" id="kobo.638.1">Make the variable </span><strong class="bold"><span class="koboSpan" id="kobo.639.1">Instance Editable</span></strong><span class="koboSpan" id="kobo.640.1"> by clicking the </span><em class="italic"><span class="koboSpan" id="kobo.641.1">eye</span></em><span class="koboSpan" id="kobo.642.1"> icon to the right of the variable type—this will allow the user to set the rotation rate of each box in </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">the scene.</span></span></li>
<li><span class="koboSpan" id="kobo.644.1">Compile the Blueprint and set the default value of the </span><strong class="bold"><span class="koboSpan" id="kobo.645.1">Rotation Rate</span></strong><span class="koboSpan" id="kobo.646.1"> variable </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">0,0,180</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.650.1"><img alt="Figure 2.25 – Resulting variables list in the My Blueprint tab" src="image/Figure_02.25_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.651.1">Figure 2.25 – Resulting variables list in the My Blueprint tab</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.652.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.653.1">Construction Script</span></strong><span class="koboSpan" id="kobo.654.1">, drag the </span><strong class="bold"><span class="koboSpan" id="kobo.655.1">Rotating Movement</span></strong><span class="koboSpan" id="kobo.656.1"> component into the graph </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.657.1">from the </span><strong class="bold"><span class="koboSpan" id="kobo.658.1">Components</span></strong><span class="koboSpan" id="kobo.659.1"> list. </span><span class="koboSpan" id="kobo.659.2">From the resulting </span><strong class="bold"><span class="koboSpan" id="kobo.660.1">Rotating Movement</span></strong><span class="koboSpan" id="kobo.661.1"> node, drag out and create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">Set Rotation Rate</span></strong><span class="koboSpan" id="kobo.663.1"> node. </span><span class="koboSpan" id="kobo.663.2">Connect the </span><strong class="bold"><span class="koboSpan" id="kobo.664.1">Rotation Rate</span></strong><span class="koboSpan" id="kobo.665.1"> variable you just created to the </span><strong class="bold"><span class="koboSpan" id="kobo.666.1">Rotation </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.667.1">Rate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.668.1"> pin:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.669.1"><img alt="Figure 2.26 – Construction script logic, setting the Rotating Movement component’s Rotation Rate using the created variable" src="image/Figure_02.26_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.670.1">Figure 2.26 – Construction script logic, setting the Rotating Movement component’s Rotation Rate using the created variable</span></p>
<p><span class="koboSpan" id="kobo.671.1">Now, when placing </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">BP_RotatingBox_Better</span></strong><span class="koboSpan" id="kobo.673.1"> into the world, you will be able to set the </span><strong class="bold"><span class="koboSpan" id="kobo.674.1">Rotation Rate</span></strong><span class="koboSpan" id="kobo.675.1"> value in the </span><strong class="bold"><span class="koboSpan" id="kobo.676.1">Defaults</span></strong><span class="koboSpan" id="kobo.677.1"> section of the </span><strong class="bold"><span class="koboSpan" id="kobo.678.1">Detail</span></strong><span class="koboSpan" id="kobo.679.1"> panel. </span><span class="koboSpan" id="kobo.679.2">Try placing multiple boxes and setting different values. </span><span class="koboSpan" id="kobo.679.3">When you press the </span><em class="italic"><span class="koboSpan" id="kobo.680.1">Play</span></em><span class="koboSpan" id="kobo.681.1"> button in </span><strong class="bold"><span class="koboSpan" id="kobo.682.1">Editor</span></strong><span class="koboSpan" id="kobo.683.1">, you should see the boxes rotating </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">as desired.</span></span></p>
<p><span class="koboSpan" id="kobo.685.1">This solution offers a more performant approach again due to its lack of reliance on </span><strong class="bold"><span class="koboSpan" id="kobo.686.1">Event Tick</span></strong><span class="koboSpan" id="kobo.687.1"> as well as the removal of the comparison checking when the rotation exceeds 360 degrees in order to maintain values inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">0-360 range.</span></span></p>
<p><span class="koboSpan" id="kobo.689.1">Another benefit </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.690.1">of this approach is that we now have an </span><strong class="bold"><span class="koboSpan" id="kobo.691.1">Instance Editable</span></strong><span class="koboSpan" id="kobo.692.1"> variable for rotation rate, which offers much more control and customization to the user, allowing each box to have its own rotation rate. </span><span class="koboSpan" id="kobo.692.2">The variable also allows us to spin the box on all three axes, whereas the original approach only rotated the box around the </span><em class="italic"><span class="koboSpan" id="kobo.693.1">z</span></em><span class="koboSpan" id="kobo.694.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">yaw) axis.</span></span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.696.1">The cascading cast chain problem</span></h2>
<p><span class="koboSpan" id="kobo.697.1">This example is </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.698.1">something we see quite regularly with new developers when communicating between different </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">Blueprint classes.</span></span></p>
<p><span class="koboSpan" id="kobo.700.1">The implementation here is for a game where a player character could be carrying one of three weapons: a pistol, shotgun, or rifle. </span><span class="koboSpan" id="kobo.700.2">Casts have been used to identify the class of the carried weapon, and when the cast returns true, each weapon’s fire event </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">is called:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.702.1"><img alt="Figure 2.27 – A cascading cast chain in the Blueprint in the CH_Example_Bad asset" src="image/Figure_02.27_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.703.1">Figure 2.27 – A cascading cast chain in the Blueprint in the CH_Example_Bad asset</span></p>
<p><span class="koboSpan" id="kobo.704.1">There are a few issues here. </span><span class="koboSpan" id="kobo.704.2">Firstly, it is the nature of the cast node in Unreal. </span><span class="koboSpan" id="kobo.704.3">While fine for prototyping, casts carry a resource impact where each actor we attempt to cast to gets loaded as part of the actor. </span><span class="koboSpan" id="kobo.704.4">So, in this case, all three weapons are included with the character in order to be able to check if the </span><strong class="bold"><span class="koboSpan" id="kobo.705.1">Carried Weapon</span></strong><span class="koboSpan" id="kobo.706.1"> child actor matches </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">their classes.</span></span></p>
<p><span class="koboSpan" id="kobo.708.1">You can see the effect of casts on memory by checking the size map of </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">any actor.</span></span></p>
<p><span class="koboSpan" id="kobo.710.1">To do this, proceed </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.712.1">Select the </span><strong class="bold"><span class="koboSpan" id="kobo.713.1">Actor</span></strong><span class="koboSpan" id="kobo.714.1"> Blueprint in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.715.1">Content Browser</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.717.1">Right-click and select </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.718.1">Size Map…</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.720.1">This will open a popup that will show the size (in memory) of the </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">chosen actor:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.722.1"><img alt="Figure 2.28 – Size map of the character Blueprint class with a cascading cast chain" src="image/Figure_02.28_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.723.1">Figure 2.28 – Size map of the character Blueprint class with a cascading cast chain</span></p>
<p><span class="koboSpan" id="kobo.724.1">The resulting </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.725.1">Blueprint (which only has the basic character class elements and the cast chain) is 149.9 kB, compared to the 56.1 kB of a standard character with just the child actor set as a pistol. </span><span class="koboSpan" id="kobo.725.2">This could be made smaller, further optimizing the Blueprint’s memory impact, by setting the default class of the child actor to be actor, but this isn’t necessary to prove the point we are trying to make; casting causes unnecessary </span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">memory issues:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.727.1"><img alt="Figure 2.29 – Size map of a character Blueprint class with just a child actor component" src="image/Figure_02.29_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.728.1">Figure 2.29 – Size map of a character Blueprint class with just a child actor component</span></p>
<p><span class="koboSpan" id="kobo.729.1">In both examples</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.730.1"> shown previously, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">Wpn_Pistol</span></strong><span class="koboSpan" id="kobo.732.1"> class is just an empty actor with a custom event that would, in an eventual game, fire the weapon; however the class currently only contains a </span><strong class="bold"><span class="koboSpan" id="kobo.733.1">Print String</span></strong><span class="koboSpan" id="kobo.734.1"> node with the name of the weapon followed by the word </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">Fire</span></strong><span class="koboSpan" id="kobo.736.1">. </span><span class="koboSpan" id="kobo.736.2">If you consider adding meshes, textures, particle systems, and audio components, the potential size of a character with a cascading cast chain becomes exponentially larger than it needs </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">to be.</span></span></p>
<p><span class="koboSpan" id="kobo.738.1">The second issue is the processing time of casting and waiting for failure before casting to the next weapon class and potentially waiting for that to fail. </span><span class="koboSpan" id="kobo.738.2">While we are talking milliseconds, it all adds up, especially if there are multiple characters and/or your non-player characters use the same </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">character Blueprint.</span></span></p>
<p><span class="koboSpan" id="kobo.740.1">The final issue with the cascading cast chain is the inflexibility (or extra work) that this approach provides. </span><span class="koboSpan" id="kobo.740.2">With the current setup, only the three weapons included in the chain can ever be used by the character. </span><span class="koboSpan" id="kobo.740.3">To expand the number of available weapons (as the project progresses or as part of a post-release piece of downloadable content), more casts will need to be added to the chain, multiplying the effects of the two aforementioned issues as well as being generally time-consuming to add them, particularly if there is any other logic required as part of the chain such as ammo management </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">and cooldowns.</span></span></p>
<p><span class="koboSpan" id="kobo.742.1">If you want to see the current setup’s output, then open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">TestLevel</span></strong><span class="koboSpan" id="kobo.744.1"> map from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">TestFiles</span></strong><span class="koboSpan" id="kobo.746.1"> directory, click </span><em class="italic"><span class="koboSpan" id="kobo.747.1">Play</span></em><span class="koboSpan" id="kobo.748.1">, and then click the left mouse button; you will see a print in the</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.749.1"> top-left corner of the screen related to each weapon. </span><span class="koboSpan" id="kobo.749.2">Pressing the </span><em class="italic"><span class="koboSpan" id="kobo.750.1">1</span></em><span class="koboSpan" id="kobo.751.1">, </span><em class="italic"><span class="koboSpan" id="kobo.752.1">2</span></em><span class="koboSpan" id="kobo.753.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.754.1">3</span></em><span class="koboSpan" id="kobo.755.1"> keys on your keyboard will swap between different </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">weapon classes.</span></span></p>
<p><span class="koboSpan" id="kobo.757.1">Let’s take a look at the solution to </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">this problem.</span></span></p>
<h3><span class="koboSpan" id="kobo.759.1">Solution to the cascading chain problem</span></h3>
<p><span class="koboSpan" id="kobo.760.1">There are</span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.761.1"> two potential solutions to the problem; the first is to use a parent and child class approach, casting to the parent class, which will allow </span><strong class="bold"><span class="koboSpan" id="kobo.762.1">Event Fire</span></strong><span class="koboSpan" id="kobo.763.1"> to be called on all of the children. </span><span class="koboSpan" id="kobo.763.2">As this still uses a cast, the parent class will still be included in the character, inflating the </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">memory usage.</span></span></p>
<p><span class="koboSpan" id="kobo.765.1">The second solution, which we are going to implement, is using </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">an interface.</span></span></p>
<p><span class="koboSpan" id="kobo.767.1">Interfaces allow two actors to communicate, without the need to identify the class type of the </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">target actor.</span></span></p>
<p><span class="koboSpan" id="kobo.769.1">Blueprint interfaces can be called from any Blueprint graph using an actor reference (which is the highest step of the class hierarchy). </span><span class="koboSpan" id="kobo.769.2">The receiving actor is required to implement the interface to define how it will respond to the interface </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">event call.</span></span></p>
<p><span class="koboSpan" id="kobo.771.1">In building this solution, we will create a simple Blueprint interface, add it to all of the weapons, and call it from the character, simply referencing the weapon as an actor class, negating the need for casting. </span><span class="koboSpan" id="kobo.771.2">Proceed </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.773.1">Firstly, create a Blueprint interface by right-clicking in the </span><strong class="bold"><span class="koboSpan" id="kobo.774.1">Content Browser</span></strong><span class="koboSpan" id="kobo.775.1"> and navigating to </span><strong class="bold"><span class="koboSpan" id="kobo.776.1">Blueprints</span></strong><span class="koboSpan" id="kobo.777.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.778.1">Blueprint Interface</span></strong><span class="koboSpan" id="kobo.779.1">. </span><span class="koboSpan" id="kobo.779.2">Name the resulting asset </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">BI_Weapon</span></strong><span class="koboSpan" id="kobo.781.1">. </span><span class="koboSpan" id="kobo.781.2">We use the prefix </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">BI</span></strong><span class="koboSpan" id="kobo.783.1"> to label this as a </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">Blueprint interface.</span></span></li>
<li><span class="koboSpan" id="kobo.785.1">Open the </span><strong class="bold"><span class="koboSpan" id="kobo.786.1">BI_Weapon</span></strong><span class="koboSpan" id="kobo.787.1"> asset by double-clicking it. </span><span class="koboSpan" id="kobo.787.2">You should see that in the top-right </span><strong class="bold"><span class="koboSpan" id="kobo.788.1">My Blueprint</span></strong><span class="koboSpan" id="kobo.789.1"> panel, a function has been created for you called </span><strong class="bold"><span class="koboSpan" id="kobo.790.1">NewFunction_0</span></strong><span class="koboSpan" id="kobo.791.1">, and its name is currently set up to be edited. </span><span class="koboSpan" id="kobo.791.2">Rename </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">this </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">Fire</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.795.1">Open </span><strong class="bold"><span class="koboSpan" id="kobo.796.1">WPN_Pistol</span></strong><span class="koboSpan" id="kobo.797.1">, click </span><strong class="bold"><span class="koboSpan" id="kobo.798.1">Class Settings</span></strong><span class="koboSpan" id="kobo.799.1"> in the toolbar, and then click the </span><strong class="bold"><span class="koboSpan" id="kobo.800.1">Add</span></strong><span class="koboSpan" id="kobo.801.1"> dropdown and search for </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">BI_Weapon</span></strong><span class="koboSpan" id="kobo.803.1">. </span><span class="koboSpan" id="kobo.803.2">Clicking it will add the </span><strong class="bold"><span class="koboSpan" id="kobo.804.1">BI Weapon</span></strong><span class="koboSpan" id="kobo.805.1"> interface to the </span><strong class="bold"><span class="koboSpan" id="kobo.806.1">Implemented </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.807.1">Interfaces</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.808.1"> list:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.809.1"><img alt="Figure 2.30 – BI Weapon in the Implemented Interfaces list" src="image/Figure_02.30_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.810.1">Figure 2.30 – BI Weapon in the Implemented Interfaces list</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.811.1">This will now have added a </span><strong class="bold"><span class="koboSpan" id="kobo.812.1">Fire</span></strong><span class="koboSpan" id="kobo.813.1"> function under the </span><strong class="bold"><span class="koboSpan" id="kobo.814.1">Interfaces</span></strong><span class="koboSpan" id="kobo.815.1"> rollout in the </span><strong class="bold"><span class="koboSpan" id="kobo.816.1">My Blueprint</span></strong><span class="koboSpan" id="kobo.817.1"> tab. </span><span class="koboSpan" id="kobo.817.2">Double-click it; this will create an </span><strong class="bold"><span class="koboSpan" id="kobo.818.1">Event Fire</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.819.1">interface event:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.820.1"><img alt="Figure 2.31 – The Event Fire interface event, denoted by the interface icon over the top-right corner" src="image/Figure_02.31_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.821.1">Figure 2.31 – The Event Fire interface event, denoted by the interface icon over the top-right corner</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.822.1">Drag</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.823.1"> out from the </span><strong class="bold"><span class="koboSpan" id="kobo.824.1">Event Fire</span></strong><span class="koboSpan" id="kobo.825.1"> node and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">Print String</span></strong><span class="koboSpan" id="kobo.827.1"> node, then replace </span><strong class="bold"><span class="koboSpan" id="kobo.828.1">Hello</span></strong><span class="koboSpan" id="kobo.829.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">Pistol – </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">Interface Fire</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.833.1">Repeat </span><em class="italic"><span class="koboSpan" id="kobo.834.1">steps 3 to 5</span></em><span class="koboSpan" id="kobo.835.1"> on both the </span><strong class="bold"><span class="koboSpan" id="kobo.836.1">Wpn_Rifle</span></strong><span class="koboSpan" id="kobo.837.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.838.1">Wpn_Shotgun</span></strong><span class="koboSpan" id="kobo.839.1"> assets, changing the </span><strong class="bold"><span class="koboSpan" id="kobo.840.1">Print String</span></strong><span class="koboSpan" id="kobo.841.1"> node to include the name of </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">each weapon.</span></span></li>
<li><span class="koboSpan" id="kobo.843.1">Duplicate the </span><strong class="bold"><span class="koboSpan" id="kobo.844.1">CH_Example_Bad</span></strong><span class="koboSpan" id="kobo.845.1"> asset and rename </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">it </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.847.1">CH_Example_Better</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.849.1">Open </span><strong class="bold"><span class="koboSpan" id="kobo.850.1">CH_Example_Better</span></strong><span class="koboSpan" id="kobo.851.1"> and delete all of the nodes from the </span><strong class="bold"><span class="koboSpan" id="kobo.852.1">InputAction PrimaryAction</span></strong><span class="koboSpan" id="kobo.853.1"> logic flow, except for the </span><strong class="bold"><span class="koboSpan" id="kobo.854.1">Carried Weapon</span></strong><span class="koboSpan" id="kobo.855.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.856.1">Target Child </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.857.1">Actor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.858.1"> nodes.</span></span></li>
<li><span class="koboSpan" id="kobo.859.1">Drag from the </span><strong class="bold"><span class="koboSpan" id="kobo.860.1">Child Actor</span></strong><span class="koboSpan" id="kobo.861.1"> node and search for </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">Fire (Message)</span></strong><span class="koboSpan" id="kobo.863.1">; this will create a </span><strong class="bold"><span class="koboSpan" id="kobo.864.1">Fire</span></strong><span class="koboSpan" id="kobo.865.1"> interface event call, which will be called on whichever class is currently set as the </span><strong class="bold"><span class="koboSpan" id="kobo.866.1">Carried </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.867.1">Weapon</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.868.1"> class:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.869.1"><img alt="Figure 2.32 – The resulting InputAction PrimaryAction Blueprint logic with the interface call" src="image/Figure_02.32_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.870.1">Figure 2.32 – The resulting InputAction PrimaryAction Blueprint logic with the interface call</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.871.1">In order to </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.872.1">test this approach, we need to swap the </span><strong class="bold"><span class="koboSpan" id="kobo.873.1">Default Pawn Class</span></strong><span class="koboSpan" id="kobo.874.1"> in our game mode (the class that governs default game elements such as pawn and player controller, as well as handling game-level variables and events) for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">TestLevel</span></strong><span class="koboSpan" id="kobo.876.1"> map to the better example we’ve </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">just created.</span></span></p>
<ol>
<li value="10"><span class="koboSpan" id="kobo.878.1">Open </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">GM_Test</span></strong><span class="koboSpan" id="kobo.880.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">TestFiles</span></strong><span class="koboSpan" id="kobo.882.1"> directory in the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.883.1">Content Browser</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.885.1">Change the </span><strong class="bold"><span class="koboSpan" id="kobo.886.1">Default Pawn Class</span></strong><span class="koboSpan" id="kobo.887.1"> dropdown </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.889.1">CH_Example_Better</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.891.1">Now, when you play the level and click the left mouse button, you will see the new </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">interface prints.</span></span></p>
<p><span class="koboSpan" id="kobo.893.1">The outcome we have achieved is essentially the same as before; however, the code used to achieve it is tidier, faster, uses less memory, and is infinitely expandable by avoiding casts and using </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">the interface.</span></span></p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.895.1">The trade-off</span></h1>
<p><span class="koboSpan" id="kobo.896.1">With any</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.897.1"> implementation of a pattern or fix, there is a trade-off between what you gain and what it costs, and it’s important to consider the long-term effects when </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">implementing patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.899.1">In many of the cases we are exploring, the gain is simplicity, readability, or a reduction in memory footprint, which should help your game to run smoothly. </span><span class="koboSpan" id="kobo.899.2">These are all key elements worth maintaining a good code base for. </span><span class="koboSpan" id="kobo.899.3">The cost is often time. </span><span class="koboSpan" id="kobo.899.4">Some patterns may take longer to implement, and, in some cases, having to refactor code to work in a specific way can use up </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">valuable time.</span></span></p>
<p><span class="koboSpan" id="kobo.901.1">The long-term effects, however, outweigh the initial time cost as the time saved later in development to build on top of or into existing systems will prove beneficial later in your game’s </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">development cycle.</span></span></p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.903.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.904.1">In this chapter, we discussed the S.O.L.I.D. </span><span class="koboSpan" id="kobo.904.2">principles that underpin good code, exploring specific examples and how, as they expand in complexity, we need to consider these principles to keep the code functioning. </span><span class="koboSpan" id="kobo.904.3">These principles are widely recognized across the game development industry, and so understanding them will not only help improve code efficiency and readability but also allow smooth communication with co-developers on </span><span class="No-Break"><span class="koboSpan" id="kobo.905.1">larger projects.</span></span></p>
<p><span class="koboSpan" id="kobo.906.1">We also explored a series of common problems that new Unreal Engine users encounter and the solutions to them, looking specifically at a series of common tasks such as moving items and managing a selection of weapons on a character. </span><span class="koboSpan" id="kobo.906.2">The solutions, while specific, offer insights into how easily a developer can find themselves with large, lumbering Blueprints that can be solved by utilizing built-in systems </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">and tools.</span></span></p>
<p><span class="koboSpan" id="kobo.908.1">In the next chapter we will be taking these principles of clean code and seeing how Epic Games have applied them through the engine when we look at some of the patterns they have built for us. </span><span class="koboSpan" id="kobo.908.2">The utility of the engine as it were. </span><span class="koboSpan" id="kobo.908.3">These patterns will include double buffer, flyweight and </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">spatial partitioning.</span></span></p>
</div>
</body></html>