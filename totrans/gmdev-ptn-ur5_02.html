<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-31"><a id="_idTextAnchor031"/>2</h1>
<h1 id="_idParaDest-32"><a id="_idTextAnchor032"/>“Hello Patterns”</h1>
<p>This chapter will focus on the principles that underpin all good code. Design patterns are an extension <a id="_idIndexMarker036"/>of these principles, so it is important to walk before you run. Once the basics have been covered, we’ll look at some bad Blueprint code so that we can understand the process of fixing it, which we will do by following some step-by-step guides.</p>
<p>In this chapter, we’ll be covering the following topics:</p>
<ul>
<li>S.O.L.I.D. principles</li>
<li>Exploring solutions to common problems</li>
<li>The trade-off</li>
</ul>
<h1 id="_idParaDest-33"><a id="_idTextAnchor033"/>Technical requirements</h1>
<p>For this chapter, you will need a blank UE5 project open and ready. There's no need for C++ right now; we’ll be focusing on Blueprint code for simplicity.</p>
<p>The files for this project can be found in the <code>chapter2</code> branch on GitHub at <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter02">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter02</a></p>
<p>If you’ve not created a blank UE5 project before, the following steps will take you through creating a simple Blueprint project, which is all we need for this chapter:</p>
<ol>
<li>Click the <strong class="bold">Launch</strong> button in the top right of the <strong class="bold">Epic Launcher</strong> | <strong class="bold">Unreal Engine</strong> | <strong class="bold">Library</strong> tab, where we installed the engine in the first chapter.</li>
<li>Select <strong class="bold">Games</strong> on the left side of the <strong class="bold">Unreal </strong><strong class="bold">Project Browser</strong>.</li>
<li>Select <strong class="bold">Blank</strong> from the main section, and toggle <strong class="bold">Starter Content</strong> off. This will prevent Unreal from adding a bunch of unrequired assets to the project.</li>
<li>Choose a sensible location (the default is fine) and set the project name as <code>HelloPatterns</code>:</li>
</ol>
<div><div><img alt="Figure 2.1 – The Unreal Project Browser with a new, blank games project set up for creation" src="img/Figure_02.01_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – The Unreal Project Browser with a new, blank games project set up for creation</p>
<ol>
<li value="5">Click <strong class="bold">Create</strong>.</li>
</ol>
<p>Now you have your project set up, you are ready for the interactive part of this chapter, but first, let’s discuss what we mean when we say <em class="italic">good code</em>.</p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor034"/>S.O.L.I.D. principles</h1>
<p>To <a id="_idIndexMarker037"/>understand why design patterns work, we need to understand the principles that underpin good code. Let’s run a whistle-stop tour through most people’s first experience with code.</p>
<p>The universal <em class="italic">Hello World</em> program and the beginner exercises that follow are all made up of linear code. Linear code executes each line sequentially through a single file in which the whole program is written. Loops, selections, and statements make up literally everything.</p>
<p>As each program gets larger, the code becomes unsustainable. The solution is object orientation. <strong class="bold">Object-oriented programming</strong> (<strong class="bold">OOP</strong>) adds a lot, primarily classes and objects, as <a id="_idIndexMarker038"/>the name would suggest. With OOP’s added complexity, it becomes quite easy to accidentally build in fundamental issues with systems that make it impossible to expand them. Having a set of rules to follow greatly simplifies the process of building code that works for you and the next person to maintain it. These rules take the <a id="_idIndexMarker039"/>form of the <strong class="bold">S.O.L.I.D.</strong> principles, which are defined here:</p>
<ul>
<li>S – <strong class="bold">Single responsibility</strong></li>
<li>O – <strong class="bold">Open-closed</strong></li>
<li>L – <strong class="bold">Liskov substitution</strong></li>
<li>I – <strong class="bold">Interface segregation</strong></li>
<li>D – <strong class="bold">Dependency inversion</strong></li>
</ul>
<h2 id="_idParaDest-35"><a id="_idTextAnchor035"/>Single responsibility</h2>
<p>In <em class="italic">Agile Software Development: Principles, Patterns, and Practices</em>, Robert C. Martin said the following:</p>
<p class="author-quote">A class should have one and only one reason to change, meaning that a class should have only one job.</p>
<p>Each<a id="_idIndexMarker040"/> class should <em class="italic">do what it says on the tin</em>—or, in<a id="_idIndexMarker041"/> this case, the class name. If you were hiring a plumber, you wouldn’t expect that plumber to also recite <em class="italic">Hamlet</em> while fixing the pipes. The same is true for code; if you have a math library class, you expect it to take numbers in and return the results after performing some equations. What you don’t expect is for it to use these numbers as a seed to generate an image, which it sets as your desktop background. Granted, this is an extreme case that may even be considered a virus, but the point stands.</p>
<p>Writing a class that does what is expected by its name helps when working in a team. Games can become quite large with many interconnected systems, and if a developer can understand what a class is responsible for and how to operate it, from just function and class names, then time is saved. Implementation can be as simple as consistent naming conventions combined with compartmentalized functionality. For instance, a function called <code>AddItem(ItemType type, int amount)</code> on an inventory component in the object used for our player probably adds an amount of an item to the inventory of the player. You don’t need to open the function to see what it does due to this clear naming.</p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor036"/>Open-closed</h2>
<p>In <em class="italic">Agile Software Development: Principles, patterns, and practices</em>, Robert C. Martin said:</p>
<p class="author-quote">Objects or entities should be open for extension but closed for modification.</p>
<p>New <a id="_idIndexMarker042"/>functionality<a id="_idIndexMarker043"/> should be easy to create, without needing to modify the existing code. It is easy to see this in action through something like a save system. If you want to port your game to multiple platforms, then it would make sense to have a different <code>save</code> method for each. To start with, there are two target platforms (PC and Xbox); the save system might look like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Example SaveClass.cpp</p>
<pre class="source-code">
void SaveClass::SaveGame(GameProgress* gameProgress)
{
    if(target == "PC")
    {
        //save game progress the PC way
    }
    else if (target == "XBOX")
    {
        //save game progress the Xbox way
    }
}</pre> <p>Somewhere down the line, you decide to extend the system to also work on PlayStation. This is another platform to handle. The modification seems easy—just add a new case to the ever-expanding statement. Therein lies the problem; the more platforms we support, the<a id="_idIndexMarker044"/> longer this will get, and the more time and memory the function will occupy:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Example SaveClass.cpp</p>
<pre class="source-code">
void SaveClass::SaveGame(GameProgress* gameProgress)
{
    if (target == "PC")
    {
        // save game progress the PC way
    }
    else if (target == "XBOX")
    {
        // save game progress the Xbox way
    }
    else if (target == "another platform")
    {
        // save game progress on another platform
    }
    else if (target == "yet another platform")
    {
        // save game progress on yet another platform
    }
}</pre> <p>The solution<a id="_idIndexMarker045"/> is to spin the <code>save</code> function into an abstract function with an overriding child class function for each platform shown in <em class="italic">Figure 2</em><em class="italic">.2</em>. This not only means new platforms can be added with a new child class but also, we don’t have to instantiate versions of the save system we will never use, saving memory:</p>
<div><div><img alt="Figure 2.2 – UML diagram showing inheritance of a ﻿SaveClass﻿ instance with the open-closed principle applied" src="img/Figure_02.02_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – UML diagram showing inheritance of a SaveClass instance with the open-closed principle applied</p>
<p>Next, we will look at Liskov substitution.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/>Liskov substitution</h2>
<p>In <em class="italic">Agile Software Development: Principles, Patterns, and Practices</em>, Robert C. Martin said the following:</p>
<p class="author-quote">Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T.</p>
<p>Essentially, if <a id="_idIndexMarker046"/>there is a child class in use within your<a id="_idIndexMarker047"/> code, you should be able to swap it out for any of its siblings without modifying the structure of the calling code or using variables for unintended purposes. In the previous example, we turned a save system into a parent-child structure. If we were to add cloud saving, we would no longer have a file path to send data to and instead, we would use an IP address. Well, we could make this work by just piping the IP address through the file path argument as shown in the following exerpt but this is a violation of our naming convention. Undoubtedly, someone down the line will need to use this function and won’t understand what they need to do. Plus, any data not in the requested type will have to be converted by the calling object, sent, and then parsed inside the child implementation, which wastes time:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Excerpt from a program calling a save system</p>
<pre class="source-code">
SaveClass* _XboxSaver = new SaveClass_Xbox();
SaveClass* _CloudSaver = new SaveClass_Cloud();
SaveData* _DataToSave;
//Some code to prepare save data
_XboxSaver-&gt;SaveSomeData(_DataToSave, "filepath");
_CloudSaver-&gt;SaveSomeData(_DataToSave, "127.0.0.1");</pre> <p>The fix for<a id="_idIndexMarker048"/> this principle is to make the variable that may <a id="_idIndexMarker049"/>change a member of the child class. That way, initialization functions can deal with making sure the correct data is asked for, and we can easily swap out <code>save</code> objects as needed. This also means the abstract functionality from the parent can be called the same way wherever it is used, making for easier maintenance as systems grow:</p>
<div><div><img alt="Figure 2.3 – UML diagram showing inheritance of﻿ SaveClass﻿ with Liskov substitution principle applied" src="img/Figure_02.03_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – UML diagram showing inheritance of SaveClass with Liskov substitution principle applied</p>
<p>So, if we apply the Liskov substitution to our code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Excerpt from a program calling the better save system</p>
<pre class="source-code">
SaveClass* _XboxSaver = new SaveClass_Xbox("filePath");
SaveClass* _CloudSaver = new SaveClass_Cloud(new IP());
SaveData* _DataToSave;
//Some code to prepare save data
_XboxSaver-&gt;SaveSomeData(_DataToSave);
_CloudSaver-&gt;SaveSomeData(_DataToSave);</pre> <p>As you<a id="_idIndexMarker050"/> can see, the<a id="_idIndexMarker051"/> calls become the same format and are therefore substitutable and satisfy the principle.</p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor038"/>Interface segregation</h2>
<p>In <em class="italic">Agile Software Development: Principles, Patterns, and Practices</em>, Robert C. Martin said the following:</p>
<p class="author-quote">A client should never be forced to implement an interface that it doesn’t use, or clients shouldn’t be forced to depend on methods they do not use.</p>
<p>If the <a id="_idIndexMarker052"/>parent defines an abstract function, the <a id="_idIndexMarker053"/>child must override it. This causes issues when implementing an abstract function for some of the child classes as the other children that don’t need that functionality must override to immediately nullify it. The solution can either be to extend the inheritance so that there is another layer for the classes in need of this extra functionality or to create an interface (only available in multi-inheritance languages) that adds the functionality to certain subclasses.</p>
<p>Going back to the save system, if you need to get account authorization before saving on Xbox and PlayStation, then this can be done via inheritance. A new sub-class of <code>Save</code> can be made, which declares an abstract function for getting authorization. This then becomes the parent for each save system that needs the function:</p>
<div><div><img alt="Figure 2.4 – UML diagram showing ﻿SaveClass﻿ inheritance with interface segregation applied through pure inheritance" src="img/Figure_02.04_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – UML diagram showing SaveClass inheritance with interface segregation applied through pure inheritance</p>
<p>So, if we apply the concept of interface segregation to our code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Excerpt from a program that checks authentication before saving</p>
<pre class="source-code">
SaveClass2FA* _PSNSaver = new SaveClass_PSN("filePath");
SaveData* _DataToSave;
// Some code to prepare save data
if (_PSNSaver-&gt;Authenticate())
{
    _PSNSaver-&gt;SaveSomeData(_DataToSave);
}</pre> <p class="callout-heading">Important note</p>
<p class="callout">Technically, the structure shown in <em class="italic">Figure 2</em><em class="italic">.4</em> will violate the previous Liskov substitution principle as sub-classes that don’t inherit from the middle <em class="italic">interface</em> layer can’t be substituted into the pattern. Deciding which principle is more important is part of the skill of designing code and is usually learned with practice.</p>
<p>Although <a id="_idIndexMarker054"/>this inheritance structure does satisfy the <strong class="bold">interface segregation</strong> principle, it does end up getting quite messy with lots of <a id="_idIndexMarker055"/>segregated behaviors. There is another way. Applying the first principle of single responsibility to this tree, we remove each segregated behavior into its own class. Objects of this can then be created and injected into the save system where needed. The result is more independent classes, but cleaner, smaller inheritance structures. This is what is known as using <strong class="bold">class composition</strong> to solve a <a id="_idIndexMarker056"/>structure problem:</p>
<div><div><img alt="Figure 2.5 – UML diagram showing ﻿SaveClass﻿ alongside ﻿Auth﻿ hierarchy" src="img/Figure_02.05_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – UML diagram showing SaveClass alongside Auth hierarchy</p>
<p>So, if we apply class composition to our code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Excerpt of a program that implements Figure 2.5</p>
<pre class="source-code">
Auth* _Authorizer = new Auth();
SaveClass* _XboxSaver = new SaveClass_Xbox("filePath");
SaveData* _DataToSave;
//Some code to prepare save data
_Authorizer-&gt;Authorize();
_XboxSaver-&gt;SaveSomeData(_DataToSave, _Authorizer);</pre> <p>The <code>SaveSomeData</code> function<a id="_idIndexMarker057"/> would then check the<a id="_idIndexMarker058"/> authorized status of the <code>Auth</code> type object as it needs to.</p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/>Dependency inversion</h2>
<p>In <em class="italic">Agile Software Development: Principles, Patterns, and Practices</em>, Robert C. Martin said the following:</p>
<p class="author-quote">Entities must depend on abstractions, not on concretions. It states that the high-level module must not depend on the low-level modules, but they should depend on abstractions.</p>
<p>This<a id="_idIndexMarker059"/> pattern is the most useful for UE5. Simply put, if <a id="_idIndexMarker060"/>you inject a reference to a class somewhere, it really should be the highest-level abstract parent that still has the functionality you need. Easy examples would be in a PlayerController, where you don’t reference a specific pawn sub-class but, instead, the idea of a pawn. Better than that, you could reference the interface for the functionality you need; this will prevent long cast chains to filter for the type.</p>
<p>In the save example, the injection of the account authorizer is a concretion that assumes every <code>save</code> module will authorize in the same way. In reality, it would be much more appropriate to inject an <code>Authorizer</code> parent that only contains the authorized status. When creating an object to inject, we then create it as the correct sub-class and call its <code>Authorize</code> function, which is free to then operate as it needs to. You can even reuse this structure for authorization of other things elsewhere too:</p>
<div><div><img alt="Figure 2.6 – UML diagram showing ﻿SaveClass﻿ alongside ﻿Auth﻿ hierarchy" src="img/Figure_02.06_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – UML diagram showing SaveClass alongside Auth hierarchy</p>
<p>So, if we apply dependency inversion to our code, it would look like:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Excerpt of a program that implements Figure 2.6</p>
<pre class="source-code">
Auth* _Authorizer = new Auth_Xbox();
SaveClass* _XboxSaver = new SaveClass_Xbox("filePath");
SaveData* _DataToSave;
//Some code to prepare save data
_Authorizer-&gt;Authorize();
_XboxSaver-&gt;SaveSomeData(_DataToSave, _Authorizer);</pre> <p>That’s a <a id="_idIndexMarker061"/>lot of theory to have gone through, but<a id="_idIndexMarker062"/> with it, we can make tangible improvements to dire systems. These improvements should shore up the foundations of our code, setting it up to receive the more structure-heavy patterns we will be using later in this book.</p>
<p>The next section will guide you through an average beginner developer’s process of creating a project and getting something working quickly so that you can then apply what you have learned to see a tangible improvement.</p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor040"/>Exploring solutions to common problems</h1>
<p>We are going to explore a series of examples of Blueprint scripts where the intended result has been achieved but causes issues simply due to the approach taken. We will then offer an improved approach, which makes the Blueprint more performant, tidier, more reusable, or easier to expand at a later point in development. The purpose of this section is to help you begin to recognize potential areas for improvement within your own code, regardless of whether you are working in Blueprint or C++.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Everything we are about to look at in this section is bad code to prove a point. Even the fixes that follow are not perfect, but it has been written for the purpose of education and so is simplified somewhat.</p>
<p>For this section, you will need an empty project that you may have already created at the beginning of the chapter and the <code>content</code> folder from the <code>chapter2</code> branch of the GitHub link provided at the start of the chapter.</p>
<p>If you’ve not used GitHub before, click the <code>.zip</code> folder that you can then extract into your new project folder.</p>
<p>Place the <code>HelloPatterns</code> folder from <code>.zip</code> file directly into your content directory; this will provide you with some examples of bad practises that we will first review before explaining how to fix them.</p>
<p>To fix the problems, first, duplicate each of the Blueprint assets and change the suffix from <code>_Bad</code> to <code>_Better</code>. This will ensure you can look back and see the differences between where we start and where we finish when reworking these Blueprints.</p>
<p>To start fixing these Blueprints, you will need to open them by double-clicking on them in the <strong class="bold">Content Browser</strong>. Once open, navigate to the <strong class="bold">Event Graph</strong> tab where you will find the examples we’ve covered. Follow the steps under each of the <strong class="bold">Solution</strong> headings to improve the Blueprints.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/>The moving box problem</h2>
<p>The<a id="_idIndexMarker063"/> first example we’re going to look at is a simple moving box (a static mesh component) that slides from a start location (relative <code>0</code>,<code>0</code>,<code>50</code>) to an end location (relative <code>200</code>,<code>0</code>,<code>50)</code>. Both locations have been stored as vector variables within the Blueprint and their defaults set, as mentioned.</p>
<p class="callout-heading">Note</p>
<p class="callout">Here, we are using relative location, a vector variable that defines the location of an entity based on the location of its parent. A relative location of (0,0,50) on a component whose parent actor is positioned at (0,0,0) in the world would also be (0,0,50) in the world. However, if the parent actor were to move to (10,10,0), the component’s world location would be (10,10,50) as the world and relative locations are combined to provide a world location for the component.</p>
<p>The Blueprint code to move the box has two logic chains selected via a branch node (Blueprint’s version of an <code>if</code> statement) using <code>Update</code> loop). One logic chain is used to move the box forward, from start to end, and the other is used to move it back. The decision of which to use is controlled by the <strong class="bold">Forward</strong> Boolean variable:</p>
<div><div><img alt="Figure 2.7 – The Event Tick Branch for selecting which direction to move" src="img/Figure_02.07_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – The Event Tick Branch for selecting which direction to move</p>
<p>The <em class="italic">move forward</em> logic chain adds 1 cm to the <em class="italic">x</em> coordinate of the box’s relative location and updates the position of the box, relative to the actor using a <strong class="bold">Set Relative </strong><strong class="bold">Location</strong> node.</p>
<p>A check then<a id="_idIndexMarker064"/> takes place, comparing the current relative location to the end point with a 0.0 error tolerance. If the locations are equal, then <strong class="bold">Forward</strong> is set to <strong class="bold">False</strong>, which means on the next tick, the branch will select the reverse logic change:</p>
<div><div><img alt="Figure 2.8 – The move forward logic chain for the moving box" src="img/Figure_02.08_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – The move forward logic chain for the moving box</p>
<p>The <em class="italic">move backward</em> logic chain subtracts 1 cm from the <em class="italic">x</em> coordinate of the box’s relative location and updates the position in the same way. The difference here is that the check compares the relative location to the end point and, when they are equal, sets <strong class="bold">Forward</strong> to <strong class="bold">True</strong>, flicking the branch to the <em class="italic">move forward</em> logic on the next tick. This repeats indefinitely or until the actor is destroyed:</p>
<div><div><img alt="Figure 2.9 – The move backward logic chain for moving the box" src="img/Figure_02.09_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – The move backward logic chain for moving the box</p>
<p>The issue we <a id="_idIndexMarker065"/>have here is we are checking on every tick if the box has arrived at its destination. Doing the comparison on one box may not cause many issues, but if you are moving a lot of items in a scene, this sort of innocent calculation is a waste of resources, something we are keen to avoid.</p>
<h3>Solution to the moving box problem</h3>
<p>Let’s take a<a id="_idIndexMarker066"/> look at building a better approach using a timeline:</p>
<ol>
<li>Begin by deleting all of the nodes in the <strong class="bold">Event Graph</strong>, except for the <strong class="bold">Set Relative Location</strong> and <strong class="bold">Static Mesh </strong><strong class="bold">Box</strong> nodes.</li>
<li>Start by adding a custom event node by right-clicking on the graph, typing <code>custom event</code>, and pressing <em class="italic">Enter</em>. You can select the <strong class="bold">Add Custom Event…</strong> option at any point; typing more of the name will simply help reduce the options available, hopefully speeding things up:</li>
</ol>
<div><div><img alt=" Figure 2.10 – Node creation in the Event Graph with custom event filtered" src="img/Figure_02.10_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 2.10 – Node creation in the Event Graph with custom event filtered</p>
<ol>
<li value="3">Call the<a id="_idIndexMarker067"/> custom event <code>PingPongMovement</code>—this is intended at this point to be quite literal as that’s what we are coding:</li>
</ol>
<div><div><img alt=" Figure 2.11 – A custom event node for ﻿PingPongMovement﻿" src="img/Figure_02.11_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 2.11 – A custom event node for PingPongMovement</p>
<ol>
<li value="4">Drag out of the <code>add timeline</code>, select <code>T_MoveBox</code> when prompted. This will give you a timeline node, a special type of node that contains one or more graphs that can be used to provide values for other nodes that are called during the timeline node’s <strong class="bold">Update</strong> chain:</li>
</ol>
<div><div><img alt="Figure 2.12 – A timeline node, named T_MoveBox" src="img/Figure_02.12_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – A timeline node, named T_MoveBox</p>
<ol>
<li value="5">Double-click the <strong class="bold">T_MoveBox</strong> node; this will open a new tab to allow us to create <a id="_idIndexMarker068"/>and edit the graphs in this timeline. Note that the length of the timeline, shown at the top of the tab, is 5.0 seconds. This means the timeline will execute its update chain for a duration of 5.0 seconds from when it is first called:</li>
</ol>
<div><div><img alt=" Figure 2.13 – An empty timeline tab with default settings" src="img/Figure_02.13_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 2.13 – An empty timeline tab with default settings</p>
<ol>
<li value="6">Click the <strong class="bold">+Track</strong> button and choose <strong class="bold">Add </strong><strong class="bold">Float Track</strong>.</li>
<li>Name<a id="_idIndexMarker069"/> the track <code>MovementAlpha</code>. This will add a float track graph and float value output to the timeline node:</li>
</ol>
<div><div><img alt="Figure 2.14 – A float track added to the timeline" src="img/Figure_02.14_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – A float track added to the timeline</p>
<ol>
<li value="8">Right-click on the float graph and select <strong class="bold">Add Key to CurveFloat_0</strong>; repeat this to create a second key.</li>
<li>Select the first key and, using the <code>0.0</code> into both variables.</li>
<li>Select the second key and set <code>5.0</code> and <code>1.0</code>:</li>
</ol>
<div><div><img alt="Figure 2.15 – The MovementAlpha track with linear graph" src="img/Figure_02.15_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – The MovementAlpha track with linear graph</p>
<ol>
<li value="11">Return to the <code>MovementAlpha</code> curve based on the<a id="_idIndexMarker070"/> current time of the timeline:</li>
</ol>
<div><div><img alt="Figure 2.16 – The timeline node, now with the Movement Alpha float pin" src="img/Figure_02.16_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16 – The timeline node, now with the Movement Alpha float pin</p>
<ol>
<li value="12">Position and connect the <strong class="bold">Set Relative Location</strong> and <strong class="bold">Static Mesh Box</strong> nodes from the old solution to the <strong class="bold">Update</strong> output pin from the timeline.</li>
<li>Drag from the <code>lerp</code> to create a <strong class="bold">Lerp (Vector)</strong> node. This setup allows us to interpolate between two vectors, to control where our box moves, relative to the object’s location.</li>
<li>Drag and drop the <strong class="bold">Start Point</strong> variable from the left side of the <strong class="bold">Blueprint Editor</strong> window onto the <strong class="bold">A</strong> pin of the <strong class="bold">Lerp (Vector)</strong> node. The <strong class="bold">A</strong> pin is the start value for the lerp.</li>
<li>Drag and drop the <strong class="bold">End Point</strong> variable onto the <strong class="bold">B</strong> pin of the <strong class="bold">Lerp (Vector)</strong> node. The <strong class="bold">B</strong> pin is the end value for the lerp.</li>
<li>Connect<a id="_idIndexMarker071"/> the <strong class="bold">Alpha</strong> pin of the <strong class="bold">Lerp (Vector)</strong> node to the <strong class="bold">Movement Alpha</strong> pin of the timeline node:</li>
</ol>
<div><div><img alt="Figure 2.17 – The update logic of the timeline completed" src="img/Figure_02.17_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17 – The update logic of the timeline completed</p>
<p class="list-inset">Now the update logic is complete, we need to set our Blueprint up to start the timeline. To do this, proceed as follows:</p>
<ol>
<li value="17">Right-click on the <code>Event BeginPlay</code> node. This is a built-in event that is called when an actor is created (either at the beginning of the game or when spawned by another function).</li>
<li>Drag out of the <code>Ping Pong Movement</code>; you should now see a <strong class="bold">Ping Pong Movement</strong> option under the <strong class="bold">Call Function</strong> rollout—select it. This will create a call to our custom event:</li>
</ol>
<div><div><img alt="Figure 2.18 – Ping Pong Movement being called from the Event BeginPlay event" src="img/Figure_02.18_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18 – Ping Pong Movement being called from the Event BeginPlay event</p>
<p class="list-inset">This will <a id="_idIndexMarker072"/>now move the box from the start location to the end location in relative space; give it a test by placing the <code>BP_MovingBox_Better</code> Blueprint from the <strong class="bold">Content Browser</strong> into the world and clicking the <em class="italic">Play</em> button above the viewport:</p>
<div><div><img alt="Figure 2.19 – Play in Editor controls from the main Unreal Engine Editor user interface" src="img/Figure_02.19_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.19 – Play in Editor controls from the main Unreal Engine Editor user interface</p>
<p>Next, we want to set the Blueprint up so that the box moves back to the start location once it has reached the end location and loops indefinitely. To do this, proceed as follows:</p>
<ol>
<li>Detach the <strong class="bold">Ping Pong Movement</strong> custom event node from the timeline node by holding <em class="italic">Alt</em> on the keyboard and clicking either end of the connection.</li>
<li>Drag from the <code>Flip Flop</code> node. This node swaps between exec pins <strong class="bold">A</strong> and <strong class="bold">B</strong> each time it is entered. The node always starts with <strong class="bold">A</strong> for its first run. The <strong class="bold">bool</strong> pin can be used to inform other logic, but we won’t need that for this solution.</li>
<li>Connect the <strong class="bold">A</strong> pin of the <strong class="bold">Flip Flop</strong> node to the <strong class="bold">Play from Start</strong> pin of the <strong class="bold">T_MoveBox</strong> timeline node.</li>
<li>Connect the <strong class="bold">B</strong> pin of the <strong class="bold">Flip Flop</strong> node to the <strong class="bold">Reverse from End</strong> pin of the <strong class="bold">T_MoveBox</strong> timeline node:</li>
</ol>
<div><div><img alt="Figure 2.20 – Flip Flop node and timeline" src="img/Figure_02.20_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.20 – Flip Flop node and timeline</p>
<ol>
<li value="5">Lastly, connect the <strong class="bold">Finished</strong> pin of the timeline node to a <strong class="bold">Ping Pong Movement</strong> function call node (either the existing one or a new one), which will restart the<a id="_idIndexMarker073"/> process every time it finishes:</li>
</ol>
<div><div><img alt="Figure 2.21 – The improved Blueprint for the moving box, laid out for readability in the editor" src="img/Figure_02.21_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.21 – The improved Blueprint for the moving box, laid out for readability in the editor</p>
<p class="list-inset">Now, try pressing the <em class="italic">Play</em> button in the editor (the <em class="italic">Play</em> button above the viewport) again. You should now see that the box moves in one direction and then the other, over and over.</p>
<p>This approach offers a more performant solution due to not requiring the comparison. The update logic is still constantly running, in the same way as the tick approach was for the <strong class="bold">Set Relative Location</strong> node, but because the timeline controls when the direction change occurs, we no longer need to do any comparisons of vector locations after every move.</p>
<p>The timeline can also afford us more control over situations when we want to move things. The current setup features linear movement controlled by the linear curve. Changing the key types<a id="_idIndexMarker074"/> to automatic (right-click the key) or adding additional keys can provide more interesting movements and allow you to incorporate considerations such as the principles of animation into your moving objects, something that is very difficult to do without using a curve.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor042"/>The rotating box problem</h2>
<p>The<a id="_idIndexMarker075"/> second example we’re going to look at is a simple rotating box. The Blueprint actor contains the same static mesh component, but this time it’s set up to spin in place 2 degrees of rotation on each tick:</p>
<div><div><img alt="Figure 2.22 – The rotating box Blueprint code" src="img/Figure_02.22_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.22 – The rotating box Blueprint code</p>
<p>The Blueprint code also does a check for when the rotation of the box gets to 360 degrees or above and minuses 360 from the rotation value, to ensure that we keep the rotation value from spiraling out of control as the game plays:</p>
<div><div><img alt="Figure 2.23 – The check to maintain rotations between 0 and 360 degrees" src="img/Figure_02.23_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.23 – The check to maintain rotations between 0 and 360 degrees</p>
<p>The check that’s been put in place is relatively sensible, and if it were part of a single rotation or <a id="_idIndexMarker076"/>working with a character rotation within an animation Blueprint, then it would be ideal.</p>
<p>The problem with this implementation is that we are once again working on tick and doing checks that will become more cumbersome with every additional rotating box.</p>
<h3>Solution to the rotating box problem</h3>
<p>For the <a id="_idIndexMarker077"/>rotating box, the solution is to use a pre-existing solution. Instead of coding differently, we can use a component that is provided as part of UE5 to achieve the desired result. Follow the next steps:</p>
<ol>
<li>Firstly, delete all of the logic from the <strong class="bold">Event Graph</strong>, it is not required.</li>
<li>In the <strong class="bold">Components</strong> tab, click the <strong class="bold">Add</strong> button and search for a <strong class="bold">Rotating </strong><strong class="bold">Movement</strong> component:</li>
</ol>
<div><div><img alt="Figure 2.24 – Rotating Movement component selected in the Add components list" src="img/Figure_02.24_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.24 – Rotating Movement component selected in the Add components list</p>
<ol>
<li value="3">Create a new variable by clicking the <strong class="bold">+</strong> in the <strong class="bold">Variables</strong> rollout of the <strong class="bold">My </strong><strong class="bold">Blueprint</strong> tab.</li>
<li>Name the variable <code>Rotation Rate</code> and set the type to <code>Rotator</code> by clicking on the current type (typically <strong class="bold">Boolean</strong> if you are working with a new Blueprint) and selecting <strong class="bold">Rotator</strong> from the list.</li>
<li>Make the variable <strong class="bold">Instance Editable</strong> by clicking the <em class="italic">eye</em> icon to the right of the variable type—this will allow the user to set the rotation rate of each box in the scene.</li>
<li>Compile the Blueprint and set the default value of the <code>0,0,180</code>:</li>
</ol>
<div><div><img alt="Figure 2.25 – Resulting variables list in the My Blueprint tab" src="img/Figure_02.25_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.25 – Resulting variables list in the My Blueprint tab</p>
<ol>
<li value="7">In the <code>Set Rotation Rate</code> node. Connect the <strong class="bold">Rotation Rate</strong> variable you just created to the <strong class="bold">Rotation </strong><strong class="bold">Rate</strong> pin:</li>
</ol>
<div><div><img alt="Figure 2.26 – Construction script logic, setting the Rotating Movement component’s Rotation Rate using the created variable" src="img/Figure_02.26_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.26 – Construction script logic, setting the Rotating Movement component’s Rotation Rate using the created variable</p>
<p>Now, when placing <code>BP_RotatingBox_Better</code> into the world, you will be able to set the <strong class="bold">Rotation Rate</strong> value in the <strong class="bold">Defaults</strong> section of the <strong class="bold">Detail</strong> panel. Try placing multiple boxes and setting different values. When you press the <em class="italic">Play</em> button in <strong class="bold">Editor</strong>, you should see the boxes rotating as desired.</p>
<p>This solution offers a more performant approach again due to its lack of reliance on <strong class="bold">Event Tick</strong> as well as the removal of the comparison checking when the rotation exceeds 360 degrees in order to maintain values inside the 0-360 range.</p>
<p>Another benefit <a id="_idIndexMarker079"/>of this approach is that we now have an <strong class="bold">Instance Editable</strong> variable for rotation rate, which offers much more control and customization to the user, allowing each box to have its own rotation rate. The variable also allows us to spin the box on all three axes, whereas the original approach only rotated the box around the <em class="italic">z</em> (yaw) axis.</p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor043"/>The cascading cast chain problem</h2>
<p>This example is <a id="_idIndexMarker080"/>something we see quite regularly with new developers when communicating between different Blueprint classes.</p>
<p>The implementation here is for a game where a player character could be carrying one of three weapons: a pistol, shotgun, or rifle. Casts have been used to identify the class of the carried weapon, and when the cast returns true, each weapon’s fire event is called:</p>
<div><div><img alt="Figure 2.27 – A cascading cast chain in the Blueprint in the CH_Example_Bad asset" src="img/Figure_02.27_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.27 – A cascading cast chain in the Blueprint in the CH_Example_Bad asset</p>
<p>There are a few issues here. Firstly, it is the nature of the cast node in Unreal. While fine for prototyping, casts carry a resource impact where each actor we attempt to cast to gets loaded as part of the actor. So, in this case, all three weapons are included with the character in order to be able to check if the <strong class="bold">Carried Weapon</strong> child actor matches their classes.</p>
<p>You can see the effect of casts on memory by checking the size map of any actor.</p>
<p>To do this, proceed as follows:</p>
<ol>
<li>Select the <strong class="bold">Actor</strong> Blueprint in the <strong class="bold">Content Browser</strong>.</li>
<li>Right-click and select <strong class="bold">Size Map…</strong>.</li>
</ol>
<p>This will open a popup that will show the size (in memory) of the chosen actor:</p>
<div><div><img alt="Figure 2.28 – Size map of the character Blueprint class with a cascading cast chain" src="img/Figure_02.28_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.28 – Size map of the character Blueprint class with a cascading cast chain</p>
<p>The resulting <a id="_idIndexMarker081"/>Blueprint (which only has the basic character class elements and the cast chain) is 149.9 kB, compared to the 56.1 kB of a standard character with just the child actor set as a pistol. This could be made smaller, further optimizing the Blueprint’s memory impact, by setting the default class of the child actor to be actor, but this isn’t necessary to prove the point we are trying to make; casting causes unnecessary memory issues:</p>
<div><div><img alt="Figure 2.29 – Size map of a character Blueprint class with just a child actor component" src="img/Figure_02.29_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.29 – Size map of a character Blueprint class with just a child actor component</p>
<p>In both examples<a id="_idIndexMarker082"/> shown previously, the <code>Wpn_Pistol</code> class is just an empty actor with a custom event that would, in an eventual game, fire the weapon; however the class currently only contains a <code>Fire</code>. If you consider adding meshes, textures, particle systems, and audio components, the potential size of a character with a cascading cast chain becomes exponentially larger than it needs to be.</p>
<p>The second issue is the processing time of casting and waiting for failure before casting to the next weapon class and potentially waiting for that to fail. While we are talking milliseconds, it all adds up, especially if there are multiple characters and/or your non-player characters use the same character Blueprint.</p>
<p>The final issue with the cascading cast chain is the inflexibility (or extra work) that this approach provides. With the current setup, only the three weapons included in the chain can ever be used by the character. To expand the number of available weapons (as the project progresses or as part of a post-release piece of downloadable content), more casts will need to be added to the chain, multiplying the effects of the two aforementioned issues as well as being generally time-consuming to add them, particularly if there is any other logic required as part of the chain such as ammo management and cooldowns.</p>
<p>If you want to see the current setup’s output, then open the <code>TestLevel</code> map from the <code>TestFiles</code> directory, click <em class="italic">Play</em>, and then click the left mouse button; you will see a print in the<a id="_idIndexMarker083"/> top-left corner of the screen related to each weapon. Pressing the <em class="italic">1</em>, <em class="italic">2</em>, and <em class="italic">3</em> keys on your keyboard will swap between different weapon classes.</p>
<p>Let’s take a look at the solution to this problem.</p>
<h3>Solution to the cascading chain problem</h3>
<p>There are<a id="_idIndexMarker084"/> two potential solutions to the problem; the first is to use a parent and child class approach, casting to the parent class, which will allow <strong class="bold">Event Fire</strong> to be called on all of the children. As this still uses a cast, the parent class will still be included in the character, inflating the memory usage.</p>
<p>The second solution, which we are going to implement, is using an interface.</p>
<p>Interfaces allow two actors to communicate, without the need to identify the class type of the target actor.</p>
<p>Blueprint interfaces can be called from any Blueprint graph using an actor reference (which is the highest step of the class hierarchy). The receiving actor is required to implement the interface to define how it will respond to the interface event call.</p>
<p>In building this solution, we will create a simple Blueprint interface, add it to all of the weapons, and call it from the character, simply referencing the weapon as an actor class, negating the need for casting. Proceed as follows:</p>
<ol>
<li>Firstly, create a Blueprint interface by right-clicking in the <code>BI_Weapon</code>. We use the prefix <code>BI</code> to label this as a Blueprint interface.</li>
<li>Open the <code>Fire</code>.</li>
<li>Open <code>BI_Weapon</code>. Clicking it will add the <strong class="bold">BI Weapon</strong> interface to the <strong class="bold">Implemented </strong><strong class="bold">Interfaces</strong> list:</li>
</ol>
<div><div><img alt="Figure 2.30 – BI Weapon in the Implemented Interfaces list" src="img/Figure_02.30_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.30 – BI Weapon in the Implemented Interfaces list</p>
<ol>
<li value="4">This will now have added a <strong class="bold">Fire</strong> function under the <strong class="bold">Interfaces</strong> rollout in the <strong class="bold">My Blueprint</strong> tab. Double-click it; this will create an <strong class="bold">Event Fire</strong> interface event:</li>
</ol>
<div><div><img alt="Figure 2.31 – The Event Fire interface event, denoted by the interface icon over the top-right corner" src="img/Figure_02.31_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.31 – The Event Fire interface event, denoted by the interface icon over the top-right corner</p>
<ol>
<li value="5">Drag<a id="_idIndexMarker085"/> out from the <code>Print String</code> node, then replace <code>Pistol – </code><code>Interface Fire</code>.</li>
<li>Repeat <em class="italic">steps 3 to 5</em> on both the <strong class="bold">Wpn_Rifle</strong> and <strong class="bold">Wpn_Shotgun</strong> assets, changing the <strong class="bold">Print String</strong> node to include the name of each weapon.</li>
<li>Duplicate the <strong class="bold">CH_Example_Bad</strong> asset and rename it <strong class="bold">CH_Example_Better</strong>.</li>
<li>Open <strong class="bold">CH_Example_Better</strong> and delete all of the nodes from the <strong class="bold">InputAction PrimaryAction</strong> logic flow, except for the <strong class="bold">Carried Weapon</strong> and <strong class="bold">Target Child </strong><strong class="bold">Actor</strong> nodes.</li>
<li>Drag from the <code>Fire (Message)</code>; this will create a <strong class="bold">Fire</strong> interface event call, which will be called on whichever class is currently set as the <strong class="bold">Carried </strong><strong class="bold">Weapon</strong> class:</li>
</ol>
<div><div><img alt="Figure 2.32 – The resulting InputAction PrimaryAction Blueprint logic with the interface call" src="img/Figure_02.32_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.32 – The resulting InputAction PrimaryAction Blueprint logic with the interface call</p>
<p class="list-inset">In order to <a id="_idIndexMarker086"/>test this approach, we need to swap the <code>TestLevel</code> map to the better example we’ve just created.</p>
<ol>
<li value="10">Open <code>GM_Test</code> from the <code>TestFiles</code> directory in the <strong class="bold">Content Browser</strong>.</li>
<li>Change the <strong class="bold">Default Pawn Class</strong> dropdown to <strong class="bold">CH_Example_Better</strong>.</li>
</ol>
<p>Now, when you play the level and click the left mouse button, you will see the new interface prints.</p>
<p>The outcome we have achieved is essentially the same as before; however, the code used to achieve it is tidier, faster, uses less memory, and is infinitely expandable by avoiding casts and using the interface.</p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor044"/>The trade-off</h1>
<p>With any<a id="_idIndexMarker087"/> implementation of a pattern or fix, there is a trade-off between what you gain and what it costs, and it’s important to consider the long-term effects when implementing patterns.</p>
<p>In many of the cases we are exploring, the gain is simplicity, readability, or a reduction in memory footprint, which should help your game to run smoothly. These are all key elements worth maintaining a good code base for. The cost is often time. Some patterns may take longer to implement, and, in some cases, having to refactor code to work in a specific way can use up valuable time.</p>
<p>The long-term effects, however, outweigh the initial time cost as the time saved later in development to build on top of or into existing systems will prove beneficial later in your game’s development cycle.</p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor045"/>Summary</h1>
<p>In this chapter, we discussed the S.O.L.I.D. principles that underpin good code, exploring specific examples and how, as they expand in complexity, we need to consider these principles to keep the code functioning. These principles are widely recognized across the game development industry, and so understanding them will not only help improve code efficiency and readability but also allow smooth communication with co-developers on larger projects.</p>
<p>We also explored a series of common problems that new Unreal Engine users encounter and the solutions to them, looking specifically at a series of common tasks such as moving items and managing a selection of weapons on a character. The solutions, while specific, offer insights into how easily a developer can find themselves with large, lumbering Blueprints that can be solved by utilizing built-in systems and tools.</p>
<p>In the next chapter we will be taking these principles of clean code and seeing how Epic Games have applied them through the engine when we look at some of the patterns they have built for us. The utility of the engine as it were. These patterns will include double buffer, flyweight and spatial partitioning.</p>
</div>
</body></html>