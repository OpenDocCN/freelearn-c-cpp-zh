- en: Obstacle Avoidance and Collision Detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are making an autonomous robot that needs to avoid obstacles, a remote-controlled
    car that needs to detect when it hits something or even a 3D printer that needs
    to know when the print heads have reached the limits of the print area, you will
    need to include some sort of obstacle avoidance or collision detection system
    in your project. In this chapter, we will look at several sensors that can be
    used for obstacle avoidance and collision detection systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use a crash sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use an infrared obstacle avoidance sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use an Ultrasonic rangefinder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at three sensors that we can use to add obstacle
    avoidance and/or collision detection to our projects. These sensors are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Crash sensor**: Used to detect a crash and also used as limit switches for
    3D printers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrared obstacle avoidance sensor**: Used for obstacle avoidance for robotics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ultrasonic range finder**: Used for obstacle avoidance for robotics and has
    many other commercial and military uses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crash sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A crash sensor is basically a simple switch that has some sort of extender
    on it that gives it a large area to detect a crash. The following photograph show
    what a basic crash sensor would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cbf31a3-354a-4918-9ac0-4f1ca523f7c3.png)'
  prefs: []
  type: TYPE_IMG
- en: The crash sensor shown in the preceding photograph takes a simple mechanical
    switch, like the types used for end stops on 3D printers, and attaches it to the
    end of a circuit board. This makes it easy to mount out a robot chassis or other
    surfaces. The concept behind a crash sensor is when the switch is triggered, the
    sensor has bumped into something.
  prefs: []
  type: TYPE_NORMAL
- en: The crash sensor has three pins that are clearly marked as **GND**, **VCC**,
    and **OUT**. The GND pin connects to the ground rail and the VCC connects to power
    rail on the breadboard. The OUT pin connects directly to a digital pin on the
    Arduino with a 4.7K pull-up resistor.
  prefs: []
  type: TYPE_NORMAL
- en: The infrared obstacle avoidance sensor consists of an infrared transmitter,
    an infrared receiver, and a potentiometer that adjusts the distance the sensor
    will detect obstacles at. The following photographs show the obstacle avoidance
    sensor that is used for the project in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Obstacle avoidance sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The emitter on the infrared obstacle avoidance sensor emits infrared radiation
    and if an obstacle is in front of the sensor, some of the radiation is reflected
    back and picked up by the receiver. If no object is in front of the sensor then
    the radiation will dissipate, and the receiver will not receive anything back.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d396a4bf-039c-4dcf-bdb5-14d4f99feff5.png)'
  prefs: []
  type: TYPE_IMG
- en: The pins on the sensor are clearly marked with **OUT**, **GND**, and **VCC**,
    from left to right. The GND pin is connected to the ground rail and the VCC pin
    is connected to the power rail of the breadboard. The OUT pin is connected directly
    to a digital pin on the Arduino. If the signal from the OUT pin is LOW, then an
    object was detected. If the output is HIGH, then no object was detected.
  prefs: []
  type: TYPE_NORMAL
- en: The distance adjuster will adjust the distance that the sensor detects objects.
    If the adjuster is turned counter-clockwise then the distance will be decreased,
    and if you turn it clockwise the distance will increase. The sensor will detect
    objects from 2 to 30 cm.
  prefs: []
  type: TYPE_NORMAL
- en: Ultrasonic range finder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The third sensor that we will be using is a **MaxSonar EZ1** Ultrasonic range
    finder. This sensor is one of my favorite sensors to use. I have used it in almost
    every autonomous robot that I have built to determine the distance to nearby objects.
    The following is an image of the EZ1 Ultrasonic range finder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e094d1c3-4aea-4525-80cc-8e3989a25b51.png)'
  prefs: []
  type: TYPE_IMG
- en: For the example, in this chapter, we will be using pins 3,6, and 7 on the sensor.
    Pin 3 is used for analog out, pin 6 is for VCC and pin 7 is for ground. Pins 4
    and 5 are for serial RX/TX connection and pin 2 is for a pulse-width output, however,
    we will not be using those outputs in the example for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: An ultrasonic range finder works by sending an ultrasonic pulse in a particular
    direction. If there is an object in the path of the pulse when it is reflected
    back in the form of an echo. The sensor determines the distance to the object
    by measuring the time it takes for the echo to be received back.
  prefs: []
  type: TYPE_NORMAL
- en: The EZ1 ultrasonic sensor can detect and measure the distance to an object from
    0 to 6.45 meters (254 inches). This sensor has virtually no dead zone and will
    detect objects right up to the front sensor face.
  prefs: []
  type: TYPE_NORMAL
- en: Components needed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need the following components for this chapter''s project:'
  prefs: []
  type: TYPE_NORMAL
- en: One Arduino Uno or compatible board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One crash sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One obstacle avoidance sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One EZ1 Ultrasonic sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 4.7K resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram shows the Fritzing diagram for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e69c262-ac80-4c36-a471-747596d1b7df.png)'
  prefs: []
  type: TYPE_IMG
- en: The middle sensor, shown in the diagram, represents the crash sensor because
    there isn't a Fritzing part for a crash sensor. The switch in the diagram has
    the same pin layout as the crash sensor shown earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the diagram, we can see that all of the ground pins on the sensors are connected
    to the ground rail of the breadboard and all of the VCC pins on the sensors are
    connected to the power rail on the breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: The analog out on the EZ1 Ultrasonic sonar sensor is connected to the A1 analog
    pin on the Arduino, the crash sensor is connected to digital pin 3 and the infrared
    sensor is connected to digital pin 2\. The crash sensor also has a 4.7K pull-up
    resistor. Now that we have the sensors connected to the Arduino, let's look at
    the code for this project.
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will begin the code with three macros that define the pins that the three
    sensors are connected to. The macros will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These macros show that the crash sensor is connected to digital pin 4, the
    infrared sensor is connected to digital pin 3 and the ultrasonic rangefinder is
    connected to analog pin 1\. Now we need to set the mode for the two digital pins
    that we are using and also initiate the serial monitor. We can do this by adding
    the following code to the `setup()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This starts off by initiating the serial monitor and then configures the crash
    and infrared sensor pins to input so we can read the values. Now we need to add
    the code to the `loop()` function that will read the sensors. Let''s start off
    by looking at how we would read and interrupt the crash sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code starts off by using the `digitalRead()` function to read the pin that
    the crash sensor is connected to and then uses the `isnan()` function to verify
    that the `digitalRead()` function returned a correct value. If the value returned
    by the function is not valid (not a number) then an error message is printed to
    the serial console the `return` statement is called to exit this loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the value returned by the `digitalRead()` function is valid, then we check
    to see if the value is `LOW` and if so then an obstacle was detected, and a message
    is printed to the serial console. Now let''s add the code for the infrared sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is exactly the same as the crash sensor except we read the infrared
    sensor pin and check that value. Now let''s add the code for the Ultrasonic range
    finder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code starts by using the `analogRead()` function to read the pin that the
    ultrasonic range finder is connected too. We then use the `isnan()` function to
    verify that a correct value was returned.
  prefs: []
  type: TYPE_NORMAL
- en: The distance to the object is then calculated in both millimeters and inches.
    The numbers used in the calculations documented on the datasheet for the sensor
    and may be different depending on the model that you are using. Now we will want
    to put a short delay at the end of the `loop()` function to pause the execution.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's run the project.
  prefs: []
  type: TYPE_NORMAL
- en: Running the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we run this project, the output should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c55d908-f4ce-468e-be3d-7f6e503ed73c.png)'
  prefs: []
  type: TYPE_IMG
- en: This screenshot shows that an object tripped the infrared sensor twice, where
    `IR Detected` is printed to the serial console and the crash sensor once, where
    `Collision Detected` was printed to the serial console. It also shows the distance
    that the rangefinder returned as the closest object.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This challenge is going to be a little different than most. There isn''t really
    a project to do; instead, it is a thinking challenge. The challenge is to think
    about how all three of these sensors work can work together to create an autonomous
    robot. To do this, think about how all three of the sensors work:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Crash sensor**: A digital sensor that is tripped when the sensor bumps into
    something'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Infrared sensor**: A digital sensor that is tripped when something gets close'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ultrasonic range finder**: Analog sensor used to detect how far an object
    is from the sensor'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the answers:'
  prefs: []
  type: TYPE_NORMAL
- en: The Ultrasonic range finders are the most expensive by far, so I usually use
    only two of these sensors facing out form the front of the robot. These are used
    to by the robot to navigate around obstacles. With the ability to tell how far
    something is from the front of the robot, we can give the robot the logic it needs
    to decide when to turn and also, with two ultrasonic sensors, the logic to decide
    which way to turn. We can also use the Ultrasonic sensors to map a room.
  prefs: []
  type: TYPE_NORMAL
- en: The infrared sensors are very inexpensive and can be used on the sides and back
    to make sure the robot does not bump into anything when it is turning or backing
    up. Since they are a lot cheaper than the ultrasonic sensors, we can use multiple
    infrared sensors to make sure we have the full area around the robot covered.
    We could also use the infrared sensors, facing down, to make sure the robot does
    not drive off a ledge.
  prefs: []
  type: TYPE_NORMAL
- en: The crash sensors are also very inexpensive and can be used all around to the
    robot to detect if the robot crashes into anything that the ultrasonic or infrared
    sensors missed. The biggest problem with the ultrasonic and infrared sensors is
    how high they are on the robot. If they are too high, then they may miss obstacles
    that are low to the ground. A crash sensor can be used to detect these.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to use three sensors that can be used for obstacle
    avoidance and collision detection. The crash sensor is a digital sensor that can
    be used to tell when the sensor bumps into something. The infrared obstacle avoidance
    sensor is also a digital sensor that can tell when the sensor is within a certain
    distance of an obstacle. The Ultrasonic range finder is an analog sensor that
    can be used to tell how far an obstacle is from the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some different types of LEDs and see how
    we can use them in our projects.
  prefs: []
  type: TYPE_NORMAL
