<html><head></head><body>
		<div id="_idContainer152">
			<h1 class="chapter-number" id="_idParaDest-184"><a id="_idTextAnchor296"/>13</h1>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor297"/>Caching Data to Decrease Bandwidth</h1>
			<p>When it comes to reducing bandwidth usage and optimizing network usage in game development, there is a powerful technique that always comes to <span class="No-Break">mind: caching.</span></p>
			<p>Caching solves<a id="_idIndexMarker488"/> the question of why we should keep downloading the same data repeatedly when we can download it once, store it somewhere, and reuse it whenever needed. In this chapter, we will delve into caching techniques and learn how to apply them to efficiently download, store, and reuse images and other relevant data. For that, we will use a database that contains image URLs that we are going to download directly from the internet into our <span class="No-Break">players’ machines.</span></p>
			<p>To demonstrate the implementation of these caching techniques, we will prototype a new feature in our game project, where players will have the ability to upload custom images for their spaceships. To save time and focus solely on the network aspect of this feature, we will avoid implementing user experience and user interface aspects, leaving those tasks to the talented individuals in our imaginary indie studio. Your role, as a developer, will be to tackle the network-related aspects of this feature and ensure its <span class="No-Break">seamless integration.</span></p>
			<p>In the following screenshot, you can witness the exciting results of this feature in action. Two players are engaging in the game with their own custom spaceship sprites, which have been downloaded from the server. These sprites are sourced from Twemoji, an open source repository of <a id="_idIndexMarker489"/>Creative Commons-licensed emojis maintained <span class="No-Break">by Twitter.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer143">
					<img alt="Figure 13.1 – The custom spaceship sprites downloaded from the server for the two players" src="image/Figure_13.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – The custom spaceship sprites downloaded from the server for the two players</p>
			<p>The topics covered in this chapter are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break">Understanding caching</span></li>
				<li>Setting up the <span class="No-Break"><strong class="source-inline">HTTPRequest</strong></span><span class="No-Break"> node</span></li>
				<li>Implementing <span class="No-Break">texture caching</span></li>
				<li>Implementing <span class="No-Break">database caching</span></li>
				<li>Going further <span class="No-Break">with caching</span></li>
			</ul>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor298"/>Technical requirements</h1>
			<p>It is worth mentioning that this chapter builds upon the concepts presented in <a href="B18527_10.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Debugging and Profiling the Network</em>, as well as the project developed in <a href="B18527_09.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Creating an Online Adventure Prototype</em>. Therefore, it is crucial to familiarize yourself with the concepts and techniques discussed in those chapters to fully grasp the optimization methods presented here. We will also build upon the final project from <a href="B18527_12.xhtml#_idTextAnchor285"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Implementing Lag Compensation</em>, for which you can get the files through the <span class="No-Break">following link:</span></p>
			<p><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation"><span class="No-Break">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation</span></a></p>
			<p>Moreover, throughout this chapter, it is important to have a basic understanding of how to upload and host content on online services. For instance, we will be downloading files directly from the project’s GitHub repository and from a service called ImgBB, a free image-hosting platform. Without understanding the mechanisms behind content hosting and retrieval using direct links, you may encounter difficulties in understanding and implementing the processes we are about <span class="No-Break">to explore.</span></p>
			<p>To enrich your learning experience, I highly recommend downloading the latest version of the Twemoji repository, which can be obtained from <a href="https://github.com/twitter/twemoji">https://github.com/twitter/twemoji</a>. By exploring this repository, you will gain further insights into how images and other media content can be managed and incorporated into your game <span class="No-Break">development projects.</span></p>
			<p>That said, let’s understand what caching is and how we are going to use it in our <span class="No-Break">game project.</span></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor299"/>Understanding caching</h1>
			<p>In online multiplayer games, every second counts. Players expect seamless, real-time experiences without interruptions. This is where caching becomes a powerful ally in optimizing game performance. So, what exactly is caching, and why is it crucial for online <span class="No-Break">multiplayer games?</span></p>
			<p><strong class="bold">Caching</strong> is the <a id="_idIndexMarker490"/>process of storing frequently accessed data or resources on a local device or intermediate server. These resources can include images, sound files, 3D models, or even small snippets of code. Instead of fetching these resources from a remote server every time they are needed, the game stores them locally. When a request for these resources arises, the game checks whether it already has a local copy. If it does, it uses the local version, significantly reducing loading times and conserving precious <span class="No-Break">network bandwidth.</span></p>
			<p>The principle behind caching is simple yet effective: if you’ve used something once, it’s likely you’ll need it again. In the context of our multiplayer game, this means that the images, sounds, and assets that players download to customize their spaceships can be cached locally on their devices. When another player comes into view, the game can retrieve these assets from the local cache instead of re-downloading them. This creates a more streamlined experience and reduces the stress on <span class="No-Break">the network.</span></p>
			<p>Caching offers numerous advantages in online multiplayer games. The most prominent benefit is an enhanced gaming experience. By using cached resources, players can swiftly interact with others, see their personalized spaceship designs, and engage in combat without significant delays. Reduced loading times translate to more fluid and immersive gameplay. Moreover, this process eases the strain on the server, enabling it to handle more <span class="No-Break">players simultaneously.</span></p>
			<p>Caching is<a id="_idIndexMarker491"/> not just about speed; it’s also about efficiency. Downloading the same resources repeatedly not only wastes bandwidth but also makes the game less environmentally friendly and potentially costly for players with limited data plans. By caching frequently used resources, the game becomes faster, more eco-friendly, <span class="No-Break">and cost-effective.</span></p>
			<p>In the following sections, we will explore how to leverage the powerful <strong class="source-inline">HTTPRequest</strong> node to implement caching for customized spaceship images. We will dive into the processes of downloading these images and ensuring their availability in each player’s cache, enhancing the online multiplayer experience. Stay tuned for a step-by-step guide on how to implement caching in <span class="No-Break">your game.</span></p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor300"/>Setting up the HTTPRequest node</h1>
			<p>As mentioned in the chapter’s <a id="_idIndexMarker492"/>introduction, we <a id="_idIndexMarker493"/>are going to implement a feature that allows players to use custom sprites on <span class="No-Break">their spaceships.</span></p>
			<p>To prototype this feature, we will download images from a third-party image-hosting service that offers free image hosting. We will accomplish this by using a <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) request to retrieve the image file from the third-party servers. Let’s delve into the workings of HTTP to fully understand how it operates and grasp the <span class="No-Break">implementation process.</span></p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor301"/>Understanding the HTTP protocol</h2>
			<p><strong class="bold">HTTP</strong> serves as<a id="_idIndexMarker494"/> the foundation for communication <a id="_idIndexMarker495"/>on the <strong class="bold">World Wide Web</strong>. It is a protocol that defines the interaction and data exchange between clients and servers. Invented by Tim Berners-Lee in the early 1990s, HTTP was initially designed to facilitate the retrieval of hypertext documents, commonly known as web pages. Over time, it has evolved to support various types of content, including images, videos, <span class="No-Break">and files.</span></p>
			<p>When a client, such as our player, wants to retrieve a resource from a server, it initiates an <a id="_idIndexMarker496"/>HTTP request. This request consists of a method that specifies the desired action to be performed on the resource, along with a <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) that<a id="_idIndexMarker497"/> indicates the location of the resource. The most-used HTTP methods are <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong>. In the context of downloading images, the <strong class="source-inline">GET</strong> method is what we <span class="No-Break">typically employ.</span></p>
			<p>Upon receiving the HTTP request, the server processes it and prepares an HTTP response. This response contains the requested resource, accompanied by metadata such as the HTTP status code, content type, and <span class="No-Break">content length.</span></p>
			<p>Additionally, the server includes headers in the response to provide further information or instructions to <span class="No-Break">the client.</span></p>
			<p>To download images using HTTP, the client sends a <strong class="source-inline">GET</strong> request to the server, specifying the URL of the image. The server then processes this request and sends back an HTTP response that contains the image data. The client receives this response and interprets it to display the image to <span class="No-Break">the user.</span></p>
			<p>HTTP operates as a stateless protocol, meaning that each request-response cycle is independent and does not retain any information about <span class="No-Break">previous interactions.</span></p>
			<p>However, mechanisms such as cookies and session management can be employed to maintain state and enable more <span class="No-Break">complex interactions.</span></p>
			<p>In summary, HTTP serves as the protocol that facilitates communication between clients and servers on the web. It enables us to download images and other resources by sending HTTP requests to servers and receiving HTTP responses that contain the requested data. Understanding the workings of HTTP is essential for implementing features such as downloading images in our <span class="No-Break">game project.</span></p>
			<p>The reason we are going to use HTTP requests is because the types of files we want to cache are fairly large compared to the kind of data we usually transfer using <strong class="bold">Remote Procedure Calls</strong> (<strong class="bold">RPCs</strong>). Remember, the ENet library relies heavily on UDP, which isn’t the best option when we want reliable big chunks of data exchange; as UDP aims for high-speed data exchange, packets may arrive at their destination unorganized, and they may not even arrive at the destination at all. When dealing with images, we quickly reach kilobytes or even megabytes of data, so compared to our usual byte exchanges through RPCs and MultiPlayerSynchronizers, it’s very heavy content. But <a id="_idIndexMarker498"/>HTTP is meant precisely for that. In the upcoming section, we are going to set up the <strong class="source-inline">HTTPRequest</strong> nodes and a minimal database where we will pair the players’ usernames and the URLs of their custom spaceship sprites. This database is intended to go on the server side and be cached in the player’s machine later, as we will see in the <em class="italic">Implementing database </em><span class="No-Break"><em class="italic">caching</em></span><span class="No-Break"> section.</span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor302"/>Setting up the scenes and database</h2>
			<p>Let’s <a id="_idIndexMarker499"/>begin setting up the scenes <span class="No-Break">and database.</span></p>
			<p>To create our database, let’s open the <strong class="source-inline">res://09.prototyping-space-adventure/</strong> folder and create a new text file. You can quickly do that by right-clicking the folder in the <strong class="bold">FileSystem</strong> dock. The following screenshot displays the menu that pops up. From there, select <strong class="bold">New</strong> | <span class="No-Break"><strong class="bold">TextFile...</strong></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer144">
					<img alt="Figure 13.2 – Creating a new text file directly through the FileSystem dock" src="image/Figure_13.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Creating a new text file directly through the FileSystem dock</p>
			<p>Then, create <a id="_idIndexMarker500"/>a file named <strong class="source-inline">PlayerSpaceships.json</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer145">
					<img alt="Figure 13.3 – Creating a new text file named PlayerSpaceship﻿s.json" src="image/Figure_13.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Creating a new text file named PlayerSpaceships.json</p>
			<p>Now, regarding <a id="_idIndexMarker501"/>the content, we are going to maintain the users from the <strong class="bold">FakeDatabase</strong> we created in <a href="B18527_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter</em></span><span class="No-Break"><em class="italic"> 2</em></span></a><em class="italic">, Sending and Receiving Data,</em> and pair them with the URLs from the images we want to prototype. In this case, I used a service called ImgBB, which allows me to upload the images I rendered from the Twemoji repository. I used the rocket and the saucer emojis as references for these custom sprites. The content of the <strong class="source-inline">PlayerSpaceships.json</strong> file will look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
{
     "user1": "https://i.ibb.co/KxqzJMp/rocket.png",
     "user2": "https://i.ibb.co/d7BR6hX/saucer.png"
}</pre>			<p>Note that you can experiment with other images and hosting services. As long as you have the image’s direct link, usually pointing to the <strong class="source-inline">.png</strong> file, you will <span class="No-Break">be good.</span></p>
			<p>Now, it’s time to set up the <strong class="source-inline">HTTPRequest</strong> nodes. We are going to start by downloading the <strong class="source-inline">PlayerSpaceships.json</strong> file from the server. In our case, this file is hosted on GitHub, but you can store it on another server as long as you have a direct link to the actual database file. In our case you can find <span class="No-Break">it here:</span></p>
			<p><a href="http://raw.githubusercontent.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/13.caching-data/source/09.prototyping-space-adventure/PlayerSpaceships.json"><span class="No-Break">raw.githubusercontent.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/13.caching-data/source/09.prototyping-space-adventure/PlayerSpaceships.json</span></a></p>
			<p>With the <strong class="source-inline">PlayerSpaceships.json</strong> file up on the internet, let’s see how we can download it to our players’ machines with the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Create a <a id="_idIndexMarker502"/>new scene and use an <strong class="source-inline">HTTPRequest</strong> node as the <span class="No-Break">root node.</span></li>
				<li>Rename it to <strong class="source-inline">SpaceshipsDatabaseDownloadHTTPRequest</strong>, as this node will be responsible for downloading the database from <span class="No-Break">the internet.</span></li>
				<li>Attach a new script to this node and save the scene and the script. Here I saved them directly as <span class="No-Break"><strong class="source-inline">res://09.prototyping-space-</strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">adventure/SpaceshipsDatabaseDownloadHTTPRequest</strong></span><span class="No-Break">.</span></li>
				<li>Now, open the script, and let’s do <span class="No-Break">the following:</span><ol><li class="upper-roman">Create an exported variable for the path to the folder that we will use for caching. Here it’s important to use the <strong class="source-inline">user://</strong> data folder path so Godot Engine properly adapts the path depending on the platform the game is <span class="No-Break">running on:</span></li></ol><pre class="source-code">
extends HTTPRequest
@export_global_dir var cache_directory = "user://.cache/"</pre><ol><li class="upper-roman" value="2">Then, create a new exported variable that should point to where the database file is going to be saved. Let’s keep its default filename and put it into the <span class="No-Break"><strong class="source-inline">cache</strong></span><span class="No-Break"> folder:</span></li></ol><pre class="source-code">extends HTTPRequest
@export_global_dir var cache_directory = "user://.cache/"
@export_global_file var spaceships_database_path = "user://.  cache/PlayerSpaces
hips.json"</pre><ol><li class="upper-roman" value="3">After that, we can export yet another variable. But now we need to store the link <a id="_idIndexMarker503"/>of the location where the <strong class="source-inline">PlayerSpaceships.json</strong> file will be <span class="No-Break">downloaded from:</span></li></ol><pre class="source-code">extends HTTPRequest
@export_global_dir var cache_directory = "user://.cache/"
@export_global_file var spaceships_database_path = "user://.cache/PlayerSpaces
hips.json"
@export var spaceships_database_link = "https://raw.githubusercontent.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/13.caching-data/source/09.prototyping-space-adventure/PlayerSpaceships.json"</pre><ol><li class="upper-roman" value="4">With that, we can move on to the actual downloading method. Create a new method called <strong class="source-inline">download_spaceships_database()</strong> and let’s start <span class="No-Break">its implementation.</span></li><li class="upper-roman">The first thing we are going to do here is to check whether there’s a cache directory already. If we don’t have it yet, we will <span class="No-Break">create it:</span></li></ol><pre class="source-code">func download_spaceships_database():
     var directory_access = DirAccess.open(cache_directory)
     if not directory_access:
          DirAccess.make_dir_absolute(cache_directory)</pre><ol><li class="upper-roman" value="6">Then, we will<a id="_idIndexMarker504"/> check whether the <strong class="source-inline">PlayerSpaceships.json</strong> file exists. If it doesn’t, we will start the actual download. The first thing to start the download is to set the file path in the <strong class="source-inline">download_file</strong> <span class="No-Break">member variable:</span></li></ol><pre class="source-code">func download_spaceships_database():
     var directory_access = DirAccess.open(cache_directory)
     if not directory_access:
          DirAccess.make_dir_absolute(cache_directory)
     var file_access = FileAccess.open(spaceships_database_path, FileAccess.READ)
     if not file_access:
          download_file = spaceships_database_path</pre><ol><li class="upper-roman" value="7">With <strong class="source-inline">download_file</strong> set, we can make the request to the file. For that, we will use the <strong class="source-inline">request()</strong> method, which asks for a URL. This method uses the <strong class="source-inline">GET</strong> method by default to make requests, which is what we want in this case. But you can change this in the third argument, right after passing some custom headers if you want. We don’t have to pass anything other than the URL in <span class="No-Break">our case:</span></li></ol><pre class="source-code">func download_spaceships_database():
     var directory_access = DirAccess.open(cache_directory)
     if not directory_access:
          DirAccess.make_dir_absolute(cache_directory)
     var file_access = FileAccess.open(spaceships_database_path, FileAccess.READ)
     if not file_access:
          download_file = spaceships_database_path
          request(spaceships_database_link)</pre><ol><li class="upper-roman" value="8">After that, we<a id="_idIndexMarker505"/> need to wait for the request to finish. Remember, since this is an asynchronous procedure, the game needs to wait for it to complete before moving on to any logic that depends on <span class="No-Break">this file:</span></li></ol><pre class="source-code">func download_spaceships_database():
     var directory_access = DirAccess.open(cache_directory)
     if not directory_access:
          DirAccess.make_dir_absolute(cache_directory)
     var file_access = FileAccess.open(spaceships_database_path, FileAccess.READ)
     if not file_access:
          download_file = spaceships_database_path
          request(spaceships_database_link)
          await request_completed</pre></li>			</ol>
			<p>After following the preceding steps, we should have our <strong class="source-inline">SpaceshipsDatabaseDownloadHTTPRequest</strong> working. If you want to, you can test it out. For that, call the <strong class="source-inline">download_spaceship_database()</strong> method in the <strong class="source-inline">_ready()</strong> callback and run the scene. After that, if you open the user data folder, you will see the <strong class="source-inline">.cache/</strong> folder and if you enter this folder you should find the <strong class="source-inline">PlayerSpaceships.json</strong> file there. Note that in this case the <strong class="source-inline">.cache/</strong> is a hidden folder, so make sure you can see hidden folders in your file manager. To quickly open the user data folder, you can go to <strong class="bold">Project</strong> | <strong class="bold">Open User Data Folder</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer146">
					<img alt="Figure 13.4 - Open﻿ User Data Folder from the Editor’s Project tab" src="image/Figure_13.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 - Open User Data Folder from the Editor’s Project tab</p>
			<p>Now, let’s<a id="_idIndexMarker506"/> create the <strong class="source-inline">TextureDownloadHTTPRequest</strong> scene so we can use the data in <strong class="source-inline">PlayerSpaceships.json</strong> to effectively download the players’ custom spaceship sprites. For that, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Create a new scene and use an <strong class="source-inline">HTTPRequest</strong> node <span class="No-Break">as root.</span></li>
				<li>Rename it <strong class="source-inline">TextureDownloadHTTPRequest</strong> as this is the one actually responsible for downloading the textures from <span class="No-Break">the internet.</span></li>
				<li>Save the scene as <strong class="source-inline">res://09.prototyping-space-</strong> <strong class="source-inline">adventure/TextureDownloadHTTPRequest.tscn</strong> and attach a script to it, then in the script let’s do <span class="No-Break">the following:</span><ol><li class="upper-roman">Export a variable that should point to the <strong class="source-inline">PlayerSpaceships.json</strong> file in the player’s machine, so this path should use the <strong class="source-inline">user://</strong> <span class="No-Break">file path:</span></li></ol><pre class="source-code">
extends HTTPRequest
@export_global_file var spaceships_database_file = "user://.cache/PlayerSpaces hips.json"</pre><ol><li class="upper-roman" value="2">Create a new method called <strong class="source-inline">download_spaceship()</strong>. This method should receive two arguments, one for the user and another one for the file path where the sprite will <span class="No-Break">be saved:</span></li></ol><pre class="source-code">extends HTTPRequest
@export_global_file var spaceships_database_file = "user://.cache/PlayerSpaces hips.json"
func download_spaceship(user, sprite_file):</pre><ol><li class="upper-roman" value="3">Then, inside this<a id="_idIndexMarker507"/> method, we will create a new <strong class="source-inline">Dictionary</strong> called <strong class="source-inline">players_spaceships</strong>, which will start empty but will soon store the content from the <span class="No-Break"><strong class="source-inline">PlayerSpaceships.json</strong></span><span class="No-Break"> file:</span></li></ol><pre class="source-code">func download_spaceship(user, sprite_file):
     var players_spaceships = {}</pre><ol><li class="upper-roman" value="4">Now, we are going to check whether the file provided by the <strong class="source-inline">spaceships_database_file</strong> path exists. If it does, we will open it, convert it to a string using <strong class="source-inline">FileAccess.get_as_text()</strong> , and parse it from JSON format to <strong class="source-inline">Dictionary</strong> object format, storing it in the <span class="No-Break"><strong class="source-inline">players_spaceships</strong></span><span class="No-Break"> variable:</span></li></ol><pre class="source-code">func download_spaceship(user, sprite_file):
     var players_spaceships = {}     if FileAccess.file_exists(spaceships_database_file):
          var file = FileAccess.open(spaceships_database_file, FileAccess.READ)
          players_spaceships = JSON.parse_string(file.get_as_text())</pre><ol><li class="upper-roman" value="5">After that, we can download the <strong class="source-inline">user</strong> sprite based on the URL provided by the <strong class="source-inline">PlayerSpaceships.json</strong> database and store it in the file path provided by the <strong class="source-inline">sprite_file</strong> argument. For that, we will use <strong class="source-inline">HTTPRequest.download_file</strong> and download it using the <strong class="source-inline">HTTPRequest.request()</strong> method. Note that this method returns an error if the request has any <a id="_idIndexMarker508"/>issues. Let’s store this in an <strong class="source-inline">error</strong> variable to allow other classes to verify whether the request <span class="No-Break">was successful:</span></li></ol><pre class="source-code">func download_spaceship(user, sprite_file):
     var players_spaceships = {}
     if FileAccess.file_exists(spaceships_database_file):
          var file = FileAccess.open(spaceships_database_file, FileAccess.READ)
          players_spaceships = JSON.parse_string(file.get_as_text())
     if user in players_spaceships:
          download_file = sprite_file
          var error = request(players_spaceships[user])</pre><ol><li class="upper-roman" value="6">Since HTTP requests may take some time to finish downloading the content requested, we need to wait for the <strong class="source-inline">HTTPRequest.request_completed</strong> signal before ending the function and returning the error. Note that if the function doesn’t reach any of these conditional statements, we should return <strong class="source-inline">FAILED</strong> to acknowledge to other classes that <strong class="source-inline">spaceships_database_file</strong> doesn’t <a id="_idIndexMarker509"/>exist or <strong class="source-inline">user</strong> doesn’t exist in <span class="No-Break">the database:</span></li></ol><pre class="source-code">func download_spaceship(user, sprite_file):
     var players_spaceships = {}
     if FileAccess.file_exists(spaceships_database_file):
          var file = FileAccess.open(spaceships_database_file, FileAccess.READ)
          players_spaceships = JSON.parse_string(file.get_as_text())
     if user in players_spaceships:
          download_file = sprite_file
          var error = request(players_spaceships[user])
          await request_completed
          return error
     return FAILED</pre></li>			</ol>
			<p>Alright, this ends our journey to set up HTTPRequests. We created the database and the two nodes responsible for working on its data, downloading the database to the players’ machines, and downloading the content in the database as well, in this case, the players’ spaceships’ custom sprites. You can test the scene as well by calling the <strong class="source-inline">download_spaceship()</strong> method using <strong class="source-inline">"user1"</strong> and <strong class="source-inline">"user://.cache/user1_spaceship.png"</strong> as arguments. Just make sure that you’ve run the <strong class="source-inline">SpaceshipDatabaseDownloadHTTPRequest</strong> scene first so the <strong class="source-inline">PlayersSpaceships.json</strong> file exists in the <strong class="source-inline">user://.cache/</strong> folder. With that, you should see a new image downloaded right in your user data folder! The following screenshot shows what my <strong class="source-inline">user://.cache/</strong> folder <span class="No-Break">looks like:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer147">
					<img alt="Figure 13.5 – The ﻿user data folder with the Player﻿Spaceships.json file and user1’s custom spaceship sprite" src="image/Figure_13.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – The user data folder with the PlayerSpaceships.json file and user1’s custom spaceship sprite</p>
			<p>In this section, we <a id="_idIndexMarker510"/>learned about the usage of HTTP requests for caching data and downloading images in the user data folder. We saw the difference between UDP and HTTP when it comes to transferring large files such as images and how to use the <strong class="source-inline">HTTPRequest</strong> node to use the HTTP protocol in Godot and transfer data from the internet to <span class="No-Break">our machine.</span></p>
			<p>In the upcoming section, we will discuss the implementation of texture caching in the game itself, allowing for real-time changes to the players’ spaceships. This feature will be achieved by using the <strong class="source-inline">HTTPRequest</strong> nodes we created and our minimal database to get the URLs of the players’ custom <span class="No-Break">spaceship sprites.</span></p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor303"/>Implementing texture caching</h1>
			<p>In the <a id="_idIndexMarker511"/>previous section, we introduced the <strong class="source-inline">HTTPRequest</strong> node, a built-in solution offered by Godot Engine to make HTTP requests. Then we created <strong class="source-inline">TextureDownloadHTTPRequest</strong>, which is a custom node specialized in downloading images from our <strong class="source-inline">PlayersSpaceship.json</strong> database. Now, let’s dive deeper into integrating this node into our <strong class="source-inline">Player2D</strong> class so we can actually use it in <span class="No-Break">our prototype.</span></p>
			<p>In this section, we will create a method to enable the server to change a player’s spaceship sprite dynamically. But we won’t just load any sprite; we’ll fetch the proper file from the <strong class="source-inline">user://.cache/</strong> folder we set up in the <em class="italic">Setting up the scenes and database </em>section. This approach will enhance the customization and interaction in your game, allowing the server to deliver custom sprites to players in <span class="No-Break">real time.</span></p>
			<p>To achieve this, we’ll create a method called <strong class="source-inline">load_spaceship()</strong>. This method will play a fundamental role in our implementation. It will be an RPC function that the server can trigger remotely for specific players. Well, let’s get started! Open the <strong class="source-inline">res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn</strong> scene and work through the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Let’s start by adding an instance of <strong class="source-inline">TextureDownloadHTTPRequest</strong> directly as a child of the <span class="No-Break"><strong class="source-inline">Player</strong></span><span class="No-Break"> node.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer148">
					<img alt="Figure 13.6 – ﻿TextureDownloadHTTPRequest instantiated in the Player scene" src="image/Figure_13.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – TextureDownloadHTTPRequest instantiated in the Player scene</p>
			<ol>
				<li value="2">Then, open<a id="_idIndexMarker512"/> the <span class="No-Break"><strong class="source-inline">res://09.prototyping-space-adventure/Actors/Player/Player2D.gd</strong></span><span class="No-Break"> script.</span></li>
				<li>Let’s store a reference to the <strong class="source-inline">TextureDownloadHTTPRequest</strong> node. We can call it just <strong class="source-inline">http_request</strong> <span class="No-Break">for short:</span><pre class="source-code">
@onready var http_request = $TextureDownloadHTTPRequest</pre></li>				<li>Then, right below the <strong class="source-inline">setup_multiplayer()</strong> method, let’s create the <strong class="source-inline">load_spaceship()</strong> method. It will be an RPC method that should only be remotely callable by the server and should also be called locally, so the server also updates the image. This method receives the user, which loads <span class="No-Break">the spaceship:</span><pre class="source-code">
@rpc("authority", "call_local")
func load_spaceship(user):</pre></li>				<li>Now, inside this<a id="_idIndexMarker513"/> method, we are going to create the file path to the spaceship texture file in the player’s machine and store it in a variable called <strong class="source-inline">spaceship_file</strong>. This file path is composed of the <strong class="source-inline">"user://.cache/"</strong> string, followed by the <strong class="source-inline">user</strong> value we got as an argument, and we will append <strong class="source-inline">"_spaceship.png"</strong> to create the proper file path with an <span class="No-Break">image extension:</span><pre class="source-code">
@rpc("authority", "call_local")
func load_spaceship(user):
     var spaceship_file = "user://.cache/" + user + "_spaceship.png"</pre></li>				<li>With a proper file path to work with, the next step is to see whether this file already exists because the whole idea of caching data is that, if it already exists in the player’s machine, we can load it instead of re-downloading it and reduce resource consumption. The following code checks whether the file exists. If it does, we call the <strong class="source-inline">update_sprite()</strong> method passing <strong class="source-inline">spaceship_file</strong> as an argument. We are going to create the <strong class="source-inline">update_sprite()</strong> method in <span class="No-Break">a moment:</span><pre class="source-code">
@rpc("authority", "call_local")
func load_spaceship(user):
     var spaceship_file = "user://.cache/" + user + "_spaceship.png"
     if FileAccess.file_exists(spaceship_file):
          update_sprite(spaceship_file)</pre></li>				<li>Now, <strong class="source-inline">TextureDownloadHTTPRequest</strong> will play its role. If the file doesn’t exist in the cache folder, we call the <strong class="source-inline">TextureDownloadHTTPRequest.download_texture()</strong> method and wait for it to finish; remember, it’s an asynchronous method. And if this method returns an <strong class="source-inline">OK</strong> error, meaning there’s actually no error, we also call the <strong class="source-inline">update_sprite()</strong> method so the game performs the procedures to effectively update the spaceship’s sprite. The following code checks whether the <strong class="source-inline">update_sprite()</strong> method returns anything other than <strong class="source-inline">OK</strong>. If the <strong class="source-inline">update_sprite()</strong> method doesn’t return <strong class="source-inline">OK</strong>, it means no sprite will be loaded. Since the custom sprite doesn’t affect the player’s core experience, we can just assume we can keep the default sprite and let the <span class="No-Break">game </span><span class="No-Break"><a id="_idIndexMarker514"/></span><span class="No-Break">run:</span><pre class="source-code">
@rpc("authority", "call_local")
func load_spaceship(user):
     var spaceship_file = "user://.cache/" + user + "_spaceship.png"
     if FileAccess.file_exists(spaceship_file):
          update_sprite(spaceship_file)
     else:
          if await http_request.download_spaceship(user, spaceship_file) == OK:
               update_sprite(spaceship_file)</pre></li>				<li>Now let’s create the <strong class="source-inline">update_sprite()</strong> method. This is the method that effectively changes the <strong class="source-inline">Sprite</strong> node’s <strong class="source-inline">Texture</strong> property. It will load the image from the file path using the <strong class="source-inline">Image.load_from_file()</strong> method and turn it into an <strong class="source-inline">ImageTexture</strong> using the <span class="No-Break"><strong class="source-inline">ImageTexture.create_from_image()</strong></span><span class="No-Break"> method:</span><pre class="source-code">
func update_sprite(spaceship_file):
     var image = Image.load_from_file(spaceship_file)
     var texture = ImageTexture.create_from_image(image)
     $Spaceship/Sprite2D.texture = texture</pre></li>			</ol>
			<p>In this section, we saw<a id="_idIndexMarker515"/> how to use the <strong class="source-inline">TextureDownloadHTTPRequest</strong> node to download and cache the images from our database. We also saw how to dynamically change a player’s spaceship sprite using the cached images, loading them as image resources and turning them into an actual <strong class="source-inline">ImageTexture</strong> that the spaceship’s <strong class="source-inline">Sprite2D</strong> node <span class="No-Break">can use.</span></p>
			<p>Now, the missing part of this process is…how we actually get the <strong class="source-inline">PlayersSpaceship.json</strong> database and where we call the <strong class="source-inline">load_spaceship()</strong> method. Well, that’s what we are going to do in the <span class="No-Break">next section!</span></p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor304"/>Implementing database caching</h1>
			<p>With everything in place, it is time to go<a id="_idIndexMarker516"/> one step above and work on the <strong class="source-inline">World</strong> scene that is going to glue everything together and run the proper procedures to ensure that all players will see the same custom sprites. We do that in this node because this is the class responsible for setting up everything related to world synchronization, which includes the players’ spaceship custom sprites. We will need to make some changes in some core methods to achieve that, but this is for <span class="No-Break">the better.</span></p>
			<p>Since we are working with a prototype, there’s no fear of altering function signatures and other core aspects of a class. But note that if this was production-ready, we would call this class “closed” and avoid making core changes like the ones we are about to make. This would keep our game code base consistent and avoid errors. Though the changes we are about to make will mostly extend the class functionalities, we will add an argument to the <strong class="source-inline">World.create_spaceship()</strong> method, breaking the function’s contract since it didn’t ask for any arguments before. But, as said, this is a prototype, and we have the freedom to tweak things as we want. So, let’s open the <strong class="source-inline">res://09.prototyping-space-adventure/Levels/World.tscn</strong> scene and implement the improvements by working through the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>First things first, let’s add <a id="_idIndexMarker517"/>an instance of the <strong class="source-inline">SpaceshipsDatabaseDownloadHTTPRequest</strong> node as a direct child of the <span class="No-Break"><strong class="source-inline">World</strong></span><span class="No-Break"> node.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer149">
					<img alt="Figure 13.7 – ﻿SpaceshipsDatabaseDownloadHTTPRequest instantiated in the World scene" src="image/Figure_13.07_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – SpaceshipsDatabaseDownloadHTTPRequest instantiated in the World scene</p>
			<ol>
				<li value="2">Then, let’s <a id="_idIndexMarker518"/>open the <strong class="source-inline">res://09.prototyping-space-adventure/Levels/World.gd</strong> script and start the code by adding a reference to the <strong class="source-inline">SpaceshipsDatabaseDownloadHTTPRequest</strong> node. We can simply call it <strong class="source-inline">http_request</strong> here <span class="No-Break">as well:</span><pre class="source-code">
@onready var http_request = $SpaceshipsDatabaseDownloadHTTPRequest</pre></li>				<li>We will also create a new variable to store a <strong class="bold">dictionary</strong> that will pair <strong class="source-inline">player_ids</strong> and their <strong class="source-inline">user</strong>. This will allow us to look into this variable to find the proper username related to each player’s peer ID so we can easily map them in our database <span class="No-Break">moving forward:</span><pre class="source-code">
var player_users = {}</pre></li>				<li>Now, in the <strong class="source-inline">_ready()</strong> callback, after waiting briefly for the <strong class="source-inline">0.1</strong> <strong class="source-inline">SceneTree</strong>’s timer to timeout, we will wait for <strong class="source-inline">http_request</strong> to download the spaceships database as well. Remember, this only happens if the instance running the game isn’t <span class="No-Break">the server:</span><pre class="source-code">
func _ready():
     if not multiplayer.is_server():
          await(get_tree().create_timer(0.1).timeout)
          await http_request.downloa<a id="_idTextAnchor305"/>d_spaceships_database()</pre></li>				<li>Still in this <strong class="source-inline">if</strong> statement, we will make a small change. When making the RPC to the server’s <strong class="source-inline">create_spaceship()</strong> method, we will also pass the player’s user. For that, we will use the long-time-forgotten <span class="No-Break"><strong class="source-inline">AuthenticationCredentials</strong></span><span class="No-Break"> singleton!</span><pre class="source-code">
func _ready():
     if not multiplayer.is_server():
          await(get_tree().create_timer(0.1).timeout)
          await http_request.download_spaceships_database()
          rpc_id(1, "sync_world")
          rpc_id(1, "create_spaceship", AuthenticationCredentials.user)</pre></li>				<li>Moving on to the <strong class="source-inline">create_spaceship()</strong>method, we need to, of course, change its function signature to support the <span class="No-Break"><strong class="source-inline">user</strong></span><span class="No-Break"> argument:</span><pre class="source-code">
@rpc("any_peer", "call_remote")
func create_spaceship(user):</pre></li>				<li>Then, before<a id="_idIndexMarker519"/> adding the <strong class="source-inline">spaceship</strong> as a child of the <strong class="source-inline">Players</strong> node, we will use its name (which is essentially a string version of the player’s peer ID) as a key in the <strong class="source-inline">player_users</strong> dictionary and set this key’s value to the <strong class="source-inline">user</strong> argument. With that, we effectively paired the player’s ID with <span class="No-Break">their username:</span><pre class="source-code">
@rpc("any_peer", "call_remote")
func create_spaceship(user):
     var player_id = multiplayer.get_remote_sender_id()
     var spaceship = preload("res://09.prototyping-space-adventure/Actors/Player/Play er2D.tscn").instantiate()
     spaceship.name = str(player_id)
     player_users[spaceship.name] = user</pre></li>				<li>After making the RPC to the newly instantiated player spaceship’s <strong class="source-inline">setup_multiplayer()</strong> method, we will make the magic happen by also making an RPC to the <strong class="source-inline">load_spaceship()</strong> method, triggering the procedures we made in the <em class="italic">Implementing texture caching</em> section. The updated version of the <strong class="source-inline">create_spaceship()</strong> method will look like this after <span class="No-Break">these changes:</span><pre class="source-code">
@rpc("any_peer", "call_remote")
func create_spaceship(user):
     var player_id = multiplayer.get_remote_sender_id()
     var spaceship = preload("res://09.prototyping-space-adventure/Actors/Player/Play er2D.tscn").instantiate()
     spaceship.name = str(player_id)
     player_users[spaceship.name] = user
     $Players.add_child(spaceship)
     await(get_tree().create_timer(0.1).timeout)
     spaceship.rpc("setup_multiplayer", player_id)
     spaceship.rpc("load_spaceship", user)</pre></li>			</ol>
			<p>Great! With that, whenever<a id="_idIndexMarker520"/> a player jumps into the game, their spaceship will change its sprite to the custom sprite the player uploaded, if any. Now, we need to also make this happen to the spaceships that were already in the game world when the player joined. For that, we need to make some changes in the <strong class="source-inline">_on_players_multiplayer_spawner_spawned()</strong> callback. Still in the <strong class="source-inline">res://09.prototyping- space-adventure/Levels/World.gd</strong> script, let’s implement the changes by moving on to the <strong class="source-inline">_on_players_multiplayer_spawner_spawned()</strong> method and go through the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Let’s revamp the whole logic of this callback and make it from scratch. We are going to start by creating a variable to store the player’s peer ID, which we can get by turning the recently spawned node’s name into an integer. Node names are <strong class="source-inline">StringNames</strong> so they are not pure strings, meaning we need to turn them into default strings before turning them <span class="No-Break">into integers:</span><pre class="source-code">
func _on_players_multiplayer_spawner_spawned(node):
     var player_id = int(str(node.name))</pre></li>				<li>After that, we will make the global RPC to the <strong class="source-inline">setup_multiplayer()</strong> method, just as we did before, but now we pass <strong class="source-inline">player_id</strong> as <span class="No-Break">the argument:</span><pre class="source-code">
func _on_players_multiplayer_spawner_spawned(node):
     var player_id = int(str(node.name))
     node.rpc("setup_multiplayer", player_id)</pre></li>				<li>Then comes the interesting part. After making this RPC, if the spawned node, in other words the spawned player, happens to be in another player’s game instance, instead of the server’s instance, we will also make an RPC directly to the server, asking it to sync this spaceship using a method (which we are going to create soon) called <strong class="source-inline">sync_spaceship()</strong>, which receives a player ID as <span class="No-Break">its argument:</span><pre class="source-code">
func _on_players_multiplayer_spawner_spawned(node):
     var player_id = int(str(node.name))
     node.rpc("setup_multiplayer", player_id)
     if not multiplayer.is_server():
          rpc_id(1, "sync_spaceship", player_id)</pre></li>				<li>Let’s move on <a id="_idIndexMarker521"/>to the <strong class="source-inline">sync_spaceship()</strong> method now. Let’s create this method with an RPC annotation that will allow any peer to remotely call it and it will also be called locally on the server. Remember, this method receives <strong class="source-inline">player_id</strong> as <span class="No-Break">its argument:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func sync_spaceship(player_id):</pre></li>				<li>Inside the <strong class="source-inline">sync_spaceship()</strong> method, we will first and foremost store a reference to the ID of whoever made the RPC to this function. This will allow us to make the <strong class="source-inline">rpc_id()</strong> method call directly to the player that just joined the game, instead of making a call to every player every time a player joins <span class="No-Break">the game:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func sync_spaceship(player_id):
     var requester = multiplayer.get_remote_sender_id()</pre></li>				<li>Then, we will find the correct player in the <strong class="source-inline">Players</strong> node children by using the <strong class="source-inline">get_node()</strong> method and appending the <strong class="source-inline">player_id</strong>. Remember, since the <strong class="source-inline">player_id</strong> is also the node’s name, this is how we can easily find it among all the <span class="No-Break"><strong class="source-inline">Players</strong></span><span class="No-Break"> children:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func sync_spaceship(player_id):
     var requester = multiplayer.get_remote_sender_id()
     var node = get_node("Players/%s" % player_id)</pre></li>				<li>After that, we <a id="_idIndexMarker522"/>will find the player’s username. For that, we will use <strong class="source-inline">player_id</strong> as a key in <strong class="source-inline">player_users</strong>, which will return us the <span class="No-Break">proper username:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func sync_spaceship(player_id):
     var requester = multiplayer.get_remote_sender_id()
     var node = get_node("Players/%s" % player_id)
     var user = player_users[node.name]</pre></li>				<li>Finally, with the user in our hands, we can make an RPC to the <strong class="source-inline">load_spaceship()</strong> method on this requester's instance of the <strong class="source-inline">node</strong> that represents the spaceship spawned on their instance of <span class="No-Break">the game:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func sync_spaceship(player_id):
     var requester = multiplayer.get_remote_sender_id()
     var node = get_node("Players/%s" % player_id)
     var user = player_users[node.name]
     node.rpc_id(requester, "load_spaceship", user)</pre></li>			</ol>
			<p>And we did it! With this in place, the<a id="_idIndexMarker523"/> game is now able to load, store, and sync players’ custom spaceship sprites. If you run the game now you can see the game caching data to decrease bandwidth and downloading and updating the players’ spaceship sprites in real time. The following screenshot displays the before and after of implementing <span class="No-Break">this feature.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer150">
					<img alt="Figure 13.8 – The before and after implementing the custom sprites feature" src="image/Figure_13.08_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – The before and after implementing the custom sprites feature</p>
			<p>Something interesting that<a id="_idIndexMarker524"/> you can check if you want to measure how much difference caching makes is to remove the statements that check whether the files exist in the <strong class="source-inline">user://.cache/</strong> folder and add a Monitor to monitor the <strong class="source-inline">TextureDownloadHTTPRequest</strong> and <strong class="source-inline">SpaceshipsDatabaseDownloadHTTPRequest</strong> downloaded bytes. For that, you can use the <strong class="source-inline">HTTPRequest.get_downloaded_bytes()</strong> method. For instance, the following code snippet displays how we can create a Monitor in the <span class="No-Break"><strong class="source-inline">TextureDownloadHTTPRequest</strong></span><span class="No-Break"> node:</span></p>
			<pre class="source-code">
func _ready():
     var callable = Callable(self, "get_texture_downloaded_bytes")
     Performance.add_custom_monitor("Network/Texture Download Bytes", callable)
func get_texture_downloaded_bytes():
     return get_downloaded_bytes()</pre>			<p>And with that, we can test our <a id="_idIndexMarker525"/>game multiple times to simulate players logging in and out of the game and see how the caching impacts each stage. Something you will notice is that after the images have been cached, they are almost instantaneously updated when players log in to the game again. The following screenshot displays the actual impact on the network usage in bytes before and after caching the images in the <span class="No-Break">player’s machine:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer151">
					<img alt="Figure 13.9 – A comparison between the network consumption the first time the player downloads the textures and after caching the textures in their machine" src="image/Figure_13.09_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – A comparison between the network consumption the first time the player downloads the textures and after caching the textures in their machine</p>
			<p>In this section, we saw how to<a id="_idIndexMarker526"/> implement database caching for custom spaceship sprites in our game. The <strong class="source-inline">World</strong> scene is responsible for synchronizing the game world, including the players’ spaceship sprites. So, we made some changes to it to achieve the caching we’ve implemented in previous sections. We saw how to use the <strong class="source-inline">SpaceshipsDatabaseDownloadHTTPRequest</strong> node to download the spaceships database and make RPCs to update players’ spaceship sprites and sync spaceship sprites when players join the game. At the end of the section, we used a Monitor and the <strong class="source-inline">HTTPRequest.get_downloaded_bytes()</strong> method to see how caching reduces bandwidth usage and <a id="_idIndexMarker527"/>improves <span class="No-Break">network efficiency.</span></p>
			<p>Note the number of bytes saved in <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.9</em> with only two textures cached! Imagine, in the long run, how this could impact hundreds and even thousands of players as they log in and out of the game multiple times a day. And we are only talking about textures here. What else can we cache and effectively save hundreds of thousands of network bytes on? Well, that’s what we are going to see in the <span class="No-Break">upcoming section.</span></p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor306"/>Going further with caching</h1>
			<p>Well, as we saw, images are not the only type of data we can download through the internet using the <strong class="source-inline">HTTPRequest</strong> node; for instance, we also downloaded the <strong class="source-inline">PlayersSpaceship.json</strong> file, which is a text file. But we can download pretty much anything using this protocol, provided it is stored in an HTTP page. But sometimes, some files are not stored and made available publicly on an HTTP page that any browser can access. Usually in this type of situation, the backend engineer will create a REST API that we can use to retrieve these files directly from the database where they <span class="No-Break">are stored.</span></p>
			<p>This type of feature demands a physical infrastructure and the development of a custom REST API so we can work with it. Unfortunately, this goes way beyond the scope of this book. But the whole idea is that you can perform an HTTP request using custom headers and a custom URL that resembles an RPC. So, in the very URL itself you would add some parameters that the REST API would interpret as a method call and arguments. It’s very similar to what we did in <a href="B18527_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><em class="italic">,</em> <em class="italic">Sending and Receiving Data</em>, and REST APIs usually use JSON-formatted strings as the main data structure <span class="No-Break">as well.</span></p>
			<p>For instance, you can check out a series on my YouTube channel that relies heavily on REST APIs to integrate a third-party service into a game of mine called <em class="italic">Moon Cheeser</em>. The REST API is provided by <em class="italic">LootLocker</em> and at some point, I download a whole <strong class="source-inline">PacketScene</strong> from their server to cache it in the player’s machine and allow them to always have a copy of their purchased skin. You can check this particular video at the <span class="No-Break">following link:</span></p>
			<p><a href="https://youtu.be/w0qz-pJMIBo?si=WF2KH9-FRyO8glVq"><span class="No-Break">https://youtu.be/w0qz-pJMIBo?si=WF2KH9-FRyO8glVq</span></a></p>
			<p>Well, I’m going to use LootLocker’s public API as an example here too. This is the HTTP request I used to retrieve the file associated with the skin the <span class="No-Break">player purchases:</span></p>
			<pre class="source-code">
curl -X GET "https://api.lootlocker.io/game/v1/assets/list?count=10&amp;filter=purchasabl e" \-H "x-session-token: your_token_here"</pre>			<p>This translates into the following <strong class="source-inline">GDScript</strong> code, using an <span class="No-Break"><strong class="source-inline">HTTPRequest</strong></span><span class="No-Break"> node:</span></p>
			<pre class="source-code">
var url = "https://api.lootlocker.io/game/v1/assets/list?count=10&amp;filter=purchasable"
var header = ["Content-Type: application/json", "x-session-token: %s" % LootLocker.tok
en]
request(url, header)</pre>			<p>Now comes the interesting part that we haven’t explored yet. The <strong class="source-inline">HTTPRequest.request_completed</strong> signal is emitted when this request is completed and the server gives a response to the client with some very interesting data, including the response’s body, which usually is a JSON file containing the URL to the file we want. So, you can connect this signal to a signal callback and access the response’s body to get access to what the server provides you with regarding the request. This can go from the content of a file itself to a JSON file containing much more information, including the URL to download the file <span class="No-Break">you want.</span></p>
			<p>To avoid going off on a tangent here, I highly recommend you watch the video and understand how we download a resource-intensive file. In this case, I downloaded a custom <strong class="source-inline">PackedScene</strong> instance together with its dependencies, such as an image necessary to make the purchased skin display properly, and cached it into <span class="No-Break">players’ devices.</span></p>
			<p>With this in your hands, you can implement all sorts of caching and save tons of resource usage, both for your players and your server, since it won’t be constantly delivering the same files to the same <span class="No-Break">clients repeatedly.</span></p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor307"/>Summary</h1>
			<p>Well, it’s time to wrap this chapter up! In this chapter, we discussed what caching is and how it allows us to save bandwidth. We learned how to implement it for custom spaceship sprites in our game. For that, we saw how we can use the <strong class="source-inline">HTTPRequest</strong> node to download files over the internet by making HTTP requests. We also implemented a custom Monitor to see how much data we saved throughout a play session by caching textures. Finally, we saw how caching can go beyond image and text files and the possibility of using REST APIs to download all sorts of files <span class="No-Break">using HTTP.</span></p>
			<p>With that, my fellow Godot Engine developers, we reach the end of <span class="No-Break">our journey!</span></p>
			<p>We started as people who didn’t know how to send a simple message to another computer, and became fully fledged network engineers ready to create the games of our dreams and allow players to have a shared experience, enjoy their time together, and build communities around the world. Congratulations on completing this journey. You are now capable of one of the most amazing things any human being can do: to connect people together toward a <span class="No-Break">shared goal.</span></p>
			<p>This is my farewell. I’m very proud of what we went through, and I hope you use this power for good. You can definitely expect more from me to come. But for now, <span class="No-Break">that’s it.</span></p>
			<p class="author-quote">Thank you so much for reading. Keep developing, and until the next time!</p>
		</div>
	</body></html>