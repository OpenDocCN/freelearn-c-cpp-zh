<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-184"><a id="_idTextAnchor296"/>13</h1>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor297"/>Caching Data to Decrease Bandwidth</h1>
			<p>When it comes to reducing bandwidth usage and optimizing network usage in game development, there is a powerful technique that always comes to mind: caching.</p>
			<p>Caching solves<a id="_idIndexMarker488"/> the question of why we should keep downloading the same data repeatedly when we can download it once, store it somewhere, and reuse it whenever needed. In this chapter, we will delve into caching techniques and learn how to apply them to efficiently download, store, and reuse images and other relevant data. For that, we will use a database that contains image URLs that we are going to download directly from the internet into our players’ machines.</p>
			<p>To demonstrate the implementation of these caching techniques, we will prototype a new feature in our game project, where players will have the ability to upload custom images for their spaceships. To save time and focus solely on the network aspect of this feature, we will avoid implementing user experience and user interface aspects, leaving those tasks to the talented individuals in our imaginary indie studio. Your role, as a developer, will be to tackle the network-related aspects of this feature and ensure its seamless integration.</p>
			<p>In the following screenshot, you can witness the exciting results of this feature in action. Two players are engaging in the game with their own custom spaceship sprites, which have been downloaded from the server. These sprites are sourced from Twemoji, an open source repository of <a id="_idIndexMarker489"/>Creative Commons-licensed emojis maintained by Twitter.</p>
			<div><div><img alt="Figure 13.1 – The custom spaceship sprites downloaded from the server for the two players" src="img/Figure_13.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – The custom spaceship sprites downloaded from the server for the two players</p>
			<p>The topics covered in this chapter are as follows:</p>
			<ul>
				<li>Understanding caching</li>
				<li>Setting up the <code>HTTPRequest</code> node</li>
				<li>Implementing texture caching</li>
				<li>Implementing database caching</li>
				<li>Going further with caching</li>
			</ul>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor298"/>Technical requirements</h1>
			<p>It is worth mentioning that this chapter builds upon the concepts presented in <a href="B18527_10.xhtml#_idTextAnchor260"><em class="italic">Chapter 10</em></a>, <em class="italic">Debugging and Profiling the Network</em>, as well as the project developed in <a href="B18527_09.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a>, <em class="italic">Creating an Online Adventure Prototype</em>. Therefore, it is crucial to familiarize yourself with the concepts and techniques discussed in those chapters to fully grasp the optimization methods presented here. We will also build upon the final project from <a href="B18527_12.xhtml#_idTextAnchor285"><em class="italic">Chapter 12</em></a>, <em class="italic">Implementing Lag Compensation</em>, for which you can get the files through the following link:</p>
			<p><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/12.prediction-and-interpolation</a></p>
			<p>Moreover, throughout this chapter, it is important to have a basic understanding of how to upload and host content on online services. For instance, we will be downloading files directly from the project’s GitHub repository and from a service called ImgBB, a free image-hosting platform. Without understanding the mechanisms behind content hosting and retrieval using direct links, you may encounter difficulties in understanding and implementing the processes we are about to explore.</p>
			<p>To enrich your learning experience, I highly recommend downloading the latest version of the Twemoji repository, which can be obtained from <a href="https://github.com/twitter/twemoji">https://github.com/twitter/twemoji</a>. By exploring this repository, you will gain further insights into how images and other media content can be managed and incorporated into your game development projects.</p>
			<p>That said, let’s understand what caching is and how we are going to use it in our game project.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor299"/>Understanding caching</h1>
			<p>In online multiplayer games, every second counts. Players expect seamless, real-time experiences without interruptions. This is where caching becomes a powerful ally in optimizing game performance. So, what exactly is caching, and why is it crucial for online multiplayer games?</p>
			<p><strong class="bold">Caching</strong> is the <a id="_idIndexMarker490"/>process of storing frequently accessed data or resources on a local device or intermediate server. These resources can include images, sound files, 3D models, or even small snippets of code. Instead of fetching these resources from a remote server every time they are needed, the game stores them locally. When a request for these resources arises, the game checks whether it already has a local copy. If it does, it uses the local version, significantly reducing loading times and conserving precious network bandwidth.</p>
			<p>The principle behind caching is simple yet effective: if you’ve used something once, it’s likely you’ll need it again. In the context of our multiplayer game, this means that the images, sounds, and assets that players download to customize their spaceships can be cached locally on their devices. When another player comes into view, the game can retrieve these assets from the local cache instead of re-downloading them. This creates a more streamlined experience and reduces the stress on the network.</p>
			<p>Caching offers numerous advantages in online multiplayer games. The most prominent benefit is an enhanced gaming experience. By using cached resources, players can swiftly interact with others, see their personalized spaceship designs, and engage in combat without significant delays. Reduced loading times translate to more fluid and immersive gameplay. Moreover, this process eases the strain on the server, enabling it to handle more players simultaneously.</p>
			<p>Caching is<a id="_idIndexMarker491"/> not just about speed; it’s also about efficiency. Downloading the same resources repeatedly not only wastes bandwidth but also makes the game less environmentally friendly and potentially costly for players with limited data plans. By caching frequently used resources, the game becomes faster, more eco-friendly, and cost-effective.</p>
			<p>In the following sections, we will explore how to leverage the powerful <code>HTTPRequest</code> node to implement caching for customized spaceship images. We will dive into the processes of downloading these images and ensuring their availability in each player’s cache, enhancing the online multiplayer experience. Stay tuned for a step-by-step guide on how to implement caching in your game.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor300"/>Setting up the HTTPRequest node</h1>
			<p>As mentioned in the chapter’s <a id="_idIndexMarker492"/>introduction, we <a id="_idIndexMarker493"/>are going to implement a feature that allows players to use custom sprites on their spaceships.</p>
			<p>To prototype this feature, we will download images from a third-party image-hosting service that offers free image hosting. We will accomplish this by using a <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) request to retrieve the image file from the third-party servers. Let’s delve into the workings of HTTP to fully understand how it operates and grasp the implementation process.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor301"/>Understanding the HTTP protocol</h2>
			<p><strong class="bold">HTTP</strong> serves as<a id="_idIndexMarker494"/> the foundation for communication <a id="_idIndexMarker495"/>on the <strong class="bold">World Wide Web</strong>. It is a protocol that defines the interaction and data exchange between clients and servers. Invented by Tim Berners-Lee in the early 1990s, HTTP was initially designed to facilitate the retrieval of hypertext documents, commonly known as web pages. Over time, it has evolved to support various types of content, including images, videos, and files.</p>
			<p>When a client, such as our player, wants to retrieve a resource from a server, it initiates an <a id="_idIndexMarker496"/>HTTP request. This request consists of a method that specifies the desired action to be performed on the resource, along with a <code>GET</code>, <code>POST</code>, <code>PUT</code>, and <code>DELETE</code>. In the context of downloading images, the <code>GET</code> method is what we typically employ.</p>
			<p>Upon receiving the HTTP request, the server processes it and prepares an HTTP response. This response contains the requested resource, accompanied by metadata such as the HTTP status code, content type, and content length.</p>
			<p>Additionally, the server includes headers in the response to provide further information or instructions to the client.</p>
			<p>To download images using HTTP, the client sends a <code>GET</code> request to the server, specifying the URL of the image. The server then processes this request and sends back an HTTP response that contains the image data. The client receives this response and interprets it to display the image to the user.</p>
			<p>HTTP operates as a stateless protocol, meaning that each request-response cycle is independent and does not retain any information about previous interactions.</p>
			<p>However, mechanisms such as cookies and session management can be employed to maintain state and enable more complex interactions.</p>
			<p>In summary, HTTP serves as the protocol that facilitates communication between clients and servers on the web. It enables us to download images and other resources by sending HTTP requests to servers and receiving HTTP responses that contain the requested data. Understanding the workings of HTTP is essential for implementing features such as downloading images in our game project.</p>
			<p>The reason we are going to use HTTP requests is because the types of files we want to cache are fairly large compared to the kind of data we usually transfer using <code>HTTPRequest</code> nodes and a minimal database where we will pair the players’ usernames and the URLs of their custom spaceship sprites. This database is intended to go on the server side and be cached in the player’s machine later, as we will see in the <em class="italic">Implementing database </em><em class="italic">caching</em> section.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor302"/>Setting up the scenes and database</h2>
			<p>Let’s <a id="_idIndexMarker499"/>begin setting up the scenes and database.</p>
			<p>To create our database, let’s open the <code>res://09.prototyping-space-adventure/</code> folder and create a new text file. You can quickly do that by right-clicking the folder in the <strong class="bold">FileSystem</strong> dock. The following screenshot displays the menu that pops up. From there, select <strong class="bold">New</strong> | <strong class="bold">TextFile...</strong>.</p>
			<div><div><img alt="Figure 13.2 – Creating a new text file directly through the FileSystem dock" src="img/Figure_13.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Creating a new text file directly through the FileSystem dock</p>
			<p>Then, create <a id="_idIndexMarker500"/>a file named <code>PlayerSpaceships.json</code>, as shown in the following screenshot:</p>
			<div><div><img alt="Figure 13.3 – Creating a new text file named PlayerSpaceship﻿s.json" src="img/Figure_13.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Creating a new text file named PlayerSpaceships.json</p>
			<p>Now, regarding <a id="_idIndexMarker501"/>the content, we are going to maintain the users from the <code>PlayerSpaceships.json</code> file will look like this:</p>
			<pre class="source-code">
{
     "user1": "https://i.ibb.co/KxqzJMp/rocket.png",
     "user2": "https://i.ibb.co/d7BR6hX/saucer.png"
}</pre>			<p>Note that you can experiment with other images and hosting services. As long as you have the image’s direct link, usually pointing to the <code>.png</code> file, you will be good.</p>
			<p>Now, it’s time to set up the <code>HTTPRequest</code> nodes. We are going to start by downloading the <code>PlayerSpaceships.json</code> file from the server. In our case, this file is hosted on GitHub, but you can store it on another server as long as you have a direct link to the actual database file. In our case you can find it here:</p>
			<p><a href="http://raw.githubusercontent.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/13.caching-data/source/09.prototyping-space-adventure/PlayerSpaceships.json">raw.githubusercontent.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/13.caching-data/source/09.prototyping-space-adventure/PlayerSpaceships.json</a></p>
			<p>With the <code>PlayerSpaceships.json</code> file up on the internet, let’s see how we can download it to our players’ machines with the following steps:</p>
			<ol>
				<li>Create a <a id="_idIndexMarker502"/>new scene and use an <code>HTTPRequest</code> node as the root node.</li>
				<li>Rename it to <code>SpaceshipsDatabaseDownloadHTTPRequest</code>, as this node will be responsible for downloading the database from the internet.</li>
				<li>Attach a new script to this node and save the scene and the script. Here I saved them directly as <code>res://09.prototyping-space-</code> <code>adventure/SpaceshipsDatabaseDownloadHTTPRequest</code>.</li>
				<li>Now, open the script, and let’s do the following:<ol><li class="upper-roman">Create an exported variable for the path to the folder that we will use for caching. Here it’s important to use the <code>user://</code> data folder path so Godot Engine properly adapts the path depending on the platform the game is running on:</li></ol><pre class="source-code">
extends HTTPRequest
@export_global_dir var cache_directory = "user://.cache/"</pre><ol><li class="upper-roman" value="2">Then, create a new exported variable that should point to where the database file is going to be saved. Let’s keep its default filename and put it into the <code>cache</code> folder:</li></ol><pre class="source-code">extends HTTPRequest
@export_global_dir var cache_directory = "user://.cache/"
@export_global_file var spaceships_database_path = "user://.  cache/PlayerSpaces
hips.json"</pre><ol><li class="upper-roman" value="3">After that, we can export yet another variable. But now we need to store the link <a id="_idIndexMarker503"/>of the location where the <code>PlayerSpaceships.json</code> file will be downloaded from:</li></ol><pre class="source-code">extends HTTPRequest
@export_global_dir var cache_directory = "user://.cache/"
@export_global_file var spaceships_database_path = "user://.cache/PlayerSpaces
hips.json"
@export var spaceships_database_link = "https://raw.githubusercontent.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/13.caching-data/source/09.prototyping-space-adventure/PlayerSpaceships.json"</pre><ol><li class="upper-roman" value="4">With that, we can move on to the actual downloading method. Create a new method called <code>download_spaceships_database()</code> and let’s start its implementation.</li><li class="upper-roman">The first thing we are going to do here is to check whether there’s a cache directory already. If we don’t have it yet, we will create it:</li></ol><pre class="source-code">func download_spaceships_database():
     var directory_access = DirAccess.open(cache_directory)
     if not directory_access:
          DirAccess.make_dir_absolute(cache_directory)</pre><ol><li class="upper-roman" value="6">Then, we will<a id="_idIndexMarker504"/> check whether the <code>PlayerSpaceships.json</code> file exists. If it doesn’t, we will start the actual download. The first thing to start the download is to set the file path in the <code>download_file</code> member variable:</li></ol><pre class="source-code">func download_spaceships_database():
     var directory_access = DirAccess.open(cache_directory)
     if not directory_access:
          DirAccess.make_dir_absolute(cache_directory)
     var file_access = FileAccess.open(spaceships_database_path, FileAccess.READ)
     if not file_access:
          download_file = spaceships_database_path</pre><ol><li class="upper-roman" value="7">With <code>download_file</code> set, we can make the request to the file. For that, we will use the <code>request()</code> method, which asks for a URL. This method uses the <code>GET</code> method by default to make requests, which is what we want in this case. But you can change this in the third argument, right after passing some custom headers if you want. We don’t have to pass anything other than the URL in our case:</li></ol><pre class="source-code">func download_spaceships_database():
     var directory_access = DirAccess.open(cache_directory)
     if not directory_access:
          DirAccess.make_dir_absolute(cache_directory)
     var file_access = FileAccess.open(spaceships_database_path, FileAccess.READ)
     if not file_access:
          download_file = spaceships_database_path
          request(spaceships_database_link)</pre><ol><li class="upper-roman" value="8">After that, we<a id="_idIndexMarker505"/> need to wait for the request to finish. Remember, since this is an asynchronous procedure, the game needs to wait for it to complete before moving on to any logic that depends on this file:</li></ol><pre class="source-code">func download_spaceships_database():
     var directory_access = DirAccess.open(cache_directory)
     if not directory_access:
          DirAccess.make_dir_absolute(cache_directory)
     var file_access = FileAccess.open(spaceships_database_path, FileAccess.READ)
     if not file_access:
          download_file = spaceships_database_path
          request(spaceships_database_link)
          await request_completed</pre></li>			</ol>
			<p>After following the preceding steps, we should have our <code>SpaceshipsDatabaseDownloadHTTPRequest</code> working. If you want to, you can test it out. For that, call the <code>download_spaceship_database()</code> method in the <code>_ready()</code> callback and run the scene. After that, if you open the user data folder, you will see the <code>.cache/</code> folder and if you enter this folder you should find the <code>PlayerSpaceships.json</code> file there. Note that in this case the <code>.cache/</code> is a hidden folder, so make sure you can see hidden folders in your file manager. To quickly open the user data folder, you can go to <strong class="bold">Project</strong> | <strong class="bold">Open User Data Folder</strong>, as shown in the following screenshot:</p>
			<div><div><img alt="Figure 13.4 - Open﻿ User Data Folder from the Editor’s Project tab" src="img/Figure_13.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 - Open User Data Folder from the Editor’s Project tab</p>
			<p>Now, let’s<a id="_idIndexMarker506"/> create the <code>TextureDownloadHTTPRequest</code> scene so we can use the data in <code>PlayerSpaceships.json</code> to effectively download the players’ custom spaceship sprites. For that, follow these steps:</p>
			<ol>
				<li>Create a new scene and use an <code>HTTPRequest</code> node as root.</li>
				<li>Rename it <code>TextureDownloadHTTPRequest</code> as this is the one actually responsible for downloading the textures from the internet.</li>
				<li>Save the scene as <code>res://09.prototyping-space-</code> <code>adventure/TextureDownloadHTTPRequest.tscn</code> and attach a script to it, then in the script let’s do the following:<ol><li class="upper-roman">Export a variable that should point to the <code>PlayerSpaceships.json</code> file in the player’s machine, so this path should use the <code>user://</code> file path:</li></ol><pre class="source-code">
extends HTTPRequest
@export_global_file var spaceships_database_file = "user://.cache/PlayerSpaces hips.json"</pre><ol><li class="upper-roman" value="2">Create a new method called <code>download_spaceship()</code>. This method should receive two arguments, one for the user and another one for the file path where the sprite will be saved:</li></ol><pre class="source-code">extends HTTPRequest
@export_global_file var spaceships_database_file = "user://.cache/PlayerSpaces hips.json"
func download_spaceship(user, sprite_file):</pre><ol><li class="upper-roman" value="3">Then, inside this<a id="_idIndexMarker507"/> method, we will create a new <code>Dictionary</code> called <code>players_spaceships</code>, which will start empty but will soon store the content from the <code>PlayerSpaceships.json</code> file:</li></ol><pre class="source-code">func download_spaceship(user, sprite_file):
     var players_spaceships = {}</pre><ol><li class="upper-roman" value="4">Now, we are going to check whether the file provided by the <code>spaceships_database_file</code> path exists. If it does, we will open it, convert it to a string using <code>FileAccess.get_as_text()</code> , and parse it from JSON format to <code>Dictionary</code> object format, storing it in the <code>players_spaceships</code> variable:</li></ol><pre class="source-code">func download_spaceship(user, sprite_file):
     var players_spaceships = {}     if FileAccess.file_exists(spaceships_database_file):
          var file = FileAccess.open(spaceships_database_file, FileAccess.READ)
          players_spaceships = JSON.parse_string(file.get_as_text())</pre><ol><li class="upper-roman" value="5">After that, we can download the <code>user</code> sprite based on the URL provided by the <code>PlayerSpaceships.json</code> database and store it in the file path provided by the <code>sprite_file</code> argument. For that, we will use <code>HTTPRequest.download_file</code> and download it using the <code>HTTPRequest.request()</code> method. Note that this method returns an error if the request has any <a id="_idIndexMarker508"/>issues. Let’s store this in an <code>error</code> variable to allow other classes to verify whether the request was successful:</li></ol><pre class="source-code">func download_spaceship(user, sprite_file):
     var players_spaceships = {}
     if FileAccess.file_exists(spaceships_database_file):
          var file = FileAccess.open(spaceships_database_file, FileAccess.READ)
          players_spaceships = JSON.parse_string(file.get_as_text())
     if user in players_spaceships:
          download_file = sprite_file
          var error = request(players_spaceships[user])</pre><ol><li class="upper-roman" value="6">Since HTTP requests may take some time to finish downloading the content requested, we need to wait for the <code>HTTPRequest.request_completed</code> signal before ending the function and returning the error. Note that if the function doesn’t reach any of these conditional statements, we should return <code>FAILED</code> to acknowledge to other classes that <code>spaceships_database_file</code> doesn’t <a id="_idIndexMarker509"/>exist or <code>user</code> doesn’t exist in the database:</li></ol><pre class="source-code">func download_spaceship(user, sprite_file):
     var players_spaceships = {}
     if FileAccess.file_exists(spaceships_database_file):
          var file = FileAccess.open(spaceships_database_file, FileAccess.READ)
          players_spaceships = JSON.parse_string(file.get_as_text())
     if user in players_spaceships:
          download_file = sprite_file
          var error = request(players_spaceships[user])
          await request_completed
          return error
     return FAILED</pre></li>			</ol>
			<p>Alright, this ends our journey to set up HTTPRequests. We created the database and the two nodes responsible for working on its data, downloading the database to the players’ machines, and downloading the content in the database as well, in this case, the players’ spaceships’ custom sprites. You can test the scene as well by calling the <code>download_spaceship()</code> method using <code>"user1"</code> and <code>"user://.cache/user1_spaceship.png"</code> as arguments. Just make sure that you’ve run the <code>SpaceshipDatabaseDownloadHTTPRequest</code> scene first so the <code>PlayersSpaceships.json</code> file exists in the <code>user://.cache/</code> folder. With that, you should see a new image downloaded right in your user data folder! The following screenshot shows what my <code>user://.cache/</code> folder looks like:</p>
			<div><div><img alt="Figure 13.5 – The ﻿user data folder with the Player﻿Spaceships.json file and user1’s custom spaceship sprite" src="img/Figure_13.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – The user data folder with the PlayerSpaceships.json file and user1’s custom spaceship sprite</p>
			<p>In this section, we <a id="_idIndexMarker510"/>learned about the usage of HTTP requests for caching data and downloading images in the user data folder. We saw the difference between UDP and HTTP when it comes to transferring large files such as images and how to use the <code>HTTPRequest</code> node to use the HTTP protocol in Godot and transfer data from the internet to our machine.</p>
			<p>In the upcoming section, we will discuss the implementation of texture caching in the game itself, allowing for real-time changes to the players’ spaceships. This feature will be achieved by using the <code>HTTPRequest</code> nodes we created and our minimal database to get the URLs of the players’ custom spaceship sprites.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor303"/>Implementing texture caching</h1>
			<p>In the <a id="_idIndexMarker511"/>previous section, we introduced the <code>HTTPRequest</code> node, a built-in solution offered by Godot Engine to make HTTP requests. Then we created <code>TextureDownloadHTTPRequest</code>, which is a custom node specialized in downloading images from our <code>PlayersSpaceship.json</code> database. Now, let’s dive deeper into integrating this node into our <code>Player2D</code> class so we can actually use it in our prototype.</p>
			<p>In this section, we will create a method to enable the server to change a player’s spaceship sprite dynamically. But we won’t just load any sprite; we’ll fetch the proper file from the <code>user://.cache/</code> folder we set up in the <em class="italic">Setting up the scenes and database </em>section. This approach will enhance the customization and interaction in your game, allowing the server to deliver custom sprites to players in real time.</p>
			<p>To achieve this, we’ll create a method called <code>load_spaceship()</code>. This method will play a fundamental role in our implementation. It will be an RPC function that the server can trigger remotely for specific players. Well, let’s get started! Open the <code>res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn</code> scene and work through the following steps:</p>
			<ol>
				<li>Let’s start by adding an instance of <code>TextureDownloadHTTPRequest</code> directly as a child of the <code>Player</code> node.</li>
			</ol>
			<div><div><img alt="Figure 13.6 – ﻿TextureDownloadHTTPRequest instantiated in the Player scene" src="img/Figure_13.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – TextureDownloadHTTPRequest instantiated in the Player scene</p>
			<ol>
				<li value="2">Then, open<a id="_idIndexMarker512"/> the <code>res://09.prototyping-space-adventure/Actors/Player/Player2D.gd</code> script.</li>
				<li>Let’s store a reference to the <code>TextureDownloadHTTPRequest</code> node. We can call it just <code>http_request</code> for short:<pre class="source-code">
@onready var http_request = $TextureDownloadHTTPRequest</pre></li>				<li>Then, right below the <code>setup_multiplayer()</code> method, let’s create the <code>load_spaceship()</code> method. It will be an RPC method that should only be remotely callable by the server and should also be called locally, so the server also updates the image. This method receives the user, which loads the spaceship:<pre class="source-code">
@rpc("authority", "call_local")
func load_spaceship(user):</pre></li>				<li>Now, inside this<a id="_idIndexMarker513"/> method, we are going to create the file path to the spaceship texture file in the player’s machine and store it in a variable called <code>spaceship_file</code>. This file path is composed of the <code>"user://.cache/"</code> string, followed by the <code>user</code> value we got as an argument, and we will append <code>"_spaceship.png"</code> to create the proper file path with an image extension:<pre class="source-code">
@rpc("authority", "call_local")
func load_spaceship(user):
     var spaceship_file = "user://.cache/" + user + "_spaceship.png"</pre></li>				<li>With a proper file path to work with, the next step is to see whether this file already exists because the whole idea of caching data is that, if it already exists in the player’s machine, we can load it instead of re-downloading it and reduce resource consumption. The following code checks whether the file exists. If it does, we call the <code>update_sprite()</code> method passing <code>spaceship_file</code> as an argument. We are going to create the <code>update_sprite()</code> method in a moment:<pre class="source-code">
@rpc("authority", "call_local")
func load_spaceship(user):
     var spaceship_file = "user://.cache/" + user + "_spaceship.png"
     if FileAccess.file_exists(spaceship_file):
          update_sprite(spaceship_file)</pre></li>				<li>Now, <code>TextureDownloadHTTPRequest</code> will play its role. If the file doesn’t exist in the cache folder, we call the <code>TextureDownloadHTTPRequest.download_texture()</code> method and wait for it to finish; remember, it’s an asynchronous method. And if this method returns an <code>OK</code> error, meaning there’s actually no error, we also call the <code>update_sprite()</code> method so the game performs the procedures to effectively update the spaceship’s sprite. The following code checks whether the <code>update_sprite()</code> method returns anything other than <code>OK</code>. If the <code>update_sprite()</code> method doesn’t return <code>OK</code>, it means no sprite will be loaded. Since the custom sprite doesn’t affect the player’s core experience, we can just assume we can keep the default sprite and let the game <a id="_idIndexMarker514"/>run:<pre class="source-code">
@rpc("authority", "call_local")
func load_spaceship(user):
     var spaceship_file = "user://.cache/" + user + "_spaceship.png"
     if FileAccess.file_exists(spaceship_file):
          update_sprite(spaceship_file)
     else:
          if await http_request.download_spaceship(user, spaceship_file) == OK:
               update_sprite(spaceship_file)</pre></li>				<li>Now let’s create the <code>update_sprite()</code> method. This is the method that effectively changes the <code>Sprite</code> node’s <code>Texture</code> property. It will load the image from the file path using the <code>Image.load_from_file()</code> method and turn it into an <code>ImageTexture</code> using the <code>ImageTexture.create_from_image()</code> method:<pre class="source-code">
func update_sprite(spaceship_file):
     var image = Image.load_from_file(spaceship_file)
     var texture = ImageTexture.create_from_image(image)
     $Spaceship/Sprite2D.texture = texture</pre></li>			</ol>
			<p>In this section, we saw<a id="_idIndexMarker515"/> how to use the <code>TextureDownloadHTTPRequest</code> node to download and cache the images from our database. We also saw how to dynamically change a player’s spaceship sprite using the cached images, loading them as image resources and turning them into an actual <code>ImageTexture</code> that the spaceship’s <code>Sprite2D</code> node can use.</p>
			<p>Now, the missing part of this process is…how we actually get the <code>PlayersSpaceship.json</code> database and where we call the <code>load_spaceship()</code> method. Well, that’s what we are going to do in the next section!</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor304"/>Implementing database caching</h1>
			<p>With everything in place, it is time to go<a id="_idIndexMarker516"/> one step above and work on the <code>World</code> scene that is going to glue everything together and run the proper procedures to ensure that all players will see the same custom sprites. We do that in this node because this is the class responsible for setting up everything related to world synchronization, which includes the players’ spaceship custom sprites. We will need to make some changes in some core methods to achieve that, but this is for the better.</p>
			<p>Since we are working with a prototype, there’s no fear of altering function signatures and other core aspects of a class. But note that if this was production-ready, we would call this class “closed” and avoid making core changes like the ones we are about to make. This would keep our game code base consistent and avoid errors. Though the changes we are about to make will mostly extend the class functionalities, we will add an argument to the <code>World.create_spaceship()</code> method, breaking the function’s contract since it didn’t ask for any arguments before. But, as said, this is a prototype, and we have the freedom to tweak things as we want. So, let’s open the <code>res://09.prototyping-space-adventure/Levels/World.tscn</code> scene and implement the improvements by working through the following steps:</p>
			<ol>
				<li>First things first, let’s add <a id="_idIndexMarker517"/>an instance of the <code>SpaceshipsDatabaseDownloadHTTPRequest</code> node as a direct child of the <code>World</code> node.</li>
			</ol>
			<div><div><img alt="Figure 13.7 – ﻿SpaceshipsDatabaseDownloadHTTPRequest instantiated in the World scene" src="img/Figure_13.07_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – SpaceshipsDatabaseDownloadHTTPRequest instantiated in the World scene</p>
			<ol>
				<li value="2">Then, let’s <a id="_idIndexMarker518"/>open the <code>res://09.prototyping-space-adventure/Levels/World.gd</code> script and start the code by adding a reference to the <code>SpaceshipsDatabaseDownloadHTTPRequest</code> node. We can simply call it <code>http_request</code> here as well:<pre class="source-code">
@onready var http_request = $SpaceshipsDatabaseDownloadHTTPRequest</pre></li>				<li>We will also create a new variable to store a <code>player_ids</code> and their <code>user</code>. This will allow us to look into this variable to find the proper username related to each player’s peer ID so we can easily map them in our database moving forward:<pre class="source-code">
var player_users = {}</pre></li>				<li>Now, in the <code>_ready()</code> callback, after waiting briefly for the <code>0.1</code> <code>SceneTree</code>’s timer to timeout, we will wait for <code>http_request</code> to download the spaceships database as well. Remember, this only happens if the instance running the game isn’t the server:<pre class="source-code">
func _ready():
     if not multiplayer.is_server():
          await(get_tree().create_timer(0.1).timeout)
          await http_request.downloa<a id="_idTextAnchor305"/>d_spaceships_database()</pre></li>				<li>Still in this <code>if</code> statement, we will make a small change. When making the RPC to the server’s <code>create_spaceship()</code> method, we will also pass the player’s user. For that, we will use the long-time-forgotten <code>AuthenticationCredentials</code> singleton!<pre class="source-code">
func _ready():
     if not multiplayer.is_server():
          await(get_tree().create_timer(0.1).timeout)
          await http_request.download_spaceships_database()
          rpc_id(1, "sync_world")
          rpc_id(1, "create_spaceship", AuthenticationCredentials.user)</pre></li>				<li>Moving on to the <code>create_spaceship()</code>method, we need to, of course, change its function signature to support the <code>user</code> argument:<pre class="source-code">
@rpc("any_peer", "call_remote")
func create_spaceship(user):</pre></li>				<li>Then, before<a id="_idIndexMarker519"/> adding the <code>spaceship</code> as a child of the <code>Players</code> node, we will use its name (which is essentially a string version of the player’s peer ID) as a key in the <code>player_users</code> dictionary and set this key’s value to the <code>user</code> argument. With that, we effectively paired the player’s ID with their username:<pre class="source-code">
@rpc("any_peer", "call_remote")
func create_spaceship(user):
     var player_id = multiplayer.get_remote_sender_id()
     var spaceship = preload("res://09.prototyping-space-adventure/Actors/Player/Play er2D.tscn").instantiate()
     spaceship.name = str(player_id)
     player_users[spaceship.name] = user</pre></li>				<li>After making the RPC to the newly instantiated player spaceship’s <code>setup_multiplayer()</code> method, we will make the magic happen by also making an RPC to the <code>load_spaceship()</code> method, triggering the procedures we made in the <em class="italic">Implementing texture caching</em> section. The updated version of the <code>create_spaceship()</code> method will look like this after these changes:<pre class="source-code">
@rpc("any_peer", "call_remote")
func create_spaceship(user):
     var player_id = multiplayer.get_remote_sender_id()
     var spaceship = preload("res://09.prototyping-space-adventure/Actors/Player/Play er2D.tscn").instantiate()
     spaceship.name = str(player_id)
     player_users[spaceship.name] = user
     $Players.add_child(spaceship)
     await(get_tree().create_timer(0.1).timeout)
     spaceship.rpc("setup_multiplayer", player_id)
     spaceship.rpc("load_spaceship", user)</pre></li>			</ol>
			<p>Great! With that, whenever<a id="_idIndexMarker520"/> a player jumps into the game, their spaceship will change its sprite to the custom sprite the player uploaded, if any. Now, we need to also make this happen to the spaceships that were already in the game world when the player joined. For that, we need to make some changes in the <code>_on_players_multiplayer_spawner_spawned()</code> callback. Still in the <code>res://09.prototyping- space-adventure/Levels/World.gd</code> script, let’s implement the changes by moving on to the <code>_on_players_multiplayer_spawner_spawned()</code> method and go through the following steps:</p>
			<ol>
				<li>Let’s revamp the whole logic of this callback and make it from scratch. We are going to start by creating a variable to store the player’s peer ID, which we can get by turning the recently spawned node’s name into an integer. Node names are <code>StringNames</code> so they are not pure strings, meaning we need to turn them into default strings before turning them into integers:<pre class="source-code">
func _on_players_multiplayer_spawner_spawned(node):
     var player_id = int(str(node.name))</pre></li>				<li>After that, we will make the global RPC to the <code>setup_multiplayer()</code> method, just as we did before, but now we pass <code>player_id</code> as the argument:<pre class="source-code">
func _on_players_multiplayer_spawner_spawned(node):
     var player_id = int(str(node.name))
     node.rpc("setup_multiplayer", player_id)</pre></li>				<li>Then comes the interesting part. After making this RPC, if the spawned node, in other words the spawned player, happens to be in another player’s game instance, instead of the server’s instance, we will also make an RPC directly to the server, asking it to sync this spaceship using a method (which we are going to create soon) called <code>sync_spaceship()</code>, which receives a player ID as its argument:<pre class="source-code">
func _on_players_multiplayer_spawner_spawned(node):
     var player_id = int(str(node.name))
     node.rpc("setup_multiplayer", player_id)
     if not multiplayer.is_server():
          rpc_id(1, "sync_spaceship", player_id)</pre></li>				<li>Let’s move on <a id="_idIndexMarker521"/>to the <code>sync_spaceship()</code> method now. Let’s create this method with an RPC annotation that will allow any peer to remotely call it and it will also be called locally on the server. Remember, this method receives <code>player_id</code> as its argument:<pre class="source-code">
@rpc("any_peer", "call_local")
func sync_spaceship(player_id):</pre></li>				<li>Inside the <code>sync_spaceship()</code> method, we will first and foremost store a reference to the ID of whoever made the RPC to this function. This will allow us to make the <code>rpc_id()</code> method call directly to the player that just joined the game, instead of making a call to every player every time a player joins the game:<pre class="source-code">
@rpc("any_peer", "call_local")
func sync_spaceship(player_id):
     var requester = multiplayer.get_remote_sender_id()</pre></li>				<li>Then, we will find the correct player in the <code>Players</code> node children by using the <code>get_node()</code> method and appending the <code>player_id</code>. Remember, since the <code>player_id</code> is also the node’s name, this is how we can easily find it among all the <code>Players</code> children:<pre class="source-code">
@rpc("any_peer", "call_local")
func sync_spaceship(player_id):
     var requester = multiplayer.get_remote_sender_id()
     var node = get_node("Players/%s" % player_id)</pre></li>				<li>After that, we <a id="_idIndexMarker522"/>will find the player’s username. For that, we will use <code>player_id</code> as a key in <code>player_users</code>, which will return us the proper username:<pre class="source-code">
@rpc("any_peer", "call_local")
func sync_spaceship(player_id):
     var requester = multiplayer.get_remote_sender_id()
     var node = get_node("Players/%s" % player_id)
     var user = player_users[node.name]</pre></li>				<li>Finally, with the user in our hands, we can make an RPC to the <code>load_spaceship()</code> method on this requester's instance of the <code>node</code> that represents the spaceship spawned on their instance of the game:<pre class="source-code">
@rpc("any_peer", "call_local")
func sync_spaceship(player_id):
     var requester = multiplayer.get_remote_sender_id()
     var node = get_node("Players/%s" % player_id)
     var user = player_users[node.name]
     node.rpc_id(requester, "load_spaceship", user)</pre></li>			</ol>
			<p>And we did it! With this in place, the<a id="_idIndexMarker523"/> game is now able to load, store, and sync players’ custom spaceship sprites. If you run the game now you can see the game caching data to decrease bandwidth and downloading and updating the players’ spaceship sprites in real time. The following screenshot displays the before and after of implementing this feature.</p>
			<div><div><img alt="Figure 13.8 – The before and after implementing the custom sprites feature" src="img/Figure_13.08_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – The before and after implementing the custom sprites feature</p>
			<p>Something interesting that<a id="_idIndexMarker524"/> you can check if you want to measure how much difference caching makes is to remove the statements that check whether the files exist in the <code>user://.cache/</code> folder and add a Monitor to monitor the <code>TextureDownloadHTTPRequest</code> and <code>SpaceshipsDatabaseDownloadHTTPRequest</code> downloaded bytes. For that, you can use the <code>HTTPRequest.get_downloaded_bytes()</code> method. For instance, the following code snippet displays how we can create a Monitor in the <code>TextureDownloadHTTPRequest</code> node:</p>
			<pre class="source-code">
func _ready():
     var callable = Callable(self, "get_texture_downloaded_bytes")
     Performance.add_custom_monitor("Network/Texture Download Bytes", callable)
func get_texture_downloaded_bytes():
     return get_downloaded_bytes()</pre>			<p>And with that, we can test our <a id="_idIndexMarker525"/>game multiple times to simulate players logging in and out of the game and see how the caching impacts each stage. Something you will notice is that after the images have been cached, they are almost instantaneously updated when players log in to the game again. The following screenshot displays the actual impact on the network usage in bytes before and after caching the images in the player’s machine:</p>
			<div><div><img alt="Figure 13.9 – A comparison between the network consumption the first time the player downloads the textures and after caching the textures in their machine" src="img/Figure_13.09_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – A comparison between the network consumption the first time the player downloads the textures and after caching the textures in their machine</p>
			<p>In this section, we saw how to<a id="_idIndexMarker526"/> implement database caching for custom spaceship sprites in our game. The <code>World</code> scene is responsible for synchronizing the game world, including the players’ spaceship sprites. So, we made some changes to it to achieve the caching we’ve implemented in previous sections. We saw how to use the <code>SpaceshipsDatabaseDownloadHTTPRequest</code> node to download the spaceships database and make RPCs to update players’ spaceship sprites and sync spaceship sprites when players join the game. At the end of the section, we used a Monitor and the <code>HTTPRequest.get_downloaded_bytes()</code> method to see how caching reduces bandwidth usage and <a id="_idIndexMarker527"/>improves network efficiency.</p>
			<p>Note the number of bytes saved in <em class="italic">Figure 13</em><em class="italic">.9</em> with only two textures cached! Imagine, in the long run, how this could impact hundreds and even thousands of players as they log in and out of the game multiple times a day. And we are only talking about textures here. What else can we cache and effectively save hundreds of thousands of network bytes on? Well, that’s what we are going to see in the upcoming section.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor306"/>Going further with caching</h1>
			<p>Well, as we saw, images are not the only type of data we can download through the internet using the <code>HTTPRequest</code> node; for instance, we also downloaded the <code>PlayersSpaceship.json</code> file, which is a text file. But we can download pretty much anything using this protocol, provided it is stored in an HTTP page. But sometimes, some files are not stored and made available publicly on an HTTP page that any browser can access. Usually in this type of situation, the backend engineer will create a REST API that we can use to retrieve these files directly from the database where they are stored.</p>
			<p>This type of feature demands a physical infrastructure and the development of a custom REST API so we can work with it. Unfortunately, this goes way beyond the scope of this book. But the whole idea is that you can perform an HTTP request using custom headers and a custom URL that resembles an RPC. So, in the very URL itself you would add some parameters that the REST API would interpret as a method call and arguments. It’s very similar to what we did in <a href="B18527_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a><em class="italic">,</em> <em class="italic">Sending and Receiving Data</em>, and REST APIs usually use JSON-formatted strings as the main data structure as well.</p>
			<p>For instance, you can check out a series on my YouTube channel that relies heavily on REST APIs to integrate a third-party service into a game of mine called <em class="italic">Moon Cheeser</em>. The REST API is provided by <em class="italic">LootLocker</em> and at some point, I download a whole <code>PacketScene</code> from their server to cache it in the player’s machine and allow them to always have a copy of their purchased skin. You can check this particular video at the following link:</p>
			<p><a href="https://youtu.be/w0qz-pJMIBo?si=WF2KH9-FRyO8glVq">https://youtu.be/w0qz-pJMIBo?si=WF2KH9-FRyO8glVq</a></p>
			<p>Well, I’m going to use LootLocker’s public API as an example here too. This is the HTTP request I used to retrieve the file associated with the skin the player purchases:</p>
			<pre class="source-code">
curl -X GET "https://api.lootlocker.io/game/v1/assets/list?count=10&amp;filter=purchasabl e" \-H "x-session-token: your_token_here"</pre>			<p>This translates into the following <code>GDScript</code> code, using an <code>HTTPRequest</code> node:</p>
			<pre class="source-code">
var url = "https://api.lootlocker.io/game/v1/assets/list?count=10&amp;filter=purchasable"
var header = ["Content-Type: application/json", "x-session-token: %s" % LootLocker.tok
en]
request(url, header)</pre>			<p>Now comes the interesting part that we haven’t explored yet. The <code>HTTPRequest.request_completed</code> signal is emitted when this request is completed and the server gives a response to the client with some very interesting data, including the response’s body, which usually is a JSON file containing the URL to the file we want. So, you can connect this signal to a signal callback and access the response’s body to get access to what the server provides you with regarding the request. This can go from the content of a file itself to a JSON file containing much more information, including the URL to download the file you want.</p>
			<p>To avoid going off on a tangent here, I highly recommend you watch the video and understand how we download a resource-intensive file. In this case, I downloaded a custom <code>PackedScene</code> instance together with its dependencies, such as an image necessary to make the purchased skin display properly, and cached it into players’ devices.</p>
			<p>With this in your hands, you can implement all sorts of caching and save tons of resource usage, both for your players and your server, since it won’t be constantly delivering the same files to the same clients repeatedly.</p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor307"/>Summary</h1>
			<p>Well, it’s time to wrap this chapter up! In this chapter, we discussed what caching is and how it allows us to save bandwidth. We learned how to implement it for custom spaceship sprites in our game. For that, we saw how we can use the <code>HTTPRequest</code> node to download files over the internet by making HTTP requests. We also implemented a custom Monitor to see how much data we saved throughout a play session by caching textures. Finally, we saw how caching can go beyond image and text files and the possibility of using REST APIs to download all sorts of files using HTTP.</p>
			<p>With that, my fellow Godot Engine developers, we reach the end of our journey!</p>
			<p>We started as people who didn’t know how to send a simple message to another computer, and became fully fledged network engineers ready to create the games of our dreams and allow players to have a shared experience, enjoy their time together, and build communities around the world. Congratulations on completing this journey. You are now capable of one of the most amazing things any human being can do: to connect people together toward a shared goal.</p>
			<p>This is my farewell. I’m very proud of what we went through, and I hope you use this power for good. You can definitely expect more from me to come. But for now, that’s it.</p>
			<p class="author-quote">Thank you so much for reading. Keep developing, and until the next time!</p>
		</div>
	</body></html>