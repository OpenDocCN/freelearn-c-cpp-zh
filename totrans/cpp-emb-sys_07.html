<html><head></head><body>
<div id="_idContainer048">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 class="chapterTitle" id="_idParaDest-73"><span class="koboSpan" id="kobo.2.1">Classes – Building Blocks of C++ Applications</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.3.1">Classes</span></strong><span class="koboSpan" id="kobo.4.1"> in C++ are means</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.5.1"> of organizing code into logical units. </span><span class="koboSpan" id="kobo.5.2">They allow us to structure data and functions that perform operations on that data in blueprints. </span><span class="koboSpan" id="kobo.5.3">These blueprints can be used to build instances of the classes, known as </span><strong class="keyWord"><span class="koboSpan" id="kobo.6.1">objects</span></strong><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">We can initialize objects with data, manipulate them by calling </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.8.1">functions or methods on them, store them in containers, or pass their references to objects of other classes to make the interaction between different parts of a system.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">Classes are the basic building blocks of C++ applications. </span><span class="koboSpan" id="kobo.9.2">They help us organize code in units with isolated responsibility reflecting dependencies and interactions with other parts of the system. </span><span class="koboSpan" id="kobo.9.3">They can be combined or extended, allowing us to reuse their functionality and add additional capabilities. </span><span class="koboSpan" id="kobo.9.4">We use them to make abstractions of different parts of an embedded system, including low-level components such as </span><strong class="keyWord"><span class="koboSpan" id="kobo.10.1">Universal Asynchronous Receiver/Transmitter</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.12.1">UART</span></strong><span class="koboSpan" id="kobo.13.1">) drivers </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.14.1">and libraries or business logic components such as a cellular modem library.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.15.1">The goal of this chapter is to delve into C++ classes and learn how we can use them to write better code. </span><span class="koboSpan" id="kobo.15.2">In this chapter, we’re going to cover the following main topics: </span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.16.1">Encapsulation</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.17.1">Storage duration and initialization</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.18.1">Inheritance and dynamic polymorphism</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-74"><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.20.1">To get the most out of this chapter, I strongly recommend using Compiler Explorer (</span><a href="https://godbolt.org/"><span class="url"><span class="koboSpan" id="kobo.21.1">https://godbolt.org/</span></span></a><span class="koboSpan" id="kobo.22.1">) as you read through the examples. </span><span class="koboSpan" id="kobo.22.2">Select GCC as your compiler and target x86 architecture. </span><span class="koboSpan" id="kobo.22.3">This will allow you to see standard output (stdio) results and better observe the code’s behavior. </span><span class="koboSpan" id="kobo.22.4">As we are using a lot of modern C++ features make sure to select C++23 standard, by adding </span><code class="inlineCode"><span class="koboSpan" id="kobo.23.1">-std=c++23</span></code><span class="koboSpan" id="kobo.24.1"> in compiler options box.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.25.1">The examples from this chapter are available on GitHub (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter05)"><span class="url"><span class="koboSpan" id="kobo.26.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter05)</span></span></a><span class="koboSpan" id="kobo.27.1">.</span></p>
<h1 class="heading-1" id="_idParaDest-75"><span class="koboSpan" id="kobo.28.1">Encapsulation</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.29.1">Encapsulation</span></strong><span class="koboSpan" id="kobo.30.1"> is a programming</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.31.1"> concept that organizes code into units that contain both data and functions that operate on that data. </span><span class="koboSpan" id="kobo.31.2">It is not strictly related to </span><strong class="keyWord"><span class="koboSpan" id="kobo.32.1">Object-Oriented Programming</span></strong><span class="koboSpan" id="kobo.33.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.34.1">OOP</span></strong><span class="koboSpan" id="kobo.35.1">) and is </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.36.1">often used in other programming paradigms. </span><span class="koboSpan" id="kobo.36.2">Encapsulation allows us to decouple code into units with single responsibilities, making the code easier to reason about, improving readability, and facilitating maintenance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.37.1">In terms of OOP, encapsulation can also refer to hiding an object’s members or restricting access to these members from the outside. </span><span class="koboSpan" id="kobo.37.2">In C++, this can be achieved using access specifiers. </span><span class="koboSpan" id="kobo.37.3">C++ has the following specifiers:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.38.1">Public</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.39.1">Private</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.40.1">Protected</span></li>
</ul>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.41.1">Public</span></strong><span class="koboSpan" id="kobo.42.1"> and </span><strong class="keyWord"><span class="koboSpan" id="kobo.43.1">private</span></strong><span class="koboSpan" id="kobo.44.1"> are the most</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.45.1"> commonly used specifiers. </span><span class="koboSpan" id="kobo.45.2">They give us the ability to </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.46.1">control the interface of the class, that is, to control which class members are available to the users of a class. </span><span class="koboSpan" id="kobo.46.2">The following example demonstrates how to define a class with public and private access sections, demonstrating the concept of encapsulation:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.47.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.48.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.49.1">&lt;cstdint&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.50.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.51.1">uart</span></span><span class="koboSpan" id="kobo.52.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.53.1">public</span></span><span class="koboSpan" id="kobo.54.1">:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.55.1">uart</span></span><span class="koboSpan" id="kobo.56.1">(std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.57.1">uint32_t</span></span><span class="koboSpan" id="kobo.58.1"> baud = </span><span class="hljs-number"><span class="koboSpan" id="kobo.59.1">9600</span></span><span class="koboSpan" id="kobo.60.1">): </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.61.1">baudrate_</span></span><span class="koboSpan" id="kobo.62.1">(baud) {}
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.63.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.64.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.65.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.66.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.67.1">write_brr</span></span><span class="koboSpan" id="kobo.68.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.69.1">calculate_uartdiv</span></span><span class="koboSpan" id="kobo.70.1">());
    }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.71.1">private</span></span><span class="koboSpan" id="kobo.72.1">:
    std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.73.1">uint32_t</span></span><span class="koboSpan" id="kobo.74.1"> baudrate_;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.75.1">std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.76.1">uint8_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.77.1">calculate_uartdiv</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.78.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.79.1">{
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.80.1">return</span></span><span class="koboSpan" id="kobo.81.1"> baudrate_ / </span><span class="hljs-number"><span class="koboSpan" id="kobo.82.1">32000</span></span><span class="koboSpan" id="kobo.83.1">;
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.84.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.85.1">write_brr</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.86.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.87.1">uint8_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.88.1">)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.89.1">{}
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.90.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.91.1">main</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.92.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.93.1">{
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.94.1">uart </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.95.1">uart1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.96.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.97.1">115200</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.98.1">)</span></span><span class="koboSpan" id="kobo.99.1">;
    uart</span><span class="hljs-number"><span class="koboSpan" id="kobo.100.1">1.</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.101.1">init</span></span><span class="koboSpan" id="kobo.102.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.103.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.104.1">0</span></span><span class="koboSpan" id="kobo.105.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.106.1">In this example, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.107.1">uart</span></code><span class="koboSpan" id="kobo.108.1"> class has</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.109.1"> public and private access sections. </span><span class="koboSpan" id="kobo.109.2">Let’s go through the code step by step:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.110.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.111.1">public</span></code><span class="koboSpan" id="kobo.112.1"> section includes a constructor that initializes the </span><code class="inlineCode"><span class="koboSpan" id="kobo.113.1">baudrate_</span></code><span class="koboSpan" id="kobo.114.1"> private member variable</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.115.1">We also have an </span><code class="inlineCode"><span class="koboSpan" id="kobo.116.1">init</span></code><span class="koboSpan" id="kobo.117.1"> method in the public section, in which we write a value to a </span><strong class="keyWord"><span class="koboSpan" id="kobo.118.1">Bit Rate Register</span></strong><span class="koboSpan" id="kobo.119.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.120.1">BRR</span></strong><span class="koboSpan" id="kobo.121.1">), which</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.122.1"> is specific to the STM32 platform, using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.123.1">write_brr</span></code><span class="koboSpan" id="kobo.124.1"> private method</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.125.1">The value written to the BRR register is calculated in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.126.1">calculate_uartdiv</span></code><span class="koboSpan" id="kobo.127.1"> private method</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.128.1">As we can see, methods with a public access specifier within the </span><code class="inlineCode"><span class="koboSpan" id="kobo.129.1">uart</span></code><span class="koboSpan" id="kobo.130.1"> class can use private member variables and methods. </span><span class="koboSpan" id="kobo.130.2">However, if we tried to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.131.1">write_brr</span></code><span class="koboSpan" id="kobo.132.1"> on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.133.1">uart1</span></code><span class="koboSpan" id="kobo.134.1"> object, as in </span><code class="inlineCode"><span class="koboSpan" id="kobo.135.1">uart1.write_brr(5)</span></code><span class="koboSpan" id="kobo.136.1">, the compilation of the program would fail.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.137.1">The private access specifier allows us to hide methods and data from the user of our class (in this case, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.138.1">main</span></code><span class="koboSpan" id="kobo.139.1"> function). </span><span class="koboSpan" id="kobo.139.2">This helps us define a clear interface for our classes in C++. </span><span class="koboSpan" id="kobo.139.3">By controlling which methods a user of the class can use, we are not only protecting the class but also the user from unwanted behavior.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.140.1">This example serves the purpose of explaining access specifiers in C++, but let’s also use it to explain the </span><code class="inlineCode"><span class="koboSpan" id="kobo.141.1">init</span></code><span class="koboSpan" id="kobo.142.1"> method. </span><span class="koboSpan" id="kobo.142.2">Why do we need it if we have a constructor?</span></p>
<p class="normal"><span class="koboSpan" id="kobo.143.1">The purpose of </span><code class="inlineCode"><span class="koboSpan" id="kobo.144.1">init</span></code><span class="koboSpan" id="kobo.145.1"> is to allow us to fully control the initialization of hardware. </span><span class="koboSpan" id="kobo.145.2">The object may also be constructed as a global or static variable. </span><span class="koboSpan" id="kobo.145.3">The initialization of static and global objects is done before reaching the </span><code class="inlineCode"><span class="koboSpan" id="kobo.146.1">main</span></code><span class="koboSpan" id="kobo.147.1"> function and initializing hardware. </span><span class="koboSpan" id="kobo.147.2">That is why some kind of </span><code class="inlineCode"><span class="koboSpan" id="kobo.148.1">init</span></code><span class="koboSpan" id="kobo.149.1"> method is common in classes in embedded projects. </span><span class="koboSpan" id="kobo.149.2">Using it, we can ensure that all hardware</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.150.1"> peripherals are initialized in the correct order.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.151.1">The default access specifier for classes in C++ is private, so we could write the definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.152.1">uart</span></code><span class="koboSpan" id="kobo.153.1"> class from the previous example as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.154.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.155.1">uart</span></span><span class="koboSpan" id="kobo.156.1"> {
    std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.157.1">uint32_t</span></span><span class="koboSpan" id="kobo.158.1"> baudrate_;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.159.1">std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.160.1">uint8_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.161.1">calculate_uartdiv</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.162.1">()</span></span><span class="koboSpan" id="kobo.163.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.164.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.165.1">write_brr</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.166.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.167.1">uint8_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.168.1">)</span></span><span class="koboSpan" id="kobo.169.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.170.1">public</span></span><span class="koboSpan" id="kobo.171.1">:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.172.1">uart</span></span><span class="koboSpan" id="kobo.173.1">(std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.174.1">uint32_t</span></span><span class="koboSpan" id="kobo.175.1"> baud = </span><span class="hljs-number"><span class="koboSpan" id="kobo.176.1">9600</span></span><span class="koboSpan" id="kobo.177.1">);
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.178.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.179.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.180.1">()</span></span><span class="koboSpan" id="kobo.181.1">;
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.182.1">We chose to explicitly define the private access section. </span><span class="koboSpan" id="kobo.182.2">We put it after the </span><code class="inlineCode"><span class="koboSpan" id="kobo.183.1">public</span></code><span class="koboSpan" id="kobo.184.1"> section, as publicly accessible members are the interface for our class, and when you read code and a class definition, the first thing you want to see is the interface. </span><span class="koboSpan" id="kobo.184.2">You want to see how to interact with the class and which methods are part of the public interface that you can use.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.185.1">The only data member we have in this example is </span><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">baudrate_</span></code><span class="koboSpan" id="kobo.187.1">. </span><span class="koboSpan" id="kobo.187.2">It is private, and the only option for a user of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.188.1">uart</span></code><span class="koboSpan" id="kobo.189.1"> class to set it up is through the constructor. </span><span class="koboSpan" id="kobo.189.2">It is a common practice for data members that we want</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.190.1"> to expose to the public to define setter and getter methods.</span></p>
<h2 class="heading-2" id="_idParaDest-76"><span class="koboSpan" id="kobo.191.1">Setters and getters</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.192.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.193.1">uart</span></code><span class="koboSpan" id="kobo.194.1"> class, we </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.195.1">could define setters and getters for </span><code class="inlineCode"><span class="koboSpan" id="kobo.196.1">baudrate_</span></code><span class="koboSpan" id="kobo.197.1"> members</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.198.1"> as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-function"><span class="koboSpan" id="kobo.199.1">std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.200.1">uint32_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.201.1">get_baudrate</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.202.1">()</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.203.1">const</span></span><span class="koboSpan" id="kobo.204.1">{
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.205.1">return</span></span><span class="koboSpan" id="kobo.206.1"> baudrate_;
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.207.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.208.1">set_baudrate</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.209.1">(baudrate)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.210.1">{
        baudrate_ = baudrate;
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.211.1">Now, this would allow us to set and get the </span><code class="inlineCode"><span class="koboSpan" id="kobo.212.1">baudrate</span></code><span class="koboSpan" id="kobo.213.1"> value from the public interface, but these trivial setters and getters do not add any value to our interface. </span><span class="koboSpan" id="kobo.213.2">They are just exposing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.214.1">baudrate_</span></code><span class="koboSpan" id="kobo.215.1"> member. </span><span class="koboSpan" id="kobo.215.2">It would be the same as if we put it under the public access specifier. </span><span class="koboSpan" id="kobo.215.3">Setters and getters should serve a clear purpose. </span><span class="koboSpan" id="kobo.215.4">For example, a setter can include validation logic, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-type"><span class="koboSpan" id="kobo.216.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.217.1">set_baudrate</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.218.1">(baudrate)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.219.1">{
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.220.1">if</span></span><span class="koboSpan" id="kobo.221.1"> (baudrate &lt;= c_max_baudrate) {
            baudrate_ = baudrate;
        } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.222.1">else</span></span><span class="koboSpan" id="kobo.223.1"> {
            baudrate = c_max_baudrate;
        }
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.224.1">In the modified setter, we are making a sanity check of the value to be set and setting the private member only if it makes sense to do so, else setting it to the maximum baudrate (</span><code class="inlineCode"><span class="koboSpan" id="kobo.225.1">c_max_baudrate</span></code><span class="koboSpan" id="kobo.226.1">) supported in our system. </span><span class="koboSpan" id="kobo.226.2">This is just an example; it probably doesn’t make sense to change the baudrate after the UART initialization.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.227.1">Exposing data members through setters and getters in some sense breaks encapsulation. </span><span class="koboSpan" id="kobo.227.2">The idea of encapsulation is to hide the implementation details, and data members are implementation details. </span><span class="koboSpan" id="kobo.227.3">Therefore, setters and especially getters should be used sparingly and only when they serve a meaningful purpose.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.228.1">We can use classes in C++ to encapsulate only functionality, without data, or data that is commonly </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.229.1">shared </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.230.1">with all users of a class. </span><span class="koboSpan" id="kobo.230.2">For that, we can use static methods.</span></p>
<h2 class="heading-2" id="_idParaDest-77"><span class="koboSpan" id="kobo.231.1">Static methods</span></h2>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.232.1">Static methods</span></strong><span class="koboSpan" id="kobo.233.1"> are C++ methods </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.234.1">declared with static keywords, and they</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.235.1"> are accessible without object instantiation. </span><span class="koboSpan" id="kobo.235.2">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.236.1">uart</span></code><span class="koboSpan" id="kobo.237.1"> class example, besides the constructor, we have the </span><code class="inlineCode"><span class="koboSpan" id="kobo.238.1">init</span></code><span class="koboSpan" id="kobo.239.1"> method, which is part of the public interface. </span><span class="koboSpan" id="kobo.239.2">We use it by calling this method on an object we previously created using a single argument constructor by providing it with the baudrate. </span><span class="koboSpan" id="kobo.239.3">We could also design the </span><code class="inlineCode"><span class="koboSpan" id="kobo.240.1">uart</span></code><span class="koboSpan" id="kobo.241.1"> class as a type that has all static methods and use it as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.242.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.243.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.244.1">&lt;cstdint&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.245.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.246.1">uart</span></span><span class="koboSpan" id="kobo.247.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.248.1">public</span></span><span class="koboSpan" id="kobo.249.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.250.1">static</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.251.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.252.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.253.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.254.1">uint32_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.255.1"> baudrate)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.256.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.257.1">write_brr</span></span><span class="koboSpan" id="kobo.258.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.259.1">calculate_uartdiv</span></span><span class="koboSpan" id="kobo.260.1">(baudrate));
    }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.261.1">private</span></span><span class="koboSpan" id="kobo.262.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.263.1">static</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.264.1"> std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.265.1">uint8_t</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.266.1">calculate_uartdiv</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.267.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.268.1">uint32_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.269.1"> baudrate)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.270.1">{
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.271.1">return</span></span><span class="koboSpan" id="kobo.272.1"> baudrate / </span><span class="hljs-number"><span class="koboSpan" id="kobo.273.1">32000</span></span><span class="koboSpan" id="kobo.274.1">;
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.275.1">static</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.276.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.277.1">write_brr</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.278.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.279.1">uint8_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.280.1">)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.281.1">{}
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.282.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.283.1">main</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.284.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.285.1">{
    uart::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.286.1">init</span></span><span class="koboSpan" id="kobo.287.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.288.1">115200</span></span><span class="koboSpan" id="kobo.289.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.290.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.291.1">0</span></span><span class="koboSpan" id="kobo.292.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.293.1">As you can see, we removed the single argument constructor and declared all methods as static. </span><span class="koboSpan" id="kobo.293.2">We also removed the </span><code class="inlineCode"><span class="koboSpan" id="kobo.294.1">baudrate_</span></code><span class="koboSpan" id="kobo.295.1"> private data member and passed it directly from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.296.1">init</span></code><span class="koboSpan" id="kobo.297.1"> method to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.298.1">calculate_uartdiv</span></code><span class="koboSpan" id="kobo.299.1"> method. </span><span class="koboSpan" id="kobo.299.2">We now have a type that we can use without object instantiation. </span><span class="koboSpan" id="kobo.299.3">We call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">init</span></code><span class="koboSpan" id="kobo.301.1"> method by using the class name followed by a double colon and the method name, as shown in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.302.1">main</span></code><span class="koboSpan" id="kobo.303.1"> function. </span><span class="koboSpan" id="kobo.303.2">It is worth noting that static methods can only use static data members and other static functions from a class as non-static members require the instantiation of an object.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.304.1">We can group functions in C++ in a common </span><em class="italic"><span class="koboSpan" id="kobo.305.1">unit</span></em><span class="koboSpan" id="kobo.306.1"> by using namespaces. </span><span class="koboSpan" id="kobo.306.2">However, grouping them into a type is useful as we can pass types as template arguments. </span><span class="koboSpan" id="kobo.306.3">We will discuss namespaces and templates later in this book to better understand the benefits of this approach. </span><span class="koboSpan" id="kobo.306.4">Namespaces will be discussed in </span><a href="Chapter_06.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.307.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.308.1"> and templates in </span><a href="Chapter_08.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.309.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.310.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.311.1">In C++, we can also use the struct keyword to define a type. </span><span class="koboSpan" id="kobo.311.2">The default access for struct members is public. </span><span class="koboSpan" id="kobo.311.3">Historically, structs were used for compatibility with C, so one could write a header file for a </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.312.1">library that is used in both C and C++ programs. </span><span class="koboSpan" id="kobo.312.2">In this</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.313.1"> case, the struct we would share between C and C++ programs could only have common data types and couldn’t have methods as members.</span></p>
<h2 class="heading-2" id="_idParaDest-78"><span class="koboSpan" id="kobo.314.1">Structs</span></h2>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.315.1">Structs</span></strong><span class="koboSpan" id="kobo.316.1"> are commonly </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.317.1">used in C++ for types that only have data members that</span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.318.1"> we want to make publicly available to users. </span><span class="koboSpan" id="kobo.318.2">They are mostly identical to classes, with a difference being in the default access level, which is public for structs. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.319.1">Here is an example of a struct that only has data members:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.320.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.321.1">accelerometer_data</span></span><span class="koboSpan" id="kobo.322.1"> {
    std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.323.1">uint32_t</span></span><span class="koboSpan" id="kobo.324.1"> x;
    std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.325.1">uint32_t</span></span><span class="koboSpan" id="kobo.326.1"> y;
    std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.327.1">uint32_t</span></span><span class="koboSpan" id="kobo.328.1"> z;
};
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.329.1">accelerometer_data</span></code><span class="koboSpan" id="kobo.330.1"> could be produced by a </span><code class="inlineCode"><span class="koboSpan" id="kobo.331.1">sensor</span></code><span class="koboSpan" id="kobo.332.1"> class, stored in a </span><code class="inlineCode"><span class="koboSpan" id="kobo.333.1">ring_buffer</span></code><span class="koboSpan" id="kobo.334.1"> class, and consumed by a </span><code class="inlineCode"><span class="koboSpan" id="kobo.335.1">sensor_fusion</span></code><span class="koboSpan" id="kobo.336.1"> class. </span><span class="koboSpan" id="kobo.336.2">The members of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.337.1">accelerometer_data</span></code><span class="koboSpan" id="kobo.338.1"> class are values from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.339.1">x</span></code><span class="koboSpan" id="kobo.340.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.341.1">y</span></code><span class="koboSpan" id="kobo.342.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.343.1">z</span></code><span class="koboSpan" id="kobo.344.1"> axes, and they are publicly available to users of this class.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.345.1">In this case, we use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.346.1">accelerometer_data</span></code><span class="koboSpan" id="kobo.347.1"> struct only as a data holder, and we implement the behavior related to this data in other places. </span><span class="koboSpan" id="kobo.347.2">This is just an example. </span><span class="koboSpan" id="kobo.347.3">Structuring data in simple structs versus using classes with data and complex behavior is a design choice and it depends on the exact application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.348.1">Structs are also used to group functions into types. </span><span class="koboSpan" id="kobo.348.2">They are usually all declared as static and made publicly available to users. </span><span class="koboSpan" id="kobo.348.3">Using a struct instead of a class is convenient in this use case as the default access specifier is public and it also reflects our intent as a struct is usually used when all members are made public.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.349.1">Besides the public and private access specifiers, there is also</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.350.1"> the </span><strong class="keyWord"><span class="koboSpan" id="kobo.351.1">protected specifier</span></strong><span class="koboSpan" id="kobo.352.1"> in C++. </span><span class="koboSpan" id="kobo.352.2">The protected specifier is related to inheritance and will be explained later in this chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.353.1">Let us now move on to constructors and the initialization of variables and objects in C++. </span><span class="koboSpan" id="kobo.353.2">Object initialization is</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.354.1"> an important task and failing to do it properly can cause </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.355.1">problems in programs. </span><span class="koboSpan" id="kobo.355.2">We will discuss different options for object initialization and analyze potential pitfalls and how to avoid them.</span></p>
<h1 class="heading-1" id="_idParaDest-79"><span class="koboSpan" id="kobo.356.1">Storage duration and initialization</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.357.1">C++ objects with </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.358.1">automatic storage duration are initialized upon declaration and destroyed when exiting the variable scope. </span><span class="koboSpan" id="kobo.358.2">Objects can also have a static storage duration. </span><span class="koboSpan" id="kobo.358.3">Data members of objects can also have static storage specifiers, and there are rules for the initialization of such members. </span><span class="koboSpan" id="kobo.358.4">We will first go through non-static member initialization.</span></p>
<h2 class="heading-2" id="_idParaDest-80"><span class="koboSpan" id="kobo.359.1">Non-static member initialization</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.360.1">There are different </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.361.1">ways to initialize non-static class </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.362.1">members. </span><span class="koboSpan" id="kobo.362.2">The first thing that comes to mind when we discuss initialization and C++ is constructors. </span><span class="koboSpan" id="kobo.362.3">While constructors are powerful C++ features that allow us to have great control over the initialization, let us start with </span><strong class="keyWord"><span class="koboSpan" id="kobo.363.1">default member initializers</span></strong><span class="koboSpan" id="kobo.364.1">.</span></p>
<h3 class="heading-3" id="_idParaDest-81"><span class="koboSpan" id="kobo.365.1">Default member initializers</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.366.1">As of C++11, it is possible</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.367.1"> to set a</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.368.1"> default value for a member directly in a class definition, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.369.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.370.1">my_class</span></span><span class="koboSpan" id="kobo.371.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.372.1">int</span></span><span class="koboSpan" id="kobo.373.1"> a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.374.1">4</span></span><span class="koboSpan" id="kobo.375.1">;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.376.1">int</span></span><span class="koboSpan" id="kobo.377.1"> *ptr = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.378.1">nullptr</span></span><span class="koboSpan" id="kobo.379.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.380.1">This simple code snippet would fail to compile if we were to compile it with any pre-C++11 standard. </span><span class="koboSpan" id="kobo.380.2">The default member initializers allow us to set a default value for class members in a class definition, which improves readability and saves us from setting the same member variable if we have multiple constructors. </span><span class="koboSpan" id="kobo.380.3">This is particularly useful for setting default values for pointers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.381.1">If we didn’t use the default initializer for </span><code class="inlineCode"><span class="koboSpan" id="kobo.382.1">ptr</span></code><span class="koboSpan" id="kobo.383.1">, it would be loaded with some random value from memory. </span><span class="koboSpan" id="kobo.383.2">Dereferencing such a pointer would result in reading from or writing to a random location, potentially leading to a serious fault. </span><span class="koboSpan" id="kobo.383.3">This hypothetical situation would be detected by a compiler or a static analyzer as they would report the usage of an uninitialized value, which is undefined behavior. </span><span class="koboSpan" id="kobo.383.4">Still, this shows the importance of initializing member variables with default values, and a default member initializer is an option for this task.</span></p>
<h3 class="heading-3" id="_idParaDest-82"><span class="koboSpan" id="kobo.384.1">Constructors and member initializer lists</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.385.1">Constructors are nameless methods in class definition that can’t be called explicitly. </span><span class="koboSpan" id="kobo.385.2">They are invoked upon the object initialization. </span><span class="koboSpan" id="kobo.385.3">A constructor that can be invoked with no arguments is called the default constructor. </span><span class="koboSpan" id="kobo.385.4">We already saw one in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.386.1">uart</span></code><span class="koboSpan" id="kobo.387.1"> class example:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-built_in"><span class="koboSpan" id="kobo.388.1">uart</span></span><span class="koboSpan" id="kobo.389.1">(std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.390.1">uint32_t</span></span><span class="koboSpan" id="kobo.391.1"> baud = </span><span class="hljs-number"><span class="koboSpan" id="kobo.392.1">9600</span></span><span class="koboSpan" id="kobo.393.1">): </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.394.1">baudrate_</span></span><span class="koboSpan" id="kobo.395.1">(baud) {
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.396.1">// empty constructor body</span></span><span class="koboSpan" id="kobo.397.1">
    }
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.398.1">Even though this constructor has a parameter, we used the default argument that will be provided to the constructor if it is called with no arguments. </span><span class="koboSpan" id="kobo.398.2">If no argument is provided at the call site, the default value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.399.1">9600</span></code><span class="koboSpan" id="kobo.400.1"> will be used for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.401.1">baud</span></code><span class="koboSpan" id="kobo.402.1"> argument. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.403.1">We use the following syntax when we want to use the default constructor:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.404.1">    uart uart1;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.405.1">This is also called </span><strong class="keyWord"><span class="koboSpan" id="kobo.406.1">default initialization</span></strong><span class="koboSpan" id="kobo.407.1">, and it is performed when the object is declared with no initializer. </span><span class="koboSpan" id="kobo.407.2">Please note that there are no parentheses as this would cause syntax ambiguity and would be interpreted by the compiler as a function declaration.</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-function"><span class="koboSpan" id="kobo.408.1">uart </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.409.1">uart1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.410.1">()</span></span><span class="koboSpan" id="kobo.411.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.412.1">The preceding </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.413.1">line </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.414.1">would be interpreted by the compiler as the declaration of a function named </span><code class="inlineCode"><span class="koboSpan" id="kobo.415.1">uart1</span></code><span class="koboSpan" id="kobo.416.1"> that returns the object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.417.1">uart</span></code><span class="koboSpan" id="kobo.418.1"> class and accepts no arguments. </span><span class="koboSpan" id="kobo.418.2">This is the reason we are not using parentheses when using the default constructor.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.419.1">As our </span><code class="inlineCode"><span class="koboSpan" id="kobo.420.1">uart</span></code><span class="koboSpan" id="kobo.421.1"> class constructor can also accept an argument, we can use direct initialization syntax and provide the constructor with an argument, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-function"><span class="koboSpan" id="kobo.422.1">uart </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.423.1">uart1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.424.1">(</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.425.1">115200</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.426.1">)</span></span><span class="koboSpan" id="kobo.427.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.428.1">This will call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.429.1">uart</span></code><span class="koboSpan" id="kobo.430.1"> class constructor and provide it with a value of </span><code class="inlineCode"><span class="koboSpan" id="kobo.431.1">115200</span></code><span class="koboSpan" id="kobo.432.1"> for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.433.1">baud</span></code><span class="koboSpan" id="kobo.434.1"> argument. </span><span class="koboSpan" id="kobo.434.2">While we have explained nuances related to the syntax of the default constructor, we still need to explain the initialization of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.435.1">baudrate_</span></code><span class="koboSpan" id="kobo.436.1"> member variable. </span><span class="koboSpan" id="kobo.436.2">In this case, we are using the member initializer list. </span><span class="koboSpan" id="kobo.436.3">It is specified after the colon character and before the opening brace of the compound statement as </span><code class="inlineCode"><span class="koboSpan" id="kobo.437.1">baudrate_(baud)</span></code><span class="koboSpan" id="kobo.438.1">. </span><span class="koboSpan" id="kobo.438.2">In our case, we have only one item in the member initializer list; if there are more, they are delimited with a comma, as in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.439.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.440.1">sensor</span></span><span class="koboSpan" id="kobo.441.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.442.1">public</span></span><span class="koboSpan" id="kobo.443.1">:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.444.1">sensor</span></span><span class="koboSpan" id="kobo.445.1">(uart &amp;u, std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.446.1">uint32_t</span></span><span class="koboSpan" id="kobo.447.1"> read_interval):
                </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.448.1">uart_</span></span><span class="koboSpan" id="kobo.449.1">(u),
                </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.450.1">read_interval_</span></span><span class="koboSpan" id="kobo.451.1">(read_interval) {}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.452.1">private</span></span><span class="koboSpan" id="kobo.453.1">:
    uart &amp;uart_;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.454.1">const</span></span><span class="koboSpan" id="kobo.455.1"> std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.456.1">uint32_t</span></span><span class="koboSpan" id="kobo.457.1"> read_interval_;
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.458.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.459.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.460.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.461.1">{
    uart uart1;
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.462.1">sensor </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.463.1">sensor1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.464.1">(uart1, </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.465.1">500</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.466.1">)</span></span><span class="koboSpan" id="kobo.467.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.468.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.469.1">0</span></span><span class="koboSpan" id="kobo.470.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.471.1">In the preceding </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.472.1">code, we</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.473.1"> are initializing a reference to </span><code class="inlineCode"><span class="koboSpan" id="kobo.474.1">uart</span></code><span class="koboSpan" id="kobo.475.1"> and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.476.1">read_interval_</span></code><span class="koboSpan" id="kobo.477.1"> unsigned integer in the member initializer list in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.478.1">sensor</span></code><span class="koboSpan" id="kobo.479.1"> constructor.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.480.1">The important thing to notice is the reference to an object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.481.1">uart</span></code><span class="koboSpan" id="kobo.482.1"> class. </span><span class="koboSpan" id="kobo.482.2">References in C++ are similar to pointers in C; that is, they point to an already-created object. </span><span class="koboSpan" id="kobo.482.3">However, they need to be initialized when declared and they can’t be reassigned to point to another object. </span><span class="koboSpan" id="kobo.482.4">References and </span><code class="inlineCode"><span class="koboSpan" id="kobo.483.1">const</span></code><span class="koboSpan" id="kobo.484.1">-qualified members must be initialized using a member initializer list.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.485.1">Constructors can have no or many parameters. </span><span class="koboSpan" id="kobo.485.2">If a constructor has one parameter and is declared without the </span><strong class="keyWord"><span class="koboSpan" id="kobo.486.1">explicit specifier</span></strong><span class="koboSpan" id="kobo.487.1">, it is called a converting constructor.</span></p>
<h3 class="heading-3" id="_idParaDest-83"><span class="koboSpan" id="kobo.488.1">Converting constructors and explicit specifiers</span></h3>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.489.1">Converting constructors</span></strong><span class="koboSpan" id="kobo.490.1"> allow</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.491.1"> the compiler to make an implicit conversion from the</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.492.1"> type of its argument to the type of its class. </span><span class="koboSpan" id="kobo.492.2">To better understand this, let’s take a look at the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.493.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.494.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.495.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.496.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.497.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.498.1">&lt;student&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.499.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.500.1">uart</span></span><span class="koboSpan" id="kobo.501.1"> {
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.502.1">uart</span></span><span class="koboSpan" id="kobo.503.1">(std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.504.1">uint32_t</span></span><span class="koboSpan" id="kobo.505.1"> baud = </span><span class="hljs-number"><span class="koboSpan" id="kobo.506.1">9600</span></span><span class="koboSpan" id="kobo.507.1">): </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.508.1">baudrate_</span></span><span class="koboSpan" id="kobo.509.1">(baud) {}
    std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.510.1">uint32_t</span></span><span class="koboSpan" id="kobo.511.1"> baudrate_;
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.512.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.513.1">uart_consumer</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.514.1">(uart u)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.515.1">{
   </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.516.1">printf</span></span><span class="koboSpan" id="kobo.517.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.518.1">"Uart baudrate is %d\r\n"</span></span><span class="koboSpan" id="kobo.519.1">, u.baudrate_);
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.520.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.521.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.522.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.523.1">{
    uart uart1;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.524.1">uart_consumer</span></span><span class="koboSpan" id="kobo.525.1">(uart1);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.526.1">uart_consumer</span></span><span class="koboSpan" id="kobo.527.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.528.1">115200</span></span><span class="koboSpan" id="kobo.529.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.530.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.531.1">0</span></span><span class="koboSpan" id="kobo.532.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.533.1">The interesting part </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.534.1">of this </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.535.1">example is the call to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.536.1">uart_consumer</span></code><span class="koboSpan" id="kobo.537.1"> function with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.538.1">115200</span></code><span class="koboSpan" id="kobo.539.1"> argument. </span><span class="koboSpan" id="kobo.539.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.540.1">uart_consumer</span></code><span class="koboSpan" id="kobo.541.1"> function expects the object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.542.1">uart</span></code><span class="koboSpan" id="kobo.543.1"> class as an argument, but due to rules of implicit conversion and the existing converting constructor, the compiler constructs an object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.544.1">uart</span></code><span class="koboSpan" id="kobo.545.1"> class using </span><code class="inlineCode"><span class="koboSpan" id="kobo.546.1">115200</span></code><span class="koboSpan" id="kobo.547.1"> as an argument, resulting in the following output of the program:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.548.1">Uart baudrate is 9600
Uart baudrate is 115200
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.549.1">Implicit conversion can be unsafe, and it is often unwanted. </span><span class="koboSpan" id="kobo.549.2">To prevent it, we can declare a constructor using an explicit specifier, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-keyword"><span class="koboSpan" id="kobo.550.1">explicit</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.551.1">uart</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.552.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.553.1">uint32_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.554.1"> baud = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.555.1">9600</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.556.1">)</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.557.1">: baudrate_(baud) {</span></span><span class="koboSpan" id="kobo.558.1">}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.559.1">Compiling the preceding example with an explicit constructor will result in a compiler error:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.560.1">&lt;source&gt;:19:19: error: could not convert '115200' from 'int' to 'uart'
   19 |     uart_consumer(115200);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.561.1">By declaring a constructor as explicit, we can be sure that no user of our class will create a situation with potential implicit conversion, which may lead to unwanted behavior in our program. </span><span class="koboSpan" id="kobo.561.2">But what if we want to prevent calls to our constructor using the float type? </span><span class="koboSpan" id="kobo.561.3">It may not be a good example, but you can imagine a constructor expecting a </span><code class="inlineCode"><span class="koboSpan" id="kobo.562.1">uint8_t</span></code><span class="koboSpan" id="kobo.563.1"> type and someone calling it with a </span><code class="inlineCode"><span class="koboSpan" id="kobo.564.1">uint32_t</span></code><span class="koboSpan" id="kobo.565.1"> argument.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.566.1">We can delete specific constructors, which will result in failed compilation. </span><span class="koboSpan" id="kobo.566.2">We can do it using the following syntax in the class declaration:</span></p>
<pre class="programlisting code"><code class="hljs-code"> <span class="hljs-built_in"><span class="koboSpan" id="kobo.567.1">uart</span></span><span class="koboSpan" id="kobo.568.1">(</span><span class="hljs-type"><span class="koboSpan" id="kobo.569.1">float</span></span><span class="koboSpan" id="kobo.570.1">) = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.571.1">delete</span></span><span class="koboSpan" id="kobo.572.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.573.1">Calling the</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.574.1"> constructor </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.575.1">with a</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.576.1"> float</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.577.1"> type will result in the following compile error:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.578.1">&lt;source&gt;:12:25: error: use of deleted function 'uart::uart(float)'
   12 |     uart uart1(100000.0f);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.579.1">We can also use brace list initialization, which narrows down the conversion and prevents the float-to-integer conversion. </span><span class="koboSpan" id="kobo.579.2">We can use it as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.580.1">    uart uart1{</span><span class="hljs-number"><span class="koboSpan" id="kobo.581.1">100000.0f</span></span><span class="koboSpan" id="kobo.582.1">};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.583.1">This call would result in the following compile error:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.584.1">&lt;source&gt;:11:25: error: narrowing conversion of '1.0e+5f' from 'float' to 'uint8_t' {aka 'unsigned char'} [-Wnarrowing]
   11 |     uart uart1{100000.0f};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.585.1">The list initialization limits the implicit conversion and helps with detecting problems at compile time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.586.1">Class data members can</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.587.1"> be</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.588.1"> declared using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.589.1">static</span></code><span class="koboSpan" id="kobo.590.1"> keyword, and there are special rules </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.591.1">for </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.592.1">initializing them.</span></p>
<h2 class="heading-2" id="_idParaDest-84"><span class="koboSpan" id="kobo.593.1">Static member initialization</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.594.1">Static </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.595.1">members are</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.596.1"> not tied to the objects of a class or struct. </span><span class="koboSpan" id="kobo.596.2">They are variables with static storage duration, and they can be accessed by any object of a class. </span><span class="koboSpan" id="kobo.596.3">Let’s go through a simple example to better understand static members and how we initialize them:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.597.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.598.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.599.1">&lt;cstdio&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.600.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.601.1">object_counter</span></span><span class="koboSpan" id="kobo.602.1"> {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.603.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.604.1">int</span></span><span class="koboSpan" id="kobo.605.1"> cnt;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.606.1">object_counter</span></span><span class="koboSpan" id="kobo.607.1">() {
        cnt++;
    }
    ~</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.608.1">object_counter</span></span><span class="koboSpan" id="kobo.609.1">() {
        cnt--;
    }
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.610.1">int</span></span><span class="koboSpan" id="kobo.611.1"> object_counter::cnt = </span><span class="hljs-number"><span class="koboSpan" id="kobo.612.1">0</span></span><span class="koboSpan" id="kobo.613.1">;
</span><span class="hljs-type"><span class="koboSpan" id="kobo.614.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.615.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.616.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.617.1">{
    {
        object_counter obj1;
        object_counter obj2;
        object_counter obj3;
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.618.1">printf</span></span><span class="koboSpan" id="kobo.619.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.620.1">"Number of existing objects in this scope is: %d\r\n"</span></span><span class="koboSpan" id="kobo.621.1">,
</span><span class="hljs-keyword"> </span><span class="koboSpan" id="kobo.622.1">object_counter::cnt);
    }
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.623.1">printf</span></span><span class="koboSpan" id="kobo.624.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.625.1">"Number of existing objects in this scope is: %d\r\n"</span></span><span class="koboSpan" id="kobo.626.1">, 
</span><span class="hljs-keyword"> </span><span class="koboSpan" id="kobo.627.1">object_counter::cnt);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.628.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.629.1">0</span></span><span class="koboSpan" id="kobo.630.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.631.1">In this example, we</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.632.1"> have a simple </span><code class="inlineCode"><span class="koboSpan" id="kobo.633.1">object_counter</span></code><span class="koboSpan" id="kobo.634.1"> struct. </span><span class="koboSpan" id="kobo.634.2">The struct has one static data member, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.635.1">cnt</span></code><span class="koboSpan" id="kobo.636.1"> integer. </span><span class="koboSpan" id="kobo.636.2">In the constructor, we are </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.637.1">incrementing this counter variable, and in the destructor, we are decrementing it. </span><span class="koboSpan" id="kobo.637.2">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.638.1">main</span></code><span class="koboSpan" id="kobo.639.1"> function, we are creating three </span><code class="inlineCode"><span class="koboSpan" id="kobo.640.1">object_counter</span></code><span class="koboSpan" id="kobo.641.1"> objects in an unnamed scope.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.642.1">When the program flow exits the unnamed scope, destructors will be called. </span><span class="koboSpan" id="kobo.642.2">We are printing the number of existing objects both inside the scope and after leaving it. </span><span class="koboSpan" id="kobo.642.3">Inside the unnamed scope, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.643.1">cnt</span></code><span class="koboSpan" id="kobo.644.1"> value should be equal to </span><code class="inlineCode"><span class="koboSpan" id="kobo.645.1">3</span></code><span class="koboSpan" id="kobo.646.1">, as we created three objects, and when we exit it, and destructors decrement the </span><code class="inlineCode"><span class="koboSpan" id="kobo.647.1">cnt</span></code><span class="koboSpan" id="kobo.648.1"> variable, it should be </span><code class="inlineCode"><span class="koboSpan" id="kobo.649.1">0</span></code><span class="koboSpan" id="kobo.650.1">. </span><span class="koboSpan" id="kobo.650.2">The following is the output of the example:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.651.1">Number of existing objects in this scope is: 3
Number of existing objects in this scope is: 0
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.652.1">The output shows that the behavior of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.653.1">cnt</span></code><span class="koboSpan" id="kobo.654.1"> static variable is as we predicted. </span><span class="koboSpan" id="kobo.654.2">In this case, we declared a static variable in the class declaration, but we defined it using the following line:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.655.1">int</span></span><span class="koboSpan" id="kobo.656.1"> object_counter::cnt = </span><span class="hljs-number"><span class="koboSpan" id="kobo.657.1">0</span></span><span class="koboSpan" id="kobo.658.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.659.1">With the C++17 standard, it is possible to declare a static variable using an </span><code class="inlineCode"><span class="koboSpan" id="kobo.660.1">inline</span></code><span class="koboSpan" id="kobo.661.1"> specifier inside the struct (or class) definition and provide it with the initializer, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.662.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.663.1">object_counter</span></span><span class="koboSpan" id="kobo.664.1"> {
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.665.1">inline</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.666.1">static</span></span> <span class="hljs-type"><span class="koboSpan" id="kobo.667.1">int</span></span><span class="koboSpan" id="kobo.668.1"> cnt = </span><span class="hljs-number"><span class="koboSpan" id="kobo.669.1">0</span></span><span class="koboSpan" id="kobo.670.1">;
    ...
</span><span class="koboSpan" id="kobo.670.2">};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.671.1">This makes the code more concise, easier to use as we don’t need to define the variable outside the class definition, and easier to read.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.672.1">We covered the</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.673.1"> basics of classes in C++, including access </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.674.1">specifiers, initializing methods, and constructors. </span><span class="koboSpan" id="kobo.674.2">Now, we will see how we can reuse classes using inheritance and dynamic polymorphism.</span></p>
<h1 class="heading-1" id="_idParaDest-85"><span class="koboSpan" id="kobo.675.1">Inheritance and dynamic polymorphism</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.676.1">In C++, we can </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.677.1">expand the functionality of a class without modifying it with inheritance. </span><span class="koboSpan" id="kobo.677.2">Inheritance is an example of establishing a hierarchical relationship between classes; for example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.678.1">ADXL345</span></code><span class="koboSpan" id="kobo.679.1"> is an accelerometer. </span><span class="koboSpan" id="kobo.679.2">Let us go through a trivial example that demonstrates inheritance in C++:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.680.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.681.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.682.1">&lt;cstdio&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.683.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.684.1">A</span></span><span class="koboSpan" id="kobo.685.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.686.1">public</span></span><span class="koboSpan" id="kobo.687.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.688.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.689.1">method_1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.690.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.691.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.692.1">printf</span></span><span class="koboSpan" id="kobo.693.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.694.1">"Class A, method1\r\n"</span></span><span class="koboSpan" id="kobo.695.1">);
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.696.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.697.1">method_2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.698.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.699.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.700.1">printf</span></span><span class="koboSpan" id="kobo.701.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.702.1">"Class A, method2\r\n"</span></span><span class="koboSpan" id="kobo.703.1">);
    }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.704.1">protected</span></span><span class="koboSpan" id="kobo.705.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.706.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.707.1">method_protected</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.708.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.709.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.710.1">printf</span></span><span class="koboSpan" id="kobo.711.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.712.1">"Class A, method_protected\r\n"</span></span><span class="koboSpan" id="kobo.713.1">);
    }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.714.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.715.1">B</span></span><span class="koboSpan" id="kobo.716.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.717.1">public</span></span><span class="koboSpan" id="kobo.718.1"> A{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.719.1">public</span></span><span class="koboSpan" id="kobo.720.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.721.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.722.1">method_1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.723.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.724.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.725.1">printf</span></span><span class="koboSpan" id="kobo.726.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.727.1">"Class B, method1\r\n"</span></span><span class="koboSpan" id="kobo.728.1">);
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.729.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.730.1">method_3</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.731.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.732.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.733.1">printf</span></span><span class="koboSpan" id="kobo.734.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.735.1">"Class B, method3\r\n"</span></span><span class="koboSpan" id="kobo.736.1">);
        A::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.737.1">method_2</span></span><span class="koboSpan" id="kobo.738.1">();
        A::</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.739.1">method_protected</span></span><span class="koboSpan" id="kobo.740.1">();
    }
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.741.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.742.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.743.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.744.1">{
    B b;
    b.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.745.1">method_1</span></span><span class="koboSpan" id="kobo.746.1">();
    b.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.747.1">method_2</span></span><span class="koboSpan" id="kobo.748.1">();
    b.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.749.1">method_3</span></span><span class="koboSpan" id="kobo.750.1">();
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.751.1">printf</span></span><span class="koboSpan" id="kobo.752.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.753.1">"-----------------\r\n"</span></span><span class="koboSpan" id="kobo.754.1">);
    A &amp;a = b;
    a.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.755.1">method_1</span></span><span class="koboSpan" id="kobo.756.1">();
    a.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.757.1">method_2</span></span><span class="koboSpan" id="kobo.758.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.759.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.760.1">0</span></span><span class="koboSpan" id="kobo.761.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.762.1">In this example, </span><code class="inlineCode"><span class="koboSpan" id="kobo.763.1">class B</span></code><span class="koboSpan" id="kobo.764.1"> inherits </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.765.1">private and protected members from </span><code class="inlineCode"><span class="koboSpan" id="kobo.766.1">class A</span></code><span class="koboSpan" id="kobo.767.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.768.1">class A</span></code><span class="koboSpan" id="kobo.769.1"> is the base class, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.770.1">class B</span></code><span class="koboSpan" id="kobo.771.1"> is derived from it. </span><span class="koboSpan" id="kobo.771.2">The derived class has access to public and protected members of the base class. </span><span class="koboSpan" id="kobo.771.3">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.772.1">main</span></code><span class="koboSpan" id="kobo.773.1"> function, we create an object of </span><code class="inlineCode"><span class="koboSpan" id="kobo.774.1">class B</span></code><span class="koboSpan" id="kobo.775.1">, and we call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.776.1">method_1</span></code><span class="koboSpan" id="kobo.777.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.778.1">method_2</span></code><span class="koboSpan" id="kobo.779.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.780.1">method_3</span></code><span class="koboSpan" id="kobo.781.1"> methods. </span><span class="koboSpan" id="kobo.781.2">The output of this part of the code is shown here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.782.1">Class B, method1
Class A, method2
Class B, method3
Class A, method2
Class A, method_protected
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.783.1">In the first line of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.784.1">main</span></code><span class="koboSpan" id="kobo.785.1"> function, we see that the call to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.786.1">method_1</span></code><span class="koboSpan" id="kobo.787.1"> function on object </span><code class="inlineCode"><span class="koboSpan" id="kobo.788.1">b</span></code><span class="koboSpan" id="kobo.789.1"> executes </span><code class="inlineCode"><span class="koboSpan" id="kobo.790.1">method_1</span></code><span class="koboSpan" id="kobo.791.1"> defined in </span><code class="inlineCode"><span class="koboSpan" id="kobo.792.1">class B</span></code><span class="koboSpan" id="kobo.793.1"> even though it is derived from </span><code class="inlineCode"><span class="koboSpan" id="kobo.794.1">class A</span></code><span class="koboSpan" id="kobo.795.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.796.1">class A</span></code><span class="koboSpan" id="kobo.797.1"> has also defined </span><code class="inlineCode"><span class="koboSpan" id="kobo.798.1">method_1</span></code><span class="koboSpan" id="kobo.799.1">. </span><span class="koboSpan" id="kobo.799.2">This is </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.800.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.801.1">static binding</span></strong><span class="koboSpan" id="kobo.802.1"> as the decision to call </span><code class="inlineCode"><span class="koboSpan" id="kobo.803.1">method_1</span></code><span class="koboSpan" id="kobo.804.1"> is defined in </span><code class="inlineCode"><span class="koboSpan" id="kobo.805.1">class A</span></code><span class="koboSpan" id="kobo.806.1"> and is made by the compiler.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.807.1">An object of the derived </span><code class="inlineCode"><span class="koboSpan" id="kobo.808.1">class B</span></code><span class="koboSpan" id="kobo.809.1"> contains an object of the base </span><code class="inlineCode"><span class="koboSpan" id="kobo.810.1">class A</span></code><span class="koboSpan" id="kobo.811.1">. </span><span class="koboSpan" id="kobo.811.2">If we call </span><code class="inlineCode"><span class="koboSpan" id="kobo.812.1">method_2</span></code><span class="koboSpan" id="kobo.813.1"> on object </span><code class="inlineCode"><span class="koboSpan" id="kobo.814.1">b</span></code><span class="koboSpan" id="kobo.815.1">, the compiler will find no definition in </span><code class="inlineCode"><span class="koboSpan" id="kobo.816.1">class B</span></code><span class="koboSpan" id="kobo.817.1">, but as class </span><code class="inlineCode"><span class="koboSpan" id="kobo.818.1">B</span></code><span class="koboSpan" id="kobo.819.1"> inherits from class </span><code class="inlineCode"><span class="koboSpan" id="kobo.820.1">A</span></code><span class="koboSpan" id="kobo.821.1">, the compiler will call </span><code class="inlineCode"><span class="koboSpan" id="kobo.822.1">method_2</span></code><span class="koboSpan" id="kobo.823.1"> on object </span><code class="inlineCode"><span class="koboSpan" id="kobo.824.1">a</span></code><span class="koboSpan" id="kobo.825.1">, which is a part of object </span><code class="inlineCode"><span class="koboSpan" id="kobo.826.1">b</span></code><span class="koboSpan" id="kobo.827.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.828.1">In </span><code class="inlineCode"><span class="koboSpan" id="kobo.829.1">method_3</span></code><span class="koboSpan" id="kobo.830.1">, we see that we can call methods of the base class from the derived class. </span><span class="koboSpan" id="kobo.830.2">We can also see that we can call protected methods of the base class. </span><span class="koboSpan" id="kobo.830.3">This is one of the use cases of private access specifiers; it allows access to derived classes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.831.1">We can assign the object of the derived class to a reference of the base class. </span><span class="koboSpan" id="kobo.831.2">We could also do the same for a pointer. </span><span class="koboSpan" id="kobo.831.3">Here is the result of calls of methods made on the reference:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.832.1">Class A, method1
Class A, method2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.833.1">Calling </span><code class="inlineCode"><span class="koboSpan" id="kobo.834.1">method_1</span></code><span class="koboSpan" id="kobo.835.1"> on a reference of the base class will result in a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.836.1">method_1</span></code><span class="koboSpan" id="kobo.837.1"> defined in </span><code class="inlineCode"><span class="koboSpan" id="kobo.838.1">class A</span></code><span class="koboSpan" id="kobo.839.1">. </span><span class="koboSpan" id="kobo.839.2">This is another instance of static binding in action. </span><span class="koboSpan" id="kobo.839.3">But what if we wanted that a call on a base class</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.840.1"> reference or pointer to result in executing a function on the derived class? </span><span class="koboSpan" id="kobo.840.2">And why would we want this? </span><span class="koboSpan" id="kobo.840.3">Let’s first address the </span><em class="italic"><span class="koboSpan" id="kobo.841.1">how</span></em><span class="koboSpan" id="kobo.842.1">. </span><span class="koboSpan" id="kobo.842.2">C++ provides a mechanism of dynamic binding through virtual functions.</span></p>
<h2 class="heading-2" id="_idParaDest-86"><span class="koboSpan" id="kobo.843.1">Virtual functions</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.844.1">In our example, we </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.845.1">assign </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.846.1">a reference of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.847.1">A&amp;</span></code><span class="koboSpan" id="kobo.848.1"> to an object of </span><code class="inlineCode"><span class="koboSpan" id="kobo.849.1">class B</span></code><span class="koboSpan" id="kobo.850.1">. </span><span class="koboSpan" id="kobo.850.2">If we want calls to </span><code class="inlineCode"><span class="koboSpan" id="kobo.851.1">method_1</span></code><span class="koboSpan" id="kobo.852.1"> on this reference (</span><code class="inlineCode"><span class="koboSpan" id="kobo.853.1">A&amp; a</span></code><span class="koboSpan" id="kobo.854.1">) to execute the </span><code class="inlineCode"><span class="koboSpan" id="kobo.855.1">method_1</span></code><span class="koboSpan" id="kobo.856.1"> function defined in </span><code class="inlineCode"><span class="koboSpan" id="kobo.857.1">class B</span></code><span class="koboSpan" id="kobo.858.1">, we can declare </span><code class="inlineCode"><span class="koboSpan" id="kobo.859.1">method_1</span></code><span class="koboSpan" id="kobo.860.1"> as a virtual function in </span><code class="inlineCode"><span class="koboSpan" id="kobo.861.1">class A</span></code><span class="koboSpan" id="kobo.862.1">, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.863.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.864.1">A</span></span><span class="koboSpan" id="kobo.865.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.866.1">public</span></span><span class="koboSpan" id="kobo.867.1">:
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.868.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.869.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.870.1">method_1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.871.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.872.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.873.1">printf</span></span><span class="koboSpan" id="kobo.874.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.875.1">"Class A, method1\r\n"</span></span><span class="koboSpan" id="kobo.876.1">);
    }
...
</span><span class="koboSpan" id="kobo.876.2">};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.877.1">Now, the call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.878.1">method_1</span></code><span class="koboSpan" id="kobo.879.1"> on the reference of </span><code class="inlineCode"><span class="koboSpan" id="kobo.880.1">class A</span></code><span class="koboSpan" id="kobo.881.1">, bound to the object of </span><code class="inlineCode"><span class="koboSpan" id="kobo.882.1">class B</span></code><span class="koboSpan" id="kobo.883.1">, will result in a call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.884.1">method_1</span></code><span class="koboSpan" id="kobo.885.1"> defined in </span><code class="inlineCode"><span class="koboSpan" id="kobo.886.1">class B</span></code><span class="koboSpan" id="kobo.887.1">, as we can see in the output:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.888.1">Class B, method1
Class A, method2
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.889.1">Here, we see the output of </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.890.1">the </span><code class="inlineCode"><span class="koboSpan" id="kobo.891.1">method_1</span></code><span class="koboSpan" id="kobo.892.1"> call matches the definition of this method from </span><code class="inlineCode"><span class="koboSpan" id="kobo.893.1">class B</span></code><span class="koboSpan" id="kobo.894.1">. </span><span class="koboSpan" id="kobo.894.2">We say that </span><code class="inlineCode"><span class="koboSpan" id="kobo.895.1">class B</span></code><span class="koboSpan" id="kobo.896.1"> is </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.897.1">overriding </span><code class="inlineCode"><span class="koboSpan" id="kobo.898.1">method_1</span></code><span class="koboSpan" id="kobo.899.1"> from </span><code class="inlineCode"><span class="koboSpan" id="kobo.900.1">class A</span></code><span class="koboSpan" id="kobo.901.1">, and there is a special notion for this, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.902.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.903.1">B</span></span><span class="koboSpan" id="kobo.904.1">: </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.905.1">public</span></span><span class="koboSpan" id="kobo.906.1"> A {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.907.1">public</span></span><span class="koboSpan" id="kobo.908.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.909.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.910.1">method_1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.911.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.912.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.913.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.914.1">printf</span></span><span class="koboSpan" id="kobo.915.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.916.1">"Class B, method1\r\n"</span></span><span class="koboSpan" id="kobo.917.1">);
    }
...
</span><span class="koboSpan" id="kobo.917.2">};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.918.1">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.919.1">override</span></strong><span class="koboSpan" id="kobo.920.1"> keyword makes the compiler aware of our intention of overriding a virtual method from the base class. </span><span class="koboSpan" id="kobo.920.2">If the method we are overriding is not declared virtual, the compiler will raise an error.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.921.1">Virtual functions in C++ are usually implemented using virtual tables. </span><span class="koboSpan" id="kobo.921.2">This is the work that a compiler does for us. </span><span class="koboSpan" id="kobo.921.3">It creates a virtual table that stores pointers for every virtual function, which points to the </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.922.1">overridden</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.923.1"> implementation.</span></p>
<h3 class="heading-3" id="_idParaDest-87"><span class="koboSpan" id="kobo.924.1">Virtual function implementation</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.925.1">Every class that</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.926.1"> overrides a</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.927.1"> virtual function has a virtual table. </span><span class="koboSpan" id="kobo.927.2">You can think of it as a hidden table of function pointers. </span><span class="koboSpan" id="kobo.927.3">Every object of a class has a pointer to this table. </span><span class="koboSpan" id="kobo.927.4">This pointer is used at runtime to access a table and find the correct function to be called on the object. </span><span class="koboSpan" id="kobo.927.5">Let us slightly modify our </span><code class="inlineCode"><span class="koboSpan" id="kobo.928.1">class A</span></code><span class="koboSpan" id="kobo.929.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.930.1">class B</span></code><span class="koboSpan" id="kobo.931.1"> to better understand this. </span><span class="koboSpan" id="kobo.931.2">The following is the code of the modified </span><code class="inlineCode"><span class="koboSpan" id="kobo.932.1">class A</span></code><span class="koboSpan" id="kobo.933.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.934.1">class B</span></code><span class="koboSpan" id="kobo.935.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.936.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.937.1">A</span></span><span class="koboSpan" id="kobo.938.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.939.1">public</span></span><span class="koboSpan" id="kobo.940.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.941.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.942.1">method_1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.943.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.944.1">virtual</span></span><span class="koboSpan" id="kobo.945.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.946.1">printf</span></span><span class="koboSpan" id="kobo.947.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.948.1">"Class A, method1\r\n"</span></span><span class="koboSpan" id="kobo.949.1">);
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.950.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.951.1">method_2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.952.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.953.1">virtual</span></span><span class="koboSpan" id="kobo.954.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.955.1">printf</span></span><span class="koboSpan" id="kobo.956.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.957.1">"Class A, method2\r\n"</span></span><span class="koboSpan" id="kobo.958.1">);
    }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.959.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.960.1">B</span></span><span class="koboSpan" id="kobo.961.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.962.1">public</span></span><span class="koboSpan" id="kobo.963.1"> A{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.964.1">public</span></span><span class="koboSpan" id="kobo.965.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.966.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.967.1">method_2</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.968.1">()</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.969.1">override</span></span><span class="koboSpan" id="kobo.970.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.971.1">printf</span></span><span class="koboSpan" id="kobo.972.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.973.1">"Class B, method2\r\n"</span></span><span class="koboSpan" id="kobo.974.1">);
    }
 };
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.975.1">We modified </span><code class="inlineCode"><span class="koboSpan" id="kobo.976.1">class A</span></code><span class="koboSpan" id="kobo.977.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.978.1">class B</span></code><span class="koboSpan" id="kobo.979.1"> so that </span><code class="inlineCode"><span class="koboSpan" id="kobo.980.1">class A</span></code><span class="koboSpan" id="kobo.981.1"> has two virtual methods, </span><code class="inlineCode"><span class="koboSpan" id="kobo.982.1">method_1</span></code><span class="koboSpan" id="kobo.983.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.984.1">method_2</span></code><span class="koboSpan" id="kobo.985.1">. </span><code class="inlineCode"><span class="koboSpan" id="kobo.986.1">class B</span></code><span class="koboSpan" id="kobo.987.1"> only overrides </span><code class="inlineCode"><span class="koboSpan" id="kobo.988.1">method_2</span></code><span class="koboSpan" id="kobo.989.1">. </span><span class="koboSpan" id="kobo.989.2">The compiler will generate a virtual table for </span><code class="inlineCode"><span class="koboSpan" id="kobo.990.1">class B</span></code><span class="koboSpan" id="kobo.991.1"> and a pointer that every object of </span><code class="inlineCode"><span class="koboSpan" id="kobo.992.1">class B</span></code><span class="koboSpan" id="kobo.993.1"> will hold. </span><span class="koboSpan" id="kobo.993.2">The virtual pointer points to the generated virtual table. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.994.1">This can be visualized as follows:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.995.1"><img alt="Figure 5.1 – Virtual table" src="../Images/B22402_05_01.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.996.1">Figure 5</span></span><span class="koboSpan" id="kobo.997.1">.1 – Virtual table</span></p>
<p class="normal"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.998.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.999.1">.1</span></em><span class="koboSpan" id="kobo.1000.1"> depicts a possible implementation of virtual functions in C++ using virtual tables and virtual pointers. </span><span class="koboSpan" id="kobo.1000.2">If we call </span><code class="inlineCode"><span class="koboSpan" id="kobo.1001.1">method_2</span></code><span class="koboSpan" id="kobo.1002.1"> on a reference to an object of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1003.1">class B</span></code><span class="koboSpan" id="kobo.1004.1">, it will follow the virtual pointer </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.1005.1">to the</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.1006.1"> virtual table and select the function pointer that points to the implementation of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1007.1">method_2</span></code><span class="koboSpan" id="kobo.1008.1"> in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1009.1">class B</span></code><span class="koboSpan" id="kobo.1010.1">, that is, the overridden virtual function. </span><span class="koboSpan" id="kobo.1010.2">This mechanism happens at runtime. </span><span class="koboSpan" id="kobo.1010.3">There is a layer of indirection to get to the overridden function, which results in space and time overhead.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1011.1">In C++, we can define a virtual function to be a pure virtual function. </span><span class="koboSpan" id="kobo.1011.2">If a class has a pure virtual function, it is</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.1012.1"> called an </span><strong class="keyWord"><span class="koboSpan" id="kobo.1013.1">abstract class</span></strong><span class="koboSpan" id="kobo.1014.1">, and it can’t be instantiated. </span><span class="koboSpan" id="kobo.1014.2">Derived classes must override pure virtual functions, or they are also abstract classes. </span><span class="koboSpan" id="kobo.1014.3">Let’s go through the following code example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1015.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1016.1">A</span></span><span class="koboSpan" id="kobo.1017.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1018.1">public</span></span><span class="koboSpan" id="kobo.1019.1">:
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1020.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1021.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1022.1">method_1</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1023.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1024.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1025.1">0</span></span><span class="koboSpan" id="kobo.1026.1">;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1027.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1028.1">B</span></span><span class="koboSpan" id="kobo.1029.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1030.1">public</span></span><span class="koboSpan" id="kobo.1031.1"> A{
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1032.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1033.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1034.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1035.1">{
    B b;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1036.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1037.1">0</span></span><span class="koboSpan" id="kobo.1038.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1039.1">This program will fail to compile as </span><code class="inlineCode"><span class="koboSpan" id="kobo.1040.1">class B</span></code><span class="koboSpan" id="kobo.1041.1"> didn’t override the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1042.1">method_1</span></code><span class="koboSpan" id="kobo.1043.1"> virtual method from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1044.1">class A</span></code><span class="koboSpan" id="kobo.1045.1">. </span><span class="koboSpan" id="kobo.1045.2">Abstract classes shift the responsibility of the implementation of certain behaviors (methods) to derived classes. </span><span class="koboSpan" id="kobo.1045.3">Classes that have all virtual methods are called interfaces.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1046.1">Inheritance defines a </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.1047.1">hierarchical </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.1048.1">relationship between classes, and we can say that </span><code class="inlineCode"><span class="koboSpan" id="kobo.1049.1">class B</span></code><span class="koboSpan" id="kobo.1050.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1051.1">class A,</span></code><span class="koboSpan" id="kobo.1052.1"> just as a cat is an animal. </span><span class="koboSpan" id="kobo.1052.2">We can represent this relationship in a </span><strong class="keyWord"><span class="koboSpan" id="kobo.1053.1">Unified Modeling Language</span></strong><span class="koboSpan" id="kobo.1054.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.1055.1">UML</span></strong><span class="koboSpan" id="kobo.1056.1">) diagram.</span></p>
<h3 class="heading-3" id="_idParaDest-88"><span class="koboSpan" id="kobo.1057.1">UML class diagrams</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.1058.1">UML diagrams are</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.1059.1"> used to describe </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.1060.1">software components. </span><span class="koboSpan" id="kobo.1060.2">If they describe the relationship between classes, they are called UML class diagrams. </span><span class="koboSpan" id="kobo.1060.3">One such diagram is shown in the following figure:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1061.1"><img alt="Figure 5.2 – UML diagram of class A and class B’s relationship" src="../Images/B22402_05_02.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.1062.1">Figure 5</span></span><span class="koboSpan" id="kobo.1063.1">.2 – UML diagram of class A and class B’s relationship</span></p>
<p class="normal"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1064.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1065.1">.2</span></em><span class="koboSpan" id="kobo.1066.1"> depicts a UML class diagram visualizing the hierarchical relationship between </span><code class="inlineCode"><span class="koboSpan" id="kobo.1067.1">A</span></code><span class="koboSpan" id="kobo.1068.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1069.1">B</span></code><span class="koboSpan" id="kobo.1070.1">. </span><span class="koboSpan" id="kobo.1070.2">The line connecting </span><code class="inlineCode"><span class="koboSpan" id="kobo.1071.1">B</span></code><span class="koboSpan" id="kobo.1072.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1073.1">A</span></code><span class="koboSpan" id="kobo.1074.1"> with a hollow, unfilled triangular arrowhead pointing to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1075.1">A</span></code><span class="koboSpan" id="kobo.1076.1"> means </span><code class="inlineCode"><span class="koboSpan" id="kobo.1077.1">B</span></code><span class="koboSpan" id="kobo.1078.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.1079.1">A</span></code><span class="koboSpan" id="kobo.1080.1">. </span><span class="koboSpan" id="kobo.1080.2">This UML diagram also</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.1081.1"> shows </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.1082.1">methods available in both classes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1083.1">UML diagrams are useful for describing design patterns, and we will use them in this book to help us visualize the relationship between software components in code examples.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1084.1">We have learned what inheritance is and how we can use it with virtual functions to achieve dynamic binding. </span><span class="koboSpan" id="kobo.1084.2">Let’s get back to the question of why we need these mechanisms and how we can use them to create better software. </span><span class="koboSpan" id="kobo.1084.3">The mechanisms we learned in this chapter provide the means </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.1085.1">for </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.1086.1">dynamic (runtime) polymorphism.</span></p>
<h2 class="heading-2" id="_idParaDest-89"><span class="koboSpan" id="kobo.1087.1">Dynamic polymorphism</span></h2>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.1088.1">Polymorphism</span></strong><span class="koboSpan" id="kobo.1089.1"> is a</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.1090.1"> mechanism that enables a single interface for different types. </span><span class="koboSpan" id="kobo.1090.2">It can be static or dynamic. </span><span class="koboSpan" id="kobo.1090.3">Dynamic polymorphism in C++ is achieved through inheritance and virtual functions. </span><span class="koboSpan" id="kobo.1090.4">This type of polymorphism is also</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.1091.1"> called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1092.1">subtyping</span></strong><span class="koboSpan" id="kobo.1093.1">, as it treats subtypes or derived classes through the interface based on the base class.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1094.1">Polymorphism allows us to use a single interface for different implementations. </span><span class="koboSpan" id="kobo.1094.2">Let us go through an example of the library for GSM modems. </span><span class="koboSpan" id="kobo.1094.3">GSM modems usually communicate with the host microcontroller through the UART interface. </span><span class="koboSpan" id="kobo.1094.4">A microcontroller may have multiple UART peripherals, such as UART and </span><strong class="keyWord"><span class="koboSpan" id="kobo.1095.1">Low-Power Universal Asynchronous Receiver/Transmitter</span></strong><span class="koboSpan" id="kobo.1096.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.1097.1">LPUART</span></strong><span class="koboSpan" id="kobo.1098.1">) on STM32. </span><span class="koboSpan" id="kobo.1098.2">We </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.1099.1">may also want to use the library on different microcontrollers.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1100.1">We can define a common interface for different UART implementations on different platforms and use this interface in our GSM library. </span><span class="koboSpan" id="kobo.1100.2">An implementation of UART will be provided by the platform on which we use the GSM library, and it will implement the common UART interface. </span><span class="koboSpan" id="kobo.1100.3">We can use a UML class diagram to visualize our library design, as in the following figure:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1101.1"><img alt="Figure 5.3 – UML diagram of GSM library and UART interface" src="../Images/B22402_05_03.png"/></span></figure>
<p class="packt_figref"><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">Figure 5</span></span><span class="koboSpan" id="kobo.1103.1">.3 – UML diagram of GSM library and UART interface</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1104.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1105.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1106.1">.3</span></em><span class="koboSpan" id="kobo.1107.1">, we see the relationship between the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1108.1">gsm_lib</span></code><span class="koboSpan" id="kobo.1109.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1110.1">uart</span></code><span class="koboSpan" id="kobo.1111.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.1112.1">uart_stm32</span></code><span class="koboSpan" id="kobo.1113.1"> classes. </span><span class="koboSpan" id="kobo.1113.2">GSM library functionality is implemented in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1114.1">gsm_lib</span></code><span class="koboSpan" id="kobo.1115.1"> class, which uses the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1116.1">uart</span></code><span class="koboSpan" id="kobo.1117.1"> interface. </span><span class="koboSpan" id="kobo.1117.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1118.1">uart</span></code><span class="koboSpan" id="kobo.1119.1"> interface is implemented by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1120.1">uart_stm32</span></code><span class="koboSpan" id="kobo.1121.1"> class. </span><span class="koboSpan" id="kobo.1121.2">The functionality of the GSM library is complex, but let’s go through a very simplified code example just to demonstrate the relationship between</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.1122.1"> these three classes and how they work together. </span><span class="koboSpan" id="kobo.1122.2">The following is a simplified example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.1123.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1124.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.1125.1">&lt;span&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1126.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1127.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.1128.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.1129.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1130.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.1131.1">&lt;cstdint&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1132.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1133.1">uart</span></span><span class="koboSpan" id="kobo.1134.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1135.1">public</span></span><span class="koboSpan" id="kobo.1136.1">:
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1137.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1138.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1139.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1140.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1141.1">uint32_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1142.1"> baudrate)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1143.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1144.1">0</span></span><span class="koboSpan" id="kobo.1145.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1146.1">virtual</span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1147.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1148.1">write</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1149.1">(std::span&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1150.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1151.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1152.1">&gt; data)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1153.1">= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1154.1">0</span></span><span class="koboSpan" id="kobo.1155.1">;
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1156.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1157.1">uart_stm32</span></span><span class="koboSpan" id="kobo.1158.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1159.1">public</span></span><span class="koboSpan" id="kobo.1160.1"> uart{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1161.1">public</span></span><span class="koboSpan" id="kobo.1162.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1163.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1164.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1165.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1166.1">uint32_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1167.1"> baudrate = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1168.1">9600</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1169.1">)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1170.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1171.1">{ 
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1172.1">printf</span></span><span class="koboSpan" id="kobo.1173.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1174.1">"uart_stm32::init: setting baudrate to %d\r\n"</span></span><span class="koboSpan" id="kobo.1175.1">, baudrate);
    } 
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1176.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1177.1">write</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1178.1">(std::span&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.1179.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.1180.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1181.1">&gt; data)</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1182.1">override</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1183.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1184.1">printf</span></span><span class="koboSpan" id="kobo.1185.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1186.1">"uart_stm32::write: "</span></span><span class="koboSpan" id="kobo.1187.1">);
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1188.1">for</span></span><span class="koboSpan" id="kobo.1189.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1190.1">auto</span></span><span class="koboSpan" id="kobo.1191.1"> ch: data) {
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1192.1">putc</span></span><span class="koboSpan" id="kobo.1193.1">(ch, stdout);
        }
    }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1194.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1195.1">gsm_lib</span></span><span class="koboSpan" id="kobo.1196.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1197.1">public</span></span><span class="koboSpan" id="kobo.1198.1">:
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1199.1">gsm_lib</span></span><span class="koboSpan" id="kobo.1200.1">(uart &amp;u) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1201.1">uart_</span></span><span class="koboSpan" id="kobo.1202.1">(u) {}
        </span><span class="hljs-type"><span class="koboSpan" id="kobo.1203.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1204.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1205.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1206.1">{
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1207.1">printf</span></span><span class="koboSpan" id="kobo.1208.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1209.1">"gsm_lib::init: sending AT command\r\n"</span></span><span class="koboSpan" id="kobo.1210.1">);
            uart_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1211.1">write</span></span><span class="koboSpan" id="kobo.1212.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1213.1">"AT"</span></span><span class="koboSpan" id="kobo.1214.1">);
        }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1215.1">private</span></span><span class="koboSpan" id="kobo.1216.1">:
        uart &amp;uart_;
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1217.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1218.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1219.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1220.1">{
    uart_stm32 uart_stm32_obj;
    uart_stm32_obj.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1221.1">init</span></span><span class="koboSpan" id="kobo.1222.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1223.1">115200</span></span><span class="koboSpan" id="kobo.1224.1">);
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.1225.1">gsm_lib </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1226.1">gsm</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1227.1">(uart_stm32_obj)</span></span><span class="koboSpan" id="kobo.1228.1">;
    gsm.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1229.1">init</span></span><span class="koboSpan" id="kobo.1230.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1231.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1232.1">0</span></span><span class="koboSpan" id="kobo.1233.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1234.1">In this code example, we see that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1235.1">uart</span></code><span class="koboSpan" id="kobo.1236.1"> class has two pure virtual functions, which makes it an interface class. </span><span class="koboSpan" id="kobo.1236.2">This interface is inherited and implemented by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1237.1">uart_stm32</span></code><span class="koboSpan" id="kobo.1238.1"> class. </span><span class="koboSpan" id="kobo.1238.2">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1239.1">main</span></code><span class="koboSpan" id="kobo.1240.1"> function, we create an object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1241.1">uart_stm32</span></code><span class="koboSpan" id="kobo.1242.1"> class, whose reference is passed to the constructor of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1243.1">gsm_lib</span></code><span class="koboSpan" id="kobo.1244.1"> class, where it is used to initialize a private member reference to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1245.1">uart</span></code><span class="koboSpan" id="kobo.1246.1"> interface.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1247.1">You can also run this program in a simulator environment, which we covered in the previous chapter. </span><span class="koboSpan" id="kobo.1247.2">It is available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1248.1">Chapter05/gsm_lib</span></code><span class="koboSpan" id="kobo.1249.1"> folder.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1250.1">The design of the GSM library using the UART interface allows us to have a flexible library that we can use on </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.1251.1">different platforms. </span><span class="koboSpan" id="kobo.1251.2">This design also allows us to debug the communication between the library and GSM modem by providing it with a UART implementation that will serve as a tap, redirecting reads and writes and simultaneously logging them.</span></p>
<h1 class="heading-1" id="_idParaDest-90"><span class="koboSpan" id="kobo.1252.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1253.1">In this chapter, we covered the basics of classes in C++. </span><span class="koboSpan" id="kobo.1253.2">We learned about member access specifiers, different ways of initializing objects, and inheritance. </span><span class="koboSpan" id="kobo.1253.3">We also got to know virtual functions in more detail and learned how to use them for dynamic polymorphism.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1254.1">In the next chapter, we will talk more about other basic concepts in C++, such as namespaces, function overloading, and the standard library.</span></p>
<h1 class="heading-1" id="_idParaDest-91"><span class="koboSpan" id="kobo.1255.1">Join our community on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1256.1">Join our community’s Discord space for discussions with the author and other readers:</span></p>
<p class="normal"><a href="https://packt.link/embeddedsystems"><span class="url"><span class="koboSpan" id="kobo.1257.1">https://packt.link/embeddedsystems</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.1258.1"><img alt="" role="presentation" src="../Images/QR_code_Discord1.png"/></span></p>
</div>
</body></html>