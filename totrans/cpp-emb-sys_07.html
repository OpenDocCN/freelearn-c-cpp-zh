<html><head></head><body>
<div><h1 class="chapterNumber">5</h1>
<h1 class="chapterTitle" id="_idParaDest-73">Classes – Building Blocks of C++ Applications</h1>
<p class="normal"><strong class="keyWord">Classes</strong> in C++ are means<a id="_idIndexMarker236"/> of organizing code into logical units. They allow us to structure data and functions that perform operations on that data in blueprints. These blueprints can be used to build instances of the classes, known as <strong class="keyWord">objects</strong>. We can initialize objects with data, manipulate them by calling <a id="_idIndexMarker237"/>functions or methods on them, store them in containers, or pass their references to objects of other classes to make the interaction between different parts of a system.</p>
<p class="normal">Classes are the basic building blocks of C++ applications. They help us organize code in units with isolated responsibility reflecting dependencies and interactions with other parts of the system. They can be combined or extended, allowing us to reuse their functionality and add additional capabilities. We use them to make abstractions of different parts of an embedded system, including low-level components such as <strong class="keyWord">Universal Asynchronous Receiver/Transmitter</strong> (<strong class="keyWord">UART</strong>) drivers <a id="_idIndexMarker238"/>and libraries or business logic components such as a cellular modem library.</p>
<p class="normal">The goal of this chapter is to delve into C++ classes and learn how we can use them to write better code. In this chapter, we’re going to cover the following main topics: </p>
<ul>
<li class="bulletList">Encapsulation</li>
<li class="bulletList">Storage duration and initialization</li>
<li class="bulletList">Inheritance and dynamic polymorphism</li>
</ul>
<h1 class="heading-1" id="_idParaDest-74">Technical requirements</h1>
<p class="normal">To get the most out of this chapter, I strongly recommend using Compiler Explorer (<a href="https://godbolt.org/">https://godbolt.org/</a>) as you read through the examples. Select GCC as your compiler and target x86 architecture. This will allow you to see standard output (stdio) results and better observe the code’s behavior. As we are using a lot of modern C++ features make sure to select C++23 standard, by adding <code class="inlineCode">-std=c++23</code> in compiler options box.</p>
<p class="normal">The examples from this chapter are available on GitHub (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter05)">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter05)</a>.</p>
<h1 class="heading-1" id="_idParaDest-75">Encapsulation</h1>
<p class="normal"><strong class="keyWord">Encapsulation</strong> is a programming<a id="_idIndexMarker239"/> concept that organizes code into units that contain both data and functions that operate on that data. It is not strictly related to <strong class="keyWord">Object-Oriented Programming</strong> (<strong class="keyWord">OOP</strong>) and is <a id="_idIndexMarker240"/>often used in other programming paradigms. Encapsulation allows us to decouple code into units with single responsibilities, making the code easier to reason about, improving readability, and facilitating maintenance.</p>
<p class="normal">In terms of OOP, encapsulation can also refer to hiding an object’s members or restricting access to these members from the outside. In C++, this can be achieved using access specifiers. C++ has the following specifiers:</p>
<ul>
<li class="bulletList">Public</li>
<li class="bulletList">Private</li>
<li class="bulletList">Protected</li>
</ul>
<p class="normal"><strong class="keyWord">Public</strong> and <strong class="keyWord">private</strong> are the most<a id="_idIndexMarker241"/> commonly used specifiers. They give us the ability to <a id="_idIndexMarker242"/>control the interface of the class, that is, to control which class members are available to the users of a class. The following example demonstrates how to define a class with public and private access sections, demonstrating the concept of encapsulation:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdint&gt;
class uart {
public:
    uart(std::uint32_t baud = 9600): baudrate_(baud) {}
    void init() {
        write_brr(calculate_uartdiv());
    }
private:
    std::uint32_t baudrate_;
    std::uint8_t calculate_uartdiv() {
        return baudrate_ / 32000;
    }
    void write_brr(std::uint8_t) {}
};
int main () {
    uart uart1(115200);
    uart1.init();
    return 0;
}
</code></pre>
<p class="normal">In this example, the <code class="inlineCode">uart</code> class has<a id="_idIndexMarker243"/> public and private access sections. Let’s go through the code step by step:</p>
<ul>
<li class="bulletList">The <code class="inlineCode">public</code> section includes a constructor that initializes the <code class="inlineCode">baudrate_</code> private member variable</li>
<li class="bulletList">We also have an <code class="inlineCode">init</code> method in the public section, in which we write a value to a <strong class="keyWord">Bit Rate Register</strong> (<strong class="keyWord">BRR</strong>), which<a id="_idIndexMarker244"/> is specific to the STM32 platform, using the <code class="inlineCode">write_brr</code> private method</li>
<li class="bulletList">The value written to the BRR register is calculated in the <code class="inlineCode">calculate_uartdiv</code> private method</li>
</ul>
<p class="normal">As we can see, methods with a public access specifier within the <code class="inlineCode">uart</code> class can use private member variables and methods. However, if we tried to use <code class="inlineCode">write_brr</code> on the <code class="inlineCode">uart1</code> object, as in <code class="inlineCode">uart1.write_brr(5)</code>, the compilation of the program would fail.</p>
<p class="normal">The private access specifier allows us to hide methods and data from the user of our class (in this case, the <code class="inlineCode">main</code> function). This helps us define a clear interface for our classes in C++. By controlling which methods a user of the class can use, we are not only protecting the class but also the user from unwanted behavior.</p>
<p class="normal">This example serves the purpose of explaining access specifiers in C++, but let’s also use it to explain the <code class="inlineCode">init</code> method. Why do we need it if we have a constructor?</p>
<p class="normal">The purpose of <code class="inlineCode">init</code> is to allow us to fully control the initialization of hardware. The object may also be constructed as a global or static variable. The initialization of static and global objects is done before reaching the <code class="inlineCode">main</code> function and initializing hardware. That is why some kind of <code class="inlineCode">init</code> method is common in classes in embedded projects. Using it, we can ensure that all hardware<a id="_idIndexMarker245"/> peripherals are initialized in the correct order.</p>
<p class="normal">The default access specifier for classes in C++ is private, so we could write the definition of the <code class="inlineCode">uart</code> class from the previous example as follows:</p>
<pre class="programlisting code"><code class="hljs-code">class uart {
    std::uint32_t baudrate_;
    std::uint8_t calculate_uartdiv();
    void write_brr(std::uint8_t);
public:
    uart(std::uint32_t baud = 9600);
    void init();
};
</code></pre>
<p class="normal">We chose to explicitly define the private access section. We put it after the <code class="inlineCode">public</code> section, as publicly accessible members are the interface for our class, and when you read code and a class definition, the first thing you want to see is the interface. You want to see how to interact with the class and which methods are part of the public interface that you can use.</p>
<p class="normal">The only data member we have in this example is <code class="inlineCode">baudrate_</code>. It is private, and the only option for a user of the <code class="inlineCode">uart</code> class to set it up is through the constructor. It is a common practice for data members that we want<a id="_idIndexMarker246"/> to expose to the public to define setter and getter methods.</p>
<h2 class="heading-2" id="_idParaDest-76">Setters and getters</h2>
<p class="normal">In the <code class="inlineCode">uart</code> class, we <a id="_idIndexMarker247"/>could define setters and getters for <code class="inlineCode">baudrate_</code> members<a id="_idIndexMarker248"/> as follows:</p>
<pre class="programlisting code"><code class="hljs-code"> std::uint32_t get_baudrate() const{
        return baudrate_;
    }
    void set_baudrate(baudrate) {
        baudrate_ = baudrate;
    }
</code></pre>
<p class="normal">Now, this would allow us to set and get the <code class="inlineCode">baudrate</code> value from the public interface, but these trivial setters and getters do not add any value to our interface. They are just exposing the <code class="inlineCode">baudrate_</code> member. It would be the same as if we put it under the public access specifier. Setters and getters should serve a clear purpose. For example, a setter can include validation logic, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"> void set_baudrate(baudrate) {
        if (baudrate &lt;= c_max_baudrate) {
            baudrate_ = baudrate;
        } else {
            baudrate = c_max_baudrate;
        }
    }
</code></pre>
<p class="normal">In the modified setter, we are making a sanity check of the value to be set and setting the private member only if it makes sense to do so, else setting it to the maximum baudrate (<code class="inlineCode">c_max_baudrate</code>) supported in our system. This is just an example; it probably doesn’t make sense to change the baudrate after the UART initialization.</p>
<p class="normal">Exposing data members through setters and getters in some sense breaks encapsulation. The idea of encapsulation is to hide the implementation details, and data members are implementation details. Therefore, setters and especially getters should be used sparingly and only when they serve a meaningful purpose.</p>
<p class="normal">We can use classes in C++ to encapsulate only functionality, without data, or data that is commonly <a id="_idIndexMarker249"/>shared <a id="_idIndexMarker250"/>with all users of a class. For that, we can use static methods.</p>
<h2 class="heading-2" id="_idParaDest-77">Static methods</h2>
<p class="normal"><strong class="keyWord">Static methods</strong> are C++ methods <a id="_idIndexMarker251"/>declared with static keywords, and they<a id="_idIndexMarker252"/> are accessible without object instantiation. In the <code class="inlineCode">uart</code> class example, besides the constructor, we have the <code class="inlineCode">init</code> method, which is part of the public interface. We use it by calling this method on an object we previously created using a single argument constructor by providing it with the baudrate. We could also design the <code class="inlineCode">uart</code> class as a type that has all static methods and use it as follows:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdint&gt;
class uart {
public:
    static void init(std::uint32_t baudrate) {
        write_brr(calculate_uartdiv(baudrate));
    }
private:
    static std::uint8_t calculate_uartdiv(std::uint32_t baudrate) {
        return baudrate / 32000;
    }
    static void write_brr(std::uint8_t) {}
};
int main () {
    uart::init(115200);
    return 0;
}
</code></pre>
<p class="normal">As you can see, we removed the single argument constructor and declared all methods as static. We also removed the <code class="inlineCode">baudrate_</code> private data member and passed it directly from the <code class="inlineCode">init</code> method to the <code class="inlineCode">calculate_uartdiv</code> method. We now have a type that we can use without object instantiation. We call the <code class="inlineCode">init</code> method by using the class name followed by a double colon and the method name, as shown in the <code class="inlineCode">main</code> function. It is worth noting that static methods can only use static data members and other static functions from a class as non-static members require the instantiation of an object.</p>
<p class="normal">We can group functions in C++ in a common <em class="italic">unit</em> by using namespaces. However, grouping them into a type is useful as we can pass types as template arguments. We will discuss namespaces and templates later in this book to better understand the benefits of this approach. Namespaces will be discussed in <a href="Chapter_06.xhtml"><em class="italic">Chapter 6</em></a> and templates in <a href="Chapter_08.xhtml"><em class="italic">Chapter 8</em></a>.</p>
<p class="normal">In C++, we can also use the struct keyword to define a type. The default access for struct members is public. Historically, structs were used for compatibility with C, so one could write a header file for a <a id="_idIndexMarker253"/>library that is used in both C and C++ programs. In this<a id="_idIndexMarker254"/> case, the struct we would share between C and C++ programs could only have common data types and couldn’t have methods as members.</p>
<h2 class="heading-2" id="_idParaDest-78">Structs</h2>
<p class="normal"><strong class="keyWord">Structs</strong> are commonly <a id="_idIndexMarker255"/>used in C++ for types that only have data members that<a id="_idIndexMarker256"/> we want to make publicly available to users. They are mostly identical to classes, with a difference being in the default access level, which is public for structs. </p>
<p class="normal">Here is an example of a struct that only has data members:</p>
<pre class="programlisting code"><code class="hljs-code">struct accelerometer_data {
    std::uint32_t x;
    std::uint32_t y;
    std::uint32_t z;
};
</code></pre>
<p class="normal"><code class="inlineCode">accelerometer_data</code> could be produced by a <code class="inlineCode">sensor</code> class, stored in a <code class="inlineCode">ring_buffer</code> class, and consumed by a <code class="inlineCode">sensor_fusion</code> class. The members of the <code class="inlineCode">accelerometer_data</code> class are values from the <code class="inlineCode">x</code>, <code class="inlineCode">y</code>, and <code class="inlineCode">z</code> axes, and they are publicly available to users of this class.</p>
<p class="normal">In this case, we use the <code class="inlineCode">accelerometer_data</code> struct only as a data holder, and we implement the behavior related to this data in other places. This is just an example. Structuring data in simple structs versus using classes with data and complex behavior is a design choice and it depends on the exact application.</p>
<p class="normal">Structs are also used to group functions into types. They are usually all declared as static and made publicly available to users. Using a struct instead of a class is convenient in this use case as the default access specifier is public and it also reflects our intent as a struct is usually used when all members are made public.</p>
<p class="normal">Besides the public and private access specifiers, there is also<a id="_idIndexMarker257"/> the <strong class="keyWord">protected specifier</strong> in C++. The protected specifier is related to inheritance and will be explained later in this chapter.</p>
<p class="normal">Let us now move on to constructors and the initialization of variables and objects in C++. Object initialization is<a id="_idIndexMarker258"/> an important task and failing to do it properly can cause <a id="_idIndexMarker259"/>problems in programs. We will discuss different options for object initialization and analyze potential pitfalls and how to avoid them.</p>
<h1 class="heading-1" id="_idParaDest-79">Storage duration and initialization</h1>
<p class="normal">C++ objects with <a id="_idIndexMarker260"/>automatic storage duration are initialized upon declaration and destroyed when exiting the variable scope. Objects can also have a static storage duration. Data members of objects can also have static storage specifiers, and there are rules for the initialization of such members. We will first go through non-static member initialization.</p>
<h2 class="heading-2" id="_idParaDest-80">Non-static member initialization</h2>
<p class="normal">There are different <a id="_idIndexMarker261"/>ways to initialize non-static class <a id="_idIndexMarker262"/>members. The first thing that comes to mind when we discuss initialization and C++ is constructors. While constructors are powerful C++ features that allow us to have great control over the initialization, let us start with <strong class="keyWord">default member initializers</strong>.</p>
<h3 class="heading-3" id="_idParaDest-81">Default member initializers</h3>
<p class="normal">As of C++11, it is possible<a id="_idIndexMarker263"/> to set a<a id="_idIndexMarker264"/> default value for a member directly in a class definition, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">class my_class{
    int a = 4;
    int *ptr = nullptr;
}
</code></pre>
<p class="normal">This simple code snippet would fail to compile if we were to compile it with any pre-C++11 standard. The default member initializers allow us to set a default value for class members in a class definition, which improves readability and saves us from setting the same member variable if we have multiple constructors. This is particularly useful for setting default values for pointers.</p>
<p class="normal">If we didn’t use the default initializer for <code class="inlineCode">ptr</code>, it would be loaded with some random value from memory. Dereferencing such a pointer would result in reading from or writing to a random location, potentially leading to a serious fault. This hypothetical situation would be detected by a compiler or a static analyzer as they would report the usage of an uninitialized value, which is undefined behavior. Still, this shows the importance of initializing member variables with default values, and a default member initializer is an option for this task.</p>
<h3 class="heading-3" id="_idParaDest-82">Constructors and member initializer lists</h3>
<p class="normal">Constructors are nameless methods in class definition that can’t be called explicitly. They are invoked upon the object initialization. A constructor that can be invoked with no arguments is called the default constructor. We already saw one in the <code class="inlineCode">uart</code> class example:</p>
<pre class="programlisting code"><code class="hljs-code"> uart(std::uint32_t baud = 9600): baudrate_(baud) {
    // empty constructor body
    }
</code></pre>
<p class="normal">Even though this constructor has a parameter, we used the default argument that will be provided to the constructor if it is called with no arguments. If no argument is provided at the call site, the default value of <code class="inlineCode">9600</code> will be used for the <code class="inlineCode">baud</code> argument. </p>
<p class="normal">We use the following syntax when we want to use the default constructor:</p>
<pre class="programlisting code"><code class="hljs-code">    uart uart1;
</code></pre>
<p class="normal">This is also called <strong class="keyWord">default initialization</strong>, and it is performed when the object is declared with no initializer. Please note that there are no parentheses as this would cause syntax ambiguity and would be interpreted by the compiler as a function declaration.</p>
<pre class="programlisting code"><code class="hljs-code"> uart uart1();
</code></pre>
<p class="normal">The preceding <a id="_idIndexMarker265"/>line <a id="_idIndexMarker266"/>would be interpreted by the compiler as the declaration of a function named <code class="inlineCode">uart1</code> that returns the object of the <code class="inlineCode">uart</code> class and accepts no arguments. This is the reason we are not using parentheses when using the default constructor.</p>
<p class="normal">As our <code class="inlineCode">uart</code> class constructor can also accept an argument, we can use direct initialization syntax and provide the constructor with an argument, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"> uart uart1(115200);
</code></pre>
<p class="normal">This will call the <code class="inlineCode">uart</code> class constructor and provide it with a value of <code class="inlineCode">115200</code> for the <code class="inlineCode">baud</code> argument. While we have explained nuances related to the syntax of the default constructor, we still need to explain the initialization of the <code class="inlineCode">baudrate_</code> member variable. In this case, we are using the member initializer list. It is specified after the colon character and before the opening brace of the compound statement as <code class="inlineCode">baudrate_(baud)</code>. In our case, we have only one item in the member initializer list; if there are more, they are delimited with a comma, as in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">class sensor {
public:
    sensor(uart &amp;u, std::uint32_t read_interval):
                uart_(u),
                read_interval_(read_interval) {}
private:
    uart &amp;uart_;
    const std::uint32_t read_interval_;
};
int main() {
    uart uart1;
    sensor sensor1(uart1, 500);
    return 0;
}
</code></pre>
<p class="normal">In the preceding <a id="_idIndexMarker267"/>code, we<a id="_idIndexMarker268"/> are initializing a reference to <code class="inlineCode">uart</code> and the <code class="inlineCode">read_interval_</code> unsigned integer in the member initializer list in the <code class="inlineCode">sensor</code> constructor.</p>
<p class="normal">The important thing to notice is the reference to an object of the <code class="inlineCode">uart</code> class. References in C++ are similar to pointers in C; that is, they point to an already-created object. However, they need to be initialized when declared and they can’t be reassigned to point to another object. References and <code class="inlineCode">const</code>-qualified members must be initialized using a member initializer list.</p>
<p class="normal">Constructors can have no or many parameters. If a constructor has one parameter and is declared without the <strong class="keyWord">explicit specifier</strong>, it is called a converting constructor.</p>
<h3 class="heading-3" id="_idParaDest-83">Converting constructors and explicit specifiers</h3>
<p class="normal"><strong class="keyWord">Converting constructors</strong> allow<a id="_idIndexMarker269"/> the compiler to make an implicit conversion from the<a id="_idIndexMarker270"/> type of its argument to the type of its class. To better understand this, let’s take a look at the following example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
#include &lt;student&gt;
struct uart {
    uart(std::uint32_t baud = 9600): baudrate_(baud) {}
    std::uint32_t baudrate_;
};
void uart_consumer(uart u) {
   printf("Uart baudrate is %d\r\n", u.baudrate_);
}
int main() {
    uart uart1;
    uart_consumer(uart1);
    uart_consumer(115200);
    return 0;
}
</code></pre>
<p class="normal">The interesting part <a id="_idIndexMarker271"/>of this <a id="_idIndexMarker272"/>example is the call to the <code class="inlineCode">uart_consumer</code> function with the <code class="inlineCode">115200</code> argument. The <code class="inlineCode">uart_consumer</code> function expects the object of the <code class="inlineCode">uart</code> class as an argument, but due to rules of implicit conversion and the existing converting constructor, the compiler constructs an object of the <code class="inlineCode">uart</code> class using <code class="inlineCode">115200</code> as an argument, resulting in the following output of the program:</p>
<pre class="programlisting con"><code class="hljs-con">Uart baudrate is 9600
Uart baudrate is 115200
</code></pre>
<p class="normal">Implicit conversion can be unsafe, and it is often unwanted. To prevent it, we can declare a constructor using an explicit specifier, as follows:</p>
<pre class="programlisting code"><code class="hljs-code"> explicit uart(std::uint32_t baud = 9600): baudrate_(baud) {}
</code></pre>
<p class="normal">Compiling the preceding example with an explicit constructor will result in a compiler error:</p>
<pre class="programlisting con"><code class="hljs-con">&lt;source&gt;:19:19: error: could not convert '115200' from 'int' to 'uart'
   19 |     uart_consumer(115200);
</code></pre>
<p class="normal">By declaring a constructor as explicit, we can be sure that no user of our class will create a situation with potential implicit conversion, which may lead to unwanted behavior in our program. But what if we want to prevent calls to our constructor using the float type? It may not be a good example, but you can imagine a constructor expecting a <code class="inlineCode">uint8_t</code> type and someone calling it with a <code class="inlineCode">uint32_t</code> argument.</p>
<p class="normal">We can delete specific constructors, which will result in failed compilation. We can do it using the following syntax in the class declaration:</p>
<pre class="programlisting code"><code class="hljs-code"> uart(float) = delete;
</code></pre>
<p class="normal">Calling the<a id="_idIndexMarker273"/> constructor <a id="_idIndexMarker274"/>with a<a id="_idIndexMarker275"/> float<a id="_idIndexMarker276"/> type will result in the following compile error:</p>
<pre class="programlisting con"><code class="hljs-con">&lt;source&gt;:12:25: error: use of deleted function 'uart::uart(float)'
   12 |     uart uart1(100000.0f);
</code></pre>
<p class="normal">We can also use brace list initialization, which narrows down the conversion and prevents the float-to-integer conversion. We can use it as follows:</p>
<pre class="programlisting code"><code class="hljs-code">    uart uart1{100000.0f};
</code></pre>
<p class="normal">This call would result in the following compile error:</p>
<pre class="programlisting con"><code class="hljs-con">&lt;source&gt;:11:25: error: narrowing conversion of '1.0e+5f' from 'float' to 'uint8_t' {aka 'unsigned char'} [-Wnarrowing]
   11 |     uart uart1{100000.0f};
</code></pre>
<p class="normal">The list initialization limits the implicit conversion and helps with detecting problems at compile time.</p>
<p class="normal">Class data members can<a id="_idIndexMarker277"/> be<a id="_idIndexMarker278"/> declared using the <code class="inlineCode">static</code> keyword, and there are special rules <a id="_idIndexMarker279"/>for <a id="_idIndexMarker280"/>initializing them.</p>
<h2 class="heading-2" id="_idParaDest-84">Static member initialization</h2>
<p class="normal">Static <a id="_idIndexMarker281"/>members are<a id="_idIndexMarker282"/> not tied to the objects of a class or struct. They are variables with static storage duration, and they can be accessed by any object of a class. Let’s go through a simple example to better understand static members and how we initialize them:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
struct object_counter {
    static int cnt;
    object_counter() {
        cnt++;
    }
    ~object_counter() {
        cnt--;
    }
};
int object_counter::cnt = 0;
int main() {
    {
        object_counter obj1;
        object_counter obj2;
        object_counter obj3;
        printf("Number of existing objects in this scope is: %d\r\n",
 object_counter::cnt);
    }
    printf("Number of existing objects in this scope is: %d\r\n", 
 object_counter::cnt);
    return 0;
}
</code></pre>
<p class="normal">In this example, we<a id="_idIndexMarker283"/> have a simple <code class="inlineCode">object_counter</code> struct. The struct has one static data member, the <code class="inlineCode">cnt</code> integer. In the constructor, we are <a id="_idIndexMarker284"/>incrementing this counter variable, and in the destructor, we are decrementing it. In the <code class="inlineCode">main</code> function, we are creating three <code class="inlineCode">object_counter</code> objects in an unnamed scope.</p>
<p class="normal">When the program flow exits the unnamed scope, destructors will be called. We are printing the number of existing objects both inside the scope and after leaving it. Inside the unnamed scope, the <code class="inlineCode">cnt</code> value should be equal to <code class="inlineCode">3</code>, as we created three objects, and when we exit it, and destructors decrement the <code class="inlineCode">cnt</code> variable, it should be <code class="inlineCode">0</code>. The following is the output of the example:</p>
<pre class="programlisting con"><code class="hljs-con">Number of existing objects in this scope is: 3
Number of existing objects in this scope is: 0
</code></pre>
<p class="normal">The output shows that the behavior of the <code class="inlineCode">cnt</code> static variable is as we predicted. In this case, we declared a static variable in the class declaration, but we defined it using the following line:</p>
<pre class="programlisting code"><code class="hljs-code">int object_counter::cnt = 0;
</code></pre>
<p class="normal">With the C++17 standard, it is possible to declare a static variable using an <code class="inlineCode">inline</code> specifier inside the struct (or class) definition and provide it with the initializer, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">struct object_counter {
    inline static int cnt = 0;
    ...
};
</code></pre>
<p class="normal">This makes the code more concise, easier to use as we don’t need to define the variable outside the class definition, and easier to read.</p>
<p class="normal">We covered the<a id="_idIndexMarker285"/> basics of classes in C++, including access <a id="_idIndexMarker286"/>specifiers, initializing methods, and constructors. Now, we will see how we can reuse classes using inheritance and dynamic polymorphism.</p>
<h1 class="heading-1" id="_idParaDest-85">Inheritance and dynamic polymorphism</h1>
<p class="normal">In C++, we can <a id="_idIndexMarker287"/>expand the functionality of a class without modifying it with inheritance. Inheritance is an example of establishing a hierarchical relationship between classes; for example, <code class="inlineCode">ADXL345</code> is an accelerometer. Let us go through a trivial example that demonstrates inheritance in C++:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
class A {
public:
    void method_1() {
        printf("Class A, method1\r\n");
    }
    void method_2() {
        printf("Class A, method2\r\n");
    }
protected:
    void method_protected() {
        printf("Class A, method_protected\r\n");
    }
};
class B : public A{
public:
    void method_1() {
        printf("Class B, method1\r\n");
    }
    void method_3() {
        printf("Class B, method3\r\n");
        A::method_2();
        A::method_protected();
    }
};
int main() {
    B b;
    b.method_1();
    b.method_2();
    b.method_3();
    printf("-----------------\r\n");
    A &amp;a = b;
    a.method_1();
    a.method_2();
    return 0;
}
</code></pre>
<p class="normal">In this example, <code class="inlineCode">class B</code> inherits <a id="_idIndexMarker288"/>private and protected members from <code class="inlineCode">class A</code>. <code class="inlineCode">class A</code> is the base class, and <code class="inlineCode">class B</code> is derived from it. The derived class has access to public and protected members of the base class. In the <code class="inlineCode">main</code> function, we create an object of <code class="inlineCode">class B</code>, and we call the <code class="inlineCode">method_1</code>, <code class="inlineCode">method_2</code>, and <code class="inlineCode">method_3</code> methods. The output of this part of the code is shown here:</p>
<pre class="programlisting con"><code class="hljs-con">Class B, method1
Class A, method2
Class B, method3
Class A, method2
Class A, method_protected
</code></pre>
<p class="normal">In the first line of the <code class="inlineCode">main</code> function, we see that the call to the <code class="inlineCode">method_1</code> function on object <code class="inlineCode">b</code> executes <code class="inlineCode">method_1</code> defined in <code class="inlineCode">class B</code> even though it is derived from <code class="inlineCode">class A</code>, and <code class="inlineCode">class A</code> has also defined <code class="inlineCode">method_1</code>. This is <a id="_idIndexMarker289"/>called <strong class="keyWord">static binding</strong> as the decision to call <code class="inlineCode">method_1</code> is defined in <code class="inlineCode">class A</code> and is made by the compiler.</p>
<p class="normal">An object of the derived <code class="inlineCode">class B</code> contains an object of the base <code class="inlineCode">class A</code>. If we call <code class="inlineCode">method_2</code> on object <code class="inlineCode">b</code>, the compiler will find no definition in <code class="inlineCode">class B</code>, but as class <code class="inlineCode">B</code> inherits from class <code class="inlineCode">A</code>, the compiler will call <code class="inlineCode">method_2</code> on object <code class="inlineCode">a</code>, which is a part of object <code class="inlineCode">b</code>.</p>
<p class="normal">In <code class="inlineCode">method_3</code>, we see that we can call methods of the base class from the derived class. We can also see that we can call protected methods of the base class. This is one of the use cases of private access specifiers; it allows access to derived classes.</p>
<p class="normal">We can assign the object of the derived class to a reference of the base class. We could also do the same for a pointer. Here is the result of calls of methods made on the reference:</p>
<pre class="programlisting con"><code class="hljs-con">Class A, method1
Class A, method2
</code></pre>
<p class="normal">Calling <code class="inlineCode">method_1</code> on a reference of the base class will result in a call to <code class="inlineCode">method_1</code> defined in <code class="inlineCode">class A</code>. This is another instance of static binding in action. But what if we wanted that a call on a base class<a id="_idIndexMarker290"/> reference or pointer to result in executing a function on the derived class? And why would we want this? Let’s first address the <em class="italic">how</em>. C++ provides a mechanism of dynamic binding through virtual functions.</p>
<h2 class="heading-2" id="_idParaDest-86">Virtual functions</h2>
<p class="normal">In our example, we <a id="_idIndexMarker291"/>assign <a id="_idIndexMarker292"/>a reference of type <code class="inlineCode">A&amp;</code> to an object of <code class="inlineCode">class B</code>. If we want calls to <code class="inlineCode">method_1</code> on this reference (<code class="inlineCode">A&amp; a</code>) to execute the <code class="inlineCode">method_1</code> function defined in <code class="inlineCode">class B</code>, we can declare <code class="inlineCode">method_1</code> as a virtual function in <code class="inlineCode">class A</code>, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">class A {
public:
    virtual void method_1() {
        printf("Class A, method1\r\n");
    }
...
};
</code></pre>
<p class="normal">Now, the call to <code class="inlineCode">method_1</code> on the reference of <code class="inlineCode">class A</code>, bound to the object of <code class="inlineCode">class B</code>, will result in a call to <code class="inlineCode">method_1</code> defined in <code class="inlineCode">class B</code>, as we can see in the output:</p>
<pre class="programlisting con"><code class="hljs-con">Class B, method1
Class A, method2
</code></pre>
<p class="normal">Here, we see the output of <a id="_idIndexMarker293"/>the <code class="inlineCode">method_1</code> call matches the definition of this method from <code class="inlineCode">class B</code>. We say that <code class="inlineCode">class B</code> is <a id="_idIndexMarker294"/>overriding <code class="inlineCode">method_1</code> from <code class="inlineCode">class A</code>, and there is a special notion for this, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">class B: public A {
public:
    void method_1() override {
        printf("Class B, method1\r\n");
    }
...
};
</code></pre>
<p class="normal">The <strong class="keyWord">override</strong> keyword makes the compiler aware of our intention of overriding a virtual method from the base class. If the method we are overriding is not declared virtual, the compiler will raise an error.</p>
<p class="normal">Virtual functions in C++ are usually implemented using virtual tables. This is the work that a compiler does for us. It creates a virtual table that stores pointers for every virtual function, which points to the <a id="_idIndexMarker295"/>overridden<a id="_idIndexMarker296"/> implementation.</p>
<h3 class="heading-3" id="_idParaDest-87">Virtual function implementation</h3>
<p class="normal">Every class that<a id="_idIndexMarker297"/> overrides a<a id="_idIndexMarker298"/> virtual function has a virtual table. You can think of it as a hidden table of function pointers. Every object of a class has a pointer to this table. This pointer is used at runtime to access a table and find the correct function to be called on the object. Let us slightly modify our <code class="inlineCode">class A</code> and <code class="inlineCode">class B</code> to better understand this. The following is the code of the modified <code class="inlineCode">class A</code> and <code class="inlineCode">class B</code>:</p>
<pre class="programlisting code"><code class="hljs-code">class A {
public:
    void method_1() virtual{
        printf("Class A, method1\r\n");
    }
    void method_2() virtual{
        printf("Class A, method2\r\n");
    }
};
class B : public A{
public:
    void method_2() override{
        printf("Class B, method2\r\n");
    }
 };
</code></pre>
<p class="normal">We modified <code class="inlineCode">class A</code> and <code class="inlineCode">class B</code> so that <code class="inlineCode">class A</code> has two virtual methods, <code class="inlineCode">method_1</code> and <code class="inlineCode">method_2</code>. <code class="inlineCode">class B</code> only overrides <code class="inlineCode">method_2</code>. The compiler will generate a virtual table for <code class="inlineCode">class B</code> and a pointer that every object of <code class="inlineCode">class B</code> will hold. The virtual pointer points to the generated virtual table. </p>
<p class="normal">This can be visualized as follows:</p>
<figure class="mediaobject"><img alt="Figure 5.1 – Virtual table" src="img/B22402_05_01.png"/></figure>
<p class="packt_figref">Figure 5.1 – Virtual table</p>
<p class="normal"><em class="italic">Figure 5</em><em class="italic">.1</em> depicts a possible implementation of virtual functions in C++ using virtual tables and virtual pointers. If we call <code class="inlineCode">method_2</code> on a reference to an object of <code class="inlineCode">class B</code>, it will follow the virtual pointer <a id="_idIndexMarker299"/>to the<a id="_idIndexMarker300"/> virtual table and select the function pointer that points to the implementation of <code class="inlineCode">method_2</code> in <code class="inlineCode">class B</code>, that is, the overridden virtual function. This mechanism happens at runtime. There is a layer of indirection to get to the overridden function, which results in space and time overhead.</p>
<p class="normal">In C++, we can define a virtual function to be a pure virtual function. If a class has a pure virtual function, it is<a id="_idIndexMarker301"/> called an <strong class="keyWord">abstract class</strong>, and it can’t be instantiated. Derived classes must override pure virtual functions, or they are also abstract classes. Let’s go through the following code example:</p>
<pre class="programlisting code"><code class="hljs-code">class A {
public:
    virtual void method_1() = 0;
};
class B : public A{
};
int main() {
    B b;
    return 0;
}
</code></pre>
<p class="normal">This program will fail to compile as <code class="inlineCode">class B</code> didn’t override the <code class="inlineCode">method_1</code> virtual method from <code class="inlineCode">class A</code>. Abstract classes shift the responsibility of the implementation of certain behaviors (methods) to derived classes. Classes that have all virtual methods are called interfaces.</p>
<p class="normal">Inheritance defines a <a id="_idIndexMarker302"/>hierarchical <a id="_idIndexMarker303"/>relationship between classes, and we can say that <code class="inlineCode">class B</code> is <code class="inlineCode">class A,</code> just as a cat is an animal. We can represent this relationship in a <strong class="keyWord">Unified Modeling Language</strong> (<strong class="keyWord">UML</strong>) diagram.</p>
<h3 class="heading-3" id="_idParaDest-88">UML class diagrams</h3>
<p class="normal">UML diagrams are<a id="_idIndexMarker304"/> used to describe <a id="_idIndexMarker305"/>software components. If they describe the relationship between classes, they are called UML class diagrams. One such diagram is shown in the following figure:</p>
<figure class="mediaobject"><img alt="Figure 5.2 – UML diagram of class A and class B’s relationship" src="img/B22402_05_02.png"/></figure>
<p class="packt_figref">Figure 5.2 – UML diagram of class A and class B’s relationship</p>
<p class="normal"><em class="italic">Figure 5</em><em class="italic">.2</em> depicts a UML class diagram visualizing the hierarchical relationship between <code class="inlineCode">A</code> and <code class="inlineCode">B</code>. The line connecting <code class="inlineCode">B</code> and <code class="inlineCode">A</code> with a hollow, unfilled triangular arrowhead pointing to <code class="inlineCode">A</code> means <code class="inlineCode">B</code> is <code class="inlineCode">A</code>. This UML diagram also<a id="_idIndexMarker306"/> shows <a id="_idIndexMarker307"/>methods available in both classes.</p>
<p class="normal">UML diagrams are useful for describing design patterns, and we will use them in this book to help us visualize the relationship between software components in code examples.</p>
<p class="normal">We have learned what inheritance is and how we can use it with virtual functions to achieve dynamic binding. Let’s get back to the question of why we need these mechanisms and how we can use them to create better software. The mechanisms we learned in this chapter provide the means <a id="_idIndexMarker308"/>for <a id="_idIndexMarker309"/>dynamic (runtime) polymorphism.</p>
<h2 class="heading-2" id="_idParaDest-89">Dynamic polymorphism</h2>
<p class="normal"><strong class="keyWord">Polymorphism</strong> is a<a id="_idIndexMarker310"/> mechanism that enables a single interface for different types. It can be static or dynamic. Dynamic polymorphism in C++ is achieved through inheritance and virtual functions. This type of polymorphism is also<a id="_idIndexMarker311"/> called <strong class="keyWord">subtyping</strong>, as it treats subtypes or derived classes through the interface based on the base class.</p>
<p class="normal">Polymorphism allows us to use a single interface for different implementations. Let us go through an example of the library for GSM modems. GSM modems usually communicate with the host microcontroller through the UART interface. A microcontroller may have multiple UART peripherals, such as UART and <strong class="keyWord">Low-Power Universal Asynchronous Receiver/Transmitter</strong> (<strong class="keyWord">LPUART</strong>) on STM32. We <a id="_idIndexMarker312"/>may also want to use the library on different microcontrollers.</p>
<p class="normal">We can define a common interface for different UART implementations on different platforms and use this interface in our GSM library. An implementation of UART will be provided by the platform on which we use the GSM library, and it will implement the common UART interface. We can use a UML class diagram to visualize our library design, as in the following figure:</p>
<figure class="mediaobject"><img alt="Figure 5.3 – UML diagram of GSM library and UART interface" src="img/B22402_05_03.png"/></figure>
<p class="packt_figref">Figure 5.3 – UML diagram of GSM library and UART interface</p>
<p class="normal">In <em class="italic">Figure 5</em><em class="italic">.3</em>, we see the relationship between the <code class="inlineCode">gsm_lib</code>, <code class="inlineCode">uart</code>, and <code class="inlineCode">uart_stm32</code> classes. GSM library functionality is implemented in the <code class="inlineCode">gsm_lib</code> class, which uses the <code class="inlineCode">uart</code> interface. The <code class="inlineCode">uart</code> interface is implemented by the <code class="inlineCode">uart_stm32</code> class. The functionality of the GSM library is complex, but let’s go through a very simplified code example just to demonstrate the relationship between<a id="_idIndexMarker313"/> these three classes and how they work together. The following is a simplified example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;span&gt;
#include &lt;cstdio&gt;
#include &lt;cstdint&gt;
class uart {
public:
    virtual void init(std::uint32_t baudrate) = 0;
    virtual void write(std::span&lt;const char&gt; data) = 0;
};
class uart_stm32 : public uart{
public:
    void init(std::uint32_t baudrate = 9600) override { 
        printf("uart_stm32::init: setting baudrate to %d\r\n", baudrate);
    } 
    void write(std::span&lt;const char&gt; data) override {
        printf("uart_stm32::write: ");
        for(auto ch: data) {
            putc(ch, stdout);
        }
    }
};
class gsm_lib{
    public:
        gsm_lib(uart &amp;u) : uart_(u) {}
        void init() {
            printf("gsm_lib::init: sending AT command\r\n");
            uart_.write("AT");
        }
    private:
        uart &amp;uart_;
};
int main() {
    uart_stm32 uart_stm32_obj;
    uart_stm32_obj.init(115200);
    gsm_lib gsm(uart_stm32_obj);
    gsm.init();
    return 0;
}
</code></pre>
<p class="normal">In this code example, we see that the <code class="inlineCode">uart</code> class has two pure virtual functions, which makes it an interface class. This interface is inherited and implemented by the <code class="inlineCode">uart_stm32</code> class. In the <code class="inlineCode">main</code> function, we create an object of the <code class="inlineCode">uart_stm32</code> class, whose reference is passed to the constructor of the <code class="inlineCode">gsm_lib</code> class, where it is used to initialize a private member reference to the <code class="inlineCode">uart</code> interface.</p>
<p class="normal">You can also run this program in a simulator environment, which we covered in the previous chapter. It is available in the <code class="inlineCode">Chapter05/gsm_lib</code> folder.</p>
<p class="normal">The design of the GSM library using the UART interface allows us to have a flexible library that we can use on <a id="_idIndexMarker314"/>different platforms. This design also allows us to debug the communication between the library and GSM modem by providing it with a UART implementation that will serve as a tap, redirecting reads and writes and simultaneously logging them.</p>
<h1 class="heading-1" id="_idParaDest-90">Summary</h1>
<p class="normal">In this chapter, we covered the basics of classes in C++. We learned about member access specifiers, different ways of initializing objects, and inheritance. We also got to know virtual functions in more detail and learned how to use them for dynamic polymorphism.</p>
<p class="normal">In the next chapter, we will talk more about other basic concepts in C++, such as namespaces, function overloading, and the standard library.</p>
<h1 class="heading-1" id="_idParaDest-91">Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/embeddedsystems">https://packt.link/embeddedsystems</a></p>
<p class="normal"><img alt="" role="presentation" src="img/QR_code_Discord1.png"/></p>
</div>
</body></html>