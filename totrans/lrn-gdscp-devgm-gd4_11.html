<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-267"><a id="_idTextAnchor660"/>11</h1>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor661"/>Playing Together  with Multiplayer</h1>
			<p>Playing games on your own is lots of fun. I’ve spent many hours exploring exotic worlds, acquiring new skills, and experiencing deep storylines on my own. But where games really shine, compared to other forms of media, is the ability for the player to create their own stories. Nothing lets players create their own story like letting them play with another real person. From cooperation and tense moments trying to help each other in games like World of Warcraft or Rocket League, to rivalry and intimidating each other in games like Call of Duty or Gran Turismo. Human behavior is still something that invokes more emotions than interacting with a complete fictional world.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>A crash course in computer networking</li>
				<li>Using the <code>MultiplayerSynchronizer</code> and <code>MultiplayerSpawner</code></li>
				<li>Running the game on multiple computers</li>
			</ul>
			<p>In this chapter, we are going to implement networked multiplayer. This means that two people will be able to play together over the internet. Now, because of how networks work, and we still <a id="_idIndexMarker657"/>want to be safe, we’ll only be able to play over a <strong class="bold">local area network</strong> (<strong class="bold">LAN</strong>). This means that people who are connected to the same Wi-Fi network, for example, will be able to play together.</p>
			<p>The reason why you don’t want to run a globally accessible server from your personal computer is quite simple: you don’t want the risk of people hacking your computer. Though there are ways to do this in a safe way, this is beyond the scope of this book.</p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor662"/>Technical requirements</h1>
			<p>As for every chapter, you can find the final code on the GitHub repository in the subfolder for this chapter: <a href="https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter11">https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter11</a>.</p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor663"/>A crash course in computer networking</h1>
			<p>In this section, I would like to give you a brief crash course on computer networking. Because Godot does a lot out of the box, we don’t have to be complete networking wizards to <a id="_idIndexMarker658"/>implement simple multiplayer games. This means that you could skip this section and directly start with the actual implementation of the multiplayer nodes and code. However, I recommend reading on if you want at least some high-level explanation of why we do things the way we are going to do them.</p>
			<p>Computers in networks talk to each other through a layered model. On the top level, there is the eventual application, the game. Our game needs to send information from one instance of the game, running on one computer, to another instance of the game, running on another computer, also called <strong class="bold">another machine</strong>. This top layer is called the <strong class="bold">Application Layer</strong>. In between <a id="_idIndexMarker659"/>these computers could be a vast network of interconnected servers, routers, and other networking infrastructure. This network <a id="_idIndexMarker660"/>is the lowest layer, called the <strong class="bold">Physical Layer</strong>.</p>
			<div><div><img alt="Figure 11.1 – The seven layers of computer networking" src="img/B19358_11_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – The seven layers of computer networking</p>
			<p>Between the Application Layer and the Physical Layer, there are multiple other layers. These layers make sure that data is sent and received between all links in the chain that need to be taken to transmit this packet of data from Computer A to Computer B and each serves a different purpose.</p>
			<p>Though Godot provides us with a great deal of flexibility, not every layer is equally important to us at the moment. Let’s take a closer look at two network layers: the Transport and Application Layers.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor664"/>What is a Transport Layer?</h2>
			<p>The first layer <a id="_idIndexMarker661"/>we’ll look at is the <strong class="bold">Transport Layer</strong>, the fourth layer of <a id="_idIndexMarker662"/>computer networking. This layer is, among other things, responsible for deciding how to cut the data we want to send in smaller packages of data, making sure that packages of data are received from one end to the other, uncorrupted.</p>
			<div><div><img alt="Figure 11.2 – The Transport Layer is the fourth layer in computer networking" src="img/B19358_11_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – The Transport Layer is the fourth layer in computer networking</p>
			<p>To meet these responsibilities, different protocols have been invented that are able to take care of them with varying <a id="_idIndexMarker663"/>degrees of reliability. A <strong class="bold">protocol</strong> is basically a set of rules by which computers can communicate with each other.</p>
			<p>For example, if we send out a package of data from Computer A to Computer B, we could just send it off and hope for the best. However, our package of data could accidentally get dropped somewhere within the vast internet. A server forgets to send it from one link to the other, a cable gets unplugged, or any other error could happen.</p>
			<p>Now, how do we make sure that the data we send actually arrives? Well, we could ask for confirmation from the receiving computer. But what if that confirmation gets lost somewhere? Well, we could do a double confirmation, one from each participant in the communication.</p>
			<p>All these rules just solve the problem of making sure a package of data gets sent and received, but there are many other problems that we need to overcome as well. You can see that these <a id="_idIndexMarker664"/>protocols quickly become complex. Luckily, smart people <a id="_idIndexMarker665"/>already thought about all of this for us.</p>
			<p>In gaming, there are two main protocols that are used:</p>
			<ul>
				<li><strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>): The TCP is a Transport Layer protocol <a id="_idIndexMarker666"/>that makes sure that every package that is sent will be received. But to achieve this, the protocol takes more time, sending confirmations back and forth.</li>
				<li><strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>): The UDP is a Transport Layer protocol that does not <a id="_idIndexMarker667"/>care whether packages arrive or not. It just sends them over a connection in the hopes that they make it, which most of them should do. This is way faster than the TCP but less reliable.</li>
			</ul>
			<p>Godot Engine can operate using either TCP or UDP and can even switch between the two for different kinds of data, depending on how important guaranteed delivery is. For our game, we will use both the UDP and TCP for different kinds of data.</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor665"/>What is an Application Layer?</h2>
			<p>The Application <a id="_idIndexMarker668"/>Layer is the highest layer in the networking layers. This is <a id="_idIndexMarker669"/>when we actually use the data that we received within the game. Additionally, here, we have a choice to make; even though we have the data, how are we going to organize the computers that we are connected with?</p>
			<div><div><img alt="Figure 11.3 – The Application Layer is the seventh layer in computer networking" src="img/B19358_11_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – The Application Layer is the seventh layer in computer networking</p>
			<p>For games, there <a id="_idIndexMarker670"/>are two network architectures <a id="_idIndexMarker671"/>that prevail: peer-to-peer or client-server.</p>
			<h3>Peer-to-peer network</h3>
			<p>In a peer-to-peer network, every computer can talk to any other computer and ask it things. They are <a id="_idIndexMarker672"/>all equals and peers. For example, Computer A could <a id="_idIndexMarker673"/>ask Computer B to tell at what location its player character is located. Computer B will then send over this data so that Computer A can show its user where the player character of Computer B is situated in the game world.</p>
			<div><div><img alt="Figure 11.4 – In a peer-to-peer network, each computer can talk to the other computers" src="img/B19358_11_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – In a peer-to-peer network, each computer can talk to the other computers</p>
			<p>This solution <a id="_idIndexMarker674"/>is pretty elegant because every computer is equal and <a id="_idIndexMarker675"/>has the same number of rights. However, we’ll also need to be vigilant because what if Computer B is used by a hacker and lies to the other computers? Instead of reporting the position of the player according to the game’s rules, Computer B gives positions that are impossible to reach; maybe they teleport its player character around. This is quite a problem. The next network architecture tries to tackle this problem.</p>
			<h3>Client-server network</h3>
			<p>Instead of <a id="_idIndexMarker676"/>treating every computer as equal, we could have one of the <a id="_idIndexMarker677"/>computers as the center for all communication. Every time any of the computers in the network want information, such as the location of another computer’s player character, they’ll have to ask this central computer. The central computer will then answer for the other computer.</p>
			<p>In this situation, we call the central computer the server, and the connected computers the clients.</p>
			<div><div><img alt="Figure 11.5 – In a client-server, network each computer talks to the server" src="img/B19358_11_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – In a client-server, network each computer talks to the server</p>
			<p>With this <a id="_idIndexMarker678"/>architecture, the server can check up <a id="_idIndexMarker679"/>on all clients and make sure none of them are cheating.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor666"/>Networking in Godot Engine</h2>
			<p>Again, Godot Engine supports both peer-to-peer and client-server network architectures. To make it easier on ourselves, we’ll go with a client-server approach. This way, we can <a id="_idIndexMarker680"/>make sure that important parts of the <a id="_idIndexMarker681"/>game get run only on the server and our clients don’t have to worry about them. For example, considering counting the score – clients can easily lie about this, while now the server will be the only computer keeping score.</p>
			<p>Alright, after this short introduction to computer networking, although there is still so much to learn, we have enough knowledge of the underlying structure that we can start implementing multiplayer in our game.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor667"/>Learning about IP addresses</h2>
			<p>In real life, to send <a id="_idIndexMarker682"/>mail to another person, you need to know the address of <a id="_idIndexMarker683"/>their house. For computer networks, this is pretty much the same. To send messages between computers, we need to know their <strong class="bold">IP address</strong>. This is a unique address that makes sure you can find any computer connected to the internet.</p>
			<p>Currently, there are two versions of IP addresses in use: <code>0</code> to <code>255</code> separated by a period, like so:</p>
			<pre class="source-code">
166.58.155.136</pre>			<p>This version is supposed to be able to have a unique address for 4.3 billion devices. But it turns out that humans have been so productive that 4.3 billion devices will probably not be enough! These days, almost any electrical device can be connected to the internet, even fridges, toasters, and watches. That is why we are slowly transitioning to IPv6 addresses, which support 340 undecillion devices. That is 340 trillion devices.</p>
			<p>An IPv6 address looks like this:</p>
			<pre class="source-code">
e9fd:da7d:474d:dedb:d152:dce2:1294:2560</pre>			<p>Depending on <a id="_idIndexMarker684"/>how your computer is connected to the internet, this IP address changes from time to time, so don’t depend on it being the same.</p>
			<p>An IP address is <a id="_idIndexMarker685"/>a postal address we can send a letter to, but then, we still need to know to whom in the household the letter is addressed. In a computer network, a <strong class="bold">port</strong> is used to <a id="_idIndexMarker686"/>address the exact application within the computer. Let’s talk about ports next.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor668"/>Using port numbers</h2>
			<p>An IP address, be it IPv4 or IPv6, only indicates where to send the data to. But computers have many applications that each need their own connection. So, from the moment the <a id="_idIndexMarker687"/>data is received, to which application do we send it? Well, each application can use different ports, which are like the different platforms in <a id="_idIndexMarker688"/>a train station. Although each train arrives at the same station, they arrive at different platforms.</p>
			<p>Each application can choose a port, which is just a number from <code>0</code> to <code>65535</code>. However, the first 1,024 are reserved for standard computer functionality and we will not be able to pick these.</p>
			<p>To specify which port to send data to, we can add the port number at the end of the IP address, behind a colon:</p>
			<pre class="source-code">
166.58.155.136<strong class="bold">:5904</strong>
e9fd:da7d:474d:dedb:d152:dce2:1294:2560<code>5904</code>.</p>
			<p>Now that we <a id="_idIndexMarker689"/>know about the basic mechanisms of computer networking, such as <a id="_idIndexMarker690"/>the different layers and how IP addresses work, we are able to start implementing multiplayer into our game. So, let’s give that a shot!</p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor669"/>Setting up the base networking code</h1>
			<p>In the <em class="italic">A crash course in computer networking</em> section, we saw that we wanted to set up a client-server network architecture and that we could use IP addresses and ports to find computers <a id="_idIndexMarker691"/>over the internet. In this section, we’ll start implementing this.</p>
			<p>We’re going to make our multiplayer game work like this: every time you start playing, it spins up a server in the background. This way, anyone can join after one person starts the match.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor670"/>Creating the client-server connection</h2>
			<p>If we want to connect our players through a client-server model, we need to be able to set up one <a id="_idIndexMarker692"/>computer as a server and the others as clients that connect to this server. Let’s start by writing some code.</p>
			<ol>
				<li>In the <code>menu.gd</code> script, add a constant at the top that indicates which port we want to use:<pre class="source-code">
const PORT: int = 7890</pre></li>				<li>Now add these two functions to the bottom of the script:<pre class="source-code">
func host_game():
   var peer = ENetMultiplayerPeer.new()
   peer.create_server(PORT)
   if peer.get_connection_status() == MultiplayerPeer.CONNECTION_DISCONNECTED:
      return
   multiplayer.multiplayer_peer = peer
func connect_to_game(ip_address: String):
   var peer = ENetMultiplayerPeer.new()
   peer.create_client(ip_address, PORT)
   if peer.get_connection_status() == MultiplayerPeer.CONNECTION_DISCONNECTED:
      return
   multiplayer.multiplayer_peer = peer</pre><p class="list-inset">The <code>host_game()</code> function will use the <code>ENetMultiplayerPeer</code> class to create a new server using the <code>create_server()</code> function that is defined on it. To create <a id="_idIndexMarker693"/>this server, we only have to specify on which port we want to receive the data. Once this is done, we check whether the connection status is disconnected; if we are not connected, then we need to return from the function. We can check the connection status using the <code>get_connection_status()</code> function on the <code>peer</code> object.</p></li>				<li>Lastly, we set this peer as <code>multiplayer_peer</code>, which is defined on the multiplayer global variable.<p class="list-inset">The <code>connect_to_game()</code> function does largely the same but creates a client using the <code>create_client()</code> function on the <code>ENetMultiplayerPeer</code> <code>peer</code> object. The <code>create_client()</code> function takes an IP address and port. These will, of course, be the IP address and port of the server.</p></li>
			</ol>
			<p>With these two functions in place, we can add some more UI to connect to the right server.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor671"/>Adding UI</h2>
			<p>Now, for the menu, we want to be able to start a game that will set up a server or input an IP address <a id="_idIndexMarker694"/>to join an already hosted game. We won’t have to let the player choose a port, both because it’s less of a hassle for the player and because we don’t want them to accidentally choose an invalid port number. We, the programmers, decide we are going to use port <code>7890</code>.</p>
			<div><div><img alt="Figure 11.6 – The main menu with an input field to specify an IP address" src="img/B19358_11_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – The main menu with an input field to specify an IP address</p>
			<ol>
				<li>Open up the <code>menu.tscn</code> scene.</li>
				<li>Add a <code>LineEdit</code> node in <code>VBoxContainer</code>, which holds the play and exit buttons, and rename it <code>IpAddressLineEdit</code>.</li>
				<li>Place <code>IpAddressLineEdit</code> under the <code>PlayButton</code> node, but not as a child.</li>
			</ol>
			<div><div><img alt="Figure 11.7 – The main menu scene tree with the added IpAddressLineEdit" src="img/B19358_11_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – The main menu scene tree with the added IpAddressLineEdit</p>
			<ol>
				<li value="4">Select the <code>IpAddressLineEdit</code> node and set <code>IP ADDRESS</code>. This will <a id="_idIndexMarker695"/>show some placeholder text that will get replaced the moment the user puts anything into the line edit.</li>
			</ol>
			<div><div><img alt="Figure 11.8 – Setting Placeholder Text in a LineEdit node" src="img/B19358_11_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Setting Placeholder Text in a LineEdit node</p>
			<ol>
				<li value="5">Now, in the <code>menu.gd</code> script, cache the <code>IpAddressLineEdit</code> at the top:<pre class="source-code">
@onready var _ip_address_line_edit = $CenterContainer/MainUIContainer/PanelContainer/MarginContainer/VBoxContainer/VBoxContainer/IpAddressLineEdit</pre></li>				<li>Lastly, we need to change the <code>_on_play_button_pressed()</code> function to host or connect to a game:<pre class="source-code">
func _on_play_button_pressed():
   if _ip_address_line_edit.text.is_empty():
      host_game()
   else:
      connect_to_game(_ip_address_line_edit.text)
   get_tree().change_scene_to_file("res://screens/game/main.tscn")</pre></li>			</ol>
			<p>With all this in place, we have all that is needed to set up the client-server architecture. One computer <a id="_idIndexMarker696"/>will be the server and the others, the clients. Before we dive into the things we have to change in the code of the game itself, such as spawning playable characters for every person joining and then making sure the position of each player is synchronized between each computer, we can try out what we have already created.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor672"/>Running multiple debug instances at the same time</h2>
			<p>To debug a multiplayer game, we need to be able to run our game multiple times in debug <a id="_idIndexMarker697"/>mode. Luckily, Godot Engine has a handy feature that allows us to run as many instances of our game as we want at the same time.</p>
			<ol>
				<li>Click <strong class="bold">Debug</strong> in the top menu bar.</li>
				<li>Under the <strong class="bold">Run Multiple Instances</strong> menu, choose <strong class="bold">Run </strong><strong class="bold">2 Instances</strong>.</li>
			</ol>
			<div><div><img alt="Figure 11.9 – In the Debug dropdown menu, we set the number of instances we want to run" src="img/B19358_11_09.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – In the Debug dropdown menu, we set the number of instances we want to run</p>
			<ol>
				<li value="3">Run the project. This will make two instances of the game pop up at the same time.</li>
				<li>In one instance, just press <strong class="bold">Play</strong>. The game should start up normally.</li>
				<li>In the other instance, type <code>::1</code> in the IP address input field and then press <strong class="bold">Play</strong>.</li>
			</ol>
			<div><div><img alt="Figure 11.10 – Specifying the ::1 IP address will loop back to the same computer" src="img/B19358_11_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – Specifying the ::1 IP address will loop back to the same computer</p>
			<p>Unfortunately, you won’t see anything special happen. We still need to account for multiple <a id="_idIndexMarker698"/>players in our game code, but normally, there should be no errors in the bottom <strong class="bold">Debug</strong> panel.</p>
			<p class="callout-heading">Local host IP address</p>
			<p class="callout">There is a special IP address that does not go to another computer but rather loops back to the same computer again. In the IPv6 format, this address is <code>::1</code>, and for IPv4, it is <code>127.0.0.1</code>.</p>
			<p>You’ll also see that there are now multiple tabs in the <strong class="bold">Debug</strong> panel, one for each instance of the game. This way, we will be able to debug each separately.</p>
			<div><div><img alt="Figure 11.11 – When running multiple instances, we’ll also have multiple Debug tabs" src="img/B19358_11_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – When running multiple instances, we’ll also have multiple Debug tabs</p>
			<p>Now that <a id="_idIndexMarker699"/>we are able to create a server and connect clients, let’s start by making our game multiplayer compatible and synchronizing spawned scenes between both games.</p>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor673"/>Synchronizing different clients</h1>
			<p>Until now, we learned about computer networking and set up a connection between multiple instances <a id="_idIndexMarker700"/>of our game. The next step is to change the scenes and code within our game to account for multiple players. We want to accomplish two things:</p>
			<ul>
				<li>Firstly, if the server instances a new scene, such as a new projectile, we want that scene to be instanced on every client</li>
				<li>Secondly, we want to synchronize values, such as the position of each player character, between all clients</li>
			</ul>
			<p>We’ll first look at which Godot Engine nodes can help us achieve these two goals while updating the player character to be used in multiplayer. After that, we’ll update the entity spawner, enemy, collectible, and projectile scenes, too. Most of these changes will be quite small.</p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor674"/>Updating the player scene for multiplayer</h2>
			<p>Because the <a id="_idIndexMarker701"/>player is the most <a id="_idIndexMarker702"/>important entity in the game, let’s start by updating them for multiplayer. This way, we can quickly make sure everything is working correctly, too.</p>
			<h3>Using MultiplayerSpawner to spawn player scenes</h3>
			<p>To <a id="_idIndexMarker703"/>synchronize instanced scenes between the server and the clients, Godot Engine has a node called <code>MultiplayerSpawner</code>. It will <a id="_idIndexMarker704"/>listen to the scenes that are getting added to the scene tree and will replicate them on each of the other clients, too. Let’s add one to the main game scene:</p>
			<ol>
				<li>Open the <code>main.tscn</code> scene.</li>
				<li>Under the root <code>MultiplayerSpawner</code> node, and call it <code>PlayerMultiplayerSpawner</code>, because it will be spawning new player characters.</li>
			</ol>
			<div><div><img alt="Figure 11.12 – The main.tscn scene tree with an added PlayerMultiplayerSpawner" src="img/B19358_11_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – The main.tscn scene tree with an added PlayerMultiplayerSpawner</p>
			<ol>
				<li value="3">Now, in the inspector window for <code>PlayerMultiplayerSpawner</code>, press <code>player.tscn</code> scene into that element.</li>
			</ol>
			<div><div><img alt="Figure 11.13 – Add the player.tscn scene as an element in PlayerMultiplayerSpawner" src="img/B19358_11_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – Add the player.tscn scene as an element in PlayerMultiplayerSpawner</p>
			<ol>
				<li value="4">Now, to <a id="_idIndexMarker705"/>specify positions at which our players can spawn, add <code>Node2D</code>, called <code>PlayerStartPositions</code>, under the <code>Main</code> node with different <code>Marker2D</code> nodes where we can spawn players. Place each marker at a good spot to start a player from.</li>
			</ol>
			<div><div><img alt="Figure 11.14 – The PlayerStartPositions node with Marker2D to spawn players at" src="img/B19358_11_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – The PlayerStartPositions node with Marker2D to spawn players at</p>
			<ol>
				<li value="5">In the <code>main.gd</code> script, we’ll cache the player scene in an export variable. So, add the following line of code at the top and drag the <code>player.tscn</code> scene into this export variable in the inspector, too:<pre class="source-code">
@export var player_scene: PackedScene</pre></li>				<li>Also, cache the <code>PlayerMultiplayerSpawner</code> node in a variable called <code>_player_multiplayer_spawner</code> and <code>PlayerStartPositions</code> in a variable called <code>_player_start_positions</code>:<pre class="source-code">
@onready var _player_multiplayer_spawner: MultiplayerSpawner = $PlayerMultiplayerSpawner
@onready var _player_start_positions: Node2D = $PlayerStartPositions</pre></li>				<li>We’ll also add a variable at the top of the script that specifies what position we will spawn the next player at. With this variable, we will select which <code>Marker2D</code> to use as to location to spawn each player at:<pre class="source-code">
<code>main.gd</code> script:<pre class="source-code">
func add_player(id: int):
   _player_multiplayer_spawner.spawn(id)
func spawn_player(id: int):
   var player: Player = player_scene.instantiate()
   player.multiplayer_id = id
   player.died.connect(_on_player_died)
   var spawn_marker: Marker2D = _player_start_positions.get_childr(_player_spawn_index)
   player.position = spawn_marker.position
   _player_spawn_index = (_player_spawn_index + 1) % _player_start_positions.get_child_count()
   return player</pre></li>				<li>To use these functions, we’ll add a <code>_ready()</code> function to the <code>main.gd</code> script:<pre class="source-code">
func _ready():
   _player_multiplayer_spawner.spawn_function = spawn_player
   if multiplayer.is_server():
      multiplayer.peer_connected.connect(add_player)
      add_player(1)</pre></li>				<li>Lastly, but <a id="_idIndexMarker707"/>very importantly, delete the <code>Player</code> node that is already in the <code>main.tscn</code> scene. We do this because we’ll spawn each player character from code and so they don’t need the node to be in there already.</li>
			</ol>
			<p>In the <code>add_player()</code> function, we simply ask <code>_player_multiplayer_spawner</code> to spawn a new instance of the player scene.</p>
			<p>Then, in the <code>spawn_player()</code> function, which will be used by the <code>PlayerMultiplayerSpawner</code> to spawn new <code>Player</code> scenes, we instantiate a new player scene and set its <code>multiplayer_id</code> property to the  ID that we received as a parameter. This ID is used to determine which client owns that particular player node. We’ll use it in the next section. Afterward, we must return the new player instance so that the <code>PlayerMultiplayerSpawner</code> can handle the rest for us.</p>
			<p>We use the <code>_player_spawn_index</code> variable to select which <code>Marker2D</code> to select in <code>PlayerStartPositions</code>. After each player spawned, we increment this variable with <code>1</code> and make sure it loops back around with the <code>%</code> operator. This makes sure that we don’t spawn players on top of each other.</p>
			<p>In the <code>_ready()</code> function, first, we set <code>spawn_function</code> for <code>_player_multiplayer_spawner</code> to be the <code>spawn_player()</code> function that we defined. This way, the multiplayer spawner knows how to create new instances of the player scene.</p>
			<p>Then, you see that we check the <code>multiplayer</code> object if this code is being run on the server, using <code>multiplayer.is_server()</code>. This <code>is_server()</code> function returns <code>true</code> if the code is run on the server.</p>
			<p>If we are running on the server, we do the following:</p>
			<pre class="source-code">
multiplayer.peer_connected.connect(add_player)</pre>			<p><code>peer_connected</code> is a signal that is thrown by the <code>multiplayer</code> object when a new peer (a new client) connects to the server. Instead of connecting through the editor, like we used to do for detecting whether the player is close to the collectibles, we directly call the <code>connect()</code> function on this signal and pass along the function that we want to execute when a player connects to the server, which is the <code>add_player()</code> function.</p>
			<p>After <a id="_idIndexMarker708"/>connecting to the <code>peer_connected</code> signal, we call the <code>add_player()</code> function with <code>1</code> as <code>id</code>, which is the default ID for the server.</p>
			<p>We will not yet be able to run the game for now, first, we need to update the player scene.</p>
			<h3>Updating the player code for multiplayer</h3>
			<p>When you try running the game with multiple instances at the end of the last section, you will notice <a id="_idIndexMarker709"/>that there are some things off, mainly that, on each client separately, you control both players at the same time.</p>
			<p>This behavior happens because, although we spawn a player per client, all code gets run all the time on each client separately. We have to specify that the movement code for each player character should only be run on the client associated with that player character, not all at once on all clients. Afterward, we should synchronize the position to the server.</p>
			<p>We’ll do this by <a id="_idIndexMarker710"/>setting the <strong class="bold">multiplayer authority</strong> of the player character node. This authority “owns” this node and decides how it behaves.</p>
			<p>So, let’s alter our code so the players work properly:</p>
			<ol>
				<li>Firstly, add the <code>multiplayer_id</code> variable that we used in the last section somewhere at the top of the <code>player.gd</code> script:<pre class="source-code">
var multiplayer_id: int</pre></li>				<li>Add an <code>_enter_tree()</code> function; this function is a life cycle function that gets called when the node enters the tree, right before the <code>_ready()</code> function. In this function, we set the multiplayer authority to the client that has the same ID as <code>multiplayer_id</code> of this player node:<pre class="source-code">
func _enter_tree():
   set_multiplayer_authority(multiplayer_id)</pre></li>				<li>Cache the <code>CameraPosition</code> node at the top of the script:<pre class="source-code">
@onready var _camera_position: Node2D = $CameraPosition</pre></li>				<li>Now, update the <code>_ready()</code> function like this:<pre class="source-code">
func _ready():
   update_health_label()
<strong class="bold">   if not multiplayer.is_server():</strong>
<strong class="bold">      _shoot_timer.stop()</strong>
<strong class="bold">   if not is_multiplayer_authority():</strong>
<strong class="bold">      _camera_position.queue_free()</strong>
<strong class="bold">      set_physics_process(false))</strong></pre></li>			</ol>
			<p>In <em class="italic">step 2</em>, we set the multiplayer authority for a node, which means that we determine which client is <a id="_idIndexMarker711"/>the owner of this node. For most nodes in multiplayer, the server should be the owner. But the player character is so important to each client that we give the authority of each to their respective client.</p>
			<p>After that, we use <code>multiplayer.is_server()</code> to stop <code>_shoot_timer</code> when we are not running on the server. This way, we make sure that projectiles only get spawned on the server side and replicated to all clients from there.</p>
			<p>Next, we use <code>is_multiplayer_authority()</code> to check whether we are the authority of this specific player node. If we are not, we free <code>_camera_position</code>. We don’t need multiple cameras, only the one that is used to track the player we want to see, and we also disable the <code>_physics_process()</code> function. Only the client that owns this node will have to calculate this player’s position and then report back to the server where the player is.</p>
			<p class="callout-heading">Disabling the _process() and _physics_process() functions</p>
			<p class="callout">By default, the <code>_process()</code> and <code>_physics_process()</code> functions get called on each frame and physics frames, respectively. However, we can choose to enable or disable them manually by calling <code>set_process()</code> and <code>set_physics_process()</code> along with a Boolean that says whether they should run or not.</p>
			<p>After all this, you can <a id="_idIndexMarker712"/>run the game with multiple instances, like we saw in the <em class="italic">Running multiple debug instances at the same time</em> section, and you should see a second player spawn! Each player is able to move properly, but their positions are unfortunately not synchronized. We’ll do that next.</p>
			<h3>Synchronizing the players’ positions and health</h3>
			<p>We can spawn scenes across clients and determine on which client certain pieces of code <a id="_idIndexMarker713"/>should run. The last piece of the puzzle is to synchronize certain variables, like the position and health of our players. Luckily, this is actually very easy to do using the <code>MultiplayerSynchronizer</code> node. We are going to use two of these, one for the position and one for the health. Although one synchronizer can synchronize multiple variables, we want the position to be managed by each client individually and the health to be managed by the server:</p>
			<ol>
				<li>In the <code>player.tscn</code> scene, add two <code>MultiplayerSynchronizer</code> nodes under the root <code>Player</code> node. Call on <code>PositionMultiplayerSynchronizer</code> and the other <code>HealthMultiplayerSynchronizer</code>.</li>
			</ol>
			<div><div><img alt="Figure 11.15 – The player.tscn scene tree after adding two MultiplayerSynchronizer nodes" src="img/B19358_11_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15 – The player.tscn scene tree after adding two MultiplayerSynchronizer nodes</p>
			<ol>
				<li value="2">Select <code>PositionMultiplayerSynchronizer</code> and a new panel should appear <a id="_idIndexMarker714"/>at the bottom of the editor.</li>
			</ol>
			<div><div><img alt="Figure 11.16 – The Replication panel that opens up when selecting MultiplayerSynchronizer" src="img/B19358_11_16.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16 – The Replication panel that opens up when selecting MultiplayerSynchronizer</p>
			<ol>
				<li value="3">Here, press <strong class="bold">+ Add property </strong><strong class="bold">to synchronize</strong>.</li>
				<li>Select the <code>Player</code> node and press <strong class="bold">OK</strong>.</li>
			</ol>
			<div><div><img alt="Figure 11.17 – Select the Player node to synchronize one of its values" src="img/B19358_11_17.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.17 – Select the Player node to synchronize one of its values</p>
			<ol>
				<li value="5">Now, search <a id="_idIndexMarker715"/>for the <code>position</code> property and press <strong class="bold">Open</strong>.</li>
			</ol>
			<div><div><img alt="Figure 11.18 – Select the position property to synchronize its value" src="img/B19358_11_18.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.18 – Select the position property to synchronize its value</p>
			<ol>
				<li value="6">Do <em class="italic">steps 2</em> to <em class="italic">5</em> again but add the <code>health</code> property to <code>HealthMultiplayerSynchronizer</code> this time.</li>
			</ol>
			<div><div><img alt="Figure 11.19 – The Replication panel tracking the position value of the Player node" src="img/B19358_11_19.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.19 – The Replication panel tracking the position value of the Player node</p>
			<ol>
				<li value="7">Now, update the <code>_enter_tree()</code> function of the player so that we give the multiplayer <a id="_idIndexMarker716"/>authority of <code>HealthMultiplayerSpawner</code> to the server:<pre class="source-code">
func _enter_tree() -&gt; void:
   set_multiplayer_authority(multiplayer_id)
   <code>1</code>. So, to give the authority to the server, we set the multiplayer authority of <code>HealthMultiplayerSynchronizer</code> to <code>1</code>.</p></li>			</ol>
			<p>That is all we need to do to synchronize values between different clients. <code>MultiplayerSynchronizer</code> simply tracks them for us.</p>
			<p>Running two instances of the game and connecting them finally shows that if we move one player character in one client, it also moves that player character in the other client.</p>
			<p>Now that we updated the hardest scene to multiplayer, the player scene, we have all the knowledge to do the same for the remaining scenes. Let’s dive in so that we have a complete multiplayer game at the end!</p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor675"/>Synchronizing EntitySpawner</h2>
			<p>To make sure the enemy and health potion scenes are spawned on each client when the entity <a id="_idIndexMarker717"/>spawner wants to, we’ll have to make a few little adjustments to the <code>EnitySpawner</code> scene:</p>
			<ol>
				<li>In the <code>entity_spawner.tscn</code> scene, add a <code>MultiplayerSpawner</code> node.</li>
			</ol>
			<div><div><img alt="Figure 11.20 – The EntitySpawner scene tree after adding MultiplayerSpawner" src="img/B19358_11_20.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.20 – The EntitySpawner scene tree after adding MultiplayerSpawner</p>
			<ol>
				<li value="2">In the <code>entity_spawner.gd</code> script, cache the <code>MultiplayerSpawner</code> node:<pre class="source-code">
@onready var _multiplayer_spawner = $MultiplayerSpawner</pre></li>				<li>Then, in the <code>_ready()</code> function, let’s add the scene this spawner uses to this <code>MultiplayerSpawner</code> node and only start the timer if we are running on the server. This ensures that not every client is spawning new entities, only the server:<pre class="source-code">
func _ready():
<strong class="bold">   _multiplayer_spawner.add_spawnable_scene(entity_scene.resource_path)</strong>
   <strong class="bold">if multiplayer.is_server():</strong>
      start_timer()</pre></li>				<li>One last thing we need to do is change the exact way we add the <code>new_entity</code> to the scene. So, change the line with <code>add_child(new_entity)</code> to the following:<pre class="source-code">
add_child(new_entity<strong class="bold">, true</strong>)</pre></li>			</ol>
			<p>In <em class="italic">step 3</em>, we add a spawnable scene to the <code>MultiplayerSpawner</code> node. This is very convenient as now we can add any scene on the fly.</p>
			<p>In <em class="italic">step 4</em>, we supply the Boolean <code>true</code> as a second parameter to the <code>add_child()</code> function, next to the node that we want to add to the scene tree. This indicates that we want to use <a id="_idIndexMarker718"/>human-readable names for each node, names that are easy for humans to read. When we don’t set this Boolean to <code>true</code>, the engine will pick a name for the node. These names look like <code>@Node2D@2</code>. These are reserved names that cannot be synchronized using a <code>MultiplayerSpawner</code> node. When we do set this Boolean to <code>true</code>, each new instance gets nicely named, for example, <code>Enemy2</code>, <code>Enemy3</code>, and so on. In a multiplayer scenario, this is important for the server to properly synchronize scenes and values between them.</p>
			<p>Now that we can synchronize the spawned entities of enemies and collectibles between clients, let’s synchronize their behavior, too.</p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor676"/>Synchronizing the enemy and collectibles</h2>
			<p>For both <a id="_idIndexMarker719"/>the enemy and all collectibles, making them work with multiplayer is quite easy and straightforward:</p>
			<ol>
				<li>Add <code>MultiplayerSynchronizer</code> to the <code>enemy.tscn</code> and <code>collectible.tscn</code>.</li>
			</ol>
			<div><div><img alt="Figure 11.21 – The scene tree of the Collectible after adding MultiplayerSynchronizer" src="img/B19358_11_21.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.21 – The scene tree of the Collectible after adding MultiplayerSynchronizer</p>
			<ol>
				<li value="2">Now, add the <code>position</code> property of the root node in the <strong class="bold">Replication</strong> menu at the bottom.</li>
			</ol>
			<div><div><img alt="Figure 11.22 – The Replication panel tracking the position of the Collectible node" src="img/B19358_11_22.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.22 – The Replication panel tracking the position of the Collectible node</p>
			<p>That is <a id="_idIndexMarker720"/>about it for <code>Collectible</code>, while for <code>Enemy</code>, we need to do some last things in the code:</p>
			<ol>
				<li>Cache <code>PlayerDetectionArea</code> at the top of the <code>enemy.gd</code> script:<pre class="source-code">
@onready var _player_detection_area: Area2D = $PlayerDetectionArea</pre></li>				<li>Now, update the <code>_ready()</code> function like this:<pre class="source-code">
func _ready():
   <strong class="bold">if not multiplayer.is_server():</strong>
      <strong class="bold">set_physics_process(false)</strong>
      <strong class="bold">_player_detection_area.monitoring = false</strong>
      <strong class="bold">return</strong>
   var player_nodes: Array = get_tree().get_nodes_in_group("player")
   if not player_nodes.is_empty():
      target = <strong class="bold">player_nodes.pick_random()</strong></pre></li>			</ol>
			<p>The first thing we do in the <code>_ready()</code> function of the enemy is disable the <code>_physics_process()</code> function and <code>_player_detection_area</code> if we are not running them from the server. This makes sure that enemies are fully controlled by the server.</p>
			<p>The <code>Area2D</code> nodes have a property, <code>monitoring</code>, that stops looking for collisions with other areas or bodies when set to <code>false</code>. This is what we are using here to disable <code>_player_detection_area</code> on other clients than the server.</p>
			<p>Lastly, we <a id="_idIndexMarker721"/>want to be able to target any of the players in the game, so we change how to target a player. The <code>pick_random()</code> function on an array will pick any element within that array at random and return it. This is ideal for picking a random player within the scene!</p>
			<p>Let’s now look at how we can synchronize the projectiles.</p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor677"/>Synchronizing the projectile</h2>
			<p>The last <a id="_idIndexMarker722"/>scene we need to synchronize between the multiple clients is the one of the projectiles. So, let’s do that with the following steps:</p>
			<ol>
				<li>In the <code>projectile.tscn</code> scene, add <code>MultiplayerSynchronizer</code>.</li>
			</ol>
			<div><div><img alt="Figure 11.23 – The scene tree of Projectile after adding MultiplayerSynchronizer" src="img/B19358_11_23.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.23 – The scene tree of Projectile after adding MultiplayerSynchronizer</p>
			<ol>
				<li value="2">This time, synchronize both the <code>position</code> and <code>rotation</code> properties.</li>
			</ol>
			<div><div><img alt="Figure 11.24 – The Replication panel tracking the position and rotation of the Projectile node" src="img/B19358_11_24.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.24 – The Replication panel tracking the position and rotation of the Projectile node</p>
			<p class="list-inset">Cache <code>EnemyDetectionArea</code> at the top of the <code>projectile.gd</code> script:</p>
			<pre class="source-code">
@onready var _enemy_detection_area: Area2D = $EnemyDetectionArea</pre>			<ol>
				<li value="3">Now, add a <code>_ready()</code> function as follows:<pre class="source-code">
func _ready():
   if not multiplayer.is_server():
      set_physics_process(false)
      _enemy_detection_area.monitoring = false</pre></li>				<li>We need <a id="_idIndexMarker723"/>to change the way the projectile is added to the scene within the <code>player.gd</code> script from <code>get_parent().add_child(new_projectile)</code> to the following:<pre class="source-code">
get_parent().add_child(new_projectile<strong class="bold">, true</strong>)</pre></li>			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">Remember that the last parameter of the <code>add_child()</code> function is a Boolean that determines that the name of the new node should be human readable.</p>
			<ol>
				<li value="5">Lastly, we need to make sure that the <code>projectile.tscn</code> scene is replicated in the main scene, just like we did for the <code>player.tscn</code> scene. Add a <code>MultiplayerSpawner</code> node in the <code>main.tscn</code>, call it <code>ProjectileMultiplayerSpawner</code>, and add <code>projectile.tscn</code> in <strong class="bold">Auto </strong><strong class="bold">Spawn List</strong>.</li>
			</ol>
			<div><div><img alt="Figure 11.25 – Main scene with ProjectilMultiplayerSpawner with the projectile.tscn scene" src="img/B19358_11_25.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.25 – Main scene with ProjectilMultiplayerSpawner with the projectile.tscn scene</p>
			<p>That is it <a id="_idIndexMarker724"/>for the <code>Projectile</code> scene and thereby all the scenes important to playing the game itself! You can now run multiple instances of the game and everything within the game should be synchronized. The last thing we’ll need to look at is synchronizing the timers within the game and the game-over menu for both players.</p>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor678"/>Fixing the timer and end game</h1>
			<p>The last thing <a id="_idIndexMarker725"/>we need to adjust for multiplayer is the timer that times our <a id="_idIndexMarker726"/>run and the end of the game, stopping the entity spawners and showing the game-over menu. So, let’s get started on this last effort.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor679"/>Synchronizing the timer</h2>
			<p>To synchronize <a id="_idIndexMarker727"/>the score timer, we simply have to do the following three things:</p>
			<ol>
				<li>Add <code>MultiplayerSynchronizer</code> to the <code>main.tscn</code> scene.</li>
			</ol>
			<div><div><img alt="Figure 11.26 – The Main scene tree after adding MultiplayerSynchronizer" src="img/B19358_11_26.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.26 – The Main scene tree after adding MultiplayerSynchronizer</p>
			<ol>
				<li value="2">Synchronize <a id="_idIndexMarker728"/>the <code>_time</code> property of the <code>Main</code> node.</li>
			</ol>
			<div><div><img alt="Figure 11.27 – The Replication panel tracking the _time property of the Main node" src="img/B19358_11_27.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.27 – The Replication panel tracking the _time property of the Main node</p>
			<ol>
				<li value="3">Now, disable the <code>_process()</code> function from within <code>_ready()</code> if we are not running on the server:<pre class="source-code">
func _ready():
   # Other code
   <strong class="bold">if not multiplayer.is_server():</strong>
      set_process(false)</pre></li>			</ol>
			<p>That is all we need to do synchronize the timer across all clients.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor680"/>Synchronizing the end of the game</h2>
			<p>To make <a id="_idIndexMarker729"/>sure that when the game ends, it ends for all clients, let’s do the following:</p>
			<ol>
				<li>In the <code>main.gd</code> script, let’s connect to each player character’s <code>died</code> signal in the <code>add_player()</code> function:<pre class="source-code">
func add_player(id: int):
   var player: Player = player_scene.instantiate()
   player.name = str(id)
   add_child(player)
   <code>_on_player_died()</code> function and add a new <code>end_game()</code> function:<pre class="source-code">
func _on_player_died() -&gt; void:
   end_game.rpc()
@rpc("authority", "reliable", "call_local")
func end_game():
   _game_over_menu.show()
   _enemy_spawner.stop_timer()
   _health_potion_spawner.stop_timer()
   set_process(false)
   Highscore.set_new_highscore(_time)</pre></li>				<li>Then, in the <code>menu.gd</code> script, change the <code>_ready()</code> function to the following:<pre class="source-code">
func _ready():
   _highscore_label.text = "Highscore: " + str(Highscore.highscore)
<strong class="bold">   if multiplayer.has_multiplayer_peer():</strong>
<strong class="bold">      multiplayer.multiplayer_peer.close()</strong></pre></li>			</ol>
			<p>In the first <a id="_idIndexMarker730"/>step, we simply connect to each player’s <code>died</code> signal through code.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that only the server connects to the <code>died</code> signal because it is the server that manages the game loop.</p>
			<p>In the second step, we do something very interesting. We call the <code>end_game()</code> function through <strong class="bold">RPC</strong>, which means that we call it on every client at the same time!</p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="bold">Remote procedure call</strong> (<strong class="bold">RPC</strong>) is a protocol that makes functions directly callable over different clients. This makes it easy to execute the same code on all connected instances of the game at the same time.</p>
			<p>You can see that we use the <code>@rpc</code> annotation right before the <code>end_game()</code> function. This is to indicate how we would like this function to be handled when calling on every client at once. The strings we pass it along mean the following:</p>
			<ul>
				<li><code>"authority"</code>: Only the one with authority, the server, in this case, can call this function.</li>
				<li><code>"reliable"</code>: We want this command to be sent reliably over the network, using TCP.</li>
				<li><code>"</code><code>call_local"</code>: This function, when called, should be executed on all clients, including the one that called it.</li>
			</ul>
			<p>This means that the game-over menu will be shown on every client from the moment one of the players dies.</p>
			<p>In the third step, we simply close the multiplayer connection, when there is one, and we open up the <a id="_idIndexMarker731"/>main menu. This way, we make sure we don’t stay connected while we are not playing anymore.</p>
			<p>Now that the whole game is ready to be played in multiplayer, let’s get started on actually running it on multiple machines at the same time!</p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor681"/>Running the game on multiple computers</h1>
			<p>Until this point, we’ve been running multiple instances of our game on the same machine. But the <a id="_idIndexMarker732"/>strength of multiplayer comes from playing with multiple people over multiple machines.</p>
			<p>In this section, we’ll start off by showing the server’s IP address on screen and then look into how we can run a debug instance on multiple computers at the same time so they can connect.</p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor682"/>Showing the IP address of the server</h2>
			<p>We have <a id="_idIndexMarker733"/>been using <code>::1</code> as the IP address that loops back to the same computer so that we can debug our game. However, before we can connect to another computer over a network, we need to know their real IP address. To do this, we’ll show the server’s IP address on the screen when they are hosting a game.</p>
			<div><div><img alt="Figure 11.28 – The server has an IP address displayed at the bottom of the screen to connect" src="img/B19358_11_28.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.28 – The server has an IP address displayed at the bottom of the screen to connect</p>
			<p>In <em class="italic">Figure 11</em><em class="italic">.28</em>, you can <a id="_idIndexMarker734"/>see that we want to show the IP address at the bottom of the screen. Let’s get to it:</p>
			<ol>
				<li>In the <code>main.tscn</code> scene, add <code>CenterContainer</code> with <code>Label</code> as a child, just like we did for the timer. Give them names like in <em class="italic">Figure 11</em><em class="italic">.29</em>.</li>
			</ol>
			<div><div><img alt="Figure 11.29 – The CanvasLayer node with NetworkUI" src="img/B19358_11_29.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.29 – The CanvasLayer node with NetworkUI</p>
			<ol>
				<li value="2">Now, in the <code>main.gd</code> script, cache <code>IPLabel</code> at the top:<pre class="source-code">
@onready var _ip_label = $CanvasLayer/NetworkUI/IPLabel</pre></li>				<li>Next, add this function that shows the local IP address:<pre class="source-code">
func show_local_ip_address():
   var addresses = []
   for ip in IP.get_local_addresses():
      if ip.begins_with("10.") or ip.begins_with("172.16.") or ip.begins_with("192.168."):
         addresses.push_back(ip)
   if not addresses.is_empty():
      _ip_label.text = addresses[0]</pre></li>				<li>Now, call <a id="_idIndexMarker735"/>this function in the <code>_ready()</code> function, but only if we’re running on the server:<pre class="source-code">
func _ready():
   if multiplayer.is_server():
      show_local_ip_address()
   # …</pre></li>			</ol>
			<p>Don’t worry too much about the implementation of the <code>show_local_ip_address()</code> function. The basis is that it will search for the local IP address by scanning all the network addresses of the current computer and saving the ones that start with <code>"10."</code>, <code>"172.16."</code>, or <code>"192.168."</code>, which are the know beginnings for local IP addresses. The reasons why it works are a little obscure and beyond the scope of this book.</p>
			<p>Now that we know what IP address the server has, let’s see how we can actually set everything up to connect two computers together.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor683"/>Connecting from another computer</h2>
			<p>The big <a id="_idIndexMarker736"/>caveat for now, which we already mentioned in the introduction of the chapter, is that we will not be able to play over the real worldwide internet. This is because of multiple security reasons; you wouldn’t want strangers to have direct access to your computer. However, we will be able to play on the same local network. This means that two computers that are connected to the same router, the same Wi-Fi network, and so forth, will be able to connect to each other in the game! All we’ll have to do is the following:</p>
			<ol>
				<li>Transfer the complete Godot project to another computer. You can do this any way you like. With a USB, using an online platform such as Dropbox, Google,<strong class="bold"> </strong>Drive, or any other means of transferring files.</li>
				<li>Make sure both computers are connected to the same local network.</li>
				<li>Open the project in the same Godot Engine version as you are using.</li>
				<li>Run a debug instance of the game on each computer.</li>
				<li>Press play on one computer, making it the server. Use the IP address the server displays to connect to the other clients.</li>
			</ol>
			<p>Now, you <a id="_idIndexMarker737"/>should be able to play together over the network!</p>
			<p>That is all for connecting multiple computers. We’ll proceed with a summary of the chapter, but first, here are some additional exercises to solidify our knowledge.</p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor684"/>Additional exercises – Sharpening the axe</h1>
			<ol>
				<li>When the game ended, we got a menu with a <code>add_player()</code> function for each pair that is connected in the <code>_ready()</code> function of the <code>main.gd</code> script. You can get a list of all the peer IDs with <code>multiplayer.get_peers()</code>.</li>
			</ol>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor685"/>Summary</h1>
			<p>The joy in playing video games is sharing the experience and nothing makes that easier than directly playing together!</p>
			<p>In this chapter, we started by taking a crash course in computer networking where we learned the basics of how computer networks, such as the internet, work. After this, we started to implement multiplayer into our own game using the <code>MultiplayerSpawner</code> and <code>MultiplayerSynchronizer</code> node. Lastly, we tried out playing the game over a real network.</p>
			<p>This chapter marks the end of <em class="italic">Part 2</em> of the book, where we focused on learning how to develop our game and doing so. Starting from the next chapter, we’ll learn how to export a game, go a little deeper into more advanced programming<a id="_idTextAnchor686"/> topics, and see how we can save or load the game.</p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor687"/>Quiz time</h1>
			<ul>
				<li>What is the difference between the TCP and UDP?</li>
				<li>If we take the example of a residence with flats, where the port number is the flat number, what does the IP address represent?</li>
				<li>What did we use <code>MultiplayerSpawner</code> for?</li>
				<li>What did we use <code>MultiplayerSynchronizer</code> for?</li>
				<li>What function would we use to check whether the current script is running on the server?</li>
			</ul>
		</div>
	

		<div><h1 id="_idParaDest-294" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor688"/>Part 3: Deepening Our Knowledge</h1>
		</div>
		<div><p>After learning how to program and creating your very own game from scratch, you will now take a step back and learn some more advanced programming and game development techniques.</p>
			<p>By the end of this final part, you will have exported and distributed your game to various different platforms on the web so that everyone can play it from within their browser. You will also learn more advanced OOP concepts and different programming patterns that will help you in your future game projects. Even the filesystem will be covered so that you can save and load data. The last chapter will guide you through the next steps to take, which resources you could consult to learn more, and how to join the game development community.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B19358_12.xhtml#_idTextAnchor689"><em class="italic">Chapter 12</em></a>, <em class="italic">Exporting to Multiple Platforms</em></li>
				<li><a href="B19358_13.xhtml#_idTextAnchor705"><em class="italic">Chapter 13</em></a>, <em class="italic">OOP Continued and Advanced Topics</em></li>
				<li><a href="B19358_14.xhtml#_idTextAnchor721"><em class="italic">Chapter 14</em></a>, <em class="italic">Advanced Programming Patterns</em></li>
				<li><a href="B19358_15.xhtml#_idTextAnchor740"><em class="italic">Chapter 15</em></a>, <em class="italic">Using the File System</em></li>
				<li><a href="B19358_16.xhtml#_idTextAnchor755"><em class="italic">Chapter 16</em></a>, <em class="italic">What Next?</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>