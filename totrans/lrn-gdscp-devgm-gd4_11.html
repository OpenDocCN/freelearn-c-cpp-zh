<html><head></head><body>
		<div id="_idContainer269">
			<h1 class="chapter-number" id="_idParaDest-267"><a id="_idTextAnchor660"/>11</h1>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor661"/>Playing Together  with Multiplayer</h1>
			<p>Playing games on your own is lots of fun. I’ve spent many hours exploring exotic worlds, acquiring new skills, and experiencing deep storylines on my own. But where games really shine, compared to other forms of media, is the ability for the player to create their own stories. Nothing lets players create their own story like letting them play with another real person. From cooperation and tense moments trying to help each other in games like World of Warcraft or Rocket League, to rivalry and intimidating each other in games like Call of Duty or Gran Turismo. Human behavior is still something that invokes more emotions than interacting with a complete <span class="No-Break">fictional world.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>A crash course in <span class="No-Break">computer networking</span></li>
				<li>Using the <strong class="source-inline">MultiplayerSynchronizer</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">MultiplayerSpawner</strong></span></li>
				<li>Running the game on <span class="No-Break">multiple computers</span></li>
			</ul>
			<p>In this chapter, we are going to implement networked multiplayer. This means that two people will be able to play together over the internet. Now, because of how networks work, and we still <a id="_idIndexMarker657"/>want to be safe, we’ll only be able to play over a <strong class="bold">local area network</strong> (<strong class="bold">LAN</strong>). This means that people who are connected to the same Wi-Fi network, for example, will be able to <span class="No-Break">play together.</span></p>
			<p>The reason why you don’t want to run a globally accessible server from your personal computer is quite simple: you don’t want the risk of people hacking your computer. Though there are ways to do this in a safe way, this is beyond the scope of <span class="No-Break">this book.</span></p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor662"/>Technical requirements</h1>
			<p>As for every chapter, you can find the final code on the GitHub repository in the subfolder for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter11"><span class="No-Break">https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter11</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor663"/>A crash course in computer networking</h1>
			<p>In this section, I would like to give you a brief crash course on computer networking. Because Godot does a lot out of the box, we don’t have to be complete networking wizards to <a id="_idIndexMarker658"/>implement simple multiplayer games. This means that you could skip this section and directly start with the actual implementation of the multiplayer nodes and code. However, I recommend reading on if you want at least some high-level explanation of why we do things the way we are going to <span class="No-Break">do them.</span></p>
			<p>Computers in networks talk to each other through a layered model. On the top level, there is the eventual application, the game. Our game needs to send information from one instance of the game, running on one computer, to another instance of the game, running on another computer, also called <strong class="bold">another machine</strong>. This top layer is called the <strong class="bold">Application Layer</strong>. In between <a id="_idIndexMarker659"/>these computers could be a vast network of interconnected servers, routers, and other networking infrastructure. This network <a id="_idIndexMarker660"/>is the lowest layer, called the <span class="No-Break"><strong class="bold">Physical Layer</strong></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer240">
					<img alt="Figure 11.1 – The seven layers of computer networking" src="image/B19358_11_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – The seven layers of computer networking</p>
			<p>Between the Application Layer and the Physical Layer, there are multiple other layers. These layers make sure that data is sent and received between all links in the chain that need to be taken to transmit this packet of data from Computer A to Computer B and each serves a <span class="No-Break">different purpose.</span></p>
			<p>Though Godot provides us with a great deal of flexibility, not every layer is equally important to us at the moment. Let’s take a closer look at two network layers: the Transport and <span class="No-Break">Application Layers.</span></p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor664"/>What is a Transport Layer?</h2>
			<p>The first layer <a id="_idIndexMarker661"/>we’ll look at is the <strong class="bold">Transport Layer</strong>, the fourth layer of <a id="_idIndexMarker662"/>computer networking. This layer is, among other things, responsible for deciding how to cut the data we want to send in smaller packages of data, making sure that packages of data are received from one end to the <span class="No-Break">other, uncorrupted.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer241">
					<img alt="Figure 11.2 – The Transport Layer is the fourth layer in computer networking" src="image/B19358_11_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – The Transport Layer is the fourth layer in computer networking</p>
			<p>To meet these responsibilities, different protocols have been invented that are able to take care of them with varying <a id="_idIndexMarker663"/>degrees of reliability. A <strong class="bold">protocol</strong> is basically a set of rules by which computers can communicate with <span class="No-Break">each other.</span></p>
			<p>For example, if we send out a package of data from Computer A to Computer B, we could just send it off and hope for the best. However, our package of data could accidentally get dropped somewhere within the vast internet. A server forgets to send it from one link to the other, a cable gets unplugged, or any other error <span class="No-Break">could happen.</span></p>
			<p>Now, how do we make sure that the data we send actually arrives? Well, we could ask for confirmation from the receiving computer. But what if that confirmation gets lost somewhere? Well, we could do a double confirmation, one from each participant in <span class="No-Break">the communication.</span></p>
			<p>All these rules just solve the problem of making sure a package of data gets sent and received, but there are many other problems that we need to overcome as well. You can see that these <a id="_idIndexMarker664"/>protocols quickly become complex. Luckily, smart people <a id="_idIndexMarker665"/>already thought about all of this <span class="No-Break">for us.</span></p>
			<p>In gaming, there are two main protocols that <span class="No-Break">are used:</span></p>
			<ul>
				<li><strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>): The TCP is a Transport Layer protocol <a id="_idIndexMarker666"/>that makes sure that every package that is sent will be received. But to achieve this, the protocol takes more time, sending confirmations back <span class="No-Break">and forth.</span></li>
				<li><strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>): The UDP is a Transport Layer protocol that does not <a id="_idIndexMarker667"/>care whether packages arrive or not. It just sends them over a connection in the hopes that they make it, which most of them should do. This is way faster than the TCP but <span class="No-Break">less reliable.</span></li>
			</ul>
			<p>Godot Engine can operate using either TCP or UDP and can even switch between the two for different kinds of data, depending on how important guaranteed delivery is. For our game, we will use both the UDP and TCP for different kinds <span class="No-Break">of data.</span></p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor665"/>What is an Application Layer?</h2>
			<p>The Application <a id="_idIndexMarker668"/>Layer is the highest layer in the networking layers. This is <a id="_idIndexMarker669"/>when we actually use the data that we received within the game. Additionally, here, we have a choice to make; even though we have the data, how are we going to organize the computers that we are <span class="No-Break">connected with?</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer242">
					<img alt="Figure 11.3 – The Application Layer is the seventh layer in computer networking" src="image/B19358_11_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – The Application Layer is the seventh layer in computer networking</p>
			<p>For games, there <a id="_idIndexMarker670"/>are two network architectures <a id="_idIndexMarker671"/>that prevail: peer-to-peer <span class="No-Break">or client-server.</span></p>
			<h3>Peer-to-peer network</h3>
			<p>In a peer-to-peer network, every computer can talk to any other computer and ask it things. They are <a id="_idIndexMarker672"/>all equals and peers. For example, Computer A could <a id="_idIndexMarker673"/>ask Computer B to tell at what location its player character is located. Computer B will then send over this data so that Computer A can show its user where the player character of Computer B is situated in the <span class="No-Break">game world.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer243">
					<img alt="Figure 11.4 – In a peer-to-peer network, each computer can talk to the other computers" src="image/B19358_11_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – In a peer-to-peer network, each computer can talk to the other computers</p>
			<p>This solution <a id="_idIndexMarker674"/>is pretty elegant because every computer is equal and <a id="_idIndexMarker675"/>has the same number of rights. However, we’ll also need to be vigilant because what if Computer B is used by a hacker and lies to the other computers? Instead of reporting the position of the player according to the game’s rules, Computer B gives positions that are impossible to reach; maybe they teleport its player character around. This is quite a problem. The next network architecture tries to tackle <span class="No-Break">this problem.</span></p>
			<h3>Client-server network</h3>
			<p>Instead of <a id="_idIndexMarker676"/>treating every computer as equal, we could have one of the <a id="_idIndexMarker677"/>computers as the center for all communication. Every time any of the computers in the network want information, such as the location of another computer’s player character, they’ll have to ask this central computer. The central computer will then answer for the <span class="No-Break">other computer.</span></p>
			<p>In this situation, we call the central computer the server, and the connected computers <span class="No-Break">the clients.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer244">
					<img alt="Figure 11.5 – In a client-server, network each computer talks to the server" src="image/B19358_11_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – In a client-server, network each computer talks to the server</p>
			<p>With this <a id="_idIndexMarker678"/>architecture, the server can check up <a id="_idIndexMarker679"/>on all clients and make sure none of them <span class="No-Break">are cheating.</span></p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor666"/>Networking in Godot Engine</h2>
			<p>Again, Godot Engine supports both peer-to-peer and client-server network architectures. To make it easier on ourselves, we’ll go with a client-server approach. This way, we can <a id="_idIndexMarker680"/>make sure that important parts of the <a id="_idIndexMarker681"/>game get run only on the server and our clients don’t have to worry about them. For example, considering counting the score – clients can easily lie about this, while now the server will be the only computer <span class="No-Break">keeping score.</span></p>
			<p>Alright, after this short introduction to computer networking, although there is still so much to learn, we have enough knowledge of the underlying structure that we can start implementing multiplayer in <span class="No-Break">our game.</span></p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor667"/>Learning about IP addresses</h2>
			<p>In real life, to send <a id="_idIndexMarker682"/>mail to another person, you need to know the address of <a id="_idIndexMarker683"/>their house. For computer networks, this is pretty much the same. To send messages between computers, we need to know their <strong class="bold">IP address</strong>. This is a unique address that makes sure you can find any computer connected to <span class="No-Break">the internet.</span></p>
			<p>Currently, there are two versions of IP addresses in use: <strong class="bold">IPv4</strong> and <strong class="bold">IPv6</strong>. An IPv4 address is comprised of 4 numbers ranging from <strong class="source-inline">0</strong> to <strong class="source-inline">255</strong> separated by a period, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
166.58.155.136</pre>			<p>This version is supposed to be able to have a unique address for 4.3 billion devices. But it turns out that humans have been so productive that 4.3 billion devices will probably not be enough! These days, almost any electrical device can be connected to the internet, even fridges, toasters, and watches. That is why we are slowly transitioning to IPv6 addresses, which support 340 undecillion devices. That is 340 <span class="No-Break">trillion devices.</span></p>
			<p>An IPv6 address looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
e9fd:da7d:474d:dedb:d152:dce2:1294:2560</pre>			<p>Depending on <a id="_idIndexMarker684"/>how your computer is connected to the internet, this IP address changes from time to time, so don’t depend on it being <span class="No-Break">the same.</span></p>
			<p>An IP address is <a id="_idIndexMarker685"/>a postal address we can send a letter to, but then, we still need to know to whom in the household the letter is addressed. In a computer network, a <strong class="bold">port</strong> is used to <a id="_idIndexMarker686"/>address the exact application within the computer. Let’s talk about <span class="No-Break">ports next.</span></p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor668"/>Using port numbers</h2>
			<p>An IP address, be it IPv4 or IPv6, only indicates where to send the data to. But computers have many applications that each need their own connection. So, from the moment the <a id="_idIndexMarker687"/>data is received, to which application do we send it? Well, each application can use different ports, which are like the different platforms in <a id="_idIndexMarker688"/>a train station. Although each train arrives at the same station, they arrive at <span class="No-Break">different platforms.</span></p>
			<p>Each application can choose a port, which is just a number from <strong class="source-inline">0</strong> to <strong class="source-inline">65535</strong>. However, the first 1,024 are reserved for standard computer functionality and we will not be able to <span class="No-Break">pick these.</span></p>
			<p>To specify which port to send data to, we can add the port number at the end of the IP address, behind <span class="No-Break">a colon:</span></p>
			<pre class="source-code">
166.58.155.136<strong class="bold">:5904</strong>
e9fd:da7d:474d:dedb:d152:dce2:1294:2560<strong class="bold">:5904</strong></pre>			<p>Here, we have an IPv4 and IPv6 address that directs to the port with the <span class="No-Break">number </span><span class="No-Break"><strong class="source-inline">5904</strong></span><span class="No-Break">.</span></p>
			<p>Now that we <a id="_idIndexMarker689"/>know about the basic mechanisms of computer networking, such as <a id="_idIndexMarker690"/>the different layers and how IP addresses work, we are able to start implementing multiplayer into our game. So, let’s give that <span class="No-Break">a shot!</span></p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor669"/>Setting up the base networking code</h1>
			<p>In the <em class="italic">A crash course in computer networking</em> section, we saw that we wanted to set up a client-server network architecture and that we could use IP addresses and ports to find computers <a id="_idIndexMarker691"/>over the internet. In this section, we’ll start <span class="No-Break">implementing this.</span></p>
			<p>We’re going to make our multiplayer game work like this: every time you start playing, it spins up a server in the background. This way, anyone can join after one person starts <span class="No-Break">the match.</span></p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor670"/>Creating the client-server connection</h2>
			<p>If we want to connect our players through a client-server model, we need to be able to set up one <a id="_idIndexMarker692"/>computer as a server and the others as clients that connect to this server. Let’s start by writing <span class="No-Break">some code.</span></p>
			<ol>
				<li>In the <strong class="source-inline">menu.gd</strong> script, add a constant at the top that indicates which port we want <span class="No-Break">to use:</span><pre class="source-code">
const PORT: int = 7890</pre></li>				<li>Now add these two functions to the bottom of <span class="No-Break">the script:</span><pre class="source-code">
func host_game():
   var peer = ENetMultiplayerPeer.new()
   peer.create_server(PORT)
   if peer.get_connection_status() == MultiplayerPeer.CONNECTION_DISCONNECTED:
      return
   multiplayer.multiplayer_peer = peer
func connect_to_game(ip_address: String):
   var peer = ENetMultiplayerPeer.new()
   peer.create_client(ip_address, PORT)
   if peer.get_connection_status() == MultiplayerPeer.CONNECTION_DISCONNECTED:
      return
   multiplayer.multiplayer_peer = peer</pre><p class="list-inset">The <strong class="source-inline">host_game()</strong> function will use the <strong class="source-inline">ENetMultiplayerPeer</strong> class to create a new server using the <strong class="source-inline">create_server()</strong> function that is defined on it. To create <a id="_idIndexMarker693"/>this server, we only have to specify on which port we want to receive the data. Once this is done, we check whether the connection status is disconnected; if we are not connected, then we need to return from the function. We can check the connection status using the <strong class="source-inline">get_connection_status()</strong> function on the <span class="No-Break"><strong class="source-inline">peer</strong></span><span class="No-Break"> object.</span></p></li>				<li>Lastly, we set this peer as <strong class="source-inline">multiplayer_peer</strong>, which is defined on the multiplayer <span class="No-Break">global variable.</span><p class="list-inset">The <strong class="source-inline">connect_to_game()</strong> function does largely the same but creates a client using the <strong class="source-inline">create_client()</strong> function on the <strong class="source-inline">ENetMultiplayerPeer</strong> <strong class="source-inline">peer</strong> object. The <strong class="source-inline">create_client()</strong> function takes an IP address and port. These will, of course, be the IP address and port of <span class="No-Break">the server.</span></p></li>
			</ol>
			<p>With these two functions in place, we can add some more UI to connect to the <span class="No-Break">right server.</span></p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor671"/>Adding UI</h2>
			<p>Now, for the menu, we want to be able to start a game that will set up a server or input an IP address <a id="_idIndexMarker694"/>to join an already hosted game. We won’t have to let the player choose a port, both because it’s less of a hassle for the player and because we don’t want them to accidentally choose an invalid port number. We, the programmers, decide we are going to use <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">7890</strong></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer245">
					<img alt="Figure 11.6 – The main menu with an input field to specify an IP address" src="image/B19358_11_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – The main menu with an input field to specify an IP address</p>
			<ol>
				<li>Open up the <span class="No-Break"><strong class="source-inline">menu.tscn</strong></span><span class="No-Break"> scene.</span></li>
				<li>Add a <strong class="source-inline">LineEdit</strong> node in <strong class="source-inline">VBoxContainer</strong>, which holds the play and exit buttons, and rename <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">IpAddressLineEdit</strong></span><span class="No-Break">.</span></li>
				<li>Place <strong class="source-inline">IpAddressLineEdit</strong> under the <strong class="source-inline">PlayButton</strong> node, but not as <span class="No-Break">a child.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer246">
					<img alt="Figure 11.7 – The main menu scene tree with the added IpAddressLineEdit" src="image/B19358_11_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – The main menu scene tree with the added IpAddressLineEdit</p>
			<ol>
				<li value="4">Select the <strong class="source-inline">IpAddressLineEdit</strong> node and set <strong class="bold">Placeholder Text</strong> to <strong class="source-inline">IP ADDRESS</strong>. This will <a id="_idIndexMarker695"/>show some placeholder text that will get replaced the moment the user puts anything into the <span class="No-Break">line edit.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer247">
					<img alt="Figure 11.8 – Setting Placeholder Text in a LineEdit node" src="image/B19358_11_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Setting Placeholder Text in a LineEdit node</p>
			<ol>
				<li value="5">Now, in the <strong class="source-inline">menu.gd</strong> script, cache the <strong class="source-inline">IpAddressLineEdit</strong> at <span class="No-Break">the top:</span><pre class="source-code">
@onready var _ip_address_line_edit = $CenterContainer/MainUIContainer/PanelContainer/MarginContainer/VBoxContainer/VBoxContainer/IpAddressLineEdit</pre></li>				<li>Lastly, we need to change the <strong class="source-inline">_on_play_button_pressed()</strong> function to host or connect to <span class="No-Break">a game:</span><pre class="source-code">
func _on_play_button_pressed():
   if _ip_address_line_edit.text.is_empty():
      host_game()
   else:
      connect_to_game(_ip_address_line_edit.text)
   get_tree().change_scene_to_file("res://screens/game/main.tscn")</pre></li>			</ol>
			<p>With all this in place, we have all that is needed to set up the client-server architecture. One computer <a id="_idIndexMarker696"/>will be the server and the others, the clients. Before we dive into the things we have to change in the code of the game itself, such as spawning playable characters for every person joining and then making sure the position of each player is synchronized between each computer, we can try out what we have <span class="No-Break">already created.</span></p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor672"/>Running multiple debug instances at the same time</h2>
			<p>To debug a multiplayer game, we need to be able to run our game multiple times in debug <a id="_idIndexMarker697"/>mode. Luckily, Godot Engine has a handy feature that allows us to run as many instances of our game as we want at the <span class="No-Break">same time.</span></p>
			<ol>
				<li>Click <strong class="bold">Debug</strong> in the top <span class="No-Break">menu bar.</span></li>
				<li>Under the <strong class="bold">Run Multiple Instances</strong> menu, choose <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">2 Instances</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer248">
					<img alt="Figure 11.9 – In the Debug dropdown menu, we set the number of instances we want to run" src="image/B19358_11_09.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – In the Debug dropdown menu, we set the number of instances we want to run</p>
			<ol>
				<li value="3">Run the project. This will make two instances of the game pop up at the <span class="No-Break">same time.</span></li>
				<li>In one instance, just press <strong class="bold">Play</strong>. The game should start <span class="No-Break">up normally.</span></li>
				<li>In the other instance, type <strong class="source-inline">::1</strong> in the IP address input field and then <span class="No-Break">press </span><span class="No-Break"><strong class="bold">Play</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer249">
					<img alt="Figure 11.10 – Specifying the ::1 IP address will loop back to the same computer" src="image/B19358_11_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – Specifying the ::1 IP address will loop back to the same computer</p>
			<p>Unfortunately, you won’t see anything special happen. We still need to account for multiple <a id="_idIndexMarker698"/>players in our game code, but normally, there should be no errors in the bottom <span class="No-Break"><strong class="bold">Debug</strong></span><span class="No-Break"> panel.</span></p>
			<p class="callout-heading">Local host IP address</p>
			<p class="callout">There is a special IP address that does not go to another computer but rather loops back to the same computer again. In the IPv6 format, this address is <strong class="source-inline">::1</strong>, and for IPv4, it <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">127.0.0.1</strong></span><span class="No-Break">.</span></p>
			<p>You’ll also see that there are now multiple tabs in the <strong class="bold">Debug</strong> panel, one for each instance of the game. This way, we will be able to debug <span class="No-Break">each separately.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer250">
					<img alt="Figure 11.11 – When running multiple instances, we’ll also have multiple Debug tabs" src="image/B19358_11_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – When running multiple instances, we’ll also have multiple Debug tabs</p>
			<p>Now that <a id="_idIndexMarker699"/>we are able to create a server and connect clients, let’s start by making our game multiplayer compatible and synchronizing spawned scenes between <span class="No-Break">both games.</span></p>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor673"/>Synchronizing different clients</h1>
			<p>Until now, we learned about computer networking and set up a connection between multiple instances <a id="_idIndexMarker700"/>of our game. The next step is to change the scenes and code within our game to account for multiple players. We want to accomplish <span class="No-Break">two things:</span></p>
			<ul>
				<li>Firstly, if the server instances a new scene, such as a new projectile, we want that scene to be instanced on <span class="No-Break">every client</span></li>
				<li>Secondly, we want to synchronize values, such as the position of each player character, between <span class="No-Break">all clients</span></li>
			</ul>
			<p>We’ll first look at which Godot Engine nodes can help us achieve these two goals while updating the player character to be used in multiplayer. After that, we’ll update the entity spawner, enemy, collectible, and projectile scenes, too. Most of these changes will be <span class="No-Break">quite small.</span></p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor674"/>Updating the player scene for multiplayer</h2>
			<p>Because the <a id="_idIndexMarker701"/>player is the most <a id="_idIndexMarker702"/>important entity in the game, let’s start by updating them for multiplayer. This way, we can quickly make sure everything is working <span class="No-Break">correctly, too.</span></p>
			<h3>Using MultiplayerSpawner to spawn player scenes</h3>
			<p>To <a id="_idIndexMarker703"/>synchronize instanced scenes between the server and the clients, Godot Engine has a node called <strong class="source-inline">MultiplayerSpawner</strong>. It will <a id="_idIndexMarker704"/>listen to the scenes that are getting added to the scene tree and will replicate them on each of the other clients, too. Let’s add one to the main <span class="No-Break">game scene:</span></p>
			<ol>
				<li>Open the <span class="No-Break"><strong class="source-inline">main.tscn</strong></span><span class="No-Break"> scene.</span></li>
				<li>Under the root <strong class="bold">Main</strong> node, add a <strong class="source-inline">MultiplayerSpawner</strong> node, and call it <strong class="source-inline">PlayerMultiplayerSpawner</strong>, because it will be spawning new <span class="No-Break">player characters.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer251">
					<img alt="Figure 11.12 – The main.tscn scene tree with an added PlayerMultiplayerSpawner" src="image/B19358_11_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – The main.tscn scene tree with an added PlayerMultiplayerSpawner</p>
			<ol>
				<li value="3">Now, in the inspector window for <strong class="source-inline">PlayerMultiplayerSpawner</strong>, press <strong class="bold">Add Element</strong> in <strong class="bold">Auto Spawn List</strong> and drag the <strong class="source-inline">player.tscn</strong> scene into <span class="No-Break">that element.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer252">
					<img alt="Figure 11.13 – Add the player.tscn scene as an element in PlayerMultiplayerSpawner" src="image/B19358_11_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – Add the player.tscn scene as an element in PlayerMultiplayerSpawner</p>
			<ol>
				<li value="4">Now, to <a id="_idIndexMarker705"/>specify positions at which our players can spawn, add <strong class="source-inline">Node2D</strong>, called <strong class="source-inline">PlayerStartPositions</strong>, under the <strong class="source-inline">Main</strong> node with different <strong class="source-inline">Marker2D</strong> nodes where we can spawn players. Place each marker at a good spot to start a <span class="No-Break">player from.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer253">
					<img alt="Figure 11.14 – The PlayerStartPositions node with Marker2D to spawn players at" src="image/B19358_11_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – The PlayerStartPositions node with Marker2D to spawn players at</p>
			<ol>
				<li value="5">In the <strong class="source-inline">main.gd</strong> script, we’ll cache the player scene in an export variable. So, add the following line of code at the top and drag the <strong class="source-inline">player.tscn</strong> scene into this export variable in the <span class="No-Break">inspector, too:</span><pre class="source-code">
@export var player_scene: PackedScene</pre></li>				<li>Also, cache the <strong class="source-inline">PlayerMultiplayerSpawner</strong> node in a variable called <strong class="source-inline">_player_multiplayer_spawner</strong> and <strong class="source-inline">PlayerStartPositions</strong> in a variable <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">_player_start_positions</strong></span><span class="No-Break">:</span><pre class="source-code">
@onready var _player_multiplayer_spawner: MultiplayerSpawner = $PlayerMultiplayerSpawner
@onready var _player_start_positions: Node2D = $PlayerStartPositions</pre></li>				<li>We’ll also add a variable at the top of the script that specifies what position we will spawn the next player at. With this variable, we will select which <strong class="source-inline">Marker2D</strong> to use as to location to spawn each <span class="No-Break">player at:</span><pre class="source-code">
<strong class="bold">var _player_spawn_index: int = 0</strong></pre></li>				<li>Now, we’ll <a id="_idIndexMarker706"/>add two functions to spawn new players in the <span class="No-Break"><strong class="source-inline">main.gd</strong></span><span class="No-Break"> script:</span><pre class="source-code">
func add_player(id: int):
   _player_multiplayer_spawner.spawn(id)
func spawn_player(id: int):
   var player: Player = player_scene.instantiate()
   player.multiplayer_id = id
   player.died.connect(_on_player_died)
   var spawn_marker: Marker2D = _player_start_positions.get_childr(_player_spawn_index)
   player.position = spawn_marker.position
   _player_spawn_index = (_player_spawn_index + 1) % _player_start_positions.get_child_count()
   return player</pre></li>				<li>To use these functions, we’ll add a <strong class="source-inline">_ready()</strong> function to the <span class="No-Break"><strong class="source-inline">main.gd</strong></span><span class="No-Break"> script:</span><pre class="source-code">
func _ready():
   _player_multiplayer_spawner.spawn_function = spawn_player
   if multiplayer.is_server():
      multiplayer.peer_connected.connect(add_player)
      add_player(1)</pre></li>				<li>Lastly, but <a id="_idIndexMarker707"/>very importantly, delete the <strong class="source-inline">Player</strong> node that is already in the <strong class="source-inline">main.tscn</strong> scene. We do this because we’ll spawn each player character from code and so they don’t need the node to be in <span class="No-Break">there already.</span></li>
			</ol>
			<p>In the <strong class="source-inline">add_player()</strong> function, we simply ask <strong class="source-inline">_player_multiplayer_spawner</strong> to spawn a new instance of the <span class="No-Break">player scene.</span></p>
			<p>Then, in the <strong class="source-inline">spawn_player()</strong> function, which will be used by the <strong class="source-inline">PlayerMultiplayerSpawner</strong> to spawn new <strong class="source-inline">Player</strong> scenes, we instantiate a new player scene and set its <strong class="source-inline">multiplayer_id</strong> property to the  ID that we received as a parameter. This ID is used to determine which client owns that particular player node. We’ll use it in the next section. Afterward, we must return the new player instance so that the <strong class="source-inline">PlayerMultiplayerSpawner</strong> can handle the rest <span class="No-Break">for us.</span></p>
			<p>We use the <strong class="source-inline">_player_spawn_index</strong> variable to select which <strong class="source-inline">Marker2D</strong> to select in <strong class="source-inline">PlayerStartPositions</strong>. After each player spawned, we increment this variable with <strong class="source-inline">1</strong> and make sure it loops back around with the <strong class="source-inline">%</strong> operator. This makes sure that we don’t spawn players on top of <span class="No-Break">each other.</span></p>
			<p>In the <strong class="source-inline">_ready()</strong> function, first, we set <strong class="source-inline">spawn_function</strong> for <strong class="source-inline">_player_multiplayer_spawner</strong> to be the <strong class="source-inline">spawn_player()</strong> function that we defined. This way, the multiplayer spawner knows how to create new instances of the <span class="No-Break">player scene.</span></p>
			<p>Then, you see that we check the <strong class="source-inline">multiplayer</strong> object if this code is being run on the server, using <strong class="source-inline">multiplayer.is_server()</strong>. This <strong class="source-inline">is_server()</strong> function returns <strong class="source-inline">true</strong> if the code is run on <span class="No-Break">the server.</span></p>
			<p>If we are running on the server, we do <span class="No-Break">the following:</span></p>
			<pre class="source-code">
multiplayer.peer_connected.connect(add_player)</pre>			<p><strong class="source-inline">peer_connected</strong> is a signal that is thrown by the <strong class="source-inline">multiplayer</strong> object when a new peer (a new client) connects to the server. Instead of connecting through the editor, like we used to do for detecting whether the player is close to the collectibles, we directly call the <strong class="source-inline">connect()</strong> function on this signal and pass along the function that we want to execute when a player connects to the server, which is the <span class="No-Break"><strong class="source-inline">add_player()</strong></span><span class="No-Break"> function.</span></p>
			<p>After <a id="_idIndexMarker708"/>connecting to the <strong class="source-inline">peer_connected</strong> signal, we call the <strong class="source-inline">add_player()</strong> function with <strong class="source-inline">1</strong> as <strong class="source-inline">id</strong>, which is the default ID for <span class="No-Break">the server.</span></p>
			<p>We will not yet be able to run the game for now, first, we need to update the <span class="No-Break">player scene.</span></p>
			<h3>Updating the player code for multiplayer</h3>
			<p>When you try running the game with multiple instances at the end of the last section, you will notice <a id="_idIndexMarker709"/>that there are some things off, mainly that, on each client separately, you control both players at the <span class="No-Break">same time.</span></p>
			<p>This behavior happens because, although we spawn a player per client, all code gets run all the time on each client separately. We have to specify that the movement code for each player character should only be run on the client associated with that player character, not all at once on all clients. Afterward, we should synchronize the position to <span class="No-Break">the server.</span></p>
			<p>We’ll do this by <a id="_idIndexMarker710"/>setting the <strong class="bold">multiplayer authority</strong> of the player character node. This authority “owns” this node and decides how <span class="No-Break">it behaves.</span></p>
			<p>So, let’s alter our code so the players <span class="No-Break">work properly:</span></p>
			<ol>
				<li>Firstly, add the <strong class="source-inline">multiplayer_id</strong> variable that we used in the last section somewhere at the top of the <span class="No-Break"><strong class="source-inline">player.gd</strong></span><span class="No-Break"> script:</span><pre class="source-code">
var multiplayer_id: int</pre></li>				<li>Add an <strong class="source-inline">_enter_tree()</strong> function; this function is a life cycle function that gets called when the node enters the tree, right before the <strong class="source-inline">_ready()</strong> function. In this function, we set the multiplayer authority to the client that has the same ID as <strong class="source-inline">multiplayer_id</strong> of this <span class="No-Break">player node:</span><pre class="source-code">
func _enter_tree():
   set_multiplayer_authority(multiplayer_id)</pre></li>				<li>Cache the <strong class="source-inline">CameraPosition</strong> node at the top of <span class="No-Break">the script:</span><pre class="source-code">
@onready var _camera_position: Node2D = $CameraPosition</pre></li>				<li>Now, update the <strong class="source-inline">_ready()</strong> function <span class="No-Break">like this:</span><pre class="source-code">
func _ready():
   update_health_label()
<strong class="bold">   if not multiplayer.is_server():</strong>
<strong class="bold">      _shoot_timer.stop()</strong>
<strong class="bold">   if not is_multiplayer_authority():</strong>
<strong class="bold">      _camera_position.queue_free()</strong>
<strong class="bold">      set_physics_process(false))</strong></pre></li>			</ol>
			<p>In <em class="italic">step 2</em>, we set the multiplayer authority for a node, which means that we determine which client is <a id="_idIndexMarker711"/>the owner of this node. For most nodes in multiplayer, the server should be the owner. But the player character is so important to each client that we give the authority of each to their <span class="No-Break">respective client.</span></p>
			<p>After that, we use <strong class="source-inline">multiplayer.is_server()</strong> to stop <strong class="source-inline">_shoot_timer</strong> when we are not running on the server. This way, we make sure that projectiles only get spawned on the server side and replicated to all clients <span class="No-Break">from there.</span></p>
			<p>Next, we use <strong class="source-inline">is_multiplayer_authority()</strong> to check whether we are the authority of this specific player node. If we are not, we free <strong class="source-inline">_camera_position</strong>. We don’t need multiple cameras, only the one that is used to track the player we want to see, and we also disable the <strong class="source-inline">_physics_process()</strong> function. Only the client that owns this node will have to calculate this player’s position and then report back to the server where the <span class="No-Break">player is.</span></p>
			<p class="callout-heading">Disabling the _process() and _physics_process() functions</p>
			<p class="callout">By default, the <strong class="source-inline">_process()</strong> and <strong class="source-inline">_physics_process()</strong> functions get called on each frame and physics frames, respectively. However, we can choose to enable or disable them manually by calling <strong class="source-inline">set_process()</strong> and <strong class="source-inline">set_physics_process()</strong> along with a Boolean that says whether they should run <span class="No-Break">or not.</span></p>
			<p>After all this, you can <a id="_idIndexMarker712"/>run the game with multiple instances, like we saw in the <em class="italic">Running multiple debug instances at the same time</em> section, and you should see a second player spawn! Each player is able to move properly, but their positions are unfortunately not synchronized. We’ll do <span class="No-Break">that next.</span></p>
			<h3>Synchronizing the players’ positions and health</h3>
			<p>We can spawn scenes across clients and determine on which client certain pieces of code <a id="_idIndexMarker713"/>should run. The last piece of the puzzle is to synchronize certain variables, like the position and health of our players. Luckily, this is actually very easy to do using the <strong class="source-inline">MultiplayerSynchronizer</strong> node. We are going to use two of these, one for the position and one for the health. Although one synchronizer can synchronize multiple variables, we want the position to be managed by each client individually and the health to be managed by <span class="No-Break">the server:</span></p>
			<ol>
				<li>In the <strong class="source-inline">player.tscn</strong> scene, add two <strong class="source-inline">MultiplayerSynchronizer</strong> nodes under the root <strong class="source-inline">Player</strong> node. Call on <strong class="source-inline">PositionMultiplayerSynchronizer</strong> and the <span class="No-Break">other </span><span class="No-Break"><strong class="source-inline">HealthMultiplayerSynchronizer</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer254">
					<img alt="Figure 11.15 – The player.tscn scene tree after adding two MultiplayerSynchronizer nodes" src="image/B19358_11_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15 – The player.tscn scene tree after adding two MultiplayerSynchronizer nodes</p>
			<ol>
				<li value="2">Select <strong class="source-inline">PositionMultiplayerSynchronizer</strong> and a new panel should appear <a id="_idIndexMarker714"/>at the bottom of <span class="No-Break">the editor.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer255">
					<img alt="Figure 11.16 – The Replication panel that opens up when selecting MultiplayerSynchronizer" src="image/B19358_11_16.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16 – The Replication panel that opens up when selecting MultiplayerSynchronizer</p>
			<ol>
				<li value="3">Here, press <strong class="bold">+ Add property </strong><span class="No-Break"><strong class="bold">to synchronize</strong></span><span class="No-Break">.</span></li>
				<li>Select the <strong class="source-inline">Player</strong> node and <span class="No-Break">press </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer256">
					<img alt="Figure 11.17 – Select the Player node to synchronize one of its values" src="image/B19358_11_17.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.17 – Select the Player node to synchronize one of its values</p>
			<ol>
				<li value="5">Now, search <a id="_idIndexMarker715"/>for the <strong class="source-inline">position</strong> property and <span class="No-Break">press </span><span class="No-Break"><strong class="bold">Open</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer257">
					<img alt="Figure 11.18 – Select the position property to synchronize its value" src="image/B19358_11_18.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.18 – Select the position property to synchronize its value</p>
			<ol>
				<li value="6">Do <em class="italic">steps 2</em> to <em class="italic">5</em> again but add the <strong class="source-inline">health</strong> property to <strong class="source-inline">HealthMultiplayerSynchronizer</strong> <span class="No-Break">this time.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer258">
					<img alt="Figure 11.19 – The Replication panel tracking the position value of the Player node" src="image/B19358_11_19.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.19 – The Replication panel tracking the position value of the Player node</p>
			<ol>
				<li value="7">Now, update the <strong class="source-inline">_enter_tree()</strong> function of the player so that we give the multiplayer <a id="_idIndexMarker716"/>authority of <strong class="source-inline">HealthMultiplayerSpawner</strong> to <span class="No-Break">the server:</span><pre class="source-code">
func _enter_tree() -&gt; void:
   set_multiplayer_authority(multiplayer_id)
   <strong class="bold">$HealthMultiplayerSynchronizer.set_multiplayer_authority(1)</strong></pre><p class="list-inset">Remember that the multiplayer ID of the server is always <strong class="source-inline">1</strong>. So, to give the authority to the server, we set the multiplayer authority of <strong class="source-inline">HealthMultiplayerSynchronizer</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></p></li>			</ol>
			<p>That is all we need to do to synchronize values between different clients. <strong class="source-inline">MultiplayerSynchronizer</strong> simply tracks them <span class="No-Break">for us.</span></p>
			<p>Running two instances of the game and connecting them finally shows that if we move one player character in one client, it also moves that player character in the <span class="No-Break">other client.</span></p>
			<p>Now that we updated the hardest scene to multiplayer, the player scene, we have all the knowledge to do the same for the remaining scenes. Let’s dive in so that we have a complete multiplayer game at <span class="No-Break">the end!</span></p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor675"/>Synchronizing EntitySpawner</h2>
			<p>To make sure the enemy and health potion scenes are spawned on each client when the entity <a id="_idIndexMarker717"/>spawner wants to, we’ll have to make a few little adjustments to the <span class="No-Break"><strong class="source-inline">EnitySpawner</strong></span><span class="No-Break"> scene:</span></p>
			<ol>
				<li>In the <strong class="source-inline">entity_spawner.tscn</strong> scene, add a <span class="No-Break"><strong class="source-inline">MultiplayerSpawner</strong></span><span class="No-Break"> node.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer259">
					<img alt="Figure 11.20 – The EntitySpawner scene tree after adding MultiplayerSpawner" src="image/B19358_11_20.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.20 – The EntitySpawner scene tree after adding MultiplayerSpawner</p>
			<ol>
				<li value="2">In the <strong class="source-inline">entity_spawner.gd</strong> script, cache the <span class="No-Break"><strong class="source-inline">MultiplayerSpawner</strong></span><span class="No-Break"> node:</span><pre class="source-code">
@onready var _multiplayer_spawner = $MultiplayerSpawner</pre></li>				<li>Then, in the <strong class="source-inline">_ready()</strong> function, let’s add the scene this spawner uses to this <strong class="source-inline">MultiplayerSpawner</strong> node and only start the timer if we are running on the server. This ensures that not every client is spawning new entities, only <span class="No-Break">the server:</span><pre class="source-code">
func _ready():
<strong class="bold">   _multiplayer_spawner.add_spawnable_scene(entity_scene.resource_path)</strong>
   <strong class="bold">if multiplayer.is_server():</strong>
      start_timer()</pre></li>				<li>One last thing we need to do is change the exact way we add the <strong class="source-inline">new_entity</strong> to the scene. So, change the line with <strong class="source-inline">add_child(new_entity)</strong> to <span class="No-Break">the following:</span><pre class="source-code">
add_child(new_entity<strong class="bold">, true</strong>)</pre></li>			</ol>
			<p>In <em class="italic">step 3</em>, we add a spawnable scene to the <strong class="source-inline">MultiplayerSpawner</strong> node. This is very convenient as now we can add any scene on <span class="No-Break">the fly.</span></p>
			<p>In <em class="italic">step 4</em>, we supply the Boolean <strong class="source-inline">true</strong> as a second parameter to the <strong class="source-inline">add_child()</strong> function, next to the node that we want to add to the scene tree. This indicates that we want to use <a id="_idIndexMarker718"/>human-readable names for each node, names that are easy for humans to read. When we don’t set this Boolean to <strong class="source-inline">true</strong>, the engine will pick a name for the node. These names look like <strong class="source-inline">@Node2D@2</strong>. These are reserved names that cannot be synchronized using a <strong class="source-inline">MultiplayerSpawner</strong> node. When we do set this Boolean to <strong class="source-inline">true</strong>, each new instance gets nicely named, for example, <strong class="source-inline">Enemy2</strong>, <strong class="source-inline">Enemy3</strong>, and so on. In a multiplayer scenario, this is important for the server to properly synchronize scenes and values <span class="No-Break">between them.</span></p>
			<p>Now that we can synchronize the spawned entities of enemies and collectibles between clients, let’s synchronize their <span class="No-Break">behavior, too.</span></p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor676"/>Synchronizing the enemy and collectibles</h2>
			<p>For both <a id="_idIndexMarker719"/>the enemy and all collectibles, making them work with multiplayer is quite easy <span class="No-Break">and straightforward:</span></p>
			<ol>
				<li>Add <strong class="source-inline">MultiplayerSynchronizer</strong> to the <strong class="source-inline">enemy.tscn</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">collectible.tscn</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer260">
					<img alt="Figure 11.21 – The scene tree of the Collectible after adding MultiplayerSynchronizer" src="image/B19358_11_21.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.21 – The scene tree of the Collectible after adding MultiplayerSynchronizer</p>
			<ol>
				<li value="2">Now, add the <strong class="source-inline">position</strong> property of the root node in the <strong class="bold">Replication</strong> menu at <span class="No-Break">the bottom.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer261">
					<img alt="Figure 11.22 – The Replication panel tracking the position of the Collectible node" src="image/B19358_11_22.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.22 – The Replication panel tracking the position of the Collectible node</p>
			<p>That is <a id="_idIndexMarker720"/>about it for <strong class="source-inline">Collectible</strong>, while for <strong class="source-inline">Enemy</strong>, we need to do some last things in <span class="No-Break">the code:</span></p>
			<ol>
				<li>Cache <strong class="source-inline">PlayerDetectionArea</strong> at the top of the <span class="No-Break"><strong class="source-inline">enemy.gd</strong></span><span class="No-Break"> script:</span><pre class="source-code">
@onready var _player_detection_area: Area2D = $PlayerDetectionArea</pre></li>				<li>Now, update the <strong class="source-inline">_ready()</strong> function <span class="No-Break">like this:</span><pre class="source-code">
func _ready():
   <strong class="bold">if not multiplayer.is_server():</strong>
      <strong class="bold">set_physics_process(false)</strong>
      <strong class="bold">_player_detection_area.monitoring = false</strong>
      <strong class="bold">return</strong>
   var player_nodes: Array = get_tree().get_nodes_in_group("player")
   if not player_nodes.is_empty():
      target = <strong class="bold">player_nodes.pick_random()</strong></pre></li>			</ol>
			<p>The first thing we do in the <strong class="source-inline">_ready()</strong> function of the enemy is disable the <strong class="source-inline">_physics_process()</strong> function and <strong class="source-inline">_player_detection_area</strong> if we are not running them from the server. This makes sure that enemies are fully controlled by <span class="No-Break">the server.</span></p>
			<p>The <strong class="source-inline">Area2D</strong> nodes have a property, <strong class="source-inline">monitoring</strong>, that stops looking for collisions with other areas or bodies when set to <strong class="source-inline">false</strong>. This is what we are using here to disable <strong class="source-inline">_player_detection_area</strong> on other clients than <span class="No-Break">the server.</span></p>
			<p>Lastly, we <a id="_idIndexMarker721"/>want to be able to target any of the players in the game, so we change how to target a player. The <strong class="source-inline">pick_random()</strong> function on an array will pick any element within that array at random and return it. This is ideal for picking a random player within <span class="No-Break">the scene!</span></p>
			<p>Let’s now look at how we can synchronize <span class="No-Break">the projectiles.</span></p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor677"/>Synchronizing the projectile</h2>
			<p>The last <a id="_idIndexMarker722"/>scene we need to synchronize between the multiple clients is the one of the projectiles. So, let’s do that with the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>In the <strong class="source-inline">projectile.tscn</strong> scene, <span class="No-Break">add </span><span class="No-Break"><strong class="source-inline">MultiplayerSynchronizer</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer262">
					<img alt="Figure 11.23 – The scene tree of Projectile after adding MultiplayerSynchronizer" src="image/B19358_11_23.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.23 – The scene tree of Projectile after adding MultiplayerSynchronizer</p>
			<ol>
				<li value="2">This time, synchronize both the <strong class="source-inline">position</strong> and <span class="No-Break"><strong class="source-inline">rotation</strong></span><span class="No-Break"> properties.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer263">
					<img alt="Figure 11.24 – The Replication panel tracking the position and rotation of the Projectile node" src="image/B19358_11_24.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.24 – The Replication panel tracking the position and rotation of the Projectile node</p>
			<p class="list-inset">Cache <strong class="source-inline">EnemyDetectionArea</strong> at the top of the <span class="No-Break"><strong class="source-inline">projectile.gd</strong></span><span class="No-Break"> script:</span></p>
			<pre class="source-code">
@onready var _enemy_detection_area: Area2D = $EnemyDetectionArea</pre>			<ol>
				<li value="3">Now, add a <strong class="source-inline">_ready()</strong> function <span class="No-Break">as follows:</span><pre class="source-code">
func _ready():
   if not multiplayer.is_server():
      set_physics_process(false)
      _enemy_detection_area.monitoring = false</pre></li>				<li>We need <a id="_idIndexMarker723"/>to change the way the projectile is added to the scene within the <strong class="source-inline">player.gd</strong> script from <strong class="source-inline">get_parent().add_child(new_projectile)</strong> to <span class="No-Break">the following:</span><pre class="source-code">
get_parent().add_child(new_projectile<strong class="bold">, true</strong>)</pre></li>			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">Remember that the last parameter of the <strong class="source-inline">add_child()</strong> function is a Boolean that determines that the name of the new node should be <span class="No-Break">human readable.</span></p>
			<ol>
				<li value="5">Lastly, we need to make sure that the <strong class="source-inline">projectile.tscn</strong> scene is replicated in the main scene, just like we did for the <strong class="source-inline">player.tscn</strong> scene. Add a <strong class="source-inline">MultiplayerSpawner</strong> node in the <strong class="source-inline">main.tscn</strong>, call it <strong class="source-inline">ProjectileMultiplayerSpawner</strong>, and add <strong class="source-inline">projectile.tscn</strong> in <strong class="bold">Auto </strong><span class="No-Break"><strong class="bold">Spawn List</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer264">
					<img alt="Figure 11.25 – Main scene with ProjectilMultiplayerSpawner with the projectile.tscn scene" src="image/B19358_11_25.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.25 – Main scene with ProjectilMultiplayerSpawner with the projectile.tscn scene</p>
			<p>That is it <a id="_idIndexMarker724"/>for the <strong class="source-inline">Projectile</strong> scene and thereby all the scenes important to playing the game itself! You can now run multiple instances of the game and everything within the game should be synchronized. The last thing we’ll need to look at is synchronizing the timers within the game and the game-over menu for <span class="No-Break">both players.</span></p>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor678"/>Fixing the timer and end game</h1>
			<p>The last thing <a id="_idIndexMarker725"/>we need to adjust for multiplayer is the timer that times our <a id="_idIndexMarker726"/>run and the end of the game, stopping the entity spawners and showing the game-over menu. So, let’s get started on this <span class="No-Break">last effort.</span></p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor679"/>Synchronizing the timer</h2>
			<p>To synchronize <a id="_idIndexMarker727"/>the score timer, we simply have to do the following <span class="No-Break">three things:</span></p>
			<ol>
				<li>Add <strong class="source-inline">MultiplayerSynchronizer</strong> to the <span class="No-Break"><strong class="source-inline">main.tscn</strong></span><span class="No-Break"> scene.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer265">
					<img alt="Figure 11.26 – The Main scene tree after adding MultiplayerSynchronizer" src="image/B19358_11_26.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.26 – The Main scene tree after adding MultiplayerSynchronizer</p>
			<ol>
				<li value="2">Synchronize <a id="_idIndexMarker728"/>the <strong class="source-inline">_time</strong> property of the <span class="No-Break"><strong class="source-inline">Main</strong></span><span class="No-Break"> node.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer266">
					<img alt="Figure 11.27 – The Replication panel tracking the _time property of the Main node" src="image/B19358_11_27.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.27 – The Replication panel tracking the _time property of the Main node</p>
			<ol>
				<li value="3">Now, disable the <strong class="source-inline">_process()</strong> function from within <strong class="source-inline">_ready()</strong> if we are not running on <span class="No-Break">the server:</span><pre class="source-code">
func _ready():
   # Other code
   <strong class="bold">if not multiplayer.is_server():</strong>
      set_process(false)</pre></li>			</ol>
			<p>That is all we need to do synchronize the timer across <span class="No-Break">all clients.</span></p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor680"/>Synchronizing the end of the game</h2>
			<p>To make <a id="_idIndexMarker729"/>sure that when the game ends, it ends for all clients, let’s do <span class="No-Break">the following:</span></p>
			<ol>
				<li>In the <strong class="source-inline">main.gd</strong> script, let’s connect to each player character’s <strong class="source-inline">died</strong> signal in the <span class="No-Break"><strong class="source-inline">add_player()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func add_player(id: int):
   var player: Player = player_scene.instantiate()
   player.name = str(id)
   add_child(player)
   <strong class="bold">player.died.connect(_on_player_died)</strong></pre></li>				<li>Now, change the <strong class="source-inline">_on_player_died()</strong> function and add a new <span class="No-Break"><strong class="source-inline">end_game()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func _on_player_died() -&gt; void:
   end_game.rpc()
@rpc("authority", "reliable", "call_local")
func end_game():
   _game_over_menu.show()
   _enemy_spawner.stop_timer()
   _health_potion_spawner.stop_timer()
   set_process(false)
   Highscore.set_new_highscore(_time)</pre></li>				<li>Then, in the <strong class="source-inline">menu.gd</strong> script, change the <strong class="source-inline">_ready()</strong> function to <span class="No-Break">the following:</span><pre class="source-code">
func _ready():
   _highscore_label.text = "Highscore: " + str(Highscore.highscore)
<strong class="bold">   if multiplayer.has_multiplayer_peer():</strong>
<strong class="bold">      multiplayer.multiplayer_peer.close()</strong></pre></li>			</ol>
			<p>In the first <a id="_idIndexMarker730"/>step, we simply connect to each player’s <strong class="source-inline">died</strong> signal <span class="No-Break">through code.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that only the server connects to the <strong class="source-inline">died</strong> signal because it is the server that manages the <span class="No-Break">game loop.</span></p>
			<p>In the second step, we do something very interesting. We call the <strong class="source-inline">end_game()</strong> function through <strong class="bold">RPC</strong>, which means that we call it on every client at the <span class="No-Break">same time!</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="bold">Remote procedure call</strong> (<strong class="bold">RPC</strong>) is a protocol that makes functions directly callable over different clients. This makes it easy to execute the same code on all connected instances of the game at the <span class="No-Break">same time.</span></p>
			<p>You can see that we use the <strong class="source-inline">@rpc</strong> annotation right before the <strong class="source-inline">end_game()</strong> function. This is to indicate how we would like this function to be handled when calling on every client at once. The strings we pass it along mean <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">"authority"</strong>: Only the one with authority, the server, in this case, can call <span class="No-Break">this function.</span></li>
				<li><strong class="source-inline">"reliable"</strong>: We want this command to be sent reliably over the network, <span class="No-Break">using TCP.</span></li>
				<li><strong class="source-inline">"</strong><strong class="source-inline">call_local"</strong>: This function, when called, should be executed on all clients, including the one that <span class="No-Break">called it.</span></li>
			</ul>
			<p>This means that the game-over menu will be shown on every client from the moment one of the <span class="No-Break">players dies.</span></p>
			<p>In the third step, we simply close the multiplayer connection, when there is one, and we open up the <a id="_idIndexMarker731"/>main menu. This way, we make sure we don’t stay connected while we are not <span class="No-Break">playing anymore.</span></p>
			<p>Now that the whole game is ready to be played in multiplayer, let’s get started on actually running it on multiple machines at the <span class="No-Break">same time!</span></p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor681"/>Running the game on multiple computers</h1>
			<p>Until this point, we’ve been running multiple instances of our game on the same machine. But the <a id="_idIndexMarker732"/>strength of multiplayer comes from playing with multiple people over <span class="No-Break">multiple machines.</span></p>
			<p>In this section, we’ll start off by showing the server’s IP address on screen and then look into how we can run a debug instance on multiple computers at the same time so they <span class="No-Break">can connect.</span></p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor682"/>Showing the IP address of the server</h2>
			<p>We have <a id="_idIndexMarker733"/>been using <strong class="source-inline">::1</strong> as the IP address that loops back to the same computer so that we can debug our game. However, before we can connect to another computer over a network, we need to know their real IP address. To do this, we’ll show the server’s IP address on the screen when they are hosting <span class="No-Break">a game.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer267">
					<img alt="Figure 11.28 – The server has an IP address displayed at the bottom of the screen to connect" src="image/B19358_11_28.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.28 – The server has an IP address displayed at the bottom of the screen to connect</p>
			<p>In <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.28</em>, you can <a id="_idIndexMarker734"/>see that we want to show the IP address at the bottom of the screen. Let’s get <span class="No-Break">to it:</span></p>
			<ol>
				<li>In the <strong class="source-inline">main.tscn</strong> scene, add <strong class="source-inline">CenterContainer</strong> with <strong class="source-inline">Label</strong> as a child, just like we did for the timer. Give them names like in <span class="No-Break"><em class="italic">Figure 11</em></span><span class="No-Break"><em class="italic">.29</em></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer268">
					<img alt="Figure 11.29 – The CanvasLayer node with NetworkUI" src="image/B19358_11_29.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.29 – The CanvasLayer node with NetworkUI</p>
			<ol>
				<li value="2">Now, in the <strong class="source-inline">main.gd</strong> script, cache <strong class="source-inline">IPLabel</strong> at <span class="No-Break">the top:</span><pre class="source-code">
@onready var _ip_label = $CanvasLayer/NetworkUI/IPLabel</pre></li>				<li>Next, add this function that shows the local <span class="No-Break">IP address:</span><pre class="source-code">
func show_local_ip_address():
   var addresses = []
   for ip in IP.get_local_addresses():
      if ip.begins_with("10.") or ip.begins_with("172.16.") or ip.begins_with("192.168."):
         addresses.push_back(ip)
   if not addresses.is_empty():
      _ip_label.text = addresses[0]</pre></li>				<li>Now, call <a id="_idIndexMarker735"/>this function in the <strong class="source-inline">_ready()</strong> function, but only if we’re running on <span class="No-Break">the server:</span><pre class="source-code">
func _ready():
   if multiplayer.is_server():
      show_local_ip_address()
   # …</pre></li>			</ol>
			<p>Don’t worry too much about the implementation of the <strong class="source-inline">show_local_ip_address()</strong> function. The basis is that it will search for the local IP address by scanning all the network addresses of the current computer and saving the ones that start with <strong class="source-inline">"10."</strong>, <strong class="source-inline">"172.16."</strong>, or <strong class="source-inline">"192.168."</strong>, which are the know beginnings for local IP addresses. The reasons why it works are a little obscure and beyond the scope of <span class="No-Break">this book.</span></p>
			<p>Now that we know what IP address the server has, let’s see how we can actually set everything up to connect two <span class="No-Break">computers together.</span></p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor683"/>Connecting from another computer</h2>
			<p>The big <a id="_idIndexMarker736"/>caveat for now, which we already mentioned in the introduction of the chapter, is that we will not be able to play over the real worldwide internet. This is because of multiple security reasons; you wouldn’t want strangers to have direct access to your computer. However, we will be able to play on the same local network. This means that two computers that are connected to the same router, the same Wi-Fi network, and so forth, will be able to connect to each other in the game! All we’ll have to do is <span class="No-Break">the following:</span></p>
			<ol>
				<li>Transfer the complete Godot project to another computer. You can do this any way you like. With a USB, using an online platform such as Dropbox, Google,<strong class="bold"> </strong>Drive, or any other means of <span class="No-Break">transferring files.</span></li>
				<li>Make sure both computers are connected to the same <span class="No-Break">local network.</span></li>
				<li>Open the project in the same Godot Engine version as you <span class="No-Break">are using.</span></li>
				<li>Run a debug instance of the game on <span class="No-Break">each computer.</span></li>
				<li>Press play on one computer, making it the server. Use the IP address the server displays to connect to the <span class="No-Break">other clients.</span></li>
			</ol>
			<p>Now, you <a id="_idIndexMarker737"/>should be able to play together over <span class="No-Break">the network!</span></p>
			<p>That is all for connecting multiple computers. We’ll proceed with a summary of the chapter, but first, here are some additional exercises to solidify <span class="No-Break">our knowledge.</span></p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor684"/>Additional exercises – Sharpening the axe</h1>
			<ol>
				<li>When the game ended, we got a menu with a <strong class="bold">Retry</strong> button, but this <strong class="bold">Retry</strong> button does not properly work in multiplayer. Can you find a way so that we properly start a new game when all players press this button? The server will have to use the <strong class="source-inline">add_player()</strong> function for each pair that is connected in the <strong class="source-inline">_ready()</strong> function of the <strong class="source-inline">main.gd</strong> script. You can get a list of all the peer IDs <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">multiplayer.get_peers()</strong></span><span class="No-Break">.</span></li>
			</ol>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor685"/>Summary</h1>
			<p>The joy in playing video games is sharing the experience and nothing makes that easier than directly <span class="No-Break">playing together!</span></p>
			<p>In this chapter, we started by taking a crash course in computer networking where we learned the basics of how computer networks, such as the internet, work. After this, we started to implement multiplayer into our own game using the <strong class="source-inline">MultiplayerSpawner</strong> and <strong class="source-inline">MultiplayerSynchronizer</strong> node. Lastly, we tried out playing the game over a <span class="No-Break">real network.</span></p>
			<p>This chapter marks the end of <em class="italic">Part 2</em> of the book, where we focused on learning how to develop our game and doing so. Starting from the next chapter, we’ll learn how to export a game, go a little deeper into more advanced programming<a id="_idTextAnchor686"/> topics, and see how we can save or load <span class="No-Break">the game.</span></p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor687"/>Quiz time</h1>
			<ul>
				<li>What is the difference between the TCP <span class="No-Break">and UDP?</span></li>
				<li>If we take the example of a residence with flats, where the port number is the flat number, what does the IP <span class="No-Break">address represent?</span></li>
				<li>What did we use <span class="No-Break"><strong class="source-inline">MultiplayerSpawner</strong></span><span class="No-Break"> for?</span></li>
				<li>What did we use <span class="No-Break"><strong class="source-inline">MultiplayerSynchronizer</strong></span><span class="No-Break"> for?</span></li>
				<li>What function would we use to check whether the current script is running on <span class="No-Break">the server?</span></li>
			</ul>
		</div>
	

		<div class="Content" id="_idContainer270">
			<h1 id="_idParaDest-294" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor688"/>Part 3: Deepening Our Knowledge</h1>
		</div>
		<div id="_idContainer271">
			<p>After learning how to program and creating your very own game from scratch, you will now take a step back and learn some more advanced programming and game <span class="No-Break">development techniques.</span></p>
			<p>By the end of this final part, you will have exported and distributed your game to various different platforms on the web so that everyone can play it from within their browser. You will also learn more advanced OOP concepts and different programming patterns that will help you in your future game projects. Even the filesystem will be covered so that you can save and load data. The last chapter will guide you through the next steps to take, which resources you could consult to learn more, and how to join the game <span class="No-Break">development community.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B19358_12.xhtml#_idTextAnchor689"><em class="italic">Chapter 12</em></a>, <em class="italic">Exporting to Multiple Platforms</em></li>
				<li><a href="B19358_13.xhtml#_idTextAnchor705"><em class="italic">Chapter 13</em></a>, <em class="italic">OOP Continued and Advanced Topics</em></li>
				<li><a href="B19358_14.xhtml#_idTextAnchor721"><em class="italic">Chapter 14</em></a>, <em class="italic">Advanced Programming Patterns</em></li>
				<li><a href="B19358_15.xhtml#_idTextAnchor740"><em class="italic">Chapter 15</em></a>, <em class="italic">Using the File System</em></li>
				<li><a href="B19358_16.xhtml#_idTextAnchor755"><em class="italic">Chapter 16</em></a>, <em class="italic">What Next?</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer272">
			</div>
		</div>
		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer273">
			</div>
		</div>
	</body></html>