- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Building the C++ Matching Engine
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建C++匹配引擎
- en: We spent the last chapter discussing the design of the electronic trading ecosystem
    we will build in this book. The first component we will start with is the matching
    engine at the exchange. In this chapter, we will focus on the task of building
    the order book of the exchange matching engine, based on orders that clients enter.
    We will implement the various data structures and algorithms needed to track these
    orders, perform matching when orders *cross* each other, and update the order
    book. *Crossing* means when a buy order has a price equal to or greater than a
    sell order and then can execute against each other, but we will discuss this in
    greater detail in this chapter. We will focus on achieving the lowest latencies
    possible in these operations, since the exchanges with the best infrastructure
    are likely to do the most business and be preferred by participants. For now,
    we will not worry about the details of the market data publisher and order gateway
    server components at the trading exchange.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章讨论了本书中将构建的电子交易生态系统设计。我们将从交易所的匹配引擎开始。在本章中，我们将专注于基于客户输入的订单构建交易所匹配引擎的订单簿的任务。我们将实现跟踪这些订单、在订单*交叉*时进行匹配以及更新订单簿所需的各个数据结构和算法。"交叉"意味着当买方订单的价格等于或高于卖方订单的价格时，它们可以相互执行，但我们将在本章中更详细地讨论这一点。我们将专注于在这些操作中实现尽可能低的延迟，因为具有最佳基础设施的交易所可能进行最多的业务，并受到参与者的青睐。目前，我们不会担心交易交换中市场数据发布者和订单网关服务器组件的细节。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining the operations and interactions in our matching engine
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义匹配引擎中的操作和交互
- en: Building the matching engine and exchanging external data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建匹配引擎和交换外部数据
- en: Building the order book and matching orders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建订单簿和匹配订单
- en: We will kick off this chapter by first clarifying some assumptions we will make
    to simplify the matching engine and limit the scope of what we can cover in this
    book. We will also define some types, constants, and basic structures in the first
    section.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先澄清一些假设，以简化匹配引擎并限制本书中可以涵盖的范围。我们将在第一部分定义一些类型、常量和基本结构。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code for this book can be found in the GitHub repository for this book
    at [https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP).
    The source code for this chapter is in the `Chapter6` directory in the repository.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有代码都可以在本书的GitHub仓库[https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP)中找到。本章的源代码位于仓库的`Chapter6`目录中。
- en: It is important that you have read and understand the design of the electronic
    trading ecosystem presented in the *Designing Our Trading Ecosystem* chapter.
    Note that in this chapter, we will also use the code we built in [*Chapter 4*](B19434_04.xhtml#_idTextAnchor093),
    *Building the C++ Building Blocks for Low Latency Applications*, which can be
    found in the `Chapter6/common/` directory in the GitHub repository for this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，您已经阅读并理解了*设计我们的交易生态系统*章节中介绍的电子交易生态系统设计。请注意，在本章中，我们还将使用在[*第4章*](B19434_04.xhtml#_idTextAnchor093)中构建的代码，即*构建低延迟应用的C++构建块*，这些代码可以在本书GitHub仓库的`Chapter6/common/`目录中找到。
- en: 'The specifications of the environment in which the source code for this book
    was developed are shown as follows. We present the details of this environment
    because all the C++ code presented in this book is not necessarily portable and
    might require some minor changes to work in your environment:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书源代码开发环境的规格如下所示。我们提供此环境的详细信息，因为本书中展示的所有C++代码并不一定可移植，可能需要在您的环境中进行一些小的修改才能运行：
- en: 'OS: `Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr
    18 17:40:00 UTC 2 x86_64 x86_64` `x86_64 GNU/Linux.`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '操作系统: `Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr
    18 17:40:00 UTC 2 x86_64 x86_64 GNU/Linux.`'
- en: 'GCC: `g++ (Ubuntu` `11.3.0-1ubuntu1~22.04.1) 11.3.0.`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GCC: `g++ (Ubuntu 11.3.0-1ubuntu1~22.04.1) 11.3.0.`'
- en: 'CMake: `cmake` `version 3.23.2.`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'CMake: `cmake` 版本 3.23.2.'
- en: 'Ninja: `1.10.2.`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ninja: `1.10.2.`'
- en: Defining the operations and interactions in our matching engine
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义匹配引擎中的操作和交互
- en: Here, we will declare and define the types, constants, and structures we will
    need as we build the matching engine in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将声明和定义我们在本章构建匹配引擎时需要的类型、常量和结构。
- en: Defining some types and constants
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一些类型和常量
- en: Let us define a few common typedefs to document the types we will use in the
    rest of this book. We will also define some constants to represent some assumptions
    that exist, purely for the purpose of simplifying the design of our matching engine.
    Note that you don’t need these limits/constants, and we leave this enhancement
    up to the interested among you. All the code for this subsection can be found
    in the `Chapter6/common/types.h` file in the GitHub repository for this book.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一些常见的 `typedef` 来记录我们将在这本书的其余部分使用的类型。我们还将定义一些常量来表示一些存在的假设，纯粹是为了简化我们的匹配引擎设计。请注意，您不需要这些限制/常量，我们将此增强留给感兴趣的您。本小节的所有代码都可以在GitHub仓库中找到，该仓库位于本书的
    `Chapter6/common/types.h` 文件中。
- en: Defining a few basic types
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一些基本类型
- en: 'We will define some types to hold different attributes in our electronic trading
    system, such as the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的电子交易系统中定义一些类型来存储不同的属性，例如以下内容：
- en: '`OrderId` to identify orders'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderId` 用于标识订单'
- en: '`TickerId` to identify trading instruments'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TickerId` 用于标识交易工具'
- en: '`ClientId` for the exchange to identify different clients'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClientId` 用于交易所识别不同的客户'
- en: '`Price` to hold prices for instruments'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Price` 用于存储工具的价格'
- en: '`Qty` to hold quantity values for orders'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qty` 用于存储订单的数量值'
- en: '`Priority` to capture the position of an order in the **First In First Out**
    (**FIFO**) queue at a price level, as discussed in the *Designing Our Trading*
    *Ecosystem* chapter.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Priority` 用于捕获在价格水平上的 **先进先出**（**FIFO**）队列中订单的位置，如 *设计我们的交易* *生态系统* 章节中所述。'
- en: '`Side` to signify the side (buy/sell) of an order'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Side` 用于表示订单的（买/卖）方'
- en: 'We will also provide basic methods to convert these to strings purely for logging
    purposes. Let us look at each one of these code blocks to understand the declarations
    next:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将提供基本方法将这些转换为字符串，仅用于日志记录目的。让我们逐一查看这些代码块，以了解接下来的声明：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First, we define the `OrderId` type to identify orders, which is simply `uint64_t`,
    and a corresponding `orderIdToString()` method to log it. We also add a `OrderId_INVALID`
    sentinel method to signify invalid values:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了 `OrderId` 类型来标识订单，它是一个简单的 `uint64_t`，并添加了一个相应的 `orderIdToString()`
    方法来记录它。我们还添加了一个 `OrderId_INVALID` 监视器方法来表示无效值：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We define the `TickerId` type to identify trading instruments, which is simply
    a `uint32_t` type, and add a corresponding `tickerIdToString()` method for it.
    We have a `TickerId_INVALID` sentinel value for invalid instruments:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了 `TickerId` 类型来标识交易工具，它是一个简单的 `uint32_t` 类型，并为它添加了一个相应的 `tickerIdToString()`
    方法。我们有一个 `TickerId_INVALID` 监视器值用于无效工具：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `ClientId` type is used to differentiate between different trading participants.
    The `ClientId_INVALID` value represents an invalid sentinel. The `clientIdToString()`
    method is used for logging purposes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClientId` 类型用于区分不同的交易参与者。`ClientId_INVALID` 值表示一个无效的监视器。`clientIdToString()`
    方法用于日志记录目的：'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next type is `Price`, which is used to capture prices on orders. We also
    add a `Price_INVALID` constant to represent invalid prices. Finally, a `priceToString()`
    method to *stringify* these values:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类型是 `Price`，用于捕获订单上的价格。我们还添加了一个 `Price_INVALID` 常量来表示无效价格。最后，一个 `priceToString()`
    方法将这些值转换为字符串：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Qty` type is `typedef` for `uint32_t` and represents order quantities.
    We also provide the usual `Qty_INVALID` sentinel and the `qtyToString()` method
    to convert them to strings:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Qty` 类型是 `typedef` 为 `uint32_t`，表示订单数量。我们还提供了常用的 `Qty_INVALID` 监视器值和 `qtyToString()`
    方法将它们转换为字符串：'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Priority` type is just a position in the queue of type `uint64_t`. We
    assign the `Priority_INVALID` sentinel value and the `priorityToString()` method:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Priority` 类型只是 `uint64_t` 类型队列中的一个位置。我们分配了 `Priority_INVALID` 监视器值和 `priorityToString()`
    方法：'
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Side` type is an enumeration and contains two valid values, as shown in
    the following code block. We also define a `sideToString()` method, as we did
    for the other types previously:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Side` 类型是一个枚举，包含两个有效值，如下面的代码块所示。我们同样定义了一个 `sideToString()` 方法，就像我们之前对其他类型所做的那样：'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Those are all the basic types we need for this chapter. Next, we will define
    some limits to simplify the design of our system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是本章所需的所有基本类型。接下来，我们将定义一些限制以简化我们系统的设计。
- en: Defining some limits and constraints
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一些限制和约束
- en: 'We will define the following constant limits:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义以下常量限制：
- en: '`LOG_QUEUE_SIZE` represents the size of the lock-free queue used by the logger.
    This holds the maximum number of characters that can be held in memory without
    the logger queue being full.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOG_QUEUE_SIZE`表示日志记录器使用的无锁队列的大小。这表示在不使日志记录器队列满的情况下，可以保留在内存中的最大字符数。'
- en: '`ME_MAX_TICKERS` represents the number of trading instruments the exchange
    supports.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ME_MAX_TICKERS`表示交易所支持的交易工具数量。'
- en: '`ME_MAX_CLIENT_UPDATES` holds the maximum number of unprocessed order requests
    from all clients that the matching engine has not processed yet. This also represents
    the maximum number of order responses from the matching engine that the order
    server has not published yet.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ME_MAX_CLIENT_UPDATES`表示匹配引擎尚未处理的来自所有客户端的最大未处理订单请求数量。这也代表了订单服务器尚未发布的匹配引擎的最大订单响应数量。'
- en: '`ME_MAX_MARKET_UPDATES` represents the maximum number of market updates generated
    by the matching engine that have not yet been published by the market data publisher.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ME_MAX_MARKET_UPDATES`表示匹配引擎生成的尚未由市场数据发布者发布的最大市场更新数量。'
- en: '`ME_MAX_NUM_CLIENTS` holds how many maximum simultaneous market participants
    can exist in our trading ecosystem.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ME_MAX_NUM_CLIENTS`表示在我们的交易生态系统中可以存在的最大同时市场参与者数量。'
- en: '`ME_MAX_ORDER_IDS` is the maximum number of orders possible for a single trading
    instrument.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ME_MAX_ORDER_IDS`表示单个交易工具可能的最大订单数量。'
- en: '`ME_MAX_PRICE_LEVELS` represents the maximum depth of price levels for the
    limit order book that the matching engine maintains.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ME_MAX_PRICE_LEVELS`表示匹配引擎维护的限价订单簿的价格级别的最大深度。'
- en: 'Note that these values have been chosen arbitrarily here; these can be increased
    or decreased, depending on the capacity of the system on which we run the electronic
    trading ecosystem. We chose powers of two to enable the possibility of using shifts
    over multiplies when trying to compute addresses; however, the effect is negligible
    on modern processors, and we would not recommend worrying about this too much.
    The source for the constants we described previously is presented here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里选择这些值是任意性的；这些值可以根据我们运行的电子交易生态系统的容量增加或减少。我们选择2的幂次来允许在尝试计算地址时使用位移而不是乘法；然而，在现代处理器上这种影响是可以忽略不计的，我们不会建议过分担心这一点。我们之前描述的常量的来源在此处展示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These are all the constants we require for now. Now, we can shift our attention
    to more complex structures that we will need inside the matching engine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们目前需要的所有常量。现在，我们可以将注意力转向匹配引擎内部需要的一些更复杂的结构。
- en: Designing the matching engine
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计匹配引擎
- en: We will need a few structures for our matching engine to communicate with the
    market data publisher and order server components.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些结构来使我们的匹配引擎能够与市场数据发布者和订单服务器组件进行通信。
- en: Defining the MEClientRequest and ClientRequestLFQueue types
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义MEClientRequest和ClientRequestLFQueue类型
- en: 'The `MEClientRequest` structure is used by the order server to forward order
    requests from the clients to the matching engine. Remember that the communication
    from the order server to the matching engine is established through the lock-free
    queue component we built earlier. `ClientRequestLFQueue` is a typedef for a lock-free
    queue of `MEClientRequest` objects. The code for this structure can be found in
    the `Chapter6/order_server/client_request.h` file in the GitHub repository:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`MEClientRequest`结构由订单服务器用于将客户端的订单请求转发给匹配引擎。记住，从订单服务器到匹配引擎的通信是通过我们之前构建的无锁队列组件建立的。`ClientRequestLFQueue`是`MEClientRequest`对象的无锁队列的typedef。这个结构的代码可以在GitHub仓库的`Chapter6/order_server/client_request.h`文件中找到：'
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note two things here – we use the `#pragma pack()` directive to make sure these
    structures are packed and do not contain any extra padding. This is important
    because these will be sent and received over a network as flat binary structures
    in later chapters. We also define a `ClientRequestType` enumeration to define
    what type of order request it is – whether it is a new order or a cancel request
    for an existing order. We also define an `INVALID` sentinel value and a `clientRequestTypeToString()`
    method to convert this enumeration into human-readable strings:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里注意两点——我们使用`#pragma pack()`指令来确保这些结构体是紧凑的，不包含任何额外的填充。这一点很重要，因为这些结构体将在后续章节中被作为平面二进制结构在网络中发送和接收。我们还定义了一个`ClientRequestType`枚举来定义订单请求的类型——是新的订单请求还是取消现有订单的请求。我们还定义了一个`INVALID`哨兵值和一个`clientRequestTypeToString()`方法，将这个枚举转换为人类可读的字符串：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can define the `MEClientRequest` structure, which will contain information
    for a single order request from the trading participant to the exchange. Note
    that this is the internal representation that the matching engine uses, not necessarily
    the exact format that the client sends. We will look at that in the next chapter,
    *Communicating with Market Participants*. The important members of this struct
    are the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义`MEClientRequest`结构体，它将包含交易参与者向交易所发出的单个订单请求的信息。请注意，这是匹配引擎使用的内部表示，但不一定是客户端发送的确切格式。我们将在下一章“与市场参与者通信”中探讨这一点。这个结构体的重要成员如下：
- en: A `type_` variable of type `ClientRequestType`
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型为`ClientRequestType`的`type_`变量
- en: The `client_id_` variable of type `ClientId` of the trading client that sent
    this request
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送此请求的交易客户端的`client_id_`变量，其类型为`ClientId`
- en: A `ticker_id_` variable of type `TickerId` of the instrument for which this
    request is meant
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ticker_id_`变量，其类型为`TickerId`，表示此请求针对的金融工具
- en: '`OrderId` (`order_id_`) of the order for which this request is made, which
    can be a new order or reference an existing order'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为此请求所进行的订单的`OrderId`（`order_id_`），这可能是一个新订单或引用现有订单
- en: '`Side` of the order in the `side_` variable'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单的`Side`在`side_`变量中
- en: '`Price` of the order in the `price_` variable'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单的`Price`在`price_`变量中
- en: '`Qty` of the order saved in the `qty_` variable'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单中保存的`Qty`在`qty_`变量中
- en: 'Additionally, we will also add a simple `toString()` method to help us later
    on with logging, as shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将添加一个简单的`toString()`方法，以帮助我们在以后进行日志记录，如下所示：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As discussed previously, we also define the `ClientRequestLFQueue` typedef
    to represent the lock-free queue of these structures, as shown in the following
    code snippet. The `#pragma pack(pop)` simply restores the alignment setting to
    the default – that is, not tightly packed (which we had set by specifying the
    `#pragma pack(push, 1)` directive). This is because we only want to tightly pack
    the structures that will be sent over a network and no others:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们还定义了`ClientRequestLFQueue`类型定义来表示这些结构的锁-free队列，如下面的代码片段所示。`#pragma pack(pop)`简单地恢复了对齐设置到默认值——即不是紧密打包（这是我们通过指定`#pragma
    pack(push, 1)`指令设置的）。这是因为我们只想紧密打包将通过网络发送的结构，而其他则不是：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will define a similar structure used by the matching engine that sends order
    responses to the order server component. Let us look at that in the next subsection.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个与匹配引擎使用的类似结构体，用于向订单服务器组件发送订单响应。让我们在下一小节中看看这个结构体。
- en: Defining the MEClientResponse and ClientResponseLFQueue types
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义MEClientResponse和ClientResponseLFQueue类型
- en: 'Let us present the implementation of the structure used by the matching engine
    that sends order responses for the order server component to dispatch to clients.
    Similar to the last section, we will also define `ClientResponseLFQueue`, which
    is a lock-free queue of the `MEClientResponse` objects. The code for this structure
    is available in the `Chapter6/order_server/client_response.h` source file in the
    GitHub repository:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展示匹配引擎用于向订单服务器组件发送订单响应的结构体的实现，以便将其分发给客户端。类似于上一节，我们还将定义`ClientResponseLFQueue`，它是一个`MEClientResponse`对象的锁-free队列。此结构体的代码可在GitHub仓库的`Chapter6/order_server/client_response.h`源文件中找到：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'First, we will define a `ClientResponseType` enumeration to represent the type
    of response for client orders. In addition to the `INVALID` sentinel value, it
    contains values that represent when a request for a new order is accepted, an
    order is canceled, an order is executed, or a cancel request is rejected by the
    matching engine. We also add the `clientResponseTypeToString()` method to convert
    the `ClientResponseType` values to strings:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个`ClientResponseType`枚举来表示客户端订单的响应类型。除了`INVALID`哨兵值外，它还包含表示新订单请求被接受、订单被取消、订单被执行或取消请求被匹配引擎拒绝的值。我们还添加了`clientResponseTypeToString()`方法，用于将`ClientResponseType`值转换为字符串：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we define the `MEClientResponse` message used internally by the matching
    engine to communicate order response messages for the trading clients when there
    are updates to the client’s orders. Before we look at the source code, the important
    data members in this struct are listed as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了匹配引擎内部使用的`MEClientResponse`消息，用于在客户端订单有更新时与交易客户端通信订单响应消息。在我们查看源代码之前，此结构体中的重要数据成员如下列所示：
- en: A `ClientResponseType type_` variable to represent the type of the client response.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示客户端响应类型的`ClientResponseType type_`变量
- en: A `client_id_` variable of type `ClientId` to represent which market participant
    the response message is meant for.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `client_id_` 变量，类型为 `ClientId`，用于表示响应消息针对哪个市场参与者。
- en: The `ticker_id_` variable of type `TickerId` to represent the trading instrument
    of this response.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `ticker_id_` 变量，类型为 `TickerId`，用于表示此响应的交易工具。
- en: A `client_order_id_` variable that identifies `OrderId` of the order this response
    message affects. This `OrderId` is the one that the client sent in the original
    `MEClientRequest` message for the order.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `client_order_id_` 变量，用于标识此响应消息影响的订单的 `OrderId`。这个 `OrderId` 是客户端在原始 `MEClientRequest`
    消息中为订单发送的。
- en: A `market_order_id_` variable, also of type `OrderId`, but this one identifies
    this order in the public market data stream. This `OrderId` is unique across all
    market participants, since it is possible for different market participants to
    send orders with the same `client_order_id_` value. Even in those cases, two orders
    with the same `client_order_id_` will have different `market_order_id_` values
    in their responses. This `market_order_id_` value is also used when generating
    market updates for this order.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `market_order_id_` 的变量，也是 `OrderId` 类型，但这个变量用于在公共市场数据流中识别这个订单。由于不同的市场参与者可能会发送具有相同
    `client_order_id_` 值的订单，因此这个 `OrderId` 在所有市场参与者中是唯一的。即使在那些情况下，具有相同 `client_order_id_`
    的两个订单在其响应中也会有不同的 `market_order_id_` 值。这个 `market_order_id_` 值也用于生成此订单的市场更新。
- en: A `side_` variable of type `Side` to represent the side of this order response.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `side_` 变量，类型为 `Side`，用于表示此订单响应的方面。
- en: '`Price` of this client response update and whether it is accepted, canceled
    or executed.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端响应更新的 `Price` 以及它是否被接受、取消或执行。
- en: An `exec_qty_` variable of type `Qty`, which is only used in the event of an
    order execution. This variable is used to hold how much quantity was executed
    in this `MEClientResponse` message. This value is not cumulative, meaning that
    when an order gets partially executed multiple times, a `MEClientResponse` message
    is generated for each individual execution and only contains the quantity executed
    in that particular execution, not across all of them.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `exec_qty_` 变量，类型为 `Qty`，仅在订单执行事件中使用。这个变量用于在 `MEClientResponse` 消息中保存执行了多少数量。这个值不是累积的，这意味着当订单被部分执行多次时，会为每次单独的执行生成一个
    `MEClientResponse` 消息，并且只包含那次特定执行中的数量，而不是所有执行的总和。
- en: A `leaves_qty_` variable, also of type `Qty`, which represents how much of the
    original order’s quantity is still live in the matching engine’s order book. This
    is used to communicate the size of this specific order in the book, which is still
    active for further possible executions.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `leaves_qty_` 变量，也是 `Qty` 类型，表示原始订单的数量中有多少仍然在匹配引擎的订单簿中活跃。这用于传达此特定订单在簿中的大小，该订单仍然活跃，可能进行进一步的执行。
- en: 'Finally, we also have our usual `toString()` method for easy logging purposes.
    The definition of the `MEClientResponse` structure, as discussed previously, is
    presented next:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有我们常用的 `toString()` 方法，用于方便的日志记录。如前所述的 `MEClientResponse` 结构定义如下：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ClientResponseLFQueue` type definition is presented as follows, which
    represents a lock-free queue of the structures we discussed previously:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClientResponseLFQueue` 类型定义如下，它表示我们之前讨论的结构的无锁队列：'
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That concludes the discussion of the structures we need to represent client
    requests and responses to and from the matching engine. Let us move on to the
    market update structure in the next subsection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们需要表示客户端请求和匹配引擎响应的结构讨论。让我们继续到下一小节中的市场更新结构。
- en: Defining the MEMarketUpdate and MEMarketUpdateLFQueue types
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 MEMarketUpdate 和 MEMarketUpdateLFQueue 类型
- en: 'The market update structure is used by the matching engine to provide market
    data updates to the market data publishing component. We also have a `MEMarketUpdateLFQueue`
    type to represent a lock-free queue of the `MEMarketUpdate` objects. The code
    for this can be found in the `Chapter6/exchange/market_data/market_update.h` source
    file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 市场更新结构由匹配引擎用于向市场数据发布组件提供市场数据更新。我们还有一个 `MEMarketUpdateLFQueue` 类型来表示 `MEMarketUpdate`
    对象的无锁队列。此代码可以在 `Chapter6/exchange/market_data/market_update.h` 源文件中找到：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `MEMarketUpdate` struct also needs to be a packed structure, since it will
    be part of the message that is sent and received over the network; hence, we use
    the `#pragma pack()` directive again. Before we define the struct, we need to
    define the `MarketUpdateType` enumeration that represents the update action in
    the market update for an order. In addition to taking on an `INVALID` sentinel
    value, it can also be used to represent events such as an order being added, modified,
    or canceled in the order book, as well as trade events in the market:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`MEMarketUpdate`结构体也需要是一个打包结构体，因为它将是通过网络发送和接收的消息的一部分；因此，我们再次使用`#pragma pack()`指令。在我们定义结构体之前，我们需要定义`MarketUpdateType`枚举，它表示订单市场更新中的更新操作。除了承担`INVALID`哨兵值外，它还可以用来表示订单簿中订单被添加、修改或取消的事件，以及市场中的交易事件：'
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we define the `MEMarketUpdate` struct, which contains the following
    important data members:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了`MEMarketUpdate`结构体，它包含以下重要的数据成员：
- en: The `type_` variable of `MarketUpdateType` to represent the type of the market
    update.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MarketUpdateType`的`type_`变量，用于表示市场更新的类型。'
- en: An `order_id_` variable of type `OrderId` to represent the specific order in
    the limit order book for which this order update is applicable.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型为`OrderId`的`order_id_`变量，用于表示限价订单簿中特定订单，该订单更新适用于此订单。
- en: A `ticker_id_` variable of type `TickerId` to represent the trading instrument
    that this update applies to.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型为`TickerId`的`ticker_id_`变量，用于表示此更新适用的交易工具。
- en: A `Side` variable to represent the side of this order.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示此订单方向的`Side`变量。
- en: A `Price` variable for the exact price of the order in this market order update.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示此市场订单更新中确切价格的`Price`变量。
- en: A `priority_` field of type `Priority`, which, as we discussed before, will
    be used to specify the exact position of this order in the FIFO queue. We build
    a FIFO queue of all orders at the same price. This field specifies the position/location
    of this order in that queue.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型为`Priority`的`priority_`字段，正如我们之前讨论的，它将用于指定此订单在FIFO队列中的确切位置。我们构建了一个所有价格相同的订单的FIFO队列。此字段指定了此订单在该队列中的位置/位置。
- en: 'The complete `MEMarketUpdate` struct is shown in the following code block,
    along with the `MEMarketUpdateLFQueue` typedef, which captures a lock-free queue
    of `MEMarketUpdate` struct messages:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`MEMarketUpdate`结构体如下所示，以及`MEMarketUpdateLFQueue`类型定义，它捕获了`MEMarketUpdate`结构体消息的无锁队列：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This concludes the structures we will need to represent and publish market data
    updates from the matching engine. In the next subsection, we will build some structures
    and define some types that we will use to build the limit order book.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们需要表示和发布来自匹配引擎的市场数据更新的结构。在下一个小节中，我们将构建一些结构和定义一些类型，我们将使用它们来构建限价订单簿。
- en: Designing the exchange order book
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计交易所订单簿
- en: In this section, we will define some building blocks that will be used to build,
    maintain, and update the limit order book in an efficient manner. Before we discuss
    each of the structures and objects we will need, we will present a diagram for
    you to build a visual understanding of the limit order book implementation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将定义一些构建块，这些构建块将被用来高效地构建、维护和更新限价订单簿。在我们讨论我们需要的每个结构和对象之前，我们将为您展示一个图表，以帮助您建立对限价订单簿实现的直观理解。
- en: The limit order book is organized as a collection of buy orders (referred to
    as bids) and sell orders (referred to as asks). Orders that are entered at the
    same price are organized in the **First In First Out** (**FIFO**) order in our
    matching engine. We discussed these details in the *Designing Our Trading Ecosystem*
    chapter, in the *Designing the C++ matching engine in a trading* *exchange* section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 限价订单簿组织为一系列买方订单（称为挂单）和卖方订单（称为卖单）。在匹配引擎中，价格相同的订单按照**先进先出**（**FIFO**）的顺序组织。我们已在*设计我们的交易生态系统*章节中讨论了这些细节，在*设计交易交易所中的C++匹配引擎*部分。
- en: For the order book we build inside the matching engine, we have a list of bid
    prices and ask prices that have active orders. Each price level is represented
    by the `MEOrdersAtPrice` struct, as shown in the following diagram. The bids are
    sorted from highest to lowest price level, and the asks are sorted from lowest
    to highest price level. Each `MEOrdersAtPrice` stores the individual orders from
    highest to lowest priority in a doubly linked list. Information for each individual
    order is contained in the `MEOrder` structs. We will track each price level in
    a hash map of type `OrdersAtPriceHashMap`, which is indexed by the price of that
    level. We will also track each `MEOrder` object by their `market_order_id_` value
    in a hash map of type `OrderHashMap`. The diagram representing this design of
    our matching engine order book is presented as follows.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在匹配引擎内部构建的订单簿，我们有一个包含活跃订单的买入价格和卖出价格列表。每个价格水平由 `MEOrdersAtPrice` 结构表示，如下所示。买入价格按从高到低的价格水平排序，卖出价格按从低到高的价格水平排序。每个
    `MEOrdersAtPrice` 使用双向链表从高到低优先级存储单个订单。每个单个订单的信息包含在 `MEOrder` 结构中。我们将使用类型为 `OrdersAtPriceHashMap`
    的哈希表跟踪每个价格水平，该哈希表按该级别的价格索引。我们还将使用类型为 `OrderHashMap` 的哈希表跟踪每个 `MEOrder` 对象，按其 `market_order_id_`
    值索引。表示我们匹配引擎订单簿此设计的图示如下。
- en: '![Figure 6.1 – The design of the limit order book inside the matching engine](img/Figure_6.1_B19434.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 匹配引擎内部限价订单簿的设计](img/Figure_6.1_B19434.jpg)'
- en: Figure 6.1 – The design of the limit order book inside the matching engine
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 匹配引擎内部限价订单簿的设计
- en: Now that we have discussed the overall design of the limit order book data structure
    and the components that make it up, we can start defining the basic structs we
    need to implement that design. In the next subsection, we will first design the
    basic blocks – the `MEOrder` structure to hold information for a single order.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了限价订单簿数据结构的整体设计和构成它的组件，我们可以开始定义实现该设计所需的基本结构。在下一小节中，我们首先设计基本块——用于存储单个订单信息的
    `MEOrder` 结构。
- en: Defining the MEOrder, OrderHashMap, and ClientOrderHashMap types
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 MEOrder、OrderHashMap 和 ClientOrderHashMap 类型
- en: The first structure is used to hold information inside the book for a single
    limit order, which we will call `MEOrder`. This is shown in the following code
    blocks, and the code can be found in the `Chapter6/matcher/me_order.h` and `Chapter6/matcher/me_order.cpp`
    source files in the GitHub repository.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个结构用于在订单簿内部存储单个限价订单的信息，我们将称之为 `MEOrder`。这将在以下代码块中展示，代码可以在 GitHub 仓库的 `Chapter6/matcher/me_order.h`
    和 `Chapter6/matcher/me_order.cpp` 源文件中找到。
- en: 'The `MEOrder` struct has the following important data members in it to save
    the attributes required to represent a single order in the limit order book:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`MEOrder` 结构中包含以下重要数据成员，用于保存表示单个订单在限价订单簿中所需的属性：'
- en: A `ticker_id_` variable of type `TickerId` to represent the instrument that
    this order corresponds to.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型为 `TickerId` 的 `ticker_id_` 变量，用于表示该订单对应的工具。
- en: A `client_id_` variable of type `ClientId` that captures the market participant
    who owns this order.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型为 `ClientId` 的 `client_id_` 变量，用于捕获拥有此订单的市场参与者。
- en: Two `OrderId` sets, as we discussed before – `client_order_id_`, which is what
    the client sent on its order request, and `market_order_id_`, which is generated
    by the matching engine and is unique across all clients.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 `OrderId` 集合，正如我们之前讨论的那样——`client_order_id_`，这是客户端在其订单请求中发送的内容，以及 `market_order_id_`，由匹配引擎生成，且在整个客户端中是唯一的。
- en: '`Side side_` to represent whether the order is a buy or sell order.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Side side_` 用于表示订单是买入订单还是卖出订单。'
- en: A `price_` variable of type `Price` to represent the price of the order.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型为 `Price` 的 `price_` 变量，用于表示订单的价格。
- en: '`Qty qty_` to represent the quantity of the order that is still active in the
    order book.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qty qty_` 用于表示在订单簿中仍然活跃的订单数量。'
- en: A `priority_` variable of type `Priority`, which, as we discussed before, will
    represent the exact position of this order in the queue of other `MEOrder` instances
    with the same `side_` and `price_` values.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类型为 `Priority` 的 `priority_` 变量，正如我们之前讨论的那样，它将代表此订单在具有相同 `side_` 和 `price_`
    值的其他 `MEOrder` 实例队列中的确切位置。
- en: 'The `MEOrder` structure also has two pointers to other `MEOrder` objects. This
    is because the `MEOrder` objects are also maintained as a doubly linked list of
    orders arranged at a price level in the `MEOrdersAtPrice` structure, as we discussed
    in the previous section:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEOrder`结构体也有两个指向其他`MEOrder`对象的指针。这是因为`MEOrder`对象也被维护为一个双向链表，按照在`MEOrdersAtPrice`结构体中的价格级别排列，正如我们在上一节中讨论的那样：'
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Additionally, the `OrderHashMap` type is used to represent a hash map, implemented
    using `std::array`, where `OrderId` is the key and `MEOrder` is the value. We
    will also define another type, `ClientOrderHashMap`, which is a hash map, implemented
    using `std::array` to represent a mapping from `ClientId` to the `OrderHashMap`
    objects:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`OrderHashMap`类型用于表示一个哈希表，使用`std::array`实现，其中`OrderId`是键，`MEOrder`是值。我们还将定义另一个类型，`ClientOrderHashMap`，它也是一个哈希表，使用`std::array`来表示从`ClientId`到`OrderHashMap`对象的映射：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We present the `toString()` method for the `MEOrder` structure, which is very
    simple and available in the `Chapter6/exchange/matcher/me_order.cpp` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`MEOrder`结构体提供了`toString()`方法，该方法非常简单，可在`Chapter6/exchange/matcher/me_order.cpp`文件中找到：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we will build some additional structures that contain and manage order
    objects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一些包含和管理订单对象的其他结构体。
- en: Defining the MEOrdersAtPrice and OrdersAtPriceHashMap types
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义`MEOrdersAtPrice`和`OrdersAtPriceHashMap`类型
- en: As discussed in *Figure 6**.1*, we define another structure that maintains a
    list of `MEOrder` objects, and we call it `MEOrdersAtPrice`. This structure, presented
    in the following code block, will be used to hold all the orders entered at the
    same price, arranged in the FIFO priority order. This is achieved by creating
    a singly linked list of `MEOrder` objects, arranged in order of highest to lowest
    priority. For that, we create a `first_me_order_` variable of the `MEOrder` type
    pointer, which will represent the first order at this price level, and the other
    orders following it are chained together in the FIFO order.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图6**.1*所示，我们定义了另一个结构体，用于维护`MEOrder`对象列表，我们称之为`MEOrdersAtPrice`。这个结构体，在下面的代码块中展示，将用于存储在相同价格下输入的所有订单，按照先进先出（FIFO）优先级顺序排列。这是通过创建一个按优先级从高到低排列的`MEOrder`对象的单链表来实现的。为此，我们创建了一个`first_me_order_`类型的`MEOrder`指针变量，它将代表此价格级别的第一个订单，而随后的其他订单将按照FIFO顺序链接在一起。
- en: The `MEOrdersAtPrice` structure also has two pointers to the `MEOrdersAtPrice`
    objects, one for the previous (`prev_entry_`) and one for the next (`next_entry_`).
    This is because the structure itself is a node in a doubly linked list of `MEOrdersAtPrice`
    objects. The doubly linked list of `MEOrdersAtPrice` is arranged from the most
    aggressive to the least aggressive prices on the buy and sell sides.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`MEOrdersAtPrice`结构体也有两个指向`MEOrdersAtPrice`对象的指针，一个用于前一个（`prev_entry_`），一个用于下一个（`next_entry_`）。这是因为该结构体本身是`MEOrdersAtPrice`对象的双向链表中的一个节点。`MEOrdersAtPrice`的双向链表按照买卖双方的从最积极到最不积极的顺序排列价格。'
- en: 'The two other variables this struct contains are a `side_` variable of type
    `Side` and a `price_` variable of type `Price`, respectively representing the
    side and price of this price level:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构体包含的两个其他变量分别是`side_`变量，其类型为`Side`，以及`price_`变量，其类型为`Price`，分别代表此价格级别的买卖方向和价格：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We add a default constructor and a trivial custom container to initialize objects
    of this structure:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个默认构造函数和一个简单的自定义容器来初始化此结构体的对象：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also add a simple `toString()` method for logging purposes, as shown here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个简单的`toString()`方法，用于日志记录，如下所示：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `OrdersAtPriceHashMap` type represents a hash map, implemented through
    a `std::array` to represent a mapping from Price to `MEOrdersAtPrice`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrdersAtPriceHashMap`类型表示一个哈希表，通过`std::array`实现，用于表示从价格到`MEOrdersAtPrice`的映射：'
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This concludes this section on setting up the initial types, definitions, and
    basic structures for the matching engine and limit order book. Next, we can look
    at how the matching engine framework is built.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了关于设置匹配引擎和限价订单簿的初始类型、定义和基本结构的本节内容。接下来，我们可以看看匹配引擎框架是如何构建的。
- en: Building the matching engine and exchanging external data
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建匹配引擎和交换外部数据
- en: In this section, we will build various parts of the matching engine class. A
    lot of the heavy lifting of handling client requests, building and updating the
    limit order book, and generating order responses and market updates will be offloaded
    to the order book class, which we will discuss in the next section. Please reread
    the *Designing the C++ matching engine in a trading exchange* section in the previous
    chapter, *Designing Our Trading Ecosystem*, for a refresher on the components
    we will build in this section and the design principles behind them. We present
    the diagram from that chapter here for easy reference, showing the design of the
    matching engine.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建匹配引擎类的各个部分。处理客户端请求、构建和更新限价订单簿以及生成订单响应和市场更新的大部分繁重工作将转交给订单簿类，我们将在下一节讨论。请重新阅读上一章中关于在交易交易所中设计C++匹配引擎的*设计C++匹配引擎的章节*，以复习我们将构建的组件及其设计原则。我们在此处呈现该章节的图表，以便于参考，展示了匹配引擎的设计。
- en: '![Figure 6.2 – The design of our matching engine component](img/Figure_6.2_B19434.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 我们匹配引擎组件的设计](img/Figure_6.2_B19434.jpg)'
- en: Figure 6.2 – The design of our matching engine component
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 我们匹配引擎组件的设计
- en: The matching engine is an independent thread of execution that consumes order
    requests from `ClientRequestLFQueue`, publishes order responses to `ClientResponseLFQueue`,
    and publishes market updates to `MEMarketUpdateLFQueue`. Let us first declare
    and define some code for the construction, destruction, thread management, and
    boilerplate functionality for the matching engine.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配引擎是一个独立的执行线程，它从`ClientRequestLFQueue`中消费订单请求，将订单响应发布到`ClientResponseLFQueue`，并将市场更新发布到`MEMarketUpdateLFQueue`。让我们首先声明并定义一些用于构建、销毁、线程管理和匹配引擎的样板功能的代码。
- en: Building the matching engine
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建匹配引擎
- en: The `MatchingEngine` class contains a couple of important data members – first,
    an `OrderBookHashMap` object to track the limit order book for each of the trading
    instruments. The class also contains pointers to the following objects – `ClientRequestLFQueue`,
    `ClientResponseLFQueue`, and `MEMarketUpdateLFQueue`, all of which will be passed
    to it in the constructor. Let us first declare and define some code for the construction,
    destruction, thread management, and boilerplate functionality for the matching
    engine. We will also have a Boolean, `run_`, to track the thread state, a `time_str_`
    string, and a `Logger` object to output some logs. The code for the next sub-sections
    is available in the `Chapter6/exchange/matcher/matching_engine.h` source file
    in the GitHub repository for this book.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`MatchingEngine`类包含一些重要的数据成员 – 首先，一个用于跟踪每个交易工具的限价订单簿的`OrderBookHashMap`对象。该类还包含以下对象的指针
    – `ClientRequestLFQueue`、`ClientResponseLFQueue`和`MEMarketUpdateLFQueue`，所有这些都将通过构造函数传递给它。让我们首先声明并定义一些用于构建、销毁、线程管理和匹配引擎的样板功能的代码。我们还将有一个用于跟踪线程状态的布尔变量`run_`，一个`time_str_`字符串和一个`Logger`对象来输出一些日志。下一节代码的源文件可在GitHub上这本书的`Chapter6/exchange/matcher/matching_engine.h`中找到。'
- en: 'First, the header files we need to include to build our matching engine are
    presented here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要包含以下头文件来构建我们的匹配引擎：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We declare the constructor and destructor methods next, and we add the `start()`
    and `stop()` methods to respectively start and stop the execution of the main
    matching engine loop, which we will build shortly:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来声明构造函数和析构函数方法，并添加`start()`和`stop()`方法，分别启动和停止主匹配引擎循环的执行，我们将在稍后构建它：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We add our usual boilerplate code for the constructors and assignment operators
    to prevent accidental copies:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了我们通常的构造函数和赋值运算符的样板代码，以防止意外复制：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we add the data members for this `MatchingEngine` class, as discussed
    before. The `ticker_order_book_` variable of type `OrderBookHashMap` is used to
    store `MEOrderBook` for each instrument. We store the `incoming_requests_`, `outgoing_ogw_responses_`,
    and `outgoing_md_updates_` pointers of the `ClientRequestLFQueue`, `ClientResponseLFQueue`,
    and `MEMarketUpdateLFQueue` types respectively to communicate with the other threads.
    Then, we have the `run_` Boolean variable, which we mark `volatile`, since it
    will be accessed from different threads:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加这个`MatchingEngine`类的数据成员，如之前所述。类型为`OrderBookHashMap`的`ticker_order_book_`变量用于存储每个工具的`MEOrderBook`。我们将`ClientRequestLFQueue`、`ClientResponseLFQueue`和`MEMarketUpdateLFQueue`类型的`incoming_requests_`、`outgoing_ogw_responses_`和`outgoing_md_updates_`指针分别存储，以与其他线程进行通信。然后，我们有`run_`布尔变量，我们将其标记为`volatile`，因为它将从不同的线程中被访问：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let us look at the implementation of the constructor, the destructor, and the
    `start()` method that creates and launches a thread to execute the `run()` method
    (which we will look at shortly). This code is in the `Chapter6/exchange/matcher/matching_engine.cpp`
    source file. The constructor itself is straightforward – it initializes the internal
    data members and creates an `MEOrderBook` instance for each one of the supported
    trading instruments:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看构造函数、析构函数以及创建并启动执行 `run()` 方法的线程的 `start()` 方法的实现（我们很快就会看到）。这段代码位于 `Chapter6/exchange/matcher/matching_engine.cpp`
    源文件中。构造函数本身很简单——它初始化内部数据成员并为每个支持的交易工具创建一个 `MEOrderBook` 实例：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The destructor does the opposite of the constructor and resets the internal
    data member variables. It also deletes the `MEOrderBook` objects it created in
    the constructor:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数与构造函数相反，重置内部数据成员变量。它还会删除在构造函数中创建的 `MEOrderBook` 对象：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `start()` method creates and launches a new thread, assigning it the `MatchingEngine::run()`
    method. Before it does that, it enables `run_ flag`, since it controls the execution
    of the `run()` method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`start()` 方法创建并启动一个新线程，将其分配给 `MatchingEngine::run()` 方法。在这样做之前，它启用 `run_` 标志，因为它控制
    `run()` 方法的执行：'
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `stop()` method simply sets the `run_` flag to be `false`, and that in
    turn causes the `run()` method to exit out of its main loop, but this will become
    clear shortly:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop()` 方法只是将 `run_` 标志设置为 `false`，这反过来会导致 `run()` 方法退出其主循环，但这一点很快就会变得清晰：'
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we will investigate the source code that handles how the matching engine
    consumes the order requests and publishes order responses and market updates.
    But first, let us present the main `run()` loop that the matching engine thread
    executes. This code is very simple – it simply consumes `MEClientRequest` objects
    from the `incoming_requests_` lock-free queue and forwards them to the `processClientRequest()`
    method. To achieve this, it simply checks the `LFQueue::getNextToRead()` method
    to see whether there is a valid entry to be read, and if so, forwards the object
    at that entry to be processed, and updates the read index in the lock-free queue
    using the `LFQueue::updateReadIndex()` method. This code is in the `Chapter6/exchange/matcher/matching_engine.h`
    source file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究处理匹配引擎如何消费订单请求并发布订单响应和市况更新的源代码。但首先，让我们展示匹配引擎线程执行的 main `run()` 循环。这段代码非常简单——它只是从
    `incoming_requests_` 无锁队列中消费 `MEClientRequest` 对象，并将它们转发到 `processClientRequest()`
    方法。为了实现这一点，它简单地检查 `LFQueue::getNextToRead()` 方法以查看是否有有效的条目可供读取，如果有，就将该条目处的对象转发以进行处理，并使用
    `LFQueue::updateReadIndex()` 方法更新无锁队列中的读取索引。这段代码位于 `Chapter6/exchange/matcher/matching_engine.h`
    源文件中：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, let us look at the source code to handle client requests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看处理客户端请求的源代码。
- en: Consuming from and publishing to the order gateway queue
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从订单网关队列中消费和发布
- en: 'First, we will start with the implementation of `processClientRequest()` in
    the `MatchingEngine` class in the `matching_engine.h` header file. This implementation
    simply checks for the type of the `MEClientRequest` and forwards it to the limit
    order book for the corresponding instrument. It finds the correct order book instance
    that this `MEClientRequest` is meant for by accessing the `ticker_order_book_`
    container, using the `ticker_id_` field in `MEClientRequest`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从 `matching_engine.h` 头文件中 `MatchingEngine` 类的 `processClientRequest()`
    函数实现开始。这个实现简单地检查 `MEClientRequest` 的类型，并将其转发到对应工具的限价订单簿。它通过访问 `ticker_order_book_`
    容器，使用 `MEClientRequest` 中的 `ticker_id_` 字段来找到这个 `MEClientRequest` 应该对应的正确订单簿实例：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For client requests that try to add a new order (`ClientRequestType::NEW`),
    we call the `MEOrderBook::add()` method and let it service that request:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于尝试添加新订单（`ClientRequestType::NEW`）的客户端请求，我们调用 `MEOrderBook::add()` 方法并让它处理该请求：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Similarly, client requests that try to cancel an existing order (`ClientRequestType::CANCEL`)
    are forwarded to the `MEOrderBook::cancel()` method:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，尝试取消现有订单（`ClientRequestType::CANCEL`）的客户端请求会被转发到 `MEOrderBook::cancel()`
    方法：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will also define a method in the same class that the limit order book will
    use to publish order responses through `MEClientResponse` messages. This simply
    writes the response to the `outgoing_ogw_responses_` lock-free queue and advances
    the writer index. It does that by finding the next valid index to write the `MEClientResponse`
    message to by calling the `LFQueue::getNextToWriteTo()` method, moving the data
    into that slot, and updating the next write index by calling the `LFQueue::updateWriteIndex()`
    method:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在同一个类中定义一个方法，限价订单簿将使用该方法通过`MEClientResponse`消息发布订单响应。它只是将响应写入`outgoing_ogw_responses_`无锁队列并推进写入索引。它是通过调用`LFQueue::getNextToWriteTo()`方法找到下一个有效的索引来写入`MEClientResponse`消息，将数据移动到该槽位，并通过调用`LFQueue::updateWriteIndex()`方法更新下一个写入索引来实现的：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, we will look at some code that is similar to what we just saw, except it
    is used to publish market data updates.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看一些与刚才看到的类似的代码，但它用于发布市场数据更新。
- en: Publishing to the market data publisher queue
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到市场数据发布器队列
- en: 'The `sendMarketUpdate()` method in `Chapter6/exchange/matcher/matching_engine.h`
    is used by the limit order book to publish market data updates through the `MEMarketUpdate`
    structure. It simply writes to the `outgoing_md_updates_` lock-free queue and
    advances the writer. It does this exactly the same way we saw before – by calling
    the `getNextToWriteTo()` method, writing the `MEMarketUpdate` message to that
    slot, and updating the next write index using `updateWriteIndex()`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chapter6/exchange/matcher/matching_engine.h`中的`sendMarketUpdate()`方法由限价订单簿使用，通过`MEMarketUpdate`结构发布市场数据更新。它只是将数据写入`outgoing_md_updates_`无锁队列并推进写入者。它以与我们之前看到完全相同的方式执行此操作——通过调用`getNextToWriteTo()`方法，将`MEMarketUpdate`消息写入该槽位，并使用`updateWriteIndex()`更新下一个写入索引：'
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That concludes this section, and we now have the finished implementation of
    the matching engine. In the next subsection, we will tie all these pieces together
    into the trading exchange binary, all except the limit order book implementation,
    which is the last section we will discuss in this chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容到此结束，我们现在已经完成了匹配引擎的实现。在下一小节中，我们将把这些部分组合成交易交换的二进制文件，除了限价订单簿的实现，这是本章我们将讨论的最后一部分。
- en: Building the exchange application binary
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建交换应用程序二进制文件
- en: We can now build the trading exchange binary. We will instantiate the three
    lock-free queues for order requests, order responses, and market updates that
    the matching engine object needs. We will also create the `MatchingEngine` object
    and launch the thread, and then the binary simply sleeps forever. Since the application
    goes into an infinite loop, we will also install a signal handler for this application
    to trap external signals and exit gracefully. Note that this code will be extended
    in later chapters in this book as we build the order server and market data publisher
    components on the trading exchange side that need to be added here. The code for
    this application is in `Chapter6/exchange/exchange_main.cpp` in the GitHub repository
    for this book. Let us break down the source file and understand each of the code
    blocks.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建交易交换的二进制文件。我们将实例化匹配引擎对象所需的三个无锁队列，用于订单请求、订单响应和市场更新。我们还将创建`MatchingEngine`对象并启动线程，然后二进制文件将永久休眠。由于应用程序进入无限循环，我们还将为该应用程序安装信号处理程序，以捕获外部信号并优雅地退出。请注意，随着我们在本书后续章节中构建订单服务器和市场数据发布器组件，这些组件需要添加到此处，此代码将在本书的后续章节中扩展。该应用程序的代码位于GitHub存储库中的`Chapter6/exchange/exchange_main.cpp`。
- en: 'First, we add some variables that will be pointers for the `Logger` object
    and the `MatchingEngine` object. We will also add a `signal_handler()` method
    to be invoked when killing the exchange application. The signal handler simply
    deletes these objects and exits:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加一些变量，这些变量将作为`Logger`对象和`MatchingEngine`对象的指针。我们还将添加一个`signal_handler()`方法，当终止交换应用程序时将被调用。信号处理程序简单地删除这些对象并退出：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `main()` method is pretty simple for now till we add other components in
    the next chapter. It installs the `signal_handler()` method using the `std::signal()`
    routine to trap external `SIGINT` signals. The `SIGINT` signal is the signal value
    2, which is sent to a running process when either *Ctrl* + *C* is pressed in Linux
    or `kill –2 PID` is sent to that `ClientRequestLFQueue` variable, `client_requests`,
    and the `ClientResponseLFQueue` variable, `client_responses`, to be of the `ME_MAX_CLIENT_UPDATES`
    size. We also initialize the lock-free queue variable, `market_updates`, of type
    `MEMarketUpdateLFQueue` to be of `ME_MAX_MARKET_UPDATES` capacity. The `main()`
    method also initializes the `logger` variable with an instance of the `Logger`
    class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`main()` 方法相当简单，直到我们在下一章添加其他组件。它使用 `std::signal()` 例程安装 `signal_handler()`
    方法以捕获外部 `SIGINT` 信号。`SIGINT` 信号是信号值 2，当在 Linux 中按下 *Ctrl* + *C* 或向 `ClientRequestLFQueue`
    变量 `client_requests` 和 `ClientResponseLFQueue` 变量 `client_responses` 发送 `kill
    –2 PID` 时发送给正在运行的过程。我们还初始化了无锁队列变量 `market_updates`，其类型为 `MEMarketUpdateLFQueue`，容量为
    `ME_MAX_MARKET_UPDATES`。`main()` 方法还使用 `Logger` 类的实例初始化 `logger` 变量：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, the `main()` method initializes the `matching_engine` variable with
    an instance of the `MatchingEngine` class we created and passes it the three lock-free
    queues it needs from the preceding code block. It then calls the `start()` method
    so that the main matching engine thread can start executing. At this point, the
    `main()` method is done, so it enters into an infinite loop, where it sleeps most
    of the time and waits for an external signal that will kill this process:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main()` 方法使用我们创建的 `MatchingEngine` 类的实例初始化 `matching_engine` 变量，并从前面的代码块中传递它所需的三个无锁队列。然后它调用
    `start()` 方法，以便主匹配引擎线程可以开始执行。此时，`main()` 方法已完成，因此它进入一个无限循环，其中大部分时间都在睡眠，等待一个将杀死此进程的外部信号：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To make it easy to build the main binary, we have provided a script, `Chapter6/build.sh`,
    which uses CMake and Ninja to build this binary. You will have to update this
    script to point to the correct binaries on your system, or use a different build
    system if you prefer. The next section will provide some information on how to
    run this `exchange_main` application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于构建主二进制文件，我们提供了一个脚本，`Chapter6/build.sh`，它使用 CMake 和 Ninja 构建此二进制文件。你可能需要更新此脚本以指向系统中的正确二进制文件，或者如果你更喜欢，可以使用不同的构建系统。下一节将提供有关如何运行此
    `exchange_main` 应用程序的一些信息。
- en: Running the exchange application binary
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行交易所应用程序二进制文件
- en: 'Running the `exchange_main` application is achieved at this point simply by
    calling the `exchange_main` binary, as shown in the following code block. We also
    show the output you should be able to see on the terminal:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `exchange_main` 应用程序此时只需调用 `exchange_main` 二进制文件，如下面的代码块所示。我们还会展示你应在终端上看到的输出：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This process can be stopped by sending it the `SIGINT` signal, as we mentioned
    before. At this point, it will generate three log files, similar to the ones shown
    in the following snippet. However, note at this point that there is nothing interesting
    in the log files, since we have only built the matching engine component out of
    all the components we need to build the full trading ecosystem. At the end of
    the next chapter, *Communicating with Market Participants*, we will run this application
    again with additional components and have slightly more interesting output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，可以通过发送 `SIGINT` 信号来停止此进程。此时，它将生成三个日志文件，类似于以下片段中所示。然而，请注意，此时日志文件中没有什么有趣的内容，因为我们只构建了所有需要构建的完整交易生态系统组件中的匹配引擎组件。在下一章的结尾，*与市场参与者通信*，我们将再次运行此应用程序，并添加额外的组件，输出将更有趣：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The next section will look at the internal workings of the order book and how
    it handles client order requests and generates order responses and market updates.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将探讨订单簿的内部工作原理以及它如何处理客户端订单请求并生成订单响应和市场更新。
- en: Building the order book and matching orders
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建订单簿和匹配订单
- en: This final section implements the order book functionality. Remember that the
    order book handles client order requests forwarded from the matching engine. It
    checks the order request type, updates the order book, generates order responses
    for the client, and generates market data updates for the public market data feed.
    All the code for the limit order book in the matching engine is in the `me_order_book.h`
    and `me_order_book.cpp` source files, saved in the `Chapter6/exchange/matcher/`
    directory in the GitHub repository for this book.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本节实现了订单簿功能。记住，订单簿处理来自匹配引擎转发给客户端的订单请求。它检查订单请求类型，更新订单簿，为客户端生成订单响应，并为公共市场数据馈送生成市场数据更新。匹配引擎中所有限价订单的代码都在`me_order_book.h`和`me_order_book.cpp`源文件中，保存在本书GitHub仓库的`Chapter6/exchange/matcher/`目录中。
- en: Building the internal data structures
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建内部数据结构
- en: 'First, we will declare the data members for the limit order book. We presented
    a diagram depicting the data structures that make up the limit order book previously,
    in Figure 6.1\. The limit order book contains the following important data members:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将声明限价订单簿的数据成员。我们之前在图6.1中展示了一个表示构成限价订单簿的数据结构的图表。限价订单簿包含以下重要数据成员：
- en: A `matching_engine_` pointer variable to the `MatchingEngine` parent for the
    order book to publish order responses and market data updates to.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向`MatchingEngine`父类的`matching_engine_`指针变量，用于订单簿发布订单响应和市场数据更新。
- en: The `ClientOrderHashMap` variable, `cid_oid_to_order_`, to track the `OrderHashMap`
    objects by their `ClientId` key. As a reminder, `OrderHashMap` tracks the `MEOrder`
    objects by their `OrderId` keys.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClientOrderHashMap`变量，`cid_oid_to_order_`，用于按其`ClientId`键跟踪`OrderHashMap`对象。提醒一下，`OrderHashMap`按其`OrderId`键跟踪`MEOrder`对象。'
- en: The `orders_at_price_pool_` memory pool variable of the `MEOrdersAtPrice` objects
    to create new objects from and return dead objects back to.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEOrdersAtPrice`对象的`orders_at_price_pool_`内存池变量，用于创建新对象并将死亡对象返回。'
- en: The head of the doubly linked list of bids (`bids_by_price_`) and asks (`asks_by_price_`),
    since we track orders at the price level as a list of `MEOrdersAtPrice` objects.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向链表的头部分别是出价（`bids_by_price_`）和询问（`asks_by_price_`），因为我们按价格级别将订单跟踪为`MEOrdersAtPrice`对象列表。
- en: A hash map, `OrdersAtPriceHashMap`, to track the `MEOrdersAtPrice` objects for
    the price levels, using the price of the level as a key into the map.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个哈希表，`OrdersAtPriceHashMap`，用于跟踪价格级别的`MEOrdersAtPrice`对象，使用级别的价格作为映射中的键。
- en: A memory pool of the `MEOrder` objects, called `order_pool_`, where `MEOrder`
    objects are created from and returned to without incurring dynamic memory allocations.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`MEOrder`对象的内存池，称为`order_pool_`，其中`MEOrder`对象从中创建并返回，而不产生动态内存分配。
- en: Some minor members, such as `TickerId` for the instrument for this order book,
    `OrderId` to track the next market data order ID, an `MEClientResponse` variable
    (`client_response_`), an `MEMarketUpdate` object (`market_update_`), a string
    to log time, and the `Logger` object for logging purposes.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些次要成员，例如用于此订单簿的`TickerId`，用于跟踪下一个市场数据订单ID的`OrderId`，一个`MEClientResponse`变量（`client_response_`），一个`MEMarketUpdate`对象（`market_update_`），一个用于记录时间的字符串，以及用于日志记录的`Logger`对象。
- en: 'First, we include some dependent header files and also forward-declare the
    `MatchingEngine` class because we will reference that type without fully defining
    it yet:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包含一些依赖的头文件，并提前声明`MatchingEngine`类，因为我们将在尚未完全定义该类型的情况下引用它：
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we will define the data member variables, as discussed previously:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义数据成员变量，如之前所述：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'At this point, we will also define the `OrderBookHashMap` type, which we referenced
    before and is `std::array` of the `MEOrderBook` objects indexed by `TickerId`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们还将定义之前提到的`OrderBookHashMap`类型，它是一个按`TickerId`索引的`MEOrderBook`对象的`std::array`：
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, let us present the straightforward implementation of the constructor
    and the destructor, as well as the boilerplate code for the default constructor
    and assignment operators:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们展示构造函数和析构函数的直接实现，以及默认构造函数和赋值运算符的样板代码：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we add the boilerplate code to most of our classes to prevent accidental
    copies and assignments of the `MEOrderBook` objects:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在大多数类中添加样板代码以防止意外复制和分配`MEOrderBook`对象：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Before we move on to the implementation of the different operations that will
    be performed on the order book, let us present a few simple methods to generate
    new market order IDs, convert `Price` to an index in `OrdersAtPriceHashMap`, and
    access the `OrdersAtPriceHashMap price_orders_at_price_` map when given `Price`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续实现将在订单簿上执行的不同操作之前，让我们先介绍一些简单的方法来生成新的市场订单ID，将`Price`转换为`OrdersAtPriceHashMap`中的索引，并在给定`Price`时访问`OrdersAtPriceHashMap
    price_orders_at_price_`映射：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `generateNewMarketOrderId()` method is basic; it returns the `next_market_order_id_`
    value and increments it the next time this method is called:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateNewMarketOrderId()`方法很简单；它返回`next_market_order_id_`值，并在下次调用此方法时增加它：'
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `priceToIndex()` method converts a `Price` argument into an index that
    ranges between `0` and `ME_MAX_PRICE_LEVELS-1`, which is then used to index the
    price levels `std::array`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`priceToIndex()`方法将`Price`参数转换为介于`0`和`ME_MAX_PRICE_LEVELS-1`之间的索引，然后用于索引价格级别的`std::array`：'
- en: '[PRE53]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, the `getOrdersAtPrice()` utility method indexes `std::array` of `price_orders_at_price_`
    by converting `Price` it is provided into an index, using the `priceToIndex()`
    method, which returns the `MEOrdersAtPrice` object:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`getOrdersAtPrice()`实用方法通过将提供的`Price`转换为索引来索引`price_orders_at_price_`的`std::array`，使用`priceToIndex()`方法，该方法返回`MEOrdersAtPrice`对象：
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The next few subsections will detail the important operations of handling new
    order requests and cancellation requests for existing orders, and matching aggressive
    orders that cross existing passive orders on the other side of the order book.
    We will also generate and publish order responses and market data updates back
    to the matching engine.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个小节将详细说明处理新订单请求和现有订单取消请求的重要操作，以及匹配跨越订单簿另一侧现有被动订单的积极订单。我们还将生成并发布订单响应和市场数据更新回匹配引擎。
- en: Handling new passive orders
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理新的被动订单
- en: 'The first important task we need to perform in the order book is handling client
    order requests that want to enter new orders in the market. We will implement
    the `MEOrderBook::add()` method, which the matching engine calls first. It generates
    and sends `MEClientResponse`, accepting the new order, and sends it to the matching
    engine (to be sent to the client who sent the new order). It then also checks
    to see whether this new order crosses an existing passive order on the other side
    and whether it matches either fully or partially, by calling the `checkForMatch()`
    method. If the new order either does not match at all or is partially filled and
    leaves some quantity in the book, `MEOrder` is added to the order book. In this
    case, it also generates `MEMarketUpdate` for the public market data feed and sends
    it back to the matching engine (to be published by the market data publisher component).
    We will discuss the `getNextPriority()`, `checkForMatch()`, and `addOrder()` methods
    shortly in this section, but let us first explore the `MEOrderBook::add()` method:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在订单簿中，我们需要首先执行的重要任务是处理客户订单请求，这些请求希望在市场中下新订单。我们将实现`MEOrderBook::add()`方法，这是匹配引擎首先调用的方法。它生成并发送`MEClientResponse`，接受新订单，并将其发送给匹配引擎（以发送给发送新订单的客户）。然后，它还会通过调用`checkForMatch()`方法检查新订单是否与另一侧的现有被动订单交叉，以及是否完全或部分匹配。如果新订单根本不匹配或部分填充并留下一些数量在订单簿中，`MEOrder`将被添加到订单簿中。在这种情况下，它还会为公共市场数据馈送生成`MEMarketUpdate`，并将其发送回匹配引擎（由市场数据发布组件发布）。我们将在本节中简要讨论`getNextPriority()`、`checkForMatch()`和`addOrder()`方法，但让我们首先探索`MEOrderBook::add()`方法：
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The first thing it does is generate `new_market_order_id_` to be used for `MEClientResponse`
    and `MEMarketUpdate`. It updates the `client_response_` data member with the attributes
    from this request and calls the `MatchingEngine::sendClientResponse()` method
    to publish that response back to the matching engine:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先生成`new_market_order_id_`，用于`MEClientResponse`和`MEMarketUpdate`。它更新`client_response_`数据成员，其中包含此请求的属性，并调用`MatchingEngine::sendClientResponse()`方法将响应发布回匹配引擎：
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, the `MEOrderBook::add()` method calls the `MEOrderBook::checkForMatch()`
    method, which checks the current state of the order book against the new client
    request that just came in. It checks whether a partial or complete match can be
    made. The `checkForMatch()` method (which we will build shortly) returns the quantity
    of the order left over (if any) after the matching event. For orders that do not
    execute at all, `leaves_qty` returned is the same as the original quantity on
    the order. For orders that partially execute, it is whatever is left after matching.
    For orders that fully execute, this method will return a `0` value and that will
    be assigned to `leaves_qty`. We will see the complete implementation of `checkForMatch()`
    shortly, but for now, let us use it:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`MEOrderBook::add()` 方法调用 `MEOrderBook::checkForMatch()` 方法，该方法检查订单簿的当前状态与刚刚到达的新客户端请求。它检查是否可以做出部分或完全匹配。`checkForMatch()`
    方法（我们很快就会构建）返回匹配事件后剩余的订单数量（如果有）。对于完全没有执行的订单，返回的 `leaves_qty` 与订单上的原始数量相同。对于部分执行的订单，它是匹配后剩余的数量。对于完全执行的订单，此方法将返回
    `0` 值，并将其分配给 `leaves_qty`。我们很快就会看到 `checkForMatch()` 的完整实现，但现在，让我们使用它：
- en: '[PRE57]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the event that there is a quantity left over after the matching event, we
    need to generate a market data update corresponding to this new order that will
    join the book. To do that, the `MEOrderBook::add()` method finds out the correct
    priority value for this order by calling the `MEOrderBook::getNextPriority()`
    method. It allocates a new `MEOrder` object from the `order_pool_` memory pool
    and assigns it the attributes for this order. It then calls the `MEOrderBook::addOrder()`
    method to actually add it at the correct price level and priority in the `MEOrdersAtPrice`
    data structures. Finally, it fills in the `market_update_` object with the values
    for the market update and calls the `MatchingEngine::sendMarketUpdate()` method
    to publish it to the matching engine:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配事件后还有剩余数量，我们需要生成一个与这个新订单相对应的市场数据更新，该订单将加入订单簿。为此，`MEOrderBook::add()` 方法通过调用
    `MEOrderBook::getNextPriority()` 方法来找出这个订单的正确优先级值。它从 `order_pool_` 内存池中分配一个新的
    `MEOrder` 对象，并为其分配这个订单的属性。然后，它调用 `MEOrderBook::addOrder()` 方法，实际上在 `MEOrdersAtPrice`
    数据结构中正确的价格水平和优先级添加它。最后，它用市场更新的值填写 `market_update_` 对象，并调用 `MatchingEngine::sendMarketUpdate()`
    方法将其发布到匹配引擎：
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `getNextPriority()` method is quite straightforward. If a price level already
    exists at a certain price, then it just returns a priority value one higher than
    the last order at that price. If a price level does not already exist, then it
    returns 1 for the first order at that price level:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNextPriority()` 方法相当直接。如果某个价格水平已经存在某个价格，那么它就返回比该价格最后订单高一级的优先级值。如果该价格水平不存在，那么它为该价格水平的第一个订单返回
    `1`：'
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, we will lay out the details of adding a new order to the limit order
    book. The method appends the `MEOrder` object passed to it at the end of the `MEOrdersAtPrice`
    entry at the price for this order. If an `MEOrdersAtPrice` entry does not already
    exist (new price level), it first allocates a new entry, adds the new level into
    the book using the `addOrdersAtPrice()` method, and then appends the order. Additionally,
    it tracks the `MEOrder` object in the `ClientOrderHashMap id_oid_to_order_` map,
    mapping from `ClientId` and `OrderId` to the `MEOrder` objects:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将详细说明如何将新订单添加到限价订单簿。该方法将传递给它的 `MEOrder` 对象追加到该订单的价格的 `MEOrdersAtPrice`
    条目末尾。如果一个 `MEOrdersAtPrice` 条目不存在（新的价格水平），它首先分配一个新的条目，使用 `addOrdersAtPrice()`
    方法将新水平添加到簿中，然后追加订单。此外，它还在 `ClientOrderHashMap id_oid_to_order_` 映射中跟踪 `MEOrder`
    对象，映射从 `ClientId` 和 `OrderId` 到 `MEOrder` 对象：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'First, we try to check and fetch `MEOrdersAtPrice` if one exists by calling
    the `getOrdersAtPrice()` method and saving it in the `orders_at_price` variable.
    Then, we check whether a valid `MEOrdersAtPrice` exists, meaning a price level
    with the price and side of this order already exists. If such a price level does
    not exist and this is the first order that forms that level, we create a new `MEOrdersAtPrice`
    from `orders_at_price_pool_`, initialize it, and call the `addOrdersAtPrice()`
    method on it:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们尝试通过调用 `getOrdersAtPrice()` 方法并保存到 `orders_at_price` 变量中来检查和获取 `MEOrdersAtPrice`，如果存在的话。然后，我们检查是否存在有效的
    `MEOrdersAtPrice`，这意味着存在一个具有该订单价格和方向的定价水平。如果这样的价格水平不存在，并且这是形成该水平的第一个订单，我们就会从 `orders_at_price_pool_`
    中创建一个新的 `MEOrdersAtPrice`，初始化它，并在其上调用 `addOrdersAtPrice()` 方法：
- en: '[PRE61]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If a valid price level exists, we append the new order at the very end of the
    doubly linked list of `MEOrder` objects, reachable from the `first_me_order_`
    member of `MEOrdersAtPrice`. We then update the `prev_order_` and `next_order_`
    pointers on `MEOrder` being added as well as the last element on the list, after
    which the `MEOrder` object is appended:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在有效的价格级别，我们将新的订单附加到`MEOrder`对象的双向链表的末尾，该链表可通过`MEOrdersAtPrice`的`first_me_order_`成员访问。然后，我们更新被添加的`MEOrder`上的`prev_order_`和`next_order_`指针以及链表的最后一个元素，之后`MEOrder`对象被附加：
- en: '[PRE62]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, we add this `MEOrder` pointer to the `cid_oid_to_order_` container,
    which is `std::array` of `std::array` instances, indexed first by `client_id_`
    of the order and then by `client_order_id_` of the order:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将此`MEOrder`指针添加到`cid_oid_to_order_`容器中，该容器是`std::array`的`std::array`实例的`std::array`，首先按订单的`client_id_`索引，然后按订单的`client_order_id_`索引：
- en: '[PRE63]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Finally, to finish the discussion of adding new orders to the book, we need
    to implement the `addOrdersAtPrice()` method to add new price levels to the book.
    This method first adds the new `MEOrdersAtPrice` entry into `OrdersAtPriceHashMap
    price_orders_at_price_`. Then, it walks through the bid or ask price levels, from
    the most aggressive to the least aggressive price, to find the correct spot for
    the new price level. Note that this implementation iterates through the doubly
    linked list of `MEOrdersAtPrice` objects on the side. It is possible to have an
    alternative implementation that walks through the `price_orders_at_price_` hash
    map to find the right spot. Both implementations are viable and perform differently,
    depending on the number of price levels and the distance between consecutive prices.
    We will revisit this topic at the end of the book, in the *Optimizing the Performance
    of Our C++* *System* chapter.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了完成关于向簿中添加新订单的讨论，我们需要实现`addOrdersAtPrice()`方法来向簿中添加新的价格级别。此方法首先将新的`MEOrdersAtPrice`条目添加到`OrdersAtPriceHashMap
    price_orders_at_price_`中。然后，它遍历报价或询问价格级别，从最激进的到最不激进的，以找到新价格级别的正确位置。请注意，此实现遍历`MEOrdersAtPrice`对象的一侧的双向链表。可能有一种替代实现，通过遍历`price_orders_at_price_`哈希图来找到正确的位置。两种实现都是可行的，并且根据价格级别的数量和连续价格之间的距离而有所不同。我们将在本书末尾的*优化我们的C++*
    *系统性能* *章节中重新讨论这个话题。
- en: 'The first task for the `addOrdersAtPrice()` method is to insert the new `MEOrdersAtPrice`
    in the `price_orders_at_price_` hash map, mapping from `Price` to `MEOrdersAtPrice`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`addOrdersAtPrice()`方法的第一个任务是将在`price_orders_at_price_`哈希图中插入新的`MEOrdersAtPrice`，映射从`Price`到`MEOrdersAtPrice`：'
- en: '[PRE64]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, we need to insert it in its correct location for the bids/asks arranged
    by price. We do this by first assigning a `best_orders_by_price` variable to the
    beginning of the bids or asks, sorted by price:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将其插入到按价格排列的买卖报价的正确位置。我们通过首先将一个`best_orders_by_price`变量分配给报价或询问的开始部分，并按价格排序来实现这一点：
- en: '[PRE65]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We need to handle an edge case where there are no bids or no asks – that is,
    a side of the order book is empty. In such a case, we set the `bids_by_price_`
    or `asks_by_price_` members, which point to the head of the sorted list for that
    side:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理一个边缘情况，即没有报价或没有询问——也就是说，订单簿的一侧是空的。在这种情况下，我们设置`bids_by_price_`或`asks_by_price_`成员，它们指向该侧排序列表的头部：
- en: '[PRE66]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Otherwise, we need to find the correct entry in the doubly linked list of price
    levels. We do this by walking through the bids or the asks till we find the correct
    price level, before or after which we insert the new price level. We track the
    price level before or after the new one in the following `target` variable, and
    we track whether we need to insert after or before the target variable using the
    `add_after` Boolean flag:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们需要在价格级别的双向链表中找到正确的条目。我们通过遍历报价或询问，直到找到正确的价格级别，在它之前或之后插入新的价格级别来实现这一点。我们在以下`target`变量中跟踪新价格级别之前或之后的价格级别，并使用`add_after`布尔标志跟踪我们是否需要在目标变量之后或之前插入：
- en: '[PRE67]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Once we find the correct location for the new `MEOrdersAtPrice` entry, we append
    the new price level by updating the `prev_entry_` or `next_entry_` variables in
    the `target` `MEOrdersAtPrice` structure, as well as the new `MEOrdersAtPrice`
    being appended, as shown here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了新的`MEOrdersAtPrice`条目的正确位置，我们就通过更新`target` `MEOrdersAtPrice`结构中的`prev_entry_`或`next_entry_`变量以及被附加的新`MEOrdersAtPrice`来附加新的价格级别，如下所示：
- en: '[PRE68]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, if we add the new price level before an existing price level, we need
    to check whether prepending this price level changes the `bids_by_price_` or `asks_by_price_`
    variable. Remember that these variables track the start of the bids or asks, respectively
    – that is, the highest bid price and the lowest ask price. If we have a new best
    bid/ask price level, we update the `bids_by_price_` or `asks_by_price_` variable,
    respectively:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们在一个现有价格级别之前添加新的价格级别，我们需要检查是否将此价格级别添加到前面会改变 `bids_by_price_` 或 `asks_by_price_`
    变量。记住，这些变量分别跟踪出价或要价的开始——也就是说，最高的出价价格和最低的要价价格。如果我们有一个新的最佳出价/要价价格级别，我们将分别更新 `bids_by_price_`
    或 `asks_by_price_` 变量：
- en: '[PRE69]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Next, we will discuss the source code that handles order cancellation requests.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论处理订单取消请求的源代码。
- en: Handling order cancellation requests
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理订单取消请求
- en: The code to handle order cancellation requests is forwarded from the matching
    engine. First, it checks to see whether the cancel request is valid, meaning that
    `ClientId` is valid and `OrderId` on the cancellation request corresponds to an
    active order in the order book. If the order is not cancellable, it generates
    and publishes an `MEClientResponse` message to signify a rejected cancel request
    back to the matching engine. If the order can be canceled, it generates `MEClientResponse`
    to signify the successful cancel attempt and calls the `removeOrder()` method
    to remove the order from the limit order book. We will discuss the details of
    `removeOrder()` right after this next method.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 处理订单取消请求的代码是从撮合引擎转发的。首先，它检查取消请求是否有效，这意味着 `ClientId` 是有效的，并且取消请求中的 `OrderId`
    与订单簿中的活动订单相对应。如果订单不可取消，它将生成并发布一个 `MEClientResponse` 消息来表示拒绝的取消请求返回给撮合引擎。如果订单可以取消，它将生成
    `MEClientResponse` 来表示成功的取消尝试，并调用 `removeOrder()` 方法从限价订单簿中删除订单。我们将在下一个方法之后讨论
    `removeOrder()` 的细节。
- en: 'We will track an `is_cancelable` Boolean variable that determines whether we
    were able to successfully find and cancel the client’s order or not. If `client_id`
    is larger than the maximum possible client ID value, then we cannot cancel the
    order. If the client ID is valid, then we check the container from `cid_oid_to_order_`
    for the provided `client_id` and the `order_id` value. If a valid order does not
    exist, then we confirm that the order is not cancelable:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跟踪一个 `is_cancelable` 布尔变量，以确定我们是否能够成功找到并取消客户端的订单。如果 `client_id` 大于最大可能的客户端
    ID 值，则我们无法取消订单。如果客户端 ID 有效，则我们检查 `cid_oid_to_order_` 容器中的提供的 `client_id` 和 `order_id`
    值。如果不存在有效的订单，则我们确认订单不可取消：
- en: '[PRE70]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If we determine that the order cannot be cancelled, we generate an `MEClientResponse`
    message of type `ClientResponseType::CANCEL_REJECTED` to notify the matching engine:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确定订单无法取消，我们将生成一个类型为 `ClientResponseType::CANCEL_REJECTED` 的 `MEClientResponse`
    消息来通知撮合引擎：
- en: '[PRE71]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If we can successfully cancel the order, we update the attributes in the `client_response_`
    member variable and the `market_update_` member variable. Then, we call the `removeOrder()`
    method to update our order book and delete this order from it. Finally, we send
    the market update to the matching engine, using the `sendMarketUpdate()` method,
    and we send the client response to the matching engine, using the `sendClientResponse()`
    method:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们成功取消订单，我们将更新 `client_response_` 成员变量和 `market_update_` 成员变量中的属性。然后，我们调用
    `removeOrder()` 方法来更新我们的订单簿并从其中删除此订单。最后，我们使用 `sendMarketUpdate()` 方法将市场更新发送给撮合引擎，并使用
    `sendClientResponse()` 方法将客户端响应发送给撮合引擎：
- en: '[PRE72]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, let us implement the `removeOrder()` method. It first finds `MEOrdersAtPrice`
    that the order being removed belongs to and then finds and removes `MEOrder` from
    the list of orders contained in `MEOrdersAtPrice`. If the order being removed
    is the only order at the price level, the method also calls `removeOrdersAtPrice()`
    to remove the entire price level, since after this deletion, that no longer exists.
    Finally, it removes the entry for that `MEOrder` from the `cid_oid_to_order_`
    hash map and returns the deallocated `MEOrder` object to the `order_pool_` memory
    pool:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现 `removeOrder()` 方法。它首先找到被删除订单所属的 `MEOrdersAtPrice`，然后从 `MEOrdersAtPrice`
    中包含的订单列表中找到并删除 `MEOrder`。如果被删除的订单是该价格级别的唯一订单，该方法还将调用 `removeOrdersAtPrice()` 来删除整个价格级别，因为在此删除之后，该价格级别将不再存在。最后，它从
    `cid_oid_to_order_` 哈希表中删除该 `MEOrder` 的条目，并将释放的 `MEOrder` 对象返回到 `order_pool_`
    内存池：
- en: '[PRE73]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To conclude our discussion of tasks involved in handling order cancellation
    requests, we will implement the `removeOrdersAtPrice()` method. It finds and removes
    `MEOrdersAtPrice` from the doubly linked list of `MEOrdersAtPrice` for the bid
    or ask side. If this price entry being removed happens to be the only `MEOrdersAtPrice`
    entry on that side of the book, it sets the head of the doubly linked list to
    be `nullptr`, representing an empty side of the book. Finally, the method removes
    the entry from the `price_orders_at_price_` hash map for that price and returns
    the deallocated `MEOrdersAtPrice` to the `orders_at_price_pool_` memory pool:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束我们对处理订单取消请求所涉及的任务的讨论，我们将实现 `removeOrdersAtPrice()` 方法。它从出价或询问侧的 `MEOrdersAtPrice`
    的双链表中查找并删除 `MEOrdersAtPrice`。如果被删除的价格条目恰好是该侧订单簿上唯一的 `MEOrdersAtPrice` 条目，它将双链表的头设置为
    `nullptr`，表示订单簿的一侧为空。最后，该方法从该价格的价格订单哈希表 `price_orders_at_price_` 中删除条目，并将释放的 `MEOrdersAtPrice`
    返回到 `orders_at_price_pool_` 内存池：
- en: '[PRE74]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The last operation we need to tackle is an important one – matching aggressive
    orders against passive orders on the other side of the order book. We will look
    at the implementation of that operation next.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理的最后一个操作是一个重要的操作——将侵略性订单与订单簿另一侧的被动订单进行匹配。我们将在下一节中查看该操作的实现。
- en: Matching aggressive orders and updating the order book
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配侵略性订单并更新订单簿
- en: In this subsection, we will implement the matching functionality in the limit
    order book by presenting the `MEOrderBook::checkForMatch()` method we encountered
    earlier. The diagram presented in *Figure 6**.3* shows what would happen in a
    hypothetical state of the limit order book. Here, the state of the ask side is
    shown, and the passive sell prices represented by `MEOrdersAtPrice` are `MEOrder`
    objects are shown, the first one with a priority of `MEOrder` following that in
    the FIFO queue has a priority of **13**, a market order ID of **1400**, and a
    quantity of **10**. In this case, a new buy order with a quantity of **25** and
    a price of **117** (represented in blue) will match the first order with a market
    order ID of **1200** (represented in yellow) and execute it fully. It will then
    partially execute the remaining quantity of **5** against the order with a market
    order ID of **1400** (represented in magenta), and the matching event is finished.
    These steps are presented in the algorithm right after the following diagram.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将通过展示我们之前遇到的 `MEOrderBook::checkForMatch()` 方法来实现限价订单簿中的匹配功能。图 6.3 所示的图解展示了在限价订单簿的假设状态下会发生什么。在这里，展示了询问侧的状态，由
    `MEOrdersAtPrice` 表示的被动卖价是 `MEOrder` 对象，第一个具有 `MEOrder` 的优先级，在 FIFO 队列中跟随的具有优先级
    **13**，市场订单 ID 为 **1400**，数量为 **10**。在这种情况下，一个数量为 **25**、价格为 **117**（用蓝色表示）的新买订单将与市场订单
    ID 为 **1200**（用黄色表示）的第一个订单匹配，并完全执行它。然后，它将对市场订单 ID 为 **1400**（用洋红色表示）的订单的剩余数量 **5**
    进行部分执行，并完成匹配事件。这些步骤在以下图解的算法中展示。
- en: "![Figure 6.3 – An exa\uFEFFmple of a matching event in the limit order book](img/Figure_6.3_B19434.jpg)"
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 限价订单簿中匹配事件的示例](img/Figure_6.3_B19434.jpg)'
- en: Figure 6.3 – An example of a matching event in the limit order book
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 限价订单簿中匹配事件的示例
- en: 'This method iterates through the `MEOrdersAtPrice` objects on the side of the
    book opposite to the new (and possibly aggressive) order. It iterates through
    the price levels from the most aggressive to least aggressive price and, for each
    price level, matches the `MEOrder` objects contained at that price level from
    the first to last, in the FIFO order. It continues matching the new order against
    the passive orders on the other side, from the most aggressive to the least aggressive
    price and in the first to last order at a price level, by calling the `match()`
    method. It stops and returns when either the new aggressive order has no more
    unmatched quantity left to match, the remaining price levels on the other side
    no longer cross the new order’s price, or the side of the book is empty. At that
    point, it returns the remaining unmatched quantity on the new order to the caller:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法遍历位于新（可能具有侵略性）订单对面的一侧的 `MEOrdersAtPrice` 对象。它从最具有侵略性到最不具有侵略性的价格水平遍历价格，并且对于每个价格水平，按照先进先出（FIFO）的顺序，从第一个到最后一个匹配该价格水平下包含的
    `MEOrder` 对象。它继续将新订单与另一侧的被动订单进行匹配，从最具有侵略性到最不具有侵略性的价格，并在价格水平的第一到最后一个订单，通过调用 `match()`
    方法。当新侵略性订单没有更多未匹配的数量可以匹配，另一侧剩余的价格水平不再与新订单的价格交叉，或者订单簿的一侧为空时，它停止并返回。此时，它将新订单上剩余的未匹配数量返回给调用者：
- en: '[PRE75]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We keep iterating through all the ask price levels, arranged from the lowest
    to the highest prices, starting from the `asks_by_price_` level. For the `asks_by_price_`
    level, we start from the `first_me_order_` object of the `MEOrder` type pointer
    and iterate in the FIFO order, from the lowest to the highest priority. For each
    order that can match against the new aggressive order, we call the `MEOrder::match()`
    method to perform the actual match. We continue doing this till either there is
    no more `leaves_qty` left, the `asks_by_price_` variable is `nullptr` to signify
    an empty book side, or the remaining price levels cannot be used to match the
    new order:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们持续迭代所有询问价格水平，从最低价格到最高价格排列，从`asks_by_price_`级别开始。对于`asks_by_price_`级别，我们从`MEOrder`类型指针的`first_me_order_`对象开始，按照先进先出（FIFO）的顺序迭代，从最低到最高优先级。对于每个可以与新激进订单匹配的订单，我们调用`MEOrder::match()`方法来执行实际匹配。我们继续这样做，直到没有更多的`leaves_qty`剩余，`asks_by_price_`变量为`nullptr`表示空订单簿的一侧，或者剩余的价格水平无法用于匹配新订单：
- en: '[PRE76]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If the new order has a side of sell, we perform the same logic as described
    previously, except we iterate through the `bids_by_price_` price levels, which
    are arranged from the highest buy price to the lowest buy price, as shown here:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新订单有一侧是卖出，我们将执行与之前描述相同的逻辑，只是我们迭代`bids_by_price_`价格水平，这些价格水平从最高买入价格到最低买入价格排列，如下所示：
- en: '[PRE77]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `match()` method is called when a new aggressive order matches an existing
    passive order on the other side of the book. It computes the executed quantity,
    which is the minimum of the quantity of the new order and the existing passive
    order it would match against. It subtracts this executed quantity from the remaining
    quantity of the aggressive order, as well as the passive order it matched against.
    It generates two execution order responses and sends them to the matching engine
    – one for the client who sent the aggressive order and another one for the client
    whose passive order got executed against the new order. It also creates and publishes
    a market update of type `MarketUpdateType::TRADE` to notify participants about
    the execution on the public market data feed. Finally, it checks whether this
    trade transaction fully executes the passive order or not, and if there is a full
    execution, it generates another market update of type `MarketUpdateType::CANCEL`
    to notify participants that the passive order has been removed. If the passive
    order is only partially matched, it instead generates a market update of type
    `MarketUpdateType::MODIFY` with the new remaining quantity of the passive limit
    order.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当新激进订单与订单簿另一侧的现有被动订单匹配时，会调用`match()`方法。它计算执行数量，这是新订单数量和它将与之匹配的现有被动订单数量的最小值。它从这个执行数量中减去激进订单的剩余数量以及与之匹配的被动订单。它生成两个执行订单响应并发送给匹配引擎——一个发送给发送激进订单的客户，另一个发送给被动订单被执行的客户。它还创建并发布一个类型为`MarketUpdateType::TRADE`的市场更新，以通知参与者关于公共市场数据流中的执行情况。最后，它检查这笔交易是否完全执行了被动订单，如果是完全执行，它生成另一个类型为`MarketUpdateType::CANCEL`的市场更新，通知参与者被动订单已被移除。如果被动订单只是部分匹配，它将生成一个类型为`MarketUpdateType::MODIFY`的市场更新，包含被动限价订单的新剩余数量。
- en: What this means is that participants who choose to ignore trade messages from
    the market data stream can still accurately build and maintain the limit order
    book. We could theoretically eliminate the extra cancel or modify market update,
    but that would require downstream market data consumers to apply trade messages
    to their order books and update them.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着选择忽略市场数据流中的交易消息的参与者仍然可以准确地构建和维护限价订单簿。理论上，我们可以消除额外的取消或修改市场更新，但这将要求下游市场数据消费者将交易消息应用于他们的订单簿并更新它们。
- en: 'The `MEOrderBook::match()` method takes a few arguments to identify the client
    information, but the key arguments are the `MEOrder` pointer, `itr`, and the `Qty`
    pointer, `leaves_qty`. The `MEOrder` pointer represents the order in the book
    that the new order is being matched against, and `Qty` represents the remaining
    quantity on the new order. These arguments are passed by pointer because we will
    modify them directly in this method and expect the changes to be reflected in
    the calling method:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`MEOrderBook::match()`方法接受一些参数来识别客户信息，但关键参数是`MEOrder`指针`itr`和`Qty`指针`leaves_qty`。`MEOrder`指针代表订单簿中与新订单匹配的订单，而`Qty`代表新订单上的剩余数量。这些参数通过指针传递，因为我们将在该方法中直接修改它们，并期望这些更改在调用方法中反映出来：'
- en: '[PRE78]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We compute the `fill_qty` variable to be the minimum of the quantity on the
    passive order that exists in the book and the new order’s quantity. We then use
    `fill_qty` to decrease both `leaves_qty` and the `qty_` member on the `MEOrder`
    object:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算 `fill_qty` 变量，使其成为账本中存在的被动订单数量和新订单数量的最小值。然后我们使用 `fill_qty` 减少订单簿中的 `leaves_qty`
    和 `MEOrder` 对象上的 `qty_` 成员：
- en: '[PRE79]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We generate a client response message of type `ClientResponseType::FILLED`,
    meant for the client who sent the new order, and dispatch it to the matching engine
    using the `sendClientResponse()` method:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成一个类型为 `ClientResponseType::FILLED` 的客户端响应消息，是为发送新订单的客户准备的，并使用 `sendClientResponse()`
    方法将其调度到匹配引擎：
- en: '[PRE80]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We also generate a second client response message of `type_` `ClientResponseType::FILLED`;
    this one is meant for the client whose order was in the order book and got matched:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还生成了一个第二客户端响应消息，类型为 `ClientResponseType::FILLED`；这个消息是为订单在订单簿中且被匹配的客户准备的：
- en: '[PRE81]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We will also generate a market update of type `MarketUpdateType::TRADE` and
    publish it using `sendMarketUpdate()`, notifying the participants about the trade
    transaction that occurred and providing them with `fill_qty`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将生成一个类型为 `MarketUpdateType::TRADE` 的市场更新，并使用 `sendMarketUpdate()` 方法发布它，通知参与者关于发生的交易交易，并为他们提供
    `fill_qty`：
- en: '[PRE82]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, we will generate a market update for the passive client order that
    existed in the book. If there is some quantity remaining on this `MEOrder`, then
    we generate a `MarketUpdateType::MODIFY` message and pass the remaining quantity
    left on that order. If the order is fully executed, then we generate a `MarketUpdateType::CANCEL`
    update, publish it, and also call the `MEOrderBook::removeOrder()` method to remove
    this `MEOrder` from the order book:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为账本中存在的被动客户订单生成一个市场更新。如果这个 `MEOrder` 上还有剩余数量，那么我们生成一个 `MarketUpdateType::MODIFY`
    消息，并传递该订单上剩余的数量。如果订单完全执行，则生成一个 `MarketUpdateType::CANCEL` 更新，发布它，并调用 `MEOrderBook::removeOrder()`
    方法从订单簿中移除这个 `MEOrder`：
- en: '[PRE83]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This concludes our discussion of the operations involved in handling client
    order requests, updating the limit order book inside the matching engine, and
    generating and publishing order responses and market updates.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对处理客户订单请求、更新匹配引擎内部的限价订单簿以及生成和发布订单响应和市场更新的操作的讨论。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started the C++ implementation of our electronic trading ecosystem in this
    chapter. The first component we built was the exchange matching engine in charge
    of accepting and answering order requests from the order server component in the
    exchange infrastructure. This component is also responsible for generating and
    publishing market data updates to the market data publisher component in the exchange’s
    infrastructure.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中开始了我们的电子交易生态系统的 C++ 实现。我们构建的第一个组件是交易所匹配引擎，该引擎负责接受和回答来自交易所基础设施中订单服务器组件的订单请求。此组件还负责生成和发布市场数据更新到交易所基础设施中的市场数据发布者组件。
- en: First, we declared some assumptions in our matching engine and limit order books.
    We also defined a couple of basic `OrderId` and chain together orders at the same
    price inside the `MEOrdersAtPrice` structure. Reiterating what we already covered,
    these price levels themselves are maintained in a doubly linked list and a hash
    map indexed by price.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在我们的匹配引擎和限价订单簿中声明了一些假设。我们还定义了一些基本的 `OrderId`，并在 `MEOrdersAtPrice` 结构中将相同价格下的订单链接在一起。重申我们之前已经讨论过的内容，这些价格级别本身是在一个双向链表和按价格索引的哈希表中维护的。
- en: Then, we built the matching engine component, which is an independent thread
    of execution that consumes updates from the order server and publishes responses
    and market data updates back to the order server and the market data publisher.
    We also built the main application binary for the electronic trading exchange,
    which we will enhance in the next chapter.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构建了匹配引擎组件，这是一个独立的执行线程，它从订单服务器消费更新，并将响应和市场数据更新发布回订单服务器和市场数据发布者。我们还构建了电子交易交易所的主应用程序二进制文件，我们将在下一章中对其进行增强。
- en: Finally, we laid out the details of the mechanism involved in building and updating
    the data structures for the limit order book. We discussed the tasks involved
    in handling new order requests and order cancelation requests. We also implemented
    the functionality of the matching engine to perform the actual matching between
    new aggressive orders against existing passive orders that cross in price. Match
    events generate private execution messages for the market participants involved
    in a match event. Additionally, the event also generates trade messages and order
    deletion or modification on the public market data feed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们详细阐述了构建和更新限价订单簿数据结构的机制。我们讨论了处理新订单请求和订单取消请求所涉及的任务。我们还实现了撮合引擎的功能，以执行新积极订单与现有被动订单之间的实际匹配，这些订单在价格上交叉。匹配事件为参与匹配事件的参与者生成私有执行消息。此外，该事件还生成交易消息和公共市场数据流上的订单删除或修改。
- en: In the next chapter, we will build the market data publisher component, which
    is the component that consumes the market data updates generated from the matching
    engine and puts them on the wire for participants to consume. Additionally, we
    will also build the order server component that resides in the electronic trading
    exchange and manages the communication with the different market participant order
    gateways, forwarding requests and responses to and from the matching engine.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建市场数据发布者组件，该组件负责消费由撮合引擎生成的市场数据更新，并将其传输到线上供参与者消费。此外，我们还将构建位于电子交易交易所中的订单服务器组件，该组件负责与不同市场参与者订单网关的通信，将请求和响应转发到和从撮合引擎。
