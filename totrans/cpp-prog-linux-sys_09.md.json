["```cpp\nstruct Book {\n   string_view title;\n   Book(string_view p_title) : title(p_title) {\n        cout << \"Constructor for: \" << title << endl; }\n   ~Book() {cout << \"Destructor for: \" << title << endl;}};\nint main() {\n    unique_ptr<Book> book1 =\n        make_unique<Book>(\"Jaws\");\n    unique_ptr<Book> book1_new;\n    book1_new = move(book1); // {1}\n    cout << book1_new->title << endl;\n    shared_ptr<Book> book2 =\n        make_unique<Book>(\"Dune\");\n    shared_ptr<Book> book2_new;\n    book2_new = book2; // {2}\n    cout << book2->title <<\" \"<< book2_new->title << endl;\n    cout << book2.use_count() << endl;\n```", "```cpp\nConstructor for: Jaws\nJaws\nConstructor for: Dune\nDune Dune\n2\nDestructor for: Dune\nDestructor for: Jaws\n```", "```cpp\nstruct ListNode {\n    Book data;\n    ListNode(string_view p_title) {\n        data.title = p_title;\n        cout << \"Node created: \" << data.title << endl;\n    }\n```", "```cpp\n    ~ListNode() {\n        cout << \"Node destroyed: \" << data.title\n             << endl;\n    }\n    shared_ptr<ListNode> next;\n    weak_ptr<ListNode> prev;\n};\nint main() {\n    shared_ptr<ListNode> head =\n        make_shared<ListNode>(\"Dune\");\n    head->next = make_shared<ListNode>(\"Jaws\");\n    if (!head->next->prev.expired())\n        head->next->prev = head;\n```", "```cpp\nNode created: Dune\nNode created: Jaws\nNode destroyed: Dune\nNode destroyed: Jaws\n```", "```cpp\n#include <iostream>\n#include <chrono>\n#include <optional>\n#include <string_view>\n#include <thread>\nusing namespace std;\nusing namespace std::literals::chrono_literals;\nstruct Settings {\n    Settings(string_view fileName) {\n        cout << \"Loading settings: \" << fileName << endl;\n    }\n    ~Settings() {\n        cout << \"Removing settings\" << endl;\n    }\n```", "```cpp\n    void setSetting(string_view setting,\n                    string_view value) {\n        cout << \"Set setting: \" << setting\n             << \" to: \" << value << endl;\n    }\n};\n```", "```cpp\nstruct Config {\n    optional<Settings> settings{};\n    Config() {\n        cout << \"Config loaded...\" << endl;\n    }\n    void changeSetting(string_view setting,\n                       string_view value) {\n        if (!settings)\n            settings.emplace(\"settings.cfg\");\n        settings->setSetting(setting, value);\n    }\n};\nint main() {\n    Config cfg;\n    cout << \"Application startup...\" << endl;\n    this_thread::sleep_for(10s);\n    cfg.changeSetting(\"Drive mode\", \"Sport\");\n    cfg.changeSetting(\"Gear label\", \"PRNDL\");\n```", "```cpp\nConfig loaded...\nApplication startup...\nLoading settings: settings.cfg\nSet setting: Drive mode to: Sport\nSet setting: Gear label to: PRNDL\nRemoving settings\n```", "```cpp\n...\npthread_cond_t  condition_variable;\npthread_mutex_t condition_lock;\n...\npthread_cond_init(&condition_variable, NULL);\n...\nvoid consume() {\n    pthread_mutex_lock(&condition_lock);\n    while (shared_res == 0)\n        pthread_cond_wait(&condition_variable,\n                          &condition_lock);\n    // Consume from shared_res;\n    pthread_mutex_unlock(&condition_lock);\n}\nvoid produce() {\n    pthread_mutex_lock(&condition_lock);\n    if (shared_res == 0)\n        pthread_cond_signal(&condition_variable);\n    // Produce for shared_res;\n    pthread_mutex_unlock(&condition_lock);\n}\npthread_mutex_unlock(&condition_lock);\n...\npthread_cond_destroy(&condition_variable);\n...\n```", "```cpp\n...\n#include <condition_variable>\nmutex cv_mutex;\ncondition_variable cond_var;\n...\nvoid waiting() {\n    cout << \"Waiting for work...\" << endl;\n    unique_lock<mutex> lock(cv_mutex);\n    cond_var.wait(lock);\n    processing();\n    cout << \"Work done.\" << endl;\n}\nvoid done() {\n    cout << \"Shared resource ready.\"  << endl;\n    cond_var.notify_one();\n}\nint main () {\n    jthread t1(waiting); jthread t2(done);\n    t1.join(); t2.join();\n    return 0;\n}\n```", "```cpp\nWaiting for work...\nShared resource ready.\nProcessing shared resource.\nWork done.\n```", "```cpp\nwhile (!token.stop_requested())\n```", "```cpp\n#include <condition_variable>\n#include <iostream>\n#include <mutex>\n#include <thread>\n#include <syncstream>\nusing namespace std;\nint main() {\n    osyncstream{cout} << \"Main thread id: \"\n                      << this_thread::get_id()\n                      << endl;\n```", "```cpp\n    jthread worker{[](stop_token token) {\n        mutex mutex;\n        unique_lock lock(mutex);\n        condition_variable_any().wait(lock, token,\n            [&token] { return token.stop_requested(); });\n        osyncstream{cout} << \"Thread with id \"\n                          << this_thread::get_id()\n                          << \" is currently working.\"\n                          << endl;\n    }};\n    stop_callback callback(worker.get_stop_token(), [] {\n    osyncstream{cout} <<\"Stop callback executed by thread:\"\n                      << this_thread::get_id()\n                      << endl;\n    });\n    auto stopper_func = [&worker] {\n        if (worker.request_stop())\n            osyncstream{cout} << \"Stop request executed by\n              thread: \"\n                              << this_thread::get_id()\n                              << endl;\n    };\n    jthread stopper(stopper_func);\n    stopper.join(); }\n```", "```cpp\nMain thread id: 140323902175040\nStop callback executed by thread: 140323893778176\nStop request executed by thread: 140323893778176\nThread with id 140323902170880 is currently working.\n```", "```cpp\ntemplate<typename T>\nstruct mmap_deallocator {\n    size_t m_size;\n    mmap_deallocator(size_t size) : m_size{size} {}\n    void operator()(T *ptr) const {\n       munmap(ptr, m_size);\n    }\n};\n```", "```cpp\nunique_ptr<T, mmap_deallocator<T>>(obj, del);\n```", "```cpp\nmutex cv_mutex;\ncondition_variable cond_var;\nbool work_done = false;\n```", "```cpp\ntemplate<typename T, typename N>\nauto producer(T buffer, N size) {\n    unique_lock<mutex> lock(cv_mutex);\n    cond_var.wait(lock, [] { return work_done == false; });\n    if (int fd =\n            shm_open(SHM_ID, O_CREAT | O_RDWR, 0644);\n                     fd != -1) {\n        ftruncate(fd, size);\n```", "```cpp\n        if (auto ptr =\n                mmap(0, size,\n                     PROT_RW, MAP_SHARED,\n                     fd, 0); ptr != MAP_FAILED) {\n            auto obj = new (ptr) T(buffer);\n            auto del = mmap_deallocator<T>(size);\n            work_done = true;\n            lock.unlock();\n            cond_var.notify_one();\n            return unique_ptr<T,\n                mmap_deallocator<T>>(obj, del);\n        }\n        else {\n          const auto ecode{ make_error_code(errc{errno}) };\n…\n        }\n    }\n    else {\n        const auto ecode{ make_error_code(errc{errno}) };\n...\n        throw exception;\n    }\n    // Some shm function failed.\n    throw bad_alloc();\n}\n```", "```cpp\ncond_var.wait(lock, []{ return work_done == true; });\n```", "```cpp\nSending: This is a testing message!\nReceiving: This is a testing message!\n```", "```cpp\nstruct Book {\n    string_view title;\n    string_view author;\n    uint32_t    year;\n};\nshared_mutex shresMutex;\nvector<Book> shared_data =  {{\"Harry Potter\", ...\n```", "```cpp\nvoid wr_addNewBook(string_view title,\n                   string_view author,\n                   uint32_t year) {\n    lock_guard<shared_mutex> writerLock(shresMutex); // {1}\n    osyncstream{cout} << \"Add new book: \" << title << endl;\n    shared_data.emplace_back(Book {title, author, year});\n    this_thread::sleep_for(500ms);\n}\n```", "```cpp\nvoid rd_applyYearFilter(uint32_t yearKey) {\n    auto year_filter =\n        [yearKey](const auto& book)\n       { return book.year < yearKey; };\n    shared_lock<shared_mutex> readerLock(shresMutex);\n    osyncstream{cout}\n   << \"Apply year filter: \" << endl; // {2}\n    for (const auto &book : shared_data |\n                            views::filter(year_filter))\n        osyncstream{cout} << book.title << endl;\n}\n```", "```cpp\nvoid rd_Reversed() {\n    for (const auto &book : views::reverse(shared_data))\n        osyncstream{cout} << book.title << endl; ...\n```", "```cpp\nfor (const auto &book :\n         views::reverse(shared_data) |\n         views::filter([nameSizeKey](Book book)\n              {return book.author.size() < nameSizeKey;}))}\n```", "```cpp\nfor (const auto &book :\n   ranges::drop_view(shared_data, dropKey))\n        osyncstream{cout} << book.title << endl;\n```", "```cpp\nauto const sub_res =\n    ranges::subrange(shared_data.begin(),\n                     shared_data.begin()+5);\n    for (const auto& book: sub_res){\n        osyncstream{cout}\n        << book.title << \" \" << book.author\n             <<  \" \" << book.year << endl;\n```", "```cpp\n    thread yearFilter1(\n        []{ rd_applyYearFilter(1990); });\n    thread reversed(\n        []{ rd_Reversed(); });\n    thread reversed_and_filtered(\n        []{ rd_ReversedFilteredByAuthorNameSize(8); });\n    thread addBook1(\n        []{ wr_addNewBook(\"Dune\", \"Herbert\", 1965); });\n    thread dropFirstElements(\n        []{ rd_dropFirstN(1); });\n    thread addBook2(\n        []{ wr_addNewBook(\"Jaws\", \"Benchley\", 1974); });\n    thread yearFilter2(\n        []{ rd_applyYearFilter(1970); });\n```", "```cpp\nApply reversed order:\nIt\nEast of Eden\nHarry Potter\nDrop first N elements:\nEast of Eden\nIt\nApply reversed order and filter by author name size:\nIt\nHarry Potter\nApply year filter:\nEast of Eden\nIt\nAdd new book: Dune\nApply year filter:\nEast of Eden\nDune\nAdd new book: Jaws\nPrint subranged books in main thread:\nEast of Eden Steinbeck 1952\nIt King 1986\n```", "```cpp\n#include <iostream>\n#include <new>\nusing std::hardware_destructive_interference_size;\nint main() {\n    std::cout << \"L1 Cache Line size: \"\n        << hardware_destructive_interference_size\n        << \" bytes\";\n    return 0;\n}\n```", "```cpp\nL1 Cache Line size: 64 bytes\n```", "```cpp\n    cout << \"L1 Cache Line size: \"\n         << hardware_constructive_interference_size\n         << \" bytes\" << endl;\n    atomic<uint32_t> a_var1;\n    atomic<uint32_t> a_var2;\n    atomic<uint32_t> a_var3;\n```", "```cpp\n       cout << \"The atomic var size is: \" << sizeof(a_var1)\n            << \" and its address are: \\n\"\n            << &a_var1 << endl\n            << &a_var2 << endl\n            << &a_var3 << endl;\n        ...\n```", "```cpp\nL1 Cache Line size: 64 bytes\nThe atomic var size is: 4 and the addresses are:\n0x7ffeb0a11c7c\n0x7ffeb0a11c78\n0x7ffeb0a11c74\n```", "```cpp\n    alignas(hardware_destructive_interference_size)\n        atomic<uint32_t> a_var1;\n```", "```cpp\nL1 Cache Line size: 64 bytes\nThe atomic var size is: 4 and the addresses are:\n0x7ffc3ac0af40\n0x7ffc3ac0af00\n0x7ffc3ac0aec0\n```", "```cpp\nvoid increment(std::atomic<uint32_t>& shared_res) {\n    for(int I = 0; i < 100000; ++i) {shared_res++;}\n}\n```", "```cpp\n    ...\n    auto start = chrono::steady_clock::now();\n    alignas(hardware_destructive_interference_size)\n        atomic<uint32_t> a_var1 = 0;\n    alignas(hardware_destructive_interference_size)\n        atomic<uint32_t> a_var2 = 0;\n    alignas(hardware_destructive_interference_size)\n        atomic<uint32_t> a_var3 = 0;\n    jthread t1([&]() {increment(a_var1);});\n    jthread t2([&]() {increment(a_var2);});\n    jthread t3([&]() {increment(a_var3);});\n    t1.join();\n    t2.join();\n    t3.join();\n    auto end = chrono::steady_clock::now();\n    ...\n```", "```cpp\nThread 1: shrd_res++; T1: load value\n                      T1: add 1\nThread 2: shrd_res++; T2: load value\n                      T2: add 1\n                      T2: store value\n                      T1: store value\n```", "```cpp\n    memory_order_relaxed = memory_order::relaxed;\n    ```", "```cpp\n    memory_order_acquire = memory_order::acquire;\n    memory_order_release = memory_order::release;\n    memory_order_acq_rel = memory_order::acq_rel;\n    ```", "```cpp\n    memory_order_consume = memory_order::consume;\n    ```", "```cpp\n    memory_order_seq_cst = memory_order::seq_cst;\n    ```", "```cpp\nstruct SpinLock {\n    atomic_bool state = false;\n    void lock() {\n        while (state.exchange(true,\n                              std::memory_order_acquire){\n            while (state.load(std::memory_order_relaxed))\n           // Consider this_thread::yield()\n                // for excessive iterations, which\n                // go over a given threshold.\n}\n    void unlock() noexcept {\n        state.store(false, std::memory_order_release); };\n```", "```cpp\nstruct TicketLock {\n    alignas(hardware_destructive_interference_size)\n        atomic_size_t serving;\n    alignas(hardware_destructive_interference_size)\n        atomic_size_t next;\n```", "```cpp\n    void lock() {\n        const auto ticket = next.fetch_add(1,\n                                memory_order_relaxed);\n        while (serving.load(memory_order_acquire) !=\n               ticket);\n    }\n    void unlock() {\n        serving.fetch_add(1, memory_order_release);\n    }\n};\n```", "```cpp\nTicketLock spinlock = {0};\nvector<string> shared_res {};\nvoid producer() {\n    for(int i = 0; i < 100; i ++) {\n        osyncstream{cout} << \"Producing: \" << endl;\n        spinlock.lock();\n        shared_res.emplace_back(\"test1\");\n        shared_res.emplace_back(\"test2\");\n        for (const auto& el : shared_res)\n            osyncstream{cout} << \"p:\" << el << endl;\n        spinlock.unlock();\n        this_thread::sleep_for(100ms);\n    }\n}\n```", "```cpp\nvoid consumer() {\n    for (int i = 0; i < 100; i ++) {\n         this_thread::sleep_for(100ms);\n         osyncstream{cout} << \"Consuming: \" << endl;\n         spinlock.lock();\n         for (const auto& el : shared_res)\n             osyncstream{cout} << \"c:\" << el << endl;\n```", "```cpp\n         shared_res.clear();\n         spinlock.unlock();\n         if (shared_res.empty())\n             osyncstream{cout} << \"Consumed\" << endl;\n     }\n}\n```", "```cpp\nProducing:\np:test1\np:test2\nConsuming:\nc:test1\nc:test2\n...\n```", "```cpp\nvoid producer() {\n    for(int i = 0; i < 100; i ++) {\n        cout <<\"Producing:\" << endl;\n        unique_lock<mutex> mtx(cv_mutex);\n        cond_var.wait(mtx, []{ return work_done ==\n                                      !work_done; });\n```", "```cpp\n        spinlock.lock();\n        shared_res.emplace_back\"test1\");\n        shared_res.emplace_back\"test2\");\n        for (const auto& el : shared_res)\n            cout <<\"p\" << el << endl;\n        spinlock.unlock();\n        work_done = !work_done;\n    }\n}\n```"]