- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building the C++ Trading Algorithm’s Building Blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will build components that make up the intelligence in
    our trading applications. These are the components that the trading strategies
    will rely on very heavily to make decisions, send and manage orders, track and
    manage positions, **profits and losses** (**PnLs**), and manage risk. Not only
    do the trading strategies need to track the trading PnLs since the goal is to
    make money, but these components also need to track the PnLs to decide when to
    stop trading if needed. We will learn how to compute complex features from market
    data updates, track trading performance based on order executions and market updates,
    send and manage live strategy orders in the market, and manage market risk. In
    this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reacting to executions and managing positions, PnLs, and risk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the feature engine and computing complex features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using executions and updating positions and PnLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending and managing orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing and managing risk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code for this book can be found in this book’s GitHub repository at
    [https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP).
    The source for this chapter is in the `Chapter9` directory in this repository.
  prefs: []
  type: TYPE_NORMAL
- en: You must have read and understood the design of the electronic trading ecosystem
    that was presented in *Chapter*, *Designing Our Trading Ecosystem*, especially
    the *Designing a framework for low-latency C++ trading algorithms* section. As
    before, we will use the building blocks we built in *Chapter*, *Building the C++
    Building Blocks for* *Low-Latency Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specifications of the environment in which the source code for this book
    was developed are shown here. We have provided the details of this environment
    since all the C++ code presented in this book is not necessarily portable and
    might require some minor changes for it to work in your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18
    17:40:00 UTC 2 x86_64 x86_64` `x86_64 GNU/Linux.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g++ (Ubuntu` `11.3.0-1ubuntu1~22.04.1) 11.3.0.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmake` `version 3.23.2.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.10.2.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reacting to executions and managing positions, PnLs, and risk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to build a few basic building blocks that will build and support our
    trading strategies. We discussed the need for these components in *Chapter*, *Designing
    Our Trading Ecosystem*, in the *Designing a framework for low-latency C++ trading
    algorithms* section. We have already implemented a major component – the limit
    order book – but in this section, we will build the remaining components we need,
    namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `FeatureEngine`, which will be used to compute simple and complex features/signals
    that drive the trading strategy decisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `PositionKeeper`, which will receive executions and compute important measures
    such as position, PnLs, traded volumes, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `OrderManager`, which will be used by the strategies to send orders, manage
    them, and update these orders when there are updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `RiskManager` to compute and check the market risk that a trading strategy
    is attempting to take on, as well as the risk it has realized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the topology of all these components and how they
    interact with each other. If you need to refresh your memory on why these components
    exist, what purpose they serve, how they interact with each other, and how they
    are designed, please revisit *Chapter*, *Designing Our Trading Ecosystem*, and
    look at the subsections in the *Designing a framework for low-latency C++ trading*
    *algorithms* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The sub-components inside our trading engine](img/Figure_9.1_B19434.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – The sub-components inside our trading engine
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s kick off our effort of implementing these components, starting with
    the feature engine in the next sub-section. But before we do that, we need to
    add two additional methods for the `Side` enumeration, which will make a lot of
    our source code simpler down the road. Both of these can be found in the `Chapter9/common/types.h`
    header file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method we will add is the `sideToIndex()` method, which converts
    a `Side` value into an index that can be used to index into an array. This will
    allow us to maintain arrays of different types of objects that are indexed by
    a `Side` value. The implementation is simple – we simply typecast the side to
    a `size_t` type and add a `1` to account for the fact that `Side::SELL` has a
    value of -1 and valid that indices start from 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also define a `sideToValue()` method, which converts a `Side` value
    into either a 1 for `Side::BUY` or a -1 for `Side::SELL`. This will help us when
    we compute positions and PnLs, which we will see shortly in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have that additional functionality out of the way, we can start
    computing the feature engine.
  prefs: []
  type: TYPE_NORMAL
- en: Building the feature and computing complex features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build a minimal version of a feature engine. We will
    only compute two simple features – one (market price) that computes fair market
    prices based on the top of book prices and quantity and another (aggressive trade
    qty ratio) that computes how big a trade is compared to the top of book quantities.
    We will use these feature values to drive our market-making and liquidity-taking
    trading algorithms later in this chapter. The source code for the `FeatureEngine`
    class we will build here can be found in the `Chapter9/trading/strategy/feature_engine.h`
    file on GitHub. We discussed the details of this component in *Chapter*, *Designing
    Our Trading Ecosystem*, in the *Designing a framework for low-latency C++ trading*
    *algorithms* section.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the data members in the feature engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to declare the `FeatureEngine` class and define the data members
    inside this class. First, we will include the required header files and define
    a constant sentinel value to represent invalid or uninitialized feature values.
    This is called `Feature_INVALID`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `FeatureEngine` class is basic and has two important data members of the
    `double` type – one to compute and store the fair market price value, `mkt_price_`,
    and another to compute and store the aggressive trade quantity ratio feature value,
    `agg_trade_qty_ratio_`. It also stores a pointer to a `Logger` object (`logger_`)
    for logging purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will look at how to initialize this class since we have already initialized
    the two feature variables with the `Feature_INVALID` value.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the feature engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The constructor for this class accepts a `Logger` object and initializes the
    `logger_` data member – that’s all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will present two getter methods – `getMktPrice()` and `getAggTradeQtyRatio()`
    – to fetch the value of the two features that the `FeatureEngine` class is responsible
    for computing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the next two subsections, we will see how this component handles order book
    updates and trade events and updates the feature values.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the feature on order book changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `FeatureEngine` class expects the `onOrderBookUpdate()` method to be called
    when there is an update to the order book. First, it uses `MarketOrderBook::getBBO()`
    to extract the BBO. As a reminder, `mkt_price_` value if they are valid. The fair
    market price is formulated as the book quantity weighted price, `(bid_price *
    ask_qty + ask_price * bid_qty) / (bid_qty + ask_qty)`. Note that this is just
    a single formulation for a fair market price; the important thing to remember
    with feature engineering is that there is no single correct formulation. You are
    encouraged to formulate a version of a fair market price or any other feature
    value you want to use in the future. The formulation we are using here tries to
    move the fair market price closer to the offer if there are more buy orders than
    sell orders and moves it closer to the bid if there are more sell orders than
    buy orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The next subsection will compute the other feature, which we will refer to as
    the Aggressive Trade Quantity Ratio, for computing the trade quantity as a fraction
    of the book price level quantity.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the feature on trade events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`FeatureEngine` expects the `onTradeUpdate()` method to be called when there
    is a trade event in the market data stream. As we saw previously, it fetches the
    BBO and checks if the prices are valid and then computes the `agg_trade_qty_ratio_`
    feature to be a ratio of the trade quantity and the quantity of the BBO that the
    trade aggresses on. As we mentioned with the previous feature, there is no single
    correct formulation of a feature – this is just the formulation we are using for
    now; hopefully, you will add your own formulations in the future. This formulation
    tries to measure how big a trade aggressor was compared to how much liquidity
    was available on the BBO side the aggressor trades against. We are simply trying
    to quantify the trade pressure with this feature that we are computing. As we
    mentioned previously, there are many other possible formulations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That is the entire implementation of our `FeatureEngine` for this book. In the
    next section, we will learn how to handle executions and use that to update positions
    and PnLs.
  prefs: []
  type: TYPE_NORMAL
- en: Using executions to update positions and PnLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will build a `PositionKeeper` class that will be responsible for processing
    executions on a strategy’s orders and computing and tracking positions and PnLs.
    This component is used by the strategy as well as the risk manager to compute
    positions and PnLs for different purposes. All the source code for the `PositionKeeper`
    class is in the `Chapter9/trading/strategy/position_keeper.h` file on GitHub.
    Before we build the `PositionKeeper` class, which manages positions for all trading
    instruments, we will need to build a `PositionInfo` struct, which is also present
    in the same source file. The `PositionInfo` struct is the lower-level struct for
    managing the positions and PnLs for a single trading instrument; we will cover
    it in more detail in the next few subsections. We discussed the details of this
    component in *Chapter*, *Designing Our Trading Ecosystem*, in the *Designing a
    framework for low-latency C++ trading* *algorithms* section.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the data members in PositionInfo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we must specify the `include` files that will be needed for the `position_keeper.h`
    file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The data members inside the `PositionInfo` struct are presented in the source
    code. The important data members are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A `position_` variable of the `int32_t` type to represent the current position.
    This can be positive, negative, or 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three `double` values – `real_pnl_`, `unreal_pnl_`, and `total_pnl_` – to track
    the realized or closed PnL for positions that have been closed (`real_pnl_`),
    the unrealized or open PnL for the currently open position (`unreal_pnl_`), and
    the total PnL, which is a summation of the two values (`total_pnl_`), respectively.
    The realized PnL only changes when additional order executions occur; the unrealized
    PnL can change even without order executions if there is a non-zero position and
    market prices change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `std::array` of `double` of a size large enough to accommodate entries for
    the buy side and sell side. This array will be indexed using the `sideToIndex(Side::BUY)`
    and `sideToIndex(Side::SELL)` values. This `open_vwap_` `std::array` variable
    tracks the product of price and execution quantity on each side when there is
    an open long (positive) or short (negative) position. We will need this to compute
    the unrealized PnL by comparing the **volume-weighted average price** (**VWAP**)
    of the open long or short position against the current market price.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `volume_` variable of the `Qty` type to track the total quantity that has
    been executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `const` pointer variable to a `BBO` object called `bbo_`, which will be used
    on market updates to fetch the updated top-of-book prices:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also add a simple `toString()` method to this struct to *stringify*
    instances of this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to process order executions and update the positions and PnLs
    based on those executions.
  prefs: []
  type: TYPE_NORMAL
- en: Handling order executions in PositionInfo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a trading strategy’s orders are executed, `PositionKeeper` needs to update
    the positions and PnLs that have been tracked for the trading instrument of the
    execution. It does this by providing the `MEClientResponse` message corresponding
    to order executions to the `PositionInfo::addFIll()` method. We will build this
    in this subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at the source code for our implementation of the `PositionInfo::addFill()`
    method, we will look at an example of how the algorithm to update the realized
    and unrealized PnLs works. This will help you easily understand the source code
    for the implementation. We will track the evolution of the different variables
    as we work our way through a few hypothetical executions for a hypothetical trading
    instrument. We will display the following variables as columns in our tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**position – old**: This is the position before the current execution message
    is processed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**position – new**: This will be the new position after processing the current
    execution message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**open_vwap – BUY**: This is the sum of the products of execution price and
    execution quantity for buy executions only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**open_vwap – SELL**: This is the sum of the products of execution price and
    execution quantity for sell executions only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VWAP – BUY**: This is the actual VWAP of the current long/positive position,
    represented in units of price and not price x quantity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VWAP – SELL**: This is the actual VWAP of the current short/negative position,
    represented in units of price and not price x quantity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PnL – real**: This is the realized PnL after processing this execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PnL – unreal**: This is the unrealized PnL for the open position after processing
    this execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assuming we get an execution for buying 10 at 100.0, we must update `open_vwap`,
    `VWAP` on the `BUY` side, and the new position, as shown here. No changes need
    to be made to the unreal PnL yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **position** | **open_vwap** | **VWAP** | **PnL** |'
  prefs: []
  type: TYPE_TB
- en: '| **Old** | **new** | **BUY** | **SELL** | **BUY** | **SELL** | **real** |
    **unreal** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 10 | 1000.0 | 0.0 | 100.0 | 0.0 | 0.0 | 0.0 |'
  prefs: []
  type: TYPE_TB
- en: 'Assuming we get another execution for buying 10 at 90.0, our old position was
    10 and the new position will be 20\. The `open_vwap` property for `BUY` now gets
    10 * 90 added to the previous 1,000 and becomes 1,900\. The `VWAP` column for
    the open long/positive position is 95, which can be computed by dividing 1,900
    (`BUY` `open_vwap`) by 20 (new position). We compute the unreal PnL by using a
    `VWAP` of 95 and the latest execution price of 90 and multiplying the difference
    of -5 by the position of 20 to get -100\. We have a negative unrealized PnL because
    our long/positive position’s `VWAP` is higher than current market prices (represented
    by the latest execution price):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **position** | **open_vwap** | **VWAP** | **PnL** |'
  prefs: []
  type: TYPE_TB
- en: '| **old** | **new** | **BUY** | **SELL** | **BUY** | **SELL** | **real** |
    **unreal** |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 20 | 1900.0 | 0.0 | 95.0 | 0.0 | 0.0 | -100.0 |'
  prefs: []
  type: TYPE_TB
- en: 'Now, let’s assume we get a sell execution for selling 10 at 92\. Our old position
    of 20 will be reduced to 10\. Our `open_vwap` and `VWAP` on the `BUY` side do
    not change since this was a sell execution. Since we closed 10 out of our long/positive
    20 positions, we will have some realized PnL and the remaining 10 long/positive
    positions will have some unrealized PnL based on the execution price of this latest
    execution. The realized PnL is computed using the sell execution price of 92,
    the `VWAP` property of the long/positive position, which is 95, and the execution
    quantity of 10 to yield a realized PnL of (92 - 95) * 10 = -30\. In this case,
    the unrealized PnL is also the same since there is a long/positive 10 position
    left:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **position** | **open_vwap** | **VWAP** | **PnL** |'
  prefs: []
  type: TYPE_TB
- en: '| **Old** | **new** | **BUY** | **SELL** | **BUY** | **SELL** | **real** |
    **unreal** |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 10 | 1900.0 | 0.0 | 95.0 | 0.0 | -30.0 | -30.0 |'
  prefs: []
  type: TYPE_TB
- en: 'Now, let’s assume we receive another sell execution for selling 20 at 97\.
    This will cause our position to flip from 10 to –10 (note that we set `open_vwap`
    and `VWAP` for the `BUY` side to 0). The `open_vwap` property for the `SELL` side
    becomes 970 because of the -10 position and the execution price of 97\. We close
    the previous position of 10, which had a `VWAP` of 95 with this sell at 97\. Since
    we sold higher than the `VWAP` property of our long/positive position, we make
    a profit of (97 - 95) * 10 = 20, which when added to the previous realized PnL
    of -30, yields the final `realized` PnL of -10\. The unrealized PnL here is 0
    since a `VWAP` of 97 is the same as the current execution price of 97:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **position** | **open_vwap** | **VWAP** | **PnL** |'
  prefs: []
  type: TYPE_TB
- en: '| **Old** | **new** | **BUY** | **SELL** | **BUY** | **SELL** | **real** |
    **unreal** |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | -10 | 0.0 | 970.0 | 0.0 | 97.0 | -10.0 | 0.0 |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s assume that we get another sell execution of selling 20 and 94\. Here,
    the short/negative position increases from -10 to -30\. The `open_vwap` property
    on the `SELL` side is updated by adding (20 * 94) to the previous value of 970
    to yield 2,850\. The `VWAP` property of our short position is updated to 95 by
    dividing the `open_vwap` property of 2,850 by the position of 30 to yield 95\.
    The realized PnL does not change since the position was increased and nothing
    was reduced or closed. The unreal PnL uses the execution price of 94 on this new
    execution, compares it to the `VWAP` property of 95, and uses the new position
    of -30 to yield (95 - 94) * 30 = 30:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **position** | **open_vwap** | **VWAP** | **PnL** |'
  prefs: []
  type: TYPE_TB
- en: '| **Old** | **new** | **BUY** | **SELL** | **BUY** | **SELL** | **real** |
    **unreal** |'
  prefs: []
  type: TYPE_TB
- en: '| -10 | -30 | 0.0 | 2850.0 | 0.0 | 95.0 | -10.0 | 30.0 |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s assume that there is yet another sell execution of selling 10 at 90\.
    The short/negative position increases from -30 to -40\. We add the new execution’s
    price and quantity product (10 * 90) to the previous `open_vwap` property’s `SELL`
    of 2,850 to yield 3,750\. The actual `VWAP` of the short position changes from
    95 to 93.75 and was obtained by dividing this 3,750 value by the new position
    of 40\. The realized PnL does not change since the position was increased, but
    the unrealized PnL is updated using (93.75 - 90) * 40 = 150:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **position** | **open_vwap** | **VWAP** | **PnL** |'
  prefs: []
  type: TYPE_TB
- en: '| **Old** | **new** | **BUY** | **SELL** | **BUY** | **SELL** | **real** |
    **unreal** |'
  prefs: []
  type: TYPE_TB
- en: '| -30 | -40 | 0.0 | 3750.0 | 0.0 | 93.75 | -10.0 | 150.0 |'
  prefs: []
  type: TYPE_TB
- en: 'Finally, let’s assume that we receive a buy execution for buying 40 at 88\.
    This execution will flatten our short/negative position of -40, so the new position
    will be 0\. The unrealized PnL will be 0 and the `open_vwap` and `VWAP` properties
    will be 0 for both sides since there is no open position anymore. The realized
    PnL is updated using the previous `VWAP` property, the execution price, and the
    position of 40, so (93.75 - 88) * 40 = 230\. This is added to the previously realized
    PnL of –10 to yield the final realized PnL of 220:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **position** | **open_vwap** | **VWAP** | **PnL** |'
  prefs: []
  type: TYPE_TB
- en: '| **Old** | **new** | **BUY** | **SELL** | **BUY** | **SELL** | **real** |
    **unreal** |'
  prefs: []
  type: TYPE_TB
- en: '| -40 | 0 | 0.0 | 0.0 | 0.0 | 0.0 | 220.0 | 0.0 |'
  prefs: []
  type: TYPE_TB
- en: Now, we can move on and discuss the implementation details of this algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we must do is initialize a few local variables. Here, the `old_position`
    variable saves the `current position_` value before updating it. `side_index`
    and `opp_side_index` use the `sideToIndex()` method to find the indices in the
    `open_vwap_` array that correspond to the side of the execution and the side opposite
    to the side of execution, respectively. We must also initialize a `side_value`
    variable, which will be +1 for a buy execution and -1 for a sell execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must update the `position_` variable using the quantity executed (`exec_qty_`)
    in this response and the `side_value` variable we initialized. We must also update
    the `volume_` member by adding the new execution quantity to it. When we receive
    an execution on a buy order, our position increases; conversely, when we receive
    an execution on a sell order, our position decreases. When our position is positive,
    also known as a *long position*, we profit when prices increase and make a loss
    when prices decrease. When our position is negative, also known as a *short position*,
    we profit when prices decrease and make a loss when prices increase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next important step for us is to update the `open_vwap_` entry’s `std::array`
    variable. We will check if we were flat (position 0) before this execution and
    open a new position with this execution or if we already had an open position
    and we got an execution that increases that position. In this case, we will simply
    update the `open_vwap_` variable using `side_index` to index the correct side.
    Since `open_vwap_` tracks the product of execution prices and executed quantities
    at those prices, we can simply multiply `price_` and `exec_qty_` on this execution
    and add it to the existing sum, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to handle the case where we had a pre-existing open position. This
    most recent execution reduces or flattens the position. In this case, we will
    need to update the realized PnL (`real_pnl_`) using the `open_vwap_` entry for
    the side opposite to the side of execution. One thing to understand is that the
    realized PnL is only updated when an open position is reduced or closed because,
    in this case, we have bought and sold a certain quantity. Another way to think
    about this is that we can match some of the buy quantity with some of the sell
    quantity and create a pair of buy and sell trades. In this case, we have closed
    at least part of our position. In the previous case, where we either opened a
    new position or increased an already open position, we did not have a pair of
    buy and sell trades to match up, so we did not need to update the realized PnL.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will compute an `opp_side_vwap` value, which is the average price
    of all the executions on the other side, using the `open_vwap_` entry for `opp_side_index`
    and normalize it using the absolute value of `old_position` before this execution.
    Remember that the `open_vwap_` variable is named poorly; it tracks the product
    of execution price and quantity, not just the price, so dividing it by the quantity
    represented by `old_position` yields the actual VWAP. Then, we will update the
    `open_vwap_` entry for `opp_side_index` using the product of the VWAP we computed
    in `opp_side_vwap` and the absolute value of the new `position_` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update the `real_pnl_` value by finding the minimum quantity value of
    the execution quantity (`exec_qty_`) and the absolute value of `old_position`.
    We must multiply that by the difference between the current execution message’s
    price (`price_`) and `opp_side_vwap`. Finally, we need to multiply this product
    by `opp_side_value` to account for whether a profit was made (bought at a lower
    price than the sell VWAP or sold at a higher price than the buy VWAP) or a loss
    was made (bought at a higher price than the sell VWAP or sold at a lower price
    than the buy VWAP):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to handle an edge case if this execution causes the position to flip,
    meaning it goes from a long position to a short position or vice versa. This position
    flip can happen, for instance, when we have a long/positive position of a certain
    amount and we receive a sell execution of a quantity larger than that position.
    Conversely, this can happen if we have a short/negative position of a certain
    amount and we receive a buy execution of a quantity larger than that position.
    In each of these cases, we go from having a positive/long position to a negative/short
    position or go from having a negative/short position to a positive/long position.
    In this case, we can simply reset the `open_vwap_` value corresponding to the
    opposite side to 0 and reset the `open_vwap_` value for the side of execution
    (and thus the side of the new position) so that it’s the product of the latest
    execution price and the absolute value of our current `position_`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will wrap up the `PositionInfo::addFill()` method by updating the
    unrealized PnL (`unreal_pnl_`) value. The case where we are now flat (`position_
    == 0`) is straightforward – we reset the `open_vwap_` variable for both sides
    and set `unreal_pnl_` to 0 since no open position implies no `unreal_pnl_`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we still have an open `position_` after this execution, then we can compute
    the `unreal_pnl_` value that was obtained by multiplying the absolute value of
    `position_` with the difference between the execution price from the current execution
    and the VWAP computed from the `open_vwap_` entry for the `position_` side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `total_pnl_` is just the summation of `real_pnl_` and `unreal_pnl_`,
    as explained previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The final piece of functionality we need to add to `PositionInfo` is for handling
    changes in market prices and updating the unrealized PnL for any open position.
    We will investigate this functionality in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Handling order book changes in PositionInfo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When there are market updates that cause changes in the order book we build,
    we need to update the unrealized and total PnL values. The `PositionInfo::updateBBO()`
    method is called by the `PositionKeeper` class for the trading instrument, which
    receives a market update. This, in turn, leads to an order book change. We provide
    the `BBO` object that corresponds to the trading instrument that was updated in
    the `updateBBO()` method. We save the `bbo` argument provided in this method in
    the `bbo_` data member in our `PositionInfo` struct. This method only has anything
    to do if `position_` is non-zero and the bid and ask price values on the BBO provided
    are valid. This is the first thing we will check for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to update the unrealized PnL, we can use the mid-price of the BBO
    prices, which we can compute and save in the `mid_price` variable, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can update `unreal_pnl_` using the same logic that we saw in
    the previous subsection, except that we use the `mid_price` value instead of an
    execution price. Let’s explain why we update the unrealized PnL even though we
    do not have additional executions. Let’s say we have a long position from an execution
    at a hypothetical price of 100\. At this point, the initial unrealized PnL is
    0\. Let’s also assume that, in the future, the market prices (represented by our
    `mid_price` variable) go up to 110\. In that case, our realized PnL has not changed
    because we have not executed any sell orders. However, our unrealized PnL increases
    because if we decide to liquidate our long position, we would get executions at
    a price roughly equal to `mid_price`. This is why we update the unrealized PnL
    when market prices change, even though no additional orders have been executed.
    Also, note that the realized PnL captures the PnL of pairs of buy and sell executions,
    so that does not need to be updated here since there were no additional executions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must update the `total_pnl_` data member and log it if it has changed
    since the last time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This concludes all the functionality we need for the `PositionInfo` struct.
    We will now shift our discussion to the `PositionKeeper` class, which we will
    use to manage the position and PnL for the entire trading engine across all trading
    instruments.
  prefs: []
  type: TYPE_NORMAL
- en: Designing PositionKeeper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `PositionKeeper` class manages the position and PnL across all trading
    instruments in the trading engine. The `PositionKeeper` class contains a `std::array`
    of `PositionInfo` objects and is large enough to accommodate `ME_MAX_TICKERS`
    number of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add a getter method to fetch and return the `PositionInfo` instance
    for a provided `TickerId` called `getPositionInfo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also add a simple `toString()` method, which we will use for logging
    purposes later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Initializing an object of this class is straightforward and something we will
    discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing PositionKeeper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `PositionKeeper` constructor accepts a `Logger` object and initializes
    the `logger_` data member with that argument, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will see how order executions and changes to `BBO` are handled in the
    `PositionKeeper` class and forwarded to the correct `PositionInfo` object.
  prefs: []
  type: TYPE_NORMAL
- en: Handling order executions and market updates in PositionKeeper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `PositionKeeper::addFill()` method handles order executions and its implementation
    is straightforward. It simply calls the `PositionInfo::addFill()` method on the
    correct `PositionInfo` object for that `TickerId`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PositionKeeper::updateBBO()` method handles changes in `BBO` due to market
    updates and corresponding changes in the order book. It also simply calls the
    `PositionInfo::updateBBO()` method on the correct `PositionInfo` object for `TickerId`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That concludes the design and implementation of everything we need in our `PositionKeeper`
    class. In the next section, we will build an order manager class, which will be
    used by the trading strategies to manage their orders at a higher level.
  prefs: []
  type: TYPE_NORMAL
- en: Sending and managing orders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter*, *Designing Our Trading Ecosystem*, we discussed the purpose of
    the trading system’s order manager component (the *Designing a framework for low-latency
    C++ trading algorithms* section). In this section, we will implement an `OrderManager`
    class to encapsulate the order management logic inside this class and thus make
    it easy for trading strategies to manage their orders. Before we build the `OrderManager`
    class itself, we will need to define a basic building block called the `OMOrder`
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the OMOrder struct and its related types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this first subsection, we will define some enumerations and types to be used
    in the `OrderManager` class and its sub-components. All the source code for this
    subsection is in the `Chapter9/trading/strategy/om_order.h` source file on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must provide the `include` files that the `om_order.h` file needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must declare an `OMOrderState` enumeration, which will be used to track
    the state of a strategy order (`OMOrder`) in the order manager. These states represent
    the state of an `OMOrder`, as described here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `INVALID` state represents an invalid order state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PENDING_NEW` state signifies that a new order has been sent out by `OrderManager`
    but it has not been accepted by the electronic trading exchange yet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we receive a response from the exchange to signify acceptance, the order
    goes from `PENDING_NEW` to `LIVE`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like `PENDING_NEW`, the `PENDING_CANCEL` state represents the state of an order
    when a cancellation for an order has been sent to the exchange but has not been
    processed by the exchange or the response has not been received back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `DEAD` state represents an order that does not exist – it has either not
    been sent yet or fully executed or successfully cancelled:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also add a method for converting `OMOrderState` enumerations into strings
    for logging purposes, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can define the `OMOrder` structure, which has the following key fields:'
  prefs: []
  type: TYPE_NORMAL
- en: A `ticker_id_` variable of the `TickerId` type to represent which trading instrument
    this order is for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `order_id_` variable of the `OrderId` type, which is the unique order ID
    that’s been assigned to this order object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `side_` variable to hold the `Side` property of this order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order’s `Price` is held in the `price_` data member
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The live or requested `Qty` for this order is saved in the `qty_` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An `order_state_` variable of the `OMOrderState` type, which we defined previously,
    to represent the current state of `OMOrder`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also add a `toString()` method to stringify `OMOrder` objects for logging
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define an `OMOrderSideHashMap` typedef to represent a `std::array`
    of `OMOrder` objects and indicate that the capacity of this array is large enough
    to hold an entry for the buy side and another for the sell side. Objects of the
    `OMOrderSideHashMap` type will be indexed by the `sideToIndex(Side::BUY)` and
    `sideToIndex(Side::SELL)` indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also define an `OMOrderTickerSideHashMap`, which is just another `std::array`
    of this `OMOrderSideHashMap` object that’s large enough to hold all trading instruments
    – that is, of `ME_MAX_TICKERS` size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can build the order manager class, which is used to manage `OMOrder`
    objects for trading strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the OrderManager class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our simplified order manager will manage `OMOrder` objects on the trading strategy’s
    behalf. To keep things simple, our `OrderManager` class will allow, at most, a
    single order on the buy side and a single order on the sell side. We will look
    at the details of this implementation in this section. All the code for the `OrderManager`
    class can be found in the `Chapter9/trading/strategy/order_manager.h` and `Chapter9/trading/strategy/order_manager.cpp`
    source files.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the data members in OrderManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to define the data members that belong within our `OrderManager` class.
    But before we do that, in the following code block, we have provided the header
    files we will need to include in the `order_manager.h` source file. We must also
    forward declare the `TradeEngine` class since we will refer to it in this class
    but want to avoid circular dependency issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can design the internal data members in the `OrderManager` class. The
    key members are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A `trade_engine_` variable. This is a pointer to a `TradeEngine` object. We
    will use this to store the parent `TradeEngine` instance that is using this order
    manager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constant reference to a `RiskManager` object stored in the `risk_manager_`
    member variable. This will be used to perform *pre-trade* risk checks – that is,
    risk checks that are performed before new orders are sent out to the exchange.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ticker_side_order_` variable of the `OMOrderTickerSideHashMap` type to hold
    a pair (a buy and a sell) of `OMOrder` objects for each trading instrument. This
    will be used as a hash map that’s indexed first by the `TickerId` value of the
    instrument we want to send an order for and then indexed by the `sideToIndex(Side::BUY)`
    or `sideToIndex(Side::SELL)` values to manage the buy or sell order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New and unique order IDs starting from `1`, which we will generate using a
    simple `next_order_id_` variable of the `OrderId` type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: That is all the data inside the `OrderManager` class. In the next subsection,
    we will learn how to initialize these members and the `OrderManager` class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing OrderManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Initializing `OrderManager` is straightforward. In addition to what we initialized
    in the class definition itself, we must initialize the `trade_engine_`, `risk_manager_`
    and `logger_` data members, which we expect to be passed through the constructor
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown here, we must add a simple convenience function that we can use in
    our `OrderManager` implementation called `getOMOrderSideHashMap()`. This simply
    returns the `OMOrderSideHashMap` instance for the provided `TickerId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can move on to an important task in `OrderManager` – sending new orders.
  prefs: []
  type: TYPE_NORMAL
- en: Sending new orders from OrderManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `OrderManager::newOrder()` method is the lower-level method in our order
    manager class. It requires a pointer to an `OMOrder` object for which this new
    order is being sent. It also needs the `TickerId`, `Price`, `Side`, and `Qty`
    attributes to be set on the new order that’s being sent out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It creates a `MEClientRequest` structure of the `ClientRequestType::NEW` type
    and fills in the attributes that are passed through the arguments, sets `OrderId`
    to be `next_order_id_` and `ClientId` to be the client ID of `TradeEngine`, which
    can be obtained by calling the `clientId()` method. It also calls `TradeEngine::sendClientRequest()`
    and provides the `MEClientRequest` object (`new_request`) it just initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it updates the `OMOrder` object pointer it was provided in the method
    parameters and assigns it the attributes that were just set on the new order that
    was sent out. Note that the state of this `OMOrder` is set to `OMOrderState::PENDING_NEW`
    since it will be sent out shortly but will not be active until the exchange accepts
    it and we receive that response. It also increments the `next_order_id_` variable
    to maintain uniqueness on any new orders that might be sent out later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We will see where this `newOrder()` method gets called from shortly, but before
    that, let’s look at the complementary task of cancelling orders.
  prefs: []
  type: TYPE_NORMAL
- en: Cancelling orders from OrderManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`OrderManager::cancelOrder()` is the lower-level method in our order manager
    class and will be used to send a cancel request for live orders being managed
    by `OrderManager`. It only accepts a single parameter, which is the `OMOrder`
    object for which it is going to send the cancel request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the `newOrder()` method, we must initialize an `MEClientRequest` `client_request`
    object of the `ClientRequestType::CANCEL` type and populate the attributes in
    it from the `OMOrder` object that was passed into the method. It calls the `TradeEngine::sendClientRequest()`
    method to send the cancel request out. One thing to understand is that the `next_order_id_`
    member variable is only used for generating new order IDs for new outgoing order
    requests. Cancelling an existing order does not change the `next_order_id_` variable,
    as shown in the following code block. In our design, `next_order_id_` keeps incrementing
    sequentially each time we send an `MEClientRequest` of the `ClientRequestType::NEW`
    type. Theoretically, we could reuse the `order_id_` value from the order we just
    cancelled on the next new order request, but that would require us to track the
    free order IDs, which is not too difficult either. This was just a design choice
    we made, but feel free to modify this scheme and track free order IDs if you wish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must update the `order_state_` value of the `OMOrder` object to
    `OMOrderState::PENDING_CANCEL` to represent the fact that a cancel request has
    been sent out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Previously, we mentioned that `newOrder()` and `cancelOrder()` are lower-level
    methods in the `OrderManager` class. Trading strategies that use `OrderManager`
    will not call these methods directly; instead, they will have `OrderManager` manage
    the orders by calling the `OrderManager::moveOrders()` method. We will build this
    in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Adding methods to simplify order management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we build the `moveOrders()` method, we will build one more lower-level
    method that’s used by `OrderManager`. This method, called `moveOrder()`, manages
    a single order and either sends a new order or cancels an existing order, depending
    on the arguments provided to it. The most important parameter for this method
    is a pointer to an `OMOrder` object. It also accepts the `TickerId`, `Price`,
    `Side`, and `Qty` parameters. The purpose of this method is to make sure that
    the `OMOrder` object that’s passed to it is placed or replaced with the provided
    `price`, `side`, and `qty` arguments. This involves a combination of cancelling
    an existing order if it is not at the specified price and/or placing a new order
    with the `price` and `qty` parameters specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The action this method decides to take depends on the current `order_state_`
    of the `OMOrder` object passed to it. We will go through the different `OMOrderState`
    cases one by one, starting with `OMOrderState::LIVE`. If the `OMOrder` object
    is already live/active, it checks to make sure that the `price` parameter matches
    the order’s `price_` attribute. If that is not the case, then it calls the `OrderManager::cancelOrder()`
    method to cancel this order and replaces it in the next iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For cases where the order is in an `INVALID` or `DEAD` state, which means not
    active in the market, we will place the order using the `OrderManager::newOrder()`
    method we built previously. But it needs to check with `RiskManager` whether this
    action is allowed by calling the `RiskManager::checkPreTradeRisk()` method and
    passing it the `TickerId`, `Side` and `Qty` attributes of the order we would like
    to send. At this point, it should be clear why this is called pre-trade risk –
    we check if we can perform the action/trade before we do it. We will discuss the
    design and implementation of `RiskManager`, as well as the `checkPreTradeRisk()`
    method, shortly. For now, all you need to know is that it returns a `RiskCheckResult`
    enumeration value of `RiskCheckResult::ALLOWED` if the risk checks pass and a
    different value if the risk checks fail – that is, the action/trade is not allowed.
    In the following code block, we only send the order by calling the `newOrder()`
    method if the `checkPreTradeRisk()` method returns `RiskCheckResult::ALLOWED`.
    As a final note, here, we log an error message if the risk check fails using the
    `riskCheckResultToString()` method. We will cover this shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'For the cases where the `OMOrder` object’s `order_state_` is `PENDING_NEW`
    or `PENDING_CANCEL`, we do nothing since we are waiting for a response from the
    electronic trading exchange before we can proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have all the pieces we need to build our `OrderManager::moveOrders()`
    method. This is the primary method that’s used by trading strategies to generate
    and manage the orders it needs. It accepts a few parameters – the `TickerId` parameter
    of the instrument, the `Price` parameter’s `bid_price` for the buy order, the
    `Price` parameter’s `ask_price` for the sell order, and a `clip` parameter of
    the `Qty` type, which will be the quantity of the buy and sell orders. We will
    see where this `clip` parameter comes from in the *Defining the TradeEngineCfg
    structure* subsection, in the *Computing and managing risk* section. For now,
    note that the term `clip` comes from the term clip for ammunition for firearms,
    and in the context of our trading strategies, it means the size of each order
    that our trading strategy can send. We will see that this parameter gets used
    to set the size of outgoing new order requests. This is just the name of the variable
    we chose; it could also be `trade_size`, `order_size`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to note here is that passing a price value of `Price_INVALID` for
    `bid_price` or `ask_price` will cause the order to be cancelled – that is, it
    will only have an order on the buy side or the sell side instead of both. This
    is because the `moveOrder()` method cancels an order if the price on `OMOrder`
    does not match the price passed to the method. And because any `OMOrder` that
    is active in the market (`OMOrderState::LIVE`) will have a valid price other than
    `Price_INVALID`, that check evaluates to true and causes the order to be cancelled.
    One more thing to note here is that, currently, we support a single `clip` value
    for both the buy and sell orders, but it is easy to extend this so that we have
    different quantities for the buy order and the sell order. The implementation
    of this method is extremely simple – it fetches the buy order (`bid_order`) by
    indexing the `ticker_side_order_` container with the `ticker_id` value and indexing
    that with the `sideToIndex(Side::BUY)` value. It then calls the `OrderManager::moveOrder()`
    method on this `bid_order` and passes it the `bid_price` parameter for the price
    and passes it the `clip` parameter for the quantity. We do the same thing for
    the sell order (`ask_order`), except we use `sideToIndex(Side::SELL)` and `ask_price`
    for the sell side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We need to add one final functionality to our `OrderManager` class, which is
    handling incoming order responses. We will tackle this in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Handling order updates and updating orders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can wrap up our discussion on the implementation of `OrderManager`,
    we need to add some code to handle incoming order responses in the form of `MEClientResponse`
    messages. The `OrderManager::onOrderUpdate()` method we will build here expects
    to be called and passed a `MEClientResponse` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we must fetch the `OMOrder` object that this `MEClientResponse` message
    is meant for. We can do that by accessing the `ticker_side_order_` container using
    the `ticker_id_` field in `client_response` and converting the `side_` field in
    the `client_response` message into an index using the `sideToIndex()` method.
    This is shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We will update the `OMOrder` object we fetched previously, but that depends
    on the type of `MEClientResponse` we received. In the case of `ClientResponseType::ACCEPTED`,
    all we need to do is set the `order_state_` member of this `OMOrder` object to
    `OMOrderState::LIVE` to mark it as accepted and active in the market:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If the type of the response is `ClientResponseType::CANCELED`, then we just
    update the `order_state_` variable of `OMOrder` to `OMOrderState::DEAD` since
    it is no longer active in the market:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If `MEClientResponse` is of the `ClientResponseType::FILLED` type, which is
    done to denote an execution, we update the `qty_` field on `OMOrder` to be the
    new `leaves_qty_`. This reflects the live quantity that still exists in the market.
    We also need to check that if the `qty_` field (and thus the `leaves_qty_` field
    on `client_response`) is 0, meaning the order was fully executed, the order is
    no longer active in the market. If so, we must set `order_state_` to `OMOrderState::DEAD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We ignore the `CANCEL_REJECTED` and `INVALID` `ClientResponseType` enumeration
    values since there is no action that we need to take:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the discussion, design, and implementation of our `OrderManager`
    component. However, we referenced and used `RiskManager` in the implementation
    of the `OrderManager` class without discussing all its details. We will do this
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Computing and managing risk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final component we still need to build before we can build our trading strategies
    is `RiskManager`. The `RiskManager` component tracks the active order quantities
    that a trading strategy has in the market through the same `OrderManager` instance
    that a trading strategy uses. It also tracks the positions and realized and unrealized
    PnLs using the `PositionKeeper` instance, which tracks the trading strategy’s
    positions and PnLs. It checks that the strategy stays within its assigned risk
    limits. If the trading strategy goes past its risk limits, such as if it loses
    more money than it’s allowed, tries to send an order larger than it’s allowed,
    or builds a position larger than it’s allowed, it prevents it from trading. To
    keep our `RiskManager` simple, we will only implement risk checks on the maximum
    allowed order size, the maximum allowed position, and the maximum allowed loss
    for each trading instrument in the client’s trading system. The source code for
    our `RiskManager` can be found in the `Chapter9/trading/strategy/risk_manager.h`
    and `Chapter9/trading/strategy/risk_manager.cpp` source files. First, we will
    declare an enumeration and a `RiskInfo` struct. We discussed the details of this
    component in *Chapter*, *Designing Our Trading Ecosystem*, in the *Designing a
    framework for low-latency C++ trading* *algorithms* section.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the RiskCfg structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will define a structure that holds risk configurations. This is called
    the `RiskCfg` struct and is defined in the `Chapter9/common/types.h` header file.
    The risk configuration holds the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A `max_order_size_` member of the `Qty` type. It represents the maximum allowed
    order size that a strategy is allowed to send.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `max_position_` member variable of the `Qty` type. This represents the maximum
    position that a strategy is allowed to build.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `max_loss_` variable of the `double` type. This is the maximum allowed loss
    before the trading strategy is shut off from trading further.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We must also add a `toString()` method to the structure for logging purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We will define another configuration structure in the next section. This structure
    will be used to configure `TradeEngine`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the TradeEngineCfg structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we must define a structure to encapsulate `TradeEngine` configurations.
    We will call it `TradeEngineCfg`. This is what we use as the higher-level `TradeEngine`
    configuration and is defined in the `Chapter9/common/types.h` header file. It
    has the following important data members:'
  prefs: []
  type: TYPE_NORMAL
- en: A `clip_` member of the `Qty` type. This is what the trading strategies will
    use as the quantity of the orders that they send out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `threshold_` member of the `double` type. This will be used by the trading
    strategies and will be used against the feature values to decide if a trading
    decision needs to be made or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final member is a `risk_cfg_` variable of the `RiskCfg` type. We defined
    this previously so that it can hold the risk configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As usual, we must also define a `toString()` method to convert these objects
    into strings for logging purposes. All the code described here can be seen in
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TradeEngineCfgHashMap` type we are defining here is a `std::array` of
    these `TradeEngineCfg` objects and is large enough to hold all possible `TickerId`
    values (`ME_MAX_TICKERS`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to define a type to represent the outcome of risk checks – the
    `RiskCheckResult` enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the RiskCheckResult enumeration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will formally declare the `RiskCheckResult` enumeration we encountered
    before. But before we do that, let’s look at the `include` files we need in the
    `risk_manager.h` header file. We will also need to forward declare the `OrderManager`
    class we built before so that we can use it without running into circular header
    dependency issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RiskCheckResult` enumeration is used to encapsulate information about
    the outcome of a risk check in `RiskManager`. Let’s look at these values in more
    detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INVALID` represents an invalid sentinel value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ORDER_TOO_LARGE` means that the risk check failed because the order quantity
    that we are attempting to send would exceed the maximum allowed order quantity
    limit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POSITION_TOO_LARGE` means that the current position, plus the order quantity
    on the side we are attempting to send, would cause us to potentially exceed the
    maximum position limit that’s been configured in `RiskManager`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LOSS_TOO_LARGE` enumeration represents the fact that the risk check failed
    because the trading strategy’s total loss (realized plus unrealized loss) is above
    what is allowed in `RiskManager`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ALLOWED` enumeration is a value that represents that all risk checks passed
    successfully. As mentioned previously, this is the only value that allows the
    trading strategy to send additional orders to the exchange:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also add a `riskCheckResultToString()` method to convert these enumerations
    into strings for logging purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will define the basic `RiskInfo` struct, which holds
    the information we need to perform risk checks for a single trading instrument.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the RiskInfo structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously, the `RiskInfo` struct holds the information needed
    to perform risk checks for a single trading instrument. The `RiskManager` class
    maintains and manages a container of `RiskInfo` objects. The `RiskInfo` struct
    needs the following important data members:'
  prefs: []
  type: TYPE_NORMAL
- en: A `const` pointer to `PositionInfo` called `position_info_`. This will be used
    to fetch the position and PnL information for the trading instrument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An object (`risk_cfg_`) of the `RiskCfg` type to hold the configured risk limits
    for this instrument. These are the limits that will be checked against:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add a `toString()` method to this class for logging purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must define a `TickerRiskInfoHashMap` type, which is a `std::array`
    of `RiskInfo` objects of `ME_MAX_TICKERS` size. We will use this as a hash map
    of `TickerId` to `RiskInfo` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will look at the implementation of the `checkPreTradeRisk()` method,
    which performs the actual risk checks.
  prefs: []
  type: TYPE_NORMAL
- en: Performing risk checks in RiskInfo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `checkPreTradeRisk()` method accepts a `Side` argument and a `Qty` argument
    and returns a `RiskCheckResult` enumeration value, depending on whether the risk
    check passes or fails for some reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'First, it checks if the `qty` argument that’s passed to the method is larger
    than the `max_order_size_` member in the `RiskCfg` object (`risk_cfg_`). If this
    is the case, the risk check fails, and it returns the `RiskCheckResult::ORDER_TOO_LARGE`
    enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it checks if the current `position_` (which it fetches from the `position_info_`
    data member), plus the additional `qty` we want to send, exceeds the maximum allowed
    `max_position_ limit` in the `RiskCfg` object (`risk_cfg_`). Note that it uses
    the `sideToValue(side)` method here to correctly compute what the position could
    be if this new `qty` were to be executed and then uses the `std::abs()` method
    to correctly compare against the `max_position_` parameter. In the case of a failure,
    it signifies the error by returning the `RiskCheckResult::POSITION_TOO_LARGE`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it checks the last risk metric in our `RiskManager`, which is the
    total loss. It checks `total_pnl_` from `position_info_` against the `max_loss_`
    parameter in the `risk_cfg_` configuration. If the loss exceeds the max loss allowed,
    it returns a `RiskCheckResult::LOSS_TOO_LARGE` enumeration value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if all the risk checks pass successfully, it returns the `RiskCheckResult::ALLOWED`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This important method concludes the design and implementation of the `RiskInfo`
    struct. Now, we can start building the `RiskManager` class, which is used by the
    other components we covered.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the data members in RiskManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will design our `RiskManager`, starting by defining the data members
    that make up this class. The key member is a `ticker_risk_` variable of the `TickerRiskInfoHashMap`
    type and holds `RiskInfo` objects. We defined this previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will learn how to initialize the `RiskManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing our RiskManager class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `RiskManager` constructor expects a `Logger` object, a pointer to a `PositionKeeper`
    object, and a reference to an object of the `TradeEngineCfgHashMap` type (`ticker_cfg`)
    that holds the risk configurations. It initializes the `logger_` member variable
    and stores the `PositionInfo` objects from the `PositionKeeper` (`getPositionInfo()`)
    and `RiskCfg` objects from `TradeEngineCfgHashMap` (`risk_cfg_`) in the `TickerRiskInfoHashMap`
    data member (`ticker_risk_`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will implement the final task that `RiskManager` needs to perform –
    performing risk checks.
  prefs: []
  type: TYPE_NORMAL
- en: Performing risk checks in RiskManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given a `TickerId` for an instrument, as well as a `Side` and `Qty` for the
    order we expect to send, performing risk checks for it in `RiskManager` is straightforward.
    It simply fetches the correct `RiskInfo` object corresponding to the instrument,
    calls the `RiskInfo::checkPreTradeRisk()` method, and returns the return value
    from that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: That concludes our design and implementation of the `RiskManager` component,
    as well as all the components we needed before we can start putting them together
    and building our trading strategies. We will start with that in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: One important note is that we will need to build all the components presented
    in this chapter, as well as *Building the C++ Market-Making and Liquidity-Taking
    Algorithms* chapter before we can build and run a meaningful trading client. Since
    our ecosystem consists of a server (trading exchange) and client (trading client)
    infrastructure, we will need to wait until the *Building the C++ Market-Making
    and Liquidity-Taking Algorithms* chapter, the *Building and running the main trading
    application* section, before we can run the full ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, our primary focus was on adding intelligence and sophistication
    to the market participants’ trading systems. First, we discussed our market-making
    and liquidity-taking trading strategies. We discussed the motivation behind these
    strategies, how they seek to profit in the markets, and the trading dynamics of
    these algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented the important components that make up the intelligence around
    our trading strategies. The first one was the feature engine that’s used to compute
    trading features/signals from the market data so that they can be used by the
    trading strategies to make informed trading decisions. The next one was the position
    keeper, which is in charge of tracking a trading strategy’s positions and PnLs
    as the strategy’s orders are executed in the market. After, we looked at the order
    manager component, which sends and manages live orders in the market to simplify
    the trading strategy’s implementation. The risk manager was the final and possibly
    the most vital component that we looked at since it is in charge of tracking and
    regulating the risk that a trading algorithm has currently taken, as well as any
    additional risk it is trying to take.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all the important components in one place, in the next chapter,
    we will build our market-making strategy to provide passive liquidity in the market.
    Then, we will build the liquidity-taking trading algorithm to send aggressive
    orders and initiate and manage positions in the market. Finally, we will build
    our trade engine framework, which will house all the necessary components and
    build and drive the trading algorithms we built. By doing this, we will complete
    our electronic trading ecosystem.
  prefs: []
  type: TYPE_NORMAL
