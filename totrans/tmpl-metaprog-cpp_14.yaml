- en: Assignment Answers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业答案
- en: '[*Chapter 1*](B18367_01_ePub.xhtml#_idTextAnchor015), Introduction to Templates'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第一章*](B18367_01_ePub.xhtml#_idTextAnchor015)，模板简介'
- en: '**Question 1**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 1**'
- en: Why do we need templates? What advantages do they provide?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么需要模板？它们提供了哪些优势？
- en: '**Answer**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: 'There are several benefits to using templates: they help us avoid writing repetitive
    code, they foster the creation of generic libraries, and they can help us write
    less and better code.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板有几个好处：它们帮助我们避免编写重复的代码，促进了通用库的创建，并且可以帮助我们编写更少、更好的代码。
- en: '**Question 2**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 2**'
- en: How do you call a function that is a template? What about a class that is a
    template?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如何调用模板函数？对于模板类又是如何？
- en: '**Answer**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: A function that is a template is called a function template. Similarly, a class
    that is a template is called a class template.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 模板函数被称为函数模板。同样，模板类被称为类模板。
- en: '**Question 3**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 3**'
- en: How many kinds of template parameters exist and what are they?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少种模板参数类型？它们是什么？
- en: '**Answer**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: 'There are three kinds of template parameters: type template parameters, non-type
    template parameters, and template template parameters.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数有三种类型：类型模板参数、非类型模板参数和模板模板参数。
- en: '**Question 4**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 4**'
- en: What is partial specialization? What about full specialization?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是部分专业化？完全专业化又是如何？
- en: '**Answer**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: Specialization is the technique of providing an alternative implementation for
    a template, called the primary template. Partial specialization is an alternative
    implementation provided for only some of the template parameters. A full specialization
    is an alternative implementation when arguments are provided for all the template
    parameters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 专业化是一种为模板提供替代实现的技术，这种模板被称为主模板。部分专业化是为模板的一些参数提供的替代实现。当为所有模板参数提供参数时，这是一种完全专业化的替代实现。
- en: '**Question 5**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 5**'
- en: What are the main disadvantages of using templates?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板的主要缺点是什么？
- en: '**Answer**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: 'The main disadvantages of using templates include the following: complex and
    cumbersome syntax, compiler errors that are often long and hard to read and understand,
    and increased compilation times.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板的主要缺点包括以下内容：复杂的语法、通常很长且难以阅读和理解的编译器错误，以及编译时间的增加。
- en: '[*Chapter 2*](B18367_02_ePub.xhtml#_idTextAnchor024), Template Fundamentals'
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第二章*](B18367_02_ePub.xhtml#_idTextAnchor024)，模板基础'
- en: '**Question 1**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 1**'
- en: What category of types can be used for non-type template parameters?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些类型的类型可以用于非类型模板参数？
- en: '**Answer**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: 'Non-type template parameters can only have structural types. Structure types
    are integral types, floating-point types (as of C++20), enumeration types, pointer
    types (either to objects or functions), pointer to member types (either to member
    objects or member functions), lvalue reference types (either to objects or functions),
    and literal class types that meet several requirements: all base classes are public
    and non-mutable, all non-static data members are public and non-mutable, and the
    types of all the base classes and the non-static data members are also structural
    types or arrays thereof. `const` and `volatile` qualified versions of these types
    are also allowed.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 非类型模板参数只能具有结构化类型。结构化类型包括整数类型、浮点类型（自 C++20 起包括）、枚举类型、指针类型（指向对象或函数）、成员指针类型（指向成员对象或成员函数）、左值引用类型（指向对象或函数），以及满足几个要求的字面类类型：所有基类都是公共的且不可变的，所有非静态数据成员都是公共的且不可变的，所有基类和所有非静态数据成员的类型也是结构化类型或其数组。这些类型的
    `const` 和 `volatile` 修饰版本也是允许的。
- en: '**Question 2**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 2**'
- en: Where are default template arguments not allowed?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模板参数不允许在哪些地方使用？
- en: '**Answer**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: Default template arguments cannot be used for parameter packs, in declarations
    of friend class templates, and in the declaration or definition of an explicit
    specialization of a function template or member function template.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模板参数不能用于参数包的声明，在友元类模板的声明中，以及在函数模板或成员函数模板的显式特化的声明或定义中。
- en: '**Question 3**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 3**'
- en: What is explicit instantiation declaration and how does it differ syntactically
    from explicit instantiation definition?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 显式实例化声明是什么？它与显式实例化定义在语法上有什么区别？
- en: '**Answer**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: Explicit instantiation declaration is the way you can tell the compiler that
    the definition of a template instantiation is found in a different translation
    unit and that a new definition should not be generated. The syntax is the same
    as for explicit instantiation definitions, except that the `extern` keyword is
    used in front of the declaration.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 显式实例化声明是告诉编译器模板实例化的定义位于不同的翻译单元中，并且不应生成新定义的方法。其语法与显式实例化定义相同，只是声明前使用了`extern`关键字。
- en: '**Question 4**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题4**'
- en: What is an alias template?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是别名模板？
- en: '**Answer**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: An alias template is a name that, unlike type aliases, which refer to another
    type, refers to a template or, in other words, a family of types. Alias templates
    are introduced with using declarations. They cannot be introduced with `typedef`
    declarations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 别名模板是一个名称，与类型别名不同，它不是引用另一个类型，而是引用一个模板，换句话说，是一系列类型。别名模板通过使用声明引入。它们不能通过`typedef`声明引入。
- en: '**Question 5**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题5**'
- en: What are template lambdas?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是模板lambda？
- en: '**Answer**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: Template lambdas are an improved form of generic lambdas, introduced in C++20\.
    They allow us to use the template syntax to explicitly specify the shape of the
    templatized function-call operator of the function object that the compiler is
    generating for a lambda expression.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 模板lambda是C++20中引入的泛型lambda的改进形式。它们允许我们使用模板语法显式指定编译器为lambda表达式生成的函数对象的模板化函数调用运算符的形状。
- en: '[*Chapter 3*](B18367_03_ePub.xhtml#_idTextAnchor051), Variadic Templates'
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第3章*](B18367_03_ePub.xhtml#_idTextAnchor051)，变长模板'
- en: '**Question 1**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题1**'
- en: What are variadic templates and why are they useful?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是变长模板以及它们为什么有用？
- en: '**Answer**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: Variadic templates are templates with a variable number of arguments. They allow
    us to write not only functions with variable number of arguments but also class
    templates, variable templates, and alias templates. Unlike other approaches, such
    as the use of the `va_` macros, they are type-safe, do not require macros, and
    do not require us to explicitly specify the number of arguments.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 变长模板是具有可变数量参数的模板。它们不仅允许我们编写具有可变数量参数的函数，还可以编写类模板、可变模板和别名模板。与使用`va_`宏等其他方法不同，它们是类型安全的，不需要宏，也不需要我们显式指定参数数量。
- en: '**Question 2**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题2**'
- en: What is a parameter pack?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是参数包？
- en: '**Answer**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: 'There are two kinds of parameter packs: template parameter packs and function
    parameter packs. The former are template parameters that accept zero, one, or
    more template arguments. The latter are function parameters that accept zero,
    one, or more function arguments.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种参数包：模板参数包和函数参数包。前者是接受零个、一个或多个模板参数的模板参数。后者是接受零个、一个或多个函数参数的函数参数。
- en: '**Question 3**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题3**'
- en: What are the contexts where parameter packs can be expanded?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪些上下文中可以展开参数包？
- en: '**Answer**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: 'Parameter packs can be expanded in a multitude of contexts, as follows: template
    parameter lists, template argument lists, function parameter lists, function argument
    lists, parenthesized initializers, brace-enclosed initializers, base specifiers
    and member initializer lists, fold expressions, using declarations, lambda captures,
    the `sizeof…` operator, alignment specifiers, and attribute lists.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 参数包可以在多种上下文中展开，如下所示：模板参数列表、模板参数列表、函数参数列表、函数参数列表、括号初始化器、花括号初始化器、基指定符和成员初始化列表、折叠表达式、使用声明、lambda捕获、`sizeof...`运算符、对齐指定符和属性列表。
- en: '**Question 4**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题4**'
- en: What are fold expressions?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是折叠表达式？
- en: '**Answer**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: A fold expression is an expression involving a parameter pack that folds (or
    reduces) the elements of the parameter pack over a binary operator.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠表达式是一个涉及参数包的表达式，它将参数包的元素折叠（或归约）到二元运算符上。
- en: '**Question 5**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题5**'
- en: What are the benefits of using fold expressions?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用折叠表达式的优点是什么？
- en: '**Answer**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: The benefits of using fold expressions include having less and simpler code
    to write, fewer template instantiations, which lead to faster compile times, and
    potentially faster code, since multiple function calls are replaced with a single
    expression.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用折叠表达式的优点包括编写更少、更简单的代码，更少的模板实例化，这导致编译时间更快，并且可能更快地执行代码，因为多个函数调用被单个表达式所替代。
- en: '[*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064), Advanced Template Concepts'
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第4章*](B18367_04_ePub.xhtml#_idTextAnchor064)，高级模板概念'
- en: '**Question 1**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题1**'
- en: When is name lookup performed?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在何时进行名称查找？
- en: '**Answer**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: Name lookup is performed at the point of template instantiation for dependent
    names (those that depend on the type or value of a template parameter) and at
    the point of template definition for non-dependent names (those that don’t depend
    on template parameters).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 名称查找是在模板实例化的点上对依赖名称（依赖于模板参数的类型或值的名称）进行的，在模板定义的点上对非依赖名称（不依赖于模板参数的名称）进行的。
- en: '**Question 2**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 2**'
- en: What are deduction guides?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 推导指南是什么？
- en: '**Answer**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: Deduction guides are a mechanism that tells the compiler how to perform class
    template argument deduction. Deduction guides are fictional function templates
    representing constructor signatures of a fictional class type. If overload resolution
    fails on the constructed set of fictional function templates, then the program
    is ill-formed and an error is generated. Otherwise, the return type of the selected
    function template specialization becomes the deduced class template specialization.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 推导指南是一种机制，告诉编译器如何执行类模板参数的推导。推导指南是代表虚构类类型的构造函数签名的虚构函数模板。如果虚构函数模板的构造集上解析过载失败，则程序是不良形式，并生成错误。否则，所选函数模板特化的返回类型成为推导出的类模板特化。
- en: '**Question 3**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 3**'
- en: What are forwarding references?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是前向引用？
- en: '**Answer**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: A forward reference (also known as universal reference) is a reference in a
    template that behaves as an rvalue reference if an rvalue was passed as an argument
    or an lvalue reference if an lvalue was passed as an argument. A forwarding reference
    must have the `T&&` form such as in `template <typename T> void f(T&&)`. Forms
    such as `T const &&` or `std::vector<T>&&` do not represent forwarding references
    but normal rvalue references.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前向引用（也称为通用引用）是模板中的一个引用，如果传递了右值作为参数，则表现得像一个右值引用；如果传递了左值作为参数，则表现得像一个左值引用。前向引用必须具有
    `T&&` 形式，例如在 `template <typename T> void f(T&&)` 中。如 `T const &&` 或 `std::vector<T>&&`
    这样的形式不代表前向引用，而是正常的右值引用。
- en: '**Question 4**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 4**'
- en: What does `decltype` do?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`decltype` 做什么？'
- en: '**Answer**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: The `decltype` specifier is a type specifier. It returns the type of an expression.
    It is usually used in templates together with the `auto` specifier in order to
    declare the return type of a function template that depends on its template arguments,
    or the return type of a function that wraps another function and returns the result
    from executing the wrapped function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`decltype` 说明符是一个类型说明符。它返回表达式的类型。它通常与 `auto` 说明符一起在模板中使用，以声明依赖于其模板参数的函数模板的返回类型，或者包装另一个函数并返回包装函数执行结果的函数的返回类型。'
- en: '**Question 5**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 5**'
- en: What does `std::declval` do?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::declval` 做什么？'
- en: '**Answer**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: '`std::declval` is a utility function template from the `<utility>` header that
    adds an rvalue reference to its type template argument. It can only be used in
    unevaluated contexts (compile-time-only contexts that are not evaluated during
    runtime), and its purpose is to help with dependent type evaluation for types
    that do not have a default constructor or one that cannot be accessed because
    it’s private or protected.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::declval` 是来自 `<utility>` 头文件的一个实用函数模板，它为其类型模板参数添加了一个右值引用。它只能在未评估上下文中使用（仅在编译时上下文中使用，在运行时不进行评估），其目的是帮助对没有默认构造函数或无法访问的（因为它私有或受保护）的类型进行依赖类型评估。'
- en: '[*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080), Type Traits and Conditional
    Compilation'
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第 5 章*](B18367_05_ePub.xhtml#_idTextAnchor080)，类型特性和条件编译'
- en: '**Question 1**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 1**'
- en: What are type traits?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是类型特性？
- en: '**Answer**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: Type traits are small class templates that enable us to either query properties
    of types or perform transformations of types.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 类型特性是小的类模板，使我们能够查询类型的属性或对类型进行转换。
- en: '**Question 2**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 2**'
- en: What is SFINAE?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 SFINAE？
- en: '**Answer**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: '**SFINAE** is an acronym for **Substitution Failure Is Not An Error**. This
    is a rule for template substitution and works as follows: when the compiler encounters
    the use of a function template, it substitutes the arguments in order to instantiate
    the template; if an error occurs at this point, it is not regarded as an ill-formed
    code, only as a deduction failure. As a result, the function is removed from the
    overload set instead of causing an error. Therefore, an error only occurs if there
    is no match in the overload set for a particular function call.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**SFINAE** 是 **Substitution Failure Is Not An Error** 的缩写。这是一个模板替换规则，其工作方式如下：当编译器遇到函数模板的使用时，它会替换参数以实例化模板；如果在此处发生错误，它不会被视为无效代码，而只是推导失败。因此，函数将从重载集中移除，而不是导致错误。因此，只有在特定函数调用在重载集中没有匹配项时才会发生错误。'
- en: '**Question 3**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 3**'
- en: What is `constexpr if`?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 `constexpr if`？
- en: '**Answer**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: '`constexpr if` is a compile-time version of the `if` statement. The syntax
    for it is `if` `constexpr(condition)`. It’s been available since C++17 and allows
    us to discard a branch, at compile time, based on the value of a compile-time
    expression.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr if` 是 `if` 语句的编译时版本。它的语法是 `if` `constexpr(condition)`。它自 C++17 起可用，允许我们根据编译时表达式的值在编译时丢弃一个分支。'
- en: '**Question 4**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 4**'
- en: What does `std::is_same` do?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::is_same` 做什么？'
- en: '**Answer**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: '`std::is_same` is a type trait that checks whether two types are the same.
    It includes checks for the `const` and `volatile` qualifiers, yielding `false`
    for two types that have different qualifiers (such as `int` and `int const`).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::is_same` 是一个类型特性，用于检查两个类型是否相同。它包括对 `const` 和 `volatile` 修饰符的检查，如果两个类型有不同的修饰符（例如
    `int` 和 `int const`），则返回 `false`。'
- en: '**Question 5**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 5**'
- en: What does `std::conditional` do?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::conditional` 做什么？'
- en: '**Answer**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: '`std::conditional` is a metafunction that chooses one type or another based
    on a compile-time constant.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::conditional` 是一个元函数，根据编译时常量选择一个类型或另一个类型。'
- en: '[*Chapter 6*](B18367_06_ePub.xhtml#_idTextAnchor099), Concepts and Constraints'
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第 6 章*](B18367_06_ePub.xhtml#_idTextAnchor099)，概念和约束'
- en: '**Question 1**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 1**'
- en: What are constraints? What about concepts?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 约束是什么？概念又是什么？
- en: '**Answer**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: A constraint is a requirement imposed on a template argument. A concept is a
    named set of one or more constraints.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 约束是对模板参数施加的要求。概念是一组命名约束。
- en: '**Question 2**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 2**'
- en: What is a requires clause and a requires expression?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 需求子句和需求表达式是什么？
- en: '**Answer**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: A requires clause is a construct that allows us to specify a constraint on a
    template argument or function declaration. This construct is composed of the `requires`
    keyword followed by a compile-time Boolean expression. A requires clause affects
    the behavior of a function, including it for overload resolution only if the Boolean
    expression is `true`. On the other hand, a requires expression has the `requires
    (parameters-list) expression;` form, where `parameters-list` is optional. Its
    purpose is to verify that some expressions are well-formed, without having any
    side effects or affecting the behavior of the function. Requires expressions can
    be used with requires clauses, although named concepts are preferred, mainly for
    readability.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 需求子句是一个构造，允许我们指定模板参数或函数声明的约束。这个构造由 `requires` 关键字后跟一个编译时布尔表达式组成。需求子句会影响函数的行为，包括在重载解析中仅当布尔表达式为
    `true` 时才包括它。另一方面，需求表达式具有 `requires (parameters-list) expression;` 的形式，其中 `parameters-list`
    是可选的。它的目的是验证某些表达式是否良好形成，没有任何副作用或影响函数的行为。需求表达式可以与需求子句一起使用，尽管命名概念更受欢迎，主要是因为可读性。
- en: '**Question 3**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 3**'
- en: What are the categories of requires expressions?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 需求表达式的类别有哪些？
- en: '**Answer**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: 'There are four categories of requires expressions: simple requirements, type
    requirements, compound requirements, and nested requirements.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 需求表达式分为四类：简单需求、类型需求、复合需求和嵌套需求。
- en: '**Question 4**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 4**'
- en: How do constraints affect the ordering of templates in overload resolution?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 约束如何影响重载解析中模板的排序？
- en: '**Answer**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: The constraining of functions affects their order in the overload resolution
    set. When multiple overloads match the set of arguments, the overload that is
    more constrained is selected. However, keep in mind that constraining with type
    traits (or Boolean expressions in general) and concepts is not semantically equal.
    For details on this topic, revisit the *Learning about the ordering of templates
    with constraints* section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的约束会影响它们在重载解析集中的顺序。当多个重载与参数集匹配时，选择约束更强的重载。然而，请注意，使用类型特性（或一般而言的布尔表达式）和概念进行约束在语义上并不相同。有关此主题的详细信息，请回顾*了解具有约束的模板排序*部分。
- en: '**Question 5**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题5**'
- en: What are abbreviated function templates?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 简化函数模板是什么？
- en: '**Answer**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: Abbreviated function templates are a new feature introduced in C++20 that provides
    a simplified syntax for function templates. The `auto` specifier can be used to
    define function parameters and the template syntax can be skipped. The compiler
    will automatically generate a function template from an abbreviated function template.
    Such functions can be constrained using concepts, therefore imposing requirements
    on the template arguments.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 简化函数模板是C++20中引入的新特性，它为函数模板提供了简化的语法。可以使用`auto`指定符来定义函数参数，并且可以省略模板语法。编译器将自动从简化函数模板生成函数模板。这些函数可以使用概念进行约束，因此对模板参数施加要求。
- en: '[*Chapter 7*](B18367_07_ePub.xhtml#_idTextAnchor123), Patterns and Idioms'
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第7章*](B18367_07_ePub.xhtml#_idTextAnchor123)，模式和惯用法'
- en: '**Question 1**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题1**'
- en: What are typical problems for which the Curiously Recuring Template Pattern
    is used?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 奇特重复模板模式通常用于解决哪些典型问题？
- en: '**Answer**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: The **Curiously Recurring Template Pattern** (**CRTP**) is typically used for
    solving problems such as adding common functionality to types and avoiding code
    duplication, limiting the number of times a type can be instantiated, or implementing
    the composite design pattern.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**奇特重复模板模式**（**CRTP**）通常用于解决为类型添加公共功能、避免代码重复、限制类型实例化的次数或实现组合设计模式等问题。'
- en: '**Question 2**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题2**'
- en: What are mixins and what is their purpose?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 混合模式是什么？它们的目的又是什么？
- en: '**Answer**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: Mixins are small classes that are designed to add functionality to other classes,
    by inheriting from the classes they are supposed to complement. This is the opposite
    of the CRTP pattern.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 混合模式是设计用来通过从它们打算补充的类继承来向其他类添加功能的小类。这与CRTP模式相反。
- en: '**Question 3**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题3**'
- en: What is type erasure?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除是什么？
- en: '**Answer**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: Type erasure is the term used to describe a pattern that removes information
    from types, making it possible for types that are not related to be treated in
    a generic way. Although forms of type erasure can be achieved with `void` pointers
    or polymorphism, the true type erasure pattern is achieved in C++ with templates.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除是描述从类型中删除信息的模式的术语，这使得不相关的类型可以以通用方式处理。尽管可以通过`void`指针或多态实现类型擦除的形式，但真正的类型擦除模式是在C++中使用模板实现的。
- en: '**Question 4**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题4**'
- en: What is tag dispatching and what are its alternatives?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 标签分派是什么？它的替代方案有哪些？
- en: '**Answer**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: Tag dispatching is a technique that enables us to select one or another function
    overload at compile time. Although tag dispatching itself is an alternative to
    `std::enable_if` and SFINAE, it also has its own alternatives. These are constexpr
    if in C++17 and concepts in C++20.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 标签分派是一种技术，它使我们能够在编译时选择一个或另一个函数重载。虽然标签分派本身是`std::enable_if`和SFINAE的替代方案，但它也有自己的替代方案。这些是C++17中的constexpr
    if和C++20中的概念。
- en: '**Question 5**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题5**'
- en: What are expression templates and where are they used?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式模板是什么？它们在哪里被使用？
- en: '**Answer**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: Expression templates are a metaprogramming technique that enables a lazy evaluation
    of a computation at compile-time. The benefit of this technique is that it avoids
    performing inefficient operations at runtime at the expense of more complex code
    that could be difficult to comprehend. Expression templates are typically used
    to implement linear algebra libraries.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式模板是一种元编程技术，它允许在编译时进行计算的惰性评估。这种技术的优点是它避免了在运行时执行低效操作，代价是代码更加复杂，可能难以理解。表达式模板通常用于实现线性代数库。
- en: '[*Chapter 8*](B18367_08_ePub.xhtml#_idTextAnchor179), Ranges and Algorithms'
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第8章*](B18367_08_ePub.xhtml#_idTextAnchor179)，范围和算法'
- en: '**Question 1**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题1**'
- en: What are the sequence containers from the standard library?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的序列容器有哪些？
- en: '**Answer**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: The sequence containers from the C++ standard library are `std::vector`, `std::deque`,
    `std::list`, `std::array`, and `std::forward_list`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 标准库中的序列容器包括 `std::vector`，`std::deque`，`std::list`，`std::array` 和 `std::forward_list`。
- en: '**Question 2**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 2**'
- en: What are the common member functions defined in the standard containers?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 标准容器中定义了哪些常见的成员函数？
- en: '**Answer**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: The member functions that are defined for most containers in the standard library
    are `size` (not present in `std::forward_list`), `empty`, `clear` (not present
    in `std::array`, `std::stack`, `std::queue`, and `std::priority_queue`), `swap`,
    `begin`, and `end`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中大多数容器定义的成员函数包括 `size`（在 `std::forward_list` 中不存在），`empty`，`clear`（在 `std::array`，`std::stack`，`std::queue`
    和 `std::priority_queue` 中不存在），`swap`，`begin` 和 `end`。
- en: '**Question 3**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 3**'
- en: What are iterators and how many categories exist?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是什么？有多少个类别？
- en: '**Answer**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: 'An iterator is an abstraction that enables us to access the elements of a container
    in a generic way, without having to know the implementation details of each container.
    Iterators are key for writing general-purpose algorithms. There are six categories
    of iterators in C++: input, forward, bidirectional, random-access, contiguous
    (as of C++17), and output.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是一种抽象，它使我们能够以通用方式访问容器中的元素，而无需了解每个容器的实现细节。迭代器对于编写通用算法至关重要。在 C++ 中有六种迭代器类别：输入迭代器、正向迭代器、双向迭代器、随机访问迭代器、连续迭代器（自
    C++17 起存在）和输出迭代器。
- en: '**Question 4**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 4**'
- en: What operations does a random-access iterator support?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 随机访问迭代器支持哪些操作？
- en: '**Answer**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: 'The random-access iterators must support the following operations (in addition
    to those required for input, forward, and bidirectional iterators): the `+` and
    `-` arithmetic operators, inequality comparison (with other iterators), compound
    assignment, and offset dereference operators.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 随机访问迭代器必须支持以下操作（除了输入、正向和双向迭代器所需操作之外）：`+` 和 `-` 算术运算符，不等式比较（与其他迭代器），复合赋值运算符和偏移量解引用运算符。
- en: '**Question 5**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 5**'
- en: What are range access functions?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是范围访问函数？
- en: '**Answer**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: Range access functions are non-member functions that provide a uniform way to
    access the data or properties of containers, arrays, and the `std::initializer_list`
    class. These functions include `std::size`/`std::ssize`, `std::empty`, `std::data`,
    `std::begin`, and `std::end`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 范围访问函数是非成员函数，它们提供了一种统一的方式来访问容器、数组和 `std::initializer_list` 类的数据或属性。这些函数包括 `std::size`/`std::ssize`，`std::empty`，`std::data`，`std::begin`
    和 `std::end`。
- en: '[*Chapter 9*](B18367_09_ePub.xhtml#_idTextAnchor188), The Ranges Library'
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第 9 章*](B18367_09_ePub.xhtml#_idTextAnchor188)，范围库'
- en: '**Question 1**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 1**'
- en: What is a range?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是范围？
- en: '**Answer**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: A range is an abstraction for a sequence of elements, defined with a beginning
    and end iterator. The beginning iterator points to the first element in the sequence.
    The end iterator points to the one-past-last element of the sequence.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 范围是对元素序列的抽象，由起始迭代器和结束迭代器定义。起始迭代器指向序列中的第一个元素。结束迭代器指向序列的最后一个元素之后的位置。
- en: '**Question 2**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 2**'
- en: What is a view in the ranges library?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 范围库中的视图是什么？
- en: '**Answer**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: A view in the C++ ranges library, also called a range adaptor, is an object
    that implements an algorithm that takes one or more ranges as input and perhaps
    other arguments and returns an adapted range. Views are lazy-evaluated, meaning
    they do not perform the adaptation until their elements are iterated.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 范围库中的一个视图，也称为范围适配器，是一个实现算法的对象，该算法接受一个或多个范围作为输入，可能还有其他参数，并返回一个调整后的范围。视图是延迟计算的，这意味着它们在迭代元素之前不会执行调整。
- en: '**Question 3**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 3**'
- en: What are constrained algorithms?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是限制性算法？
- en: '**Answer**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: Constrained algorithms are implementations of the existing standard library
    algorithms but in the C++20 ranges library. They are called constrained because
    their template arguments are constrained using C++20 concepts. In these algorithms,
    instead of requiring a begin-end pair of iterators for specifying, a range of
    values accepts a single range argument. However, overloads that accept an iterator-sentinel
    pair also exist.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 限制性算法是现有标准库算法的实现，但位于 C++20 范围库中。它们被称为限制性，因为它们的模板参数使用 C++20 概念进行约束。在这些算法中，而不是要求一个
    begin-end 迭代器对来指定，一个值范围接受单个范围参数。然而，也存在接受迭代器-哨兵对的过载。
- en: '**Question 4**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 4**'
- en: What is a sentinel?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是哨兵？
- en: '**Answer**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: A sentinel is an abstraction for an end iterator. This makes it possible for
    the end iterator to have a different type than the range iterator. Sentinels cannot
    be dereferenced or incremented. Sentinels are useful when the test for the end
    of a range depends on some variable (dynamic) condition and you don’t know you
    are at the end of the range until something happens (for instance, a condition
    becomes false).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 哨兵是对结束迭代器的抽象。这使得结束迭代器可以具有与范围迭代器不同的类型。哨兵不能被解引用或递增。当测试范围结束的条件依赖于某些变量（动态）条件，并且你不知道何时到达范围的末尾（例如，某个条件变为假）时，哨兵非常有用。
- en: '**Question 5**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题 5**'
- en: How can you check that a sentinel type corresponds to an iterator type?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何检查哨兵类型是否对应迭代器类型？
- en: '**Answer**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案**'
- en: You can check that a sentinel type can be used with an iterator type by using
    the `std::sentinel_for` concept from the `<iterator>` header.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用来自 `<iterator>` 头文件的 `std::sentinel_for` 概念来检查哨兵类型是否可以与迭代器类型一起使用。
