- en: Assignment Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Chapter 1*](B18367_01_ePub.xhtml#_idTextAnchor015), Introduction to Templates'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Question 1**'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need templates? What advantages do they provide?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several benefits to using templates: they help us avoid writing repetitive
    code, they foster the creation of generic libraries, and they can help us write
    less and better code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 2**'
  prefs: []
  type: TYPE_NORMAL
- en: How do you call a function that is a template? What about a class that is a
    template?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: A function that is a template is called a function template. Similarly, a class
    that is a template is called a class template.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 3**'
  prefs: []
  type: TYPE_NORMAL
- en: How many kinds of template parameters exist and what are they?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three kinds of template parameters: type template parameters, non-type
    template parameters, and template template parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 4**'
  prefs: []
  type: TYPE_NORMAL
- en: What is partial specialization? What about full specialization?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: Specialization is the technique of providing an alternative implementation for
    a template, called the primary template. Partial specialization is an alternative
    implementation provided for only some of the template parameters. A full specialization
    is an alternative implementation when arguments are provided for all the template
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 5**'
  prefs: []
  type: TYPE_NORMAL
- en: What are the main disadvantages of using templates?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main disadvantages of using templates include the following: complex and
    cumbersome syntax, compiler errors that are often long and hard to read and understand,
    and increased compilation times.'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 2*](B18367_02_ePub.xhtml#_idTextAnchor024), Template Fundamentals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Question 1**'
  prefs: []
  type: TYPE_NORMAL
- en: What category of types can be used for non-type template parameters?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-type template parameters can only have structural types. Structure types
    are integral types, floating-point types (as of C++20), enumeration types, pointer
    types (either to objects or functions), pointer to member types (either to member
    objects or member functions), lvalue reference types (either to objects or functions),
    and literal class types that meet several requirements: all base classes are public
    and non-mutable, all non-static data members are public and non-mutable, and the
    types of all the base classes and the non-static data members are also structural
    types or arrays thereof. `const` and `volatile` qualified versions of these types
    are also allowed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 2**'
  prefs: []
  type: TYPE_NORMAL
- en: Where are default template arguments not allowed?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: Default template arguments cannot be used for parameter packs, in declarations
    of friend class templates, and in the declaration or definition of an explicit
    specialization of a function template or member function template.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 3**'
  prefs: []
  type: TYPE_NORMAL
- en: What is explicit instantiation declaration and how does it differ syntactically
    from explicit instantiation definition?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit instantiation declaration is the way you can tell the compiler that
    the definition of a template instantiation is found in a different translation
    unit and that a new definition should not be generated. The syntax is the same
    as for explicit instantiation definitions, except that the `extern` keyword is
    used in front of the declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 4**'
  prefs: []
  type: TYPE_NORMAL
- en: What is an alias template?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: An alias template is a name that, unlike type aliases, which refer to another
    type, refers to a template or, in other words, a family of types. Alias templates
    are introduced with using declarations. They cannot be introduced with `typedef`
    declarations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 5**'
  prefs: []
  type: TYPE_NORMAL
- en: What are template lambdas?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: Template lambdas are an improved form of generic lambdas, introduced in C++20\.
    They allow us to use the template syntax to explicitly specify the shape of the
    templatized function-call operator of the function object that the compiler is
    generating for a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B18367_03_ePub.xhtml#_idTextAnchor051), Variadic Templates'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Question 1**'
  prefs: []
  type: TYPE_NORMAL
- en: What are variadic templates and why are they useful?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: Variadic templates are templates with a variable number of arguments. They allow
    us to write not only functions with variable number of arguments but also class
    templates, variable templates, and alias templates. Unlike other approaches, such
    as the use of the `va_` macros, they are type-safe, do not require macros, and
    do not require us to explicitly specify the number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 2**'
  prefs: []
  type: TYPE_NORMAL
- en: What is a parameter pack?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of parameter packs: template parameter packs and function
    parameter packs. The former are template parameters that accept zero, one, or
    more template arguments. The latter are function parameters that accept zero,
    one, or more function arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 3**'
  prefs: []
  type: TYPE_NORMAL
- en: What are the contexts where parameter packs can be expanded?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameter packs can be expanded in a multitude of contexts, as follows: template
    parameter lists, template argument lists, function parameter lists, function argument
    lists, parenthesized initializers, brace-enclosed initializers, base specifiers
    and member initializer lists, fold expressions, using declarations, lambda captures,
    the `sizeof…` operator, alignment specifiers, and attribute lists.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 4**'
  prefs: []
  type: TYPE_NORMAL
- en: What are fold expressions?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: A fold expression is an expression involving a parameter pack that folds (or
    reduces) the elements of the parameter pack over a binary operator.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 5**'
  prefs: []
  type: TYPE_NORMAL
- en: What are the benefits of using fold expressions?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of using fold expressions include having less and simpler code
    to write, fewer template instantiations, which lead to faster compile times, and
    potentially faster code, since multiple function calls are replaced with a single
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18367_04_ePub.xhtml#_idTextAnchor064), Advanced Template Concepts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Question 1**'
  prefs: []
  type: TYPE_NORMAL
- en: When is name lookup performed?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: Name lookup is performed at the point of template instantiation for dependent
    names (those that depend on the type or value of a template parameter) and at
    the point of template definition for non-dependent names (those that don’t depend
    on template parameters).
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 2**'
  prefs: []
  type: TYPE_NORMAL
- en: What are deduction guides?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: Deduction guides are a mechanism that tells the compiler how to perform class
    template argument deduction. Deduction guides are fictional function templates
    representing constructor signatures of a fictional class type. If overload resolution
    fails on the constructed set of fictional function templates, then the program
    is ill-formed and an error is generated. Otherwise, the return type of the selected
    function template specialization becomes the deduced class template specialization.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 3**'
  prefs: []
  type: TYPE_NORMAL
- en: What are forwarding references?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: A forward reference (also known as universal reference) is a reference in a
    template that behaves as an rvalue reference if an rvalue was passed as an argument
    or an lvalue reference if an lvalue was passed as an argument. A forwarding reference
    must have the `T&&` form such as in `template <typename T> void f(T&&)`. Forms
    such as `T const &&` or `std::vector<T>&&` do not represent forwarding references
    but normal rvalue references.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 4**'
  prefs: []
  type: TYPE_NORMAL
- en: What does `decltype` do?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: The `decltype` specifier is a type specifier. It returns the type of an expression.
    It is usually used in templates together with the `auto` specifier in order to
    declare the return type of a function template that depends on its template arguments,
    or the return type of a function that wraps another function and returns the result
    from executing the wrapped function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 5**'
  prefs: []
  type: TYPE_NORMAL
- en: What does `std::declval` do?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::declval` is a utility function template from the `<utility>` header that
    adds an rvalue reference to its type template argument. It can only be used in
    unevaluated contexts (compile-time-only contexts that are not evaluated during
    runtime), and its purpose is to help with dependent type evaluation for types
    that do not have a default constructor or one that cannot be accessed because
    it’s private or protected.'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18367_05_ePub.xhtml#_idTextAnchor080), Type Traits and Conditional
    Compilation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Question 1**'
  prefs: []
  type: TYPE_NORMAL
- en: What are type traits?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: Type traits are small class templates that enable us to either query properties
    of types or perform transformations of types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 2**'
  prefs: []
  type: TYPE_NORMAL
- en: What is SFINAE?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**SFINAE** is an acronym for **Substitution Failure Is Not An Error**. This
    is a rule for template substitution and works as follows: when the compiler encounters
    the use of a function template, it substitutes the arguments in order to instantiate
    the template; if an error occurs at this point, it is not regarded as an ill-formed
    code, only as a deduction failure. As a result, the function is removed from the
    overload set instead of causing an error. Therefore, an error only occurs if there
    is no match in the overload set for a particular function call.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 3**'
  prefs: []
  type: TYPE_NORMAL
- en: What is `constexpr if`?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: '`constexpr if` is a compile-time version of the `if` statement. The syntax
    for it is `if` `constexpr(condition)`. It’s been available since C++17 and allows
    us to discard a branch, at compile time, based on the value of a compile-time
    expression.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 4**'
  prefs: []
  type: TYPE_NORMAL
- en: What does `std::is_same` do?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::is_same` is a type trait that checks whether two types are the same.
    It includes checks for the `const` and `volatile` qualifiers, yielding `false`
    for two types that have different qualifiers (such as `int` and `int const`).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 5**'
  prefs: []
  type: TYPE_NORMAL
- en: What does `std::conditional` do?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::conditional` is a metafunction that chooses one type or another based
    on a compile-time constant.'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18367_06_ePub.xhtml#_idTextAnchor099), Concepts and Constraints'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Question 1**'
  prefs: []
  type: TYPE_NORMAL
- en: What are constraints? What about concepts?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: A constraint is a requirement imposed on a template argument. A concept is a
    named set of one or more constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 2**'
  prefs: []
  type: TYPE_NORMAL
- en: What is a requires clause and a requires expression?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: A requires clause is a construct that allows us to specify a constraint on a
    template argument or function declaration. This construct is composed of the `requires`
    keyword followed by a compile-time Boolean expression. A requires clause affects
    the behavior of a function, including it for overload resolution only if the Boolean
    expression is `true`. On the other hand, a requires expression has the `requires
    (parameters-list) expression;` form, where `parameters-list` is optional. Its
    purpose is to verify that some expressions are well-formed, without having any
    side effects or affecting the behavior of the function. Requires expressions can
    be used with requires clauses, although named concepts are preferred, mainly for
    readability.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 3**'
  prefs: []
  type: TYPE_NORMAL
- en: What are the categories of requires expressions?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four categories of requires expressions: simple requirements, type
    requirements, compound requirements, and nested requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 4**'
  prefs: []
  type: TYPE_NORMAL
- en: How do constraints affect the ordering of templates in overload resolution?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: The constraining of functions affects their order in the overload resolution
    set. When multiple overloads match the set of arguments, the overload that is
    more constrained is selected. However, keep in mind that constraining with type
    traits (or Boolean expressions in general) and concepts is not semantically equal.
    For details on this topic, revisit the *Learning about the ordering of templates
    with constraints* section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 5**'
  prefs: []
  type: TYPE_NORMAL
- en: What are abbreviated function templates?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: Abbreviated function templates are a new feature introduced in C++20 that provides
    a simplified syntax for function templates. The `auto` specifier can be used to
    define function parameters and the template syntax can be skipped. The compiler
    will automatically generate a function template from an abbreviated function template.
    Such functions can be constrained using concepts, therefore imposing requirements
    on the template arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18367_07_ePub.xhtml#_idTextAnchor123), Patterns and Idioms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Question 1**'
  prefs: []
  type: TYPE_NORMAL
- en: What are typical problems for which the Curiously Recuring Template Pattern
    is used?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: The **Curiously Recurring Template Pattern** (**CRTP**) is typically used for
    solving problems such as adding common functionality to types and avoiding code
    duplication, limiting the number of times a type can be instantiated, or implementing
    the composite design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 2**'
  prefs: []
  type: TYPE_NORMAL
- en: What are mixins and what is their purpose?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: Mixins are small classes that are designed to add functionality to other classes,
    by inheriting from the classes they are supposed to complement. This is the opposite
    of the CRTP pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 3**'
  prefs: []
  type: TYPE_NORMAL
- en: What is type erasure?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: Type erasure is the term used to describe a pattern that removes information
    from types, making it possible for types that are not related to be treated in
    a generic way. Although forms of type erasure can be achieved with `void` pointers
    or polymorphism, the true type erasure pattern is achieved in C++ with templates.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 4**'
  prefs: []
  type: TYPE_NORMAL
- en: What is tag dispatching and what are its alternatives?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: Tag dispatching is a technique that enables us to select one or another function
    overload at compile time. Although tag dispatching itself is an alternative to
    `std::enable_if` and SFINAE, it also has its own alternatives. These are constexpr
    if in C++17 and concepts in C++20.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 5**'
  prefs: []
  type: TYPE_NORMAL
- en: What are expression templates and where are they used?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: Expression templates are a metaprogramming technique that enables a lazy evaluation
    of a computation at compile-time. The benefit of this technique is that it avoids
    performing inefficient operations at runtime at the expense of more complex code
    that could be difficult to comprehend. Expression templates are typically used
    to implement linear algebra libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18367_08_ePub.xhtml#_idTextAnchor179), Ranges and Algorithms'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Question 1**'
  prefs: []
  type: TYPE_NORMAL
- en: What are the sequence containers from the standard library?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: The sequence containers from the C++ standard library are `std::vector`, `std::deque`,
    `std::list`, `std::array`, and `std::forward_list`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 2**'
  prefs: []
  type: TYPE_NORMAL
- en: What are the common member functions defined in the standard containers?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: The member functions that are defined for most containers in the standard library
    are `size` (not present in `std::forward_list`), `empty`, `clear` (not present
    in `std::array`, `std::stack`, `std::queue`, and `std::priority_queue`), `swap`,
    `begin`, and `end`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 3**'
  prefs: []
  type: TYPE_NORMAL
- en: What are iterators and how many categories exist?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An iterator is an abstraction that enables us to access the elements of a container
    in a generic way, without having to know the implementation details of each container.
    Iterators are key for writing general-purpose algorithms. There are six categories
    of iterators in C++: input, forward, bidirectional, random-access, contiguous
    (as of C++17), and output.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 4**'
  prefs: []
  type: TYPE_NORMAL
- en: What operations does a random-access iterator support?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The random-access iterators must support the following operations (in addition
    to those required for input, forward, and bidirectional iterators): the `+` and
    `-` arithmetic operators, inequality comparison (with other iterators), compound
    assignment, and offset dereference operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 5**'
  prefs: []
  type: TYPE_NORMAL
- en: What are range access functions?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: Range access functions are non-member functions that provide a uniform way to
    access the data or properties of containers, arrays, and the `std::initializer_list`
    class. These functions include `std::size`/`std::ssize`, `std::empty`, `std::data`,
    `std::begin`, and `std::end`.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18367_09_ePub.xhtml#_idTextAnchor188), The Ranges Library'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Question 1**'
  prefs: []
  type: TYPE_NORMAL
- en: What is a range?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: A range is an abstraction for a sequence of elements, defined with a beginning
    and end iterator. The beginning iterator points to the first element in the sequence.
    The end iterator points to the one-past-last element of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 2**'
  prefs: []
  type: TYPE_NORMAL
- en: What is a view in the ranges library?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: A view in the C++ ranges library, also called a range adaptor, is an object
    that implements an algorithm that takes one or more ranges as input and perhaps
    other arguments and returns an adapted range. Views are lazy-evaluated, meaning
    they do not perform the adaptation until their elements are iterated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 3**'
  prefs: []
  type: TYPE_NORMAL
- en: What are constrained algorithms?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: Constrained algorithms are implementations of the existing standard library
    algorithms but in the C++20 ranges library. They are called constrained because
    their template arguments are constrained using C++20 concepts. In these algorithms,
    instead of requiring a begin-end pair of iterators for specifying, a range of
    values accepts a single range argument. However, overloads that accept an iterator-sentinel
    pair also exist.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 4**'
  prefs: []
  type: TYPE_NORMAL
- en: What is a sentinel?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: A sentinel is an abstraction for an end iterator. This makes it possible for
    the end iterator to have a different type than the range iterator. Sentinels cannot
    be dereferenced or incremented. Sentinels are useful when the test for the end
    of a range depends on some variable (dynamic) condition and you don’t know you
    are at the end of the range until something happens (for instance, a condition
    becomes false).
  prefs: []
  type: TYPE_NORMAL
- en: '**Question 5**'
  prefs: []
  type: TYPE_NORMAL
- en: How can you check that a sentinel type corresponds to an iterator type?
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer**'
  prefs: []
  type: TYPE_NORMAL
- en: You can check that a sentinel type can be used with an iterator type by using
    the `std::sentinel_for` concept from the `<iterator>` header.
  prefs: []
  type: TYPE_NORMAL
