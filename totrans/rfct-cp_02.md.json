["```cpp\nclass Message {\npublic:\n  Message(SenderId sender_id, ReceiverId receiver_id,\n          const RawData& data)\n    : sender_id_{sender_id},\n      receiver_id_{receiver_id}, raw_data_{data} {}\n  SenderId sender_id() const { return sender_id_; }\n  ReceiverId receiver_id() const { return receiver_id_; }\n  void save(const std::string& file_path) const {\n    // serializes a message to raw bytes and saves\n    // to file system\n  }\n  std::string serialize() const {\n    // serializes to JSON\n    return {\"JSON\"};\n  }\n  void send() const {\n    auto sender = Communication::get_instance();\n    sender.send(sender_id_, receiver_id_, serialize());\n  }\nprivate:\n  SenderId sender_id_;\n  ReceiverId receiver_id_;\n  RawData raw_data_;\n};\n```", "```cpp\nclass Message {\npublic:\n  Message(SenderId sender_id, ReceiverId receiver_id,\n          const RawData& data)\n    : sender_id_{sender_id},\n      receiver_id_{receiver_id}, raw_data_{data} {}\n  SenderId sender_id() const { return sender_id_; }\n  ReceiverId receiver_id() const { return receiver_id_; }\n  std::string serialize() const {\n    // serializes to JSON\n    return {\"JSON\"};\n  }\nprivate:\n  SenderId sender_id_;\n  ReceiverId receiver_id_;\n  RawData raw_data_;\n};\n```", "```cpp\nclass MessageSaver {\npublic:\n  MessageSaver(const std::string& target_directory);\n  void save(const Message& message) const;\n};\n```", "```cpp\nclass Message {\npublic:\n  Message(SenderId sender_id, ReceiverId receiver_id)\n    : sender_id_{sender_id}, receiver_id_{receiver_id} {}\n  SenderId sender_id() const { return sender_id_; }\n  ReceiverId receiver_id() const { return receiver_id_; }\n  virtual std::string serialize() const = 0;\nprivate:\n  SenderId sender_id_;\n  ReceiverId receiver_id_;\n};\n```", "```cpp\nclass StartMessage : public Message {\npublic:\n  StartMessage(SenderId sender_id, ReceiverId receiver_id,\n               std::chrono::milliseconds start_delay)\n    : Message{sender_id, receiver_id},\n      start_delay_{start_delay} {}\n  std::string serialize() const override {\n    return {\"naive serialization to JSON\"};\n  }\nprivate:\n  const std::chrono::milliseconds start_delay_;\n};\nclass StopMessage : public Message {\npublic:\n  StopMessage(SenderId sender_id, ReceiverId receiver_id,\n              std::chrono::milliseconds stop_delay)\n    : Message{sender_id, receiver_id},\n      stop_delay_{stop_delay} {}\n  std::string serialize() const override {\n    return {\"naive serialization to JSON\"};\n  }\nprivate:\n  const std::chrono::milliseconds stop_delay_;\n};\n```", "```cpp\nclass MessageSaver {\npublic:\n  virtual void save(const Message& message) const = 0;\n};\n```", "```cpp\nclass FilesystemMessageSaver : public MessageSaver {\npublic:\n  FilesystemMessageSaver(const std::string&\n    target_directory);\n  void save(const Message& message) const override;\n};\n```", "```cpp\nclass RemoteMessageSaver : public MessageSaver {\npublic:\n    RemoteMessageSaver(const std::string&\n      remote_storage_address);\n    void save(const Message& message) const override;\n};\n```", "```cpp\nclass InternalMessage : public Message {\npublic:\n    InternalMessage(SenderId sender_id, ReceiverId\n      receiver_id)\n        : Message{sender_id, receiver_id} {}\n    std::string serialize() const override {\n        throw std::runtime_error{\"InternalMessage can't be\n          serialized!\"};\n    }\n};\n```", "```cpp\nclass Message {\npublic:\n    virtual ~Message() = default;\n    // other common message behaviors\n};\nclass SerializableMessage : public Message {\npublic:\n    virtual std::string serialize() const = 0;\n};\nclass StartMessage : public SerializableMessage {\n    // ...\n};\nclass StopMessage : public SerializableMessage {\n    // ...\n};\nclass InternalMessage : public Message {\n    // InternalMessage doesn't have serialize method now.\n};\n```", "```cpp\nclass JsonMessageParser {\npublic:\n  virtual std::unique_ptr<Message>\n  parse(const std::vector<uint8_t>& message_pack)\n    const = 0;\n};\nclass MessagePackMessageParser {\npublic:\n  virtual std::unique_ptr<Message>\n  parse(const std::vector<uint8_t>& message_pack)\n    const = 0;\n};\n```", "```cpp\nclass MessageRouter {\npublic:\n  MessageRouter(ReceiverId id)\n    : id_{id} {}\n  void route(const Message& message) const {\n    if (message.receiver_id() == id_) {\n      handler_.handle(message);\n    } else {\n      try {\n        sender_.send(message);\n      } catch (const CommunicationError& e) {\n        saver_.save(message);\n      }\n    }\n  }\nprivate:\n  const ReceiverId id_;\n  const MessageHandler handler_;\n  const MessageSender sender_;\n  const MessageSaver saver_;\n};\n```", "```cpp\nclass BaseMessageHandler {\npublic:\n    virtual ~BaseMessageHandler() {}\n    virtual void handle(const Message& message) const = 0;\n};\nclass BaseMessageSender {\npublic:\n    virtual ~BaseMessageSender() {}\n    virtual void send(const Message& message) const = 0;\n};\nclass BaseMessageSaver {\npublic:\n    virtual ~BaseMessageSaver() {}\n    virtual void save(const Message& message) const = 0;\n};\nclass MessageRouter {\npublic:\n    MessageRouter(ReceiverId id,\n                  const BaseMessageHandler& handler,\n                  const BaseMessageSender& sender,\n                  const BaseMessageSaver& saver)\n        : id_{id}, handler_{handler}, sender_{sender},\n          saver_{saver} {}\n    void route(const Message& message) const {\n        if (message.receiver_id() == id_) {\n            handler_.handle(message);\n        } else {\n            try {\n                sender_.send(message);\n            } catch (const CommunicationError& e) {\n                saver_.save(message);\n            }\n        }\n    }\nprivate:\n    ReceiverId id_;\n    const BaseMessageHandler& handler_;\n    const BaseMessageSender& sender_;\n    const BaseMessageSaver& saver_;\n};\nint main() {\n  auto id      = ReceiverId{42};\n  auto handler = MessageHandler{};\n  auto sender = MessageSender{\n    Communication::get_instance()};\n  auto saver =\n    FilesystemMessageSaver{\"/tmp/undelivered_messages\"};\n  auto router = MessageRouter{id, sender, saver};\n}\n```", "```cpp\nstruct Data {\n  int val{42};\n};\nint main() {\n  const Data data;\n  data.val = 43; // assignment of member 'Data::val' in\n                 // read-only object\n  const int val{42};\n  val = 43; // assignment of read-only variable 'val'\n}\n```", "```cpp\nfor (const int i : array) {\n  std::cout << i << std::endl; // just reading: const\n}\nfor (int i : array) {\n  std::cout << i << std::endl; // just reading: non-const\n}\n```", "```cpp\nvoid foo(const int value);\n```", "```cpp\nclass Book {\npublic:\n  std::string name() { return name_; }\nprivate:\n  std::string name_;\n};\nvoid print(const Book& book) {\n  cout << book.name()\n       << endl; // ERROR: 'this' argument to member\n                // function\n                // 'name' has type 'const Book', but\n                // function is not marked\n                // const clang(member_function_call_bad_cvr)\n}\n```", "```cpp\nclass DataReader {\npublic:\n  Data read() const {\n    auto lock = std::lock_guard<std::mutex>(mutex);\n    // read data\n    return Data{};\n  }\nprivate:\n  mutable std::mutex mutex;\n};\n```", "```cpp\nvoid read_data(int* data); // Legacy code: read_data does\n                           // not modify `*data`\nvoid read_data(const int* data) {\n  read_data(const_cast<int*>(data));\n}\n```", "```cpp\nvoid foo(char* p);\nvoid bar(const char* p);\n```", "```cpp\nclass Config {\npublic:\n  std::string hostname() const;\n  uint16_t port() const;\n};\nint main(int argc, char* argv[]) {\n  const Config config = parse_args(argc, argv);\n  run(config);\n}\n```", "```cpp\nvoid a() {\n  auto value = int{42};\n  auto t = std::thread([&]() { std::cout << value; });\n  t.join();\n}\nvoid b() {\n  auto value = int{42};\n  auto t = std::thread([&value = std::as_const(value)]() {\n    std::cout << value;\n  });\n  t.join();\n}\nvoid c() {\n  const auto value = int{42};\n  auto t = std::thread([&]() {\n      auto v = const_cast<int&>(value);\n      std::cout << v;\n  });\n  t.join();\n}\nvoid d() {\n  const auto value = int{42};\n  auto t = std::thread([&]() { std::cout << value; });\n  t.join();\n}\n```", "```cpp\nstruct Point {\n  int x;\n  int y;\n};\nvoid foo() {\n  const auto point = Point{.x = 10, .y = 10};\n  auto t           = std::thread([&]() { std::cout <<\n    point.x; });\n  t.join();\n}\n```", "```cpp\nclass DataReader {\npublic:\n  Data read() const {\n    auto lock = std::lock_guard<std::mutex>(mutex);\n    // read data\n    return Data{};\n  }\nprivate:\n  mutable std::mutex mutex;\n};\n```", "```cpp\nclass RequestProcessor {\npublic:\n  Result process(uint64_t request_id,\n                 Request request) const {\n    if (auto it = cache_.find(request_id); it !=\n      cache_.cend()) {\n      return it->second;\n    }\n    // process request\n    // create result\n    auto result = Result{};\n    cache_[request_id] = result;\n    return result;\n  }\nprivate:\n  mutable std::unordered_map<uint64_t, Result> cache_;\n};\nvoid process_request() {\n  auto requests = std::vector<std::tuple<uint64_t,\n    Request>>{};\n  const auto processor = RequestProcessor{};\n  for (const auto& request : requests) {\n    auto t = std::thread([&]() {\n      processor.process(std::get<0>(request),\n                        std::get<1>(request));\n    });\n    t.detach();\n  }\n}\n```"]