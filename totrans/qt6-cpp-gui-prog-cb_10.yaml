- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: JSON Parsing Made Easy
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化 JSON 解析
- en: JSON is the file extension of a data format called **JavaScript Object Notation**,
    which is used to store and transport information in a structured format. The JSON
    format is used extensively for the web. Most modern web **Application Programming
    Interfaces** (**APIs**) use JSON format to transfer data to their web clients.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是一种名为 **JavaScript Object Notation** 的数据格式的文件扩展名，用于以结构化格式存储和传输信息。JSON 格式在网络上被广泛使用。大多数现代网络
    **应用程序编程接口** （**API**） 使用 JSON 格式将数据传输给其网络客户端。
- en: 'This chapter will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: JSON format in a nutshell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 格式概述
- en: Processing JSON data from a text file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文本文件处理 JSON 数据
- en: Writing JSON data to a text file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 JSON 数据写入文本文件
- en: Using Google’s Geocoding API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Google 的 Geocoding API
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter include Qt 6.6.1 MinGW 64-bit and
    Qt Creator 12.0.2\. All the code used in this chapter can be downloaded from the
    following GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter10](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter10).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括 Qt 6.6.1 MinGW 64 位和 Qt Creator 12.0.2。本章中使用的所有代码都可以从以下 GitHub 仓库下载：[https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter10](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter10)。
- en: JSON format in a nutshell
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON 格式概述
- en: JSON is a human-readable text format commonly used for data transmission in
    web applications, especially **JavaScript** applications. However, it is also
    used for many other purposes, hence it is independent of JavaScript and can be
    used for any programming language or platform, despite its name.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是一种常用于网络应用程序中数据传输的易读文本格式，尤其是在 **JavaScript** 应用程序中。然而，它也被用于许多其他目的，因此它独立于
    JavaScript，可以用于任何编程语言或平台，尽管它的名字如此。
- en: In this example, we will learn about JSON format and how to verify whether your
    JSON data is in a valid format or not.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将了解 JSON 格式以及如何验证您的 JSON 数据是否为有效格式。
- en: How to do it…
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let’s get started and learn how to write your own JSON data and verify its
    format:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习如何编写自己的 JSON 数据并验证其格式：
- en: Open up your web browser and go to the **JSONLint Online Validator and Formatter**
    website at [https://jsonlint.com](https://jsonlint.com).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的网络浏览器并转到 [https://jsonlint.com](https://jsonlint.com) 上的 **JSONLint Online
    Validator and Formatter** 网站。
- en: 'Write the following JSON data in the text editor on the website:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网站上的文本编辑器中编写以下 JSON 数据：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After that, press the **Validate JSON** button. You should get the following
    result:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，按下 **Validate JSON** 按钮。你应该会得到以下结果：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, try to remove the double quote symbols from the `members` variable:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试从 `members` 变量中移除双引号符号：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Press the **Validate JSON** button again and you should get an error like this:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按下 **Validate JSON** 按钮，你应该会得到一个如下错误：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, revert to the valid JSON format by adding the double quote symbols back
    to the `members` variable. Then, press the **Compress** button. You should get
    the following result, which has no empty space and next lines:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过将双引号符号添加回 `members` 变量来恢复有效的 JSON 格式。然后，按下 **Compress** 按钮。你应该会得到以下结果，其中没有空格和换行符：
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can now press the **Prettify** button to revert it to the previous structure.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以按下 **Prettify** 按钮将其恢复到之前的结构。
- en: How it works…
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The curly braces, `{` and `}`, contain a set of data as an object. An **object**
    is an individual data structure that contains its own properties or variables
    in the form of **key-value pairs**. Keys are unique strings that act as human-readable
    variable names, and values are represented by either a string, integer, floating-point
    number, Boolean, or even an entire object or array. JSON supports recursive objects,
    which is very handy for many different use cases.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号 `{` 和 `}` 包含一组数据作为对象。一个 **对象** 是一个包含其自身属性或变量的独立数据结构，这些属性或变量以 **键值对** 的形式存在。键是作为人类可读变量名的唯一字符串，而值由字符串、整数、浮点数、布尔值表示，甚至可以是一个完整的对象或数组。JSON
    支持递归对象，这对于许多不同的用例非常有用。
- en: The square brackets, `[` and `]`, indicate that the data is contained in an
    array. An **array** simply stores a list of values of the same type, which can
    be manipulated, sorted, or removed from the array by iterating over its content
    using a standard iterator pattern in any programming language you use for your
    project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号 `[` 和 `]` 表示数据包含在数组中。**数组**简单地存储相同类型的值列表，可以通过在您用于项目的任何编程语言中使用标准迭代器模式遍历其内容来操作、排序或从数组中删除。
- en: In the previous example, we first created a nameless object as the main object
    of the data. You must create either a main object or a main array as a starting
    point. Then, we added an array called `members`, which contains individual objects
    with variables such as `name`, `age`, and `gender`. Do note that if you add double
    quotes (`"`) around an integer or floating-point number, the variable will be
    treated as a string instead of a number.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们首先创建了一个无名的对象作为数据的主对象。你必须创建一个主对象或主数组作为起点。然后，我们添加了一个名为 `members` 的数组，其中包含具有
    `name`、`age` 和 `gender` 等变量的单个对象。请注意，如果你在整数或浮点数周围添加双引号 (`"`)，变量将被视为字符串而不是数字。
- en: The previous example demonstrated the simplest form of JSON data that can be
    sent through the network and processed by any modern programming language.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例演示了可以通过网络发送并由任何现代编程语言处理的 JSON 数据的最简单形式。
- en: Processing JSON data from a text file
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文本文件中的 JSON 数据
- en: In this recipe, we will learn how to process JSON data taken from a text file
    and extract it using the stream reader.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何处理从文本文件中获取的 JSON 数据并使用流读取器提取它。
- en: How to do it…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let’s create a simple program that reads and processes XML files by following
    these steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的程序，通过以下步骤读取和处理 XML 文件：
- en: Create a new **Qt Widgets Application** project at your desired location.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你希望的位置创建一个新的 **Qt Widgets 应用程序** 项目。
- en: 'Open any text editor and create a JSON file that looks like the following,
    then save it as `scene.json`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开任何文本编辑器并创建一个看起来像下面的 JSON 文件，然后将其保存为 `scene.json`：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Continue to write the JSON code by adding more objects after the `Library`
    object, as shown in the following code:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续编写 JSON 代码，在 `Library` 对象之后添加更多对象，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Go back to Qt Creator and open `mainwindow.h`. Add the following headers at
    the top of the script, right after `#``include <QMainWindow>`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Qt Creator 并打开 `mainwindow.h`。在脚本顶部 `#include <QMainWindow>` 之后添加以下头文件：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Open `mainwindow.ui` and drag a push button from the widget box on the left
    side to the UI editor. Change the object name of the button to `loadJsonButton`
    and its display text to `Load JSON`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.ui` 并从左侧的部件框中拖动一个按钮到 UI 编辑器。将按钮的对象名称更改为 `loadJsonButton` 并将其显示文本更改为
    `Load JSON`：
- en: '![Figure 10.1 – Adding the Load JSON push button](img/B20976_10_001.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 添加 Load JSON 按钮](img/B20976_10_001.jpg)'
- en: Figure 10.1 – Adding the Load JSON push button
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 添加 Load JSON 按钮图
- en: Right-click on the button and select **Go to slot…**. A window will pop up with
    a list of signals available for selection.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击按钮并选择 **转到槽…**。将弹出一个窗口，其中包含可供选择的信号列表。
- en: Choose the default `clicked()` option and press the `on_loadJsonButton_clicked()`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择默认的 `clicked()` 选项并按 `on_loadJsonButton_clicked()`。
- en: 'Add the following code to the `on_loadJsonButton_clicked()` function:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `on_loadJsonButton_clicked()` 函数中：
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We continue to write the code. The following code loops through the JSON file
    and prints out each attribute’s name and value:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续编写代码。以下代码遍历 JSON 文件并打印出每个属性的名称和值：
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Build and run the project and you will see a window pop up that looks like
    the one you made in *step 5*:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行项目，你将看到一个弹出窗口，其外观类似于你在 *步骤 5* 中创建的：
- en: '![Figure 10.2 – Building and launching the program](img/B20976_10_002.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 构建和启动程序](img/B20976_10_002.jpg)'
- en: Figure 10.2 – Building and launching the program
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 构建和启动程序
- en: 'Click on the **Load JSON** button and you should see the *file selector* window
    pop up on the screen. Select the JSON file you created in *step 2* and press the
    **Select** button. You should see the following debug text appear in the *Application
    Output* window in Qt Creator, which indicates that the program has successfully
    loaded the data from the JSON file you just selected:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **加载 JSON** 按钮，你应该会在屏幕上弹出 *文件选择器* 窗口。选择你在 *步骤 2* 中创建的 JSON 文件并按 **选择** 按钮。你应该会在
    Qt Creator 的 *应用程序输出* 窗口中看到以下调试文本出现，这表明程序已成功加载你刚刚选择的 JSON 文件中的数据：
- en: '![Figure 10.3 – The results printed in the Application Output window](img/B20976_10_003.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 应用输出窗口中打印的结果](img/B20976_10_003.jpg)'
- en: Figure 10.3 – The results printed in the Application Output window
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 应用输出窗口中打印的结果
- en: How it works…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this example, we’re trying to extract and process data from a JSON file using
    the `QJsonDocument` class. Imagine you’re making a computer game and you’re using
    JSON files to store the attributes of all the objects in your game scene. In this
    case, the JSON format plays an important role in storing the data in a structured
    way, which allows for easy extraction.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们正在尝试使用`QJsonDocument`类从JSON文件中提取和处理数据。想象一下你正在制作一个电脑游戏，你正在使用JSON文件来存储游戏场景中所有对象的属性。在这种情况下，JSON格式在以结构化方式存储数据方面发挥着重要作用，这使得数据提取变得容易。
- en: We need to add the header of the class related to JSON to our source file, which,
    in this case, is the `QJsonDocument` class. The `QJsonDocument` class is built
    into Qt’s core library, so there is no need to include any additional modules
    with it, which also means that it’s the recommended class to use to process JSON
    data in Qt. Once we click on the `on_loadJsonButton_clicked()` slot will be called;
    this is where we write the code to process the JSON data.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将相关的JSON类头添加到我们的源文件中，在这种情况下，是`QJsonDocument`类。`QJsonDocument`类是Qt核心库的一部分，因此不需要包含任何额外的模块，这也意味着它是推荐用于在Qt中处理JSON数据的类。一旦我们点击`on_loadJsonButton_clicked()`槽，就会调用；这就是我们编写代码来处理JSON数据的地方。
- en: We use a file dialog to select the JSON file we want to process. Then, we send
    the selected file’s filename, together with its path, to the `QFile` class to
    open and read the text data of the JSON file. After that, the file’s data is sent
    to the `QJsonDocument` class for processing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用文件对话框来选择我们想要处理的JSON文件。然后，我们将所选文件的文件名及其路径发送到`QFile`类以打开和读取JSON文件的文本数据。之后，文件的数据被发送到`QJsonDocument`类进行处理。
- en: We first check whether the main JSON structure is an array. If it is an array,
    we then check whether the array has any data in it. After that, use a `for` loop
    to read through the entire array and extract the individual objects stored in
    the array.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查主JSON结构是否为数组。如果是数组，我们接着检查数组中是否有数据。之后，使用`for`循环遍历整个数组，并提取存储在数组中的单个对象。
- en: Then, we extract the key-pair data from the objects and print out both the key
    and value.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从对象中提取键值对数据，并打印出键和值。
- en: There’s more…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Besides the web applications, many commercial game engines and interactive applications
    use the JSON format to store information for in-game scenes, meshes, and other
    forms of assets used in their products. This is because the JSON format provides
    many benefits over other file formats, such as compact file size, high flexibility
    and extendibility, easy file recovery, and a relational tree structure that allows
    it to be used for highly efficient and performance-critical applications, such
    as search engines, intelligent data mining servers, and scientific simulations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除了网络应用之外，许多商业游戏引擎和交互式应用也使用JSON格式来存储用于其产品中的游戏场景、网格以及其他形式资产的信息。这是因为JSON格式相较于其他文件格式提供了许多优势，例如紧凑的文件大小、高度的灵活性和可扩展性、易于文件恢复，以及允许其用于高度高效和性能关键的应用程序，如搜索引擎、智能数据挖掘服务器和科学模拟。
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about the XML format, visit [https://www.w3schools.com/js/js_json_intro.asp](https://www.w3schools.com/js/js_json_intro.asp).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于XML格式的信息，请访问[https://www.w3schools.com/js/js_json_intro.asp](https://www.w3schools.com/js/js_json_intro.asp)。
- en: Writing JSON data to a text file
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将JSON数据写入文本文件
- en: Since we have learned how to process data obtained from a JSON file in the previous
    recipe, we will move on to learning how to save data to a JSON file. We will continue
    with the previous example and add to it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在前一个菜谱中学习了如何处理从JSON文件中获得的数据，我们将继续学习如何将数据保存到JSON文件中。我们将继续使用前一个示例并对其进行扩展。
- en: How to do it…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will learn how to save data in a JSON file through the following steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下步骤学习如何在JSON文件中保存数据：
- en: 'Add another button to `mainwindow.ui`, then set its object name as `saveJsonButton`
    and its label as `Save JSON`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mainwindow.ui`中添加另一个按钮，然后将其对象名称设置为`saveJsonButton`，标签设置为`保存JSON`：
- en: '![Figure 10.4 – Adding the Save JSON button](img/B20976_10_004.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 添加保存JSON按钮](img/B20976_10_004.jpg)'
- en: Figure 10.4 – Adding the Save JSON button
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 添加保存JSON按钮
- en: 'Right-click on the button and select `clicked()` option and click `on_saveJsonButton_clicked()`
    will now be automatically added to both your `mainwindow.h` and `mainwindow.cpp`
    files by Qt:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击按钮并选择 `clicked()` 选项，然后点击 `on_saveJsonButton_clicked()` 将自动添加到你的 `mainwindow.h`
    和 `mainwindow.cpp` 文件中，由 Qt 完成：
- en: '![Figure 10.5 – Selecting the clicked() signal and pressing OK](img/B20976_10_005.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 选择 clicked() 信号并按 OK](img/B20976_10_005.jpg)'
- en: Figure 10.5 – Selecting the clicked() signal and pressing OK
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 选择 clicked() 信号并按 OK
- en: 'Add the following code to the `on_saveJsonButton_clicked()` function:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `on_saveJsonButton_clicked()` 函数中：
- en: '[PRE10]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s also write the first `contact` element:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也编写第一个 `contact` 元素：
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Write the second `contact` element as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式编写第二个 `contact` 元素：
- en: '[PRE12]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, save the data into the text file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将数据保存到文本文件中：
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Build and run the program and you should see an additional button on the program
    UI:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行程序，你应该在程序 UI 中看到额外的按钮：
- en: '![Figure 10.6 – Your application should now look like this](img/B20976_10_006.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 你的应用程序现在应该看起来像这样](img/B20976_10_006.jpg)'
- en: Figure 10.6 – Your application should now look like this
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 你的应用程序现在应该看起来像这样
- en: Click on the **Save JSON** button and a save file dialog will appear on the
    screen. Type the filename you require and click the **Save** button.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **保存 JSON** 按钮，屏幕上会出现一个保存文件对话框。输入所需的文件名，然后点击 **保存** 按钮。
- en: 'Open up the JSON file you just saved with any text editor. The first part of
    the file should look like this:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用任何文本编辑器打开你刚刚保存的 JSON 文件。文件的前一部分应该看起来像这样：
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The saving process is similar to loading a JSON file in the previous example.
    The only difference is instead of using the `QJsonDocument::fromJson()` function,
    we switched to using the `QJsonDocument::toJson()` function. We still used the
    file dialog and the `QFile` class to save the XML file. This time, we had to change
    the open mode from `QFile::ReadOnly` to `QFile::WriteOnly` before passing the
    byte array data to the `QFile` class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 保存过程与上一个示例中加载 JSON 文件的过程类似。唯一的区别是，我们不是使用 `QJsonDocument::fromJson()` 函数，而是切换到使用
    `QJsonDocument::toJson()` 函数。我们仍然使用了文件对话框和 `QFile` 类来保存 XML 文件。这次，在将字节数据传递给 `QFile`
    类之前，我们必须将打开模式从 `QFile::ReadOnly` 更改为 `QFile::WriteOnly`。
- en: Next, we started writing the JSON file by creating `QJsonDocument` and `QJsonArray`
    variables followed by creating a `QJsonObject` object for each contact. Then,
    we filled in the information for each contact and appended it to the `QJsonArray`
    array.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始编写 JSON 文件，通过创建 `QJsonDocument` 和 `QJsonArray` 变量，然后为每个联系人创建一个 `QJsonObject`
    对象。然后，我们填写每个联系人的信息，并将其追加到 `QJsonArray` 数组中。
- en: Finally, we used `QJsonDocument::setArray()` to apply the `QJsonArray` array
    we created previously as the main array of the JSON data before passing it to
    the `QFile` class as a byte array data using the `QJsonDocument::toJson()` function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `QJsonDocument::setArray()` 将我们之前创建的 `QJsonArray` 数组应用于 JSON 数据的主数组，在将其作为字节数据使用
    `QJsonDocument::toJson()` 函数传递给 `QFile` 类之前。
- en: Using Google’s Geocoding API
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Google 的 Geocoding API
- en: In this example, we will learn how to obtain the full address of a specific
    location by using Google’s Geocoding API.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将学习如何使用 Google 的 Geocoding API 通过地址获取特定位置的完整地址。
- en: How to do it…
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let’s create a program that utilizes the Geocoding API by following these steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建一个利用 Geocoding API 的程序：
- en: Create a new **Qt Widgets** **Application** project.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **Qt Widgets 应用程序** 项目。
- en: 'Open `mainwindow.ui` and add a couple of text labels, input fields, and a button
    to make your UI look similar to this:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.ui` 并添加几个文本标签、输入字段和一个按钮，使你的 UI 看起来类似于以下内容：
- en: '![Figure 10.7 – Setting up your UI](img/B20976_10_007.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 设置你的 UI](img/B20976_10_007.jpg)'
- en: Figure 10.7 – Setting up your UI
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 设置你的 UI
- en: 'Open your project (`.pro`) file and add the network module to your project.
    You can do that by simply adding the word `network` after `core` and `gui`, as
    shown in the following code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的项目（`.pro`）文件，并将网络模块添加到你的项目中。你可以通过在 `core` 和 `gui` 之后简单地添加单词 `network` 来做到这一点，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#include <QMainWindow>'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QMainWindow>`'
- en: '#include <QDebug>'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QDebug>`'
- en: '#include <QtNetwork/QNetworkAccessManager>'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QtNetwork/QNetworkAccessManager>`'
- en: '#include <QtNetwork/QNetworkReply>'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QtNetwork/QNetworkReply>`'
- en: '#include <QJsonDocument>'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QJsonDocument>`'
- en: '#include <QJsonArray>'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QJsonArray>`'
- en: '#include <QJsonObject>'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QJsonObject>`'
- en: '[PRE16]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Declare a slot function manually and call it `getAddressFinished()`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动声明一个槽函数并调用它 `getAddressFinished()`：
- en: '[PRE17]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Declare a `private` variable called `addressRequest`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `addressRequest` 的 `private` 变量：
- en: '[PRE18]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Open `mainwindow.ui` again, right-click on the `clicked()` option and press
    `mainwindow.h` and `mainwindow.cpp` source files.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开`mainwindow.ui`，在`clicked()`选项上右键单击，然后按`mainwindow.h`和`mainwindow.cpp`源文件。
- en: 'Open `mainwindow.cpp` and add the following code to the class constructor:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`mainwindow.cpp`，并将以下代码添加到类构造函数中：
- en: '[PRE19]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following code to the `getAddressFinished()` slot function we just
    declared manually:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到我们刚刚手动声明的`getAddressFinished()`槽函数中：
- en: '[PRE20]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Continue to get the first set of results from the JSON array to obtain the
    formatted address:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续从JSON数组中获取第一组结果以获取格式化地址：
- en: '[PRE21]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following code to the `clicked()` slot function created by Qt:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到Qt创建的`clicked()`槽函数中：
- en: '[PRE22]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Build and run the program and you should be able to obtain the address by inserting
    the **Longitude** and **Latitude** values and clicking the **Get** **Address**
    button:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行程序，你应该能够通过插入**经度**和**纬度**值并点击**获取** **地址**按钮来获取地址：
- en: '![Figure 10.8 – Inserting the coordinates and pressing the Get Address button](img/B20976_10_008.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 插入坐标并点击获取地址按钮](img/B20976_10_008.jpg)'
- en: Figure 10.8 – Inserting the coordinates and pressing the Get Address button
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 插入坐标并点击获取地址按钮
- en: 'Let’s try with a longitude of `-73.9780838` and a latitude of `40.6712957`.
    Click the **Get Address** button and you will see the following result in the
    application output window:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试使用经度为`-73.9780838`和纬度为`40.6712957`。点击**获取地址**按钮，你将在应用程序输出窗口中看到以下结果：
- en: '[PRE23]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: I won’t be able to tell you exactly how Google obtains the address from its
    backend system but I can teach you how to request data from Google by using `QNetworkRequest`.
    All you need to do is to set the URL of the network request to the URL I used
    in the previous source code and append both the latitude and longitude information
    to the URL.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能确切地告诉你Google是如何从其后端系统中获取地址的，但我可以教你如何使用`QNetworkRequest`请求Google的数据。你需要做的只是将网络请求的URL设置为我在前面的源代码中使用的URL，并将纬度和经度信息附加到URL上。
- en: 'After that, all we can do is wait for the response from the Google API server.
    We need to specify JSON as the desired format when sending the request to Google;
    otherwise, it may return the results in JSON format. This can be done by adding
    the `json` keyword within the network request URL, as highlighted here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们所能做的就是等待来自Google API服务器的响应。在向Google发送请求时，我们需要指定JSON作为期望的格式；否则，它可能会以JSON格式返回结果。这可以通过在网络请求URL中添加`json`关键字来实现，如下所示：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When the program receives the response from Google, the `getAddressFinished()`
    slot function will be called and we will be able to obtain the data sent by Google
    through `QNetworkReply`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序收到Google的响应时，`getAddressFinished()`槽函数将被调用，我们就能通过`QNetworkReply`获取Google发送的数据。
- en: Google usually replies with a long text in JSON format, which contains a ton
    of data we don’t need. All we need is the text stored in the `formatted_address`
    element in the JSON data. Since there is more than one element by the name of
    `formatted_address`, we just need to find the first one and ignore the rest. You
    can also do the reverse by providing an address to Google and obtaining the location’s
    coordinates from its network response.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Google通常以JSON格式回复一段长文本，其中包含我们不需要的大量数据。我们只需要JSON数据中存储在`formatted_address`元素中的文本。由于存在多个名为`formatted_address`的元素，我们只需找到第一个并忽略其余的。你也可以通过向Google提供一个地址，并从其网络响应中获取位置坐标来实现相反的操作。
- en: There’s more…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Google’s **Geocoding API** is part of the **Google Maps APIs** web services,
    which provide geographical data for your map applications. Besides the Geocoding
    API, you can also use their **Location API**, **Geolocation API**, and **Time
    Zone API** to achieve your desired results.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Google的**地理编码API**是**Google Maps APIs**网络服务的一部分，为你的地图应用程序提供地理数据。除了地理编码API之外，你还可以使用他们的**位置API**、**地理位置API**和**时区API**来实现你想要的结果。
- en: Note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information regarding the Google Maps APIs web services, visit [https://developers.google.com/maps/web-services](https://developers.google.com/maps/web-services).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Google Maps APIs网络服务的更多信息，请访问[https://developers.google.com/maps/web-services](https://developers.google.com/maps/web-services)。
