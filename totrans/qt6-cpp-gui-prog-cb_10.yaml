- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON Parsing Made Easy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON is the file extension of a data format called **JavaScript Object Notation**,
    which is used to store and transport information in a structured format. The JSON
    format is used extensively for the web. Most modern web **Application Programming
    Interfaces** (**APIs**) use JSON format to transfer data to their web clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: JSON format in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing JSON data from a text file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing JSON data to a text file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Google’s Geocoding API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter include Qt 6.6.1 MinGW 64-bit and
    Qt Creator 12.0.2\. All the code used in this chapter can be downloaded from the
    following GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter10](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: JSON format in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON is a human-readable text format commonly used for data transmission in
    web applications, especially **JavaScript** applications. However, it is also
    used for many other purposes, hence it is independent of JavaScript and can be
    used for any programming language or platform, despite its name.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will learn about JSON format and how to verify whether your
    JSON data is in a valid format or not.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started and learn how to write your own JSON data and verify its
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up your web browser and go to the **JSONLint Online Validator and Formatter**
    website at [https://jsonlint.com](https://jsonlint.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following JSON data in the text editor on the website:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, press the **Validate JSON** button. You should get the following
    result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, try to remove the double quote symbols from the `members` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Press the **Validate JSON** button again and you should get an error like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, revert to the valid JSON format by adding the double quote symbols back
    to the `members` variable. Then, press the **Compress** button. You should get
    the following result, which has no empty space and next lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can now press the **Prettify** button to revert it to the previous structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The curly braces, `{` and `}`, contain a set of data as an object. An **object**
    is an individual data structure that contains its own properties or variables
    in the form of **key-value pairs**. Keys are unique strings that act as human-readable
    variable names, and values are represented by either a string, integer, floating-point
    number, Boolean, or even an entire object or array. JSON supports recursive objects,
    which is very handy for many different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The square brackets, `[` and `]`, indicate that the data is contained in an
    array. An **array** simply stores a list of values of the same type, which can
    be manipulated, sorted, or removed from the array by iterating over its content
    using a standard iterator pattern in any programming language you use for your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we first created a nameless object as the main object
    of the data. You must create either a main object or a main array as a starting
    point. Then, we added an array called `members`, which contains individual objects
    with variables such as `name`, `age`, and `gender`. Do note that if you add double
    quotes (`"`) around an integer or floating-point number, the variable will be
    treated as a string instead of a number.
  prefs: []
  type: TYPE_NORMAL
- en: The previous example demonstrated the simplest form of JSON data that can be
    sent through the network and processed by any modern programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Processing JSON data from a text file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to process JSON data taken from a text file
    and extract it using the stream reader.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a simple program that reads and processes XML files by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Qt Widgets Application** project at your desired location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open any text editor and create a JSON file that looks like the following,
    then save it as `scene.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continue to write the JSON code by adding more objects after the `Library`
    object, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go back to Qt Creator and open `mainwindow.h`. Add the following headers at
    the top of the script, right after `#``include <QMainWindow>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `mainwindow.ui` and drag a push button from the widget box on the left
    side to the UI editor. Change the object name of the button to `loadJsonButton`
    and its display text to `Load JSON`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Adding the Load JSON push button](img/B20976_10_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Adding the Load JSON push button
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the button and select **Go to slot…**. A window will pop up with
    a list of signals available for selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the default `clicked()` option and press the `on_loadJsonButton_clicked()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `on_loadJsonButton_clicked()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We continue to write the code. The following code loops through the JSON file
    and prints out each attribute’s name and value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the project and you will see a window pop up that looks like
    the one you made in *step 5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Building and launching the program](img/B20976_10_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Building and launching the program
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Load JSON** button and you should see the *file selector* window
    pop up on the screen. Select the JSON file you created in *step 2* and press the
    **Select** button. You should see the following debug text appear in the *Application
    Output* window in Qt Creator, which indicates that the program has successfully
    loaded the data from the JSON file you just selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.3 – The results printed in the Application Output window](img/B20976_10_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – The results printed in the Application Output window
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we’re trying to extract and process data from a JSON file using
    the `QJsonDocument` class. Imagine you’re making a computer game and you’re using
    JSON files to store the attributes of all the objects in your game scene. In this
    case, the JSON format plays an important role in storing the data in a structured
    way, which allows for easy extraction.
  prefs: []
  type: TYPE_NORMAL
- en: We need to add the header of the class related to JSON to our source file, which,
    in this case, is the `QJsonDocument` class. The `QJsonDocument` class is built
    into Qt’s core library, so there is no need to include any additional modules
    with it, which also means that it’s the recommended class to use to process JSON
    data in Qt. Once we click on the `on_loadJsonButton_clicked()` slot will be called;
    this is where we write the code to process the JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: We use a file dialog to select the JSON file we want to process. Then, we send
    the selected file’s filename, together with its path, to the `QFile` class to
    open and read the text data of the JSON file. After that, the file’s data is sent
    to the `QJsonDocument` class for processing.
  prefs: []
  type: TYPE_NORMAL
- en: We first check whether the main JSON structure is an array. If it is an array,
    we then check whether the array has any data in it. After that, use a `for` loop
    to read through the entire array and extract the individual objects stored in
    the array.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we extract the key-pair data from the objects and print out both the key
    and value.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the web applications, many commercial game engines and interactive applications
    use the JSON format to store information for in-game scenes, meshes, and other
    forms of assets used in their products. This is because the JSON format provides
    many benefits over other file formats, such as compact file size, high flexibility
    and extendibility, easy file recovery, and a relational tree structure that allows
    it to be used for highly efficient and performance-critical applications, such
    as search engines, intelligent data mining servers, and scientific simulations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the XML format, visit [https://www.w3schools.com/js/js_json_intro.asp](https://www.w3schools.com/js/js_json_intro.asp).
  prefs: []
  type: TYPE_NORMAL
- en: Writing JSON data to a text file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have learned how to process data obtained from a JSON file in the previous
    recipe, we will move on to learning how to save data to a JSON file. We will continue
    with the previous example and add to it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will learn how to save data in a JSON file through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another button to `mainwindow.ui`, then set its object name as `saveJsonButton`
    and its label as `Save JSON`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Adding the Save JSON button](img/B20976_10_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Adding the Save JSON button
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the button and select `clicked()` option and click `on_saveJsonButton_clicked()`
    will now be automatically added to both your `mainwindow.h` and `mainwindow.cpp`
    files by Qt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Selecting the clicked() signal and pressing OK](img/B20976_10_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Selecting the clicked() signal and pressing OK
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `on_saveJsonButton_clicked()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s also write the first `contact` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the second `contact` element as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, save the data into the text file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the program and you should see an additional button on the program
    UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Your application should now look like this](img/B20976_10_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Your application should now look like this
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Save JSON** button and a save file dialog will appear on the
    screen. Type the filename you require and click the **Save** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up the JSON file you just saved with any text editor. The first part of
    the file should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The saving process is similar to loading a JSON file in the previous example.
    The only difference is instead of using the `QJsonDocument::fromJson()` function,
    we switched to using the `QJsonDocument::toJson()` function. We still used the
    file dialog and the `QFile` class to save the XML file. This time, we had to change
    the open mode from `QFile::ReadOnly` to `QFile::WriteOnly` before passing the
    byte array data to the `QFile` class.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we started writing the JSON file by creating `QJsonDocument` and `QJsonArray`
    variables followed by creating a `QJsonObject` object for each contact. Then,
    we filled in the information for each contact and appended it to the `QJsonArray`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used `QJsonDocument::setArray()` to apply the `QJsonArray` array
    we created previously as the main array of the JSON data before passing it to
    the `QFile` class as a byte array data using the `QJsonDocument::toJson()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using Google’s Geocoding API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to obtain the full address of a specific
    location by using Google’s Geocoding API.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a program that utilizes the Geocoding API by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Qt Widgets** **Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `mainwindow.ui` and add a couple of text labels, input fields, and a button
    to make your UI look similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Setting up your UI](img/B20976_10_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Setting up your UI
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your project (`.pro`) file and add the network module to your project.
    You can do that by simply adding the word `network` after `core` and `gui`, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '#include <QMainWindow>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <QDebug>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <QtNetwork/QNetworkAccessManager>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <QtNetwork/QNetworkReply>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <QJsonDocument>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <QJsonArray>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <QJsonObject>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a slot function manually and call it `getAddressFinished()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `private` variable called `addressRequest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `mainwindow.ui` again, right-click on the `clicked()` option and press
    `mainwindow.h` and `mainwindow.cpp` source files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `mainwindow.cpp` and add the following code to the class constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the `getAddressFinished()` slot function we just
    declared manually:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continue to get the first set of results from the JSON array to obtain the
    formatted address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the `clicked()` slot function created by Qt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the program and you should be able to obtain the address by inserting
    the **Longitude** and **Latitude** values and clicking the **Get** **Address**
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Inserting the coordinates and pressing the Get Address button](img/B20976_10_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Inserting the coordinates and pressing the Get Address button
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try with a longitude of `-73.9780838` and a latitude of `40.6712957`.
    Click the **Get Address** button and you will see the following result in the
    application output window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I won’t be able to tell you exactly how Google obtains the address from its
    backend system but I can teach you how to request data from Google by using `QNetworkRequest`.
    All you need to do is to set the URL of the network request to the URL I used
    in the previous source code and append both the latitude and longitude information
    to the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, all we can do is wait for the response from the Google API server.
    We need to specify JSON as the desired format when sending the request to Google;
    otherwise, it may return the results in JSON format. This can be done by adding
    the `json` keyword within the network request URL, as highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When the program receives the response from Google, the `getAddressFinished()`
    slot function will be called and we will be able to obtain the data sent by Google
    through `QNetworkReply`.
  prefs: []
  type: TYPE_NORMAL
- en: Google usually replies with a long text in JSON format, which contains a ton
    of data we don’t need. All we need is the text stored in the `formatted_address`
    element in the JSON data. Since there is more than one element by the name of
    `formatted_address`, we just need to find the first one and ignore the rest. You
    can also do the reverse by providing an address to Google and obtaining the location’s
    coordinates from its network response.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google’s **Geocoding API** is part of the **Google Maps APIs** web services,
    which provide geographical data for your map applications. Besides the Geocoding
    API, you can also use their **Location API**, **Geolocation API**, and **Time
    Zone API** to achieve your desired results.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information regarding the Google Maps APIs web services, visit [https://developers.google.com/maps/web-services](https://developers.google.com/maps/web-services).
  prefs: []
  type: TYPE_NORMAL
