- en: '18'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type Traits and Policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers compile-time type information (type traits) and modular,
    policy-based design in C++. It will showcase how they empower metaprogramming
    and foster versatile code design when working with the C++ **Standard Template
    Library** (**STL**) data types and algorithms. It also discusses policies, presenting
    a strategy to customize the behavior in templated code without altering core logic.
    Through real-world examples, hands-on implementation techniques, and best practices,
    you will harness the potential of these powerful C++ tools with the STL, creating
    adaptable and optimized software components.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and using type traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing type traits with the STL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and using policies in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using policies with the STL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and using type traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing generic code in C++, there’s often a need to gather information
    about types without knowing the specifics of those types in advance. Enter **type
    traits**—a toolkit for querying and manipulating type information at compile time.
    Think of them as inspectors that report on the characteristics of types, allowing
    you to make informed decisions in your code based on those reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++’s STL provides a rich collection of type traits in the `<type_traits>`
    header. These traits can answer questions such as: Is a particular type a pointer?
    An integer? Is it arithmetic? Can it be default-constructed? For instance, `std::is_integral<T>::value`
    will return `true` if `T` is an integral type or `false` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing code adaptability with type traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type traits aren’t just a means of introspection; they’re enablers of adaptability.
    By understanding the properties of types, you can design algorithms and data structures
    that adjust their behavior accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a generic function that must operate differently for pointers and non-pointer
    types. With the help of `std::is_pointer<T>::value`, you can conditionally execute
    code paths using `if constexpr` statements, tailoring the behavior at compile
    time. This creates cleaner and more intuitive code and results in optimal performance,
    as the unnecessary code paths are pruned away during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Another everyday use case is optimizing storage in generic containers. For instance,
    if a type is trivially destructible (without custom destruction logic), you can
    safely skip calling its destructor, leading to performance gains. Here, `std::is_trivially_destructible<T>::value`
    comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: Empowering metaprogramming with type traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Metaprogramming**, the act of writing code that generates or manipulates
    other code, is a hallmark of advanced C++ programming. Type traits are invaluable
    tools in this area, enabling richer and more expressive compile-time computations.'
  prefs: []
  type: TYPE_NORMAL
- en: A classic metaprogramming problem is factorial calculation at compile time.
    While this can be achieved through template recursion, the real challenge is to
    halt the recursion for non-integer types. This is where `std::is_integral<T>::value`
    proves its worth, ensuring that the computation only progresses for valid types.
  prefs: []
  type: TYPE_NORMAL
- en: Another powerful facet is using type traits with `static_assert` to enforce
    constraints. If you’re writing a template function that should only accept arithmetic
    types, a simple static assertion with `std::is_arithmetic<T>::value` can ensure
    the code won’t compile for unsuitable types, providing clear and immediate feedback
    to the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Toward more informed and adaptable code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you master type traits, remember these tools are not just about querying
    type properties. They leverage that knowledge to craft more robust, adaptable,
    and efficient code. Whether you aim for ultimate performance, cleaner interfaces,
    or just the satisfaction of metaprogramming mastery, type traits are ready to
    assist.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we’ll further explore how type traits synergize with
    policies and, more importantly, how to craft your own type traits and policies,
    tailoring them to fit the unique demands of your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing type traits with the STL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Utilizing type traits with STL data types and algorithms is a powerful technique
    that enhances the efficiency and correctness of C++ programming. When applied
    to STL data types, type traits enable a deeper understanding of the characteristics
    of these types, such as their size, alignment, or whether they are fundamental
    types. This insight can significantly optimize data storage and access patterns,
    leading to better memory management and performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of STL algorithms, type traits are instrumental in selecting
    the most appropriate algorithm or optimizing its behavior based on the properties
    of the types involved. For example, knowing whether a type supports certain operations
    can allow algorithms to bypass unnecessary checks or use more efficient techniques.
    This boosts performance and ensures that algorithms with various types behave
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Applying type traits in STL data types and algorithms is essential to advanced
    C++ programming, enabling developers to write more efficient, robust, and adaptable
    code. Let’s begin to discover the full potential of type traits in the context
    of the STL’s data types and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Working with data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understanding and utilizing type traits is important for writing robust and
    adaptable code. Type traits, a part of the STL, allow programmers to query and
    interact with types at compile time, fostering type safety and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Type traits offer the compile-time introspection of types, enabling programmers
    to write generic and type-safe code. They are particularly useful in template
    metaprogramming, where operations depend on type properties. By leveraging type
    traits, developers can ascertain type properties, such as whether a type is an
    integer, floating-point, or whether it supports certain operations. We can also
    tailor code behavior based on type characteristics without incurring runtime costs
    or use them to write more straightforward, more maintainable code that automatically
    adapts to different types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a scenario where we need a function template to process numerical
    data, but the processing differs for integer and floating-point types. Using type
    traits, we can create a specialized behavior for each type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `std::is_integral_v` and `std::is_floating_point_v` are type
    traits that assess whether `T` is an integer or floating-point type, respectively.
    The `if constexpr` construct enables compile-time decision-making, ensuring that
    only the relevant code block for the type `T` is compiled. This approach makes
    the code type safe and optimizes performance by avoiding unnecessary checks at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing type traits with STL data types enhances code reliability, efficiency,
    and maintainability. Next, let’s explore more advanced uses of type traits, such
    as how they can be combined with other template techniques to build sophisticated,
    type-aware algorithms and data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Working with algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to their indispensable role in crafting adaptable code and enabling
    metaprogramming, type traits also play a crucial role in conjunction with STL
    algorithms. This synergy between type traits and algorithms empowers us to write
    highly versatile and type-aware code.
  prefs: []
  type: TYPE_NORMAL
- en: Type traits for algorithm customization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: STL algorithms often operate on generic data structures, ranging from sorting
    to searching. The ability to customize the behavior of these algorithms based
    on the properties of the elements they process is essential for writing efficient
    and flexible code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `std::sort` algorithm, which can sort elements in a container.
    By employing type traits, we can make it more versatile. For instance, you may
    want to sort elements in descending order for types that support it (e.g., integers)
    while leaving the order unchanged for others. Using `std::is_integral<T>::value`,
    you can conditionally pass a custom comparison function to `std::sort`, tailoring
    the sorting behavior to the type being sorted as the following code illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This approach demonstrates how type traits can lead to more efficient code by
    eliminating unnecessary conditionals at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring algorithm compatibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider an algorithm that processes a collection of objects to demonstrate
    the power of type traits with user-defined types. This algorithm requires that
    the objects provide a specific interface, for instance, a `serialize` method for
    converting the object state to a string. By employing type traits, we can ensure
    that the algorithm is only used with types that conform to this requirement at
    compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `has_serialize` is a custom type trait that checks for the
    existence of a `serialize` method. The `processCollection` function template uses
    this trait to enforce that it is only used with types that provide this method.
    The `static_assert` generates a clear compile-time error message if an incompatible
    type is used.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can create more robust and self-documenting code by enforcing algorithm
    compatibility with custom types using type traits. This approach ensures that
    constraints are clearly defined and checked at compile time, preventing runtime
    errors and leading to more predictable and reliable software.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing algorithms for specific types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Efficiency is a critical concern in algorithm design. Type traits can help optimize
    algorithms for specific types by choosing the most efficient implementation based
    on type properties.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider an algorithm that calculates the sum of elements in a
    container. If the element type is integral, you can use a more efficient integer-based
    accumulator, while for floating-point types, you may prefer a floating-point accumulator.
    Type traits such as `std::is_integral<T>::value` can guide your choice of accumulator
    type, resulting in more efficient calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Type traits combined with STL algorithms enable you to create type-aware and
    efficient code. You can take full advantage of the STL while crafting robust and
    high-performance C++ applications by customizing algorithm behavior, ensuring
    compatibility, and optimizing for specific types.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and using policies in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Policy-based design is a design paradigm in C++ that emphasizes modularity and
    flexibility without sacrificing performance. It revolves around decomposing a
    software component’s behavior into interchangeable policies. These policies dictate
    how specific actions are executed. By choosing different policies, the behavior
    of a component can be modified without changing its fundamental logic.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits with respect to the STL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of the STL, a policy-based design is particularly relevant. The
    STL is inherently generic and designed to meet a broad spectrum of programming
    needs. Implementing policies can significantly enhance its versatility, allowing
    for precise customization to specific use cases. For example, the container memory
    allocation strategy can be defined as a policy. Whether employing the standard
    allocator, a pool allocator, or a custom stack-based allocator, you can simply
    insert the desired policy, and the container adjusts without modifying its primary
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, policies can be tailored for performance in particular contexts. A
    sorting algorithm could utilize varied comparison strategies depending on the
    data type. Rather than drafting multiple iterations of the algorithm, one can
    design a single version and replace the comparison policy as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a C++ code example demonstrating this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have two comparison policies: `NumericComparison` for numeric
    types and `StringComparison` for strings. The `sortWithPolicy` function is a template
    that takes a comparison policy as an argument, allowing the same sorting function
    to be used with different data types and comparison strategies. The numeric data
    is sorted in ascending order, while the strings are sorted based on their length,
    demonstrating the flexibility of using policies to tailor sorting behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Building modular components using policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider designing a templated data structure, such as a hash table. Policies
    can dictate multiple elements of this hash table: the hashing technique, the collision
    resolution method, or the memory allocation approach. By segregating these as
    individual, switchable policies, the hash table can be fine-tuned to specific
    requirements without altering its core functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: This modularity also encourages code reusability. A well-crafted policy can
    be applied across various components, ensuring code consistency and easier maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Potential challenges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While policy-based design offers numerous advantages, it presents particular
    challenges. One of the primary concerns is guaranteeing policy compatibility with
    the main component logic. Although a component might be structured to accommodate
    diverse policies, each must conform to a predetermined interface or standard.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation also emerges as a challenge. Given the increased flexibility that
    policies provide, it’s essential to meticulously document the expected behaviors,
    interfaces, and each policy’s implications, enabling users to make knowledgeable
    choices.
  prefs: []
  type: TYPE_NORMAL
- en: The role of policies in modern C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As C++ progresses, the shift toward more generic and adaptable components becomes
    evident. Policy-based design is pivotal in this evolution, enabling developers
    to devise components prioritizing modularity and performance. Gaining proficiency
    in this design approach will empower you to produce software that not only endures
    but also efficiently adapts to changing needs.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we’ll examine the practical aspects of implementing
    type traits and policies, laying a robust groundwork for their practical application
    in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Using policies with the STL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In exploring policy-based design, we’ve established how this design paradigm
    fosters modularity and flexibility in C++ software components. Now, let’s get
    into the specifics of how policies can be effectively employed to enhance the
    functionality and adaptability of STL data types, contributing to more efficient
    and customized solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most pertinent applications of policies in the context of STL data
    types is the management of memory allocation. Consider a scenario where you must
    optimize memory allocation for a specific container, such as a `std::vector` instance.
    By introducing memory allocation policies, you can tailor the container’s memory
    management strategy to your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you may have a specialized memory allocator optimized for your
    application’s specific use case. Instead of modifying the container’s internal
    logic, you can seamlessly integrate this custom allocator as a policy. This way,
    the `std::vector` instance can efficiently use your custom allocator without requiring
    fundamental code changes, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This template class accepts a type `T` and an allocator policy, defaulted to
    `std::allocator<T>`. The critical point is that such a design allows for seamless
    integration of custom memory allocation strategies without altering the fundamental
    code structure of the container.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting policies for versatile algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: STL algorithms, including sorting algorithms, often work with various data types.
    Policies offer an elegant solution when different comparison strategies are needed
    for sorting. Rather than creating multiple sorting algorithm versions, you can
    design a single algorithm and introduce a comparison policy as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the example of a sorting algorithm. Using a comparison policy, you
    can sort elements differently based on the data type. This approach streamlines
    your code base and avoids code duplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This example showcases a templated `customSort` function, demonstrating how
    a default comparison policy can be overridden to tailor the sorting behavior for
    different data types. This approach exemplifies a powerful strategy for creating
    versatile, maintainable, and efficient sorting algorithms within the STL framework,
    showcasing the benefits of policy-based design in C++ programming.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuning data structures with policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing custom data structures that mimic STL containers, you can leverage
    policies to fine-tune their behavior. Imagine building a hash table. Policies
    can govern critical aspects such as the hashing technique, collision resolution
    method, or memory allocation approach.
  prefs: []
  type: TYPE_NORMAL
- en: By isolating these functionalities as individual, interchangeable policies,
    you create a hash table that can be adapted to specific use cases without altering
    its core logic. This modular approach simplifies maintenance, as you can adjust
    individual policies as needed, keeping the rest of the structure intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how custom hash tables can be tailored for enhanced
    interaction with STL types and algorithms through policy-based design. This approach
    allows the behavior of the hash table (such as the hashing mechanism, collision
    resolution strategy, or memory management) to be defined by policies, making the
    data structure flexible and adaptable to different use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`DefaultHashPolicy` and `SeparateChainingPolicy` are default policies for hashing
    and collision resolution in this example. The `CustomHashTable` template class
    can be instantiated with different policies as required, making it highly versatile
    and compatible with various STL types and algorithms. This policy-based design
    enables fine-grained control over the behavior and characteristics of the hash
    table.'
  prefs: []
  type: TYPE_NORMAL
- en: Policies in C++ offer a powerful toolset to enhance the adaptability and performance
    of STL data types. Whether it’s optimizing memory allocation, customizing sorting
    strategies, or tailoring data structures to specific needs, policies enable us
    to modularly extend the capabilities of the STL components while maintaining code
    consistency and reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered the intricacies of type traits and policies
    within the context of the C++ STL. We began by examining type traits, which serve
    as a toolkit for compile-time type inspection, allowing us to make decisions in
    our code based on type characteristics. Through exploring various type traits
    provided in the `<type_traits>` header, we learned how to determine whether a
    type is a pointer, an integer, arithmetic, default-constructible, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we investigated how type traits enhance code adaptability, enabling us
    to tailor the behavior of our algorithms and data structures. We saw firsthand
    how traits such as `std::is_pointer` and `std::is_trivially_destructible` can
    optimize performance by informing our code to behave differently based on type
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: We then transitioned to policies, exploring their role in enabling modularity
    and flexibility in design without compromising performance. We recognized the
    benefits of policy-based design in STL applications, such as customizing memory
    allocation and sorting strategies. The modularity of policy-based components was
    highlighted as a means for fine-tuning behavior and encouraging code reusability.
  prefs: []
  type: TYPE_NORMAL
- en: The utility of this chapter lies in its potential to enhance our coding practices.
    We can write more robust, adaptable, and efficient code using type traits. At
    the same time, policies allow us to construct flexible, modular components tailored
    to various requirements without fundamental changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [*Chapter 19*](B21945_19.xhtml#_idTextAnchor679), *Exception
    Safety*, we will build upon the knowledge acquired here by learning about the
    guarantees provided by the STL regarding exceptions. We will start by understanding
    the basics of exception safety, focusing on the pivotal role of program invariants
    and resource integrity in robust software design. We will examine strong exception
    safety, exploring how to build STL containers that offer unwavering guarantees.
    Finally, we’ll discuss the impact of `noexcept` on STL operations, further preparing
    us to write reliable and efficient C++ code that stands resilient in the face
    of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 5: STL Data Structures and Algorithms: Under the Hood'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We conclude our exploration of STL data structures and algorithms by getting
    into some of its more advanced usage patterns. We will venture beyond the surface
    into the mechanics and guarantees that enable robust, concurrent C++ applications.
    We will start by discovering exception safety, detailing the levels of guarantees
    provided by STL components and strategies for writing exception-safe code with
    an emphasis on the impact of noexcept.
  prefs: []
  type: TYPE_NORMAL
- en: We then venture into areas of thread safety and concurrency, dissecting the
    delicate balance between concurrent execution and the thread safety of STL containers
    and algorithms. We will gain actionable insights on race conditions, the prudent
    use of mutexes and locks, and the thread-safe application of STL containers, highlighting
    specific concerns and detailed insights into their behaviors in multithreaded
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will introduce the interaction of STL with modern C++ features like
    concepts and coroutines, showcasing how these features refine template usage and
    enable asynchronous programming with STL.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will dive into parallel algorithms, discussing the incorporation
    of execution policies, the impact of constexpr, and performance considerations
    when employing parallelism in STL. This part of the book equips readers with the
    advanced knowledge to exploit the full potential of the STL in concurrent and
    parallel environments, ensuring their code is efficient, safe, and modern.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 19*](B21945_19.xhtml#_idTextAnchor679)*: Exception Safety*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 20*](B21945_20.xhtml#_idTextAnchor696)*: Thread Safety and Concurrency
    with the STL*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 21*](B21945_21.xhtml#_idTextAnchor745)*: STL Interaction with Concepts
    and Coroutines*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 22*](B21945_22.xhtml#_idTextAnchor762)*: Parallel Algorithms with
    the STL*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
