- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Applying the Adapter Pattern
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用适配器模式
- en: This chapter will extend our quest to expand your C++ programming skills beyond
    core OOP concepts, with the goal of enabling you to solve recurring types of coding
    problems utilizing common design patterns. Incorporating design patterns in coding
    solutions can not only provide elegant solutions but also enhance code maintenance
    and provide potential opportunities for code reuse.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将扩展我们的探索，旨在将你的C++编程技能扩展到核心面向对象概念之外，目标是使你能够利用常见设计模式解决重复出现的编程问题。在编码解决方案中采用设计模式不仅可以提供优雅的解决方案，还可以提高代码维护性，并提供代码重用的潜在机会。
- en: The next core design pattern that we will learn how to implement effectively
    in C++ is the **Adapter pattern**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将学习如何在C++中有效地实现下一个核心设计模式——**适配器模式**。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding the Adapter pattern and how it contributes to OOP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解适配器模式及其对面向对象编程（OOP）的贡献
- en: Understanding how to implement the Adapter pattern in C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何在C++中实现适配器模式
- en: By the end of this chapter, you will understand the essential Adapter pattern
    and how it can be used to either allow two incompatible classes to communicate
    or to upgrade unseemly code to well-designed OO code. Adding another key design
    pattern to your knowledge set will refine your programming skills to help make
    you a more valuable programmer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将理解基本的适配器模式以及如何使用它来允许两个不兼容的类进行通信，或者将不合适的代码升级为良好的面向对象代码。将另一个关键设计模式添加到你的知识库中，将提高你的编程技能，帮助你成为一个更有价值的程序员。
- en: Let’s increase our programming skillset by examining another common design pattern,
    the Adapter pattern.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过研究另一个常见的设计模式——适配器模式，来增加我们的编程技能集。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter18](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter18).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter18` in a file named `Chp18-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下GitHub URL中可以找到完整程序示例的在线代码：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter18](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter18)。每个完整程序示例都可以在GitHub仓库中找到，位于相应章节标题（子目录）下的文件中，该文件以章节编号开头，后面跟着一个连字符，然后是当前章节中的示例编号。例如，本章的第一个完整程序可以在上述GitHub目录下的`Chapter18`子目录中的名为`Chp18-Ex1.cpp`的文件中找到。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3Kaxckc](https://bit.ly/3Kaxckc).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下链接查看：[https://bit.ly/3Kaxckc](https://bit.ly/3Kaxckc)。
- en: Understanding the Adapter pattern
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解适配器模式
- en: The **Adapter pattern** is a structural design pattern that provides a means
    for converting an existing, undesirable interface of a class to an interface that
    another class expects. An **Adapter class** will be the link for communication
    between two existing components, adapting the interfaces so that the two may share
    and exchange information. An Adapter allows two or more classes to work together
    that otherwise could not do so.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**适配器模式**是一种结构型设计模式，它提供了一种将现有类的不理想接口转换为另一个类期望的接口的方法。**适配器类**将是两个现有组件之间通信的链接，通过适配接口使得这两个组件可以共享和交换信息。适配器允许两个或更多类协同工作，否则它们无法这样做。'
- en: Ideally, an Adapter will not add functionality but will add the preferred interface
    for usage (or conversion) to either allow one class to be used in an expected
    manner or for two otherwise incompatible classes to communicate with one another.
    In its most simple form, an Adapter simply converts an existing class to support
    an expected interface as may be specified in an OO design.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，适配器不会添加功能，而是添加使用（或转换）的首选接口，以便允许一个类以预期的方式使用，或者使两个原本不兼容的类能够相互通信。在其最简单的形式中，适配器只是将现有的类转换为支持预期的接口，正如在面向对象设计中可能指定的那样。
- en: An Adapter can be either associated with or derived from the class for which
    it is providing an adaptive interface. If inheritance is used, a private or protected
    base class is appropriate to hide the underlying implementation. If instead, the
    Adapter class is associated with the class having the undesirable interface, the
    methods in the Adapter class (with the new interfaces) will merely delegate the
    work to its associated class.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器可以与它提供适配接口的类相关联或从该类派生。如果使用继承，则适当的私有或受保护的基类可以隐藏底层实现。如果相反，适配器类与具有不理想接口的类相关联，适配器类中的方法（具有新接口）将仅将工作委托给其关联的类。
- en: The Adapter pattern can also be used to add an OO interface to (that is, to
    *wrap an OO interface around*) a series of functions or other classes, allowing
    assorted existing components to be utilized more naturally in an OO system. This
    specific type of Adapter is known as a `extern C`, to allow the linker to resolve
    linkage conventions between the two languages).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式还可以用来给一系列函数或其他类添加面向对象（OO）接口（即，在周围包裹一个OO接口），使得各种现有组件在面向对象系统中更自然地被利用。这种特定的适配器类型被称为
    `extern C`，以便链接器解决两种语言之间的链接约定）。
- en: Utilizing the Adapter pattern has benefits. The Adapter allows the reuse of
    existing code by providing a shared interface to allow otherwise unrelated classes
    to communicate. The OO programmer will now use the Adapter class directly, allowing
    for easier maintenance of the application. That is, most programmer interaction
    will be with a well-designed Adapter class, rather than with two or more odd components.
    A small drawback of using an Adapter is a slightly decreased performance from
    the added layer of code. However, most often, reusing existing components through
    providing a clean interface to support their interaction is a winning proposition,
    despite a (hopefully small) performance trade-off.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 利用适配器模式有好处。适配器通过提供一个共享接口，允许原本不相关的类进行通信，从而允许重用现有代码。现在面向对象的程序员将直接使用适配器类，这有助于应用程序的维护。也就是说，大多数程序员的交互将是一个设计良好的适配器类，而不是与两个或更多奇特的组件交互。使用适配器的一个小缺点是，由于增加了代码层，性能略有下降。然而，通常情况下，通过提供一个干净的接口来支持现有组件的交互，以重用现有组件，这是一个有利可图的方案，尽管可能会有（希望是小的）性能权衡。
- en: 'The Adapter pattern will include the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式将包括以下内容：
- en: An **Adaptee** class, which represents the class with desirable utilities, yet
    which exists in a form that is not suitable or as expected.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **Adaptee** 类，它代表了具有理想实用工具的类，但它的存在形式不适合或不理想。
- en: An **Adapter** class, which adapts the interface of the Adaptee class to meet
    the needs of the desired interface.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **Adapter** 类，它将 Adaptee 类的接口适配以满足所需接口的需求。
- en: A **Target** class, which represents the specific, desired interface of the
    application at hand. A class may be both a Target and an Adapter.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **Target** 类，它代表了当前应用程序的具体、所需的接口。一个类可能既是 Target 也是 Adapter。
- en: Optional **Client** classes, which will interact with the Target class to fully
    define the application at hand.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的 **Client** 类，它们将与 Target 类交互，以完全定义当前的应用程序。
- en: An Adapter pattern allows the reuse of qualified, existing components that do
    not meet the interface needs of current application designs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式允许重用符合当前应用程序设计接口需求的现有合格组件。
- en: Let’s move forward to see two common applications of the Adapter pattern; one
    will have two potential means for implementation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，看看适配器模式的两种常见应用；其中一种将有两种潜在的实现方式。
- en: Implementing the Adapter pattern
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现适配器模式
- en: Let’s explore two common uses of the Adapter pattern. That is, creating an Adapter
    to bridge the gap between two incompatible class interfaces or building an Adapter
    to simply wrap an existing set of functions with an OO interface.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索适配器模式（Adapter pattern）的两种常见用法。那就是创建一个适配器来弥合两个不兼容的类接口之间的差距，或者创建一个适配器来简单地用面向对象（OO）接口包装现有的函数集。
- en: We will start with the usage of an *Adapter* providing a connector between two
    (or more) incompatible classes. The *Adaptee* will be a well-tested class that
    we would like to reuse (but which has an undesirable interface), and the *Target*
    classes will be those specified in our OO design for an application in the making.
    Let’s now specify an Adapter to allow our Adaptee to work with our Target classes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从使用一个提供两个（或更多）不兼容类之间连接器的适配器（*Adapter*）的用法开始。*Adaptee* 将是一个经过良好测试的类，我们希望重用它（但它的接口可能不理想），而*Target*
    类将是我们在正在制作的应用程序中的OO设计所指定的。现在让我们指定一个适配器，以便我们的 Adaptee 能够与我们的 Target 类一起工作。
- en: Using an Adapter to provide a necessary interface to an existing class
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用适配器为现有类提供必要的接口
- en: To implement the Adapter pattern, we will first need to identify our Adaptee
    class. We will then create an Adapter class to modify the interface of the Adaptee.
    We will also identify our Target class, representing the class we need to model
    per our OO design. At times, our Adapter and Target may be rolled into a single
    class. In an actual application, we will additionally have Client classes, representing
    the full complement of classes found in the final application at hand. Let’s start
    with the Adaptee and Adapter classes, as these class definitions will begin the
    foundation on which to build our pattern.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现适配器模式，我们首先需要确定我们的Adaptee类。然后我们将创建一个适配器类来修改Adaptee的接口。我们还将确定我们的Target类，代表我们需要根据OO设计进行建模的类。有时，适配器和目标可能会合并成一个类。在实际应用中，我们还将有Client类，代表最终应用中发现的完整类集。让我们从Adaptee和Adapter类开始，因为这些类定义将是我们构建模式的基础。
- en: In our example, we will specify our Adaptee class as one we are accustomed to
    seeing – `Person`. We will imagine that our planet has recently become aware of
    many other exoplanets capable of supporting life and that we have benevolently
    made allies with each such civilization. Further imagining that the various software
    systems on Earth would like to welcome and include our new friends, including
    `Romulans` and `Orkans`, we would like to adapt some of our existing software
    to easily accommodate the new demographics of our exoplanet neighbors. With that
    in mind, we will transform our `Person` class to include more interplanetary terminology
    by creating an Adapter class, `Humanoid`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的例子中，我们将指定我们的Adaptee类为我们习惯看到的类——`Person`。我们将设想我们的星球最近意识到了许多其他能够支持生命的系外行星，并且我们已经善意地与每个这样的文明结盟。进一步设想地球上的各种软件系统都希望欢迎并包括我们的新朋友，包括`Romulans`和`Orkans`，我们希望调整一些现有的软件以轻松适应我们系外行星邻居的新人口结构。考虑到这一点，我们将通过创建一个适配器类`Humanoid`来将我们的`Person`类转换为包含更多星际术语。 '
- en: In our forthcoming implementation, we will use private inheritance to inherit
    `Humanoid` (Adapter) from `Person` (Adaptee), therefore hiding the underlying
    implementation of the Adaptee. We could have alternatively associated a `Humanoid`
    with a `Person` (an implementation we will also review in this section). We can
    then flesh out some derived classes of `Humanoid` within our hierarchy, such as
    `Orkan`, `Romulan`, and `Earthling`, to accommodate the intergalactic application
    at hand. The `Orkan`, `Romulan`, and `Earthling` classes can be considered our
    Target classes, or those that our application will instantiate. We will choose
    to make our Adapter class, `Humanoid`, abstract so that it is not directly instantiable.
    Because our specific derived classes (Target classes) can be generalized by their
    abstract base class type (`Humanoid`) in our application (Client), we can also
    consider `Humanoid` a Target class. That is, `Humanoid` can be viewed primarily
    as an Adapter, but secondarily as a generalized Target class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们即将到来的实现中，我们将使用私有继承从`Person`（Adaptee）继承`Humanoid`（Adapter），因此隐藏了Adaptee的底层实现。我们还可以将一个`Humanoid`与一个`Person`关联（我们将在本节中回顾这种实现）。然后我们可以在我们的层次结构中充实一些`Humanoid`的派生类，例如`Orkan`、`Romulan`和`Earthling`，以适应手头的星际应用。`Orkan`、`Romulan`和`Earthling`类可以被视为我们的Target类，或者是我们应用将要实例化的类。我们将选择使我们的适配器类`Humanoid`抽象，这样它就不能直接实例化。因为我们的特定派生类（目标类）可以通过我们的应用（Client）中的抽象基类类型（`Humanoid`）进行泛化，我们也可以将`Humanoid`视为一个目标类。也就是说，`Humanoid`主要被视为一个适配器，但次要地被视为一个泛化的目标类。
- en: Our various Client classes can utilize derived classes of `Humanoid`, making
    instances of each of its concrete descendants. These instances may be stored in
    their own specialized type or genericized using `Humanoid` pointers. Our implementation
    is a modern take on the well-used Adapter design pattern.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的各个Client类可以利用`Humanoid`的派生类，创建其具体后代的实例。这些实例可以存储在自己的专用类型中，或者使用`Humanoid`指针进行泛化。我们的实现是对广泛使用的适配器设计模式的一种现代诠释。
- en: Specifying the Adaptee and Adapter (private inheritance technique)
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定Adaptee和Adapter（私有继承技术）
- en: 'Let’s take a look at the mechanics of the first usage of our Adapter pattern,
    beginning by reviewing the definition for our Adaptee class, `Person`. This example
    can be found, as a complete program, in our GitHub repository:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们适配器模式第一次使用时的机制，首先回顾一下我们的Adaptee类`Person`的定义。这个例子可以作为完整的程序在我们的GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex1.cpp)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous class definition, we notice that our `Person` class definition
    is as we have been accustomed to seeing it in many other examples throughout this
    book. This class is instantiable; however, `Person` is not an appropriate class
    to instantiate in our intergalactic application. Instead, the expected interface
    would be to utilize that found in `Humanoid`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类定义中，我们注意到我们的 `Person` 类定义与我们在这本书的许多其他示例中看到的一样。这个类是可以实例化的；然而，在我们的星际应用程序中，`Person`
    并不是一个合适的类来实例化。相反，预期的接口应该是使用 `Humanoid` 中的接口。
- en: 'With that in mind, let’s take a look at our Adapter class, `Humanoid`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，让我们来看看我们的适配器类 `Humanoid`：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the aforementioned `Humanoid` class, our goal is to provide an Adapter to
    contribute to the expected interface that our intergalactic application requires.
    We simply derive `Humanoid` from `Person` using private inheritance, hiding the
    public interfaces found in `Person` from use outside the scope of `Humanoid`.
    We understand that the target application (Client) would not wish for the public
    interfaces found in `Person` to be utilized by various subtypes of `Humanoid`
    instances. Notice that we are not adding functionality, only adapting the interface.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述 `Humanoid` 类中，我们的目标是提供一个适配器，以贡献我们星际应用程序所需的预期接口。我们简单地使用私有继承从 `Person` 派生
    `Humanoid`，隐藏了 `Person` 中发现的公共接口，使其在 `Humanoid` 的作用域之外不被使用。我们理解目标应用程序（客户端）不希望
    `Person` 中的公共接口被 `Humanoid` 实例的各种子类型所利用。请注意，我们不是添加功能，只是在适配接口。
- en: We then notice the public methods introduced in `Humanoid` that provide the
    desired interfaces for the Target class(es). The implementation of these interfaces
    is often straightforward. We simply call the inherited method defined in `Person`,
    which will easily complete the task at hand (but which uses an unacceptable interface
    to do so). For example, our `Humanoid::GetPrimaryName()` method simply calls `Person::GetLastName();`
    to complete the task. However, `GetPrimaryName()` may more so represent appropriate
    intergalactic lingo than `Person::GetLastName()`. We can see how `Humanoid` is
    serving as an Adapter for `Person`. We can also see how most of the member functions
    of the Adapter class, `Humanoid`, use inline functions to simply wrap the `Person`
    methods with more suitable interfaces while adding no overhead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着注意到 `Humanoid` 中引入的公共方法，为目标类（们）提供了所需的接口。这些接口的实现通常是直接的。我们只需调用在 `Person` 中定义的继承方法，就可以轻松完成当前任务（但这样做使用的是不可接受的接口）。例如，我们的
    `Humanoid::GetPrimaryName()` 方法简单地调用 `Person::GetLastName();` 来完成任务。然而，`GetPrimaryName()`
    可能更多地代表了适当的星际语言，而不是 `Person::GetLastName()`。我们可以看到 `Humanoid` 如何作为 `Person` 的适配器。我们还可以看到适配器类
    `Humanoid` 的大多数成员函数如何使用内联函数简单地封装 `Person` 方法，以提供更合适的接口，同时不增加任何开销。
- en: Note that it is not necessary to precede the calls to `Person` base class methods
    within Humanoid methods with `Person::` (except when a `Humanoid` method calls
    the same named method in `Person`, such as with `GetTitle()`). The scope resolution
    usage of `Person::` avoids potential recursion in these situations.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 Humanoid 方法中对 `Person` 基类方法的调用前不需要使用 `Person::`（除非 `Humanoid` 方法调用 `Person`
    中相同名称的方法，例如 `GetTitle()`）。使用 `Person::` 的作用域解析避免了这些情况中的潜在递归。
- en: We also notice that `Humanoid` introduces an abstract polymorphic method (that
    is, a pure virtual function) with the specification of `virtual const string &Converse()
    = 0;`. We have made the design decision that only derived classes of `Humanoid`
    will be instantiable. Nonetheless, we understand that public descendant classes
    may still be collected by their base class type of `Humanoid`. Here, `Humanoid`
    serves primarily as the Adapter class and secondarily as a Target class offering
    the suite of acceptable interfaces.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到，`Humanoid` 引入了一个抽象的多态方法（即纯虚函数），其指定为 `virtual const string &Converse()
    = 0;`。我们已经做出了设计决定，只有 `Humanoid` 的派生类才能被实例化。尽管如此，我们理解公共派生类仍然可以被其基类类型 `Humanoid`
    收集。在这里，`Humanoid` 主要作为适配器类，次要作为提供一系列可接受接口的目标类。
- en: Notice that our pure virtual function `virtual const String &Converse() = 0;`
    includes a default implementation. This is rare but allowed, so long as the implementation
    is not written inline. Here, we utilize the opportunity to specify a default behavior
    for `Humanoid::Converse()`, by simply calling `Person::Speak()`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的纯虚函数`virtual const String &Converse() = 0;`包含了一个默认实现。这种情况很少见，但允许这样做，只要实现不是内联编写的。在这里，我们利用这个机会为`Humanoid::Converse()`指定一个默认行为，只需简单地调用`Person::Speak()`。
- en: Deriving concrete classes from the Adapter
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从适配器派生具体类
- en: 'Next, let’s extend our Adapter (`Humanoid`) and take a look at one of our concrete,
    derived Target classes, `Orkan`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们扩展我们的适配器（`Humanoid`）并查看我们的一个具体派生目标类`Orkan`：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our aforementioned `Orkan` class, we use public inheritance to derive `Orkan`
    from `Humanoid`. An `Orkan` *Is-A* `Humanoid`. As such, all of the public interfaces
    in `Humanoid` are available to `Orkan` instances. Notice that our alternate constructor
    sets the default greeting message to `"Nanu nanu"`, per the `Orkan` dialect.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面提到的`Orkan`类中，我们使用公有继承从`Humanoid`派生`Orkan`。一个`Orkan` *是* 一个`Humanoid`。因此，`Humanoid`中的所有公共接口都对`Orkan`实例可用。注意，我们的备用构造函数将默认问候信息设置为`"Nanu
    nanu"`，按照`Orkan`方言。
- en: Because we wish `Orkan` to be a concrete, instantiable class, we must override
    `Humanoid::Converse()` and provide an implementation in the `Orkan` class. Notice,
    however, that `Orkan::Converse()` simply calls `Humanoid::Converse();`. Perhaps
    `Orkan` finds the default implementation in its base class acceptable. Notice
    that we use the `Humanoid::` scope resolution to qualify `Converse()` within the
    `Orkan::Converse()` method to avoid recursion.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望`Orkan`成为一个具体可实例化的类，我们必须在`Orkan`类中重写`Humanoid::Converse()`并提供实现。然而，请注意，`Orkan::Converse()`只是调用`Humanoid::Converse();`。也许`Orkan`认为其基类中的默认实现是可以接受的。注意，我们使用`Humanoid::`作用域解析符在`Orkan::Converse()`方法中限定`Converse()`，以避免递归。
- en: Interestingly, had `Humanoid` not been an abstract class, `Orkan` would not
    have had to override `Converse()` – the default behavior would have automatically
    been inherited. Yet, with `Humanoid` defined as abstract, the override of `Converse()`
    is necessary within `Orkan`, otherwise, `Orkan` will also be also viewed as an
    abstract class. No worries! We can utilize the benefit of the default behavior
    of `Humanoid::Converse()` merely by calling it within `Orkan::Converse()`. This
    will satisfy the requirements for making `Orkan` concrete, while allowing `Humanoid`
    to remain abstract, while still providing the rare default behavior for `Converse()`!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果`Humanoid`不是一个抽象类，`Orkan`就不需要重写`Converse()`方法——默认行为会自动继承。然而，由于`Humanoid`被定义为抽象类，`Orkan`中必须重写`Converse()`方法，否则`Orkan`也会被视为一个抽象类。不用担心！我们只需在`Orkan::Converse()`中调用`Humanoid::Converse()`，就可以利用`Humanoid::Converse()`的默认行为的好处。这将满足使`Orkan`具体化的要求，同时允许`Humanoid`保持抽象状态，同时仍然为`Converse()`提供罕见的默认行为！
- en: 'Now, let’s take a look at our next concrete Target class, `Romulan`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下我们的下一个具体目标类`Romulan`：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Taking a comparably quick look at the aforementioned `Romulan` class, we notice
    that this concrete Target is similar to its sibling class, `Orkan`. We notice
    that the default message for the greeting passed up to our base class constructor
    is `"jolan'tru"` to reflect `Romulan` dialect. Though we could have made our implementation
    of `Romulan::Converse()` more intricate, we chose not to do so. We can quickly
    understand the full scope of this class.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 快速看一下前面提到的`Romulan`类，我们会注意到这个具体的目标类与它的兄弟类`Orkan`相似。我们会注意到传递给基类构造函数的默认问候信息是`"jolan'tru"`，以反映`Romulan`方言。尽管我们可以使我们的`Romulan::Converse()`实现更加复杂，但我们选择不这样做。我们可以快速理解这个类的全部范围。
- en: 'Next, let’s take a look at our third Target class, `Earthling`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下我们的第三个目标类`Earthling`：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Again, taking another comparably quick look at the aforementioned `Earthling`
    class, we notice that this concrete Target is similar to its sibling classes,
    `Orkan` and `Romulan`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，快速看一下前面提到的`Earthling`类，我们会注意到这个具体的目标类与它的兄弟类`Orkan`和`Romulan`相似。
- en: Now that we have defined our Adaptee, Adapter, and multiple Target classes,
    let’s bring the pieces together by examining the Client portion of our program.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的适配器、适配器和多个目标类，让我们通过检查程序的客户端部分来将这些组件组合在一起。
- en: Bringing the pattern components together
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将模式组件组合在一起
- en: Finally, let us consider what a sample Client may look like in our overall application.
    Certainly, it may consist of many files with a variety of classes. In its simplest
    form, as shown next, our Client will contain a `main()` function to drive the
    application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑一下在我们的整体应用程序中一个示例客户端可能的样子。当然，它可能由许多具有各种类的文件组成。在其最简单的形式中，如以下所示，我们的客户端将包含一个`main()`函数来驱动应用程序。
- en: 'Let’s now take a look at our `main()` function to see how our pattern is orchestrated:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们的`main()`函数，看看我们的模式是如何编排的：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Reviewing our aforementioned `main()` function, we first create an STL `list`
    of `Humanoid` pointers with `list<Humanoid *> allies;`. We then instantiate an
    `Orkan`, `Romulan`, and an `Earthling` and add each to the list using `allies.push_back()`.
    Again, using the Standard Template Library, we next create a list iterator to
    walk through the list of pointers to `Humanoid` instances. As we iterate through
    our generalized list of allies, we call the approved interfaces of `GetInfo()`
    and `Converse()` on each item in our list (that is, for each specific type of
    `Humanoid`).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们之前提到的`main()`函数，我们首先使用`list<Humanoid *>`创建一个STL列表，名为`allies;`。然后我们实例化一个`Orkan`、`Romulan`和一个`Earthling`，并使用`allies.push_back()`将它们每个都添加到列表中。再次使用标准模板库，我们接下来创建一个列表迭代器来遍历指向`Humanoid`实例的指针列表。当我们遍历我们的通用盟友列表时，我们在列表中的每个项目上调用`GetInfo()`和`Converse()`的批准接口（即，对于每种特定的`Humanoid`类型）。
- en: Next, we specify one specific `Humanoid`, an `Earthling`, and change this instance’s
    default greeting by invoking `e1->SetSalutation("Bonjour");`. By calling `Converse()`
    again on this instance (we first did so on this object generically in the aforementioned
    loop), we can request that the `Earthling` use `"Bonjour"` to greet allies instead
    of `"Hello"` (the default greeting for `Earthling`).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指定一个特定的`Humanoid`，一个`Earthling`，并通过调用`e1->SetSalutation("Bonjour");`来更改这个实例的默认问候语。通过再次在这个实例上调用`Converse()`（我们首先在上面的循环中泛型地这样做），我们可以要求`Earthling`使用`"Bonjour"`来问候盟友，而不是使用默认的问候语`"Hello"`（`Earthling`的默认问候语）。
- en: 'Let’s take a look at the output for this program:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序的输出：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the aforementioned output, notice that the planetary specification for each
    `Humanoid` is displayed (`Orkan`, `Romulan`, and `Earthling`), followed by their
    secondary and primary names. Then, the appropriate greeting is displayed for the
    particular `Humanoid`. Notice that `Earthling` `Eve Xu` first converses using
    `"Hello"` and then later converses using `"Bonjour"`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，请注意，每个`Humanoid`的行星规范都显示了出来（`Orkan`、`Romulan`和`Earthling`），然后是它们的次要和主要名称。然后，显示特定`Humanoid`的适当问候语。请注意，`Earthling`
    `Eve Xu`首先使用`"Hello"`进行对话，然后后来使用`"Bonjour"`进行对话。
- en: An advantage of the preceding implementation (using a private base class to
    derive Adapter from Adaptee) is that the coding is very straightforward. With
    this approach, any protected methods in the Adaptee class can easily be carried
    down to be used within the scope of the Adapter methods. We will soon see that
    protected members will be an issue should we instead use the association as a
    means of connecting the Adapter to Adaptee.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之前实现（使用私有基类从Adaptee派生Adapter）的一个优点是代码非常直接。使用这种方法，Adaptee类中的任何受保护的方法都可以轻松地传递到Adapter方法的作用域内。我们很快就会看到，如果我们将关联用作将Adapter连接到Adaptee的手段，受保护成员将是一个问题。
- en: A disadvantage of the prior mentioned approach is that it is a C++ specific
    implementation. Other languages do not support private base classes. Alternatively,
    using a public base class to define the relationship between Adapter and Adaptee
    would fail to conceal the unwanted Adaptee interface, and would be a very poor
    design choice.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的方法的一个缺点是它是一个C++特定的实现。其他语言不支持私有基类。另外，使用公有基类来定义Adapter和Adaptee之间的关系将无法隐藏不想要的Adaptee接口，这将是一个非常糟糕的设计选择。
- en: Considering an alternate specification of Adaptee and Adapter (association)
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑Adaptee和Adapter（关联）的另一种规范
- en: Let us now briefly consider a slightly revised version of the aforementioned
    Adapter pattern implementation. We will instead use an association to model the
    relationship between the Adaptee and Adapter. The concrete derived classes (Targets)
    will still be derived from the Adapter as before.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在简要考虑一下之前提到的Adapter模式实现的略微修改版本。我们将使用关联来模拟Adaptee和Adapter之间的关系。具体的派生类（目标）仍然会像之前一样从Adapter派生。
- en: 'Here is an alternative implementation of our Adapter class, `Humanoid`, using
    an association between Adapter and Adaptee. Though we will only review the portion
    of the code that differs from our initial approach, the full implementation can
    be found as a complete program in our GitHub repository:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的 Adapter 类 `Humanoid` 的另一种实现，使用 Adapter 和 Adaptee 之间的关联。尽管我们只会审查与我们的初始方法不同的代码部分，但完整的实现可以在我们的
    GitHub 仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex2.cpp)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex2.cpp)'
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice in the aforementioned implementation of our Adapter class, `Humanoid`
    is no longer derived from `Person`. Instead, `Humanoid` will add a private data
    member `Person *life;`, which will represent an association between the Adapter
    (`Humanoid`) and the Adaptee (`Person`). In our Humanoid constructors, we will
    need to allocate the underlying implementation of the Adaptee (`Person`). We will
    also need to delete the Adaptee (`Person`) in our destructor.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述 Adapter 类的实现中，`Humanoid` 已不再从 `Person` 派生。相反，`Humanoid` 将添加一个私有数据成员 `Person
    *life;`，它将代表 Adapter (`Humanoid`) 和 Adaptee (`Person`) 之间的关联。在我们的 Humanoid 构造函数中，我们需要分配
    Adaptee (`Person`) 的底层实现。我们还需要在我们的析构函数中删除 Adaptee (`Person`)。
- en: Similar to our last implementation, `Humanoid` offers the same member functions
    within its public interface. However, notice that each `Humanoid` method delegates,
    through the associated object, a call to the appropriate Adaptee methods. For
    example, `Humanoid::GetSecondaryName()` merely calls `life->GetFirstName();` to
    delegate the request (versus calling the inherited, corresponding Adaptee methods).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们上一次的实现类似，`Humanoid` 在其公共接口中提供了相同的成员函数。然而，请注意，每个 `Humanoid` 方法都通过关联对象将调用委托给适当的
    Adaptee 方法。例如，`Humanoid::GetSecondaryName()` 仅调用 `life->GetFirstName();` 来委托请求（而不是调用继承的相应
    Adaptee 方法）。
- en: As in our initial implementation, our derived classes from `Humanoid` (`Orkan`,
    `Romulan`, and `Earthling`) are specified in the same fashion, as is our Client
    within our `main()` function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们最初的实现一样，我们的从 `Humanoid` 派生的类（`Orkan`、`Romulan` 和 `Earthling`）以相同的方式指定，同样，我们的
    `main()` 函数中的客户端也是这样。
- en: Choosing the relationship between Adaptee and Adapter
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择 Adaptee 和 Adapter 之间的关系
- en: An interesting point to consider when choosing between private inheritance or
    association as the relationship between Adapter and Adaptee is whether or not
    the Adaptee contains any protected members. Recall that the original code for
    `Person` included a protected `ModifyTitle()` method. Should protected members
    exist in the Adaptee class? The private base class implementation allows those
    inherited, protected members to continue to be accessed within the scope of the
    Adapter class (that is, by methods of the Adapter). However, using the association-based
    implementation, the protected methods in the Adaptee (`Person`) are unusable in
    the scope of the Adapter. To make this example work, we were required to move
    `Person::ModifyTitle()` to the public access region. However, modifying the Adaptee
    class is not always possible, nor is it necessarily recommended. Considering the
    protected member issue, our initial implementation using a private base class
    is the stronger implementation, as it does not depend on us modifying the class
    definition of the Adaptee (`Person`).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择私有继承或关联作为 Adapter 和 Adaptee 之间的关系时，一个值得考虑的有趣点是 Adaptee 是否包含任何受保护的成员。回想一下，`Person`
    的原始代码包括一个受保护的 `ModifyTitle()` 方法。Adaptee 类中应该存在受保护的成员吗？私有基类实现允许那些继承的受保护成员在 Adapter
    类的作用域内继续被访问（即通过 Adapter 的方法）。然而，使用基于关联的实现，Adaptee (`Person`) 中的受保护方法在 Adapter
    的作用域内不可用。为了使这个例子工作，我们需要将 `Person::ModifyTitle()` 移到公共访问区域。然而，修改 Adaptee 类并不总是可能的，也不一定是推荐的。考虑到受保护成员的问题，我们最初使用私有基类的实现是更强的实现，因为它不依赖于我们修改
    Adaptee (`Person`) 的类定义。
- en: Let us now take a brief look at an alternate usage of the Adapter pattern. We
    will simply be using an Adapter class as a wrapper class. We will add an OO interface
    to an otherwise loosely arranged set of functions that work well, but lack the
    desired interface our application (Client) desires.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要地看一下适配器模式的一种替代用法。我们只是将适配器类用作包装类。我们将向一个原本松散排列但工作良好的函数集添加面向对象的接口，但这些函数缺少我们应用程序（客户端）所需的目标接口。
- en: Using an Adapter as a wrapper
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用适配器作为包装器
- en: As an alternative usage of the Adapter pattern, we will wrap an OO interface
    around a grouping of related external functions. That is, we will create a wrapper
    class to encapsulate these functions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为适配器模式的一种替代用法，我们将围绕一组相关的外部函数包装一个面向对象（OO）接口。也就是说，我们将创建一个包装类来封装这些函数。
- en: In our example, the external functions will represent a suite of existing database
    access functions. We will assume that the core database functionality is well
    tested for our data type (`Person`) and has been used problem-free. However, these
    external functions by themselves present an undesirable and unexpected functional
    interface.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，外部函数将代表一组现有的数据库访问函数。我们假设核心数据库功能已经针对我们的数据类型（`Person`）进行了良好的测试，并且没有问题地使用过。然而，这些外部函数本身提供了一个不理想且意外的功能接口。
- en: We will instead wrap the external functions by creating an Adapter class to
    encapsulate their collective functionality. Our Adapter class will be `CitizenDataBase`,
    representing an encapsulated means for reading and writing `Person` instances
    from and to a database. Our existing external functions will provide the implementation
    for our `CitizenDataBase` member functions. Let us assume that the OO interfaces,
    as defined in our Adapter class, meet the requirements of our OO design.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个适配器类来封装这些外部函数的功能。我们的适配器类将是`CitizenDataBase`，代表一种封装的从数据库读取和写入`Person`实例的方法。我们现有的外部函数将为我们的`CitizenDataBase`成员函数提供实现。让我们假设在适配器类中定义的面向对象接口符合我们的面向对象设计要求。
- en: 'Let’s take a look at the mechanics of our simple wrapper Adapter pattern, beginning
    by examining external functions providing the database access functionality. This
    example can be found, as a complete program, in our GitHub repository:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们简单包装适配器模式的机制，首先从检查提供数据库访问功能的外部函数开始。这个例子作为完整的程序可以在我们的GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex3.cpp)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex3.cpp)'
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In our previously defined external functions, let’s assume all functions are
    well tested and allow `Person` instances to be read from or written to a database.
    To support this simulation, we have created an external `Person` instance with
    `Person objectRead;` to provide a brief, non-stack located storage place for a
    newly read instance (used by `db_read()`) until the newly read instance is captured
    as a return value. Keep in mind that the existing external functions do not represent
    an encapsulated solution.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前定义的外部函数中，让我们假设所有函数都经过了良好的测试，并允许从数据库中读取或写入`Person`实例。为了支持这种模拟，我们创建了一个外部`Person`实例`Person
    objectRead;`，为刚读取的实例提供一个简短的、非堆栈位置的存储空间（由`db_read()`使用），直到新读取的实例被捕获为返回值。请注意，现有的外部函数并不代表一个封装的解决方案。
- en: 'Now, let’s create a simple wrapper class to encapsulate these external functions.
    The wrapper class, `CitizensDataBase`, will represent our Adapter class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的包装类来封装这些外部函数。这个包装类，`CitizensDataBase`，将代表我们的适配器类：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In our aforementioned class definition for our Adapter class, we simply encapsulate
    the external database functionality within the `CitizenDataBase` class. Here,
    `CitizenDataBase` is not only our Adapter class but also our Target class, as
    it contains the interfaces our application at hand (Client) expects. Notice that
    the `CitizenDataBase` methods of `Read()` and `Write()` have both been inlined
    in the class definition; their methods merely call the external functions. This
    is an example of how a wrapper class with inline functions can be a low-cost Adapter
    class, adding a very minimal amount of overhead (constructors, destructor, and
    potentially other non-inline methods).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前为适配器类定义的类中，我们只是简单地将外部数据库功能封装在 `CitizenDataBase` 类中。在这里，`CitizenDataBase`
    不仅是我们的适配器类，也是我们的目标类，因为它包含了我们的应用程序（客户端）所期望的接口。请注意，`CitizenDataBase` 的 `Read()`
    和 `Write()` 方法都已经在类定义中内联了；它们的方法只是调用外部函数。这是一个示例，说明了具有内联函数的包装类可以是一个低成本适配器类，仅添加非常小的开销（构造函数、析构函数以及可能的其他非内联方法）。
- en: 'Now, let’s take a look at our `main()` function, which is a streamlined version
    of a Client:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看我们的 `main()` 函数，它是客户端的一个精简版本：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the aforementioned `main()` function, we first instantiate three `Person`
    instances. We then instantiate a `CitizenDataBase` to provide encapsulated access
    to write or read our `Person` instances, to or from the database. The methods
    for our `CitizenDataBase` constructors call the external function `db_open()`
    to open the database. Likewise, the destructor calls `db_close()`. As expected,
    our `CitizenDataBase` methods for `Read()` and `Write()` will each, respectively,
    call the external functions, `db_read()` or `db_write()`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述 `main()` 函数中，我们首先创建了三个 `Person` 实例。然后，我们创建了一个 `CitizenDataBase` 实例，以提供封装的访问权限来写入或读取我们的
    `Person` 实例，到或从数据库中。我们的 `CitizenDataBase` 构造函数的方法调用外部函数 `db_open()` 来打开数据库。同样，析构函数调用
    `db_close()`。正如预期的那样，我们的 `CitizenDataBase` 的 `Read()` 和 `Write()` 方法将分别调用外部函数
    `db_read()` 或 `db_write()`。
- en: 'Let’s take a look at the output for this program:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序的输出：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the aforementioned output, we can notice the correlation between the various
    member functions to the wrapped, external functions via construction, a call to
    write and read, and then the destruction of the database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们可以注意到各种成员函数与包装的外部函数之间的关联，通过构造函数、写入和读取的调用，以及数据库的销毁。
- en: Our simple `CitizenDataBase` wrapper is a very straightforward, but reasonable,
    use of the Adapter pattern. Interestingly, our `CitizenDataBase` also has commonalities
    with the **Data Access Object pattern**, as this wrapper provides a clean interface
    to a data storage mechanism, concealing the implementation (access) to the underlying
    database.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单 `CitizenDataBase` 包装器是适配器模式的一个非常直接但合理的应用。有趣的是，我们的 `CitizenDataBase` 也与
    **数据访问对象模式** 有相似之处，因为这个包装器提供了一个干净的接口来访问数据存储机制，隐藏了底层数据库的实现（访问）。
- en: We have now seen three implementations of the Adapter pattern. We have folded
    the concepts of Adapter, Adaptee, Target, and Client into the framework of classes
    we are accustomed to seeing, namely `Person`, as well as into descendants of our
    Adapter (`Orkan`, `Romulan`, and `Earthling`, as in our first two examples). Let
    us now briefly recap what we have learned relating to patterns before moving forward
    to our next chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了适配器模式的三个实现。我们将适配器、适配者、目标和客户端的概念融合到了我们习惯看到的类框架中，即 `Person` 类，以及我们的适配器的后代（`Orkan`、`Romulan`
    和 `Earthling`，如我们的前两个例子所示）。现在，让我们简要回顾一下我们在学习模式之前所学的知识，然后继续到下一章。
- en: Summary
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have advanced our pursuit to become better C++ programmers
    through widening our knowledge of design patterns. We have explored the Adapter
    pattern in both the concept and through multiple implementations. Our first implementation
    used private inheritance two derive the Adapter from the Adaptee class. We specified
    our Adapter as an abstract class and then used public inheritance to introduce
    several Target classes based on the interface provided by our Adapter class. Our
    second implementation instead modeled the relationship between the Adapter and
    Adaptee using association. We then looked at an example usage of an Adapter as
    a wrapper to simply add an OO interface to existing function-based application
    components.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过扩展我们对设计模式的知识来提高我们成为更好的C++程序员的追求。我们探讨了适配器模式的概念及其多种实现。我们的第一个实现使用私有继承从适配器类派生出适配器。我们指定适配器为一个抽象类，然后使用公共继承根据适配器类提供的接口引入几个目标类。我们的第二个实现则使用关联来模拟适配器和适配器之间的关系。然后我们查看了一个适配器作为包装器的示例用法，简单地为现有的基于函数的应用程序组件添加OO接口。
- en: Utilizing common design patterns, such as the Adapter pattern, will help you
    more easily reuse existing, well-tested portions of code in a manner understood
    by other programmers. By utilizing core design patterns, you will be contributing
    to well-understood and reusable solutions with more sophisticated programming
    techniques.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 利用常见的设计模式，例如适配器模式，将帮助您更轻松地重用现有经过良好测试的代码部分，并且其他程序员也能理解。通过利用核心设计模式，您将为理解良好且可重用的解决方案做出贡献，并使用更复杂的编程技术。
- en: We are now ready to continue forward with our next design pattern, in [*Chapter
    19*](B19087_19.xhtml#_idTextAnchor829), *Using the Singleton Pattern*. Adding
    more patterns to our arsenal of programming skills makes us more versatile and
    valued programmers. Let’s continue forward!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备继续前进，学习下一个设计模式，在[*第19章*](B19087_19.xhtml#_idTextAnchor829)中，*使用单例模式*。将更多模式添加到我们的编程技能库中，使我们成为更灵活且更有价值的程序员。让我们继续前进！
- en: Questions
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Using the Adapter examples found in this chapter, create a program as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章中找到的适配器示例，创建一个如下所示的程序：
- en: 'Implement a `CitizenDataBase` that stores various types of `Humanoid` instances
    (`Orkan`, `Romulan`, `Earthling`, and perhaps `Martian`). Decide whether you will
    use the private base class Adapter-Adaptee relationship or the association relationship
    between the Adapter and Adaptee (hint: the private inheritance version will be
    easier).'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`CitizenDataBase`，该数据库存储各种类型的`Humanoid`实例（`Orkan`、`Romulan`、`Earthling`以及可能还有`Martian`）。决定您将使用私有基类适配器-适配器关系还是适配器和适配器之间的关联关系（提示：私有继承版本将更容易）。
- en: Noting that the `CitizenDataBase` handles `Person` instances, can this class
    be used *as-is* to store various types of `Humanoid` instances, or must it be
    adapted in some way? Recall that `Person` is a base class of `Humanoid` (if you
    chose this implementation), but also remember that we can never upcast past a
    non-public inheritance boundary.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到`CitizenDataBase`处理`Person`实例，这个类是否可以原样使用来存储各种类型的`Humanoid`实例，或者必须以某种方式对其进行适配？回想一下，`Person`是`Humanoid`的基类（如果您选择了这种实现），但也要记住，我们永远不能超出非公共继承边界进行向上转型。
- en: What other examples can you imagine that might easily incorporate the Adapter
    pattern?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能想象出哪些其他例子可以轻松地结合适配器模式？
