- en: '18'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying the Adapter Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will extend our quest to expand your C++ programming skills beyond
    core OOP concepts, with the goal of enabling you to solve recurring types of coding
    problems utilizing common design patterns. Incorporating design patterns in coding
    solutions can not only provide elegant solutions but also enhance code maintenance
    and provide potential opportunities for code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: The next core design pattern that we will learn how to implement effectively
    in C++ is the **Adapter pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Adapter pattern and how it contributes to OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to implement the Adapter pattern in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the essential Adapter pattern
    and how it can be used to either allow two incompatible classes to communicate
    or to upgrade unseemly code to well-designed OO code. Adding another key design
    pattern to your knowledge set will refine your programming skills to help make
    you a more valuable programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s increase our programming skillset by examining another common design pattern,
    the Adapter pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter18](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter18).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter18` in a file named `Chp18-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3Kaxckc](https://bit.ly/3Kaxckc).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Adapter pattern** is a structural design pattern that provides a means
    for converting an existing, undesirable interface of a class to an interface that
    another class expects. An **Adapter class** will be the link for communication
    between two existing components, adapting the interfaces so that the two may share
    and exchange information. An Adapter allows two or more classes to work together
    that otherwise could not do so.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, an Adapter will not add functionality but will add the preferred interface
    for usage (or conversion) to either allow one class to be used in an expected
    manner or for two otherwise incompatible classes to communicate with one another.
    In its most simple form, an Adapter simply converts an existing class to support
    an expected interface as may be specified in an OO design.
  prefs: []
  type: TYPE_NORMAL
- en: An Adapter can be either associated with or derived from the class for which
    it is providing an adaptive interface. If inheritance is used, a private or protected
    base class is appropriate to hide the underlying implementation. If instead, the
    Adapter class is associated with the class having the undesirable interface, the
    methods in the Adapter class (with the new interfaces) will merely delegate the
    work to its associated class.
  prefs: []
  type: TYPE_NORMAL
- en: The Adapter pattern can also be used to add an OO interface to (that is, to
    *wrap an OO interface around*) a series of functions or other classes, allowing
    assorted existing components to be utilized more naturally in an OO system. This
    specific type of Adapter is known as a `extern C`, to allow the linker to resolve
    linkage conventions between the two languages).
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the Adapter pattern has benefits. The Adapter allows the reuse of
    existing code by providing a shared interface to allow otherwise unrelated classes
    to communicate. The OO programmer will now use the Adapter class directly, allowing
    for easier maintenance of the application. That is, most programmer interaction
    will be with a well-designed Adapter class, rather than with two or more odd components.
    A small drawback of using an Adapter is a slightly decreased performance from
    the added layer of code. However, most often, reusing existing components through
    providing a clean interface to support their interaction is a winning proposition,
    despite a (hopefully small) performance trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Adapter pattern will include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An **Adaptee** class, which represents the class with desirable utilities, yet
    which exists in a form that is not suitable or as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **Adapter** class, which adapts the interface of the Adaptee class to meet
    the needs of the desired interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Target** class, which represents the specific, desired interface of the
    application at hand. A class may be both a Target and an Adapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional **Client** classes, which will interact with the Target class to fully
    define the application at hand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Adapter pattern allows the reuse of qualified, existing components that do
    not meet the interface needs of current application designs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move forward to see two common applications of the Adapter pattern; one
    will have two potential means for implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Adapter pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s explore two common uses of the Adapter pattern. That is, creating an Adapter
    to bridge the gap between two incompatible class interfaces or building an Adapter
    to simply wrap an existing set of functions with an OO interface.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the usage of an *Adapter* providing a connector between two
    (or more) incompatible classes. The *Adaptee* will be a well-tested class that
    we would like to reuse (but which has an undesirable interface), and the *Target*
    classes will be those specified in our OO design for an application in the making.
    Let’s now specify an Adapter to allow our Adaptee to work with our Target classes.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Adapter to provide a necessary interface to an existing class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement the Adapter pattern, we will first need to identify our Adaptee
    class. We will then create an Adapter class to modify the interface of the Adaptee.
    We will also identify our Target class, representing the class we need to model
    per our OO design. At times, our Adapter and Target may be rolled into a single
    class. In an actual application, we will additionally have Client classes, representing
    the full complement of classes found in the final application at hand. Let’s start
    with the Adaptee and Adapter classes, as these class definitions will begin the
    foundation on which to build our pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we will specify our Adaptee class as one we are accustomed to
    seeing – `Person`. We will imagine that our planet has recently become aware of
    many other exoplanets capable of supporting life and that we have benevolently
    made allies with each such civilization. Further imagining that the various software
    systems on Earth would like to welcome and include our new friends, including
    `Romulans` and `Orkans`, we would like to adapt some of our existing software
    to easily accommodate the new demographics of our exoplanet neighbors. With that
    in mind, we will transform our `Person` class to include more interplanetary terminology
    by creating an Adapter class, `Humanoid`.
  prefs: []
  type: TYPE_NORMAL
- en: In our forthcoming implementation, we will use private inheritance to inherit
    `Humanoid` (Adapter) from `Person` (Adaptee), therefore hiding the underlying
    implementation of the Adaptee. We could have alternatively associated a `Humanoid`
    with a `Person` (an implementation we will also review in this section). We can
    then flesh out some derived classes of `Humanoid` within our hierarchy, such as
    `Orkan`, `Romulan`, and `Earthling`, to accommodate the intergalactic application
    at hand. The `Orkan`, `Romulan`, and `Earthling` classes can be considered our
    Target classes, or those that our application will instantiate. We will choose
    to make our Adapter class, `Humanoid`, abstract so that it is not directly instantiable.
    Because our specific derived classes (Target classes) can be generalized by their
    abstract base class type (`Humanoid`) in our application (Client), we can also
    consider `Humanoid` a Target class. That is, `Humanoid` can be viewed primarily
    as an Adapter, but secondarily as a generalized Target class.
  prefs: []
  type: TYPE_NORMAL
- en: Our various Client classes can utilize derived classes of `Humanoid`, making
    instances of each of its concrete descendants. These instances may be stored in
    their own specialized type or genericized using `Humanoid` pointers. Our implementation
    is a modern take on the well-used Adapter design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the Adaptee and Adapter (private inheritance technique)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take a look at the mechanics of the first usage of our Adapter pattern,
    beginning by reviewing the definition for our Adaptee class, `Person`. This example
    can be found, as a complete program, in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous class definition, we notice that our `Person` class definition
    is as we have been accustomed to seeing it in many other examples throughout this
    book. This class is instantiable; however, `Person` is not an appropriate class
    to instantiate in our intergalactic application. Instead, the expected interface
    would be to utilize that found in `Humanoid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, let’s take a look at our Adapter class, `Humanoid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned `Humanoid` class, our goal is to provide an Adapter to
    contribute to the expected interface that our intergalactic application requires.
    We simply derive `Humanoid` from `Person` using private inheritance, hiding the
    public interfaces found in `Person` from use outside the scope of `Humanoid`.
    We understand that the target application (Client) would not wish for the public
    interfaces found in `Person` to be utilized by various subtypes of `Humanoid`
    instances. Notice that we are not adding functionality, only adapting the interface.
  prefs: []
  type: TYPE_NORMAL
- en: We then notice the public methods introduced in `Humanoid` that provide the
    desired interfaces for the Target class(es). The implementation of these interfaces
    is often straightforward. We simply call the inherited method defined in `Person`,
    which will easily complete the task at hand (but which uses an unacceptable interface
    to do so). For example, our `Humanoid::GetPrimaryName()` method simply calls `Person::GetLastName();`
    to complete the task. However, `GetPrimaryName()` may more so represent appropriate
    intergalactic lingo than `Person::GetLastName()`. We can see how `Humanoid` is
    serving as an Adapter for `Person`. We can also see how most of the member functions
    of the Adapter class, `Humanoid`, use inline functions to simply wrap the `Person`
    methods with more suitable interfaces while adding no overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is not necessary to precede the calls to `Person` base class methods
    within Humanoid methods with `Person::` (except when a `Humanoid` method calls
    the same named method in `Person`, such as with `GetTitle()`). The scope resolution
    usage of `Person::` avoids potential recursion in these situations.
  prefs: []
  type: TYPE_NORMAL
- en: We also notice that `Humanoid` introduces an abstract polymorphic method (that
    is, a pure virtual function) with the specification of `virtual const string &Converse()
    = 0;`. We have made the design decision that only derived classes of `Humanoid`
    will be instantiable. Nonetheless, we understand that public descendant classes
    may still be collected by their base class type of `Humanoid`. Here, `Humanoid`
    serves primarily as the Adapter class and secondarily as a Target class offering
    the suite of acceptable interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our pure virtual function `virtual const String &Converse() = 0;`
    includes a default implementation. This is rare but allowed, so long as the implementation
    is not written inline. Here, we utilize the opportunity to specify a default behavior
    for `Humanoid::Converse()`, by simply calling `Person::Speak()`.
  prefs: []
  type: TYPE_NORMAL
- en: Deriving concrete classes from the Adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let’s extend our Adapter (`Humanoid`) and take a look at one of our concrete,
    derived Target classes, `Orkan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In our aforementioned `Orkan` class, we use public inheritance to derive `Orkan`
    from `Humanoid`. An `Orkan` *Is-A* `Humanoid`. As such, all of the public interfaces
    in `Humanoid` are available to `Orkan` instances. Notice that our alternate constructor
    sets the default greeting message to `"Nanu nanu"`, per the `Orkan` dialect.
  prefs: []
  type: TYPE_NORMAL
- en: Because we wish `Orkan` to be a concrete, instantiable class, we must override
    `Humanoid::Converse()` and provide an implementation in the `Orkan` class. Notice,
    however, that `Orkan::Converse()` simply calls `Humanoid::Converse();`. Perhaps
    `Orkan` finds the default implementation in its base class acceptable. Notice
    that we use the `Humanoid::` scope resolution to qualify `Converse()` within the
    `Orkan::Converse()` method to avoid recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, had `Humanoid` not been an abstract class, `Orkan` would not
    have had to override `Converse()` – the default behavior would have automatically
    been inherited. Yet, with `Humanoid` defined as abstract, the override of `Converse()`
    is necessary within `Orkan`, otherwise, `Orkan` will also be also viewed as an
    abstract class. No worries! We can utilize the benefit of the default behavior
    of `Humanoid::Converse()` merely by calling it within `Orkan::Converse()`. This
    will satisfy the requirements for making `Orkan` concrete, while allowing `Humanoid`
    to remain abstract, while still providing the rare default behavior for `Converse()`!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at our next concrete Target class, `Romulan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Taking a comparably quick look at the aforementioned `Romulan` class, we notice
    that this concrete Target is similar to its sibling class, `Orkan`. We notice
    that the default message for the greeting passed up to our base class constructor
    is `"jolan'tru"` to reflect `Romulan` dialect. Though we could have made our implementation
    of `Romulan::Converse()` more intricate, we chose not to do so. We can quickly
    understand the full scope of this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at our third Target class, `Earthling`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Again, taking another comparably quick look at the aforementioned `Earthling`
    class, we notice that this concrete Target is similar to its sibling classes,
    `Orkan` and `Romulan`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined our Adaptee, Adapter, and multiple Target classes,
    let’s bring the pieces together by examining the Client portion of our program.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing the pattern components together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, let us consider what a sample Client may look like in our overall application.
    Certainly, it may consist of many files with a variety of classes. In its simplest
    form, as shown next, our Client will contain a `main()` function to drive the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now take a look at our `main()` function to see how our pattern is orchestrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Reviewing our aforementioned `main()` function, we first create an STL `list`
    of `Humanoid` pointers with `list<Humanoid *> allies;`. We then instantiate an
    `Orkan`, `Romulan`, and an `Earthling` and add each to the list using `allies.push_back()`.
    Again, using the Standard Template Library, we next create a list iterator to
    walk through the list of pointers to `Humanoid` instances. As we iterate through
    our generalized list of allies, we call the approved interfaces of `GetInfo()`
    and `Converse()` on each item in our list (that is, for each specific type of
    `Humanoid`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we specify one specific `Humanoid`, an `Earthling`, and change this instance’s
    default greeting by invoking `e1->SetSalutation("Bonjour");`. By calling `Converse()`
    again on this instance (we first did so on this object generically in the aforementioned
    loop), we can request that the `Earthling` use `"Bonjour"` to greet allies instead
    of `"Hello"` (the default greeting for `Earthling`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned output, notice that the planetary specification for each
    `Humanoid` is displayed (`Orkan`, `Romulan`, and `Earthling`), followed by their
    secondary and primary names. Then, the appropriate greeting is displayed for the
    particular `Humanoid`. Notice that `Earthling` `Eve Xu` first converses using
    `"Hello"` and then later converses using `"Bonjour"`.
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of the preceding implementation (using a private base class to
    derive Adapter from Adaptee) is that the coding is very straightforward. With
    this approach, any protected methods in the Adaptee class can easily be carried
    down to be used within the scope of the Adapter methods. We will soon see that
    protected members will be an issue should we instead use the association as a
    means of connecting the Adapter to Adaptee.
  prefs: []
  type: TYPE_NORMAL
- en: A disadvantage of the prior mentioned approach is that it is a C++ specific
    implementation. Other languages do not support private base classes. Alternatively,
    using a public base class to define the relationship between Adapter and Adaptee
    would fail to conceal the unwanted Adaptee interface, and would be a very poor
    design choice.
  prefs: []
  type: TYPE_NORMAL
- en: Considering an alternate specification of Adaptee and Adapter (association)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us now briefly consider a slightly revised version of the aforementioned
    Adapter pattern implementation. We will instead use an association to model the
    relationship between the Adaptee and Adapter. The concrete derived classes (Targets)
    will still be derived from the Adapter as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an alternative implementation of our Adapter class, `Humanoid`, using
    an association between Adapter and Adaptee. Though we will only review the portion
    of the code that differs from our initial approach, the full implementation can
    be found as a complete program in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the aforementioned implementation of our Adapter class, `Humanoid`
    is no longer derived from `Person`. Instead, `Humanoid` will add a private data
    member `Person *life;`, which will represent an association between the Adapter
    (`Humanoid`) and the Adaptee (`Person`). In our Humanoid constructors, we will
    need to allocate the underlying implementation of the Adaptee (`Person`). We will
    also need to delete the Adaptee (`Person`) in our destructor.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to our last implementation, `Humanoid` offers the same member functions
    within its public interface. However, notice that each `Humanoid` method delegates,
    through the associated object, a call to the appropriate Adaptee methods. For
    example, `Humanoid::GetSecondaryName()` merely calls `life->GetFirstName();` to
    delegate the request (versus calling the inherited, corresponding Adaptee methods).
  prefs: []
  type: TYPE_NORMAL
- en: As in our initial implementation, our derived classes from `Humanoid` (`Orkan`,
    `Romulan`, and `Earthling`) are specified in the same fashion, as is our Client
    within our `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the relationship between Adaptee and Adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An interesting point to consider when choosing between private inheritance or
    association as the relationship between Adapter and Adaptee is whether or not
    the Adaptee contains any protected members. Recall that the original code for
    `Person` included a protected `ModifyTitle()` method. Should protected members
    exist in the Adaptee class? The private base class implementation allows those
    inherited, protected members to continue to be accessed within the scope of the
    Adapter class (that is, by methods of the Adapter). However, using the association-based
    implementation, the protected methods in the Adaptee (`Person`) are unusable in
    the scope of the Adapter. To make this example work, we were required to move
    `Person::ModifyTitle()` to the public access region. However, modifying the Adaptee
    class is not always possible, nor is it necessarily recommended. Considering the
    protected member issue, our initial implementation using a private base class
    is the stronger implementation, as it does not depend on us modifying the class
    definition of the Adaptee (`Person`).
  prefs: []
  type: TYPE_NORMAL
- en: Let us now take a brief look at an alternate usage of the Adapter pattern. We
    will simply be using an Adapter class as a wrapper class. We will add an OO interface
    to an otherwise loosely arranged set of functions that work well, but lack the
    desired interface our application (Client) desires.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Adapter as a wrapper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an alternative usage of the Adapter pattern, we will wrap an OO interface
    around a grouping of related external functions. That is, we will create a wrapper
    class to encapsulate these functions.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the external functions will represent a suite of existing database
    access functions. We will assume that the core database functionality is well
    tested for our data type (`Person`) and has been used problem-free. However, these
    external functions by themselves present an undesirable and unexpected functional
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: We will instead wrap the external functions by creating an Adapter class to
    encapsulate their collective functionality. Our Adapter class will be `CitizenDataBase`,
    representing an encapsulated means for reading and writing `Person` instances
    from and to a database. Our existing external functions will provide the implementation
    for our `CitizenDataBase` member functions. Let us assume that the OO interfaces,
    as defined in our Adapter class, meet the requirements of our OO design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the mechanics of our simple wrapper Adapter pattern, beginning
    by examining external functions providing the database access functionality. This
    example can be found, as a complete program, in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter18/Chp18-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In our previously defined external functions, let’s assume all functions are
    well tested and allow `Person` instances to be read from or written to a database.
    To support this simulation, we have created an external `Person` instance with
    `Person objectRead;` to provide a brief, non-stack located storage place for a
    newly read instance (used by `db_read()`) until the newly read instance is captured
    as a return value. Keep in mind that the existing external functions do not represent
    an encapsulated solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create a simple wrapper class to encapsulate these external functions.
    The wrapper class, `CitizensDataBase`, will represent our Adapter class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In our aforementioned class definition for our Adapter class, we simply encapsulate
    the external database functionality within the `CitizenDataBase` class. Here,
    `CitizenDataBase` is not only our Adapter class but also our Target class, as
    it contains the interfaces our application at hand (Client) expects. Notice that
    the `CitizenDataBase` methods of `Read()` and `Write()` have both been inlined
    in the class definition; their methods merely call the external functions. This
    is an example of how a wrapper class with inline functions can be a low-cost Adapter
    class, adding a very minimal amount of overhead (constructors, destructor, and
    potentially other non-inline methods).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at our `main()` function, which is a streamlined version
    of a Client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned `main()` function, we first instantiate three `Person`
    instances. We then instantiate a `CitizenDataBase` to provide encapsulated access
    to write or read our `Person` instances, to or from the database. The methods
    for our `CitizenDataBase` constructors call the external function `db_open()`
    to open the database. Likewise, the destructor calls `db_close()`. As expected,
    our `CitizenDataBase` methods for `Read()` and `Write()` will each, respectively,
    call the external functions, `db_read()` or `db_write()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned output, we can notice the correlation between the various
    member functions to the wrapped, external functions via construction, a call to
    write and read, and then the destruction of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Our simple `CitizenDataBase` wrapper is a very straightforward, but reasonable,
    use of the Adapter pattern. Interestingly, our `CitizenDataBase` also has commonalities
    with the **Data Access Object pattern**, as this wrapper provides a clean interface
    to a data storage mechanism, concealing the implementation (access) to the underlying
    database.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen three implementations of the Adapter pattern. We have folded
    the concepts of Adapter, Adaptee, Target, and Client into the framework of classes
    we are accustomed to seeing, namely `Person`, as well as into descendants of our
    Adapter (`Orkan`, `Romulan`, and `Earthling`, as in our first two examples). Let
    us now briefly recap what we have learned relating to patterns before moving forward
    to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have advanced our pursuit to become better C++ programmers
    through widening our knowledge of design patterns. We have explored the Adapter
    pattern in both the concept and through multiple implementations. Our first implementation
    used private inheritance two derive the Adapter from the Adaptee class. We specified
    our Adapter as an abstract class and then used public inheritance to introduce
    several Target classes based on the interface provided by our Adapter class. Our
    second implementation instead modeled the relationship between the Adapter and
    Adaptee using association. We then looked at an example usage of an Adapter as
    a wrapper to simply add an OO interface to existing function-based application
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing common design patterns, such as the Adapter pattern, will help you
    more easily reuse existing, well-tested portions of code in a manner understood
    by other programmers. By utilizing core design patterns, you will be contributing
    to well-understood and reusable solutions with more sophisticated programming
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to continue forward with our next design pattern, in [*Chapter
    19*](B19087_19.xhtml#_idTextAnchor829), *Using the Singleton Pattern*. Adding
    more patterns to our arsenal of programming skills makes us more versatile and
    valued programmers. Let’s continue forward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the Adapter examples found in this chapter, create a program as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a `CitizenDataBase` that stores various types of `Humanoid` instances
    (`Orkan`, `Romulan`, `Earthling`, and perhaps `Martian`). Decide whether you will
    use the private base class Adapter-Adaptee relationship or the association relationship
    between the Adapter and Adaptee (hint: the private inheritance version will be
    easier).'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Noting that the `CitizenDataBase` handles `Person` instances, can this class
    be used *as-is* to store various types of `Humanoid` instances, or must it be
    adapted in some way? Recall that `Person` is a base class of `Humanoid` (if you
    chose this implementation), but also remember that we can never upcast past a
    non-public inheritance boundary.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What other examples can you imagine that might easily incorporate the Adapter
    pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
