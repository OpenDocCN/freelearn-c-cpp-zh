<html><head></head><body>
<div><div><div><h1 id="_idParaDest-303" class="chapter-number"><a id="_idTextAnchor490"/>18</h1>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor491"/>Power Management and Energy Efficiency in Embedded Systems</h1>
			<p>In this chapter, we will delve into power management and energy efficiency in embedded systems, a critical aspect in today’s technology-driven world. Efficient power management is vital for prolonging battery life and ensuring optimal performance in embedded devices. This chapter aims to equip you with the necessary knowledge and skills to implement effective power management techniques in your designs.</p>
			<p>We will begin by exploring various power management techniques, laying the foundation to understand how to reduce power consumption in embedded systems. Following this, we will examine the different sleep modes and low-power states available in STM32F4 microcontrollers, providing detailed insights into their configurations and applications. Then, we will discuss the wake-up sources and triggers in the STM32F4, which are essential to ensure that the microcontroller can respond promptly to external events. Finally, we will put theory into practice by developing a driver to enter standby mode and wake up the microcontroller, demonstrating how to apply these concepts in real-world scenarios.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>An overview of power management techniques</li>
				<li>Low-power modes in STM32F4</li>
				<li>Wake-up sources and triggers in STM32F4</li>
				<li><a id="_idTextAnchor492"/>Developing a driver to enter standby mode and wake up</li>
			</ul>
			<p>By the end of this chapter, you will have a thorough understanding of power management in embedded systems and be able to implement energy-efficient designs using STM32F4 microcontrollers. This knowledge will enable you to create embedded systems that optimize power consumption and extend battery life, essential for modern applications.</p>
			<h1 id="_idParaDest-305"><a id="_idTextAnchor493"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a>.</p>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor494"/>An overview of power management techniques</h1>
			<p>In this section, we will explore the world of <a id="_idIndexMarker1254"/>power management techniques, a crucial aspect of embedded systems design. As our devices become more advanced and our expectations for battery life increase, understanding how to manage power effectively is more important than ever. Let’s dive into the various power management techniques and how they are implemented, taking a look at some case studies to see these techniques in action.</p>
			<p>Power management in embedded systems involves a combination of hardware and software strategies designed to reduce energy consumption. This is particularly important for battery-powered devices, where efficient power usage can significantly extend battery life. The main<a id="_idIndexMarker1255"/> techniques we’ll cover include <strong class="bold">Dynamic Voltage and Frequency Scaling</strong> (<strong class="bold">DVFS</strong>), clock gating, power gating, and utilizing low-power modes.</p>
			<p>Let’s start with DVFS.</p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor495"/>Dynamic Voltage and Frequency Scaling (DVFS)</h2>
			<p>DVFS is a<a id="_idIndexMarker1256"/> method where the voltage and frequency of a <a id="_idIndexMarker1257"/>microcontroller are adjusted based on the workload. By lowering the voltage and frequency during periods of low activity, power consumption can be greatly reduced. Conversely, during periods of high demand, the voltage and frequency are increased to ensure performance.</p>
			<h3>How is DVFS implemented?</h3>
			<p>In STM32 microcontrollers, DVFS can be<a id="_idIndexMarker1258"/> managed through specific power control registers. These registers allow a system to dynamically adjust the operating points based on the required performance levels. For example, the STM32F4 series has several power modes that can be configured to adjust the system clock and core voltage.</p>
			<h3>An example use case – mobile phones</h3>
			<p>Mobile phones <a id="_idIndexMarker1259"/>are a prime example of DVFS in action. When a phone is idle, it reduces the CPU frequency and voltage to save the battery. As soon as you start using an app or playing a game, the CPU ramps up its frequency and voltage to provide the necessary performance. This balance between performance and power savings is what makes modern smartphones<a id="_idIndexMarker1260"/> so efficient.</p>
			<p>Another common technique is clock gating.</p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor496"/>Clock gating</h2>
			<p>Clock gating<a id="_idIndexMarker1261"/> is a technique <a id="_idIndexMarker1262"/>where the clock signal to certain parts of a microcontroller is turned off when they are not in use. This prevents unnecessary switching of transistors, which in turn saves power.</p>
			<h3>How is clock gating implemented?</h3>
			<p>Clock gating is typically <a id="_idIndexMarker1263"/>controlled through clock control registers. In the STM32 series, each peripheral’s clock can be enabled or disabled individually using these registers. For instance, if a particular peripheral such as the ADC is not needed, its clock can be disabled to save power.</p>
			<h3>An example use case – smart home devices</h3>
			<p>Smart home devices <a id="_idIndexMarker1264"/>such as smart thermostats or lights use clock gating to manage power efficiently. These devices spend a significant amount of time in a low-power state, waking up only to perform specific tasks. By gating the clock to unused peripherals, these devices can conserve energy and extend their battery life.</p>
			<p>Another technique is power gating.</p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor497"/>Power gating</h2>
			<p>Power gating<a id="_idIndexMarker1265"/> takes <a id="_idIndexMarker1266"/>power savings a step further by completely shutting off the power to certain parts of a microcontroller. This technique ensures zero power consumption for the powered-down sections.</p>
			<h3>How is power gating implemented?</h3>
			<p>Power gating is more <a id="_idIndexMarker1267"/>complex than clock gating and often involves dedicated power management units within a microcontroller. These units control the power supply to various domains of the microcontroller. In STM32 microcontrollers, power gating can be configured using the power control registers to turn off specific peripherals, or even entire sections of the microcontroller.</p>
			<h3>An example use case – wearable devices</h3>
			<p>Wearable<a id="_idIndexMarker1268"/> devices, such as fitness trackers, benefit greatly from power gating. These devices need to operate for extended periods on a single charge. By powering down sensors and other components when they are not in use, wearables can achieve longer battery life without compromising functionality.</p>
			<p>Next, let’s discuss low-power modes.</p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor498"/>Low-power modes</h2>
			<p>Low-power modes<a id="_idIndexMarker1269"/> are predefined states within microcontrollers that significantly<a id="_idIndexMarker1270"/> reduce power consumption by disabling or reducing the functionality of various components. These modes range from simple CPU sleep modes to more complex deep sleep or standby modes.</p>
			<h3>How are low-power modes implemented?</h3>
			<p>Low-power modes are <a id="_idIndexMarker1271"/>implemented through the power control registers. The STM32F4 microcontrollers, for example, offer several low-power<a id="_idIndexMarker1272"/> modes, including <strong class="bold">sleep</strong>, <strong class="bold">stop</strong>, and <strong class="bold">standby</strong>. Each<a id="_idIndexMarker1273"/> mode <a id="_idIndexMarker1274"/>provides a different balance between power savings and wake-up time.</p>
			<h3>An example use case – remote sensors</h3>
			<p>Remote<a id="_idIndexMarker1275"/> sensors used in agriculture or environmental monitoring often use low-power modes. These sensors might spend the majority of their time in a low-power state, waking up periodically to take measurements and transmit data. By leveraging low-power modes, these sensors can operate for months or<a id="_idIndexMarker1276"/> even years on a single battery charge.</p>
			<p>Now, let’s take a closer look at a couple of case studies that illustrate how a combination of these power management techniques is used in real-world applications.</p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor499"/>Case study 1 – an energy-efficient smartwatch</h2>
			<p>Smartwatches are <a id="_idIndexMarker1277"/>a great example of a device that relies heavily on power management techniques. These devices need to balance performance with battery life, as users expect them to run for days on a single charge. Let’s break down the roles the different techniques play in an energy-efficient smartwatch design:</p>
			<ul>
				<li><strong class="bold">DVFS</strong>: The smartwatch uses DVFS<a id="_idIndexMarker1278"/> to adjust the CPU frequency based on the current workload. When the user interacts with the watch, the CPU frequency increases to provide a smooth experience. When the watch is idle, the frequency is lowered to save power.</li>
				<li><strong class="bold">Clock gating</strong>: Peripherals such as the GPS or heart rate monitor are only powered when needed. When<a id="_idIndexMarker1279"/> these features are not in use, their clocks are gated to conserve energy.</li>
				<li><strong class="bold">Power gating</strong>: Components like the<a id="_idIndexMarker1280"/> display driver are powered down completely when the display is off.</li>
				<li><strong class="bold">Low-power modes</strong>: The <a id="_idIndexMarker1281"/>watch enters deep sleep mode during periods of inactivity, waking up only to check for notifications or user interactions.</li>
			</ul>
			<p>By combining these techniques, smartwatches can achieve impressive battery life without compromising on functionality. Another excellent example is solar-powered environmental monitoring.</p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor500"/>Case study 2 – a solar-powered environmental monitor</h2>
			<p>A<a id="_idIndexMarker1282"/> solar-powered environmental monitor deployed in remote locations must operate efficiently to ensure continuous data collection and transmission. The roles are as follows:</p>
			<ul>
				<li><strong class="bold">DVFS</strong>: The monitor adjusts its operating frequency based on the intensity of sunlight and battery <a id="_idIndexMarker1283"/>charge. During peak sunlight hours, it operates at a higher frequency to process more data.</li>
				<li><strong class="bold">Clock gating</strong>: Sensors such as <a id="_idIndexMarker1284"/>temperature, humidity, and air quality are only active during data collection intervals. The clocks to these sensors are gated when not in use.</li>
				<li><strong class="bold">Power gating</strong>: Non-essential components are completely powered down during nighttime or <a id="_idIndexMarker1285"/>cloudy periods to conserve energy.</li>
				<li><strong class="bold">Low-power modes</strong>: The <a id="_idIndexMarker1286"/>monitor enters deep sleep mode between data collection intervals, waking up periodically to take measurements and transmit data.</li>
			</ul>
			<p>With these power management techniques, the monitor can operate autonomously for extended periods, relying solely on solar power.</p>
			<p>Power management is a vital aspect of embedded system design, especially as devices become more portable and battery-dependent. By understanding and implementing techniques such as DVFS, clock gating, power gating, and low-power modes, we can design embedded systems that are both powerful and energy-efficient. Whether it’s a smartwatch, a remote sensor, or any other battery-powered device, effective power management ensures longer battery life and better overall performance. As we continue to push the boundaries of what embedded systems can do, mastering these power management techniques will be more important than ever.</p>
			<p>In the next section, we will explore the low-power modes in our STM32F4 microcontroller.</p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor501"/>Low-power modes in STM32F4</h2>
			<p>In this <a id="_idIndexMarker1287"/>section, we will learn about the low-power modes <a id="_idIndexMarker1288"/>available in STM32F4 microcontrollers. We’ll cover the various low-power modes, how to configure them, and the practical aspects of using them in your projects.</p>
			<p>Let’s start by understanding these low-power modes. Low-power modes in the STM32F4 microcontrollers are designed to reduce power consumption by disabling or limiting the functionality of certain components. The STM32F4 offers several low-power states, each providing a different balance between power savings and wake-up latency. These modes include sleep, stop, and standby modes.</p>
			<p>We can put our system into low-power <a id="_idIndexMarker1289"/>mode by executing <a id="_idIndexMarker1290"/>the<code>SLEEPONEXIT</code> bit in the <strong class="bold">Cortex®-M4 with FPU system control register</strong> on <a id="_idIndexMarker1291"/>return from an ISR.</p>
			<p>Let’s dive into the details of each low-power mode, starting with sleep mode.</p>
			<h4>Sleep mode</h4>
			<p>Sleep mode<a id="_idIndexMarker1292"/> is the <a id="_idIndexMarker1293"/>most basic low-power mode, where the CPU clock is stopped but peripherals continue to operate. This mode offers <a id="_idIndexMarker1294"/>a <strong class="bold">quick wake-up time</strong>, making it ideal for applications that require frequent transitions between active and low-power states.</p>
			<p>To enter sleep mode, we need to clear the <code>SLEEPDEEP</code> bit in the <strong class="bold">System Control Register</strong> (<strong class="bold">SCR</strong>) and then<a id="_idIndexMarker1295"/> execute the WFI or WFE instruction, as shown in the following snippet:</p>
			<pre class="source-code">
void enter_sleep_mode(void) {
    // Clear the SLEEPDEEP bit to enter Sleep mode
    SCB-&gt;SCR &amp;= ~SCB_SCR_SLEEPDEEP_Msk;
    // Request Wait For Interrupt
    __WFI();
}</pre>			<p>The microcontroller <strong class="bold">exits Sleep mode upon any interrupt or event</strong>. Since the peripherals remain active, any configured interrupt from a peripheral can wake the CPU.</p>
			<p>An example use case<a id="_idIndexMarker1296"/> is <strong class="bold">sensor monitoring</strong>.</p>
			<p>For applications such as <a id="_idIndexMarker1297"/>continuous sensor monitoring, sleep <a id="_idIndexMarker1298"/>mode provides an efficient way to reduce power consumption without sacrificing responsiveness. The microcontroller can wake up quickly to process sensor data and then return to sleep mode.</p>
			<p>The next mode is stop mode.</p>
			<h4>Stop mode</h4>
			<p>Stop mode offers<a id="_idIndexMarker1299"/> a <strong class="bold">deeper power-saving state than sleep mode</strong> by stopping <a id="_idIndexMarker1300"/>the main internal regulator and halting the system clock. Only the low-speed clock (LSI or LSE) remains active. This mode provides a <strong class="bold">moderate wake-up time</strong> and <a id="_idIndexMarker1301"/>significant power savings.</p>
			<p>To enter stop mode, set the <code>SLEEPDEEP</code> bit in<a id="_idIndexMarker1302"/> the <code> </code>(<code>PWR_CR</code>), and then execute the WFI or WFE instruction, as shown in the following snippet. Additional configuration can also be applied to further reduce power consumption in stop mode:</p>
			<pre class="source-code">
void enter_stop_mode(void) {
    // Set SLEEPDEEP bit to enable deep sleep mode
    SCB-&gt;SCR |= SCB_SCR_SLEEPDEEP_Msk;
    // Request Wait For Interrupt
    __WFI();
}</pre>			<p>The MCU exits stop mode upon<a id="_idIndexMarker1303"/> any <strong class="bold">external interrupt</strong> or <strong class="bold">wake-up event from</strong><strong class="bold"> </strong><strong class="bold">configured EXTI lines</strong>, <strong class="bold">RTC alarms</strong>, or other configured wake-up sources. The wake-up time from stop mode is longer than from sleep mode, but it still allows for a relatively quick return to full <a id="_idIndexMarker1304"/>operation.</p>
			<p>An example use <a id="_idIndexMarker1305"/>case is <strong class="bold">periodic </strong><strong class="bold">data logging</strong>.</p>
			<p>In applications <a id="_idIndexMarker1306"/>such as data logging, a microcontroller can remain in<a id="_idIndexMarker1307"/> stop mode and wake up periodically, based on RTC alarms, to log data, and then return to stop mode. This significantly reduces power consumption while ensuring regular data logging.</p>
			<p>The final mode is standby mode.</p>
			<h4>Standby mode</h4>
			<p>Standby mode <a id="_idIndexMarker1308"/>provides<a id="_idIndexMarker1309"/> the <strong class="bold">highest power savings</strong> by turning off most internal circuitry, including the main regulator. Only a small portion of the microcontroller remains powered to monitor wake-up sources. This mode <a id="_idIndexMarker1310"/>has the <strong class="bold">longest wake-up time</strong> but offers the lowest power consumption.</p>
			<p>To enter standby mode, set the <code>PDDS</code> and <code>SLEEPDEEP</code> bits in the Power Control (<code>PWR_CR</code>) register, and then configure the wake-up sources. This snippet demonstrates how to enter standby mode:</p>
			<pre class="source-code">
void enter_standby_mode(void) {
    // Clear Wakeup flag
    PWR-&gt;CR |= PWR_CR_CWUF;
    // Set the PDDS bit to enter Standby mode
    PWR-&gt;CR |= PWR_CR_PDDS;
    // Set the SLEEPDEEP bit to enable deep sleep mode
    SCB-&gt;SCR |= SCB_SCR_SLEEPDEEP_Msk;
    // Request Wait For Interrupt
    __WFI();
}</pre>			<p>The microcontroller exits standby mode upon a <strong class="bold">wake-up event from an external wake-up pin (WKUP)</strong>, an RTC alarm, or a reset event. When the microcontroller wakes up from standby mode, it <strong class="bold">undergoes a full reset sequence</strong>, and the execution starts from the reset vector.</p>
			<p>An example use <a id="_idIndexMarker1311"/>case is <strong class="bold">remote </strong><strong class="bold">IoT devices</strong>.</p>
			<p>Standby <a id="_idIndexMarker1312"/>mode is perfect for remote IoT devices that need to operate for extended periods on battery power. These devices can remain in standby mode most of the time and wake up only for critical events or scheduled tasks, thus maximizing battery life.</p>
			<p>Now that we understand how to enter the various low-power modes, we will look at how to wake up from them.</p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor502"/>Wake-up sources and triggers from low-power modes in STM32F4</h1>
			<p>While low-power modes help conserve energy, ensuring that a microcontroller can wake up promptly when needed is equally important. The STM32F4 microcontroller series provides a variety of wake-up sources and triggers to handle this effectively. In this section, we’ll explore these wake-up sources, how they function, and their practical applications.</p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor503"/>Understanding wake-up sources</h2>
			<p>Wake-up sources are mechanisms <a id="_idIndexMarker1313"/>that bring a microcontroller out of a low-power state. The STM32F4 offers several types of wake-up sources, each suited for different scenarios. These include external interrupts, RTC alarms, watchdog timers, and various internal events. By understanding these triggers, we can design systems that balance power efficiency with responsiveness.</p>
			<p>The wake-up sources can be grouped as follows:</p>
			<ul>
				<li>External interrupts</li>
				<li><strong class="bold">Real-Time Clock</strong> (<strong class="bold">RTC</strong>) alarms</li>
				<li>Internal events</li>
			</ul>
			<p>Let’s delve into each of these wake-up sources to understand how they work and their typical use cases.</p>
			<h3>External interrupts</h3>
			<p>External interrupts<a id="_idIndexMarker1314"/> are one of <a id="_idIndexMarker1315"/>the primary wake-up sources for STM32F4 microcontrollers. These interrupts can be triggered by events on specific GPIO pins. When a microcontroller is in a low-power mode, an external signal, such as a button press or sensor output, can wake it up.</p>
			<p>Here’s how it works:</p>
			<ul>
				<li><strong class="bold">GPIO configuration</strong>: Configure the <a id="_idIndexMarker1316"/>GPIO pins to act as interrupt sources. This involves setting pin mode and enabling the interrupt on the desired edge (rising, falling, or both).</li>
				<li><strong class="bold">EXTI configuration</strong>: Each<a id="_idIndexMarker1317"/> GPIO pin can be mapped to an EXTI line, which can be configured to generate an interrupt.</li>
				<li><strong class="bold">NVIC configuration</strong>: Enable the <a id="_idIndexMarker1318"/>EXTI line interrupt in the <strong class="bold">Nested Vectored Interrupt Controller</strong> (<strong class="bold">NVIC</strong>) to ensure that the <a id="_idIndexMarker1319"/>microcontroller responds to the external event.</li>
			</ul>
			<p>Example us<a id="_idTextAnchor504"/>e cases are a <strong class="bold">smart doorbell system and </strong><strong class="bold">smart lighting</strong>.</p>
			<p>Imagine a <a id="_idIndexMarker1320"/>smart doorbell system. The microcontroller remains in a low-power mode to conserve battery life. When someone presses the doorbell button (connected to a GPIO pin), an external interrupt is triggered, waking the microcontroller to process the event and send a notification to the homeowner. Another excellent example is smart home lighting systems.</p>
			<p>A smart home lighting system<a id="_idIndexMarker1321"/> needs to conserve energy while being responsive to user inputs. The microcontroller stays in a low-power mode until an external interrupt (e.g., a motion sensor detecting movement) wakes it up. Upon waking, the microcontroller processes the event, turns on the lights, a<a id="_idTextAnchor505"/>nd then goes back to sleep after a predefined period of inactivity.</p>
			<p>The next wake-up source we will examine is the RTC Alarm.</p>
			<h3>RTC alarms</h3>
			<p>The RTC is a versatile peripheral <a id="_idIndexMarker1322"/>that can generate wake-up events at specific intervals or predefined times. It is particularly useful for applications requiring periodic <a id="_idIndexMarker1323"/>wake-ups, such as data logging or scheduled tasks.</p>
			<p>Here’s how it works:</p>
			<ul>
				<li><strong class="bold">RTC configuration</strong>: Configure the RTC to generate alarms or periodic wake-up events. This involves setting the <a id="_idIndexMarker1324"/>RTC clock source, enabling the wake-up timer, and setting the alarm time.</li>
				<li><strong class="bold">Interrupt handling</strong>: Enable the <a id="_idIndexMarker1325"/>RTC alarm or wake-up interrupt in the NVIC to ensure that the microcontroller wakes up when the alarm or timer event occurs.</li>
			</ul>
			<p><em class="italic">An example use case</em> is an <strong class="bold">environmental </strong><strong class="bold">monitoring system</strong>.</p>
			<p>Consider a remote<a id="_idIndexMarker1326"/> environmental monitoring system that logs temperature and humidity data. The microcontroller can be put into low-power mode, waking up at regular intervals (e.g., every hour) using RTC alarms to read sensors and log data, and then return to the low-power state.</p>
			<p>The final wake-up sources we will examine are <strong class="bold">internal events</strong>.</p>
			<h3>Internal events</h3>
			<p>Apart from external<a id="_idIndexMarker1327"/> triggers, internal events can also wake up a <a id="_idIndexMarker1328"/>microcontroller from low-power modes. These events include the following:</p>
			<ul>
				<li><strong class="bold">Peripheral events</strong>: Events <a id="_idIndexMarker1329"/>generated by internal peripherals, such as ADC conversions or communication interface activity</li>
				<li><strong class="bold">System events</strong>: Internal system events<a id="_idIndexMarker1330"/> such as power voltage detection or clock stability issues</li>
			</ul>
			<p>Here’s how it works:</p>
			<ul>
				<li><strong class="bold">Peripheral configuration</strong>: Configure the<a id="_idIndexMarker1331"/> peripheral to generate interrupts upon specific events. For instance, an ADC can generate an interrupt when a conversion is complete.</li>
				<li><strong class="bold">Event handling</strong>: Enable the<a id="_idIndexMarker1332"/> relevant interrupts in the NVIC to handle these internal events and wake the microcontroller.</li>
			</ul>
			<p><em class="italic">An example use case</em> is a <strong class="bold">fitness tracker</strong></p>
			<p>A wearable fitness tracker<a id="_idIndexMarker1333"/> that monitors heart rate can use the ADC to read sensor data. The microcontroller stays in a low-power mode and wakes up when the ADC completes a conversion, allowing it to process and store the heart rate data.</p>
			<p>Before we conclude this section, let’s summarize some key practical considerations to keep in mind when configuring wake-up sources.</p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor506"/>Practical considerations</h2>
			<p>When configuring wake-up sources, you must consider the<a id="_idIndexMarker1334"/> following practical aspects:</p>
			<ul>
				<li><strong class="bold">Response time</strong>: Ensure the chosen wake-up source can provide the required response time for your application. External interrupts typically offer the fastest wake-up times.</li>
				<li><strong class="bold">Power consumption</strong>: Balance power consumption with wake-up requirements. RTC alarms and watchdog timers can be configured for periodic wake-ups with minimal power overhead.</li>
				<li><strong class="bold">Reliability</strong>: Choose reliable wake-up sources for critical applications. Watchdog timers are essential for safety-critical systems to ensure that a microcontroller can recover from faults.</li>
				<li><strong class="bold">Peripheral configuration</strong>: Ensure that peripherals needed for wake-up are properly<a id="_idIndexMarker1335"/> configured and their clocks remain enabled, even in low-power states.</li>
			</ul>
			<p>Understanding and properly configuring these wake-up sources ensures that your embedded systems are both energy-efficient and reliable.</p>
			<p>In the next section, we will learn how to develop a driver to enter standby mode and subsequently wake up the system.</p>
			<h1 id="_idParaDest-317"><a id="_idTextAnchor507"/>Developing a driver to enter standby mode and wake up</h1>
			<p>Create a copy <a id="_idIndexMarker1336"/>of your previous project in your IDE, following the steps outlined in earlier chapters. <a id="_idTextAnchor508"/>Rename this copied project <code>StandByModeWithWakeupPin</code>. Next, create a new file named <code>standby_mode.c</code> in the <code>Src</code> f<a id="_idTextAnchor509"/>older, and then another file named <code>standby_mode.h</code> in the <code>Inc</code> folder.</p>
			<p>Populate your <code>standby_mode.c</code> file with the following code:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> "standby_mode.h"
<strong class="bold">#define</strong> PWR_MODE_STANDBY        (PWR_CR_PDDS)
<strong class="bold">#define</strong> WK_PIN                (1U&lt;&lt;0)
<strong class="bold">static void set_power_mode</strong>(uint32_t pwr_mode);
<strong class="bold">void wakeup_pin_init</strong>(<strong class="bold">void</strong>)
{
    //Enable clock for GPIOA
    RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    //Set PA0 as input pin
    GPIOA-&gt;MODER &amp;= ~(1U&lt;&lt;0);
    GPIOA-&gt;MODER &amp;= ~(1U&lt;&lt;1);
    //No pull
    GPIOA-&gt;PUPDR &amp;= ~(1U&lt;&lt;0);
    GPIOA-&gt;PUPDR &amp;= ~(1U&lt;&lt;1);
}</pre>			<p>This function <a id="_idIndexMarker1337"/>is responsible for configuring <code>PA0</code> to be used as a wake-up pin for exiting low-power mode. It sets <code>PA0</code> as an input pin by clearing the corresponding bits in the <code>GPIOA</code> mode register, and then it configures the pin with no pull-up or pull-down resistors:</p>
			<pre class="source-code">
void standby_wakeup_pin_setup(void)
{
    /*Wait for <strong class="bold">wakeup</strong> pin to be released*/
    while(get_wakeup_pin_state() == 0){}
    /*Disable <strong class="bold">wakeup</strong> pin*/
    PWR-&gt;CSR &amp;=~(1U&lt;&lt;8);
    /*Clear all <strong class="bold">wakeup</strong> flags*/
    PWR-&gt;CR |=(1U&lt;&lt;2);
    /*Enable <strong class="bold">wakeup</strong> pin*/
    PWR-&gt;CSR |=(1U&lt;&lt;8);
    /*Enter StandBy mode*/
    set_power_mode(PWR_MODE_STANDBY);
    /*Set SLEEPDEEP bit in the CortexM System Control Register*/
    SCB-&gt;SCR |=(1U&lt;&lt;2);
    /*Wait for interrupt*/
    __WFI();
}</pre>			<p>This function<a id="_idIndexMarker1338"/> prepares the microcontroller to enter standby mode and ensures that it can wake up via the configured wake-up pin. It begins by waiting for the wake-up pin to be released, ensuring that the pin is in a stable state before proceeding. The function then disables the wake-up pin to clear any residual settings, followed by clearing all wake-up flags to reset the wake-up status. After re-enabling the wake-up pin, the function sets the power mode to Standby by configuring the appropriate power control register. Finally, the function executes the WFI instruction, placing the microcontroller into standby mode until an interrupt occurs, triggering the wake-up process:</p>
			<pre class="source-code">
uint32_t get_wakeup_pin_state(void)
{
      return ((GPIOA-&gt;IDR &amp; WK_PIN) == WK_PIN);
}</pre>			<p>This function checks the current state of the wake-up pin (<code>PA0</code>). It reads the input data register (<code>IDR</code>) for <code>GPIOA</code> and performs a bitwise <code>AND</code> operation with the wake-up pin’s bit mask (<code>WK_PIN</code>). This operation isolates the state of <code>PA0</code>. The function then compares this result to the bit mask itself to determine whether the pin is high. If <code>PA0</code> is high, the function<a id="_idIndexMarker1339"/> returns <code>true</code>; otherwise, it returns <code>false</code>:</p>
			<pre class="source-code">
static void set_power_mode(uint32_t pwr_mode)
{
  MODIFY_REG(PWR-&gt;CR, (PWR_CR_PDDS | PWR_CR_LPDS | PWR_CR_FPDS | PWR_
  CR_LPLVDS | PWR_CR_MRLVDS), pwr_mode);
}</pre>			<p>This function configures the power mode of the STM32F4 microcontroller by modifying specific bits in <code>PWR_CR</code>. This function takes a parameter, <code>pwr_mode</code>, which specifies the desired power<a id="_idIndexMarker1340"/> mode settings. It uses the <code>MODIFY_REG</code> macro<a id="_idIndexMarker1341"/> to update the <code>PWR_CR</code> register, specifically<a id="_idIndexMarker1342"/> targeting the bits related to different <a id="_idIndexMarker1343"/>power modes<a id="_idIndexMarker1344"/> such as <strong class="bold">PDDS</strong> (<strong class="bold">Power Down Deepsleep</strong>), <strong class="bold">LPDS</strong> (<strong class="bold">Low-Power Deepsleep</strong>), <strong class="bold">FPDS</strong> (<strong class="bold">Flash Power Down in Stop Mode</strong>), <strong class="bold">LPLVDS</strong> (<strong class="bold">Low-Power Regulator in Low Voltage in Deepsleep</strong>), and <strong class="bold">MRLVDS</strong> (<strong class="bold">Main Regulator in Low Voltage </strong><strong class="bold">in Deepsleep</strong>).</p>
			<p>Next, we will populate the <code>standby_mode.h</code> file:</p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> STANDBY_MODE_H__
<strong class="bold">#define</strong> STANDBY_MODE_H__
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
uint32_t get_wakeup_pin_state(void);
void wakeup_pin_init(void);
void standby_wakeup_pin_setup(void);
<code>main.c</code>. Update your <code>main.c</code> file, as shown here:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> &lt;stdio.h&gt;
<strong class="bold">#include</strong> &lt;string.h&gt;
<strong class="bold">#include</strong> "standby_mode.h"
<strong class="bold">#include</strong> "gpio_exti.h"
<strong class="bold">#include "uart.h"</strong>
uint8_t g_btn_press;
<strong class="bold">static void check_reset_source</strong>(<strong class="bold">void</strong>);
<strong class="bold">int main</strong>(<strong class="bold">void</strong>)
{
    uart_init();
    wakeup_pin_init();
    /*Find reset source*/
    check_reset_source();
    /*Initialize EXTI*/
    pc13_exti_init();
    <strong class="bold">while</strong>(1)
    {
    }
}</pre>			<p>The <code>main</code> function starts by initializing the UART for serial communication with <code>uart_init</code>, ensuring that we can send debugging information to the serial port. Next, it configures the wake-up<a id="_idIndexMarker1346"/> pin by calling <code>wakeup_pin_init</code>, preparing the microcontroller to respond to external wake-up signals. The <code>check_reset_source</code> function is then called to determine the cause of the microcontroller’s reset, whether from standby mode or another source, and to handle any necessary<a id="_idIndexMarker1347"/> flag clearing. Following this, the <code>PC13</code> is initialized with <code>pc13_exti_init</code>. The function then enters an infinite <code>while(1)</code>, maintaining the program’s operational state and waiting for interrupts or events to occur:</p>
			<pre class="source-code">
static void check_reset_source(void)
{
        /*Enable clock access to PWR*/
         RCC-&gt;APB1ENR |= RCC_APB1ENR_PWREN;
      if ((PWR-&gt;CSR &amp; PWR_CSR_SBF) == (PWR_CSR_SBF))
      {
          /*Clear Standby flag*/
          PWR-&gt;CR |= PWR_CR_CSBF;
          printf("System resume from Standby.....\n\r");
          /*Wait for <strong class="bold">wakeup</strong> pin to be released*/
          while(get_wakeup_pin_state() == 0){}
      }
      /*Check and Clear <strong class="bold">Wakeup</strong> flag*/
      if((PWR-&gt;CSR &amp; PWR_CSR_WUF) == PWR_CSR_WUF )
      {
          PWR-&gt;CR |= PWR_CR_CWUF;
      }
}</pre>			<p>This function <a id="_idIndexMarker1348"/>determines the cause of the microcontroller’s reset and handles the necessary flags accordingly. It begins by enabling the clock for the power control (<code>PWR</code>) peripheral to ensure access to the power control and status registers. It then checks whether <a id="_idIndexMarker1349"/>the <code>PWR_CSR</code> register, which indicates that the system has resumed from standby mode. If the flag is set, it clears the SBF and prints a message, indicating that the system has resumed from standby. The function also waits for the wake-up pin to be released, ensuring that the pin is in a stable state. Additionally, it checks whether the Wakeup flag (<code>WUF</code>) is set and, if so, clears the flag to reset the wake-up status.</p>
			<p>This is the interrupt callback function:</p>
			<pre class="source-code">
static void exti_callback(void)
{
    standby_wakeup_pin_setup();
}</pre>			<p>And finally, we<a id="_idIndexMarker1350"/> have the interrupt handler:</p>
			<pre class="source-code">
void EXTI15_10_IRQHandler(void) {
    if((EXTI-&gt;PR &amp; LINE13)!=0)
    {
        /*Clear PR flag*/
        EXTI-&gt;PR |=LINE13;
        //Do something...
        exti_callback();
    }
}</pre>			<p>The <code>exti_callback</code> function, coupled with <code>EXTI15_10_IRQHandler</code>, ensures that the microcontroller properly handles external interrupts from the wake-up pin. The <code>exti_callback</code> function is a straightforward handler that calls <code>standby_wakeup_pin_setup</code>. The <code>EXTI15_10_IRQHandler</code> function is an interrupt service routine specifically for EXTI lines 15 to 10. It checks whether the interrupt was triggered by line 13 (associated with the wake-up pin), and if so, it clears the interrupt pending flag to acknowledge the interrupt. After clearing the flag, it calls <code>exti_callback</code> to handle the wake-up event.</p>
			<p>Now, let’s test the project!</p>
			<p>To test the project, start by pressing the blue push button to enter standby mode. Remember that <code>PA0</code> is configured as the wake-up pin and is active low. In normal mode, connect a jumper wire from <code>PA0</code> to the ground. To trigger a wake-up event, pull out the jumper wire and connect it to 3.3V, causing a change in logic that will wake the microcontroller from standby mode.</p>
			<p>To test on the microcontroller, simply build the project and run it.</p>
			<p>Open RealTerm and configure the <a id="_idIndexMarker1351"/>appropriate port and baud rate to view the printed message that confirms the system has resumed from standby mode.</p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor510"/>Summary</h2>
			<p>In this chapter, we delved into the critical aspects of power management and energy efficiency in embedded systems. Efficient power management is essential for prolonging battery life and ensuring optimal performance in embedded devices. We began by exploring various power management techniques, laying the foundation for understanding how to reduce power consumption in embedded systems.</p>
			<p>We then examined the different low-power modes available in STM32F4 microcontrollers, providing detailed insights into their configurations and applications. Then, we discussed the wake-up sources and triggers in STM32F4, which are essential to ensure that a microcontroller can promptly come out of low-power modes.</p>
			<p>Finally, we put theory into practice by developing a driver to enter standby mode and wake up the microcontroller.</p>
			<p>With this journey into bare-metal embedded C programming now complete, it’s important to acknowledge the profound expertise you’ve gained. By mastering the nuances of microcontroller architecture and the discipline of register-level programming, you’ve equipped yourself with the tools to create efficient and reliable embedded systems from the ground up. This book was designed to offer more than just technical instruction; it also aimed to instill a deeper understanding of the hardware and a methodical approach to firmware development. As you move forward, remember that true mastery in this field lies in the continuous application and refinement of these principles.</p>
		</div>
	</div>
</div>
</body></html>