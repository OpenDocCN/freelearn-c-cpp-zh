<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer134">
			<h1 id="_idParaDest-303" class="chapter-number"><a id="_idTextAnchor490"/>18</h1>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor491"/>Power Management and Energy Efficiency in Embedded Systems</h1>
			<p>In this chapter, we will delve into power management and energy efficiency in embedded systems, a critical aspect in today’s technology-driven world. Efficient power management is vital for prolonging battery life and ensuring optimal performance in embedded devices. This chapter aims to equip you with the necessary knowledge and skills to implement effective power management techniques in <span class="No-Break">your designs.</span></p>
			<p>We will begin by exploring various power management techniques, laying the foundation to understand how to reduce power consumption in embedded systems. Following this, we will examine the different sleep modes and low-power states available in STM32F4 microcontrollers, providing detailed insights into their configurations and applications. Then, we will discuss the wake-up sources and triggers in the STM32F4, which are essential to ensure that the microcontroller can respond promptly to external events. Finally, we will put theory into practice by developing a driver to enter standby mode and wake up the microcontroller, demonstrating how to apply these concepts in <span class="No-Break">real-world scenarios.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>An overview of power <span class="No-Break">management techniques</span></li>
				<li>Low-power modes <span class="No-Break">in STM32F4</span></li>
				<li>Wake-up sources and triggers <span class="No-Break">in STM32F4</span></li>
				<li><a id="_idTextAnchor492"/>Developing a driver to enter standby mode and <span class="No-Break">wake up</span></li>
			</ul>
			<p>By the end of this chapter, you will have a thorough understanding of power management in embedded systems and be able to implement energy-efficient designs using STM32F4 microcontrollers. This knowledge will enable you to create embedded systems that optimize power consumption and extend battery life, essential for <span class="No-Break">modern applications.</span></p>
			<h1 id="_idParaDest-305"><a id="_idTextAnchor493"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor494"/>An overview of power management techniques</h1>
			<p>In this section, we will explore the world of <a id="_idIndexMarker1254"/>power management techniques, a crucial aspect of embedded systems design. As our devices become more advanced and our expectations for battery life increase, understanding how to manage power effectively is more important than ever. Let’s dive into the various power management techniques and how they are implemented, taking a look at some case studies to see these techniques <span class="No-Break">in action.</span></p>
			<p>Power management in embedded systems involves a combination of hardware and software strategies designed to reduce energy consumption. This is particularly important for battery-powered devices, where efficient power usage can significantly extend battery life. The main<a id="_idIndexMarker1255"/> techniques we’ll cover include <strong class="bold">Dynamic Voltage and Frequency Scaling</strong> (<strong class="bold">DVFS</strong>), clock gating, power gating, and utilizing <span class="No-Break">low-power modes.</span></p>
			<p>Let’s start <span class="No-Break">with DVFS.</span></p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor495"/>Dynamic Voltage and Frequency Scaling (DVFS)</h2>
			<p>DVFS is a<a id="_idIndexMarker1256"/> method where the voltage and frequency of a <a id="_idIndexMarker1257"/>microcontroller are adjusted based on the workload. By lowering the voltage and frequency during periods of low activity, power consumption can be greatly reduced. Conversely, during periods of high demand, the voltage and frequency are increased to <span class="No-Break">ensure performance.</span></p>
			<h3>How is DVFS implemented?</h3>
			<p>In STM32 microcontrollers, DVFS can be<a id="_idIndexMarker1258"/> managed through specific power control registers. These registers allow a system to dynamically adjust the operating points based on the required performance levels. For example, the STM32F4 series has several power modes that can be configured to adjust the system clock and <span class="No-Break">core voltage.</span></p>
			<h3>An example use case – mobile phones</h3>
			<p>Mobile phones <a id="_idIndexMarker1259"/>are a prime example of DVFS in action. When a phone is idle, it reduces the CPU frequency and voltage to save the battery. As soon as you start using an app or playing a game, the CPU ramps up its frequency and voltage to provide the necessary performance. This balance between performance and power savings is what makes modern smartphones<a id="_idIndexMarker1260"/> <span class="No-Break">so efficient.</span></p>
			<p>Another common technique is <span class="No-Break">clock gating.</span></p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor496"/>Clock gating</h2>
			<p>Clock gating<a id="_idIndexMarker1261"/> is a technique <a id="_idIndexMarker1262"/>where the clock signal to certain parts of a microcontroller is turned off when they are not in use. This prevents unnecessary switching of transistors, which in turn <span class="No-Break">saves power.</span></p>
			<h3>How is clock gating implemented?</h3>
			<p>Clock gating is typically <a id="_idIndexMarker1263"/>controlled through clock control registers. In the STM32 series, each peripheral’s clock can be enabled or disabled individually using these registers. For instance, if a particular peripheral such as the ADC is not needed, its clock can be disabled to <span class="No-Break">save power.</span></p>
			<h3>An example use case – smart home devices</h3>
			<p>Smart home devices <a id="_idIndexMarker1264"/>such as smart thermostats or lights use clock gating to manage power efficiently. These devices spend a significant amount of time in a low-power state, waking up only to perform specific tasks. By gating the clock to unused peripherals, these devices can conserve energy and extend their <span class="No-Break">battery life.</span></p>
			<p>Another technique is <span class="No-Break">power gating.</span></p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor497"/>Power gating</h2>
			<p>Power gating<a id="_idIndexMarker1265"/> takes <a id="_idIndexMarker1266"/>power savings a step further by completely shutting off the power to certain parts of a microcontroller. This technique ensures zero power consumption for the <span class="No-Break">powered-down sections.</span></p>
			<h3>How is power gating implemented?</h3>
			<p>Power gating is more <a id="_idIndexMarker1267"/>complex than clock gating and often involves dedicated power management units within a microcontroller. These units control the power supply to various domains of the microcontroller. In STM32 microcontrollers, power gating can be configured using the power control registers to turn off specific peripherals, or even entire sections of <span class="No-Break">the microcontroller.</span></p>
			<h3>An example use case – wearable devices</h3>
			<p>Wearable<a id="_idIndexMarker1268"/> devices, such as fitness trackers, benefit greatly from power gating. These devices need to operate for extended periods on a single charge. By powering down sensors and other components when they are not in use, wearables can achieve longer battery life without <span class="No-Break">compromising functionality.</span></p>
			<p>Next, let’s discuss <span class="No-Break">low-power modes.</span></p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor498"/>Low-power modes</h2>
			<p>Low-power modes<a id="_idIndexMarker1269"/> are predefined states within microcontrollers that significantly<a id="_idIndexMarker1270"/> reduce power consumption by disabling or reducing the functionality of various components. These modes range from simple CPU sleep modes to more complex deep sleep or <span class="No-Break">standby modes.</span></p>
			<h3>How are low-power modes implemented?</h3>
			<p>Low-power modes are <a id="_idIndexMarker1271"/>implemented through the power control registers. The STM32F4 microcontrollers, for example, offer several low-power<a id="_idIndexMarker1272"/> modes, including <strong class="bold">sleep</strong>, <strong class="bold">stop</strong>, and <strong class="bold">standby</strong>. Each<a id="_idIndexMarker1273"/> mode <a id="_idIndexMarker1274"/>provides a different balance between power savings and <span class="No-Break">wake-up time.</span></p>
			<h3>An example use case – remote sensors</h3>
			<p>Remote<a id="_idIndexMarker1275"/> sensors used in agriculture or environmental monitoring often use low-power modes. These sensors might spend the majority of their time in a low-power state, waking up periodically to take measurements and transmit data. By leveraging low-power modes, these sensors can operate for months or<a id="_idIndexMarker1276"/> even years on a single <span class="No-Break">battery charge.</span></p>
			<p>Now, let’s take a closer look at a couple of case studies that illustrate how a combination of these power management techniques is used in <span class="No-Break">real-world applications.</span></p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor499"/>Case study 1 – an energy-efficient smartwatch</h2>
			<p>Smartwatches are <a id="_idIndexMarker1277"/>a great example of a device that relies heavily on power management techniques. These devices need to balance performance with battery life, as users expect them to run for days on a single charge. Let’s break down the roles the different techniques play in an energy-efficient <span class="No-Break">smartwatch design:</span></p>
			<ul>
				<li><strong class="bold">DVFS</strong>: The smartwatch uses DVFS<a id="_idIndexMarker1278"/> to adjust the CPU frequency based on the current workload. When the user interacts with the watch, the CPU frequency increases to provide a smooth experience. When the watch is idle, the frequency is lowered to <span class="No-Break">save power.</span></li>
				<li><strong class="bold">Clock gating</strong>: Peripherals such as the GPS or heart rate monitor are only powered when needed. When<a id="_idIndexMarker1279"/> these features are not in use, their clocks are gated to <span class="No-Break">conserve energy.</span></li>
				<li><strong class="bold">Power gating</strong>: Components like the<a id="_idIndexMarker1280"/> display driver are powered down completely when the display <span class="No-Break">is off.</span></li>
				<li><strong class="bold">Low-power modes</strong>: The <a id="_idIndexMarker1281"/>watch enters deep sleep mode during periods of inactivity, waking up only to check for notifications or <span class="No-Break">user interactions.</span></li>
			</ul>
			<p>By combining these techniques, smartwatches can achieve impressive battery life without compromising on functionality. Another excellent example is solar-powered <span class="No-Break">environmental monitoring.</span></p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor500"/>Case study 2 – a solar-powered environmental monitor</h2>
			<p>A<a id="_idIndexMarker1282"/> solar-powered environmental monitor deployed in remote locations must operate efficiently to ensure continuous data collection and transmission. The roles are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">DVFS</strong>: The monitor adjusts its operating frequency based on the intensity of sunlight and battery <a id="_idIndexMarker1283"/>charge. During peak sunlight hours, it operates at a higher frequency to process <span class="No-Break">more data.</span></li>
				<li><strong class="bold">Clock gating</strong>: Sensors such as <a id="_idIndexMarker1284"/>temperature, humidity, and air quality are only active during data collection intervals. The clocks to these sensors are gated when not <span class="No-Break">in use.</span></li>
				<li><strong class="bold">Power gating</strong>: Non-essential components are completely powered down during nighttime or <a id="_idIndexMarker1285"/>cloudy periods to <span class="No-Break">conserve energy.</span></li>
				<li><strong class="bold">Low-power modes</strong>: The <a id="_idIndexMarker1286"/>monitor enters deep sleep mode between data collection intervals, waking up periodically to take measurements and <span class="No-Break">transmit data.</span></li>
			</ul>
			<p>With these power management techniques, the monitor can operate autonomously for extended periods, relying solely on <span class="No-Break">solar power.</span></p>
			<p>Power management is a vital aspect of embedded system design, especially as devices become more portable and battery-dependent. By understanding and implementing techniques such as DVFS, clock gating, power gating, and low-power modes, we can design embedded systems that are both powerful and energy-efficient. Whether it’s a smartwatch, a remote sensor, or any other battery-powered device, effective power management ensures longer battery life and better overall performance. As we continue to push the boundaries of what embedded systems can do, mastering these power management techniques will be more important <span class="No-Break">than ever.</span></p>
			<p>In the next section, we will explore the low-power modes in our <span class="No-Break">STM32F4 microcontroller.</span></p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor501"/>Low-power modes in STM32F4</h2>
			<p>In this <a id="_idIndexMarker1287"/>section, we will learn about the low-power modes <a id="_idIndexMarker1288"/>available in STM32F4 microcontrollers. We’ll cover the various low-power modes, how to configure them, and the practical aspects of using them in <span class="No-Break">your projects.</span></p>
			<p>Let’s start by understanding these low-power modes. Low-power modes in the STM32F4 microcontrollers are designed to reduce power consumption by disabling or limiting the functionality of certain components. The STM32F4 offers several low-power states, each providing a different balance between power savings and wake-up latency. These modes include sleep, stop, and <span class="No-Break">standby modes.</span></p>
			<p>We can put our system into low-power <a id="_idIndexMarker1289"/>mode by executing <a id="_idIndexMarker1290"/>the<strong class="bold"> Wait For</strong> <strong class="bold">Interrupt</strong> (<strong class="bold">WFI</strong>) or <strong class="bold">Wait For Event </strong>(<strong class="bold">WFE</strong>) instructions, or setting the <strong class="source-inline">SLEEPONEXIT</strong> bit in the <strong class="bold">Cortex®-M4 with FPU system control register</strong> on <a id="_idIndexMarker1291"/>return from <span class="No-Break">an ISR.</span></p>
			<p>Let’s dive into the details of each low-power mode, starting with <span class="No-Break">sleep mode.</span></p>
			<h4>Sleep mode</h4>
			<p>Sleep mode<a id="_idIndexMarker1292"/> is the <a id="_idIndexMarker1293"/>most basic low-power mode, where the CPU clock is stopped but peripherals continue to operate. This mode offers <a id="_idIndexMarker1294"/>a <strong class="bold">quick wake-up time</strong>, making it ideal for applications that require frequent transitions between active and <span class="No-Break">low-power states.</span></p>
			<p>To enter sleep mode, we need to clear the <strong class="source-inline">SLEEPDEEP</strong> bit in the <strong class="bold">System Control Register</strong> (<strong class="bold">SCR</strong>) and then<a id="_idIndexMarker1295"/> execute the WFI or WFE instruction, as shown in the <span class="No-Break">following snippet:</span></p>
			<pre class="source-code">
void enter_sleep_mode(void) {
    // Clear the SLEEPDEEP bit to enter Sleep mode
    SCB-&gt;SCR &amp;= ~SCB_SCR_SLEEPDEEP_Msk;
    // Request Wait For Interrupt
    __WFI();
}</pre>			<p>The microcontroller <strong class="bold">exits Sleep mode upon any interrupt or event</strong>. Since the peripherals remain active, any configured interrupt from a peripheral can wake <span class="No-Break">the CPU.</span></p>
			<p>An example use case<a id="_idIndexMarker1296"/> is <span class="No-Break"><strong class="bold">sensor monitoring</strong></span><span class="No-Break">.</span></p>
			<p>For applications such as <a id="_idIndexMarker1297"/>continuous sensor monitoring, sleep <a id="_idIndexMarker1298"/>mode provides an efficient way to reduce power consumption without sacrificing responsiveness. The microcontroller can wake up quickly to process sensor data and then return to <span class="No-Break">sleep mode.</span></p>
			<p>The next mode is <span class="No-Break">stop mode.</span></p>
			<h4>Stop mode</h4>
			<p>Stop mode offers<a id="_idIndexMarker1299"/> a <strong class="bold">deeper power-saving state than sleep mode</strong> by stopping <a id="_idIndexMarker1300"/>the main internal regulator and halting the system clock. Only the low-speed clock (LSI or LSE) remains active. This mode provides a <strong class="bold">moderate wake-up time</strong> and <a id="_idIndexMarker1301"/>significant <span class="No-Break">power savings.</span></p>
			<p>To enter stop mode, set the <strong class="source-inline">SLEEPDEEP</strong> bit in<a id="_idIndexMarker1302"/> the <strong class="bold">Power Control Register</strong><strong class="source-inline"> </strong>(<strong class="source-inline">PWR_CR</strong>), and then execute the WFI or WFE instruction, as shown in the following snippet. Additional configuration can also be applied to further reduce power consumption in <span class="No-Break">stop mode:</span></p>
			<pre class="source-code">
void enter_stop_mode(void) {
    // Set SLEEPDEEP bit to enable deep sleep mode
    SCB-&gt;SCR |= SCB_SCR_SLEEPDEEP_Msk;
    // Request Wait For Interrupt
    __WFI();
}</pre>			<p>The MCU exits stop mode upon<a id="_idIndexMarker1303"/> any <strong class="bold">external interrupt</strong> or <strong class="bold">wake-up event from</strong><strong class="bold"> </strong><strong class="bold">configured EXTI lines</strong>, <strong class="bold">RTC alarms</strong>, or other configured wake-up sources. The wake-up time from stop mode is longer than from sleep mode, but it still allows for a relatively quick return to <span class="No-Break">full </span><span class="No-Break"><a id="_idIndexMarker1304"/></span><span class="No-Break">operation.</span></p>
			<p>An example use <a id="_idIndexMarker1305"/>case is <strong class="bold">periodic </strong><span class="No-Break"><strong class="bold">data logging</strong></span><span class="No-Break">.</span></p>
			<p>In applications <a id="_idIndexMarker1306"/>such as data logging, a microcontroller can remain in<a id="_idIndexMarker1307"/> stop mode and wake up periodically, based on RTC alarms, to log data, and then return to stop mode. This significantly reduces power consumption while ensuring regular <span class="No-Break">data logging.</span></p>
			<p>The final mode is <span class="No-Break">standby mode.</span></p>
			<h4>Standby mode</h4>
			<p>Standby mode <a id="_idIndexMarker1308"/>provides<a id="_idIndexMarker1309"/> the <strong class="bold">highest power savings</strong> by turning off most internal circuitry, including the main regulator. Only a small portion of the microcontroller remains powered to monitor wake-up sources. This mode <a id="_idIndexMarker1310"/>has the <strong class="bold">longest wake-up time</strong> but offers the lowest <span class="No-Break">power consumption.</span></p>
			<p>To enter standby mode, set the <strong class="source-inline">PDDS</strong> and <strong class="source-inline">SLEEPDEEP</strong> bits in the Power Control (<strong class="source-inline">PWR_CR</strong>) register, and then configure the wake-up sources. This snippet demonstrates how to enter <span class="No-Break">standby mode:</span></p>
			<pre class="source-code">
void enter_standby_mode(void) {
    // Clear Wakeup flag
    PWR-&gt;CR |= PWR_CR_CWUF;
    // Set the PDDS bit to enter Standby mode
    PWR-&gt;CR |= PWR_CR_PDDS;
    // Set the SLEEPDEEP bit to enable deep sleep mode
    SCB-&gt;SCR |= SCB_SCR_SLEEPDEEP_Msk;
    // Request Wait For Interrupt
    __WFI();
}</pre>			<p>The microcontroller exits standby mode upon a <strong class="bold">wake-up event from an external wake-up pin (WKUP)</strong>, an RTC alarm, or a reset event. When the microcontroller wakes up from standby mode, it <strong class="bold">undergoes a full reset sequence</strong>, and the execution starts from the <span class="No-Break">reset vector.</span></p>
			<p>An example use <a id="_idIndexMarker1311"/>case is <strong class="bold">remote </strong><span class="No-Break"><strong class="bold">IoT devices</strong></span><span class="No-Break">.</span></p>
			<p>Standby <a id="_idIndexMarker1312"/>mode is perfect for remote IoT devices that need to operate for extended periods on battery power. These devices can remain in standby mode most of the time and wake up only for critical events or scheduled tasks, thus maximizing <span class="No-Break">battery life.</span></p>
			<p>Now that we understand how to enter the various low-power modes, we will look at how to wake up <span class="No-Break">from them.</span></p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor502"/>Wake-up sources and triggers from low-power modes in STM32F4</h1>
			<p>While low-power modes help conserve energy, ensuring that a microcontroller can wake up promptly when needed is equally important. The STM32F4 microcontroller series provides a variety of wake-up sources and triggers to handle this effectively. In this section, we’ll explore these wake-up sources, how they function, and their <span class="No-Break">practical applications.</span></p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor503"/>Understanding wake-up sources</h2>
			<p>Wake-up sources are mechanisms <a id="_idIndexMarker1313"/>that bring a microcontroller out of a low-power state. The STM32F4 offers several types of wake-up sources, each suited for different scenarios. These include external interrupts, RTC alarms, watchdog timers, and various internal events. By understanding these triggers, we can design systems that balance power efficiency <span class="No-Break">with responsiveness.</span></p>
			<p>The wake-up sources can be grouped <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break">External interrupts</span></li>
				<li><strong class="bold">Real-Time Clock</strong> (<span class="No-Break"><strong class="bold">RTC</strong></span><span class="No-Break">) alarms</span></li>
				<li><span class="No-Break">Internal events</span></li>
			</ul>
			<p>Let’s delve into each of these wake-up sources to understand how they work and their typical <span class="No-Break">use cases.</span></p>
			<h3>External interrupts</h3>
			<p>External interrupts<a id="_idIndexMarker1314"/> are one of <a id="_idIndexMarker1315"/>the primary wake-up sources for STM32F4 microcontrollers. These interrupts can be triggered by events on specific GPIO pins. When a microcontroller is in a low-power mode, an external signal, such as a button press or sensor output, can wake <span class="No-Break">it up.</span></p>
			<p>Here’s how <span class="No-Break">it works:</span></p>
			<ul>
				<li><strong class="bold">GPIO configuration</strong>: Configure the <a id="_idIndexMarker1316"/>GPIO pins to act as interrupt sources. This involves setting pin mode and enabling the interrupt on the desired edge (rising, falling, <span class="No-Break">or both).</span></li>
				<li><strong class="bold">EXTI configuration</strong>: Each<a id="_idIndexMarker1317"/> GPIO pin can be mapped to an EXTI line, which can be configured to generate <span class="No-Break">an interrupt.</span></li>
				<li><strong class="bold">NVIC configuration</strong>: Enable the <a id="_idIndexMarker1318"/>EXTI line interrupt in the <strong class="bold">Nested Vectored Interrupt Controller</strong> (<strong class="bold">NVIC</strong>) to ensure that the <a id="_idIndexMarker1319"/>microcontroller responds to the <span class="No-Break">external event.</span></li>
			</ul>
			<p>Example us<a id="_idTextAnchor504"/>e cases are a <strong class="bold">smart doorbell system and </strong><span class="No-Break"><strong class="bold">smart lighting</strong></span><span class="No-Break">.</span></p>
			<p>Imagine a <a id="_idIndexMarker1320"/>smart doorbell system. The microcontroller remains in a low-power mode to conserve battery life. When someone presses the doorbell button (connected to a GPIO pin), an external interrupt is triggered, waking the microcontroller to process the event and send a notification to the homeowner. Another excellent example is smart home <span class="No-Break">lighting systems.</span></p>
			<p>A smart home lighting system<a id="_idIndexMarker1321"/> needs to conserve energy while being responsive to user inputs. The microcontroller stays in a low-power mode until an external interrupt (e.g., a motion sensor detecting movement) wakes it up. Upon waking, the microcontroller processes the event, turns on the lights, a<a id="_idTextAnchor505"/>nd then goes back to sleep after a predefined period <span class="No-Break">of inactivity.</span></p>
			<p>The next wake-up source we will examine is the <span class="No-Break">RTC Alarm.</span></p>
			<h3>RTC alarms</h3>
			<p>The RTC is a versatile peripheral <a id="_idIndexMarker1322"/>that can generate wake-up events at specific intervals or predefined times. It is particularly useful for applications requiring periodic <a id="_idIndexMarker1323"/>wake-ups, such as data logging or <span class="No-Break">scheduled tasks.</span></p>
			<p>Here’s how <span class="No-Break">it works:</span></p>
			<ul>
				<li><strong class="bold">RTC configuration</strong>: Configure the RTC to generate alarms or periodic wake-up events. This involves setting the <a id="_idIndexMarker1324"/>RTC clock source, enabling the wake-up timer, and setting the <span class="No-Break">alarm time.</span></li>
				<li><strong class="bold">Interrupt handling</strong>: Enable the <a id="_idIndexMarker1325"/>RTC alarm or wake-up interrupt in the NVIC to ensure that the microcontroller wakes up when the alarm or timer <span class="No-Break">event occurs.</span></li>
			</ul>
			<p><em class="italic">An example use case</em> is an <strong class="bold">environmental </strong><span class="No-Break"><strong class="bold">monitoring system</strong></span><span class="No-Break">.</span></p>
			<p>Consider a remote<a id="_idIndexMarker1326"/> environmental monitoring system that logs temperature and humidity data. The microcontroller can be put into low-power mode, waking up at regular intervals (e.g., every hour) using RTC alarms to read sensors and log data, and then return to the <span class="No-Break">low-power state.</span></p>
			<p>The final wake-up sources we will examine are <span class="No-Break"><strong class="bold">internal events</strong></span><span class="No-Break">.</span></p>
			<h3>Internal events</h3>
			<p>Apart from external<a id="_idIndexMarker1327"/> triggers, internal events can also wake up a <a id="_idIndexMarker1328"/>microcontroller from low-power modes. These events include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Peripheral events</strong>: Events <a id="_idIndexMarker1329"/>generated by internal peripherals, such as ADC conversions or communication <span class="No-Break">interface activity</span></li>
				<li><strong class="bold">System events</strong>: Internal system events<a id="_idIndexMarker1330"/> such as power voltage detection or clock <span class="No-Break">stability issues</span></li>
			</ul>
			<p>Here’s how <span class="No-Break">it works:</span></p>
			<ul>
				<li><strong class="bold">Peripheral configuration</strong>: Configure the<a id="_idIndexMarker1331"/> peripheral to generate interrupts upon specific events. For instance, an ADC can generate an interrupt when a conversion <span class="No-Break">is complete.</span></li>
				<li><strong class="bold">Event handling</strong>: Enable the<a id="_idIndexMarker1332"/> relevant interrupts in the NVIC to handle these internal events and wake <span class="No-Break">the microcontroller.</span></li>
			</ul>
			<p><em class="italic">An example use case</em> is a <span class="No-Break"><strong class="bold">fitness tracker</strong></span></p>
			<p>A wearable fitness tracker<a id="_idIndexMarker1333"/> that monitors heart rate can use the ADC to read sensor data. The microcontroller stays in a low-power mode and wakes up when the ADC completes a conversion, allowing it to process and store the heart <span class="No-Break">rate data.</span></p>
			<p>Before we conclude this section, let’s summarize some key practical considerations to keep in mind when configuring <span class="No-Break">wake-up sources.</span></p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor506"/>Practical considerations</h2>
			<p>When configuring wake-up sources, you must consider the<a id="_idIndexMarker1334"/> following <span class="No-Break">practical aspects:</span></p>
			<ul>
				<li><strong class="bold">Response time</strong>: Ensure the chosen wake-up source can provide the required response time for your application. External interrupts typically offer the fastest <span class="No-Break">wake-up times.</span></li>
				<li><strong class="bold">Power consumption</strong>: Balance power consumption with wake-up requirements. RTC alarms and watchdog timers can be configured for periodic wake-ups with minimal <span class="No-Break">power overhead.</span></li>
				<li><strong class="bold">Reliability</strong>: Choose reliable wake-up sources for critical applications. Watchdog timers are essential for safety-critical systems to ensure that a microcontroller can recover <span class="No-Break">from faults.</span></li>
				<li><strong class="bold">Peripheral configuration</strong>: Ensure that peripherals needed for wake-up are properly<a id="_idIndexMarker1335"/> configured and their clocks remain enabled, even in <span class="No-Break">low-power states.</span></li>
			</ul>
			<p>Understanding and properly configuring these wake-up sources ensures that your embedded systems are both energy-efficient <span class="No-Break">and reliable.</span></p>
			<p>In the next section, we will learn how to develop a driver to enter standby mode and subsequently wake up <span class="No-Break">the system.</span></p>
			<h1 id="_idParaDest-317"><a id="_idTextAnchor507"/>Developing a driver to enter standby mode and wake up</h1>
			<p>Create a copy <a id="_idIndexMarker1336"/>of your previous project in your IDE, following the steps outlined in earlier chapters. <a id="_idTextAnchor508"/>Rename this copied project <strong class="source-inline">StandByModeWithWakeupPin</strong>. Next, create a new file named <strong class="source-inline">standby_mode.c</strong> in the <strong class="source-inline">Src</strong> f<a id="_idTextAnchor509"/>older, and then another file named <strong class="source-inline">standby_mode.h</strong> in the <span class="No-Break"><strong class="source-inline">Inc</strong></span><span class="No-Break"> folder.</span></p>
			<p>Populate your <strong class="source-inline">standby_mode.c</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> "standby_mode.h"
<strong class="bold">#define</strong> PWR_MODE_STANDBY        (PWR_CR_PDDS)
<strong class="bold">#define</strong> WK_PIN                (1U&lt;&lt;0)
<strong class="bold">static void set_power_mode</strong>(uint32_t pwr_mode);
<strong class="bold">void wakeup_pin_init</strong>(<strong class="bold">void</strong>)
{
    //Enable clock for GPIOA
    RCC-&gt;AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    //Set PA0 as input pin
    GPIOA-&gt;MODER &amp;= ~(1U&lt;&lt;0);
    GPIOA-&gt;MODER &amp;= ~(1U&lt;&lt;1);
    //No pull
    GPIOA-&gt;PUPDR &amp;= ~(1U&lt;&lt;0);
    GPIOA-&gt;PUPDR &amp;= ~(1U&lt;&lt;1);
}</pre>			<p>This function <a id="_idIndexMarker1337"/>is responsible for configuring <strong class="source-inline">PA0</strong> to be used as a wake-up pin for exiting low-power mode. It sets <strong class="source-inline">PA0</strong> as an input pin by clearing the corresponding bits in the <strong class="source-inline">GPIOA</strong> mode register, and then it configures the pin with no pull-up or <span class="No-Break">pull-down resistors:</span></p>
			<pre class="source-code">
void standby_wakeup_pin_setup(void)
{
    /*Wait for <strong class="bold">wakeup</strong> pin to be released*/
    while(get_wakeup_pin_state() == 0){}
    /*Disable <strong class="bold">wakeup</strong> pin*/
    PWR-&gt;CSR &amp;=~(1U&lt;&lt;8);
    /*Clear all <strong class="bold">wakeup</strong> flags*/
    PWR-&gt;CR |=(1U&lt;&lt;2);
    /*Enable <strong class="bold">wakeup</strong> pin*/
    PWR-&gt;CSR |=(1U&lt;&lt;8);
    /*Enter StandBy mode*/
    set_power_mode(PWR_MODE_STANDBY);
    /*Set SLEEPDEEP bit in the CortexM System Control Register*/
    SCB-&gt;SCR |=(1U&lt;&lt;2);
    /*Wait for interrupt*/
    __WFI();
}</pre>			<p>This function<a id="_idIndexMarker1338"/> prepares the microcontroller to enter standby mode and ensures that it can wake up via the configured wake-up pin. It begins by waiting for the wake-up pin to be released, ensuring that the pin is in a stable state before proceeding. The function then disables the wake-up pin to clear any residual settings, followed by clearing all wake-up flags to reset the wake-up status. After re-enabling the wake-up pin, the function sets the power mode to Standby by configuring the appropriate power control register. Finally, the function executes the WFI instruction, placing the microcontroller into standby mode until an interrupt occurs, triggering the <span class="No-Break">wake-up process:</span></p>
			<pre class="source-code">
uint32_t get_wakeup_pin_state(void)
{
      return ((GPIOA-&gt;IDR &amp; WK_PIN) == WK_PIN);
}</pre>			<p>This function checks the current state of the wake-up pin (<strong class="source-inline">PA0</strong>). It reads the input data register (<strong class="source-inline">IDR</strong>) for <strong class="source-inline">GPIOA</strong> and performs a bitwise <strong class="source-inline">AND</strong> operation with the wake-up pin’s bit mask (<strong class="source-inline">WK_PIN</strong>). This operation isolates the state of <strong class="source-inline">PA0</strong>. The function then compares this result to the bit mask itself to determine whether the pin is high. If <strong class="source-inline">PA0</strong> is high, the function<a id="_idIndexMarker1339"/> returns <strong class="source-inline">true</strong>; otherwise, it <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
static void set_power_mode(uint32_t pwr_mode)
{
  MODIFY_REG(PWR-&gt;CR, (PWR_CR_PDDS | PWR_CR_LPDS | PWR_CR_FPDS | PWR_
  CR_LPLVDS | PWR_CR_MRLVDS), pwr_mode);
}</pre>			<p>This function configures the power mode of the STM32F4 microcontroller by modifying specific bits in <strong class="source-inline">PWR_CR</strong>. This function takes a parameter, <strong class="source-inline">pwr_mode</strong>, which specifies the desired power<a id="_idIndexMarker1340"/> mode settings. It uses the <strong class="source-inline">MODIFY_REG</strong> macro<a id="_idIndexMarker1341"/> to update the <strong class="source-inline">PWR_CR</strong> register, specifically<a id="_idIndexMarker1342"/> targeting the bits related to different <a id="_idIndexMarker1343"/>power modes<a id="_idIndexMarker1344"/> such as <strong class="bold">PDDS</strong> (<strong class="bold">Power Down Deepsleep</strong>), <strong class="bold">LPDS</strong> (<strong class="bold">Low-Power Deepsleep</strong>), <strong class="bold">FPDS</strong> (<strong class="bold">Flash Power Down in Stop Mode</strong>), <strong class="bold">LPLVDS</strong> (<strong class="bold">Low-Power Regulator in Low Voltage in Deepsleep</strong>), and <strong class="bold">MRLVDS</strong> (<strong class="bold">Main Regulator in Low Voltage </strong><span class="No-Break"><strong class="bold">in Deepsleep</strong></span><span class="No-Break">).</span></p>
			<p>Next, we will populate the <span class="No-Break"><strong class="source-inline">standby_mode.h</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong> STANDBY_MODE_H__
<strong class="bold">#define</strong> STANDBY_MODE_H__
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
uint32_t get_wakeup_pin_state(void);
void wakeup_pin_init(void);
void standby_wakeup_pin_setup(void);
<strong class="bold">#endif</strong></pre>			<p>We are now ready<a id="_idIndexMarker1345"/> to test inside <strong class="source-inline">main.c</strong>. Update your <strong class="source-inline">main.c</strong> file, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> &lt;stdio.h&gt;
<strong class="bold">#include</strong> &lt;string.h&gt;
<strong class="bold">#include</strong> "standby_mode.h"
<strong class="bold">#include</strong> "gpio_exti.h"
<strong class="bold">#include "uart.h"</strong>
uint8_t g_btn_press;
<strong class="bold">static void check_reset_source</strong>(<strong class="bold">void</strong>);
<strong class="bold">int main</strong>(<strong class="bold">void</strong>)
{
    uart_init();
    wakeup_pin_init();
    /*Find reset source*/
    check_reset_source();
    /*Initialize EXTI*/
    pc13_exti_init();
    <strong class="bold">while</strong>(1)
    {
    }
}</pre>			<p>The <strong class="source-inline">main</strong> function starts by initializing the UART for serial communication with <strong class="source-inline">uart_init</strong>, ensuring that we can send debugging information to the serial port. Next, it configures the wake-up<a id="_idIndexMarker1346"/> pin by calling <strong class="source-inline">wakeup_pin_init</strong>, preparing the microcontroller to respond to external wake-up signals. The <strong class="source-inline">check_reset_source</strong> function is then called to determine the cause of the microcontroller’s reset, whether from standby mode or another source, and to handle any necessary<a id="_idIndexMarker1347"/> flag clearing. Following this, the <strong class="bold">external interrupt</strong> (<strong class="bold">EXTI</strong>) for <strong class="source-inline">PC13</strong> is initialized with <strong class="source-inline">pc13_exti_init</strong>. The function then enters an infinite <strong class="bold">loop</strong>, <strong class="source-inline">while(1)</strong>, maintaining the program’s operational state and waiting for interrupts or events <span class="No-Break">to occur:</span></p>
			<pre class="source-code">
static void check_reset_source(void)
{
        /*Enable clock access to PWR*/
         RCC-&gt;APB1ENR |= RCC_APB1ENR_PWREN;
      if ((PWR-&gt;CSR &amp; PWR_CSR_SBF) == (PWR_CSR_SBF))
      {
          /*Clear Standby flag*/
          PWR-&gt;CR |= PWR_CR_CSBF;
          printf("System resume from Standby.....\n\r");
          /*Wait for <strong class="bold">wakeup</strong> pin to be released*/
          while(get_wakeup_pin_state() == 0){}
      }
      /*Check and Clear <strong class="bold">Wakeup</strong> flag*/
      if((PWR-&gt;CSR &amp; PWR_CSR_WUF) == PWR_CSR_WUF )
      {
          PWR-&gt;CR |= PWR_CR_CWUF;
      }
}</pre>			<p>This function <a id="_idIndexMarker1348"/>determines the cause of the microcontroller’s reset and handles the necessary flags accordingly. It begins by enabling the clock for the power control (<strong class="source-inline">PWR</strong>) peripheral to ensure access to the power control and status registers. It then checks whether <a id="_idIndexMarker1349"/>the <strong class="bold">standby flag</strong> (<strong class="bold">SBF</strong>) is set in the <strong class="source-inline">PWR_CSR</strong> register, which indicates that the system has resumed from standby mode. If the flag is set, it clears the SBF and prints a message, indicating that the system has resumed from standby. The function also waits for the wake-up pin to be released, ensuring that the pin is in a stable state. Additionally, it checks whether the Wakeup flag (<strong class="source-inline">WUF</strong>) is set and, if so, clears the flag to reset the <span class="No-Break">wake-up status.</span></p>
			<p>This is the interrupt <span class="No-Break">callback function:</span></p>
			<pre class="source-code">
static void exti_callback(void)
{
    standby_wakeup_pin_setup();
}</pre>			<p>And finally, we<a id="_idIndexMarker1350"/> have the <span class="No-Break">interrupt handler:</span></p>
			<pre class="source-code">
void EXTI15_10_IRQHandler(void) {
    if((EXTI-&gt;PR &amp; LINE13)!=0)
    {
        /*Clear PR flag*/
        EXTI-&gt;PR |=LINE13;
        //Do something...
        exti_callback();
    }
}</pre>			<p>The <strong class="source-inline">exti_callback</strong> function, coupled with <strong class="source-inline">EXTI15_10_IRQHandler</strong>, ensures that the microcontroller properly handles external interrupts from the wake-up pin. The <strong class="source-inline">exti_callback</strong> function is a straightforward handler that calls <strong class="source-inline">standby_wakeup_pin_setup</strong>. The <strong class="source-inline">EXTI15_10_IRQHandler</strong> function is an interrupt service routine specifically for EXTI lines 15 to 10. It checks whether the interrupt was triggered by line 13 (associated with the wake-up pin), and if so, it clears the interrupt pending flag to acknowledge the interrupt. After clearing the flag, it calls <strong class="source-inline">exti_callback</strong> to handle the <span class="No-Break">wake-up event.</span></p>
			<p>Now, let’s test <span class="No-Break">the project!</span></p>
			<p>To test the project, start by pressing the blue push button to enter standby mode. Remember that <strong class="source-inline">PA0</strong> is configured as the wake-up pin and is active low. In normal mode, connect a jumper wire from <strong class="source-inline">PA0</strong> to the ground. To trigger a wake-up event, pull out the jumper wire and connect it to 3.3V, causing a change in logic that will wake the microcontroller from <span class="No-Break">standby mode.</span></p>
			<p>To test on the microcontroller, simply build the project and <span class="No-Break">run it.</span></p>
			<p>Open RealTerm and configure the <a id="_idIndexMarker1351"/>appropriate port and baud rate to view the printed message that confirms the system has resumed from <span class="No-Break">standby mode.</span></p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor510"/>Summary</h2>
			<p>In this chapter, we delved into the critical aspects of power management and energy efficiency in embedded systems. Efficient power management is essential for prolonging battery life and ensuring optimal performance in embedded devices. We began by exploring various power management techniques, laying the foundation for understanding how to reduce power consumption in <span class="No-Break">embedded systems.</span></p>
			<p>We then examined the different low-power modes available in STM32F4 microcontrollers, providing detailed insights into their configurations and applications. Then, we discussed the wake-up sources and triggers in STM32F4, which are essential to ensure that a microcontroller can promptly come out of <span class="No-Break">low-power modes.</span></p>
			<p>Finally, we put theory into practice by developing a driver to enter standby mode and wake up <span class="No-Break">the microcontroller.</span></p>
			<p>With this journey into bare-metal embedded C programming now complete, it’s important to acknowledge the profound expertise you’ve gained. By mastering the nuances of microcontroller architecture and the discipline of register-level programming, you’ve equipped yourself with the tools to create efficient and reliable embedded systems from the ground up. This book was designed to offer more than just technical instruction; it also aimed to instill a deeper understanding of the hardware and a methodical approach to firmware development. As you move forward, remember that true mastery in this field lies in the continuous application and refinement of <span class="No-Break">these principles.</span></p>
		</div>
	</div>
</div>
</body></html>