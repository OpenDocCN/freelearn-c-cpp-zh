<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer073">
<h1 class="chapter-number" id="_idParaDest-302"><a id="_idTextAnchor876"/>20</h1>
<h1 id="_idParaDest-303"><a id="_idTextAnchor877"/>Removing Implementation Details Using the pImpl Pattern</h1>
<p><a id="_idTextAnchor878"/>This chapter will wrap up our quest to expand your C++ programming repertoire beyond core OOP concepts, with the objective of further empowering you to solve recurring types of coding problems, utilizing common design patterns. Incorporating design patterns in your coding can not only provide refined solutions but also contribute to easier code maintenance and provide for potential code reuse.</p>
<p>The next design pattern that we will learn how to implement effectively in C++ is the <strong class="bold">pImpl pattern</strong>.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Comprehending the pImpl pattern and how it reduces compile-time dependencies</li>
<li>Understanding how to implement the pImpl pattern in C++ using association and unique pointers</li>
<li>Recognizing performance issues relating to pImpl and necessary trade-offs</li>
</ul>
<p>By the end of this chapter, you will understand the pImpl pattern and how it can be used to separate implementation details from a class interface to reduce compiler dependencies. Adding an additional design pattern to your skillset will help you become a more valuable programmer. </p>
<p>Let’s increase our programming skillset by examining another common design pattern, the pImpl pattern.</p>
<h1 id="_idParaDest-304"><a id="_idTextAnchor879"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter20">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter20</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <strong class="source-inline">Chapter20</strong> in a file named <strong class="source-inline">Chp20-Ex1.cpp</strong> under the aforementioned GitHub directory. Some programs are in applicable subdirectories as indicated in the examples. </p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3CfQxhR">https://bit.ly/3CfQxhR</a>.</p>
<h1 id="_idParaDest-305"><a id="_idTextAnchor880"/><a id="_idTextAnchor881"/><a id="_idTextAnchor882"/>Understanding the pImpl pattern</h1>
<p>The <strong class="bold">pImpl pattern</strong> (<strong class="bold">p</strong>ointer to <strong class="bold">Impl</strong>ementation idiom) is a structural design<a id="_idIndexMarker1260"/> pattern<a id="_idIndexMarker1261"/> that separates<a id="_idIndexMarker1262"/> the implementation<a id="_idIndexMarker1263"/> of a class<a id="_idIndexMarker1264"/> from its public <a id="_idIndexMarker1265"/>interface. This<a id="_idIndexMarker1266"/> pattern<a id="_idIndexMarker1267"/> was originally<a id="_idIndexMarker1268"/> known as the <strong class="bold">Bridge pattern</strong> by the <strong class="bold">Gang of Four</strong> (<strong class="bold">GofF</strong>) and is also known as the <strong class="bold">Cheshire Cat</strong>, <strong class="bold">compiler-firewall idiom</strong>, <strong class="bold">d-pointer</strong>, <strong class="bold">opaque pointer</strong>, or <strong class="bold">Handle pattern</strong>.</p>
<p>The primary purpose of this pattern is to minimize compile-time dependencies. The result of reducing compile-time dependencies is that changes in a class definition (most notably, the private access region) will not send a wave of timely recompilations throughout a developing or deployed application. Instead, the necessary recompiled code can be isolated to the <em class="italic">implementation</em> of the class itself. The other pieces of the application that depend on the class definition will no longer be affected by recompilation.</p>
<p>Private members within a class definition can affect a class with respect to recompilation. This is because changing the data members can alter the size of an instance of that type. Also, private member functions must be matched by signature to function calls for overloading resolution as well as potential type conversions. </p>
<p>The manner in which traditional header (<strong class="source-inline">.h</strong> or <strong class="source-inline">.hpp</strong>) and source code files (<strong class="source-inline">.cpp</strong>) specify dependencies trigger recompilation. By removing the class inner implementation details from a class header file (and placing these details in a source file), we can remove many dependencies. We can change which header files are included in other header and source code files, streamlining the dependencies and hence the recompilation <a id="_idTextAnchor883"/>burden. </p>
<p>The pImpl pattern will compel<a id="_idIndexMarker1269"/> the following adjustments to a class definition:</p>
<ul>
<li>Private (non-virtual) members will instead be replaced by a pointer to a nested class type that includes the former private data members and methods. A forward declaration to the nested class will also be necessary.</li>
<li>The pointer to the implementation (<strong class="source-inline">pImpl</strong>) will be an association to which method calls of the class implementation will be delegated.</li>
<li>The revised class definition will exist in a header file for the class embracing this idiom. Any formerly included header files that this header file once depended upon will now be moved to instead be included in the source code file for this class.</li>
<li>Other classes including the header file of a pImpl class will now not face recompilation should the implementation of the class within its private access region be modified.</li>
<li>To effectively manage dynamic memory resources of the associated object that represents the implementation, we will use a unique pointer (smart pointer).</li>
</ul>
<p>The compilation freedom<a id="_idIndexMarker1270"/> within the revised class definition takes advantage of the fact that pointers only require a forward declaration of the class type of the pointer to compile. </p>
<p>Let’s move forward to first examine a basic, and then a refined, implementation of the pImpl pattern.</p>
<h1 id="_idParaDest-306"><a id="_idTextAnchor884"/>Implementing the pImpl pattern</h1>
<p>In order to implement<a id="_idIndexMarker1271"/> the pImpl pattern, we will need to revisit the typical header and source file composition. We will then replace the private members in a typical class definition with a pointer to the implementation, taking advantage of an association. The implementation will be encapsulated within a nested class of our target class. Our pImpl pointer will delegate all requests to our associated object that provides the inner class details or implementation.</p>
<p>The inner (nested) class<a id="_idIndexMarker1272"/> will be referred to as the <strong class="bold">implementation class</strong>. The original, now<a id="_idIndexMarker1273"/> outer, class will be<a id="_idIndexMarker1274"/> referred to as the <strong class="bold">target</strong> or <strong class="bold">interface class</strong>.</p>
<p>We will start by reviewing <a id="_idIndexMarker1275"/>the typical (non-pImpl pattern) file composition containing class definitions and member function definitions. </p>
<h2 id="_idParaDest-307"><a id="_idTextAnchor885"/>Organizing file and class contents to apply the pattern basics</h2>
<p>Let’s first review the organization<a id="_idIndexMarker1276"/> strategy of the typical C++ class<a id="_idIndexMarker1277"/> with respect to file placement<a id="_idIndexMarker1278"/> regarding the class definition and member function definitions. We will next consider the revised organization strategy of a class utilizing <a id="_idTextAnchor886"/>the pImpl pattern.</p>
<h3>Reviewing typical fil<a id="_idTextAnchor887"/><a id="_idTextAnchor888"/>e and class layout</h3>
<p>Let’s take a look<a id="_idIndexMarker1279"/> at a typical class definition<a id="_idIndexMarker1280"/> and how we previously <a id="_idIndexMarker1281"/>have organized a class<a id="_idIndexMarker1282"/> with respect to source and header files, such as in our discussions in <a href="B19087_05.xhtml#_idTextAnchor222"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring Classes in Detail</em>, and in <a href="B19087_15.xhtml#_idTextAnchor655"><em class="italic">Chapter 15</em></a>, <em class="italic">Testing Classes and Components</em>. </p>
<p>Recall that we organized each class into a header (<strong class="source-inline">.h</strong> or <strong class="source-inline">.hpp</strong>) file containing the class definition and inline function definitions, plus a corresponding source code (<strong class="source-inline">.cpp</strong>) file containing the non-inline member function definitions. Let’s review a familiar sample class definition, <strong class="source-inline">Person</strong>:</p>
<pre class="source-code">
#ifndef _PERSON_H  // preprocessor directives to avoid 
#define _PERSON_H  // multiple inclusion of header
using std::string;
<strong class="bold">class Person</strong>
{
private:
    string firstName, lastName, title;
    char middleInitial = '\0';   // in-class initialization
protected:
    void ModifyTitle(const string &amp;);
public:
    Person() = default;   // default constructor
    Person(const string &amp;, const string &amp;, char, 
           const string &amp;);  // alternate constructor
    // prototype not needed for default copy constructor
    // Person(const Person &amp;) = default;  // copy ctor
    virtual ~Person() = default;  // virtual destructor
    const string &amp;GetFirstName() const 
        { return firstName; }
    const string &amp;GetLastName() const { return lastName; }
    const string &amp;GetTitle() const { return title; }
    char GetMiddleInitial() const { return middleInitial; }
    virtu<a id="_idTextAnchor889"/>al void Print() const;
    virtual void IsA() const;
    virtual void Greeting(const string &amp;) const;
    Person &amp;operator=(const Person &amp;);  // overloaded op =
};
#endif</pre>
<p>In the aforementioned<a id="_idIndexMarker1283"/> header file (<strong class="source-inline">Person.h</strong>), we<a id="_idIndexMarker1284"/> have included<a id="_idIndexMarker1285"/> our class definition for <strong class="source-inline">Person</strong> as well as inline function<a id="_idIndexMarker1286"/> definitions for the class. Any larger inline function definitions not appearing within the class definition (indicated with the keyword <strong class="source-inline">inline</strong> in the prototype) would also appear in this file, after the class definition itself. Notice the use of preprocessor directives to ensure that a class definition is only included once per compilation unit.</p>
<p>Let’s next review the contents of the corresponding source code file, <strong class="source-inline">Person.cpp</strong>:</p>
<pre class="source-code">
#include &lt;iostream&gt;  // also incl. other relevant libraries
<strong class="bold">#include "Person.h"</strong>  // include the header file
using std::cout;     // preferred to: using namespace std;
using std::endl; 
using std::string;
<strong class="bold">// Include all the non-inline Person member functions</strong>
// The alt. constructor is one example of many in the file
Person::Person(const string &amp;fn, const string &amp;ln, char mi,
             const string &amp;t): firstName(fn), lastName(ln),
                               middleInitial(mi), title(t)
{
   // dynamically alloc. memory for any ptr data mbrs here
}</pre>
<p>In the previously defined source<a id="_idIndexMarker1287"/> code file, we define all the non-inline member functions <a id="_idIndexMarker1288"/>for the class, <strong class="source-inline">Person</strong>. Though not all methods<a id="_idIndexMarker1289"/> are shown, all can be<a id="_idIndexMarker1290"/> found in our GitHub code. Also, if the class definition contains any static data members, the definition of the external variables designating the memory for these members should be included in the source code file. </p>
<p>Let’s now consider how we can remove the implementation details from the <strong class="source-inline">Person</strong> class definition and its corresponding header file, by applying the pImpl pattern.</p>
<h3>Applying the pImpl pattern with<a id="_idTextAnchor890"/> revised class and file layout</h3>
<p>To employ the pImpl<a id="_idIndexMarker1291"/> pattern, we will reorganize our class definition<a id="_idIndexMarker1292"/> and its respective implementation. We will add a nested class within our existing class definition to represent the private members of our original class and the core of its implementation. Our outer class will include a pointer of the inner class type, serving as an association to our implementation. Our outer class will delegate all implementation requests to the inner, associated object. We will restructure the placement of classes and source code within the header and source code files. </p>
<p>Let’s take a closer look at our revised implementation for our class to understand each new detail required to implement the pImpl pattern. This example, composed of a source file <strong class="source-inline">PersonImpl.cpp</strong> and one header file <strong class="source-inline">Person.h</strong>, can be found in the same directory as a simple driver to test the pattern in our GitHub repository. To make a complete executable, you will need to compile and<a id="_idTextAnchor891"/> link together <strong class="source-inline">PersonImp.cpp</strong> and <strong class="source-inline">Chp20-Ex1.cpp</strong> (the driver), found in this same directory. Here is the GitHub repository URL for the driver:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/b<span id="_idTextAnchor892"/><span id="_idTextAnchor893"/>lob/main/Chapter20/Chp20-Ex1.cpp</a></p>
<pre class="source-code">
#ifndef _PERSON_H    <strong class="bold">// Person.h header file definition</strong>
#define _PERSON_H
<strong class="bold">class Person</strong>
{
private:
    <strong class="bold">class PersonImpl;</strong>  // forward declaration nested class
    <strong class="bold">PersonImpl *pImpl = nullptr;</strong> // ptr to implementation 
                                 // of class
protected:
    void ModifyTitle(const string &amp;);
public:
    Person();   // default constructor
    Person(const string &amp;, const string &amp;, char, 
           const string &amp;);
    Person(const Person &amp;);  // copy const. will be defined
    virtual ~Person();  // virtual destructor
    const string &amp;GetFirstName() const; // no longer inline
    const string &amp;GetLastName() const; 
    const string &amp;GetTitle() const; 
    char GetMiddleInitial() const; 
    virtual void Print() const;
    virtual void IsA() const;
    virtual void Greeting(const string &amp;) const;
    Person &amp;operator=(const Person &amp;);  // overloaded =
};
#endif</pre>
<p>In our aforementioned <a id="_idIndexMarker1293"/>revised class definition for <strong class="source-inline">Person</strong>, notice<a id="_idIndexMarker1294"/> that we have removed the data members in the private access region. Any non-virtual private methods, had they existed, would have also been removed. Instead, we include a forward declaration to our nested class with <strong class="source-inline">class PersonImpl;</strong>. We also declare a pointer to the implementation using <strong class="source-inline">PersonImpl *pImpl;</strong>, which represents an association to the nested class members encapsulating the implementation. In our initial implementation, we will use a native (raw) C++ pointer to specify the association to the nested class. We will subsequently revise our implementation to utilize a <em class="italic">unique pointer</em>.</p>
<p>Notice that our public interface for <strong class="source-inline">Person</strong> is much as before. All of our existing public and protected methods exist as expected, interface-wise. We notice, however, that the inline functions (which depend on the implementation of the data members) have been replaced with non-inline member function prototypes.</p>
<p>Let’s move forward to see the class definition for our nested class, <strong class="source-inline">PersonImpl</strong>, as well as the placement<a id="_idIndexMarker1295"/> of the member functions of <strong class="source-inline">PersonImpl</strong> and <strong class="source-inline">Person</strong> in a common source code file, <strong class="source-inline">PersonImpl.cpp</strong>. We will start with the nested <strong class="source-inline">PersonImpl</strong> class<a id="_idIndexMarker1296"/> definition:</p>
<pre class="source-code">
<strong class="bold">// PersonImpl.cpp source code file includes nested class</strong>
// Nested class definition supports implementation
<strong class="bold">class Person::PersonImpl</strong>
{
private:
    string firstName, lastName, title;
    char middleInitial = '\0';  // in-class initialization
public:
    PersonImpl() = default;   // default constructor
    PersonImpl(const string &amp;, const string &amp;, char, 
               const string &amp;);
    // Default copy ctor does not need to be prototyped
    // PersonImpl(const PersonImpl &amp;) = default;  
    virtual ~PersonImpl() = default;  // virtual destructor
    const string &amp;GetFirstName() const 
        { return firstName; }
    const string &amp;GetLastName() const { return lastName; }
    const string &amp;GetTitle() const { return title; }
    char GetMiddleInitial() const { return middleInitial; }
    void ModifyTitle(const string &amp;);
    virtual void Print() const;
    virtual void IsA()<a id="_idTextAnchor894"/> const { cout &lt;&lt; "Person" &lt;&lt; endl; }
    virtual void Greeting(const string &amp;msg) const
        { cout &lt;&lt; msg &lt;&lt; endl; }
    PersonImpl &amp;operator=(const PersonImpl &amp;); 
};</pre>
<p>In the previously mentioned nested class definition for <strong class="source-inline">PersonImpl</strong>, notice<a id="_idIndexMarker1297"/> that this class looks surprisingly similar to the original <a id="_idIndexMarker1298"/>class definition for <strong class="source-inline">Person</strong>. We have private data members and a full host of member function prototypes, even some inline functions written for brevity (which won’t actually be inlined because they are virtual). <strong class="source-inline">PersonImpl</strong> represents the implementation for <strong class="source-inline">Person</strong>, so it is crucial that this class can access all data and implement each method fully. Notice that the scope resolution operator (<strong class="source-inline">::</strong>) in the definition of <strong class="source-inline">class Person::PersonImpl</strong> is used to specify that <strong class="source-inline">PersonImpl</strong> is a nested class of <strong class="source-inline">Person</strong>.</p>
<p>Let’s continue by taking a look at the member function definitions for <strong class="source-inline">PersonImpl</strong>, which will appear in the same source file <strong class="source-inline">PersonImpl.cpp</strong> as the class definition. Though some methods have been abbreviated, their full online code is available in our GitHub repository:</p>
<pre class="source-code">
<strong class="bold">// File: PersonImpl.cpp</strong> - See online code for full methods 
// Nested class member functions. 
// Notice that the class name is Outer::Inner class
// Notice that we are using the system-supplied definitions
// for default constructor, copy constructor and destructor
// alternate constructor
<strong class="bold">Person::PersonImpl</strong>::PersonImpl(const string &amp;fn, 
             const string &amp;ln, char mi, const string &amp;t): 
             firstName(fn), lastName(ln), 
             middleInitial(mi), title(t)   
{
}
void <strong class="bold">Person::PersonImpl</strong>::ModifyTitle(const string &amp;newTitle)
{   
    title = newTitle;
}
void <strong class="bold">Person::PersonImpl</strong>::Print() const
{   // Print each data member as usual
}
// Note: same as default op=, but it is good to review what 
// is involved in implementing op= for upcoming discussion
Person::PersonImpl &amp;<strong class="bold">Person::PersonImpl</strong>::operator=
                             (const PersonImpl &amp;p)
{  
    if (this != &amp;p)  // check for self-assignment
    {
        firstName = p.firstName;
        lastName = p.lastName;
        middleInitial = p.middleInitial;
        title = p.title;
   }
   return *this;  // allow for cascaded assignments
}</pre>
<p>In the aforementioned code, we see the implementation for the overall <strong class="source-inline">Person</strong> class using<a id="_idIndexMarker1299"/> the nested class <strong class="source-inline">PersonImpl</strong>. We see the member function definitions for <strong class="source-inline">PersonImpl</strong> and notice that the bodies<a id="_idIndexMarker1300"/> of these methods are exactly how we previously implemented the methods in our original <strong class="source-inline">Person</strong> class without the pImpl pattern. Again, we notice the use of the scope resolution operator (<strong class="source-inline">::</strong>) to specify the class name for each member function definition, such as <strong class="source-inline">void Person::PersonImpl::Print() const</strong>. Here, <strong class="source-inline">Person::PersonImpl</strong> indicates the nested class of <strong class="source-inline">PersonImpl</strong> within the <strong class="source-inline">Person</strong> class. </p>
<p>Next, let’s take a moment to review the member function definitions for <strong class="source-inline">Person</strong>, our class employing the pImpl pattern. These methods will additionally contribute to the <strong class="source-inline">PersonImpl.cpp</strong> source code file and can be found in our GitHub repository:</p>
<pre class="source-code">
<strong class="bold">// Person member functions – also in PersonImpl.cpp</strong>
Person::Person(): <strong class="bold">pImpl(new PersonImpl())</strong>
{ // As shown, this is the complete member fn. definition
}
Person::Person(const string &amp;fn, const string &amp;ln, char mi,
               const string &amp;t): 
               <strong class="bold">pImpl(new PersonImpl(fn, ln, mi, t))</strong>
{ // As shown, this is the complete member fn. definition
}  
Person::Person(const Person &amp;p): 
               <strong class="bold">pImpl(new PersonImpl(*(p.pImpl)))</strong>
{  // This is the complete copy constructor definition
}  // No Person data members to copy from 'p' except deep
   // copy of *(p.pImpl) to data member pImpl
Person::~Person()
{
    <strong class="bold">delete pImpl;</strong>   // delete associated implementation
}
void Person::ModifyTitle(const string &amp;newTitle)
{   // delegate request to the implementation 
    <strong class="bold">pImpl-&gt;ModifyTitle(newTitle);</strong>  
}
const string &amp;Person::GetFirstName() const
{   // no longer inline in Person; 
    // non-inline method further hides implementation
    return <strong class="bold">pImpl-&gt;GetFirstName();</strong>
}
<strong class="bold">// Note: methods GetLastName(), GetTitle(), and  </strong>
<strong class="bold">// GetMiddleInitial() are implemented similar to</strong>
<strong class="bold">// GetFirstName(). See online code</strong>
void Person::Print() const
{
    <strong class="bold">pImpl-&gt;Print();</strong>   // delegate to implementation
}                     // (same named member function)
<strong class="bold">// Note: methods IsA() and Greeting() are implemented </strong>
<strong class="bold">// similarly to Print() – using delegation. See online code</strong>
Person &amp;Person::operator=(const Person &amp;p)
{  // delegate op= to implementation portion
   <strong class="bold">pImpl-&gt;operator=<a id="_idTextAnchor895"/>(*(p.pImpl));</strong> // call op= on impl. piece
   return *this;  // allow for cascaded assignments
}</pre>
<p>In the aforementioned member function<a id="_idIndexMarker1301"/> definitions for <strong class="source-inline">Person</strong>, we notice that all methods delegate the required<a id="_idIndexMarker1302"/> work to the nested class via the associated <strong class="source-inline">pImpl</strong>. In our constructors, we allocate the associated <strong class="source-inline">pImpl</strong> object and initialize it appropriately (using the member initialization list of each constructor). Our destructor is responsible for deleting the associated object using <strong class="source-inline">delete pImpl;</strong>.</p>
<p>Our <strong class="source-inline">Person</strong> copy constructor will set member <strong class="source-inline">pImpl</strong> to the newly allocated memory, while invoking the <strong class="source-inline">PersonImpl</strong> copy constructor for the nested object creation and initialization, passing <strong class="source-inline">*(p.pImpl)</strong> to the nested object’s copy constructor. That is, <strong class="source-inline">p.pImpl</strong> is a pointer, so we dereference the pointer using <strong class="source-inline">*</strong> to obtain a referenceable object for the <strong class="source-inline">PersonImpl</strong> copy constructor.</p>
<p>We use a similar strategy in our overloaded assignment operator for <strong class="source-inline">Person</strong>. That is, there are no data members other than <strong class="source-inline">pImpl</strong> to perform a deep assignment, so we merely call the <strong class="source-inline">PersonImpl</strong> assignment operator on associated object <strong class="source-inline">pImpl</strong>, again passing in <strong class="source-inline">*(p.pImpl)</strong> as the right-hand value.</p>
<p>Finally, let us consider a sample driver to demonstrate our pattern in action. Interestingly, our driver will work with either our originally specified non-pattern class (source and header files) or with our revised pImpl<a id="_idTextAnchor896"/> pattern-specific source and header files!</p>
<h3>Bringing the pattern components together </h3>
<p>Let’s finally take a look at our <strong class="source-inline">main()</strong> function<a id="_idIndexMarker1303"/> in our driver source file <strong class="source-inline">Chp20-Ex1.cpp</strong> to see how our pattern is orchestrated:</p>
<pre class="source-code">
#include &lt;iostream&gt;
<strong class="bold">#include "Person.h"</strong>
using std::cout;  // preferred to: using namespace std;
using std::endl;
constexpr int MAX = 3;
int main()
{
    Person *people[MAX] = { }; // initialized to nullptrs
    people[0] = new Person("Elle", "LeBrun", 'R',"Ms.");
    people[1] = new Person("Zack", "Moon", 'R', "Dr.");
    people[2] = new Person("Gabby", "Doone", 'A', "Dr.");
    for (auto *individual : people)
       individual-&gt;Print();
    for (auto *individual : people)
       delete individual;
    return 0;
}</pre>
<p>Reviewing our aforementioned <strong class="source-inline">main()</strong> function, we simply dynamically allocate several <strong class="source-inline">Person</strong> instances, call selected <strong class="source-inline">Person</strong> method(s) on the instances (<strong class="source-inline">Print()</strong>), and then delete each instance. We have included the <strong class="source-inline">Person.h</strong> header file, as expected, to be able to utilize this class. From the Client’s point of view, everything looks <em class="italic">as usual</em> and appears pattern unspecific.</p>
<p>Note that we separately compile <strong class="source-inline">PersonImp.cpp</strong> and <strong class="source-inline">Chp20-Ex1.cpp</strong>, linking the object files together<a id="_idIndexMarker1304"/> into an executable. However, due to the pImpl pattern, if we change the implementation for <strong class="source-inline">Person</strong>, the change will be encapsulated by its implementation in the <strong class="source-inline">PersonImp</strong> nested class. Only <strong class="source-inline">PersonImp.cpp</strong> will require recompilation. The Client will not need to recompile the driver, <strong class="source-inline">Chp20-Ex1.cpp</strong>, because the changes will not have occurred in the <strong class="source-inline">Person.h<a id="_idTextAnchor897"/><a id="_idTextAnchor898"/></strong> header file (which the driver depends on). </p>
<p>Let’s take a look at the output for this program:</p>
<p class="source-code">Ms. Elle R. LeBrun</p>
<p class="source-code">Dr. Zack R. Moon</p>
<p class="source-code">Dr. Gabby A. Doone</p>
<p>In the aforementioned output, we see the expected results of our simple driver. </p>
<p>Let’s move forward to consider how we may improve our implementation <a id="_idTextAnchor899"/><a id="_idTextAnchor900"/>of the pImpl pattern using a unique pointer.</p>
<h2 id="_idParaDest-308"><a id="_idTextAnchor901"/>Improving the pattern with a unique pointer</h2>
<p>Our initial implementation<a id="_idIndexMarker1305"/> using an association with a native C++ pointer<a id="_idIndexMarker1306"/> relieves many compiler dependencies. This is because the compiler only needs to see a forward class declaration of the pImpl pointer type in order to compile successfully. So far, we have achieved the core goal of using the pImpl pattern – reducing recompilation. </p>
<p>However, there is always criticism of using native or <em class="italic">raw</em> pointers. We are responsible for managing the memory ourselves, including remembering to delete the allocated nested class type in our outer class destructor. Memory leaks, memory misuse, and memory errors are potential drawbacks for managing memory resources ourselves with raw pointers. For that reason, it is customary<a id="_idIndexMarker1307"/> to implement the pImpl pattern using <strong class="bold">smart pointers</strong>.</p>
<p>We will continue<a id="_idIndexMarker1308"/> our quest to implement pImpl by examining<a id="_idIndexMarker1309"/> a key component often used with the pImpl pattern – smart pointers, or more specifically, the <strong class="source-inline">unique_ptr</strong>. </p>
<p>L<a id="_idTextAnchor902"/><a id="_idTextAnchor903"/>et’s start by understanding smart pointer basics.</p>
<h3>Understanding smart pointers</h3>
<p>To implement the pImpl pattern customarily, we<a id="_idIndexMarker1310"/> must first understand smart pointers. A <strong class="bold">smart pointer</strong> is a small wrapper class that encapsulates a raw pointer, ensuring that the pointer it contains is automatically deleted when the wrapper object goes out of scope. The class implementing the smart pointer can be implemented using templates to create a smart pointer for any data type. </p>
<p>Here is a very simple example of a smart<a id="_idTextAnchor904"/> pointer. This example can be found on our GitHub:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/Chp20-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Prog<span id="_idTextAnchor905"/>ramming-with-CPP/blob/main/Chapter20/Chp20-Ex2.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include "Person.h"
using std::cout;   // preferred to: using namespace std;
using std::endl;
template &lt;class Type&gt;
<strong class="bold">class SmartPointer</strong>
{
private:
    Type *pointer = nullptr;  // in-class initialization
public:
    // Below ctor also handles default construction 
    SmartPointer(Type *ptr = nullptr): pointer(ptr) { }
    virtual ~SmartPointer();  // allow specialized SmrtPtrs
    Type *operator-&gt;() { return pointer; }
    Type &amp;operator*() { return *pointer; }
};
SmartPointer::~SmartPointer()
{
    delete poin<a id="_idTextAnchor906"/>ter;
    cout &lt;&lt; "SmartPtr Destructor" &lt;&lt; endl;
}
int main()
{
    <strong class="bold">SmartPointer&lt;int&gt; p1(new<a id="_idTextAnchor907"/> int());</strong>
    <strong class="bold">SmartPointer&lt;Person&gt; pers<a id="_idTextAnchor908"/>1(new Person("Renee",</strong>
                               <strong class="bold">"Alexander", 'K', "Dr."));</strong>
    *p1 = 100;
    cout &lt;&lt; *p1 &lt;&lt; endl;
    (*pers1).Print();   // or use: pers1-&gt;Print();
    return 0;
}</pre>
<p>In the previously defined, straightforward <strong class="source-inline">SmartPointer</strong> class, we simply encapsulate a raw pointer. The key benefit<a id="_idIndexMarker1311"/> is that the <strong class="source-inline">SmartPointer</strong> destructor will ensure that the raw pointer is destructed when the wrapper object is popped off the stack (for local instances) or before the program terminates (for static and extern instances). Certainly, this class is basic, and we must determine the desired behaviors for the copy constructor and the assignment operator. That is, allow shallow copies/assignment, require deep copies/assignment, or disallow all copies/assignment. Nonetheless, we can now visualize the concept of a smart pointer.</p>
<p>Here is the output for our smart pointer example:</p>
<p class="source-code">100</p>
<p class="source-code">Dr. Renee K. Alexander</p>
<p class="source-code">SmartPtr Destructor</p>
<p class="source-code">SmartPtr Destructor</p>
<p>The aforementioned output shows<a id="_idIndexMarker1312"/> that the memory for each object contained within a <strong class="source-inline">SmartPointer</strong> is managed for us. We can quite easily see with the <strong class="source-inline">"SmartPtr Destructor"</strong> output strings that the destructor for each object is called on our behalf when the local objects in <a id="_idTextAnchor909"/><strong class="source-inline">main()</strong> go out of scope and are popped off the stack.</p>
<h3>Understanding unique pointers</h3>
<p>A <strong class="bold">unique pointer</strong>, specified as <strong class="source-inline">unique_ptr</strong> in the Standard C++ Library, is a type<a id="_idIndexMarker1313"/> of smart pointer that encapsulates exclusive ownership and access to a given heap memory resource. A <strong class="source-inline">unique_ptr</strong> cannot be duplicated; the owner of a <strong class="source-inline">unique_ptr</strong> will have sole use of that pointer. Owners of unique pointers can choose to move these pointers to other resources, but the repercussions are that the original resource will no longer contain the <strong class="source-inline">unique_ptr</strong>. We must <strong class="source-inline">#include &lt;memory&gt;</strong> to include the definition for <strong class="source-inline">unique_ptr</strong>.</p>
<p class="callout-heading">Additional types of smart pointers</p>
<p class="callout">Other types of smart pointers<a id="_idIndexMarker1314"/> are available in the Standard C++ Library, in addition to <strong class="source-inline">unique_ptr</strong>, such as <strong class="source-inline">weak_ptr</strong> and <strong class="source-inline">shared_ptr</strong>. These <a id="_idTextAnchor910"/>additional types of smart pointers will be explored in <a href="B19087_21.xhtml#_idTextAnchor920"><em class="italic">Chapter 21</em></a>, <em class="italic">Making C++ Safer</em>.</p>
<p>Modifying our smart pointer program to instead utilize <strong class="source-inline">unique_ptr</strong>, we now have the following:</p>
<pre class="source-code">
#include &lt;iostream&gt;
<strong class="bold">#include &lt;memory&gt;</strong>
<strong class="bold">#include "Person.h"</strong>
using std::cout;   // preferred to: using namespace std;
using std::endl;
using std::unique_ptr;
int main()
{
    <strong class="bold">unique_ptr&lt;int&gt; <a id="_idTextAnchor911"/>p1(new int());</strong>
    <strong class="bold">unique_ptr&lt;Person&gt; pers1(new Person("Renee", </strong>
<strong class="bold">                             "Alexander", 'K', "Dr."));</strong>
    *p1 = 100;
    cout &lt;&lt; *p1 &lt;&lt; endl;
    (*pers1).Print();   // or use: pers1-&gt;Print();
    return 0;
}</pre>
<p>Our output will be similar to the <strong class="source-inline">SmartPointer</strong> example; the difference<a id="_idIndexMarker1315"/> is that no <strong class="source-inline">"SmartPtr Destructor"</strong> call message will be displayed (as we are using a <strong class="source-inline">unique_ptr</strong> instead). Notice that because we included <strong class="source-inline">using std::unique_ptr;</strong>, we did not need to qualify <strong class="source-inline">unique_ptr</strong> with <strong class="source-inline">std::</strong> in the unique pointer declaration.</p>
<p>With this knowledge, let’s add unique pointers to our pImpl pattern. </p>
<h3>Adding unique pointers to the pattern</h3>
<p>To implement<a id="_idIndexMarker1316"/> the pImpl pattern using<a id="_idIndexMarker1317"/> a <strong class="source-inline">unique_ptr</strong>, we will make minimal changes to our previous implementation, starting with our <strong class="source-inline">Person.h</strong> header file. The full program example of our pImpl pattern utilizing a <strong class="source-inline">unique_ptr</strong> can be found in our GitHub repository and will additionally include a revised file for <strong class="source-inline">PersonImpl.cpp</strong>. Here is the URL for the driver, <strong class="source-inline">Chp20-Ex3.cpp</strong>; note the subdirectory, <strong class="source-inline">unique</strong>, in our GitHub repository for this complete example:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/unique/Chp20-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter20/unique/Chp20-Ex3.cpp</a></p>
<pre class="source-code">
#ifndef _PERSON_H    <strong class="bold">// Person.h header file definition</strong>
#define _PERSON_H
<strong class="bold">#include &lt;memory&gt;</strong>
class Person
{
private:
   <a id="_idTextAnchor912"/> <strong class="bold">class PersonImpl;</strong>  // forward declaration nested class
    <strong class="bold">std::unique_ptr&lt;PersonImpl&gt; pImpl;</strong> //unique ptr to impl
protected:
    void ModifyTitle(const string &amp;);
public:
    Person();   // default constructor
    Person(const string &amp;, const string &amp;, char, 
           const string &amp;);
    Person(const Person &amp;);  // copy constructor
    virtual ~Person();  // virtual destructor
    const string &amp;GetFirstName() const; // no longer inline
    const string &amp;GetLastName() const; 
    const string &amp;GetTitle() const; 
    char GetMiddleInitial() const; 
    virtual void Print() const;
    virtual void IsA() const;
    virtual void Greeting(const string &amp;) const;
    Person &amp;operator=(const Person &amp;);  // overloaded =
};
#endif</pre>
<p>Notice, in the revised aforementioned<a id="_idIndexMarker1318"/> class definition for <strong class="source-inline">Person</strong>, the unique pointer declaration<a id="_idIndexMarker1319"/> of <strong class="source-inline">std::unique_ptr&lt;PersonImpl&gt; pImpl;</strong>. Here, we use the <strong class="source-inline">std::</strong> qualifier because the standard namespace has not been explicitly included in our header file. We also <strong class="source-inline">#include &lt;memory&gt;</strong> to gain the definition for <strong class="source-inline">unique_ptr</strong>. The remainder of the class is identical to our initial implementation of pImpl using an association implemented with a raw pointer.</p>
<p>Next, let’s understand the extent to which our source code needs to be modified from our initial pImpl implementation. Let’s now take a look at the necessary modified member functions in our source file, <strong class="source-inline">PersonImpl.cpp</strong>:</p>
<pre class="source-code">
<strong class="bold">// Source file PersonImpl.cpp</strong>
// Person destructor no longer needs to delete pImpl member
// and hence can simply be the default destructor!
// Note: prototyped with virtual in header file.
Person::~Person() = default;
<strong class="bold">// unique_pointer pImpl will delete its own resources</strong></pre>
<p>Taking a look at the aforementioned member functions requiring modification, we see that it is only the <strong class="source-inline">Person</strong> destructor! Because we are using a unique pointer to implement the association to the nested class implementation, we no longer need to manage the memory<a id="_idIndexMarker1320"/> for this resource ourselves. That’s pretty nice! With these<a id="_idIndexMarker1321"/> minor changes, our pImpl pattern now features a <strong class="source-inline">unique_ptr</strong> to designate the implementation of the class.</p>
<p>Next, let’s examine some of the performance issues relating to using the pImpl pattern.</p>
<h1 id="_idParaDest-309"><a id="_idTextAnchor913"/>Understanding pImpl pattern trade-offs</h1>
<p>Incorporating the pImpl pattern<a id="_idIndexMarker1322"/> into production code has both benefits and disadvantages. Let’s review each so that we can better understand the circumstances that may warrant deploying this pattern. </p>
<p>The negligible performance issues encompass most of the disadvantages. That is, nearly every request made of the target (interface) class will need to be delegated to its nested implementation class. The only requests that can be handled by the outer class will be those not involving any data members; those circumstances will be extraordinarily rare! Another disadvantage includes slightly higher memory requirements of instances to accommodate the added pointer as part of the pattern implementation. These issues will be paramount in embedded software systems and those requiring peak performance, but relatively minor otherwise. </p>
<p>Maintenance will be a little more difficult for classes employing the pImpl pattern, an unfortunate disadvantage. Each target class is now paired with an extra (implementation) class, including a set of forwarding methods to delegate requests to the implementation. </p>
<p>A few implementation difficulties may also arise. For example, if any of the private members (now in the nested implementation class) need to access any of the protected or public methods of the outer (interface) class, we will need to include a backlink from the nested class to the outer class to access that member. Why? The <strong class="source-inline">this</strong> pointer in the inner class will be of the nested object type. Yet the protected and public methods in the outer object will expect a <strong class="source-inline">this</strong> pointer to the outer object – even if those public methods will then redelegate the request to call a private nested class method for help. This backlink will also be required to call public virtual functions of the interface from the scope of the inner class (implementation). Keep in mind, however, that we impact performance with another added pointer per object and with delegation to call each method in the associated object.</p>
<p>There are several advantages <a id="_idIndexMarker1323"/>of utilizing the pImpl pattern, offering important considerations. Of most importance, recompile time during the development and maintenance of code decreases significantly. Additionally, the compiled, binary interface of a class becomes independent of the underlying implementation of the class. Changing the implementation of a class only requires the nested implementation class to be recompiled and linked in. Users of the outer class are unaffected. As a bonus, the pImpl pattern provides a way to hide the underlying private details of a class, which may be useful when distributing class libraries or other proprietary code.</p>
<p>An advantage of including a <strong class="source-inline">unique_ptr</strong> in our pImpl implementation is that we have guaranteed proper destruction of the associated implementation class. We also have the potential to save inadvertent programmer-introduced pointer and memory mishaps!</p>
<p>The use of the pImpl pattern is a trade-off. Careful analysis of each class and of the application at hand will help determine whether the pImpl pattern is appropriate for your design. </p>
<p>We have now seen implementations of the pImpl pattern<a id="_idTextAnchor914"/> initially<a id="_idIndexMarker1324"/> using a raw pointer, and then applying a <strong class="source-inline">unique_ptr</strong>. Let us now briefly <a id="_idTextAnchor915"/>recap what we have learned relating to patterns before moving to the bonus chapter of our book, <a href="B19087_21.xhtml#_idTextAnchor920"><em class="italic">Chapter 21</em></a>, <em class="italic">Making C++ Safer</em>.</p>
<h1 id="_idParaDest-310"><a id="_idTextAnchor916"/>Summary</h1>
<p>In this chapter, we have advanced our objective of becoming more indispensable C++ programmers by furthering our programming skills with another core design pattern. We have explored the pImpl pattern with an initial implementation using native C++ pointers and association and then improved our implementation by using a unique pointer. By examining the implementation, we easily understand how the pImpl pattern reduces compile-time dependencies and can make our code more implementation-dependent.</p>
<p>Making use of core design patterns, such as the pImpl pattern, will help you more easily contribute to reusable, maintainable code that is understood by other programmers familiar with common design patterns. Your software solutions will be based on creative and well-tested design solutions.</p>
<p>We have now completed our final design pattern together, wrapping up a long journey of understanding OOP in C++. You now have a multitude of skills, including a deep understanding of OOP, extended language features, and core design patterns, all of which make you a more valuable programmer. </p>
<p>Though C++ is an intricate language with additional features, supplemental techniques, and additional design patterns to discover, you have more than a solid basis and level of expertise to easily navigate and embrace any additional language features, libraries, and patterns you may wish to acquire. You’ve come a long way; this has been an adventurous journey together! I have enjoyed every minute of our quest and I hope you have as well.</p>
<p>We began by reviewing basic language syntax and understanding the C++ essentials necessary to serve as building blocks for our then-upcoming OOP journey. We then embraced C++ as an OOP language, learning not only essential OO concepts but also how to implement them with either C++ language features, coding techniques, or both. We then extended your skills by adding knowledge of exception handling, friends, operator overloading, templates, STL basics, and testing OO classes and components. We then ventured into sophisticated programming techniques by embracing core design patterns and delving into code by applying each pattern of interest.</p>
<p>Each of these acquired skill segments represents a new tier of C++ knowledge and mastery. Each will help you to create more easily maintainable and robust code. Your future as a well-versed, skilled OO programmer in C++ awaits. Now, let’s move on<a id="_idTextAnchor917"/> to our bonus chapter, and then, let’s get programming!</p>
<h1 id="_idParaDest-311"><a id="_idTextAnchor918"/>Questions</h1>
<ol>
<li>Modify the pImpl pattern example in this chapter, which uses a unique pointer to additionally introduce unique pointers within the implementation of the nested class.</li>
<li>Revise your <strong class="source-inline">Student</strong> class from a previous chapter solution to simply inherit from the <strong class="source-inline">Person</strong> class in this chapter that embraces the pImpl pattern. What difficulties, if any, do you have? Now, modify your <strong class="source-inline">Student</strong> class to additionally utilize the pImpl pattern with a unique pointer. A suggested <strong class="source-inline">Student</strong> class is one that includes an association with a <strong class="source-inline">Course</strong>. Now, what difficulties, if any, do you have?</li>
<li>What other examples can you imagine that might reasonably incorporate the pImpl pattern for relative implementation independence?</li>
</ol>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer074">
<h1 id="_idParaDest-312"><a id="_idTextAnchor919"/>Part 5: Considerations for Safer Programming in C++</h1>
<p>The goal of this part is to understand what can be done as a programmer to make C++ a safer language, which in turn will help make our programs more robust. At this point, we will have learned a lot about C++, from language essentials to implementing OO designs in C++. We will have added additional skills to our repertoire, such as using friends and operator overloading, exception handling, templates, and the STL. We will have even looked in depth at a handful of popular design patterns. We will know that we can do nearly anything in C++, but we will have also seen that having so much power can leave room for cavalier programming and grave errors, which can lead to unwieldy code that is difficult to maintain.</p>
<p>In this section, we will review what we have learned throughout the book with a keen eye toward understanding how we can work to make our code bulletproof. We will work toward a set of core programming guidelines to follow with one goal in mind: to make our programs safe!</p>
<p>We will revisit and expand upon our knowledge of smart pointers (unique, shared, and weak) as well as introduce a complimentary idiom, RAII. We will review what we have seen along the way relating to safety issues with native C++ pointers and sum up our safety concerns with a programming guideline: always prefer smart pointers in newly created C++ code. </p>
<p>We will review modern programming features, such as range-based <strong class="source-inline">for</strong> loops and for-each style loops to understand how these simple constructs can help us avoid common errors. We will revisit <strong class="source-inline">auto</strong> instead of explicit typing to add safety to our code. We will revisit using well-tested STL types to ensure our code is not error-prone with ad hoc containers. We will revisit how the <strong class="source-inline">const</strong> qualifier can add safety to our code in a variety of ways. By reviewing specific language features used throughout the book, we will revisit how each of these features can add safety to our code. We will also consider thread safety and how various topics we have seen throughout the book relate to thread safety. </p>
<p>Finally, we will discuss core programming guidelines, such as preferring initialization over assignment, or using one of <strong class="source-inline">virtual</strong>, <strong class="source-inline">override</strong>, or <strong class="source-inline">final</strong> to specify polymorphic operations and their methods. We will understand the importance of adopting a programming guideline and see the resources available to support programming safely in C++.</p>
<p>This part comprises the following chapter:</p>
<ul>
<li><a href="B19087_21.xhtml#_idTextAnchor920"><em class="italic">Chapter 21</em></a>, <em class="italic">Making C++ Safer</em></li>
</ul>
</div>
<div>
<div id="_idContainer075">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer076">
</div>
</div>
<div class="Content" id="_idContainer077">
</div>
<div>
<div id="_idContainer078">
</div>
</div>
<div class="Basic-Text-Frame" id="_idContainer079">
<p class="hidden">Part 5: Considerations for Safer Programming in C++</p>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer080">
</div>
</div>
</div></body></html>